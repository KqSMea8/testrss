<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot(十四)_springboot使用内置定时任务的使用 - 养码青年</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9769886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9769886.html</guid>
<description>&lt;h3 id=&quot;为什么使用定时&quot;&gt;为什么使用定时？&lt;/h3&gt;
&lt;p&gt;日常工作中，经常会用到定时任务，比如各种统计，并不要求实时性。此时可以通过提前设置定时任务先把数据跑出来，后续处理起来更方便. 本篇文章主要介绍 springboot内置定时任务。&lt;/p&gt;
&lt;h3 id=&quot;实战演示&quot;&gt;实战演示&lt;/h3&gt;
&lt;h4 id=&quot;pom文件&quot;&gt;1、pom文件&lt;/h4&gt;
&lt;p&gt;pom 包里面只需要引入 Spring Boot Starter 包即可，Spring Boot Starter 包中已经内置了定时的方法。我这里方便演示，增加了lombok&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.16.20&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;启动类开启定时&quot;&gt;2、启动类开启定时&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableScheduling
public class ScheduledApplication {

    public static void main(String[] args) {
        SpringApplication.run(ScheduledApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建定时任务实现类&quot;&gt;3、创建定时任务实现类&lt;/h4&gt;
&lt;p&gt;这里并没有直接在类中写cron语句，而是写到了配置文件中。一般实际项目中这样写。&lt;/p&gt;
&lt;h5 id=&quot;scheduledtask-类&quot;&gt;3.1、ScheduledTask 类&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @author: curry
 * @Date: 2018/10/10
 */
@Component
@Slf4j
public class ScheduledTask {
    @Scheduled(cron = &quot;${job.schedule}&quot;)
    private void process1() {
        log.info(&quot;start&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;application.properties&quot;&gt;3.2 application.properties&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;job.schedule = */5 * * * * ? &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;执行结果&quot;&gt;4、执行结果&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;2018-10-10 22:48:55.001  [pool-1-thread-1] demo.ScheduledTask     : start
2018-10-10 22:49:00.001  [pool-1-thread-1] demo.ScheduledTask     : start
2018-10-10 22:49:05.001  [pool-1-thread-1] demo.ScheduledTask     : start
2018-10-10 22:49:10.001  [pool-1-thread-1] demo.ScheduledTask     : start
2018-10-10 22:49:15.001  [pool-1-thread-1] demo.ScheduledTask     : start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;corn-语法说明&quot;&gt;corn 语法说明&lt;/h3&gt;
&lt;h4 id=&quot;cron-每位的含义&quot;&gt;cron 每位的含义&lt;/h4&gt;
&lt;p&gt;cron 一共有 7 位，最后一位是年，Spring Boot 定时方案中只需要设置 6 位即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 第一位，表示秒，取值 0-59；
- 第二位，表示分，取值 0-59；
- 第三位，表示小时，取值 0-23；
- 第四位，日期天/日，取值 1-31；
- 第五位，日期月份，取值 1-12；
- 第六位，星期，取值 1-7，星期一、星期二…；
注：不是第1周、第2周的意思，另外：1表示星期天，2表示星期一。
- 第七位，年份，可以留空，取值 1970-2099。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cron-符号含义&quot;&gt;cron 符号含义&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;（*）星号：可以理解为每的意思，每秒、每分、每天、每月、每年……。
（?）问号：问号只能出现在日期和星期这两个位置，表示这个位置的值不确定，每天 12 点执行，所以第六位星期的位置是不需要关注的，就是不确定的值。同时，日期和星期是两个相互排斥的元素，通过问号来表明不指定值。
（-）减号：表达一个范围，如在小时字段中使用“10-12”，则表示从 10~12 点，即 10、11、12。
（,）逗号：表达一个列表值，如在星期字段中使用“1、2、4”，则表示星期一、星期二、星期四。
（/）斜杠：如 x/y，x 是开始值，y 是步长，比如在第一位（秒） 0/15 就是，从 0 秒开始，每 15 秒，最后就是 0、15、30、45、60，另 */y，等同于 0/y。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;举个栗子&quot;&gt;举个栗子&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;0 0 1 * * ?     每天 1 点执行。
0 5 1 * * ?     每天 1 点 5 分执行。
0-5 * * * * ?   每分钟的0/1/2/3/4/5 秒执行
0 5/10 1 * * ?  每天 1 点的 5 分、15 分、25 分、35 分、45 分、55 分这几个时间点执行。
0 5 1 ? * 1     每周星期天，1点5分 执行，注：1 表示星期天。  
0 10 3 ? * 1#3  每个月的第 三 个星期，星期天执行，# 号只能出现在星期的位置。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;fixedrate-说明&quot;&gt;fixedRate 说明&lt;/h3&gt;
&lt;p&gt;这个日常工作中很少用到，这里不做详细介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Scheduled(fixedRate = 6000) ：上一次开始执行时间点之后 6 秒再执行。
@Scheduled(fixedDelay = 6000) ：上一次执行完毕时间点之后 6 秒再执行。
@Scheduled(initialDelay=1000, fixedRate=6000) ：第一次延迟 1 秒后执行，之后按 fixedRate 的规则每 6 秒执行一次。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;其实，使用内置的定时任务还是很方便的，但是，如果复杂的情况一般使用Quartz 。大家工作中一般都会见过这个东西。下篇文章一块学习一下这个东西。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 15:12:00 +0000</pubDate>
<dc:creator>养码青年</dc:creator>
<og:description>为什么使用定时？ 日常工作中，经常会用到定时任务，比如各种统计，并不要求实时性。此时可以通过提前设置定时任务先把数据跑出来，后续处理起来更方便. 本篇文章主要介绍 springboot内置定时任务。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9769886.html</dc:identifier>
</item>
<item>
<title>深入研究.NET Core的本地化机制 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9764243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9764243.html</guid>
<description>&lt;p&gt;ASP.NET Core中提供了一些本地化服务和中间件，可将网站本地化为不同的语言文化。&lt;/p&gt;
&lt;p&gt;ASP.NET Core中我们可以使用&lt;strong&gt;Microsoft.AspNetCore.Localization&lt;/strong&gt;库来实现本地化。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在.NET Core 2.0以上版本, &lt;strong&gt;Microsoft.AspNetCore.Localization&lt;/strong&gt;已经包含在了&lt;strong&gt;Microsoft.AspNetCore.All&lt;/strong&gt;中，所以我们并不需要手动引入其他的类库。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了测试ASP.NET Core的本地化，我们首先在Visual Studio 2017中创建一个MVC项目LocalizationSample。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224323685-2094522523.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ASP.NET Core中，如果希望启动本地化，首先需要在&lt;code&gt;Startup&lt;/code&gt;类的&lt;code&gt;ConfigureServices&lt;/code&gt;方法中使用&lt;code&gt;services.AddLocalization&lt;/code&gt;添加本地化服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddLocalization(o =&amp;gt;
    {
        o.ResourcesPath = &quot;Resources&quot;;
    });
    
    services.AddMvc();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法中，我们指定了文件夹Resources作为存放翻译文件的目录。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注： 如果不指定存放翻译文件的目录, ASP.NET Core会默认从网站根目录下读取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们需要在&lt;code&gt;Configure&lt;/code&gt;方法中添加本地化中间件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseStaticFiles();

    IList&amp;lt;CultureInfo&amp;gt; supportedCultures = new List&amp;lt;CultureInfo&amp;gt;
    {
        new CultureInfo(&quot;en-US&quot;),
        new CultureInfo(&quot;zh-CN&quot;),
    };
    app.UseRequestLocalization(new RequestLocalizationOptions
    {
        DefaultRequestCulture = new RequestCulture(&quot;en-US&quot;),
        SupportedCultures = supportedCultures,
        SupportedUICultures = supportedCultures
    });

    app.UseMvc(routes =&amp;gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;app.UseRequestLocalization&lt;/code&gt;必须放置&lt;code&gt;app.UseMvc&lt;/code&gt;之前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DefaultRequestCulture&lt;/code&gt;参数指定了默认的语言文化，即用户不指定任何文化时的默认语言文化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SupportedCultures&lt;/code&gt;和&lt;code&gt;SupportedUICultures&lt;/code&gt;是指定当前应用支持的所有语言文化&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注: &lt;code&gt;SupportedCultures&lt;/code&gt;指定的是数字和日期格式, &lt;code&gt;SupportedUICultures&lt;/code&gt;指定的翻译文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们尝试添加一个资源文件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先我们创建一个Resources文件夹，这就是我们在前面&lt;code&gt;Startup&lt;/code&gt;类中配置的目录名。&lt;/li&gt;
&lt;li&gt;然后我们在Resource文件夹中添加一个资源文件，并命名为Controllers.HomeController.zh-CN.resx。&lt;/li&gt;
&lt;li&gt;在这个资源文件中，添加一个字段Hello, 并设置其值为“你好”。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224333898-126807198.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在我们打开默认生成的&lt;code&gt;HomeController&lt;/code&gt;, 清空里面所有的action, 并添加一个新的action, 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HomeController : Controller
{
    public HomeController()
    {
       
    }

    public IActionResult Hello()
    {
        return Content(&quot;Hello&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目之后访问/Home/Hello, 结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224340550-223008827.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们修改HomeController的代码, 来引入本地化字符串访问器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HomeController : Controller
{
    private readonly IStringLocalizer&amp;lt;HomeController&amp;gt; _localizer;

    public HomeController(IStringLocalizer&amp;lt;HomeController&amp;gt; localizer)
    {
        _localizer = localizer;
    }

    public IActionResult Hello()
    {
        return Content(_localizer[&quot;Hello&quot;]);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码解释&quot;&gt;代码解释&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IStringLocalizer&lt;/code&gt;是一个本地化字符串访问器的泛型接口，这里我们通过依赖注入的方式在&lt;code&gt;HomeController&lt;/code&gt;的构造函数中将其注入&lt;/li&gt;
&lt;li&gt;我们可以通过IStringLocalizer的属性访问器获取到对应字段在不同语言下的文本。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;现在我们启动程序, 重新访问/Home/Hello, 结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224347658-1718278968.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现结果没有变化，这是因为默认我们设置的语言文化是en-US, 但是我们之前没有添加en-US的资源文件，所以程序就直接将访问的字段名输出了。&lt;/p&gt;
&lt;p&gt;现在我们修改URL, 访问/Home/Hello?ui-culture=zh-CN, 结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224354626-1234754283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们期望的“你好”被正确输出了，这说明ASP.NET Core默认支持在Url中以culture参数的形式设置当前网站使用的语言文化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么我们之前添加了一个名为Controllers.HomeController.zh-CN.resx的资源文件，本地化字符串访问器&lt;code&gt;IStringLocalizer&lt;/code&gt;就能定位到这个文件并读取其中的字段属性呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是由ASP.NET Core资源文件的命名约定决定的。&lt;/p&gt;
&lt;p&gt;ASP.NET Core资源文件的名称由2部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;去掉程序集名称的完整类名&lt;/li&gt;
&lt;li&gt;语言文化名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以前面的例子为例：&lt;br/&gt;我们创建了一个本地化字符串访问器接口，它的泛型类型是&lt;code&gt;HomeController&lt;/code&gt;, 其完整类名是&lt;code&gt;LocalizationSample.Controllers.HomeController&lt;/code&gt;, 当前程序集的名称是&lt;code&gt;LocalizationSample&lt;/code&gt;, 所以去掉程序集名称之后，剩余部分是&lt;code&gt;Controllers.HomeController&lt;/code&gt;。当我们设置culture参数是zh-CN时, ASP.NET Core查找的资源文件名是Controllers.HomeController.zh-CN.resx, 这正是我们前面添加的中文语言文化资源文件名。&lt;/p&gt;
&lt;p&gt;如果你不喜欢这种方式，ASP.NET Core还提供了另外一种资源文件的组织方式&lt;/p&gt;
&lt;p&gt;你可以Resources目录下创建以下目录结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Resources
&lt;ul&gt;&lt;li&gt;Controllers
&lt;ul&gt;&lt;li&gt;HomeController.zh-CN.resx&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本地化字符串访问器也能自动定位到这个文件。&lt;/p&gt;

&lt;p&gt;ASP.NET Core的本地化中间件默认支持3种语言文化提供器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URL中的查询字符串&lt;/li&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;请求头&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;url中的查询字符串&quot;&gt;URL中的查询字符串&lt;/h2&gt;
&lt;p&gt;ASP.NET Core会从URL中的culture参数中获取当前应用使用的语言文化，这就是前面例子中，“你好”能正确输出的原因&lt;/p&gt;
&lt;p&gt;除了指定ui-culture参数，你还可以使用culture参数指定当前格式化时间，数字等所使用的语言文化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;?culture=zh-CN&amp;amp;ui-culture=zh-CN

?culture=zh-CN

?ui-culture=zh-CN&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tips: 当只指定culture或ui-culture参数时，ASP.NET Core会自动将culture和ui-culture设置成一样的。即?culture=zh-CN等同于?culture=zh-CN&amp;amp;ui-culture=zh-CN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;ASP.NET Core中还支持使用Cookie的方式设置当前应用使用的语言文化。默认使用的Cookie名称是.AspNetCore.Culture。&lt;/p&gt;
&lt;p&gt;.AspNetCore.Culture的值格式如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c=zh-CN|uic=zh-CN

c=zh-CN

uic=zh-CN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中c表示culture, uic表示ui-culture。&lt;/p&gt;
&lt;p&gt;下面我们使用Chrome的开发者工具, 为当前网页添加语言文化Cookie&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224406134-530666650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们访问/Home/Hello, &quot;你好&quot;也被正确的输出了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224413378-1328995945.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这说明ASP.NET Core从Cookie中读取到了语言文化配置&lt;/p&gt;
&lt;h2 id=&quot;请求头&quot;&gt;请求头&lt;/h2&gt;
&lt;p&gt;除了URL查询字符串和Cookie, ASP.NET Core还支持在请求头中指定语言文化。请求头中语言文化字段名称是 Accept-Language。&lt;/p&gt;
&lt;p&gt;Accept-Language的文档，参见&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用Postman来测试一下，我们设置Accept-Language为zh-CN, zh;q=0.9, 结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224421218-1345176118.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;除了Controller, 我们更多的是在View中使用本地化。&lt;br/&gt;如果希望在View中使用本地化，首先需要在&lt;code&gt;Startup&lt;/code&gt;类的&lt;code&gt;ConfigureServices&lt;/code&gt;方法中启用View本地化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc()
        .AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;LanguageViewLocationExpanderFormat&lt;/code&gt;支持2种方式,这个和前面Controller的本地化文件名称约定类似&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Suffix, 例/Resources/Home/Hello.zh-CN.resx&lt;/li&gt;
&lt;li&gt;Path, 例/Resources/Home/zh-CN/Hello.resx&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们修改HomeController的代码，&lt;code&gt;Hello&lt;/code&gt;方法将返回一个View&lt;/p&gt;
&lt;p&gt;HomeController&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult Hello()
{
    //return Content(_localizer[&quot;Hello&quot;]);
    return View();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hello.cshtml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@{
    ViewData[&quot;Title&quot;] = &quot;Hello&quot;;
}

&amp;lt;h2&amp;gt;Good Bye&amp;lt;/h2&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们创建如下图的目录结构, 并创建资源文件Hello.zh-CN.resx, 并添加GoodBye字段,其值为&quot;再见&quot;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224431474-421681496.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224435482-1860497761.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用viewlocalizer&quot;&gt;使用ViewLocalizer&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ViewLocalizer&lt;/code&gt;类可以帮助我们在Razor视图中使用本地化文本。现在我们来修改Hello.cshtml, 在文件添加本地化引用，并注入一个ViewLocalizer对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@using Microsoft.AspNetCore.Mvc.Localization

@inject IViewLocalizer Localizer
@{
    ViewData[&quot;Title&quot;] = &quot;Hello&quot;;
}

&amp;lt;h2&amp;gt;@Localizer[&quot;GoodBye&quot;]&amp;lt;/h2&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用ViewLocalizer读取了本地化文本，它的用法和&lt;code&gt;IStringLocalier&lt;/code&gt;一样，都是通过属性访问器访问对应字段的本地化文本。&lt;/p&gt;
&lt;h2 id=&quot;最终效果-1&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;现在我们运行程序并访问/Home/Hello, 结果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224441178-1571653967.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们继续访问/Home/Hello?ui-culture=zh-CN, 结果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181010224445246-1360950409.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地化字符串读取成功&lt;/p&gt;
&lt;p&gt;本篇源代码 &lt;a href=&quot;https://github.com/lamondlu/aspnetcore_localizationsample&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/aspnetcore_localizationsample&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 15:12:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>ASP.NET Core中提供了一些本地化服务和中间件，可将网站本地化为不同的语言文化。 ASP.NET Core中我们可以使用 Microsoft.AspNetCore.Localization 库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9764243.html</dc:identifier>
</item>
<item>
<title>分布式Dubbo快速入门 - Miya。</title>
<link>http://www.cnblogs.com/SimpleWu/p/9769797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9769797.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;h4 id=&quot;editorsimplewu&quot;&gt;Editor：SimpleWu&lt;/h4&gt;
&lt;p&gt;Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224439377-1704936075.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;单一应用架构&quot;&gt;单一应用架构&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;垂直应用架构&quot;&gt;垂直应用架构&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;分布式服务架构&quot;&gt;分布式服务架构&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;流动计算架构&quot;&gt;流动计算架构&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。&lt;/p&gt;
&lt;h2 id=&quot;zookeeper安装&quot;&gt;zookeeper安装&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;官方网站&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;http://zookeeper.apache.org/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;http://mirrors.hust.edu.cn/apache/zookeeper/&lt;/p&gt;
&lt;p&gt;下载好我们解压出来直接启动bin目录下zkServer.bat是不行的，我们暂时将zoo_sample.cfg改成zoo.cfg然后就可以正常启动了，启动后我们可以看到默认的端口&lt;strong&gt;2181&lt;/strong&gt;到时候我们的Dubbo就调用这个端口&lt;/p&gt;
&lt;h2 id=&quot;发布dubbo服务&quot;&gt;发布Dubbo服务&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo下载地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;https://github.com/apache/incubator-dubbo&lt;/p&gt;
&lt;p&gt;下载后我们参照里面的Demo先来搞一个provider。（dubbo-provider）&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;打开eclipse新建一个maven工程先配置个阿里云镜像否则本地没有超级慢&quot;&gt;1.打开eclipse新建一个maven工程（先配置个阿里云镜像，否则本地没有超级慢）&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--  配置阿里云  --&amp;gt;
&amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;nexus-aliyun&amp;lt;/id&amp;gt;
    &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;name&amp;gt;Nexus aliyun&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public&amp;lt;/url&amp;gt;
 &amp;lt;/mirror&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;pom.xml中添加依赖&quot;&gt;2.POM.XML中添加依赖&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.6.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.10&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.0.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.46&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.0.35.Final&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3.添加服务接口，实现服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.miya.dubbo.service;
/**
 * 服务提供者接口
 * @author SimpleWu
 *
 */
public interface MyProviderService {
    public String sayHello(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.miya.dubbo.service.impl;
import com.miya.dubbo.service.MyProviderService;
/**
 * 服务提供者接口实现类
 * @author SimpleWu
 *
 */
public class MyProviderServiceImpl implements MyProviderService {

    @Override
    public String sayHello(String name) {
        return &quot;服务1 ： MyProviderServiceImpl 。。 sayHello &quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.在resources资源文件夹中添加dubbo-provider.xml&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&amp;gt;
    &amp;lt;!-- 提供方应用名称，用于计算依赖关系 --&amp;gt;
    &amp;lt;dubbo:application name=&quot;demo-provider&quot; /&amp;gt;
    
    &amp;lt;!-- 使用zookeeper注册中心暴露服务地址 --&amp;gt;
    &amp;lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&amp;gt;
    
    &amp;lt;!-- 使用dubbo协议，在20880端口暴露服务 --&amp;gt;
    &amp;lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&amp;gt;
    
    &amp;lt;!-- service实现类作为本地的一个bean --&amp;gt;
    &amp;lt;bean id=&quot;myProviderService&quot; class=&quot;com.miya.dubbo.service.impl.MyProviderServiceImpl&quot;/&amp;gt;
    
    &amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt;
    &amp;lt;dubbo:service interface=&quot;com.miya.dubbo.service.MyProviderService&quot; ref=&quot;myProviderService&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;创建测试类发布服务&quot;&gt;5.创建测试类发布服务&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;发布服务之前需要先启动zookeeper，启动后图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224506121-1668573951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建测试类发布服务&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args){
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                new String[] { &quot;dubbo-provider.xml&quot; });
        context.start();
        System.out.println(&quot;服务提供者向zookeeper中心注册服务成功 暴露的端口为：20880&quot;);
        try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发布后图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224520674-1648724876.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果看到我们的服务接口后就说明服务发布成功！&lt;/p&gt;
&lt;h2 id=&quot;dubbo-admin管理&quot;&gt;Dubbo Admin管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;首先在dubbo目录里面找到dubbo-admin将他打成war包不能带项目路径&quot;&gt;1.首先在Dubbo目录里面找到dubbo-admin将他打成WAR包不能带项目路径&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224542671-1417970124.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要将WAR包发布到Tomcat里面最好独立运行，我们将Tomcat wepapps下的ROOT全部删掉将WAR包解压到里面，然后启动Tomcat（必须先开启我们的zookeeper），我们直接访问localhost:8080会弹出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224554258-611944141.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;默认的账号root密码root登陆&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到这个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224603214-644615085.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在这里管理我们的服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224613612-402317683.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前我们点击服务是没有查询到服务的，我们将我们之前的那个服务运行发布上去可以看到&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224623385-790400336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以点击服务名进去管理我们的服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224635779-298071446.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里可以对应的去操作我们的服务，注意我们的服务就是在20880端口暴露的，这里我们的服务也是20880说明我们的服务成功发布。&lt;/p&gt;
&lt;h2 id=&quot;消费dubbo服务&quot;&gt;消费Dubbo服务&lt;/h2&gt;
&lt;p&gt;创建一个maven项目(dubbo-consumer)开启消费者：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;pom.xml导入依赖&quot;&gt;1.POM.XML导入依赖&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.6.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.10&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.46&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.0.35.Final&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;创建消费者接口&quot;&gt;2.创建消费者接口&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.miya.dubbo.service;
/**
 * 服务提供者接口
 * @author SimpleWu
 *
 */
public interface MyProviderService {
    public String sayHello(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;在resources下创建消费者配置文件dubbo-consumer.xml&quot;&gt;3.在resources下创建消费者配置文件(dubbo-consumer.xml)&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&amp;gt;

    &amp;lt;!-- 消费方应用名称，用于计算依赖关系，不是匹配条件，不要与提供方名称一样  --&amp;gt;
    &amp;lt;dubbo:application name=&quot;demo-consumer&quot;/&amp;gt;

    &amp;lt;!-- 使用zookeeper注册中心暴露服务地址 --&amp;gt;
    &amp;lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&amp;gt;

    &amp;lt;!-- 生成远程服务代理，可以与本地bean一样使用  check属性，启动时候是否检查 一般设置成false 启动时候不检查 --&amp;gt;
    &amp;lt;dubbo:reference id=&quot;myProviderService&quot; check=&quot;false&quot; interface=&quot;com.miya.dubbo.service.MyProviderService&quot;/&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;创建消费者测试类&quot;&gt;4.创建消费者测试类&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.miya.dubbo.test;

import java.io.IOException;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.miya.dubbo.service.MyProviderService;

public class ConsumerTest {
    public static void main(String[] args) {
        //读取消费者配置文件
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;dubbo-consumer.xml&quot;});
        context.start();
        //获取消费实例
        MyProviderService demoProviderService=(MyProviderService) context.getBean(&quot;myProviderService&quot;);
        String result=demoProviderService.sayHello(&quot;Miya&quot;);
        System.out.println(&quot;远程调用的结果：&quot;+result);
        try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
        context.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;开始消费&quot;&gt;5.开始消费&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;打开zookeeper--&amp;gt;Tomcat发布Dubbo Admin管理中心--&amp;gt;启动消费者测试程序&lt;/p&gt;
&lt;p&gt;我们可以看到消费者已经有了，图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181010224652203-468682488.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;抽取与依赖版本管理&quot;&gt;抽取与依赖版本管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;抽取&quot;&gt;抽取&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前面两个项目中我们会发现两个项目中有两个相同的接口（MyProviderServiceImpl.java），这样是不好的，我们现在参照官方demo来创建一个maven工程（dubbo-api）&lt;/p&gt;
&lt;p&gt;我们将接口我们将这个接口放到api这个项目中去，然后将dubbo-consumer,dubbo-provider这两个工程中的接口删掉，这个时候我们这两个项目会报错因为找不到这个接口，我们可以将这两个项目添加依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.miya&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dubbo-api&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只要依赖dubbo-api就可以获取到了吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;依赖版本统一管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在dubbo-consumer,dubbo-provider这两个工程中会发现POM.xml中的版本号，如果我们需要修改版本要一个一个去修改有两个工程不是要改两次？那夸张以点，一万不是得改半条命？&lt;/p&gt;
&lt;p&gt;这个时候我们还是创建一个maven工程（dubbo-parent），这个工程Packaging我们选择POM，这个项目负责版本统一。首先我们抽取相同的依赖，然后给他们定义统一的版本管理方式。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.miya&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dubbo-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
    &amp;lt;!-- 依赖版本管理 --&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;dubbo-api.version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/dubbo-api.version&amp;gt;
        &amp;lt;dubbo.version&amp;gt;2.6.0&amp;lt;/dubbo.version&amp;gt;
        &amp;lt;zkclient.version&amp;gt;0.10&amp;lt;/zkclient.version&amp;gt;
        &amp;lt;curator-framework.version&amp;gt;4.0.1&amp;lt;/curator-framework.version&amp;gt;
        &amp;lt;fastjson.version&amp;gt;1.2.46&amp;lt;/fastjson.version&amp;gt;
        &amp;lt;log4j.version&amp;gt;1.2.17&amp;lt;/log4j.version&amp;gt;
        &amp;lt;slf4j-api.version&amp;gt;1.7.25&amp;lt;/slf4j-api.version&amp;gt;
        &amp;lt;commons-lang3.version&amp;gt;3.4&amp;lt;/commons-lang3.version&amp;gt;
        &amp;lt;netty-all.version&amp;gt;4.0.35.Final&amp;lt;/netty-all.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!--依赖管理 --&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.miya&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo-api&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${dubbo-api.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${zkclient.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${curator-framework.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${fastjson.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${slf4j-api.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${commons-lang3.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${netty-all.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 10 Oct 2018 14:52:00 +0000</pubDate>
<dc:creator>Miya。</dc:creator>
<og:description>[TOC] Dubbo入门 Editor：SimpleWu Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9769797.html</dc:identifier>
</item>
<item>
<title>Java基础教程(5)--变量 - maconn</title>
<link>http://www.cnblogs.com/maconn/p/9763751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maconn/p/9763751.html</guid>
<description>&lt;h2 id=&quot;一.变量&quot;&gt;一.变量&lt;/h2&gt;
&lt;h3 id=&quot;变量的定义&quot;&gt;1.变量的定义&lt;/h3&gt;
&lt;p&gt;  正如上一篇教程&lt;a href=&quot;https://www.cnblogs.com/maconn/p/9757729.html&quot;&gt;《Java基础教程(4)--面向对象概念》&lt;/a&gt;中介绍的那样，对象将它的状态存在域中。但是你可能仍然有一些疑问，例如：命名一个域的规则和惯例是什么？除了int还有其他的类型吗？域在声明的时候必须初始化吗？如果域没有显示地初始化会被赋予一个默认值吗？在本文中我们将一一讨论这些问题，但是在开始之前，需要对几个概念进行介绍。在Java中，“域”和“变量”术语都会使用，对于初学者来说这可能有一点困惑，因为它们看起来好像说的是同一个东西。&lt;br/&gt;  Java语言定义了以下几种类型的变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例变量（非静态域）：从技术层面来说，对象将它们各自的状态存在“非静态域”中，也就是没有使用static关键字修饰的域。非静态域也被称为实例变量，因为对于类的每个实例（换句话说，就是每个对象）来说，它们的值都是独立的。例如，每个自行车的当前速度相对于其他自行车来说都是独立的。&lt;/li&gt;
&lt;li&gt;类变量（静态域）：类变量是使用static关键字修饰的域。这告诉编译器无论这个类有多少个实例，这个变量只有一个副本。对于一种特定的自行车来说，它的齿轮数可以被标记为static，因为这个值适用于它的每一个实例。代码static int numGears = 6;将会创建一个静态域。此外，可以使用关键字final来修饰这个域来保证它的值不会改变。&lt;/li&gt;
&lt;li&gt;局部变量：类似于对象在域中存储其状态，方法通常会将其临时状态存储在局部变量中。声明局部变量的语法与声明域类似（例如，int count = 0;）。没有特殊的关键字将变量标记为局部变量，这完全取决于声明变量的位置——它位于方法的两个大括号之间。因此，局部变量只对声明它们的方法可见，对于类的其他部分来说它们是不可见的。&lt;/li&gt;
&lt;li&gt;参数：你已经在HelloWorld的main方法和Bicycle类中看到过参数的应用。回想一下main方法的签名——public static void main(String[] args)。这里，args变量是方法的参数。需要记住的是参数属于“变量”而不是“域”。这也适用于其他接受参数的结构（例如构造函数和异常处理），我们将陆续在后面的教程中见到它们。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  在理解了这几个概念后，相信你对变量和域的关系有了进一步的认识。变量分为实例变量、类变量、局部变量和参数，而只有实例变量和类变量属于域的概念。你也可能偶尔也会看到“成员”一词，类的域，方法和嵌套类型统称为其成员。&lt;/p&gt;
&lt;h3 id=&quot;命名&quot;&gt;2.命名&lt;/h3&gt;
&lt;p&gt;  变量名是标识符的一种，它满足标识符的规则。标识符用来给程序中需要自定义名称的某个实体命名，例如变量、方法、类、参数等。所有的标识符都需要满足以下的规则或惯例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标识符必须是由字母、数字、下划线（_）、美元符号（$）等Java允许作为标识符中一部分的字符组成。可以使用Character.isJavaIdentifierPart()来检测一个字符是否被允许作为Java标识符的一部分。&lt;/li&gt;
&lt;li&gt;标识符不能以数字或其他不允许作为出现在标识符起始位置的字符开头。可以使用Character.isJavaIdentifierStart()来检测一个字符是否被允许作为Java标识符的第一个字符。&lt;/li&gt;
&lt;li&gt;标识符不能是关键字、null、true或false。&lt;/li&gt;
&lt;li&gt;标识符不限制长度。&lt;/li&gt;
&lt;li&gt;标识符应该尽可能地表达出它的作用或意义以提高程序的可读性。建议使用驼峰法（第一个单词首字母小写，其余单词首字母大写）来为设计标识符。如果是常量（使用final修饰的变量），那么规则稍有变化，将每个字母大写并用下划线（_）分隔每个单词。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  上面提到了关键字。关键字是编程语言中事先定义的，有特别意义的单词。下面是Java中的关键字：&lt;br/&gt;&lt;img src=&quot;http://maconn.oss-cn-beijing.aliyuncs.com/18-10-10/91059650.jpg&quot;/&gt;&lt;br/&gt;  其中，const和goto关键字虽然已经不再使用，但是它们还是被保留了下来。&lt;strong&gt;true、false和null虽然被很多人误认为是关键字，但实际上它们只是字面量而已&lt;/strong&gt;。&lt;br/&gt;  &lt;/p&gt;
&lt;h2 id=&quot;二.基本数据类型&quot;&gt;二.基本数据类型&lt;/h2&gt;
&lt;h3 id=&quot;八种基本数据类型&quot;&gt;1.八种基本数据类型&lt;/h3&gt;
&lt;p&gt;  Java是一门静态语言，这意味着所有的变量在使用前必须先进行声明。考虑以下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int gear = 6;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  上面的代码声明了一个名为gear的变量，它是整数类型，并且有一个初始值1。变量的类型决定了它所能存储的数据的类型。除int之外，Java编程语言还支持其他七种基本数据类型。Java中的八种原始数据类型是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;byte：byte数据类型是8位有符号整数。它的最小值为-128（-2&lt;sup&gt;7&lt;/sup&gt;），最大值为127(2&lt;sup&gt;7&lt;/sup&gt;-1)。&lt;/li&gt;
&lt;li&gt;short：short数据类型是16位有符号整数。它的最小值为-32768（-2&lt;sup&gt;15&lt;/sup&gt;），最大值为32767（2&lt;sup&gt;15&lt;/sup&gt;-1）。&lt;/li&gt;
&lt;li&gt;int：int数据类型是32位有符号整数。它的最小值为-2&lt;sup&gt;31&lt;/sup&gt;，最大值为2&lt;sup&gt;31&lt;/sup&gt;-1。&lt;/li&gt;
&lt;li&gt;long：long数据类型是64位有符号整数。它的最小值为-2&lt;sup&gt;63&lt;/sup&gt;，最大值为2&lt;sup&gt;63&lt;/sup&gt;-1。&lt;/li&gt;
&lt;li&gt;float：float数据类型是单精度32位IEEE754浮点数（如果对浮点数的概念不了解，可以简单地将它理解为小数）。它的有效位数为6~7位，不要使用它去存储对精度要求较高的数据。&lt;/li&gt;
&lt;li&gt;double：double数据类型是双精度64位IEEE754浮点数。它的有效位数为15位。在保存浮点数时，绝大部分情况下都应该使用double类型。&lt;/li&gt;
&lt;li&gt;boolean：boolean数据类型只有两个可能的值：true和false。它一般用来表示条件的真或假。在Java中，boolean数据类型不能与其他数据类型进行相互转换。&lt;/li&gt;
&lt;li&gt;char：char数据类型是单个16位Unicode字符。它的最小值为'\u0000'，最大值为'\uffff'。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;char类型扩展&quot;&gt;char类型扩展&lt;/h4&gt;
&lt;p&gt;  要想弄清楚char类型，就必须了解Unicode编码机制。Unicode打破了传统字符编码机制的限制。在Unicode出现之前，已经有许多不同的标准：美国的ASCII、西欧语言中的ISO8859-1、俄罗斯的KOI-8、我国的GB2312等。这样就产生了下面两个问题：一是对于任意给定的编码值，在不同的编码方案下有可能对应不同的字母；二是采用大字符集的语言其编码长度可能不同。例如，有些常用的字符采用单字节编码，而另一些字符则需要两个或更多字节。&lt;br/&gt;  设计Unicode编码的目的就是要解决这些问题。在20世纪80年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来扩展。在1991年发布了Unicode 1.0，当时仅占用65536个代码值中不到一半的部分。在设计Java时决定采用16位的字符集，这样会比使用8位字符集的程序设计语言有很大的改进。&lt;br/&gt;  十分遗憾，经过一段时间，不可避免的事情发生了。由于增加了大量的汉语、日语和韩语中的文字，Unicode字符超过了65536个，16位的char类型已经不能满足描述所有Unicode字符的需要了。&lt;br/&gt;  从JavaSE 5.0开始，码点（code point）是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，码点采用十六进制书写，并加上前缀U+，例如U+0041就是拉丁字母A的码点。Unicode的码点可以分成17个平面。第一个代码级别称为基本多语言平面，码点从U+0000到U+FFFF；其余的16个平面码点从U+10000到U+10FFFF，其中包括一些辅助字符（supplementary character）。&lt;br/&gt;  下面来介绍UTF-16。UTF-16是Unicode码的一种编码格式。也就是说，Unicode决定了每个字符所对应的编码的值，而UTF-16是Unicode编码的一种书写格式，与其类似的还有UTF-8和UTF-32。虽然这些格式的表现形式不尽相同，但他们表示的编码是一致的，那就是Unicode编码。UTF-16采用不同长度的编码表示所有Unicode码点。在Unicode中，特定长度的比特序列称为代码单元。例如，UTF-8的一个代码单元的长度为8。UTF-16中16位表示一个代码单元。UTF-16编码的规则如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;U+0000到U+D7FF以及U+E000到U+FFFF（基本多语言平面）&lt;br/&gt;这个区间称为基本多语言平面，包含了最常见的字符。每个字符对应的码点使用一个代码单元就可以表示。&lt;/li&gt;
&lt;li&gt;U+D800到U+DFFF（代理区）&lt;br/&gt;因为除基本多语言平面外，其他16个平面的码点无法用2个字节表示，所以Unicode标准规定，基本多语言平面内的U+D800到U+DFFF的码点不对应于任何字符，称为代理区。因此，UTF-16利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。&lt;/li&gt;
&lt;li&gt;U+10000到U+10FFFF（辅助平面）&lt;br/&gt;辅助平面中的码点都大于U+FFFF，无法用16位来表示，因此采用一对连续的代码单元来进行编码。具体步骤如下：&lt;br/&gt;  a.码点减去0x10000，得到的结果范围在0x00000到0xFFFFF，使用二进制表示为yyyy yyyy yyxx xxxx xxxx；&lt;br/&gt;  b.高10位的值（范围为0x000到0x3FF），加上0xD800，得到的结果范围在0xD800到0xDBFF，称为高位代理，作为第一个代码单元；&lt;br/&gt;  c.低10位的值（范围也是0x000到0x3FF），加上0xDC00，得到的结果范围在0xDC00到0xDFFF，称为地位代理，作为第二个代码单元；&lt;br/&gt;  d.最终的UTF-16编码用二进制表示就是：1101 10yy yyyy yyyy 1101 11xx xxxx xxxx。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  在Java中，char类型描述了UTF-16编码中的一个代码单元。建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。&lt;/p&gt;
&lt;h3 id=&quot;默认值&quot;&gt;2.默认值&lt;/h3&gt;
&lt;p&gt;  在声明一个域时，如果不对它赋值，编译器将赋予它一个默认值。下面是这8种基本数据类型的默认值：&lt;br/&gt;&lt;img src=&quot;http://maconn.oss-cn-beijing.aliyuncs.com/18-10-10/89192501.jpg&quot;/&gt;&lt;br/&gt;  局部变量则略有不同，编译器永远不会为未初始化的局部变量分配默认值。如果没有初始化局部变量，请保证在使用它之前为其赋值。访问未初始化的局部变量将导致编译时错误。&lt;/p&gt;
&lt;h3 id=&quot;字面量&quot;&gt;3.字面量&lt;/h3&gt;
&lt;p&gt;  你可能已经注意到在初始化基本数据类型的变量时不使用new关键字。基本数据类型是语言中内置的特殊数据类型，它们不是从类创建的对象。字面量（literal）是用于表达源代码中一个固定值的表示方法。如下所示，可以将字面量分配给基本数据类型的变量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;boolean result = true;
char capitalC = 'C';
byte b = 100;
short s = 10000;
int i = 100000;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;整型字面量&quot;&gt;(1)整型字面量&lt;/h4&gt;
&lt;p&gt;  整型字面量默认为int类型。可以在整数后面加上后缀L或l来表示long类型字面量。可以使用前缀0x来表示十六进制，0来表示八进制，0b来表示二进制：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// The number 26, in decimal
int decVal = 26;
// The number 26, in hexadecimal
int hexVal = 0x1a;
// The number 26, in octal
int octVal = 032;
// The number 26, in binary
int binVal = 0b11010;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;浮点型字面量&quot;&gt;(2)浮点型字面量&lt;/h4&gt;
&lt;p&gt;  浮点型字面量默认为double类型（也可以加上D或d，不过一般省略）。可以在浮点数后面加上后缀F或f来表示float类型字面量。&lt;br/&gt;  可以使用科学计数法来表示浮点数字面量。例如，1.2345*10&lt;sup&gt;4&lt;/sup&gt;可以表示为1.2345E4，1.2345*10&lt;sup&gt;-4&lt;/sup&gt;可以表示为1.2345E-4。E后面的数字表示10的指数，也可以使用小写字母e。也可以使用十六进制表示浮点数。例如，3.875=(11.111)&lt;sub&gt;2&lt;/sub&gt;=(3.e)&lt;sub&gt;16&lt;/sub&gt;=(3e)&lt;sub&gt;16&lt;/sub&gt;*2&lt;sup&gt;-4&lt;/sup&gt;，那么3.875可以表示成0x3.ep0或0x3ep-4（因为e和十六进制的15重复，所以这里使用p表示指数）。注意，尾数采用十六进制，指数采用十进制。指数的基数是2，而不是10。&lt;/p&gt;
&lt;h4 id=&quot;字符型字面量&quot;&gt;(3)字符型字面量&lt;/h4&gt;
&lt;p&gt;  char类型的字面量值要用单引号括起来。例如，'B'是编码值为66所对应的字符常量。它与&quot;B&quot;不同，&quot;B&quot;是一个包含字符B的字符串。char类型的值可以表示为十六进制值，但需要加上前缀\u，其范围从\u0000~\uFFFF。例如，\u03C0表示圆周率符号π。&lt;br/&gt;  除了转义序列\u外，还有一些用于表示特殊字符的转义序列，如下表：&lt;br/&gt;&lt;img src=&quot;http://maconn.oss-cn-beijing.aliyuncs.com/18-10-10/27423393.jpg&quot;/&gt;&lt;br/&gt;  所有这些转义序列都可以出现在字符字面量或字符串中。例如'\u2018'或&quot;Hello\n&quot;。转义序列\u还可以出现在字符字面量或字符串之外，而其他转义序列就不可以。例如&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String\u005B\u005D args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就完全符合语法，\u005B和\u005D是[和]的编码。但要注意的是，转义序列\u会在编译代码前得到处理。例如，&quot;\u0022+\u0022&quot;并不是一个由双引号包围加号组成的字符串。实际上，\u0022会在编译代码之前替换为&quot;，这个字符串会变成&quot;&quot;+&quot;&quot;，也就是一个空串。更隐蔽的，一定要注意注释中的\u，注释&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Unicode \u000A is a new line&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会产生一个语法错误，因为\u000A会被替换成换行符，也就是说，上面的注释会变成下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Unicode 
is a new line&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似地，下面的注释也会产生语法错误：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Look inside c:\users&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为\u后面并没有跟着一个十六进制数。&lt;/p&gt;
&lt;h4 id=&quot;在数字字面量中使用下划线&quot;&gt;(4)在数字字面量中使用下划线&lt;/h4&gt;
&lt;p&gt;  在JavaSE7及之后的版本中，任意个数的下划线（_）可以出现在数字字面量中的任意两个数字之间。这个功能可以提高数字字面量的可读性，类似于使用逗号或空格等标点符号将每三个数字分为一组的形式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long creditCardNumber = 1234_5678_9012_3456L; 
long socialSecurityNumber = 999_99_9999L; 
float pi = 3.14_15F; 
long hexBytes = 0xFF_EC_DE_5E; 
long hexWords = 0xCAFE_BABE; 
long maxLong = 0x7fff_ffff_ffff_ffffL; 
byte nybbles = 0b0010_0101; 
long bytes = 0b11010010_01101001_10010100_10010010;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 10 Oct 2018 14:50:00 +0000</pubDate>
<dc:creator>maconn</dc:creator>
<og:description>经过上一篇教程的学习，我们知道对象将它的状态存在域中。然而，Java中也使用了“变量”这个术语。在这一篇教程中，我们将会讨论它们之间的关系，以及变量命名的规则和惯例，基本数据类型以及它们的默认值和字面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maconn/p/9763751.html</dc:identifier>
</item>
<item>
<title>简述RPC原理实现 - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/9769517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/9769517.html</guid>
<description>&lt;pre class=&quot;md-meta-block md-end-block&quot;&gt;
 
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;RPC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/summer.jpg&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181010221237977-1832141277.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;架构的改变，往往是因为业务规模的扩张。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;随着业务规模的扩张，为了满足业务对技术的要求，技术架构需要从单体应用架构升级到分布式服务架构，来降低公司的技术成本，更好的适应业务的发展。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;分布式服务架构的诸多优势，这里就不一一列举了，今天围绕的话题是服务框架，为了推行服务化，必然需要一套易用的服务框架，来支撑业务技术架构升级。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务架构的核心是&lt;span&gt;&lt;strong&gt;服务调用&lt;/strong&gt;&lt;span&gt;，分布式服务架构中的服务分布在不同主机的不同进程上，服务的调用跟单体应用进程内方法调用的本质区别就是需要借助网络来进行通信。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;RPC Demo实现思路&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;原作者梁飞，在此记录下他非常简洁的rpc实现思路。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;核心框架类&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * Copyright 2011 Alibaba.com All right reserved. This software is the
   * confidential and proprietary information of Alibaba.com (&quot;Confidential
   * Information&quot;). You shall not disclose such Confidential Information and shall
   * use it only in accordance with the terms of the license agreement you entered
   * into with Alibaba.com.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.alibaba.study.rpc.framework;
  ​
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ObjectInputStream;
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ObjectOutputStream;
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ServerSocket;
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;
  ​
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * RpcFramework
   * 
   * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; william.liangf
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcFramework {
  ​
      &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
       * 暴露服务
       * 
       * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; service 服务实现
       * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; port 服务端口
       * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; export(&lt;span&gt;final&lt;/span&gt; Object service, &lt;span&gt;int&lt;/span&gt; port) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (service == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;service instance == null&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (port &amp;lt;= 0 || port &amp;gt; 65535&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Invalid port &quot; +&lt;span&gt; port);
          System.out.println(&lt;/span&gt;&quot;Export service &quot; + service.getClass().getName() + &quot; on port &quot; +&lt;span&gt; port);
          ServerSocket server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerSocket(port);
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(;;) {
              &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                  &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Socket socket =&lt;span&gt; server.accept();
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                      @Override
                      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                          &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                              &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                                  ObjectInputStream input &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(socket.getInputStream());
                                  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                                      String methodName &lt;/span&gt;=&lt;span&gt; input.readUTF();
                                      Class&lt;/span&gt;&amp;lt;?&amp;gt;[] parameterTypes = (Class&amp;lt;?&amp;gt;&lt;span&gt;[])input.readObject();
                                      Object[] arguments &lt;/span&gt;=&lt;span&gt; (Object[])input.readObject();
                                      ObjectOutputStream output &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(socket.getOutputStream());
                                      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                                          Method method &lt;/span&gt;=&lt;span&gt; service.getClass().getMethod(methodName, parameterTypes);
                                          Object result &lt;/span&gt;=&lt;span&gt; method.invoke(service, arguments);
                                          output.writeObject(result);
                                      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                                          output.writeObject(t);
                                      } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                                          output.close();
                                      }
                                  } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                                      input.close();
                                  }
                              } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                                  socket.close();
                              }
                          } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                              e.printStackTrace();
                          }
                      }
                  }).start();
              } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                  e.printStackTrace();
              }
          }
      }
  ​
      &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
       * 引用服务
       * 
       * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt; 接口泛型
       * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; interfaceClass 接口类型
       * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; host 服务器主机名
       * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; port 服务器端口
       * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 远程服务
       * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T refer(&lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; interfaceClass, &lt;span&gt;final&lt;/span&gt; String host, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; port) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interfaceClass == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Interface class == null&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; interfaceClass.isInterface())
              &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;The &quot; + interfaceClass.getName() + &quot; must be interface class!&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (host == &lt;span&gt;null&lt;/span&gt; || host.length() == 0&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Host == null!&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (port &amp;lt;= 0 || port &amp;gt; 65535&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Invalid port &quot; +&lt;span&gt; port);
          System.out.println(&lt;/span&gt;&quot;Get remote service &quot; + interfaceClass.getName() + &quot; from server &quot; + host + &quot;:&quot; +&lt;span&gt; port);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] {interfaceClass}, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvocationHandler() {
              &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] arguments) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
                  Socket socket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket(host, port);
                  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                      ObjectOutputStream output &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(socket.getOutputStream());
                      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                          output.writeUTF(method.getName());
                          output.writeObject(method.getParameterTypes());
                          output.writeObject(arguments);
                          ObjectInputStream input &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(socket.getInputStream());
                          &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                              Object result &lt;/span&gt;=&lt;span&gt; input.readObject();
                              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Throwable) {
                                  &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (Throwable) result;
                              }
                              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
                          } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                              input.close();
                          }
                      } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                          output.close();
                      }
                  } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                      socket.close();  
                }  
            }  
        });  
    }  
​  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;定义服务接口&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * Copyright 2011 Alibaba.com All right reserved. This software is the
   * confidential and proprietary information of Alibaba.com (&quot;Confidential
   * Information&quot;). You shall not disclose such Confidential Information and shall
   * use it only in accordance with the terms of the license agreement you entered
   * into with Alibaba.com.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.alibaba.study.rpc.test;
  ​
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * HelloService
   * 
   * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; william.liangf
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; HelloService {
  ​
      String hello(String name);
  ​
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;实现服务&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   * Copyright 2011 Alibaba.com All right reserved. This software is the
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   * confidential and proprietary information of Alibaba.com (&quot;Confidential
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   * Information&quot;). You shall not disclose such Confidential Information and shall
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   * use it only in accordance with the terms of the license agreement you entered
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   * into with Alibaba.com.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.alibaba.study.rpc.test;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  ​
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;   * HelloServiceImpl
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   * 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; william.liangf
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HelloService {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  ​
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(String name) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;           &lt;span&gt;return&lt;/span&gt; &quot;Hello &quot; +&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  ​
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;暴露服务&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * Copyright 2011 Alibaba.com All right reserved. This software is the
   * confidential and proprietary information of Alibaba.com (&quot;Confidential
   * Information&quot;). You shall not disclose such Confidential Information and shall
   * use it only in accordance with the terms of the license agreement you entered
   * into with Alibaba.com.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.alibaba.study.rpc.test;
  ​
  &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.study.rpc.framework.RpcFramework;
  ​
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * RpcProvider
   * 
   * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; william.liangf
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcProvider {
  ​
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
          HelloService service &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloServiceImpl();
          RpcFramework.export(service, &lt;/span&gt;1234&lt;span&gt;);
      }
  ​
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;引用服务&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   * Copyright 2011 Alibaba.com All right reserved. This software is the
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   * confidential and proprietary information of Alibaba.com (&quot;Confidential
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   * Information&quot;). You shall not disclose such Confidential Information and shall
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   * use it only in accordance with the terms of the license agreement you entered
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   * into with Alibaba.com.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.alibaba.study.rpc.test;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  ​
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.study.rpc.framework.RpcFramework;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  ​
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   * RpcConsumer
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   * 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; william.liangf
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcConsumer {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       
&lt;span&gt;19&lt;/span&gt;       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;           HelloService service = RpcFramework.refer(HelloService.&lt;span&gt;class&lt;/span&gt;, &quot;127.0.0.1&quot;, 1234&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;           &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; Integer.MAX_VALUE; i ++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;               String hello = service.hello(&quot;World&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;              System.out.println(hello);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;               Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       
&lt;span&gt;28&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;em&gt;梁飞大大的博客使用原生的jdk api就展现给各位读者一个生动形象的rpc demo，实在是强。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个简单的例子的实现思路是:&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用阻塞的&lt;span&gt;&lt;strong&gt;socket IO流&lt;/strong&gt;&lt;span&gt;来进行server和client的通信，也就是rpc应用中服务提供方和服务消费方。并且是端对端的，用端口号来直接进行通信&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;方法的远程调用使用的是&lt;span&gt;&lt;strong&gt;jdk的动态代理&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;参数的序列化也是使用的最简单的&lt;span&gt;&lt;strong&gt;objectStream&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务框架&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务框架的核心是服务调用，分布式服务架构中的服务分布在不同主机的不同进程上，服务的调用跟单体应用进程内方法调用的本质区别就是需要借助网络来进行通信。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下图是服务框架的架构图，主流的服务框架的实现都是这套架构，如 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/apache/incubator-dubbo&quot;&gt;&lt;span&gt;Dubbo&lt;/span&gt;&lt;/a&gt;&lt;span&gt;、SpringCloud 等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181010221055328-2087560284.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;RPC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/arch.jpg&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Invoker 是服务的调用方&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Provider 是服务的提供方&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Registry 是服务的注册中心&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Monitor 是服务的监控模块&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Invoker 和 Provider 分别作为服务的调用和被调用方，这点很明确。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是仅有这两者还是不够的，因为作为调用方需要知道服务部署在哪，去哪调用服务，所以有了 Registry 模块，它的功能是给服务提供方注册服务，给服务调用方发现服务。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Monitor 作为服务的监控模块，负责服务的调用统计以及链路分析功能，也是服务治理重要的一环。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;核心模块&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下图是服务框架的流程图，我们分服务注册、发现、调用三个方面来进行流程分解。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181010221034847-987887310.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;RPC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/process.jpg&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务注册是服务提供方向注册中心注册服务信息；当提供服务应用下线时，负责将服务注册信息从注册中心删去。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务发现是服务调用方从注册中心订阅服务，获取服务提供方的相关信息；当服务注册信息有变更时，注册中心负责通知到服务调用方。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务调用是服务调用方通过从注册中心拿到服务提供方的信息，向服务提供方发起服务调用，获取调用结果。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对照上述流程图，我们按照请求的具体过程进行分析。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;作为服务调用方 Invoker 的具体流程是：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;4&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Request 从下往上，由于服务调用方只能拿到服务提供方提供的 API 接口或者 API 接口的 JAR 包，所以服务调用方需要经过一层代理 Proxy 来伪装服务的实现；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;经过代理 Proxy 之后，会经过路由 Router、负载均衡 LoadBalance 模块，目的是从一堆从注册中心拿到的服务提供方信息中选出最合适的服务提供方机器进行调用。另外，还会经过 Monitor 监控等模块；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;接着会经过服务编码 Codec 模块，这个模块的目的是因为请求在网络传输前需要按照通信协议以及对象的序列化方式，对传输的请求进行编解码；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最终会经过网络通信 Transporter 模块，这个模块将 Codec 编码好的请求进行传输。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;作为服务提供方 Provider 的具体流程是：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Request 从上往下，经过网络通信 Transporter 模块，获取到的是由调用方发送的Request字节数组。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;接着经过服务编码 Codec 模块，根据通信协议解出一个完整的请求包，然后使用具体的序列化方式反序列化成请求对象。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;紧接着会经过监控、限流、鉴权等模块。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最终会执行服务的真正业务实现 ServiceImpl，执行完后，结果按原路返回。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;按照上述流程分解一个服务框架的相关工作，再去看一些开源的服务框架也就不难理解了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;一般服务框架的核心模块应该有注册中心、网络通信、服务编码（通信协议、序列化）、服务路由、负载均衡，服务鉴权，可用性保障（服务降级、服务限流、服务隔离）、服务监控（Metrics、Trace）、配置中心、服务治理平台等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;注册中心&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;注册中心是用来注册和发现服务的，需要具备的基本功能有注册服务、下线服务、发现服务、通知服务变更等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当前使用比较多的开源注册中心有 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/apache/zookeeper&quot;&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;/a&gt;&lt;span&gt;、&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/coreos/etcd&quot;&gt;&lt;span&gt;ETCD&lt;/span&gt;&lt;/a&gt;&lt;span&gt;、&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/Netflix/eureka&quot;&gt;&lt;span&gt;Eureka&lt;/span&gt;&lt;/a&gt; &lt;span&gt;等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Zookeeper 与 ETCD 在整体架构上都比较类似，使用方式非常便捷，应用比较广泛。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这两套系统按照 CAP 理论，属于 CP 系统，可用性会差一点，但是作为中小规模服务注册中心，还是游刃有余，并没有某些人说的那么差劲。 Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，很不幸的是 Eureka 2.0 开源工作宣告停止。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;网络通信&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务的调用方和提供方都来自不同的主机的不同的进程，所以要进行调用，必然少不了网络通信。可以说网络通信是分布式系统的重中之重，网络通信框架的好坏直接影响服务框架的性能。从零实现一套性能高，稳定性强的通信框架还是非常难的，好在目前已经有很多开源的高性能的网络通信框架。 针对 Java 生态有 Mina、&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/netty/netty&quot;&gt;&lt;span&gt;Netty&lt;/span&gt;&lt;/a&gt; &lt;span&gt;等，目前使用最广泛的也当属 Netty。Netty 使用的是 per thread one eventloop 线程模型，这点与 Nginx 等其他高性能网络框架类似。另外，Netty 非常易用，所以网络通信选择 Netty 框架自然是毫无疑问的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Netty实践学习案例，是Netty初学者及核心技术巩固的最佳实践。
可以见我的netty学习工程:
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/sanshengshui/netty-learning-example&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务编码&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;内存对象要经过网络传输前需要做两件事：第一是确定好通信协议，第二序列化。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;通信协议&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通信协议说白了在发送数据前按照一定的格式来处理数据，然后进行发送，保证接收方拿到数据知道按照什么样的格式进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;有些同学可能不理解，为什么需要通信协议，不是有 TCP、UDP 协议了吗？这里说的不是传输层的通信协议，应该是应用层的协议类似 HTTP。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;因为的 TCP 协议虽然已经保证了可靠有序的传输，但是如果没有一套应用层的协议，就不知道发过来的字节数据是不是一个完整的数据请求，或者说是多个请求的字节数据都在一起，无法拆分，这就是是所谓的粘包，需要按照协议进行拆包，拆成一个个完整的请求包进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;协议的实现上一般大厂或者开源的服务框架选择自建协议，更偏向服务领域。如 Dubbo，当然也有些框架直接使用 HTTP，HTTP/2，比如 GRPC 使用的就是 HTTP/2。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;序列化&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;由于向网络层发送的数据必须是字节数据，不可能直接将一个对象发送到网络，所以在发送对象数据前，一般需要将对象序列化成字节数据，然后进行传输。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在服务方收到网络的字节数据时，需要经过反序列化拿到相关的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;序列化的实现目前现成比较多，如 Hessian、JSON、Thrift、ProtoBuf 等。Thrift 和 ProtoBuf 能支持跨语言，性能比较好，不过使用时需要编写 IDL 文件，有点麻烦。Hessian、JSON 使用起来比较友好，但是性能会差一点。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务路由&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务路由指的是向服务提供方发起调用时，需要根据一定的算法从注册中心拿到的服务方地址信息中选择其中的一批机器进行调用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;路由的算法一般是根据场景来进行选择的，比如有些公司实施两地三中心这种高可用部署，但是由于两地的网络延时比较大，那这时就可以实施同地区路由策略，比如上海的调用方请求会优先选择上海的服务进行调用，来降低网络延时导致的服务端到端的调用耗时。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;还有些框架支持脚本配置来进行定向路由策略。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;负载均衡&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;负载均衡是紧接着服务路由的模块，负载均衡负责将发送请求均匀合理的发送到服务提供方的节点上，而备选机器，一般就是经过路由模块选择出来的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;负载均衡的算法有很多，如 RoundRobin、Random、LeastActive、ConsistentHash 等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;而且这些算法一般都是基于权重的增强版本，因为需要根据权重来调节每台服务节点的流量。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务鉴权&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务鉴权是服务安全调用的基础，虽然绝大部分服务都是公司内部服务，但是对于敏感度较高的数据还是需要进行鉴权的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;鉴权的服务需要对服务的调用方进行授权，未经授权的调用方是不能够调用该服务的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关于服务鉴权的实现大都是基于 token 的认证方案，如 JWT（JSON Web Token） 认证。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;可用性保障&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可用性保障模块是服务高可用的一个重要保证。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务在交互中主要分成调用方和提供方两种角色，作为服务调用方，可以通过服务降级提升可用性。作为服务提供方，可以通过服务限流、服务隔离来保证可用性。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务降级&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务降级指的是当依赖的服务不可用时，使用预设的值来替代服务调用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;试想一下，假设调用一个非关键路径上的服务（也就是说该调用获取的结果是否实时，是否正确不是特别重要）出现问题，导致调用超时、失败等，在没有降级措施的情况下，会直接应用服务调用方业务。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;因此，有些非关键路径上服务调用，可以通过服务降级实现有损服务，柔性可用。 开源的降级组件有 Netflix 的 Hystrix，Hystrix 使用比较广泛。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务限流&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务降级保护的是服务的调用方，也就是服务的依赖方。而服务的提供方呢，如何保证服务的可用性呢？ 服务限流指的是对服务调用流量的限制，限制其调用频次，来保护服务。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在高并发的场景中，很容易出现流量过高，导致服务被打垮。这里就需要限流来保证服务自身的稳定运行。 Hystrix 也是可以用来限流的，但是用的比较多的有 guava 的 RateLimiter，其使用的是令牌桶算法，能够保证平滑限流。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务隔离&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;除了服务限流对服务提供方进行保护，就够了吗？ 可能还不够，考虑一下这样的场景，假设某一个有问题的方法出现问题，处理非常耗时，这样会堵住整个服务处理线程，导致正常的服务方法也不能够正常调用。因此还需要服务隔离。 服务隔离指的是对服务执行的方法进行线程池隔离，保证异常耗时方法不会对正常的方法调用产生干扰，进而保护服务的稳定运行，提升可用性。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;服务监控&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务监控是高可用系统不可或缺的重要支撑。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务监控不仅包括服务调用等业务统计信息 Metrics，还包括分布式链路追踪 Trace。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;分布式系统监控比单体应用要复杂的多，需要将大量的监控信息进行聚合展示，尤其是在分布式链路追踪方面，由于服务调用过程中涉及到多个分布在不同机器上的服务，需要一个调用链路展示系统方便查看调用链路中耗时和出问题的环节。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Metrics&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Metrics 监控主要是服务调用的一些统计报表，包括服务调用次数、成功数、失败数，以及服务方法的调用耗时，如平均耗时，耗时99线，999线等。全方位展示服务的可用性以及性能等信息。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;目前开源的 Metrics 监控有美团点评的 Cat、SoundCloud 的 Prometheus 以及基于 OpenTracking 的 SkyWalking。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Trace 监控是对分布式服务调用过程中的整体链路展示和分析。方便查看链路上各个环境的性能问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;分布式链路追踪的原理大都是基于 Google 的论文 Dapper, a Large-Scale Distributed Systems Tracing Infrastructure。 开源的分布式链路追踪系统有美团点评的 Cat，基于 OpenTracking 的SkyWalking、Twitter 的 ZipKin。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;配置中心&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;配置中心不光是常见的系统需要，服务框架也需要，它能够对系统中使用的配置进行管理，也能够针对修改配置动态通知到应用系统。 一套完善的服务框架，必然少不了配置，如一些动态开关、降级配置、限流配置、鉴权配置等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;开源的配置中心有阿里的 Diamond，携程的 Apollo。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;治理平台&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;治理平台指的是对服务进行管理的平台。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;微服务微了之后，必然会导致服务数量的上升，如果没有一个完善的治理平台，服务规模扩大之后，很难去维护，也必然导致故障频频，并且极度影响开发效率。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;治理平台主要是服务功能的相关操作平台，包括服务权重修改、服务下线、鉴权降级等配置修改等。 治理平台跟服务框架的耦合比较强，所以开源的比较少。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Oct 2018 14:16:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>前言 架构的改变，往往是因为业务规模的扩张。 随着业务规模的扩张，为了满足业务对技术的要求，技术架构需要从单体应用架构升级到分布式服务架构，来降低公司的技术成本，更好的适应业务的发展。 分布式服务架构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshengshui/p/9769517.html</dc:identifier>
</item>
<item>
<title>页面间大量数据参数传递 - 如是说</title>
<link>http://www.cnblogs.com/lishanlei/p/9769507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lishanlei/p/9769507.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;我们在开发项目中经常会遇到一种问题，就是在前端页面跳转时传递某些参数，通常我们是通过路由传递的，但是如果数据量很多的情况下，会造成路由非常的长，如果在大的话甚至会超出地址栏URL的最大限度，这就狗带了．最近手头上一个项目的前端刚好遇到这个问题，该项目前端用的是vue2.x．不是什么大问题，但是之前没有认真想过解决办法，于是将解决思路记录下来了．&lt;/p&gt;

&lt;h3&gt;地址栏URL最大限度&lt;/h3&gt;
&lt;p&gt;首先我查了不同浏览器地址栏URL的最大限度．&lt;/p&gt;
&lt;p&gt;虽然HTTP协议的&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616.html&quot; data-cke-saved-href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616.html&quot;&gt;RFC规范&lt;/a&gt;并没有详细规定URL的最大字符长度限制，但实际上，在浏览器或者服务器中总会存在限制的。这里所说的字符是指ASCII字符。HTTP RFC2616协议没有规定URL的最大长度，规定服务器如果不能处理太长的URL，就得返回414状态码（Request-URI Too Long）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微软 Internet Explorer：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://support.microsoft.com/kb/q208427/&quot; data-cke-saved-href=&quot;http://support.microsoft.com/kb/q208427/&quot;&gt;微软帮助网站&lt;/a&gt;上说IE7之前（包括IE7）的浏览器，对URL的最大长度限制是2,083个字符。&lt;br/&gt;&lt;strong&gt;Firefox：&lt;/strong&gt;&lt;br/&gt;对于Firefox1.5.x，地址栏能显示的URL最大长度是65,536个字符，但实际上有效的URL最大长度不少于100,000个字符。&lt;br/&gt;对于Firefox 3.0.5，&lt;a href=&quot;http://support.mozilla.com/tiki-view_forum_thread.php?locale=zh-CN&amp;amp;comments_parentId=153230&amp;amp;forumId=1&quot; data-cke-saved-href=&quot;http://support.mozilla.com/tiki-view_forum_thread.php?locale=zh-CN&amp;amp;comments_parentId=153230&amp;amp;forumId=1&quot;&gt;mozilla官方论坛&lt;/a&gt;上有人测试其URL长度限制为65,000个字符。&lt;br/&gt;也有人说Firefox可以支持URL高达2Gbyte的长度（&lt;a href=&quot;http://forums.mozillazine.org/viewtopic.php?f=7&amp;amp;t=322458&amp;amp;start=0&amp;amp;st=0&amp;amp;sk=t&amp;amp;sd=a&quot; data-cke-saved-href=&quot;http://forums.mozillazine.org/viewtopic.php?f=7&amp;amp;t=322458&amp;amp;start=0&amp;amp;st=0&amp;amp;sk=t&amp;amp;sd=a&quot;&gt;参考&lt;/a&gt;），在data URL中可以运用到这样大数据量的URL。dataURL是一种URL本身包含了实际数据的URL，比如一个图片、一个HTML网页或者全部的数据、代码等等。仅有Firefox支持dataURL。&lt;br/&gt;&lt;strong&gt;Safari：&lt;/strong&gt;&lt;br/&gt;Safari最少支持80,000个字符长度的URL。&lt;br/&gt;&lt;strong&gt;Opera：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://www.opera.com/support/kb/view/387/&quot; data-cke-saved-href=&quot;http://www.opera.com/support/kb/view/387/&quot;&gt;Opera官方网站&lt;/a&gt;上说，Opera并没有强制限制URL的长度。&lt;br/&gt;网友测试Opera 9支持最少190,000个字都长度的URL，并且Opera9的地址栏可以显示、编辑、复制和粘贴完整的URL串。&lt;/p&gt;
&lt;p&gt;综上，又在网上找了一个附表：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;IE&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;URL最大限制是2083个字节，Path长度最大是2048字节（Get请求）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Firefox&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;65536&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Safari&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;80000以上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Opera&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;190000字节以上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Chrome&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;8182字节&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Apache Server&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;8192字节&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;IIS&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;16384字节&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Perl HTTP::Daemon&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;至少8000字节&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;我的思路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的第一个想法就是通过缓存进行解决----cookie/localStorage/sessionStorage．通过在服务器或客户端进行数据缓存以供页面进行读取．但是在后续的思考中我想到首先cookie缓存量很小，同时session/cookie对与网站所有页面是透明的，我只是想实现指定页面间进行参数传递，其他页面应该不知情，考虑到保密性，我放弃了这个想法．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的第二个思路还是通过缓存来实现，但是是通过application cache(共享本地缓存)，具体的介绍就不在这里说了．但是我考虑到application cache具有缓存时间，而我想要的是在页面跳转后缓存的参数数据被销毁，也就是类似闪存的机制．同时application cache缓存页面需要的资源，那么其他页面所需要的资源也同时被缓存下来，这样做得不偿失．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过js的全局变量．这个没什么介绍的，将参数保存在全局变量中，那么在页面声明周期内所有页面都可以使用．但是还是那个问题，在使用全局变量的时候，其他页面也能够获得．所以pass.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路四&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我找到利用原生很不错的方法，那就是通过模态窗口来实现页面间的参数传递．以下是对showModalDialog(模态窗口)的简单介绍：&lt;/p&gt;
&lt;p&gt;基本介绍：&lt;/p&gt;




&lt;p&gt;通过vArguments来进行传递的。类型不限制，对于字符串类型，最大为4096个字符。也可以传递对象，如下：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;怎样才让在showModalDialog和showModelessDialog的超连接不弹出新窗口？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在被打开的网页里加上：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;怎样才刷新showModalDialog和showModelessDialog里的内容？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在showModalDialog和showModelessDialog里是不能按F5刷新的，又不能弹出菜单。这个只能依靠javascript了，以下是相关代码：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如何用javascript关掉showModalDialog(或showModelessDialog)打开的窗口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也要配合&amp;lt;base target=&quot;_self&quot;&amp;gt;，不然会打开一个新的IE窗口，然后再关掉的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Math.random与showModalDialog。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当你设置的弹出网页固定时（如上面的&quot;modal.htm&quot;页面），ie很可能到临时文件区，下载上次产生的该页面(openPage.html),而没有重新加载，对于动态加载的页面来说，这样往往产生误会，如没有及时更新数据，也就更不利于开发者测试。所以，你可以采用如下方式：      &lt;/p&gt;

&lt;p&gt;这样每次产生的strPage是不一样的．&lt;/p&gt;
&lt;p&gt;但是最后我还是放弃了，因为首先我用的是vue框架，写原生太不优雅；其次如上所示，使用模态窗口的局限性太大．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路五&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;俗话说：解铃还须系铃人&lt;/p&gt;
&lt;p&gt;在一筹莫展之际，我想到了vue-router中的params．上代码：&lt;/p&gt;

&lt;p&gt;query传递参数：&lt;/p&gt;

&lt;p&gt;注意：无论是params还是query进行参数传递，传参是this.$router,接收参数是this.$route,一定要细心．&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;1．当使用query进行参数传递时，参数会跟在路径后面．我们可以在地址栏看到后面跟的参数，而params不会在地址栏显示．直白的说query相当于get请求，而params相当于post请求．&lt;/p&gt;
&lt;p&gt;2．params传参，push里面只能是 name:'xxxx',不能是path:'/xxx',因为params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined．&lt;/p&gt;


&lt;p&gt;果然．．．&lt;strong&gt;自己挖的坑还要自己填&lt;/strong&gt;．．．&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 14:14:00 +0000</pubDate>
<dc:creator>如是说</dc:creator>
<og:description>前言 我们在开发项目中经常会遇到一种问题，就是在前端页面跳转时传递某些参数，通常我们是通过路由传递的，但是如果数据量很多的情况下，会造成路由非常的长，如果在大的话甚至会超出地址栏URL的最大限度，这就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lishanlei/p/9769507.html</dc:identifier>
</item>
<item>
<title>[原创]分布式系统之缓存的微观应用经验谈（二） 【主从和主备高可用篇】 - AutumnBing</title>
<link>http://www.cnblogs.com/bsfz/p/9769503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bsfz/p/9769503.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分布式系统之缓存的微观应用经验谈（二） 【主从和主备高可用篇】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　近几个月一直在忙些琐事，几乎年后都没怎么闲过。忙忙碌碌中就进入了2018年的秋天了，不得不感叹时间总是如白驹过隙，也不知道收获了什么和失去了什么。最近稍微休息，买了两本与技术无关的书，其一是 Yann Martel 写的《The High Mountains of Portugal》（葡萄牙的高山），发现阅读此书是需要一些耐心的，对人生暗喻很深，也有足够的留白，有兴趣的朋友可以细品下。好了，下面回归正题，尝试写写工作中缓存技术相关的一些实战经验和思考。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　在分布式Web程序设计中，解决高并发以及内部解耦的关键技术离不开缓存和队列，而缓存角色类似计算机硬件中CPU的各级缓存。如今的业务规模稍大的互联网项目，即使在最初beta版的开发上，都会进行预留设计。但是在诸多应用场景里，也带来了某些高成本的技术问题，需要细致权衡。本系列主要围绕分布式系统中服务端缓存相关技术，也会结合朋友间的探讨提及自己的思考细节。文中若有不妥之处，恳请指正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;为了方便独立成文，原谅在内容排版上的一点点个人强迫症。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;第二篇这里尝试聊聊缓存的主从&lt;/strong&gt;（Master-Slave）&lt;/span&gt;，以及相关的高可用实现（High-Availability）（具体应用依然以Redis 举例）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;另见：分布式系统之缓存的微观应用经验谈（一） 【基础细节篇】（&lt;a href=&quot;https://www.cnblogs.com/bsfz/p/9568591.html%20&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/p/9568591.html &lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　&lt;strong&gt;一、先简单谈谈主从分离（Master-Slave）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　（注：由于目前个人工作中大多数情况应用的是Redis 3.x，以下若有特性关联，均是以此作为参照说明。）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　1.1 关于主从分离的取舍观点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　是否采用主从分离（这里特指读写分离），个人目前的观点是，它在很多场景里，并不是一个很好的方案。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　我更想说的是，甚至任何涉及数据同步的环节，包括DB读写分离、缓存数据复制等等，如果没有特殊场景强制要求，那么尽量规避。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　虽然在互联网的一些应用场景里，读远大于写，也演变了一套看似完整的读写实践方案，大体归为“主写从读”、“一写多读”、“多读多写”。但本质上，在大多数环境下，均存在一定缺陷，无论是基于服务底层的数据同步延迟，还是开发中的逻辑切换，都带来了一些可能本末倒置的隐患和生硬。同时，在集群模式下读写分离成本实在过高，不仅仅是一致性问题，必须慎重考虑和权衡。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　如果没明白读写分离方案基于什么本质什么条件、包含哪些细节问题，那你的设计可能就很勉强，甚至出现某些关键问题时，反而很难去分析和解决。去年跟一前辈朋友取经，他们一个业务服务兜兜转转实际测出的结果是读QPS约2000，写QPS不到500，这些的分离哭笑不得，程序性能也没得到优化，反而增加了完全浪费的技术成本，以及因为读写分离带来的程序本不该处理的例外问题，也是折腾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　1.2 主从分离的一些细节&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　以 Redis为例，每个Redis实例（Instance）都是作为一个节点（node），并且默认主节点（master node），它们均可以手动转换为从节点（slave node）。每个slave node只能隶属于一个 master node， 而每个master node可以拥有n个slave node。任何主从同步都离不开复制的概念，在Redis中主要命令是 slaveof host port (指定一个master即可)，这样master node的数据将自动异步的同步到各个slave中，这算是最基本的形态了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　在进行相关软性配置时，个人推荐最好保持配置文件（config-file）的一致，这里指多个salve node。对于slave node的操作默认是只读（read-only），也建议保持这个设置。如果更改为可写权限，那么对slave node的修改是不会反向同步至master node中的，而且就算通过其他方式实现了反向同步，中间将大量存在类似传统RDBMS里的幻读问题，这里并发不大但足够繁琐，追踪到具体原因也是得不偿失。（而对应程序开发中，往往写操作也是都直接进master node执行。）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　另外顺便提下，主从的硬件配置可以一致，但是我依然推荐slave node 可以稍微高一些。另外，稍微注意，从节点内存尽量不要小于主节点的预算内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　对于node之间的数据延迟问题，外在因素一般都是网络I/O影响为主，CPU影响为次，换句话说，往往CPU的负载都足够（详见上一篇中提到的一些关联处），而网络I/O则会比较明显。在部署时候，没有特殊场景，都是同机房内联而对外隔离，但即使这样，也需要额外注意延迟的接收程度，每次同步复制的TCP数据包，并非是真正的实时处理，这个类似于之前提到的 AOF 和 RDB 的设计思想，分为实时复制和间隔性复制，前者更及时但带宽消耗大，而后者正好相反。在Redis中主要以 repl-disable-tcp-nodelay切换，默认使用前者，个人也较为推荐，但是在单次数据量较频较大，业务场景的时效要求不高，完全可以设置为后者，从而节省不少性能，也连锁提升了一定稳定性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　对于拓扑结构的设计，应用最多的就是单层拓扑，针对大量类似 keys全表扫描的操作，slave node会做到分担性能压力的作用。如果还想极致一些，把整体阻塞降到最低，可以将拓扑结构转换为树状，最简单的做法，将某个slave node直接转移到最底部，但会带来更多时效上的牺牲，所以需要考虑场景的接受程度了。同时，这里可能在具体架构落地的环节里，会比较分身乏术，需要开始考虑交由专业的运维来参与部署了，涉及上下节点间的通信、带宽监控、级联之间的复制问题，以及一些更独立的高频率统计和管理。ps下，这点一直作为备用，但在截止到目前的工作生涯里还没有找到必要的机会去采用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　对于复制/同步数据本身，无论是全量、还是增量，由于异步性（个人认为不可能设计为同步）和一定的时效损耗，必定存在一个偏移值（offset）。以Redis举例，master node和slave node中，各自对自己的当前复制时的offset做记录，如果两个角色的偏移值存在较大差异（可参考查询对应repl_offset），那么大概率存在频繁的阻塞，包括网络和自身脚本命令的阻塞。一般内部网络都是专线环境，并且都是独立部署，所以优先排查命令执行效率，和不必要的扫描问题（可参考上篇讨论）。但是无论如何，延迟或者说偏移过大的问题，总不可能完全规避，所以在开发里要么利用专业的监控服务，要么使用不同驱动库定时判断，这也无疑增加了编码复杂度，哪怕一些开源库已经尽力做了一些工作。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　二、尝试谈谈相关的高可用（High-Availability）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　缓存既然作为一种通用的中间件（当然，某些场景里也可能是最后一层，见第一篇），决定了在诸多场景里其交互频率（包括QPS）大多远远高于其他服务，这就需要其具备极高的稳定性、可用性。个人在前面阐述了一些关于主从分离的细节，下面尝试谈谈相关的HA方案和一些思考。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　2.1 关于高可用说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这里声明下，我认为主从分离和高可用本质上是没有任何一丝关系的，只是有些刚刚好的作用使之结合形成了一些HA方案。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　前面提到过，单个相对可靠的缓存服务，除了本身所在服务器自身的内存负载，设计时更需要充分考虑网络I/O、CPU的负载，以及某些场景下的磁盘I/O的代价。而这些条件全部都会拥有瓶颈，除此，你永远无法避免的问题还有服务器造成的直接宕机、服务自身的缺陷造成的某些时候的不可用（单点问题）等等。一套相对能够落地的高可用缓存方案，必然还需要拥有足够健壮的承载和相对完善的内部故障转移机制，从而达到对外提供的是整套程序化的高可用的缓存服务。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;2.2 实现HA的原始步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　以Redis为例，其本身的设计已经足够优秀和成熟，但在负载过大导致延迟过高、甚至崩溃的过程里，比较原始的方式是这样去操作：将一个关联的备用 slave node升级为 master node，可以一个 slaveof no one 基本处理。然后分析是否还做了业务层面上的主从分离，如果存在，那么还需要手工修改其他slave node 里的旧 master node指向，映射为当前 master node。 最后，当master node 重新上线时，修改自身角色并重新加入集群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　2.3 谈谈程序化HA方案的部分实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　上面提到的主干思路看起来并不复杂，但实际以人工去操作每一个环节所需要解决的问题往往不止这些，比如对于node的不可用的判定、确认后的选举逻辑、程序客户端的事件通知处理、服务的同步处理细节等。在Redis中比较成熟的 HA方案，目前主要包括依赖独立 node的 Sentinel 和自身基于 Gossip 传播的 Cluster 方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　从宏观角度来谈， Sentinel 和 Cluster 对于HA的设计均有互相借鉴，但后者 Cluster 更多是偏向提供一套可行性集群分片方案，与这里主题关联性不是很大（后续我会尝试单独写一篇，这里不延伸），围绕 Sentinel 的HA实践更直接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　Sentinel 的本质逻辑就是对所有node作定期巡视，当发现存在共同投票认为不可达的 master node， 会对其做下线标识，同时进行必要的 master选举升级，并将事件状态返回给信号方及客户端。Sentinel 的故障转移是针对 master node的，通常是把 slave node作为master的一个热备。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　这里依然以Redis 3.x 为主，在 Redis Sentinel方案里，通常指 n个 Sentinel node来自动监听Redis普通node。准确的说，每个Sentinel node 其实会监听任何一个node，包括其他Sentinel node。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　对于选举和审定的控制，可以调整配置 monitor的quorum 来确认严格性，比如， 在大多数场景里，设置为 (n / 2 + 1) 个，这样代表过半的票数认同，即认为指定node当前宕机。同时，当需要选举新的领导者master，这样也至少是趋势性客观判断。是否可以设置更小？当然可以，只是要注意的一个问题是，这样对失败的认定流程更短更快，但是误差也相对越大了，需要看看场景是否适配。个人在权衡时会尽量优先设置为前者。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　对于内部故障转移自然可以得到相应的事件通知，一般还可以写入到对应执行脚本，理论上会适合自动化这块，但个人目前尚未应用，这个偏向纯运维了，个人这里依然保持针对架构和开发来做一些讨论。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　对于监听通信，可以适度调整 failover-timeout等相关配置，这里并没有相应的计算方式，在大多数情况没太多讲究，但是也需要关注不能过度调整。个人目前采取的方式是，优先设置一个较大值，比如审定时间30秒，五个实例，那么同步转移超时时间则不低于150秒。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　对于选举完成后，发起新的数据复制流程，由于master node会面向多个 slave node 进行瞬间同步， 默认并发复制，而很多时候服务器环境有限，没有很足够的配置，甚至经常同一服务器上存在几个理想上本应该独立的服务， 这里则需要重点考虑下网络IO和磁盘IO的问题，根据实际情况临时调整，除此之外，在高峰时这也起到了限流作用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　额外再强调一下，基于主从的HA方案，依然存在 master node同步到 slave node 的延迟问题，这个基本是任何类似热备方案均存在的问题，系统交互越是密集，或者 slave node 的不断增加，都会明显增大这个延迟，所以在权衡的时候，需要考虑业务的初衷，到底能够接受到什么程度。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　任何服务里的应用，都不是看起来越多越好。假如你打算手动实现一套自定义的HA方案，或者相关的热备思路，你甚至可以考虑在业务程序里，具体点可以直接是在相关的驱动库（比如JAVA的Jedis、和.Net的 StackExchange.Redis）修改，插入数据的同时，插入到另一个备用库中。这在一些非缓存场景里，也有类似设计，并不是一定不被采用的，毕竟架构设计的初衷一定是考虑整体可行性和利弊权衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　本篇先写到这里，下一篇会围绕相关主题尝试扩展阐述。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　PS：由于个人能力和经验均有限，自己也在持续学习和实践，文中若有不妥之处，恳请指正。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;【预留占位：分布式系统之缓存的微观应用经验谈（三）【集群场景篇】&lt;a href=&quot;https://www.cnblogs.com/bsfz/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/&lt;/a&gt;】&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;End.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 14:13:00 +0000</pubDate>
<dc:creator>AutumnBing</dc:creator>
<og:description>第二篇这里尝试聊聊缓存的主从（Master-Slave），以及相关的高可用实现（High-Availability）（具体应用依然以Redis 举例） 1.1 关于主从分离的取舍观点 是否采用主从</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bsfz/p/9769503.html</dc:identifier>
</item>
<item>
<title>三、消息处理过程与集群维护 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9769487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9769487.html</guid>
<description>&lt;h2&gt;1.磁盘重认识&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010214240388-1556436630.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;

&lt;p&gt;当需要从磁盘读取数据时，要确定读的数据在哪个磁道，哪个扇区：&lt;br/&gt;首先必须找到柱面，即磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间;&lt;br/&gt;然后目标扇区旋转到磁头下,这个过程耗费的时间叫做旋转时间；&lt;br/&gt;&lt;span&gt;一次访盘请求（读/写）完成过程由三个动作组成&lt;/span&gt;&lt;br/&gt;&lt;span&gt;寻道（时间）：磁头移动定位到指定磁道;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;旋转延迟（时间）：等待指定扇区从磁头下旋转经过；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;数据传输（时间）：数据在磁盘、内存与网络之间的实际传输&lt;/span&gt;&lt;br/&gt;由于存储介质的特性，磁盘本身存取就比主存慢，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一甚至几千分支一&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么样才能提高磁盘的读写效率呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;O&quot; readability=&quot;10&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010214526424-1075650589.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;O&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;根据数据的局部性原理 ，有以下两种方法&lt;/p&gt;
&lt;p&gt;•预读或者提前读;&lt;/p&gt;
&lt;p&gt;•合并写——多个逻辑上的写操作合并成一个大的物理写操作中；&lt;/p&gt;
&lt;p&gt;即&lt;span&gt;采用磁盘顺序读写(不需要寻道时间，只需很少的旋转时间)。&lt;/span&gt;实验结果：在一个6 7200rpm SATA RAID-5 的磁盘阵列上线性写的速度大概是300M/秒，但是随机写的速度只有50K/秒，两者相差将近10000倍。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;2.Kafka消息的写入原理&lt;/h2&gt;
&lt;p&gt;一般的将数据从文件传到套接字的路径：&lt;br/&gt;&lt;span&gt;1.操作系统将数据从磁盘读到内核空间的页缓存中；&lt;/span&gt;&lt;br/&gt;2.应用将数据从内核空间读到用户空间的缓存中；&lt;br/&gt;3.应用将数据写回内存空间的套接字缓存中&lt;br/&gt;&lt;span&gt;4.操作系统将数据从套接字缓存写到网卡缓存中，以便将数据经网络发出；&lt;/span&gt;&lt;br/&gt;这样做明显是低效的，这里有四次拷贝，两次系统调用。如果使用sendfile(Java 为: FileChannel.transferTo api)，两次拷贝可以被避免：&lt;span&gt;允许操作系统将数据直接从页缓存发送到网络上&lt;/span&gt;。优化后，只有最后一步将数据拷贝到网卡缓存中是需要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215049573-1371280697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kafka topic信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215112975-2054756871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kafka 消息文件存储  (tree)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;O&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215303018-1317440729.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.Kafka消息的删除原理&lt;/h2&gt;
&lt;div class=&quot;O&quot; readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;从最久的日志段开始删除(按日志段为单位进行删除)，然后逐步向前推进，直到某个日志段不满足条件为止，删除条件：&lt;br/&gt;满足给定条件predicate(配置项log.retention.{ms,minutes,hours}和log.retention.bytes指定)；&lt;br/&gt;不能是当前激活日志段；&lt;br/&gt;大小不能小于日志段的最小大小(配置项log.segment.bytes配置)&lt;br/&gt;要删除的是否是所有日志段，如果是的话直接调用roll方法进行切分，&lt;span&gt;因为Kafka至少要保留一个日志段；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215504386-1472976064.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;1.Kafka消息的segment file的组成和物理结构&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215610963-368595486.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215652718-1005560518.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;2.Kafka消息的index file的组成和物理结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215715285-2045799860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.Kafka消息检索过程&lt;/h2&gt;
&lt;p&gt;以读取offset=368776的message为例，需要通过下面2个步骤查找：&lt;br/&gt;第一步查找segment file;&lt;br/&gt;以上图为例,其中00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件00000000000000368769.index的消息量起始偏移量为368770 = 368769 + 1。只要根据offset二分查找文件列表，就可以快速定位到具体文件。当offset=368776时定位到00000000000000368769.index|log&lt;br/&gt;第二步通过segment file查找message；&lt;br/&gt;算出368776-368770=6，取00000000000000368769.index文件第三项(6,1407)，得出从00000000000000368769.log文件头偏移1407字节读取一条消息即可&lt;/p&gt;

&lt;h2&gt;1.Kafka集群基本信息实时查看和修改&lt;/h2&gt;
&lt;p&gt;集群信息实时查看(topic工具)：&lt;br/&gt;列出集群当前所有可用的topic：&lt;br/&gt;bin/kafka-topics.sh --list –zookeeper zookeeper_address&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215918173-361101206.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;查看集群特定topic 信息：&lt;br/&gt;bin/kafka-topics.sh --describe --zookeeper zookeeper_address&lt;br/&gt;--topic topic_name&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010215941714-1803370939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;集群信息实时修改(topic工具)：&lt;br/&gt;创建topic：&lt;br/&gt;bin/kafka-topics.sh --create --zookeeper zookeeper_address --replication-factor 1 --partitions 1 --topic topic_name&lt;br/&gt;增加(不能减少) partition(最后的4是增加后的值)：&lt;br/&gt;bin/kafka-topics.sh --zookeeper zookeeper_address --alter –topic topic_name --partitions 4&lt;/p&gt;
&lt;p&gt;Topic-level configuration 配置都能修改&lt;/p&gt;
&lt;h2&gt;2.Kafka集群leader平衡机制&lt;/h2&gt;
&lt;p&gt;每个partitiion的所有replicas叫做“assigned replicas”，“assigned replicas”中的第一个replicas叫“preferred replica”，刚创建的topic一般“preferred replica”是leader。下图中Partition 0的broker  2就是preferred replica”，默认会成为该分区的leader。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010220100940-329485112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;集群leader平衡：&lt;br/&gt;bin/kafka-preferred-replica-election.sh –zookeeper zookeeper_address&lt;br/&gt;auto.leader.rebalance.enable=true&lt;/p&gt;
&lt;h2&gt;3.Kafka集群分区日志迁移&lt;/h2&gt;
&lt;p&gt;迁移topic数据到其他broker，请遵循下面四步：&lt;br/&gt;写json文件,文件格式如下：&lt;br/&gt;cat topics-to-move.json&lt;br/&gt;{&quot;topics&quot;: [{&quot;topic&quot;: &quot;foo1&quot;},&lt;br/&gt;{&quot;topic&quot;: &quot;foo2&quot;}],&lt;br/&gt;&quot;version&quot;:1&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;使用–generate生成迁移计划（下面的操作是将topic: foo1和foo2移动到broker 5,6）:&lt;br/&gt;bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --topics-to-move-json-file topics-to-move.json --broker-list &quot;5,6&quot; –generate&lt;br/&gt;这一步只是生成计划，并没有执行数据迁移；&lt;br/&gt;使用–execute执行计划：&lt;br/&gt;bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json –execute&lt;br/&gt;执行前最好保存当前的分配情况，以防出错回滚&lt;/p&gt;

&lt;div class=&quot;O&quot; readability=&quot;25&quot;&gt;
&lt;p&gt;•使用–verify验证是否已经迁移完成&lt;/p&gt;
&lt;p&gt;迁移某个topic的某些特定的partition数据到其他broker，步骤与上面一样，但是json文件如下面所示:&lt;/p&gt;
&lt;p&gt;cat custom-reassignment.json&lt;/p&gt;
&lt;p&gt;{&quot;version&quot;:1,&quot;partitions&quot;:[{&quot;topic&quot;:&quot;foo1&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[5,6]},{&quot;topic&quot;:&quot;foo2&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,3]}]}&lt;/p&gt;
&lt;p&gt;可以指定到topic的分区编号&lt;/p&gt;

&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;O&quot; readability=&quot;21.5&quot;&gt;
&lt;p&gt;kafka-reassign-partitions.sh工具会复制磁盘上的日志文件，只有当完全复制完成，才会删除迁移前磁盘上的日志文件。执行分区日志迁移需要注意：&lt;/p&gt;
&lt;p&gt;•kafka-reassign-partitions.sh 工具的粒度只能到broker，不能到broker的目录(如果broker上面配置了多个目录，是按照磁盘上面已驻留的分区数来均匀分配的)，所以，如果topic之间的数据，或者topic的partition之间的数据本身就不均匀，很有可能造成磁盘数据的不均匀:&lt;/p&gt;
&lt;p&gt;•对于分区数据较多的分区迁移数据会花大量的时间，所以建议在topic数据量较少或磁盘有效数据较少的情况下执行数据迁移操作；&lt;/p&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;进行分区迁移时最好先保留一个分区在原来的磁盘，这样不会影响正常的消费和生产，如果目的是将分区5(brober1,5)迁移到borker2,3。可以先将5迁移到2,1，最后再迁移到2,3。而不是一次将1,5迁移到2,3。因为一次迁移所有的副本，无法正常消费和生产，部分迁移则可以正常消费和生产&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;O&quot; readability=&quot;10.787601626016&quot;&gt;
&lt;div readability=&quot;25.497967479675&quot;&gt;
&lt;h2&gt;1.Kafka Offset Monitor介绍&lt;/h2&gt;
&lt;p&gt;在生产环境需要集群高可用，所以需要对Kafka集群进行监控。Kafka Offset Monitor可以监控Kafka集群以下几项：&lt;br/&gt;Kafka集群当前存活的broker集合；&lt;br/&gt;Kafka集群当前活动topic集合；&lt;br/&gt;消费者组列表&lt;br/&gt;Kafka集群当前consumer按组消费的offset lag数(即当前topic当前分区目前有多少消息积压而没有及时消费)&lt;/p&gt;

&lt;div class=&quot;O&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;部署Kafka Offset Minotor：&lt;/p&gt;
&lt;p&gt;•github下载jar包KafkaOffsetMonitor-assembly-0.2.0.jar :&lt;/p&gt;
&lt;p&gt;https://github.com/quantifind/KafkaOffsetMonitor/releases&lt;/p&gt;
&lt;p&gt;•启动Kafka Offset Minotor :&lt;/p&gt;
&lt;p&gt;java -cp KafkaOffsetMonitor-assembly-0.2.0.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk zk-01,zk-02 --refresh 5.minutes --retain 1.day &amp;amp;&lt;/p&gt;

&lt;/div&gt;
&lt;h2&gt;2.Kafka Offset Monitor使用&lt;/h2&gt;
&lt;div class=&quot;O&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010220538542-1927887467.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;3.Kafka Manager介绍&lt;/h2&gt;
&lt;p&gt;Kafka Manager由雅虎开源，提供以下功能：&lt;br/&gt;管理几个不同的集群；&lt;br/&gt;容易地检查集群的状态(topics, brokers, 副本的分布, 分区的分布) ；&lt;br/&gt;选择副本&lt;br/&gt;基于集群的当前状态产生分区分配&lt;br/&gt;重新分配分区&lt;/p&gt;
&lt;div class=&quot;O&quot; readability=&quot;10.540154015402&quot;&gt;
&lt;p&gt;Kafka Manager的安装，方法一(不但要求能上网，还要求能FQ)：&lt;/p&gt;
&lt;p&gt;•安装sbt：&lt;/p&gt;

&lt;p&gt;下载后，解压并配置环境变量(将SBT_HOME/bin配置到PATH变量中)&lt;/p&gt;
&lt;p&gt;安装Kafka Manager :&lt;/p&gt;
&lt;p&gt;•git clone https://github.com/yahoo/kafka-manager&lt;/p&gt;
&lt;p&gt;•cd kafka-manager&lt;/p&gt;
&lt;p&gt;•sbt clean dist&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;O&quot; readability=&quot;11.5&quot;&gt;
&lt;p&gt;部署Kafka Manager&lt;/p&gt;
&lt;p&gt;•修改conf/application.conf，把kafka-manager.zkhosts改为自己的zookeeper服务器地址&lt;/p&gt;
&lt;p&gt;•bin/kafka-manager -Dconfig.file=conf/application.conf -Dhttp.port=8007 &amp;amp;&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;Kafka Manager的安装，方法二：&lt;br/&gt;下载打包好的Kafka manager(也可以在课程源代码处下载)：&lt;br/&gt;https://github.com/scootli/kafka-manager-1.0-SNAPSHOT/tree/master/kafka-manager-1.0-SNAPSHOT&lt;br/&gt;下载后解压&lt;br/&gt;修改conf/application.conf，把Kafka-manager.zkhosts改为自己的zookeeper服务器地址&lt;br/&gt;bin/kafka-manager -Dconfig.file=conf/application.conf -Dhttp.port=8007 &amp;amp;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;4.Kafka Manager使用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010220821166-276259473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181010220838995-978870341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 10 Oct 2018 14:10:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<og:description>一、Kafka消息组织原理 1.磁盘重认识 当需要从磁盘读取数据时，要确定读的数据在哪个磁道，哪个扇区：首先必须找到柱面，即磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间;然后目标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9769487.html</dc:identifier>
</item>
<item>
<title>SpringBoot(二)CentOS部署SpringBoot项目从0到1 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/9675218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/9675218.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;26.429597701149&quot;&gt;
&lt;blockquote readability=&quot;6.5057471264368&quot;&gt;
&lt;p&gt;在之前的博文&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/9650939.html&quot; target=&quot;_blank&quot;&gt;《详解intellij idea搭建SpringBoot》&lt;/a&gt;介绍了idea搭建SpringBoot的详细过程， 并在&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/9651427.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装Tomcat》&lt;/a&gt;中介绍了Tomcat的安装，前面几篇文章实际上已经充分准备好了部署Linux的必要条件。那么今天来看看如何在CentOS部署SpringBoot，让你的SpringBoot在服务器上跑起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;Linux部署springboot&lt;/h2&gt;
&lt;p&gt;从0到1，5步走，在Linux Tomcat部署springboot:&lt;/p&gt;
&lt;p&gt;1. &lt;a title=&quot;CentOS安装FTP服务&quot; href=&quot;https://www.cnblogs.com/toutou/p/9662390.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装FTP服务》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a id=&quot;post_title_link_9670395&quot; href=&quot;http://www.cnblogs.com/toutou/p/9670395.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装Java JDK》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a id=&quot;post_title_link_9651427&quot; href=&quot;http://www.cnblogs.com/toutou/p/9651427.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装Tomcat》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a id=&quot;post_title_link_9650939&quot; href=&quot;http://www.cnblogs.com/toutou/p/9650939.html&quot; target=&quot;_blank&quot;&gt;《详解intellij idea搭建SpringBoot》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a id=&quot;post_title_link_9675218&quot; href=&quot;http://www.cnblogs.com/toutou/p/9675218.html&quot; target=&quot;_blank&quot;&gt;《CentOS部署SpringBoot项目》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;IntelliJ IDEA打包&lt;/h2&gt;
&lt;p&gt;1.1 设置packaging &lt;code&gt;jar&lt;/code&gt; 如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180921161225808-484354215.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2 编译插件, 如果是按照&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/9650939.html&quot; target=&quot;_blank&quot;&gt;《详解intellij idea搭建SpringBoot》&lt;/a&gt;建立的springboot模板则可跳过此步骤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3 在IntelliJ IDEA的顶部右边选择“Edit Configurations”，并添加一个Maven配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180921161253437-1820377074.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，依次执行A、B、C&lt;/p&gt;
&lt;p&gt;1.4 然后在Command line中输入“clean package”, 然后点击绿色的三角图标运行。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180921161300840-471376087.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.5 打包成功，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180921161306658-1446171878.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;springboot部署CentOS&lt;/h2&gt;
&lt;p&gt;2.1 文件传输至CentOS服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180921161313499-1396282535.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果FileZilla连接centos有问题的，可以看看&lt;a title=&quot;CentOS安装FTP服务&quot; href=&quot;https://www.cnblogs.com/toutou/p/9662390.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装FTP服务》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.2 到达jar包放置的位置，执行： &lt;code&gt;java -jar zuche-0.0.1-SNAPSHOT.jar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果需要配置端口号的话，就在后面加上&lt;code&gt;java -jar zuche-0.0.1-SNAPSHOT.jar --server.port=80&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180921161325016-1414974899.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，表示部署成功。&lt;/p&gt;
&lt;p&gt;2.3 在客户端电脑打开浏览器输入地址 http://10.168.11.106:8080/index 没有配置端口的话，就是默认的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180921161343596-624135285.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，得到的效果与&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/9650939.html&quot; target=&quot;_blank&quot;&gt;《详解intellij idea搭建SpringBoot》&lt;/a&gt;演示的本地效果一致。&lt;/p&gt;
&lt;p&gt;2.4 需要注意的是，如果在上面部署了80端口的jar包应用，下次再部署的时候会提示80端口被占用。&lt;/p&gt;
&lt;p&gt;错误信息：&lt;span&gt;ERROR 48608 --- [ main] o.apache.catalina.core.StandardService : Failed to start connector [Connector[HTTP/1.1-80]]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查看80端口号是否在使用中&lt;code&gt;lsof -i:80&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;找到进程号35986 &lt;code&gt;ps 35986&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;杀掉进程&lt;code&gt;kill -9 35986&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180929093609318-351796194.png&quot; alt=&quot;CentOS部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_5&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v相关&lt;/span&gt;常用命令&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;3.1 查看Tomcat的目录&lt;/span&gt; &lt;code&gt;sudo find / -name *tomcat*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;root权限下，从根目录递归式查找名称中包含tomcat字段的文件名称，也许会出来好多，但是也应该能够定位到Tomcat的位置了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181008155929218-553081798.png&quot; alt=&quot;Linux部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果万一不能很确定目录是否是Tomcat目录的话，可以找可能是Tomcat的目录，然后&lt;code&gt;ls&lt;/code&gt;看看目录内的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181008155937696-359734022.png&quot; alt=&quot;Linux部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.2 查看运行时的实时日志&lt;/span&gt; &lt;code&gt;tail -f catalina.out&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181008155943743-1025437031.png&quot; alt=&quot;Linux部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2.1 tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. Ctrl+c 是退出tail命令。&lt;/p&gt;
&lt;p&gt;3.2.2 格式：tail[必要参数][选择参数][文件]&lt;/p&gt;
&lt;p&gt;3.2.3 功能：用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。&lt;/p&gt;
&lt;p&gt;3.2.4 参数：&lt;/p&gt;
&lt;p&gt;-f 循环读取&lt;/p&gt;
&lt;p&gt;-q 不显示处理信息&lt;/p&gt;
&lt;p&gt;-v 显示详细的处理信息&lt;/p&gt;
&lt;p&gt;-c&amp;lt;数目&amp;gt; 显示的字节数&lt;/p&gt;
&lt;p&gt;-n&amp;lt;行数&amp;gt; 显示行数&lt;/p&gt;
&lt;p&gt;--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.&lt;/p&gt;
&lt;p&gt;-q, --quiet, --silent 从不输出给出文件名的首部&lt;/p&gt;
&lt;p&gt;-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒&lt;/p&gt;
&lt;p&gt;3.2.5 示例，显示文件末尾最后5行内容 &lt;code&gt;tail -n 5 catalina.2018-10-07.log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181008160010635-549376149.png&quot; alt=&quot;Linux部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.3 查看端口信息&lt;/span&gt;&lt;code&gt;netstat -tln&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181008160016818-678449650.png&quot; alt=&quot;Linux部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.4 查看Tomcat进程信息&lt;/span&gt;&lt;code&gt;ps -ef|grep tomcat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181008160024242-1621347177.png&quot; alt=&quot;Linux部署SpringBoot项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.5 查看当前的工作目录（pwd:print working directory）&lt;/span&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.6 windows查看Tomcat端口&lt;/span&gt; &lt;code&gt;netstat -ano|findstr 8080&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_5&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;博客总结&lt;/h2&gt;
&lt;blockquote readability=&quot;5.1894150417827&quot;&gt;
&lt;p&gt;从&lt;a title=&quot;CentOS安装FTP服务&quot; href=&quot;https://www.cnblogs.com/toutou/p/9662390.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装FTP服务》&lt;/a&gt;， 到     &lt;a id=&quot;post_title_link_9670395&quot; href=&quot;http://www.cnblogs.com/toutou/p/9670395.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装Java JDK》&lt;/a&gt;      到      &lt;a id=&quot;post_title_link_9651427&quot; href=&quot;http://www.cnblogs.com/toutou/p/9651427.html&quot; target=&quot;_blank&quot;&gt;《CentOS安装Tomcat》&lt;/a&gt;      到           到     &lt;a id=&quot;post_title_link_9650939&quot; href=&quot;http://www.cnblogs.com/toutou/p/9650939.html&quot; target=&quot;_blank&quot;&gt;《详解intellij idea搭建SpringBoot》&lt;/a&gt;       &lt;a id=&quot;post_title_link_9675218&quot; href=&quot;http://www.cnblogs.com/toutou/p/9675218.html&quot; target=&quot;_blank&quot;&gt;《CentOS部署SpringBoot项目》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;通过IntelliJ IDEA打包spring boot工程再部署到CentOS服务器，从0到1全部讲完了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 10 Oct 2018 13:45:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>在之前的博文《详解intellij idea搭建SpringBoot》介绍了idea搭建SpringBoot的详细过程， 并在《CentOS安装Tomcat》中介绍了Tomcat的安装，前面几篇文章实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/9675218.html</dc:identifier>
</item>
<item>
<title>深度学习（六）keras常用函数学习 - aircraft</title>
<link>http://www.cnblogs.com/DOMLX/p/9769301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DOMLX/p/9769301.html</guid>
<description>&lt;p&gt;&lt;span&gt;原文作者：aircraft&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原文链接：https://www.cnblogs.com/DOMLX/p/9769301.html&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;Keras是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Keras:基于Theano和TensorFlow的深度学习库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;span&gt;Keras是一个高层神经网络API，Keras由纯Python编写而成并基&lt;a href=&quot;https://baike.baidu.com/item/Tensorflow&quot; target=&quot;_blank&quot;&gt;Tensorflow&lt;/a&gt;、Theano以及CNTK后端。Keras 为支持快速实验而生，能够把你的idea迅速转换为结果，如果你有如下需求，请选择Keras：&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果还没有配置keras可以这个博客配置：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears &lt;code class=&quot;language-python&quot;&gt;Dense&lt;/code&gt;()函数--全连接层&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
keras.layers.core.Dense ( units, activation=None, &lt;br/&gt;　　　　　　　　　　　　　　　use_bias=True, &lt;br/&gt;　　　　　　　　　　　　　　　kernel_initializer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;glorot_uniform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;br/&gt;　　　　　　　　　　　　　　　bias_initializer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zeros&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;br/&gt;　　　　　　　　　　　　　　　kernel_regularizer=None, &lt;br/&gt;　　　　　　　　　　　　　　　bias_regularizer=None, &lt;br/&gt;　　　　　　　　　　　　　　　activity_regularizer=None, &lt;br/&gt;　　　　　　　　　　　　　　　kernel_constraint=None, &lt;br/&gt;　　　　　　　　　　　　　　　bias_constraint=None  )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/span&gt;：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;units：&lt;/em&gt;&lt;/strong&gt;大于0的整数，代表该层的输出维度。&lt;br/&gt;&lt;em&gt;&lt;strong&gt;activation：&lt;/strong&gt;&lt;/em&gt;激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）&lt;br/&gt;&lt;strong&gt;&lt;em&gt;use_bias:&lt;/em&gt;&lt;/strong&gt; 布尔值，是否使用偏置项&lt;br/&gt;&lt;strong&gt;&lt;em&gt;kernel_initializer：&lt;/em&gt;&lt;/strong&gt;权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers&lt;br/&gt;&lt;strong&gt;&lt;em&gt;bias_initializer：&lt;/em&gt;&lt;/strong&gt;权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers&lt;br/&gt;&lt;strong&gt;&lt;em&gt;kernel_regularizer：&lt;/em&gt;&lt;/strong&gt;施加在权重上的正则项，为Regularizer对象&lt;br/&gt;&lt;strong&gt;&lt;em&gt;bias_regularizer：&lt;/em&gt;&lt;/strong&gt;施加在偏置向量上的正则项，为Regularizer对象&lt;br/&gt;&lt;strong&gt;&lt;em&gt;activity_regularizer：&lt;/em&gt;&lt;/strong&gt;施加在输出上的正则项，为Regularizer对象&lt;br/&gt;&lt;strong&gt;&lt;em&gt;kernel_constraints：&lt;/em&gt;&lt;/strong&gt;施加在权重上的约束项，为Constraints对象&lt;br/&gt;&lt;strong&gt;&lt;em&gt;bias_constraints：&lt;/em&gt;&lt;/strong&gt;施加在偏置上的约束项，为Constraints对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;input_dim:&lt;/em&gt;&lt;/strong&gt;可以指定输入数据的维度&lt;/p&gt;

&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears Conv2D（）函数--卷积层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;若不懂卷积概念可看：&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/DOMLX/p/9579392.html&quot;&gt;深度学习（二）神经网络中的卷积和反卷积原理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;24&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Conv2D(filters, kernel_size, &lt;br/&gt;　　　　　　　　　　strides=(&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;1), &lt;br/&gt;　　　　　　　　　　padding=&lt;span class=&quot;hljs-string&quot;&gt;'valid',&lt;br/&gt;　　　　　　　　　　data_format=&lt;span class=&quot;hljs-keyword&quot;&gt;None, &lt;br/&gt;　　　　　　　　　　dilation_rate=(&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;1), &lt;br/&gt;　　　　　　　　　　activation=&lt;span class=&quot;hljs-keyword&quot;&gt;None, use_bias=&lt;span class=&quot;hljs-keyword&quot;&gt;True, &lt;br/&gt;　　　　　　　　　　kernel_initializer=&lt;span class=&quot;hljs-string&quot;&gt;'glorot_uniform', &lt;br/&gt;　　　　　　　　　　bias_initializer=&lt;span class=&quot;hljs-string&quot;&gt;'zeros', &lt;br/&gt;　　　　　　　　　　kernel_regularizer=&lt;span class=&quot;hljs-keyword&quot;&gt;None, &lt;br/&gt;　　　　　　　　　　bias_regularizer=&lt;span class=&quot;hljs-keyword&quot;&gt;None, &lt;br/&gt;　　　　　　　　　　activity_regularizer=&lt;span class=&quot;hljs-keyword&quot;&gt;None, &lt;br/&gt;　　　　　　　　　　kernel_constraint=&lt;span class=&quot;hljs-keyword&quot;&gt;None, &lt;br/&gt;　　　　　　　　　　bias_constraint=&lt;span class=&quot;hljs-keyword&quot;&gt;None)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;2D 卷积层 (例如对图像的空间卷积)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该层创建了一个卷积核， 该卷积核对层输入进行卷积， 以生成输出张量。 如果 &lt;code&gt;use_bias&lt;/code&gt; 为 True， 则会创建一个偏置向量并将其添加到输出中。 最后，如果 &lt;code&gt;activation&lt;/code&gt; 不是 &lt;code&gt;None&lt;/code&gt;，它也会应用于输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当使用该层作为模型第一层时，需要提供 &lt;code&gt;input_shape&lt;/code&gt; 参数 （整数元组，不包含样本表示的轴），例如， &lt;code&gt;input_shape=(128, 128, 3)&lt;/code&gt; 表示 128x128 RGB 图像， 在 &lt;code&gt;data_format=&quot;channels_last&quot;&lt;/code&gt; 时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;filters&lt;/strong&gt;: 整数，输出空间的维度 （即卷积中滤波器的输出数量）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;kernel_size&lt;/strong&gt;: 一个整数，或者 2 个整数表示的元组或列表， 指明 2D 卷积窗口的宽度和高度。 可以是一个整数，为所有空间维度指定相同的值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;strides&lt;/strong&gt;: 一个整数，或者 2 个整数表示的元组或列表， 指明卷积沿宽度和高度方向的步长。 可以是一个整数，为所有空间维度指定相同的值。 指定任何 stride 值 != 1 与指定 &lt;code&gt;dilation_rate&lt;/code&gt; 值 != 1 两者不兼容。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;padding&lt;/strong&gt;: &lt;code&gt;&quot;valid&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;same&quot;&lt;/code&gt; (大小写敏感)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;data_format&lt;/strong&gt;: 字符串， &lt;code&gt;channels_last&lt;/code&gt; (默认) 或 &lt;code&gt;channels_first&lt;/code&gt; 之一，表示输入中维度的顺序。 &lt;code&gt;channels_last&lt;/code&gt; 对应输入尺寸为 &lt;code&gt;(batch, height, width, channels)&lt;/code&gt;， &lt;code&gt;channels_first&lt;/code&gt; 对应输入尺寸为 &lt;code&gt;(batch, channels, height, width)&lt;/code&gt;。 它默认为从 Keras 配置文件 &lt;code&gt;~/.keras/keras.json&lt;/code&gt; 中 找到的 &lt;code&gt;image_data_format&lt;/code&gt; 值。 如果你从未设置它，将使用 &quot;channels_last&quot;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;dilation_rate&lt;/strong&gt;: 一个整数或 2 个整数的元组或列表， 指定膨胀卷积的膨胀率。 可以是一个整数，为所有空间维度指定相同的值。 当前，指定任何 &lt;code&gt;dilation_rate&lt;/code&gt; 值 != 1 与 指定 stride 值 != 1 两者不兼容。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;activation&lt;/strong&gt;: 要使用的激活函数 (详见 &lt;a href=&quot;https://keras.io/zh/activations/&quot;&gt;activations&lt;/a&gt;)。 如果你不指定，则不使用激活函数 (即线性激活： &lt;code&gt;a(x) = x&lt;/code&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;use_bias&lt;/strong&gt;: 布尔值，该层是否使用偏置向量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;kernel_initializer&lt;/strong&gt;: &lt;code&gt;kernel&lt;/code&gt; 权值矩阵的初始化器 (详见 &lt;a href=&quot;https://keras.io/zh/initializers/&quot;&gt;initializers&lt;/a&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;bias_initializer&lt;/strong&gt;: 偏置向量的初始化器 (详见 &lt;a href=&quot;https://keras.io/zh/initializers/&quot;&gt;initializers&lt;/a&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;kernel_regularizer&lt;/strong&gt;: 运用到 &lt;code&gt;kernel&lt;/code&gt; 权值矩阵的正则化函数 (详见 &lt;a href=&quot;https://keras.io/zh/regularizers/&quot;&gt;regularizer&lt;/a&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;bias_regularizer&lt;/strong&gt;: 运用到偏置向量的正则化函数 (详见 &lt;a href=&quot;https://keras.io/zh/regularizers/&quot;&gt;regularizer&lt;/a&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;activity_regularizer&lt;/strong&gt;: 运用到层输出（它的激活值）的正则化函数 (详见 &lt;a href=&quot;https://keras.io/zh/regularizers/&quot;&gt;regularizer&lt;/a&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;kernel_constraint&lt;/strong&gt;: 运用到 &lt;code&gt;kernel&lt;/code&gt; 权值矩阵的约束函数 (详见 &lt;a href=&quot;https://keras.io/zh/constraints/&quot;&gt;constraints&lt;/a&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;bias_constraint&lt;/strong&gt;: 运用到偏置向量的约束函数 (详见 &lt;a href=&quot;https://keras.io/zh/constraints/&quot;&gt;constraints&lt;/a&gt;)。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;输入尺寸&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果 data_format='channels_first'， 输入 4D 张量，尺寸为 &lt;code&gt;(samples, channels, rows, cols)&lt;/code&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果 data_format='channels_last'， 输入 4D 张量，尺寸为 &lt;code&gt;(samples, rows, cols, channels)&lt;/code&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;输出尺寸&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果 data_format='channels_first'， 输出 4D 张量，尺寸为 &lt;code&gt;(samples, filters, new_rows, new_cols)&lt;/code&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果 data_format='channels_last'， 输出 4D 张量，尺寸为 &lt;code&gt;(samples, new_rows, new_cols, filters)&lt;/code&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;别看上面的参数一堆吓死人，其实我们在实际运用的时候用的就只有几个而已：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
inputs = Input(shape=&lt;span&gt;(n_ch,patch_height,patch_width))
conv1 &lt;/span&gt;= Conv2D(32, (3, 3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data_format=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;channels_first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)(inputs)　　#这个小括号填inputs是代表这层模型连接在inputs之后
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然还可以用kears内置的序贯模型add添加构成模型图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
model =&lt;span&gt; Sequential()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Dense(64) is a fully-connected layer with 64 hidden units.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; in the first layer, you must specify the expected input data shape:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; here, 20-dimensional vectors.&lt;/span&gt;
model.add(Dense(64, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, input_dim=20))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;kears&lt;/span&gt; &lt;span&gt;MaxPooling2D&lt;/span&gt;&lt;span&gt;()函数--池化层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;若不懂池化概念可看：&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/DOMLX/p/9579108.html&quot;&gt;深度学习（一）神经网络中的池化与反池化原理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;




&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;keras.layers.pooling.MaxPooling2D( pool_size=(2, 2), strides=None, padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;valid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data_format=None )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;参数：&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;pool_size：&lt;/em&gt;&lt;/strong&gt;整数或长为2的整数tuple，代表在两个方向（竖直，水平）上的下采样因子，如取（2，2）将使图片在两个维度上均变为原长的一半。为整数意为各个维度值相同且为该数字。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;strides：&lt;/em&gt;&lt;/strong&gt;整数或长为2的整数tuple，或者None，步长值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;padding：&lt;/em&gt;&lt;/strong&gt;‘valid’或者‘same’&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;data_format：&lt;/em&gt;&lt;/strong&gt;字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;还是一样的好多东西默认就行了，下面就是一个2*2的池化层：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pool1 = MaxPooling2D((2, 2))(conv1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears  &lt;code class=&quot;language-python&quot;&gt;model.compile&lt;/code&gt;()函数--配置模型&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;model.compile(optimizer, loss, metrics=None, sample_weight_mode=None)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;编译用来配置模型的学习过程，其参数有&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;optimizer：&lt;/em&gt;&lt;/strong&gt;字符串（预定义优化器名）或优化器对象，参考优化器 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;loss：&lt;/em&gt;&lt;/strong&gt;字符串（预定义损失函数名）或目标函数，参考损失函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;metrics：&lt;/em&gt;&lt;/strong&gt;列表，包含评估模型在训练和测试时的网络性能的指标，典型用法是metrics=['accuracy']&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;sample_weight_mode：&lt;/strong&gt;&lt;/em&gt;如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。在下面fit函数的解释中有相关的参考内容。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;kwargs：&lt;/strong&gt;&lt;/em&gt;使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;model.compile(optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sgd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears  &lt;span&gt;model&lt;/span&gt;.&lt;code class=&quot;language-python&quot;&gt;fit&lt;/code&gt;()函数--模型运行函数&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;fit(self, x, y, batch_size=32, epochs=10, verbose=1, callbacks=None, validation_split=0.0,&lt;br/&gt;　　validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0 )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;x：&lt;/strong&gt;&lt;/em&gt;输入数据。如果模型只有一个输入，那么x的类型是numpy array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;y：&lt;/em&gt;&lt;/strong&gt;标签，numpy array&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;batch_size：&lt;/em&gt;&lt;/strong&gt;整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;epochs：&lt;/em&gt;&lt;/strong&gt;整数，训练的轮数，每个epoch会把训练集轮一遍。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;verbose：&lt;/em&gt;&lt;/strong&gt;日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;callbacks：&lt;/em&gt;&lt;/strong&gt;list，其中的元素是keras.callbacks.Callback的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考回调函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;validation_split：&lt;/em&gt;&lt;/strong&gt;0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之前，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;validation_data：&lt;/em&gt;&lt;/strong&gt;形式为（X，y）的tuple，是指定的验证集。此参数将覆盖validation_spilt。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;shuffle：&lt;/em&gt;&lt;/strong&gt;布尔值或字符串，一般为布尔值，表示是否在训练过程中随机打乱输入样本的顺序。若为字符串“batch”，则是用来处理HDF5数据的特殊情况，它将在batch内部将数据打乱。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;class_weight：&lt;/em&gt;&lt;/strong&gt;字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;sample_weight：&lt;/strong&gt;&lt;/em&gt;权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了sample_weight_mode='temporal'。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;initial_epoch:&lt;/em&gt;&lt;/strong&gt; 从该参数指定的epoch开始训练，在继续之前的训练时有用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参数虽多，但是很多都可以省略看代码示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;model.fit(patches_imgs_train, patches_masks_train, epochs=N_epochs, batch_size=batch_size, verbose=1, shuffle=True, validation_split=0.1, callbacks=[checkpointer])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;kears  predict()函数--测试数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;predictions = model.predict(patches_imgs_test, batch_size=32, verbose=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;predicted images size :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(predictions.shape)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears  load_weights()函数--直接导入训练好的模型&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载训练好的模型&lt;/span&gt;
model.load_weights(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./weights.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears  Dropout()函数--抛弃一些参数防止过拟合&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;Dropout（x）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;X可以取0--1之间，代表百分比抛弃数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Dropout（0.5）随机抛弃百分之五十的数据&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears UpSampling2D()函数--上采样函数&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
UpSampling2D(size=(2, 2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;size(x,y)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x代表行放大倍数  这里取2的话代表原来的一行变成了两行 （就是一行那么粗，变成了两行那么粗）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y&lt;span&gt;代表列放大倍数  &lt;span&gt;这里取2的话代表原来的一&lt;span&gt;列&lt;/span&gt;变成了两行 （就是一&lt;span&gt;列&lt;/span&gt;那么粗，变成了两&lt;span&gt;列&lt;/span&gt;那么粗）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;size(2,2)其实就等于将原图放大四倍（水平两倍，垂直两倍） 32*32 变成 62*64的图像&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears Model()函数--代表模型图&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;133&quot;&gt;
&lt;pre&gt;
&lt;span&gt;inputs =&lt;span&gt; Input((n_ch, patch_height, patch_width))
    conv1 &lt;/span&gt;= Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(inputs)
    conv1 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv1)
    conv1 &lt;/span&gt;= Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv1)
    up1 &lt;/span&gt;= UpSampling2D(size=(2, 2&lt;span&gt;))(conv1)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    conv2 = Convolution2D(16, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(up1)
    conv2 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv2)
    conv2 &lt;/span&gt;= Convolution2D(16, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv2)
    pool1 &lt;/span&gt;= MaxPooling2D(pool_size=(2, 2&lt;span&gt;))(conv2)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    conv3 = Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(pool1)
    conv3 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv3)
    conv3 &lt;/span&gt;= Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv3)
    pool2 &lt;/span&gt;= MaxPooling2D(pool_size=(2, 2&lt;span&gt;))(conv3)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    conv4 = Convolution2D(64, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(pool2)
    conv4 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv4)
    conv4 &lt;/span&gt;= Convolution2D(64, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv4)
    pool3 &lt;/span&gt;= MaxPooling2D(pool_size=(2, 2&lt;span&gt;))(conv4)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    conv5 = Convolution2D(128, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(pool3)
    conv5 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv5)
    conv5 &lt;/span&gt;= Convolution2D(128, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv5)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    up2 = merge([UpSampling2D(size=(2, 2))(conv5), conv4], mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;concat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, concat_axis=1&lt;span&gt;)
    conv6 &lt;/span&gt;= Convolution2D(64, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(up2)
    conv6 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv6)
    conv6 &lt;/span&gt;= Convolution2D(64, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv6)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    up3 = merge([UpSampling2D(size=(2, 2))(conv6), conv3], mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;concat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, concat_axis=1&lt;span&gt;)
    conv7 &lt;/span&gt;= Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(up3)
    conv7 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv7)
    conv7 &lt;/span&gt;= Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv7)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    up4 = merge([UpSampling2D(size=(2, 2))(conv7), conv2], mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;concat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, concat_axis=1&lt;span&gt;)
    conv8 &lt;/span&gt;= Convolution2D(16, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(up4)
    conv8 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv8)
    conv8 &lt;/span&gt;= Convolution2D(16, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv8)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    pool4 = MaxPooling2D(pool_size=(2, 2&lt;span&gt;))(conv8)
    conv9 &lt;/span&gt;= Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(pool4)
    conv9 &lt;/span&gt;= Dropout(0.2&lt;span&gt;)(conv9)
    conv9 &lt;/span&gt;= Convolution2D(32, 3, 3, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv9)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    conv10 = Convolution2D(2, 1, 1, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, border_mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv9)
    conv10 &lt;/span&gt;= core.Reshape((2,patch_height*&lt;span&gt;patch_width))(conv10)
    conv10 &lt;/span&gt;= core.Permute((2,1&lt;span&gt;))(conv10)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###########&lt;/span&gt;
    conv10 = core.Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(conv10)

    model &lt;/span&gt;= Model(input=inputs, output=conv10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;将模型的输入和输出给model函数就会自己组建模型运行图结构&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears Embedding()函数--嵌入层&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;keras.layers.embeddings.Embedding( input_dim, output_dim, embeddings_initializer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uniform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　embeddings_regularizer=None, activity_regularizer=None, embeddings_constraint=None, mask_zero=False, input_length=None)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;作用：嵌入层将正整数（下标）转换为具有固定大小的向量，如[[4],[20]]-&amp;gt;[[0.25,0.1],[0.6,-0.2]]。Embedding层只能作为模型的第一层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;input_dim：&lt;/strong&gt;&lt;/em&gt;大或等于0的整数，字典长度，即输入数据最大下标+1，就是矩阵中的最大值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;output_dim：&lt;/em&gt;&lt;/strong&gt;大于0的整数，代表全连接嵌入的维度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;embeddings_initializer:&lt;/em&gt;&lt;/strong&gt; 嵌入矩阵的初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;embeddings_regularizer:&lt;/em&gt;&lt;/strong&gt; 嵌入矩阵的正则项，为Regularizer对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;embeddings_constraint:&lt;/em&gt;&lt;/strong&gt; 嵌入矩阵的约束项，为Constraints对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;mask_zero：&lt;/em&gt;&lt;/strong&gt;布尔值，确定是否将输入中的‘0’看作是应该被忽略的‘填充’（padding）值，该参数在使用递归层处理变长输入时有用。设置为True的话，模型中后续的层必须都支持masking，否则会抛出异常。如果该值为True，则下标0在字典中不可用，input_dim应设置为|vocabulary| + 2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;input_length：&lt;/em&gt;&lt;/strong&gt;当输入序列的长度固定时，该值为其长度。如果要在该层后接Flatten层，然后接Dense层，则必须指定该参数，否则Dense层的输出维度无法自动推断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于embeding作用的详细介绍：&lt;a href=&quot;http://spaces.ac.cn/archives/4122/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://spaces.ac.cn/archives/4122/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;




&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears normalization()函数--标准化&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
keras.layers.normalization.BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001, center=True, &lt;br/&gt;scale=True, beta_initializer=&lt;span&gt;'&lt;span&gt;zeros&lt;span&gt;', gamma_initializer=&lt;span&gt;'&lt;span&gt;ones&lt;span&gt;', moving_mean_initializer=&lt;span&gt;'&lt;span&gt;zeros&lt;span&gt;',&lt;br/&gt;moving_variance_initializer=&lt;span&gt;'&lt;span&gt;ones&lt;span&gt;', beta_regularizer=None, gamma_regularizer=None,&lt;br/&gt;beta_constraint=None, gamma_constraint=None)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;该层在每个batch上将前一层的激活值重新规范化，即使得其输出数据的均值接近0，其标准差接近1&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_1&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;axis: 整数，指定要规范化的轴，通常为特征轴。例如在进行&lt;code&gt;data_format=&quot;channels_first&lt;/code&gt;的2D卷积后，一般会设axis=1。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;momentum: 动态均值的动量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;epsilon：大于0的小浮点数，用于防止除0错误&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;center: 若设为True，将会将beta作为偏置加上去，否则忽略参数beta&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;scale: 若设为True，则会乘以gamma，否则不使用gamma。当下一层是线性的时，可以设False，因为scaling的操作将被下一层执行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;beta_initializer：beta权重的初始方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;gamma_initializer: gamma的初始化方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;moving_mean_initializer: 动态均值的初始化方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;moving_variance_initializer: 动态方差的初始化方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;beta_regularizer: 可选的beta正则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;gamma_regularizer: 可选的gamma正则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;beta_constraint: 可选的beta约束&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;gamma_constraint: 可选的gamma约束&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;shape&quot;&gt;&lt;span&gt;输入shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;任意，当使用本层为模型首层时，指定&lt;code&gt;input_shape&lt;/code&gt;参数时有意义。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;shape_1&quot;&gt;&lt;span&gt;输出shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;与输入shape相同&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears plot()函数--画出模型图&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;plot(model, to_file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+name_experiment+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+name_experiment + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_model.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;&lt;strong&gt;kears中可以将自己建立的模型图画出来，传进去一个模型，指定画出文件的路径和名字即可&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;



&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears ModelCheckpoint()函数--保存模型参数&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;checkpointer = ModelCheckpoint(filepath=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+name_experiment+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+name_experiment +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_best_weights.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, verbose=1, monitor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;val_loss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, save_best_only=&lt;span&gt;True)

model.fit(patches_imgs_train, patches_masks_train, epochs&lt;/span&gt;=N_epochs, batch_size=batch_size, verbose=1, shuffle=True, validation_split=0.1, callbacks=[checkpointer])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;ModelCheckpoint函数可以指定一定训练次数后保存中间训练的最佳参数&lt;/span&gt;
&lt;/pre&gt;



&lt;pre&gt;
&lt;span&gt;ModelCheckpoint函数作为&lt;span&gt;model.fit&lt;/span&gt;（）函数中回调函数使用&lt;/span&gt;
&lt;/pre&gt;




&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears merge()函数--融合层&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;Merge层提供了一系列用于融合两个层或两个张量的层对象和方法。以大写首字母开头的是Layer类，以小写字母开头的是张量的函数。小写字母开头的张量函数在内部实际上是调用了大写字母开头的层。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;add&quot;&gt;&lt;span&gt;Add&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Add()
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;添加输入列表的图层。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;该层接收一个相同shape列表张量，并返回它们的和，shape不变。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import keras

input1 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;16,))
x1 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input1)
input2 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;32,))
x2 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input2)
added = keras.layers.Add()([x1, x2])  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;substract&quot;&gt;&lt;span&gt;SubStract&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Subtract()
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;两个输入的层相减。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;它将大小至少为2，相同Shape的列表张量作为输入，并返回一个张量（输入[0] - 输入[1]），也是相同的Shape。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;example_1&quot;&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import keras

input1 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;16,))
x1 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input1)
input2 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;32,))
x2 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;multiply&quot;&gt;&lt;span&gt;Multiply&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Multiply()
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;该层接收一个列表的同shape张量，并返回它们的逐元素积的张量，shape不变。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;average&quot;&gt;&lt;span&gt;Average&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Average()
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;该层接收一个列表的同shape张量，并返回它们的逐元素均值，shape不变。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;maximum&quot;&gt;&lt;span&gt;Maximum&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Maximum()
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;该层接收一个列表的同shape张量，并返回它们的逐元素最大值，shape不变。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;concatenate&quot;&gt;&lt;span&gt;Concatenate&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Concatenate(axis=-&lt;span class=&quot;hljs-number&quot;&gt;1)
&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;该层接收一个列表的同shape张量，并返回它们的按照给定轴相接构成的向量。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_1&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;axis: 想接的轴&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;dot&quot;&gt;&lt;span&gt;Dot&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.Dot(axes, normalize=&lt;span class=&quot;hljs-keyword&quot;&gt;False)
&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;计算两个tensor中样本的张量乘积。例如，如果两个张量&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;的shape都为（batch_size, n），则输出为形如（batch_size,1）的张量，结果张量每个batch的数据都是a[i,:]和b[i,:]的矩阵（向量）点积。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_2&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;axes: 整数或整数的tuple，执行乘法的轴。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;normalize: 布尔值，是否沿执行成绩的轴做L2规范化，如果设为True，那么乘积的输出是两个样本的余弦相似性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;add_1&quot;&gt;&lt;span&gt;add&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.add(inputs)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;Add层的函数式包装&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_3&quot;&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;inputs: 长度至少为2的张量列表A&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_4&quot;&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;输入列表张量之和&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;example_2&quot;&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import keras

input1 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;16,))
x1 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input1)
input2 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;32,))
x2 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input2)
added = keras.layers.add([x1, x2])

out = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;4)(added)
model = keras.models.Model(inputs=[input1, input2], outputs=out)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;subtract&quot;&gt;&lt;span&gt;subtract&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.subtract(inputs)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;Subtract层的函数式包装&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_5&quot;&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;inputs: 长度至少为2的张量列表A&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_6&quot;&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;输入张量列表的差别&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;example_3&quot;&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import keras

input1 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;16,))
x1 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input1)
input2 = keras.layers.Input(shape=(&lt;span class=&quot;hljs-number&quot;&gt;32,))
x2 = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;8, activation=&lt;span class=&quot;hljs-string&quot;&gt;'relu')(input2)
subtracted = keras.layers.subtract([x1, x2])

out = keras.layers.Dense(&lt;span class=&quot;hljs-number&quot;&gt;4)(subtracted)
model = keras.models.Model(inputs=[input1, input2], outputs=out)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;multiply_1&quot;&gt;&lt;span&gt;multiply&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.multiply(inputs)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;Multiply的函数式包装&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_7&quot;&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;inputs: 长度至少为2的张量列表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_8&quot;&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;输入列表张量之逐元素积&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;average_1&quot;&gt;&lt;span&gt;average&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.average(inputs)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;Average的函数包装&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_9&quot;&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;inputs: 长度至少为2的张量列表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_10&quot;&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;输入列表张量之逐元素均值&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;maximum_1&quot;&gt;&lt;span&gt;maximum&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.maximum(inputs)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;Maximum的函数包装&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_11&quot;&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;inputs: 长度至少为2的张量列表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_12&quot;&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;输入列表张量之逐元素均值&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;concatenate_1&quot;&gt;&lt;span&gt;concatenate&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.concatenate(inputs, axis=-&lt;span class=&quot;hljs-number&quot;&gt;1)
&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;Concatenate的函数包装&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_13&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;inputs: 长度至少为2的张量列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;axis: 相接的轴&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;dot_1&quot;&gt;&lt;span&gt;dot&lt;/span&gt;&lt;/h2&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.dot(inputs, axes, normalize=&lt;span class=&quot;hljs-keyword&quot;&gt;False)
&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;Dot的函数包装&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_14&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;inputs: 长度至少为2的张量列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;axes: 整数或整数的tuple，执行乘法的轴。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;normalize: 布尔值，是否沿执行成绩的轴做L2规范化，如果设为True，那么乘积的输出是两个样本的余弦相似性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;**kwargs: 普通的Layer关键字参数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;h3 id=&quot;conv2d&quot;&gt;&lt;span&gt;kears core()模块函数--常用层&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;h2 id=&quot;activation&quot;&gt;Activation层&lt;/h2&gt;



&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.Activation(activation)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;激活层对一个层的输出施加激活函数&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_5&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;activation：将要使用的激活函数，为预定义激活函数名或一个Tensorflow/Theano的函数。参考&lt;a href=&quot;https://keras-cn.readthedocs.io/en/latest/other/activations&quot;&gt;激活函数&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;shape&quot;&gt;&lt;span&gt;输入shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;任意，当使用激活层作为第一层时，要指定&lt;code&gt;input_shape&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;shape_1&quot;&gt;&lt;span&gt;输出shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;与输入shape相同&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;dropout&quot;&gt;&lt;span&gt;Dropout层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.Dropout(rate, noise_shape=&lt;span class=&quot;hljs-keyword&quot;&gt;None, seed=&lt;span class=&quot;hljs-keyword&quot;&gt;None)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;为输入数据施加Dropout。Dropout将在训练过程中每次更新参数时按一定概率（rate）随机断开输入神经元，Dropout层用于防止过拟合。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_6&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;rate：0~1的浮点数，控制需要断开的神经元的比例&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;noise_shape：整数张量，为将要应用在输入上的二值Dropout mask的shape，例如你的输入为(batch_size, timesteps, features)，并且你希望在各个时间步上的Dropout mask都相同，则可传入noise_shape=(batch_size, 1, features)。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;seed：整数，使用的随机数种子&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_7&quot;&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h3&gt;


&lt;hr/&gt;
&lt;h2 id=&quot;flatten&quot;&gt;&lt;span&gt;Flatten层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.Flatten()
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_8&quot;&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;model = Sequential()
model.add(Convolution2D(&lt;span class=&quot;hljs-number&quot;&gt;64, &lt;span class=&quot;hljs-number&quot;&gt;3, &lt;span class=&quot;hljs-number&quot;&gt;3,
            border_mode=&lt;span class=&quot;hljs-string&quot;&gt;'same',
            input_shape=(&lt;span class=&quot;hljs-number&quot;&gt;3, &lt;span class=&quot;hljs-number&quot;&gt;32, &lt;span class=&quot;hljs-number&quot;&gt;32)))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;reshape&quot;&gt;&lt;span&gt;Reshape层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.Reshape(target_shape)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;Reshape层用来将输入shape转换为特定的shape&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_9&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;target_shape：目标shape，为整数的tuple，不包含样本数目的维度（batch大小）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;shape_2&quot;&gt;&lt;span&gt;输入shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;任意，但输入的shape必须固定。当使用该层为模型首层时，需要指定&lt;code&gt;input_shape&lt;/code&gt;参数&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;shape_3&quot;&gt;&lt;span&gt;输出shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;code&gt;(batch_size,)+target_shape&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_10&quot;&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;permute&quot;&gt;&lt;span&gt;Permute层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.Permute(dims)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;Permute层将输入的维度按照给定模式进行重排，例如，当需要将RNN和CNN网络连接时，可能会用到该层。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_11&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;dims：整数tuple，指定重排的模式，不包含样本数的维度。重拍模式的下标从1开始。例如（2，1）代表将输入的第二个维度重拍到输出的第一个维度，而将输入的第一个维度重排到第二个维度&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_12&quot;&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;model = Sequential()
model.add(Permute((&lt;span class=&quot;hljs-number&quot;&gt;2, &lt;span class=&quot;hljs-number&quot;&gt;1), input_shape=(&lt;span class=&quot;hljs-number&quot;&gt;10, &lt;span class=&quot;hljs-number&quot;&gt;64)))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h3 id=&quot;shape_4&quot;&gt;&lt;span&gt;输入shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;任意，当使用激活层作为第一层时，要指定&lt;code&gt;input_shape&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;shape_5&quot;&gt;&lt;span&gt;输出shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;与输入相同，但是其维度按照指定的模式重新排列&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;repeatvector&quot;&gt;&lt;span&gt;RepeatVector层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.RepeatVector(n)
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;RepeatVector层将输入重复n次&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_13&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;n：整数，重复的次数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;shape_6&quot;&gt;&lt;span&gt;输入shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;形如（nb_samples, features）的2D张量&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;shape_7&quot;&gt;&lt;span&gt;输出shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;形如（nb_samples, n, features）的3D张量&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_14&quot;&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;model = Sequential()
model.add(Dense(&lt;span class=&quot;hljs-number&quot;&gt;32, input_dim=&lt;span class=&quot;hljs-number&quot;&gt;32))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;lambda&quot;&gt;&lt;span&gt;Lambda层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.Lambda(function, output_shape=&lt;span class=&quot;hljs-keyword&quot;&gt;None, mask=&lt;span class=&quot;hljs-keyword&quot;&gt;None, arguments=&lt;span class=&quot;hljs-keyword&quot;&gt;None)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;本函数用以对上一层的输出施以任何Theano/TensorFlow表达式&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_15&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;

&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;function：要实现的函数，该函数仅接受一个变量，即上一层的输出&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;output_shape：函数应该返回的值的shape，可以是一个tuple，也可以是一个根据输入shape计算输出shape的函数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;mask: 掩膜&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;arguments：可选，字典，用来记录向函数中传递的其他关键字参数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;_16&quot;&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h3&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;shape_8&quot;&gt;&lt;span&gt;输入shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;任意，当使用该层作为第一层时，要指定&lt;code&gt;input_shape&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;shape_9&quot;&gt;&lt;span&gt;输出shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;由&lt;code&gt;output_shape&lt;/code&gt;参数指定的输出shape，当使用tensorflow时可自动推断&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;activityregularizer&quot;&gt;&lt;span&gt;ActivityRegularizer层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.ActivityRegularization(l1=&lt;span class=&quot;hljs-number&quot;&gt;0.0, l2=&lt;span class=&quot;hljs-number&quot;&gt;0.0)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;经过本层的数据不会有任何变化，但会基于其激活值更新损失函数值&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_17&quot;&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;


&lt;h3 id=&quot;shape_10&quot;&gt;&lt;span&gt;输入shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;任意，当使用该层作为第一层时，要指定&lt;code&gt;input_shape&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;shape_11&quot;&gt;&lt;span&gt;输出shape&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;与输入shape相同&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;masking&quot;&gt;&lt;span&gt;Masking层&lt;/span&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;keras.layers.core.Masking(mask_value=&lt;span class=&quot;hljs-number&quot;&gt;0.0)
&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;使用给定的值对输入的序列信号进行“屏蔽”，用以定位需要跳过的时间步&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于输入张量的时间步，即输入张量的第1维度（维度从0开始算，见例子），如果输入张量在该时间步上都等于&lt;code&gt;mask_value&lt;/code&gt;，则该时间步将在模型接下来的所有层（只要支持masking）被跳过（屏蔽）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果模型接下来的一些层不支持masking，却接受到masking过的数据，则抛出异常。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;_18&quot;&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;考虑输入数据&lt;code&gt;x&lt;/code&gt;是一个形如(samples,timesteps,features)的张量，现将其送入LSTM层。因为你缺少时间步为3和5的信号，所以你希望将其掩盖。这时候应该：&lt;/span&gt;&lt;/p&gt;

&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;赋值&lt;code&gt;x[:,3,:] = 0.&lt;/code&gt;，&lt;code&gt;x[:,5,:] = 0.&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;在LSTM层之前插入&lt;code&gt;mask_value=0.&lt;/code&gt;的&lt;code&gt;Masking&lt;/code&gt;层&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;model = Sequential()
model.add(Masking(mask_value=&lt;span class=&quot;hljs-number&quot;&gt;0., input_shape=(timesteps, features)))
model.add(LSTM(&lt;span class=&quot;hljs-number&quot;&gt;32))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt; &lt;span&gt;&lt;code class=&quot;python hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;参考网址链接：https://keras-cn.readthedocs.io/en/latest/&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Oct 2018 13:40:00 +0000</pubDate>
<dc:creator>aircraft</dc:creator>
<og:description>原文作者：aircraft 原文链接：https://www.cnblogs.com/DOMLX/p/9769301.html Keras是什么？ Keras:基于Theano和TensorFlow的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DOMLX/p/9769301.html</dc:identifier>
</item>
</channel>
</rss>