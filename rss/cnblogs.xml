<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>读懂 Deployment YAML - 每天5分钟玩转 Docker 容器技术（125） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8370501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8370501.html</guid>
<description>&lt;p&gt;&lt;span&gt;既然要用 YAML 配置文件部署应用，现在就很有必要了解一下 Deployment 的配置格式，其他 Controller（比如 DaemonSet）非常类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是以 nginx-deployment 为例，配置文件如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180128073317787-1529765995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① &lt;/span&gt;&lt;code&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是当前配置格式的版本。&lt;br/&gt;② &lt;/span&gt;&lt;code&gt;&lt;span&gt;kind&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是要创建的资源类型，这里是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;br/&gt;③ &lt;/span&gt;&lt;code&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是该资源的元数据，&lt;/span&gt;&lt;code&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是必需的元数据项。&lt;br/&gt;④ &lt;/span&gt;&lt;code&gt;&lt;span&gt;spec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 部分是该 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的规格说明。&lt;br/&gt;⑤ &lt;/span&gt;&lt;code&gt;&lt;span&gt;replicas&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指明副本数量，默认为 1。&lt;br/&gt;⑥ &lt;/span&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义 Pod 的模板，这是配置文件的重要部分。&lt;br/&gt;⑦ &lt;/span&gt;&lt;code&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义 Pod 的元数据，至少要定义一个 label。label 的 key 和 value 可以任意指定。&lt;br/&gt;⑧ &lt;/span&gt;&lt;code&gt;&lt;span&gt;spec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 描述 Pod 的规格，此部分定义 Pod 中每一个容器的属性，&lt;/span&gt;&lt;code&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;image&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是必需的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此 nginx.yml 是一个最简单的 Deployment 配置文件，后面我们学习 Kubernetes 各项功能时会逐步丰富这个文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply -f nginx.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180128073334115-835645213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;部署成功。同样地，通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的各种资源：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180128073349522-2020122446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Deployment、ReplicaSet、Pod 都已经就绪。如果要删除这些资源，执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl delete deployment nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl delete -f nginx.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180128073419725-1668476532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节讨论 Deployment 的 Scale Up/Down。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jan 2018 23:21:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8370501.html</dc:identifier>
</item>
<item>
<title>为什么选择.NETCore？ - Chaunce</title>
<link>http://www.cnblogs.com/xiaoliangge/p/8373100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoliangge/p/8373100.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;在开展话题之前先出一张ASP.NETCore VS  Node.js的性能对比图  &lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=csharpcore&amp;amp;lang2=node&quot; target=&quot;_blank&quot;&gt;ASP.NET Core  VS  node.js&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/578477/201801/578477-20180129002920334-590888559.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;继续正文：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;学习新的开发框架是一项巨大的投资。&lt;/span&gt;&lt;span&gt;您需要学习如何在新框架中编写，构建，测试，部署和维护应用程序。&lt;/span&gt;&lt;span&gt;作为开发人员，有许多框架可供选择，很难知道什么是最适合的。&lt;/span&gt;&lt;span&gt;即使您正在使用.NET开发软件，.NET Core也不相同，您需要花时间学习使用它的工具和技术。&lt;/span&gt;&lt;span&gt;为了理解为什么.NET Core值得一看，这有助于知道你从哪里开始。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;如果您是.NET Framework开发人员&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Core是为了重新启动某些Framework组件而为其他人提供跨平台工作的机会。&lt;/span&gt;&lt;span&gt;由于.NET Framework主要以托管（C＃）代码为基础构建，因此这些部分不需要更改代码即可移至.NET Core。&lt;/span&gt;&lt;span&gt;依赖于Windows特定组件的库必须被移除或重构以使用跨平台替代方案。&lt;/span&gt;&lt;span&gt;这同样适用于您的应用程序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;您的.NET应用程序可以是跨平台的&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;您现有的.NET Framework应用程序可以在其他操作系统上工作。&lt;/span&gt;&lt;span&gt;对于希望扩大类库的受众平台，或者希望在分布式应用程序的其他领域使用相同代码的开发人员来说，这是非常好的选择。&lt;/span&gt;&lt;span&gt;即使你想用你亮瞎眼的MacBook上开发.NET，而无需双启动到Windows。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;并不是所有的框架都被移植到.NET Core，但主要的部分。&lt;/span&gt;&lt;span&gt;存在一些API差异。&lt;/span&gt;&lt;span&gt;例如，如果您使用了大量的反射，则可能需要重构代码才能使用Core。&lt;/span&gt;&lt;span&gt;有关更多信息，请看文章末尾的的两者差异部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;ASP.NETCore胜过框架ASP.NET&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;ASP.NET Core和ASP.NET之间的性能差异是几个数量级&lt;/strong&gt;&lt;/em&gt;。&lt;/span&gt;&lt;span&gt;&lt;span&gt;大部分的ASP.NET被传统的System.Web库所&lt;/span&gt;限制。&lt;/span&gt;&lt;span&gt;.NET Framework支持旧版本的ASP.NET项目，而且这个约束限制了ASP.NET的发展。&lt;/span&gt;&lt;span&gt;微软决定重写整个架构。&lt;/span&gt;&lt;span&gt;这意味着打破变化，但结果是值得的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;.NETCore是创新的焦点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;向后兼容性是一把双刃剑。&lt;/span&gt;&lt;span&gt;这意味着您的应用程序可以继续得到新版本框架的支持，&lt;/span&gt;&lt;span&gt;确保在新版本框架中所做的更改不会破坏现有的应用程序。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所有的努力避免变化都限制了框架的创新。&lt;/span&gt;&lt;span&gt;框架的变化需要彻底的理由（通常来自客户），详尽的测试以及来自多个层次产品组的批准。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用.NET Core，团队可以更容易专注的在.net core上工作。比如&lt;/span&gt;&lt;span&gt;核心类库（如System.Collections）的更改仍然需要与.NET Framework相同的活力，但是ASP.NET Core或Entity Framework Core可以更轻松地进行实质性更改，而不受向后兼容性的限制。&lt;/span&gt;&lt;span&gt;这允许更大的创新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Framework作为一个整体产品发布，但是Core被分解成多个部分。&lt;/span&gt;&lt;span&gt;现在开发人员可以选择使用哪个版本的库，只要它在.NET标准库之外，.NET Core团队就可以用较少的难度进行创新。&lt;/span&gt;&lt;span&gt;这就是为什么在将来你只能看到错误修复的框架; .net core将&lt;/span&gt;&lt;span&gt;获得所有新功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;发布周期更快&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果您曾在框架中遇到错误，并将其报告给Microsoft，则您将知道发布修复需要多长时间。&lt;/span&gt;&lt;span&gt;这个框架有很长的发布周期，通常至少要测量一年，而且在这些周期中还有很小的窗口用于特性工作。&lt;/span&gt;&lt;span&gt;每个代码更改都可能会导致框架中其他位置出现意外的问题。&lt;/span&gt;&lt;span&gt;为了给每个团队足够的时间来测试框架，有很多时候代码更改是受限制的或者严格审查的。&lt;/span&gt;&lt;span&gt;如果您在.NET中发现了一个错误，最好找到一个解决方法，而不是等待更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Core遵循更快的发布步调。&lt;/span&gt;&lt;span&gt;开发人员可以使用夜间构建来尽早测试。&lt;/span&gt;&lt;span&gt;不属于.NET标准库的库可以按自己的步调发布。&lt;/span&gt;&lt;span&gt;因为所有东西都是开源的，如果微软没有足够快的响应，任何开发者都可以提出修补。&lt;/span&gt;&lt;span&gt;如果解决方法不被接受，讨论就会公开进行，所有人都可以看到为什么做出这个决定&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;如果你是.NET新手&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在Windows平台上，.NET框架没有太多的竞争。&lt;/span&gt;&lt;span&gt;微软可以对从操作系统内核层到高级.NET库的所有内容进行更改。&lt;/span&gt;&lt;span&gt;通过将.NET引入其他平台，竞争环境发生了变化。&lt;/span&gt;&lt;span&gt;.NET现在必须与其他所有的开发框架竞争。&lt;/span&gt;&lt;span&gt;这里有一些东西，使.NET分开。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;C＃是一个了不起的语言&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET的旗舰语言C＃具有许多独特的功能，例如语言集成查询和异步构造，这使得它强大且易于使用。&lt;/span&gt;&lt;span&gt;C＃也在不断创新。&lt;/span&gt;&lt;span&gt;C＃团队公开设计语言，因为他们希望任何人提出建议或参与讨论。&lt;/span&gt;&lt;span&gt;编译器（Roslyn）完全是模块化和可扩展的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;ASP.NET Core性能与顶级Web平台相当&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果您正在编写Web应用程序或服务，那么ASP.NET Core是一个很好的搭建平台。&lt;/span&gt;&lt;span&gt;它具有出色的性能和低内存占用。&lt;/span&gt;&lt;span&gt;许多功能可以使您的应用程序更容易开发和维护。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;.NET Core不是从头开始的&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET在2000年以前就已经出现了。框架代码在过去几年中已经得到了巩固，开发人员也从中受益。&lt;/span&gt;&lt;span&gt;已经被移植到Core的大部分Framework代码都没有改变。&lt;/span&gt;&lt;span&gt;这使.NET Core在构建应用程序的可靠框架方面领先一步。&lt;/span&gt;&lt;span&gt;.NET Core也完全由Microsoft支持。&lt;/span&gt;&lt;span&gt;支持可能会阻碍一些组织采用开源软件。&lt;/span&gt;&lt;span&gt;这降低了为您的应用程序使用Core的风险。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;什么是.NETCore？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了理解.NET Core，它有助于理解.NET Framework。&lt;/span&gt;&lt;span&gt;微软在21世纪初发布了.NET Framework。&lt;/span&gt;&lt;span&gt;.NET Framework是一个仅限于Windows的开发框架，它在最底层提供了内存管理，安全性，异常处理和许多其他功能。&lt;/span&gt;&lt;span&gt;.NET框架附带一大堆库，可执行从XML解析到HTTP请求的各种功能。&lt;/span&gt;&lt;span&gt;它还支持几种语言，并将它们编译成相同的通用中间语言; &lt;/span&gt;&lt;span&gt;任何语言都可以使用任何其他语言构建的库。&lt;/span&gt;&lt;span&gt;这些关键概念也出现在.NET Core中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2016年，微软收购了Xamarin并发布了.NET Core 1.0。&lt;/span&gt;&lt;span&gt;之前Xamarin已经移植了.NET框架的大部分内容来运行在基于Linux / Unix的操作系统上。&lt;/span&gt;&lt;span&gt;一些代码可以在.NET Framework，Xamarin和新的.NET Core之间共享，但编译后的二进制文件不能。&lt;/span&gt;&lt;span&gt;.NET Core的一部分努力是创建一个标准化的平台，允许所有.NET实现共享相同的库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img class=&quot;alignnone size-medium wp-image-2492 aligncenter&quot; src=&quot;http://freecontent.manning.com/wp-content/uploads/Metzgar_WhyNetCore_01-300x183.png&quot; alt=&quot;metzgar_whynetcore_01&quot; width=&quot;322&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; .NET框架，.NET Core和Xamarin都共享一个称为.NET标准库的标准化平台&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以前的Xamarin和.NET Framework之间是无法共享二进制文件的。&lt;/span&gt;&lt;span&gt;随着.NET标准库和通用基础架构的推出，这两个框架现在成为统一的.NET生态系统的一部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;什么是.NETCore？&lt;/span&gt;&lt;span&gt;在上图中，似乎.NET Core是另一个包含UWP（通用Windows平台）和ASP.NET Core的框架。&lt;/span&gt;&lt;span&gt;为了使.NET Core成为现实，创建了.NET标准库和通用基础架构。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;.NETCore的关键功能&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Core借鉴了.NET Framework的最佳实践，并将软件工程的最新进展结合在一起。&lt;/span&gt;&lt;span&gt;这些是.NET Core的一些显着特征。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;扩大您类库的覆盖面&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用.NET Core，您可以使用.NET标准库编写应用程序或库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后它可以在许多平台上共享。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;alignnone size-medium wp-image-2493 aligncenter&quot; src=&quot;http://freecontent.manning.com/wp-content/uploads/Metzgar_WhyNetCore_02.png&quot; alt=&quot;metzgar_whynetcore_02&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; .NETCore开发&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;同一个库可以在后台服务“本地”或云中运行，也可以在手机，平板电脑或桌面上运行的客户端应用程序中运行。&lt;/span&gt;&lt;span&gt;与其为iOS，Android和Windows构建单独的应用程序，您可以构建一个适用于所有平台的应用程序。&lt;/span&gt;&lt;span&gt;.NET Core是小型和完美的容器，可以轻松扩展并缩短开发时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Core和.NET Standard Library建立了一个通用平台。&lt;/span&gt;&lt;span&gt;过去，当新版本的操作系统或新设备出现时，开发人员有责任重新构建新平台的应用程序或库，并分发更新。&lt;/span&gt;&lt;span&gt;使用.NET Core，不需要重建和重新分配。&lt;/span&gt;&lt;span&gt;只要新的平台支持你所有的依赖库，它就支持你的应用程序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;在任何平台上简单部署&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Microsoft产品往往具有复杂的安装过程。&lt;/span&gt;&lt;span&gt;COM组件，注册表项，特殊文件夹，GAC - 都是为了利用Windows的特性而设计的。&lt;/span&gt;&lt;span&gt;.NET框架依赖于这些构造，这使得它不适合其他操作系统。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在发布依赖于.NET Framework的应用程序时，安装程​​序必须足够聪明才能检测是否安装了错误的.NET Framework版本，并为用户提供正确的方法。&lt;/span&gt;&lt;span&gt;大多数现代Windows版本都包含.NET Framework。&lt;/span&gt;&lt;span&gt;这使得某些应用程序更容易安装，但是如果应用程序使用默认情况下未安装的功能（如ASP.NET与IIS或WCF组件的集成），则可能会导致复杂的问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;另一个复杂的问题来自补丁。&lt;/span&gt;&lt;span&gt;包括错误修复或安全更新的修补程序可以通过Windows更新或通过Microsoft下载中心分发给客户。&lt;/span&gt;&lt;span&gt;您测试应用程序的.NET Framework可能与客户使用的补丁程序不同。&lt;/span&gt;&lt;span&gt;当您假定.NET Framework对于所有客户都是一样的时候，通常很难确定在应用程序中导致奇怪行为的原因。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Core的模块化设计意味着您只包含所需的依赖关系。&lt;/span&gt;&lt;span&gt;所有这些依赖关系与您的应用程序进入相同的文件夹。&lt;/span&gt;&lt;span&gt;部署应用程序与复制文件夹一样简单。&lt;/span&gt;&lt;span&gt;这种方法的另一个优点是可以有多个版本并行运行。&lt;/span&gt;&lt;span&gt;这个策略对于使所有平台的部署体验保持一致至关重要。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;云和容器&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在云系统中，用更少的硬件为更高密度的用户提供服务是非常重要的。&lt;/span&gt;&lt;span&gt;应用程序的占位面积越小，密度越高。&lt;/span&gt;&lt;span&gt;虚拟机已经在云端普遍存在多年，但是它们有几个问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;大小 - 一个典型的虚拟机文件是千兆字节，如果不是几十千兆字节。&lt;/span&gt;&lt;span&gt;这使得它们跨网络传输非常耗时，并且对磁盘空间有很大的要求。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;启动时间 - 启动虚拟机意味着启动操作系统。&lt;/span&gt;&lt;span&gt;对于Windows来说，这是一个挑战，因为启动新机器需要花费时间。&lt;/span&gt;&lt;span&gt;这可以使处理突发交通困难。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;内存 - 虚拟机需要将整个操作系统与应用程序一起加载到内存中。&lt;/span&gt;&lt;span&gt;这意味着很多主机的内存被浪费了。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;不一致性 - 相同的虚拟机可以复制到多个主机，主机必须提供相同的虚拟化硬件，这可能依赖于物理硬件。&lt;/span&gt;&lt;span&gt;无法保证虚拟机在任何给定的主机上运行相同的操作。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;容器通过虚拟化操作系统来解决虚拟机的问题。&lt;/span&gt;&lt;span&gt;容器只包含应用程序及其依赖项。&lt;/span&gt;&lt;span&gt;文件大小要小很多倍，启动时间以秒为单位，只有应用程序加载到内存中，容器保证在任何主机上工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;内置于Windows的.NET Framework不能在容器上运行。&lt;/span&gt;&lt;span&gt;鉴于容器的明显优势，&lt;span&gt;.NET Core的设计决定之一就是使其成为模块化&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;这意味着你的.NETCore应用程序可以被“发布”，使得它和它的所有依赖关系在一个地方，这很容易放入容器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;ASP.NET性能&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果您不熟悉ASP.NET，则是.NET Framework中内置的Web应用程序平台。&lt;/span&gt;&lt;span&gt;ASP.NET被许多有影响力的组织所使用，包括Stack Overflow。&lt;/span&gt;&lt;span&gt;ASP.NET是2002年发布的第一个.NET Framework版本，并不断发展。&lt;/span&gt;&lt;span&gt;尽管ASP.NET取得了成功，但在ASP.NET团队中却感觉到他们正在失去开发人员，因为ASP.NET的性能没有竞争力，只能在Windows平台上运行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一家名为TechEmpower的公司每隔几个月就会运行一次Web应用程序平台的基准测试，并提供一个分为几类的排名。&lt;/span&gt;&lt;span&gt;基准测试在Linux上运行，仅包含Windows平台。&lt;/span&gt;&lt;span&gt;对于ASP.NET团队来说，这很麻烦。&lt;/span&gt;&lt;span&gt;许多平台都用于编写跨平台的Web应用程序，并且其性能数据令人印象深刻。&lt;/span&gt;&lt;span&gt;此外，一些Java框架发布了天文数字，例如每秒570万个明文请求，或者490万个。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;alignnone size-medium wp-image-2494 aligncenter&quot; src=&quot;http://freecontent.manning.com/wp-content/uploads/Metzgar_WhyNetCore_03.png&quot; alt=&quot;metzgar_whynetcore_03&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  TechEmpower基准，第12轮&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在TechEmpower基准测试的第十一轮中，Mono平台上的ASP.NET MVC被纳入测试。&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;结果不好。Mono上的ASP.NET每秒产生一个微小的2000个明文请求。Mono不是由Microsoft创建的，它不会像普通的.NET Framework那样得到相同数量的性能调整。为了获得更公平的比较，ASP.NET团队决定在与TechEmpower相同的硬件上运行.NET 4.6的基准测试。结果是每秒约50,000个请求。仍然没有接近NodeJS（每秒320,000个请求），或TechEmpower列表上的其他任何顶级框架。&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可怜的低分并不意外。&lt;/span&gt;&lt;span&gt;如前所述，ASP.NET知道改变现状&lt;/span&gt;&lt;span&gt;只能通过重写整个架构来清除障碍。&lt;/span&gt;&lt;span&gt;这正是发生的事情。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;ASP.NET团队着手构建ASP.NET Core，几个月后，该团队庆祝asp.net core每秒超过100万个请求。最新asp.netcore与node.js的性能对比更是让asp.net core的性能优势继续扩大&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;ASP.NET Core  &lt;/span&gt; &lt;span&gt;VS    &lt;/span&gt; &lt;span&gt;Node.js&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/578477/201801/578477-20180129002920334-590888559.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上图中可看出asp.net core的性能优势已经超过node.js数倍，性能对比链接==&amp;gt;      &lt;span&gt; &lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=csharpcore&amp;amp;lang2=node&quot; target=&quot;_blank&quot;&gt;ASP.NET Core  VS  node.js&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;a title=&quot;asp.net core VS node.js&quot; href=&quot;http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=csharpcore&amp;amp;lang2=node&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ASP.NET Core表明了微软思维的转变。微软意识到它必须具有竞争力才能赢得开发者。它还必须在Windows以外的平台上竞争。这是创建.NET Core的原动力。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;开源&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现代软件开发人员并不满足于寻求功能。&lt;/span&gt;&lt;span&gt;当已经有一个满足他们需求的开源项目的时候，尤其如此。&lt;/span&gt;&lt;span&gt;当大公司热衷于开源软件时，即使是最忠实的微软开发者也会转向其他框架和库，以便在预算内按时完成自己的项目。&lt;/span&gt;&lt;span&gt;如果微软关心“开发人员，开发人员，开发人员”，他们必须做出改变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;公开.NET Framework的源代码是第一步。&lt;/span&gt;&lt;span&gt;.NET Framework源代码已经在参考文献source.microsoft.com和GitHub上公开了好几年了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;alignnone size-medium wp-image-2495 aligncenter&quot; src=&quot;http://freecontent.manning.com/wp-content/uploads/Metzgar_WhyNetCore_04.png&quot; alt=&quot;metzgar_whynetcore_04&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; .NET Framework参考源&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;从揭露来源到接受外来的贡献是完全不同的。&lt;/span&gt;&lt;span&gt;.NET Core开发人员不仅希望获得外部贡献，还希望将社区纳入设计和开发。&lt;/span&gt;&lt;span&gt;这导致了更多的透明度。&lt;/span&gt;&lt;span&gt;ASP.NET Core团队每周都会在&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://live.asp.net/&quot;&gt;&lt;span&gt;http：// &lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;http://live.asp.net/&quot;&gt;&lt;span&gt;live.asp.net&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;上举行一次社区直播会议&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;.NET Core的代码从一开始就在GitHub上公开，任何人都可以提出请求。&lt;/span&gt;&lt;span&gt;社区成员可以在GitHub中创建错误和功能请求。&lt;/span&gt;&lt;span&gt;.NET Core已经标志着微软在开源方面的重大转变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;与.NET Framework的差异&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Core不仅是Linux和Mac的.NET Framework。&lt;/span&gt;&lt;span&gt;微软并没有移植所有的.NET Framework，而是采取了等待客户想要的方式。&lt;/span&gt;&lt;span&gt;必须有足够的客户对框架功能的兴趣来说服微软分配资源来做端口。&lt;/span&gt;&lt;span&gt;移植的障碍之一是最初建立这些功能的团队大部分已经移动。&lt;/span&gt;&lt;span&gt;幸运的是，对于ASP.NET客户来说，ASP.NET团队是.NET Core的驱动因素。&lt;/span&gt;&lt;span&gt;MVC，Web API和SignalR都可以在.NET Core中找到，或者在路线图上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;框架功能没有移植到.NETCore&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我给这个列表提供了可以改变的知识。&lt;/span&gt;&lt;span&gt;某些功能不适用于非Windows平台，其他功能将不会由Microsoft推向未来，因为有更好的替换或功能在某些方面有问题（不安全，难以维护等）。 ）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;WPF / XAML - Windows Presentation Foundation仅适用于用户界面。&lt;/span&gt;&lt;span&gt;.NET标准库不包括用户界面库，.NET Core不会提供跨平台的UI框架。&lt;/span&gt;&lt;span&gt;这意味着像Windows窗体和系统的东西。&lt;/span&gt;&lt;span&gt;绘图不会移植到.NET Core。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;事务 - 这个库使创建分布式事务变得容易。&lt;/span&gt;&lt;span&gt;它依赖于特定于Windows的组件，使其不易移植到.NET Core。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;AppDomains - 这些对于隔离程序集来说是非常有用的，而且不会终止进程，这对于允许插件的应用程序来说非常有用。&lt;/span&gt;&lt;span&gt;它们依赖于某些Windows特定的构造，这些构造在其他操作系统上不起作用。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;.NET远程处理 - 远程对象已被REST服务成功。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ASMX - 编写已被Web API取代的Web服务的旧方法。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Linq to SQL - 由实体框架取代。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;WCF服务 - Windows Communication Foundation客户端功能在.NET Core中可用，但不能创建服务。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;WF - Windows Workflow Foundation依赖于XAML，WCF服务以及其他.NET Framework特性之间的事务。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;.NET Framework开发人员的微妙变化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有经验的.NET Framework开发人员可能会在.NET Core中遇到一些惊喜。&lt;/span&gt;&lt;span&gt;编写新的代码应该是相对直接的，因为你不太可能使用像&lt;/span&gt;&lt;/span&gt;&lt;code&gt;HashTable&lt;/code&gt;&lt;span&gt;&lt;span&gt;or &lt;/span&gt;&lt;span&gt;这样的旧的结构&lt;/span&gt;&lt;/span&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Visual Studio的Intellisense也指出.NET Core是否支持类型，方法，属性等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;size-medium wp-image-2496 aligncenter&quot; src=&quot;http://freecontent.manning.com/wp-content/uploads/Metzgar_WhyNetCore_05.png&quot; alt=&quot;metzgar_whynetcore_05&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; Visual Studio IntelliSense指示.NET Core中是否有类或成员可用&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;NET可移植性分析器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果您试图将现有的.NET应用程序转换为.NET Core，那么最好的地方就是.NET可移植性分析器。&lt;/span&gt;&lt;span&gt;它既可以作为命令行应用程序，也可以作为Visual Studio插件使用。&lt;/span&gt;&lt;span&gt;有许多.NET平台可供选择：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;alignnone size-medium wp-image-2497 aligncenter&quot; src=&quot;http://freecontent.manning.com/wp-content/uploads/Metzgar_WhyNetCore_06.png&quot; alt=&quot;metzgar_whynetcore_06&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; .NET可移植性分析器中提供的目标平台&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;尽可能使用此工具创建一个详细的报告，提供有用的建议：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;alignnone size-medium wp-image-2498 aligncenter&quot; src=&quot;http://freecontent.manning.com/wp-content/uploads/Metzgar_WhyNetCore_07.png&quot; alt=&quot;metzgar_whynetcore_07&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;.NET可移植性分析器报告&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;反射&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;.NET Core中的反射工作方式与.NET Framework中的不同。&lt;/span&gt;&lt;span&gt;最明显的区别是，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Type类&lt;/code&gt;&lt;span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;正常的许多操作&lt;/span&gt;&lt;span&gt;不再存在。&lt;/span&gt;&lt;span&gt;有些人已经被调到一个新的班级&lt;/span&gt;&lt;/span&gt;&lt;code&gt;TypeInfo&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;其他操作在.NET标准库中不可用，并且需要额外的依赖性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  .NET Framework实现反射&lt;/p&gt;
&lt;pre&gt;
PropertyInfo targetProperty = null;
foreach (var property in
         owningElement.GetType().GetProperties())
{
    if (property.Name == this.Name
        &amp;amp;&amp;amp; property.PropertyType.IsGenericType)
    {
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;The .NET Core 实现反射.&lt;/p&gt;
&lt;pre&gt;
PropertyInfo targetProperty = null;
foreach (var property in
owningElement.GetType().GetProperties()) 
{
if (property.Name == this.Name &amp;amp;&amp;amp; property.PropertyType
.GetTypeInfo().IsGenericType)           
{
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;❶需要依赖于System.Reflection.TypeExtensions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❷ &lt;/span&gt;&lt;span&gt;许多类型操作移到了TypeInfo&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;概要&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;软件开发行业正在不断发展。&lt;/span&gt;&lt;span&gt;从语言到框架，工具到方法论，一切都受到挑战和改进。&lt;/span&gt;&lt;span&gt;.NET框架已经到了b不得不做出改变的时候，以跟上竞争对手。&lt;/span&gt;&lt;span&gt;.NETCore是.NET演进过程中必不可少的一步。&lt;/span&gt;&lt;span&gt;它将最好的.NET Framework与现代软件开发中使用的实践相结合。&lt;/span&gt;&lt;span&gt;诸如可移植性，简单部署，高性能，开放源代码和强大支持等特性使其值得一试。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Why Choose .NET Core?&quot; href=&quot;http://freecontent.manning.com/why-choose-net-core/&quot; rel=&quot;bookmark&quot;&gt;Why Choose .NET Core?&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 28 Jan 2018 16:39:00 +0000</pubDate>
<dc:creator>Chaunce</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoliangge/p/8373100.html</dc:identifier>
</item>
<item>
<title>我的2017——求职篇（一） - codingHeart</title>
<link>http://www.cnblogs.com/codingHeart/p/8349489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingHeart/p/8349489.html</guid>
<description>&lt;p&gt;　　对我来说，2017年最重要的日子应该是刚来到这个城市的那天，没有那一天的决定，就不会有下面荒诞不羁的故事。&lt;/p&gt;
&lt;p&gt;　　6月底上家公司的交接事宜处置妥当后，&lt;strong&gt;2017年7月1号&lt;/strong&gt;，刚辞职的我背起背包就从广州奔赴深圳了，也不知前面是什么样的路等着我，其实有些问题自己都还没想明白，可能稍微比较明确的就是大部分所考虑的 到深圳工资会高些，然后一些也多几个熟悉的人。&lt;/p&gt;
&lt;p&gt;　　刚到深圳，跟广州差不多，烈日炎炎，高中两个朋友亲自迎接让这个都市稍微有了一些亲切感，一路上闲聊，朋友问我下个工作预期薪资是多少，我才发现好像我没有仔细思考这个问题，甚至我都不知道自己到底有多大的能力。我就临时说了句“怎么也得8k吧”（因为上家公司有个同事跳槽 薪资有7k，深圳怎么也得高点吧），朋友说我才一年工作经验，可能有点不好找，我顿时就有点怂了，赶快补了句，“实在找不到 6、7千也能接受吧，找的时候再看吧”。有点尴尬，毕竟毕业之后在之前那家公司待了一年，正式项目一个没让我上过，组里有个老项目因为一个开发人员辞职了 才让我临时上去替她，都是些后期修补工作，所以一年的工作经验 我自己都不太确定 到底自己有什么样的长进。&lt;/p&gt;
&lt;p&gt;　　朋友接着问我是准备找哪个方向的，我好像也没太想好，想继续做asp.net，在上家公司.net做的多点，但我知道我对.net的了解程度远远不够，大部分的实践都是在修补那个老项目时完成的（三层，webform,webservice，ado.net）；想转前端，因为还算比较火，上家公司的时候也切了一些页面，写了不少js，项目提前几天完工 闲的时候还买了本js高程看，业余经常关注前端mvvm框架相关的东西，无奈全部仅限于了解，没有实战过。嗯，那就前端和asp.net都考虑投吧，薪资区间6k~8k。就这样，在朋友的问题下把找工作最重要的两件事确定下来了。。&lt;/p&gt;
&lt;p&gt;　　因为那天是周六，所以先跟朋友一起玩了两天，找工作的事儿先搁着了。&lt;/p&gt;
&lt;p&gt;　　周一，醒来的时候朋友已经上班去了，也着手开始找工作了，于是开始下载招聘的app（xx无忧），因为之前都没用过，简历什么的得从头开始弄，简历电脑里倒是有一份，但都是一年前校招时候的简历了，看了一下，都懒得在上面改了，想想还是重新做一份吧，，之后的两天，投出去的简历一个回音都没有，其实心里开始有点不安定了，原来是想着边找工作边复习些知识点，才知道这种情况下哪儿来的心思复习啊，天气热，心里燥，能缓解情绪的只有看剧、玩游戏了，于是军师、农药又搞起了。。。。&lt;/p&gt;
&lt;p&gt;　　周二天下午和朋友在外边喝糖水的时候，终于，收到了一条面试邀请，接着便是电话过来了，定了第二天上午面试。哈哈，心里总算松了一口气，不管明天能不能过，起码对于这次异地求职的征程来说， 也算是开了个好头儿了。&lt;/p&gt;
&lt;p&gt;　　周三7点半起来 收拾一下，至于穿什么这些细节 可以不考虑了，只带了一套换洗的衣服，短裤、T-shirt，宅+直男的样子吧，当然看着也算干净，这点还是得有的。快十点的时候到了公司，跟前台说明了下，她问我 带了简历没，“没有”，后面给了我一份 笔试题，“我这边没带笔...”（面试没带简历，笔试没带笔，你面nmb的试啊，我如果面试别人的话，我估计心里要有心理活动了），哈哈哈，好尴尬，确实仓促，没怎么准备，于是去到一个小屋子里开始做题了，前端方面的知识，题就7道左右，大部分我之前都多多少少 有在一些前端前辈的博客里了解到，所以 响应式原理，jq的事件队列，事件机制，清除浮动之类的，都大概知道些，虽然几乎没有项目实战应用过，但笔试还是能对付的，就是有个 js 的基本类型当时 有点卡住，把null搞掉了写了个object...但就后面的情况看 好像这个影响不是很大。&lt;/p&gt;
&lt;p&gt;　　做完交给前台后，一会儿项目负责人就带着我的简历、试题过来了，30岁左右，现在已经完全不记得人什么样儿了，因为我对他的印象其实不怎么好，所以也就没留太多印象。上来先拿着我的答题纸 挑了些题问我，像响应式的原理之类的，应该是看我答得的太简略了（媒体查询、百分比布局...），想对我技术方面多了解下，结果当然是，回答不太合他的意，我都有些get不到他的点....，但我答出的东西很多都是那些博主有写过的相关知识点方面的话，所以他大部分时候 还是会点点头的,哈哈，感觉他听我扯的有点无奈。&lt;/p&gt;
&lt;p&gt;　　接着，就开始拿简历上的项目经验说事儿了，刚开始有点虚，因为这些项目 基本都是当时部门经理抽出的一些模块给我做练习的，我更多在做照葫芦画瓢的这种事，还有一些更是部门闲的时候做的一些内部demo.....。不过这个面试官倒是很实在，基本不问技术细节，更多问些思路方面的（很合我口味），基本上都是在确认我确实有用过我简历上写的技术点，熟不熟练，好像不是太在意样的，这特么就是我的菜啊，这一环节下来，基本上他应该是满意的，我的简历跟我的现场表现匹配度还是很高的，这倒是情理之中，毕竟我也是个实在人，不说大话，很谦卑（其实是自卑），嘻嘻。&lt;/p&gt;
&lt;p&gt;　　技术方面的考量完了，接下来，自然要谈谈薪资了。好了，到了我觉得应该是人生很戏剧的一幕了，此后我想起的时候，总觉得有些搞笑。简历上我对薪资什么的都没有写，他没有问我 期望薪资多少，转而是想了解我在上家公司的薪资情况，虽然没什么面试方面的经验，但我第一时间还是有反应过来的，即使是个实在人，这个时候也不能说真实薪资（实在有点低，我怕我后面提出期望薪资的时候 他接受不了现实...），于是脑子转几毫秒就说，&quot;6千&quot;，他也没多加思索，开出7k，心里窃喜，居然真是这个套路的，好耿直啊，哈哈哈。然而，让我没想到的是，他是直接给出薪资，根本不先问下我的期望薪资，这就让我有点不舒服了。当然，这个时候，我还是高兴多点，毕竟也算是出师大捷了。&lt;/p&gt;
&lt;p&gt;　　作为求职者，我当然是想多争取些薪资了，而且他给我定薪资的方式确实也让我感觉很屈辱。于是三番四次、拐弯抹角的开始 透出提薪的要求，深圳和广州的生活成本啊；之前公司的项目奖金、年终奖、福利啊；我也有一年的工作经验了，看我的眼光是不是应该调高点，别着眼于我上家公司时候的工资啊。然而，无果。好像把他弄的还有点不耐烦了，直接说，“就7k的薪资，不用再谈了，你看要不要考虑考虑“。窝草，我瞬间就懵逼了，本来心里就有点不舒服了，这句话一出来，我知道 没什么好说的了，于是 笑着回应：&lt;/p&gt;
&lt;p&gt;　　“好，那我回去考虑考虑吧”，&lt;/p&gt;
&lt;p&gt;　　“好的，考虑好了可以来电话”。&lt;/p&gt;
&lt;p&gt; 　　就这样，第一次面试就这么结束了，回去的路上，偶尔有将就的念头，但一想到那个项目leader的行事风格，马上又消了。现在想想，他们应该是一个缺一个7k的”打杂“的，能招到牛逼的更好，不牛逼也不太要紧，只要7k找到能做事的人就好。&lt;/p&gt;
&lt;p&gt;　　回到朋友的住处，思绪万千啊真是，之前一直不知道自己到底是个什么水准，但就这次面试之后，信心要好不少，起码，7k也是有人要的（自卑的人说话 会把自己当一个落在角落的蒙灰物件）。同时，也有点助长我的”小野心“：看样子 提前准备下面试笔试，表现好点 8k也不是不可能。&lt;/p&gt;
&lt;p&gt;　　于是，新的征程又要开始了。&lt;/p&gt;
&lt;p&gt;　　待续。。。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jan 2018 16:28:00 +0000</pubDate>
<dc:creator>codingHeart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingHeart/p/8349489.html</dc:identifier>
</item>
<item>
<title>[机器学习]-[数据预处理]-中心化 缩放 KNN（二） - CodingStar</title>
<link>http://www.cnblogs.com/BoyceYang/p/8372999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BoyceYang/p/8372999.html</guid>
<description>&lt;p&gt;上次我们使用精度评估得到的成绩是 61%，成绩并不理想，再使 recall 和 f1 看下成绩如何？&lt;/p&gt;
&lt;p&gt;首先我们先了解一下 召回率和 f1。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;

&lt;/th&gt;
&lt;th&gt;

&lt;/th&gt;
&lt;th&gt;

&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;

&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;table-cell&quot;&gt;
&lt;p&gt;TP 真正例&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;table-cell&quot;&gt;
&lt;p&gt;FN 假反例&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;

&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;table-cell&quot;&gt;
&lt;p&gt;FP 假正例&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;table-cell&quot;&gt;
&lt;p&gt;TN 真反例&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;召回率：TP/(TP+FN)&lt;/p&gt;
&lt;p&gt;f1:2TP/(2TP+FN+FP)&lt;/p&gt;
&lt;p&gt;我们使用scikit-learn的分类报告来查看各种其他指标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1268259/b7x53qfrok.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们来介绍一下缩放和中心化，他们是预处理数值数据最基本的方法，接下来，看看它们是否对模型有影响，以及怎样的影响。&lt;/p&gt;

&lt;p&gt;在运行模型（如回归（预测连续变量）或分类（预测离散变量））之前，我们还是需要对数据进行一些预处理。对于数值变量，&lt;em&gt;规范化&lt;/em&gt;或&lt;em&gt;标准化&lt;/em&gt;数据是很常见的。这些术语是什么意思？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;规范化&lt;/em&gt;手段就是缩放数据集，使其数据取值的范围压缩到0,1。我们的做法就是转换每个数据点：规范化结果=（数据点-数据最小值）/（数据最大值-数据最小值）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;标准化则&lt;/em&gt;略有不同， 它的最终结果就是将数据集中在0左右，并按照标准偏差进行缩放：标准化结果=（数据点-均值）/标准差。&lt;/p&gt;
&lt;p&gt;有一点需要强调，这些转换只是改变了数据的范围而不是分布。当然，你也可以根据自己的需要使用其他的转换方式（如对数转换换或正太转换）来达到数据的高斯分布形式（如钟形曲线）。&lt;/p&gt;
&lt;p&gt;现在我们思考几个重要的问题：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;为什么我们要调整数据？&lt;/li&gt;
&lt;li&gt;什么时机处理更合适？&lt;/li&gt;
&lt;li&gt;分类问题和回归问题哪个更重要？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就具体看下缩放对 KNN 的影响。&lt;/p&gt;

&lt;p&gt;下面是我们的处理步骤&lt;/p&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;缩放数据&lt;/li&gt;
&lt;li&gt;使用 KNN&lt;/li&gt;
&lt;li&gt;查看模型结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用scikit-learn的&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html&quot; target=&quot;_blank&quot;&gt;缩放函数&lt;/a&gt;，它会将传给它的数组中所有的特征（列）标准化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1268259/0yxugw85yb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的处理之后提高了0.1，这就说明预处理的很成功，同时也说明预处理很重要！！！如上所述，在缩放之前，存在许多具有不同数量级范围的预测变量，这意味着它们中的某一个或几个可能在，如 KNN 算法处理中占主导地位。缩放数据的一般是基于以下两个原因：&lt;/p&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;预测变量可能有明显不同的范围，并且在某些情况下（例如使用 KNN），需要削弱某些特征对算法的主导;&lt;/li&gt;
&lt;li&gt;功能与单位无关，即不依赖于所涉及的规模：例如，我使用米来表示测量的特征，你使用厘米来表示相同的特征。如果我们都缩放各自的数据，那么，这个特征对我们每个人都是一样的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到目前位置，我们已经了解了缩放和中心化在整个机器学习中的基本位置，我们这样做主要的目的就是提高机器学习的学习能力。我希望后续，我能和大家分享一些其他类型的预处理。在进入这个之前，在下一篇文章中，我将探讨缩放在回归分类方法中的作用。&lt;/p&gt;
&lt;p&gt;最后，有兴趣的同学可以自行设置 KNN 的 n_neighbors 变量，然后观察一下 n_neighbors 对机器学习的影响。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;%&lt;span&gt;matplotlib inline
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;from sklearn.cross_validation import train_test_split&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; classification_report
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; neighbors, linear_model

plt.style.use(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ggplot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
df &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , sep = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除目标结果&lt;/span&gt;
X = df.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;quality&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , 1&lt;span&gt;).values
y1 &lt;/span&gt;= df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;quality&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].values
pd.DataFrame.hist(df, figsize &lt;/span&gt;= [15,15&lt;span&gt;]);

df.describe()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 5 作为边界进行分类&lt;/span&gt;
y = y1 &amp;lt;= 5

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 原始目标结果和二分类之后的目标结果&lt;/span&gt;
plt.figure(figsize=(20,5&lt;span&gt;));
plt.subplot(&lt;/span&gt;1, 2, 1&lt;span&gt; );
plt.hist(y1);
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;original target value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.subplot(&lt;/span&gt;1, 2, 2&lt;span&gt;);
plt.hist(y)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two-category target value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切分测试数据与训练数据&lt;/span&gt;
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42&lt;span&gt;)

knn &lt;/span&gt;= neighbors.KNeighborsClassifier(n_neighbors = 5&lt;span&gt;)
knn_model_1 &lt;/span&gt;=&lt;span&gt; knn.fit(X_train, y_train)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k-NN accuracy: {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(knn_model_1.score(X_test, y_test)))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其他评估评分&lt;/span&gt;
y_true, y_pred =&lt;span&gt; y_test, knn_model_1.predict(X_test)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(classification_report(y_true, y_pred))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预处理数据&lt;/span&gt;
Xs =&lt;span&gt; scale(X)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切分测试数据与训练数据&lt;/span&gt;
Xs_train, Xs_test, y_train, y_test = train_test_split(Xs, y, test_size=0.2, random_state=42&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以通过设置 n_neighbors 来进行训练&lt;/span&gt;
knn = neighbors.KNeighborsClassifier(n_neighbors = 5&lt;span&gt;)
knn_model_2 &lt;/span&gt;=&lt;span&gt; knn.fit(Xs_train, y_train)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k-NN test: %f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; knn_model_2.score(Xs_test, y_test))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k-NN training: %f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; knn_model_2.score(Xs_train, y_train))
y_true, y_pred &lt;/span&gt;=&lt;span&gt; y_test, knn_model_2.predict(Xs_test)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(classification_report(y_true, y_pred))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;知乎：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33379542&quot; target=&quot;_blank&quot;&gt;数据预处理-中心化 缩放 KNN（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;云+社区：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1030072&quot; target=&quot;_blank&quot;&gt;[机器学习]-[数据预处理]-中心化 缩放 KNN（二）&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 28 Jan 2018 16:28:00 +0000</pubDate>
<dc:creator>CodingStar</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BoyceYang/p/8372999.html</dc:identifier>
</item>
<item>
<title>echarts使用总结 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/8373001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/8373001.html</guid>
<description>&lt;p&gt;项目中需要实现数据可视化，在前辈的推荐之下，最终选取了echarts来实现，在此关于echarts的使用进行总结，最终代码分享至&lt;a href=&quot;https://github.com/Yabea/front/tree/master/learn%20echarts&quot;&gt;我的github&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;关于echarts&quot;&gt;关于echarts&lt;/h2&gt;
&lt;p&gt;echarts是百度推出的，使用JavaScript实现的开源可视化库，可以提供直观、可定制化的数据可视化图表，包括折线图、柱状图、散点图、地图和饼图等，&lt;a href=&quot;http://echarts.baidu.com/&quot;&gt;点击跳转主页&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;h3 id=&quot;需求&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;使用之前先谈需求：使用echarts的话，需求基本上都是为了实现数据可视化，那么数据可视化牵扯到一个怎么展示的问题，就echarts功能而言，展示将通过可视化图表进行，也就是，这里的需求可归为将某数据使用echarts以图表（假定为柱状图）的形式呈现。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;一般情况，我会直接打开&lt;a href=&quot;http://echarts.baidu.com/examples/index.html&quot;&gt;echart官方实例&lt;/a&gt;, 选取相应的实例，我们以最简单的&lt;a href=&quot;http://echarts.baidu.com/examples/editor.html?c=line-simple&quot;&gt;折线图&lt;/a&gt;为例。可以看到对应的JS代码为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: 'line'
    }]
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，这里的各种变量分别代表的是什么含义呢？当然可以在此修改部分数据，查看折线图的变化，echarts图形化的呈现是通过setOption配置方法来实现的，&lt;a href=&quot;http://echarts.baidu.com/option.html#title&quot;&gt;点击详情&lt;/a&gt;，这里对各种配置做出详尽的介绍。&lt;/p&gt;
&lt;h3 id=&quot;简单实例&quot;&gt;简单实例&lt;/h3&gt;
&lt;p&gt;那么在日常开发环境中如何实现呢？&lt;br/&gt;首先，创建first.html文件，并编写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;echarts使用&amp;lt;/title&amp;gt;  
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&amp;gt;
    &amp;lt;script src=&quot;js/echarts.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;content&quot;&amp;gt;
        &amp;lt;div class=&quot;title&quot;&amp;gt;
            echarts使用案例
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;chart&quot;&amp;gt;
            &amp;lt;div id=&quot;firstchart&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

 &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var myChart = echarts.init(document.getElementById('firstchart'));
    var option = {
        title: {
            text: '一周温度变化',
            left: 'center',
            top: '1%',
            textStyle: {
                color: 'white',
                fontSize:16,
            }
        },
        xAxis: {
            type: 'category',
            data: ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期天'],
            axisTick: {
                alignWithLabel: true
            },
            axisLine:{
                lineStyle: {
                    color:'white',
                }
            },
        },

        yAxis: {
            type: 'value',
            axisTick: {
                alignWithLabel: true
            },
            axisLine:{
                lineStyle: {
                    color:'white',
                }
            },
        },
        series: [{
            data: [11, 12, 15, 5, 8, 14, 9],
            type: 'line'
        }]
    };

    myChart.setOption(option);
 &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写对应的css样式文件，打开浏览器就可看到对应的折线图。&lt;/p&gt;
&lt;h3 id=&quot;定制&quot;&gt;定制&lt;/h3&gt;
&lt;p&gt;在平时的使用中，其它需求势必存在，而echarts本身也提供了这种定制化配置。下面关于一些常见需求举例说明：&lt;/p&gt;
&lt;h3 id=&quot;添加图注&quot;&gt;添加图注&lt;/h3&gt;
&lt;p&gt;就上述折线图而言，气温变化一般可分为最高温度变化和最低温度变化，也就意味着会有两条折线。为了更直观表现，这里可使用图注来说明,在配置项中legend属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;legend:{
    right:0,
    top:3,
    textStyle:{
        fontSize:12,
        color:'#FFF',
    },
    data:['最高温度变化']
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并设置了图注属性。&lt;/p&gt;
&lt;h3 id=&quot;将坐标名旋转&quot;&gt;将坐标名旋转&lt;/h3&gt;
&lt;p&gt;由于图标可占用的空间有限，加之坐标名字符较长，就导致坐标名显示不全的情况，可以将做表明改为斜体展示（旋转角度），通过在xAxis中添加axisLabel属性来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xAxis : [
    {
    axisLabel:{
        interval:0,
        rotate:45,//倾斜度 -90 至 90 默认为0
        },
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置坐标网格背景&quot;&gt;设置坐标网格背景&lt;/h3&gt;
&lt;p&gt;为了界面的美观，可以在图表中绘制网格，并设置网格背景。首先，在xAxis下添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;splitLine:{
    show:true,
    lineStyle:{
        color: 'white',
        width:1,
        type: 'solid'
    }
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，绘制了网格，然后，在yAxis中添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;splitArea:{
    show:true,
    areaStyle:{
        color:['#6a6f71', '#5b6062'],
    },
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可实现网格背景，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/771535/201801/771535-20180129002534912-857939154.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上。&lt;br/&gt;本文将持续更新。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jan 2018 16:26:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ybjourney/p/8373001.html</dc:identifier>
</item>
<item>
<title>-------- Rootkit 核心技术——利用 nt!_MDL 突破 KiServiceTable 的只读访问限制 Part II -------- - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8372956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8372956.html</guid>
<description>&lt;p&gt;———————————————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇开始进入正题，因为涉及 MDL，所以相关的背景知识是必须的：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;nt!_MDL 代表一个“内存描述符链表”结构，它描述着用户或内核模式虚拟内存（亦即缓冲区），其对应的那些物理页被锁定住，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无法换出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为一个虚拟的，地址上连续的用户或内核缓冲区可能映射到多个不连续的物理页，所以 nt!_MDL 定长（0x1b 字节）的头部后紧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;跟&lt;/span&gt;&lt;span&gt;数量可变的页框号（Page Frame Numbers），MDL 描述的每个物理页面都有一个页框号，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是这些页框号引用的物理地址范围就对应了一片特定的用户或内核模式缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常虚拟和物理页的大小为 4 KB，KiServiceTable 中的系统服务数量为 401 个，每函数的入口点占用 4 字节，整张调用表大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为 1.6 KB，通过 MDL 仅需要一张物理页即可描述这个缓冲区；在这种情况下，该 MDL 后只有一个页框号。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;尽管 nt!_MDL 是半透明的结构，不过在内核调试器以及 WRK 源码面前还是被脱的一丝不挂，如下图为 WRK 源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的“&lt;span&gt;ntosdef.h&lt;/span&gt;”&lt;/span&gt;&lt;span&gt;头文件中的定义，如你所见，称为“链表”乃因它的首个字段“Next”是一枚指针，指向后一个 nt!_MDL 结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于我们 hook &lt;/span&gt;&lt;span&gt;KiServiceTable 的场景而言，无需用到 Next 字段；那什么情况下会用到呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Windows 中某些类型的驱动程序，例如网络栈，它们支持 MDL 链，其内的多个 MDL 描述的那些缓冲区实际上是零散的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设栈中每个驱动都分配一个 MDL，其后跟着一些物理页框号来描述它们各自用到的虚拟缓冲区，那么这些缓冲区就通过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个 _MDL 的 Next 字段（指向下一个 MDL）链接起来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128232726115-1949059658.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于描述用户模式缓冲区的 MDL，其内的 Process 字段指向所属进程的 EPROCESS 结构，进程中的这块虚拟地址空间被 MDL 锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;住。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果由 MDL 描述的缓冲区映射到内核虚拟地址空间中，_MDL 的 &lt;span&gt;MappedSystemVa&lt;/span&gt; 字段指向内核模式缓冲区的基地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅当 _MDL 的 &lt;span&gt;MdlFlags&lt;/span&gt; 字段内设置了 MDL_MAPPED_TO_SYSTEM_VA 或 MDL_SOURCE_IS_NONPAGED_POOL 比特位，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;MappedSystemVa&lt;/span&gt; 字段才有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_MDL 的 &lt;span&gt;Size&lt;/span&gt; 字段含有 MDL 头部加上其后的整个 PFN 数组总大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图还包含了 MdlFlags 字段的所有标志宏定义，这个 2 字节的字段可以是任意宏的组合，用于说明 MDL 的一些状态与属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MDL 的 &lt;span&gt;StartVa&lt;/span&gt; 字段和 &lt;span&gt;ByteOffset&lt;/span&gt; 字段共同定义了由该 MDL 锁定的原始缓冲区的起始地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（原始缓冲区可能会映射到其它内&lt;/span&gt;&lt;span&gt;核缓冲区或&lt;/span&gt;&lt;span&gt;用户缓冲区）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StartVa 指向虚拟页的起始地址，ByteOffset 包含实际从 StartVa 开始的缓冲区偏移量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MDL 的 &lt;span&gt;ByteCount&lt;/span&gt; 字段描述由该 MDL 锁定的缓冲区大小（以字节为单位）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于我们要 hook 的 KiServiceTable 而言， KiServiceTable 这片内核缓冲区所在的虚拟页起点由 StartVa 字段携带；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ByteOffset 字段则携带 KiServiceTable 的页内偏移量，ByteCount 字段携带 KiServiceTable 这片内核缓冲区的大小。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果你现在看得云里雾里，不用担心，后面我们在调试时会把描述 KiServiceTable 的一个 nt!_MDL 结构实例拿出来分析，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到时候你就会恍然大悟这些字段的设计思想了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过编程方式使用 MDL 绕过 KiServiceTable 的只读属性，需要借助 Windows 执行体组件中的 I/O 管理器以及&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存管理器导出的一些函数，大致流程如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;IoAllocateMdl()&lt;/strong&gt; 分配一个 MDL 来描述 KiServiceTable -&amp;gt; &lt;strong&gt;MmProbeAndLockPages()&lt;/strong&gt; 把该 MDL 描述的 KiServiceTable 所&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;属&lt;/span&gt;&lt;span&gt;物理页锁定在内存中，并赋予对这张页面的读写访问权限（实际是将描述该页面的 PTE 内容中的“R”标志位修改成“W”）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&amp;gt;&lt;strong&gt;MmGetSystemAddressForMdlSafe()&lt;/strong&gt; 将 KiServiceTable 映射到另一片内核虚拟地址区域（一般而言，位于 rootkit 被加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到的内核地址范围内）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此一来，KiServiceTable 的原始虚拟地址与新映射的虚拟地址都转译到相同的物理地址，而且描述新虚拟地址的 PTE 内容标记了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写权限比特位，这&lt;/span&gt;&lt;span&gt;样我们&lt;/span&gt;&lt;span&gt;就能够通过修改这个新的虚拟地址中的系统服务例程实现安全挂钩 KiServiceTable，不会导致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BugCheck。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下所示，我把上述涉及的所有操作都封装到一个自定义的函数 &lt;strong&gt;MapMdl()&lt;/strong&gt; 里面。由于整个逻辑比较长，截图分为多张说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapMdl() 在我们的 rootkit 入口点——DriverEntry() 中被调用，而在 DriverEntry() 外部声明几个与 MDL 相关的全局变量，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它们被 MapMdl() 与 DriverEntry() 共享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，os_ki_service_table 存储着 KiServiceTable 的地址（参见前一篇定位 KiServiceTable 的代码），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把它从 DWORD 转换为泛型指针是为了符合 MapMdl() 中的 IoAllocateMdl() 调用时的形参要求；&lt;span&gt;最后一个参数——表达式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;0x191 * 4——就是整个 KiServiceTable 缓冲区的大小&lt;/span&gt;：假若 MapMdl() 成功返回，则全局变量 mapped_ki_service_table&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持有 KiServiceTable 新映射到的内核虚拟地址；这些全局变量都是“自注释”的，&lt;span&gt;pfn_array_follow_mdl 持有的地址处内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是 MDL 描述的物理页框号：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128233251819-2078706333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;MapMdl()第一部分逻辑如下图所示，局部变量 mapped_addr 预期存放 KiServiceTable 新映射到的内核虚拟地址，并作为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapMdl() 的返回值给 DriverEntry()，进一步初始化全局变量 mapped_ki_service_table。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，PVOID 可以赋给其它任意类型的指针，这是合法的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IoAllocateMdl() 返回一枚指针，指向分配好的 MDL，该 MDL 描述 KiServiceTable 的物理内存布局；这枚指针被用来初始化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作为实参传入的全局变量 &lt;strong&gt;mdl_ptr&lt;/strong&gt;（mdl_pointer 是形参）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我添加的第一个软件断点就是为了研究 IoAllocateMdl() 分配的 MDL 其中 MappedSystemVa，StartVa，以及 MdlFlags 这些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字段的内容——事实上，&lt;span&gt;这些字段值会在&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IoAllocateMdl() -&amp;gt; MmProbeAndLockPages() -&amp;gt;MmGetSystemAddressForMdlSafe()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;调用链的每一阶段发生变化，&lt;/span&gt;所以我总共添加了三个断点在相关的检查区域，有助于我们在后面的调试过程中深入理解 nt!_MDL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的设计思想。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128233204053-1583746905.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我把使用 Windows 执行体组件例程进行的操作放入一个 &lt;strong&gt;try-except&lt;/strong&gt; 块内，以便处理可能出现的异常，except 块内的逻辑如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图，&lt;/span&gt;&lt;span&gt;当违法访问出现时，调用 IoFreeMdl() 释放我们的 MDL 指针，然后 MapMdl() 返回 NULL，从而导致 DriverEntry() 打印出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;错&lt;/span&gt;&lt;span&gt;信息。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128234358975-811010904.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于 IoAllocateMdl() 的第二个参数，我们有必要进一步了解，所以我翻译了 MSDN 文档上的相关片段，如下：&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;IoAllocateMdl() 的第二个参数指定要通过分配的 MDL 描述的缓冲区的大小。如果这个长度小于 4KB，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么映射它的 MDL 就只描述了一个被锁定的物理页面；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果长度是 4KB 的整数倍，那么映射它的 MDL 就描述了相应数量的物理页面（通过紧接 MDL 后面的 PFN 数组）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于 Windows Server 2003，Windows XP，以及 Windows 2000，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此例程支持的最大缓冲区长度（以字节为单位）是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PAGE_SIZE * (65535 - sizeof(MDL)) / sizeof(ULONG_PTR) （约 67 MB）&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;对于 Windows Vista 和 Windows Server 2008，能够传入的最大缓冲区大小为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2 gigabytes - PAGE_SIZE)&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;对于 Windows 7 和 Windows Server 2008 R2，能够传入的最大缓冲区大小为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4 gigabytes - PAGE_SIZE)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行此例程的 IRQL 要求为 &amp;lt;= DISPATCH_LEVEL&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;MapMdl()第二部分逻辑如下图所示，它紧跟在第一个软件断点之后。我们检查 MDL 中的 MDL_ALLOCATED_FIXED_SIZE 标志是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否&lt;/span&gt;&lt;span&gt;置位，该标志因调用 IoAllocateMdl() 传入第二个参数指示固定大小而置位；MmProbeAndLockPages() 的第三个参数是实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写访问的关键所在，能否锁定内存倒是其次，因为像 KiServiceTable 这种系统范围的调用表，地位非常重要，如果被换出物理内&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存，&lt;/span&gt;&lt;span&gt;系统岂不就崩溃了，所以坦白讲我们只是因为需要写权限才调用它的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二个断点紧跟其后，这样就可以在调试器中检查 MmProbeAndLockPages() 是如何修改 MDL 中的标志；也可以使用编程手段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;检查，&lt;/span&gt;&lt;span&gt;如图中的第二个 if 块逻辑，事实上 MmProbeAndLockPages() 调用会向 MdlFlags 字段内添加 MDL_WRITE_OPERATION&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与 &lt;/span&gt;&lt;span&gt;MDL_PAGES_LOCKED &lt;/span&gt;&lt;span&gt;标志，这就是我们想要的结果！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后我们调用 MmGetSystemAddressForMdlSafe() 把该 MDL 描述的原始虚拟地址映射到内核空间的另一处，新地址通常位于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;驱动加载到的内核空间某处；局部变量 mapped_addr 持有这个新地址，最终用来返回并初始化全局变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mapped_ki_service_table。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理我们可以检查 MmGetSystemAddressForMdlSafe() 修改了哪些 MDL 结构成员，对于理解 MDL 的工作机理非常关键。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128234151272-1931430246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapMdl()第三部分逻辑如下图所示，我们检查 MmGetSystemAddressForMdlSafe()是否多添加了一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MDL_MAPPED_TO_SYSTEM_VA &lt;/span&gt;&lt;span&gt;标志，然后以 DBG_TRACE 宏打印信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局变量 &lt;strong&gt;backup_mdl_ptr&lt;/strong&gt; 是我们在调用 IoAllocateMdl() 就做好备份的 MDL 指针，它与 mdl_ptr 指向同一个 nt!_MDL 结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来的逻辑有助于你理解 MDL 头部后面的 PFN 数组：&lt;span&gt;mdl_ptr 指向 nt!_MDL 结构头部，把它加上 1 ，意味着把它持有的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存地址加上 1 * sizeof(MDL) 个字节，于是就定位到了 MDL 头部后面的 PFN 数组起始地址——现在全局变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;pfn_array_follow_mdl（一枚 PPFN_NUMBER 型指针）持有这个地址&lt;/span&gt;；正如图中倒数第三条 DbgPrint() 调用所言——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MDL 结构后偏移 xx （0x1b）地址处是一个 PFN 数组，用来存储该 MDL 描述的虚拟缓冲区映射到的物理页框号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后一条 DbgPrint() 调用通过解引 pfn_array_follow_mdl 来输出该地址处存放的物理页框号。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 return mapped_addr; 语句的后面，则是 try-except 块的异常捕获逻辑，请参前面截图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128234915365-906534506.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;现在，程序访问可读写的 mapped_ki_service_table 与只读的 os_ki_service_table 都转译到同一块物理内存，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;后者就是实际上存储 KiServiceTable 的地方&lt;/strong&gt;。接下来，我们用一枚函数指针保存 KiServiceTable 中某个原始的系统服务，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后用我们的钩子例程地址替换掉该位置处的原始系统服务，而钩子例程内部仅仅是调用原始系统服务，实现安全转发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了演示简单起见，我选取 KiServiceTable 中 0x39（57）号例程，因为它的参数只有一个，方便我们的钩子例程仿效同样的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数声明——内核系统服务调度器（&lt;strong&gt;nt!KiFastCallEntry()&lt;/strong&gt;）并不知道它调用的目标系统服务已经被替换成我们的钩子例程，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以他会以既定方式使用钩子例程的返回值和输出参数，在这种情况下，只要我们的钩子例程原型声明与被挂钩系统服务有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;细微差别，都可能导致非预期的内核错误而蓝屏，显然，那些参数既多又复杂的系统服务不适合我用来演示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，某些系统服务接收的参数类型的定义不在 wdm.h / ntddk.h 头文件内，讲明了这些数据类型不是给驱动开发人员使用的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅供内核组件使用，&lt;span&gt;为了引入包含该定义的头文件则会碰到复杂的头文件嵌套包含问题，其麻烦程度丝毫不逊于 Linux 平台上&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的“二进制软件包依赖性地狱”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;57 号系统服务例程亦即 nt!NtCompleteConnectPort()，有且仅有一个文档化的参数，WRK 源码中的相关定义如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128235130334-1418961878.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们的钩子例程只要完全仿效它的返回值类型与形参类型即可，然后在内部调用指向原始例程的函数指针实施重定向。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过 typedef 定义一个函数指针，其返回值类型与形参类型与 NtCompleteConnectPort() 一致，然后声明一个该函数指针&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实例。相关代码如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128235503787-873171589.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局变量 ori_sys_service_ptr 持有 NtCompleteConnectPort() 的入口点地址，前者是在我们的 rootkit 入口点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DriverEntry() 中初始化的；保存这枚指针后就可以用钩子例程替换 NtCompleteConnectPort()，如下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180128235657209-979703129.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;需要指出一点，尽管把指针名称 mapped_ki_service_table 当作数组名称来访问 KiServiceTable 是被 C 语言核心规范允许的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是上图那段代码在编译器会产生警告，如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&amp;gt;warnings &lt;span&gt;in&lt;/span&gt;&lt;span&gt; directory d:\kmdsource_use_mdl_mapping_ssdt
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&amp;gt;d:\kmdsource_use_mdl_mapping_ssdt\usemdlmappingssdt.c(&lt;span&gt;155&lt;/span&gt;) : warning C4047: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OriginalSystemServicePtr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; differs &lt;span&gt;in&lt;/span&gt; levels of indirection from &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DWORD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&amp;gt;d:\kmdsource_use_mdl_mapping_ssdt\usemdlmappingssdt.c(&lt;span&gt;157&lt;/span&gt;) : warning C4047: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DWORD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; differs &lt;span&gt;in&lt;/span&gt; levels of indirection from &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NTSTATUS (__stdcall *)(HANDLE)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;ori_sys_service_ptr 是一枚 OriginalSystemServicePtr 型函数指针（ NTSTATUS (__stdcall *)(HANDLE) ），而&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mapped_ki_service_table 是普通指针，它的数组&lt;/span&gt;&lt;span&gt;名称表示法结合数组下标，实际上被视为一个存储对应元素的 DWORD 变量，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者的间接寻址级别不同。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;就目前而言我们可以无视这两条警告，&lt;span&gt;因为含有这段代码的 rootkit 源码在编译后确实能够安全地 hook 目标系统服务函数，系统&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;正常运作不会有问题，&lt;/span&gt;类似的警告可以通过指定警告级别的编译选项来过滤掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;——————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;讲到这里你一定会嫌我既罗嗦又婆婆妈妈的，那么来看下面这一张简明扼要的全局概览，它解释了 MDL 是如何把一片缓冲区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;映射到另一处，并描述两者相同的物理布局，&lt;strong&gt;&lt;span&gt;注意，图中的组织结构是执行完 MmGetSystemAddressForMdlSafe() 后才会产生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129000329850-652575566.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意，上图中我没有给出 PFN 数组中第一个成员携带的具体 20 位物理页框号，原始和映射到的新内核缓冲区，以及实际 RAM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中的物理页框号，而“byte within page”就是页内特定偏移处开始的字节序列，亦即系统服务例程入口点的实际物理地址！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些“占位符”我会在第三部分的调试单元内给出，毕竟，驱动开发与调试是相辅相成的，只有理论没有实践怎么行，只有源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有调试怎知真理，不然，任何人对于内存的需求就真的不会超过 640 K 了。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;——————————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;h2&gt;to be continued&lt;/h2&gt;

</description>
<pubDate>Sun, 28 Jan 2018 15:59:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8372956.html</dc:identifier>
</item>
<item>
<title>OOAD之策略模式（1） - 一个待业码农的救赎</title>
<link>http://www.cnblogs.com/exceptionblog/p/8372941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/exceptionblog/p/8372941.html</guid>
<description>&lt;p&gt;在引入策略模式之前。先用一个小项目解释为什么要有策略模式。这是一个模拟鸭子的小游戏。最开始需求为，所有的鸭子都会叫以及都会游泳且叫声游泳姿势都一样。因此我们用原始OO的思维去编写代码时很容易做到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Duck{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; yuck(){
        System.out.println(&lt;/span&gt;&quot;嘎嘎叫&quot;&lt;span&gt;);
    }

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; swim(){
        Systrm.out.println(&lt;/span&gt;&quot;i am swim&quot;&lt;span&gt;)；
    }              

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是封装一个超类。然后设置两个子类通用的方法，叫和游泳。此时再编写程序需要的各种不同的鸭子子类。他们都能够叫和游泳。此时编写一个测试类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
       Duck gDuck &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreenDuck();
       Duck rDuck  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedDuck();
       
       gDuck.display();
       gDuck.yuck();
       gDuck.swim();

       rDuck.display();
       rDuck.yuck();
       rDuck.swim();
    
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GreenHeadDuck &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Duck{

   @override
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
        System.out.println(&lt;/span&gt;&quot;绿头鸭&quot;&lt;span&gt;);
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedHeadDuck &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Duck{
    
    @override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
        System.out.println(&lt;/span&gt;&quot;红头鸭&quot;&lt;span&gt;);
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类的结果为：绿头鸭   嘎嘎叫  i am swim    红头鸭  嘎嘎叫  i am swim。这个完全没有问题。好的，现在游戏上线，市场火热，新需求来了。鸭子要会飞。那我们继续用OO的思维去想，&lt;/p&gt;
&lt;p&gt;那么可以给超类Duck中设置一个通用的fly方法。让所有的鸭子都会飞。让我们把Duck的代码改一下。改成下面的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Duck{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; yuck(){
        System.out.println(&lt;/span&gt;&quot;嘎嘎叫&quot;&lt;span&gt;);
    }

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; swim(){
        Systrm.out.println(&lt;/span&gt;&quot;i am swim&quot;&lt;span&gt;)；
    }              

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display();

     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly(){
      System.out.println(&lt;/span&gt;&quot;i am flying&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好的，现在的确实现了鸭子会飞的功能，但是这也引起了一些问题。因为事实上不是所有的鸭子都会飞。你在超类中定义了方法。影响的是全部的子类。容易导致溢出的问题，也就是。有些子类不需要。但是你给它强制加了。好，那如果现在有些子类不会飞。我们继续用OO的思维去解决。那么可以在不会飞的子类中用重写去覆盖掉父类给他的方法。我们加入绿头鸭不会飞，我们修改以下绿头鸭的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GreenHeadDuck &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Duck{

   @override
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
        System.out.println(&lt;/span&gt;&quot;绿头鸭&quot;&lt;span&gt;);
    }

    @override
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly(){
       System.out.println(&lt;/span&gt;&quot;i can't fly&quot;&lt;span&gt;)
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好，可以通过在子类中覆盖来实现有些鸭子会费飞有些不会飞这个需求。但是在我们这个例子中鸭子种类少，这么玩没有关系。但如果由2000种鸭子呢。难道你要一个一个的去覆盖子类中的方法。&lt;/p&gt;
&lt;p&gt;很明显就能看出单纯的面向对象，也就是OO的思想在设计这个需求的时候并不完善。那也有些人说，那我不在超类Duck中定义fly的方法。我在子类中去定义，谁会飞我就给谁定义。这其实和上面一样。如果子类基数大。那么你写的重复代码也会很多。那么OO中的代码复用就完全没有体现出来了。&lt;/p&gt;


&lt;p&gt;因此，我们分析以下上面OO设计的问题所在。为什么会说这个设计不好。原因是在于它的行为和客户类没有分离。也就是“干什么” 和 “怎么干”没有分离开来。例如上面的例子。客户类中的fly是干什么，但是怎么干，fly里面怎么定义代码，他们没有分离。全部堆在客户类中，耦合度太高。导致，你的“怎么干“放在客户类中定义，无论你放在超类还是子类。都容易出问题，因此就导出了策略模式这个概念&lt;/p&gt;


&lt;p&gt;策略模式是干嘛的，是去耦合的。它所做的就是把”干什么“和”怎么干“分离开来。把”怎么干“封装到一个策略接口或者抽象类中。然后编写一系列的怎么干算法封装起来。客户类中只需要调用这个算法就ok了&lt;/p&gt;
&lt;p&gt;策略模式的两种标准点的定义：&lt;/p&gt;

&lt;p&gt;图视：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1251553/201801/1251553-20180128234709537-2144696152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　  环境对象(Context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。&lt;br/&gt;      抽象策略对象(Strategy)：它可由接口或抽象类来实现。&lt;br/&gt;      具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换，策略模式让算法独立于使用它的客户而独立变化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使这些算法在客户端调用它们的时候能够互不影响地变化。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;策略模式：分别封装行为接口，实现算法族，超类中放行为接口对象。在子类中的构造方法中去实例化行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能族，让行为算法的变化独立于算法的使用者。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用策略模式的步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.分析变化的行为，拿出来进行封装成一个策略接口或者抽象类。然后定义该行为的多种实现算法。形成算法族&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.在客户超类中放策略接口。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.在子类的构造方法中去具体实例化具体的策略算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;下面让我们看看用策略模式修改模拟鸭子的这个项目。&lt;/p&gt;

&lt;p&gt;1.封装变化的部分。当前鸭子的变化行为为fly。有些会飞，有些不会飞。有些会飞的好，有些飞的不好。因此封装fly这个行为为一个策略接口。FlyObject&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FlyObject{
   &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，编写项目中实现fly这个行为的多种算法。例如不会飞 nofly，飞的好，good fly，飞得不好 badfly。这三个行为族&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NoFly &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; FlyObject{
    
   @override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly(){
       System.out.println(&lt;/span&gt;&quot;不会飞&quot;&lt;span&gt;)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GoodFly &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; FlyObject{

    @override
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly(){
        System.out.println(&lt;/span&gt;&quot;Good fly&quot;&lt;span&gt;);
    }
}            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47.5&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BadFly &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; FlyObject{

   @override
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly(){
       System.out.println(&lt;/span&gt;&quot;bad fly&quot;&lt;span readability=&quot;2&quot;&gt;);
    }
}&lt;p&gt;之后在客户类的超类也就是Duck中放置策略接口，也就是FlyObject。&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyh.strategy.duck;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lyh.strategy.flybehavior.FlyBehavior;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lyh.strategy.yuckbehavior.YuckBehavior;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Duck {

    FlyBehavior flybehavior;
    YuckBehavior yuckbehavior;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Duck() {
        
    };
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly() {
        flybehavior.fly();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; yuck() {
        yuckbehavior.yuck();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setFlyBehavior(FlyBehavior fb) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.flybehavior =&lt;span&gt; fb;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setYuckBehavior(YuckBehavior yb) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.yuckbehavior =&lt;span&gt; yb;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法子类通用，不会变化&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; swim() {
        System.out.println(&lt;/span&gt;&quot;i am swim&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;在客户类的子类中去实例化具体的策略接口算法。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyh.strategy.duck;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lyh.strategy.flybehavior.GoodFlyBehavior;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lyh.strategy.yuckbehavior.GaGaYuckBehavior;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GreenHeadDuck &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Duck {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GreenHeadDuck() {
        flybehavior &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GoodFlyBehavior();
        yuckbehavior &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GaGaYuckBehavior();
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {
        System.out.println(&lt;/span&gt;&quot;绿头鸭&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyh.strategy.duck;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lyh.strategy.flybehavior.NoFlyBehavior;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lyh.strategy.yuckbehavior.NoYuckBehavior;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedHeadDuck &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Duck {

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedHeadDuck() {
        flybehavior &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoFlyBehavior();
        yuckbehavior &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoYuckBehavior();
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {
        System.out.println(&lt;/span&gt;&quot;红头鸭&quot;&lt;span&gt;);
    }

    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span readability=&quot;4&quot;&gt;因此，通过这种方式，能够实现客户类中的行为和客户类相分离。把变化的行为独立出来。抽象成接口。这样如果有新的行为需求，可以直接在行为族中加入。如果有新的客户类对象。也可以让他们&lt;br/&gt;具体选择的去实现行为族。达到降低耦合度的目的。&lt;p&gt;但是，策略模式也有缺点。也就是客户类必须了解策略行为族中的每一个算法的实现以及原理。只有全部知晓。客户类才能去区别调用他们而不会出错。这时策略模式必须要做到的一点。&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;我们什么时候使用策略模式：&lt;/strong&gt;这个没有具体的需求。一般而言。如果你定义的抽象父类中的一些方法是可变的。子类中不一定需要这些方法的时候。建议用策略模式将变化的行为封装起来。这其实也是一种方法的封装。你将行为封装，那么其他的类也可以去使用。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Jan 2018 15:52:00 +0000</pubDate>
<dc:creator>一个待业码农的救赎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/exceptionblog/p/8372941.html</dc:identifier>
</item>
<item>
<title>Google免费GPU使用教程（亲测可用） - Infaraway</title>
<link>http://www.cnblogs.com/infaraway/p/8372881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/infaraway/p/8372881.html</guid>
<description>&lt;p&gt;今天突然看到一篇推文，里面讲解了如何薅资本主义羊毛，即如何免费使用Google免费提供的GPU使用权。&lt;/p&gt;
&lt;p&gt;可以免费使用的方式就是通过Google Colab，全名Colaboratory。我们可以用它来提高Python技能，也可以用Keras、TensorFlow、PyTorch、OpenCV等等流行的深度学习库来练习开发深度学习的应用。&lt;/p&gt;
&lt;p&gt;现在我们介绍如何免费的使用这个非常非常给力的应用！！！&lt;/p&gt;
&lt;h2&gt; 一  项目建立与配置&lt;/h2&gt;
&lt;p&gt;（1）在Google Drive上创建文件夹：这项功能的使用主要是通过Google Drive，首先需要在Google Drive里面创建新的文件夹，因为我们所有的操作都是通过Google Drive文件的方式进行的，&lt;span&gt;这里我们创建了一个名为gpu的文件夹，然后打开文件夹；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）创建新的Colaboratory：右键更多选择Colaboratory， 如果更多没有的话，可以点击关联更多应用搜索添加即可！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128225457459-1965182599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;并且这里可以随意修改文件名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128230133600-1427162067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （3）设置后端Python版本和免费的GPU使用：然后就可以进行代码编写了~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128230320365-2061932740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;二   授权与挂载&lt;/h2&gt;
&lt;p&gt; （4）当完成基本的文件建立和配置后，就需要先运行下面这些代码，来安装必要的库、执行授权：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128230818350-1628850279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; !apt-get install -y -qq software-properties-common python-software-properties module-init-&lt;span&gt;tools
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; !add-apt-repository -y ppa:alessandro-strada/ppa 2&amp;gt;&amp;amp;1 &amp;gt; /dev/&lt;span&gt;null
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; !apt-get update -qq 2&amp;gt;&amp;amp;1 &amp;gt; /dev/&lt;span&gt;null
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; !apt-get -y install -qq google-drive-&lt;span&gt;ocamlfuse fuse
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; google.colab &lt;span&gt;import&lt;/span&gt;&lt;span&gt; auth
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;auth.authenticate_user()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; oauth2client.client &lt;span&gt;import&lt;/span&gt;&lt;span&gt; GoogleCredentials
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; creds =&lt;span&gt; GoogleCredentials.get_application_default()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; getpass
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; !google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret} &amp;lt; /dev/null 2&amp;gt;&amp;amp;1 |&lt;span&gt; grep URL
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; vcode =&lt;span&gt; getpass.getpass()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; !echo {vcode} | google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击运行可以看到如下结果：此时，点击链接地址，获取验证码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128230915428-1149877523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击链接地址，获取验证码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128231004990-78458639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 提示成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128231108772-501542830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （5）授权完成后，就可以挂载Google Drive了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; !mkdir -&lt;span&gt;p drive
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; !google-drive-ocamlfuse drive
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三   测试阶段&lt;/h2&gt;
&lt;p&gt;我们使用安装Keras中的测试样例代码进行效果的测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;Trains a simple convnet on the MNIST dataset.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;Gets to 99.25% test accuracy after 12 epochs
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;(there is still a lot of margin for parameter tuning).
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;16 seconds per epoch on a GRID K520 GPU.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; print_function
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mnist
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense, Dropout, Flatten
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Conv2D, MaxPooling2D
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; batch_size = 128
&lt;span&gt;19&lt;/span&gt; num_classes = 10
&lt;span&gt;20&lt;/span&gt; epochs = 12
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; input image dimensions&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; img_rows, img_cols = 28, 28
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; the data, shuffled and split between train and test sets&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; (x_train, y_train), (x_test, y_test) =&lt;span&gt; mnist.load_data()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; K.image_data_format() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;channels_first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     x_train = x_train.reshape(x_train.shape[0], 1&lt;span&gt;, img_rows, img_cols)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     x_test = x_test.reshape(x_test.shape[0], 1&lt;span&gt;, img_rows, img_cols)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     input_shape = (1&lt;span&gt;, img_rows, img_cols)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     input_shape = (img_rows, img_cols, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; x_train = x_train.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; x_test = x_test.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; x_train /= 255
&lt;span&gt;40&lt;/span&gt; x_test /= 255
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x_train shape:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, x_train.shape)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(x_train.shape[0], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;train samples&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(x_test.shape[0], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test samples&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; convert class vectors to binary class matrices&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; y_train =&lt;span&gt; keras.utils.to_categorical(y_train, num_classes)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; y_test =&lt;span&gt; keras.utils.to_categorical(y_test, num_classes)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; model =&lt;span&gt; Sequential()
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; model.add(Conv2D(32, kernel_size=(3, 3&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                  activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                  input_shape=&lt;span&gt;input_shape))
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; model.add(Conv2D(64, (3, 3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; model.add(MaxPooling2D(pool_size=(2, 2&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; model.add(Dropout(0.25&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;model.add(Flatten())
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; model.add(Dense(128, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; model.add(Dropout(0.5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; model.add(Dense(num_classes, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; model.compile(loss=&lt;span&gt;keras.losses.categorical_crossentropy,
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;               optimizer=&lt;span&gt;keras.optimizers.Adadelta(),
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;               metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;model.fit(x_train, y_train,
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;           batch_size=&lt;span&gt;batch_size,
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;           epochs=&lt;span&gt;epochs,
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;           verbose=1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;           validation_data=&lt;span&gt;(x_test, y_test))
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; score = model.evaluate(x_test, y_test, verbose=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test loss:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, score[0])
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test accuracy:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, score[1])&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里使用Google GPU的效率每个Epoch大概需要11s左右即可完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128231353834-37826241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 而我们使用实验室的工作站&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128231553990-560772689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 每个率每个Epoch大概需要130s+完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/812218/201801/812218-20180128231614694-807036137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt; 四  相关命令&lt;/h2&gt;
&lt;p&gt;（1）查看是否使用GPU：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; tf.test.gpu_device_name()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）在使用哪个GPU：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tensorflow.python.client &lt;span&gt;import&lt;/span&gt;&lt;span&gt; device_lib
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; device_lib.list_local_devices()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）RAM大小：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; !cat /proc/meminfo
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然Google的使用需要自备FQ工具！&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d&quot; target=&quot;_blank&quot;&gt;https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 28 Jan 2018 15:25:00 +0000</pubDate>
<dc:creator>Infaraway</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/infaraway/p/8372881.html</dc:identifier>
</item>
<item>
<title>全栈开发之HTML快速入门（一） - skyflask</title>
<link>http://www.cnblogs.com/skyflask/p/8325035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyflask/p/8325035.html</guid>
<description>&lt;h2&gt;一、HTML 是什么？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;HTML 指的是超文本标记语言 (&lt;strong&gt;H&lt;/strong&gt;yper &lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;M&lt;/strong&gt;arkup &lt;strong&gt;L&lt;/strong&gt;anguage)&lt;/li&gt;
&lt;li&gt;HTML 不是一种编程语言，而是一种标记语言 (markup language)&lt;/li&gt;
&lt;li&gt;标记语言是一套标记标签 (markup tag)&lt;/li&gt;
&lt;li&gt;HTML 使用标记标签来描述网页&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二、HTML基本结构&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;html&amp;gt;                             ----根控制标记
    &amp;lt;head&amp;gt;                             ---头控制标记
        &amp;lt;title&amp;gt;这是标题&amp;lt;/title&amp;gt;       ----标题标记
    &amp;lt;/head&amp;gt;                            ----头控制标记
    &amp;lt;body&amp;gt;
                             ----- 我是Body！！！
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;                            ----根控制标记
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1、head部分的标签&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;title&amp;gt;、&amp;lt;base&amp;gt;、&amp;lt;link&amp;gt;、&amp;lt;meta&amp;gt;、&amp;lt;script&amp;gt; 以及 &amp;lt;style&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;title&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义浏览器工具栏中的标题&lt;/li&gt;
&lt;li&gt;提供页面被添加到收藏夹时显示的标题&lt;/li&gt;
&lt;li&gt;显示在搜索引擎结果中的页面标题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;meta&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文档描述【网站在搜索时，进行描述。】
&lt;ul&gt;&lt;li&gt;&amp;lt;meta name=&quot;description&quot; content=&quot;在这里您可以详细浏览一汽-大众全线车型、一汽-大众授权经销商、一汽-大众二手车、一汽-大众服务等内容，体验一汽-大众精彩生活！&quot;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;文档关键词【网站在搜索时，进行关键字匹配】
&lt;ul&gt;&lt;li&gt;&amp;lt;meta name=&quot;keywords&quot; content=&quot;一汽-大众,一汽大众官网,大众一汽,一汽官网,一汽-大众官方网站&quot;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;重定向【页面重定向】
&lt;ul&gt;&lt;li&gt;&amp;lt;meta http-equiv=&quot;Refresh&quot;content=&quot;2;URL=https://www.baidu.com&quot;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;link用于导入css&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot; /&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;script用于导入js&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/code&gt;document.write(&quot;Hello World!&quot;)&lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;style用于定义css&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;

p {

background-color:red;

font-size:15px;

　　}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;base:定义页面上所有链接的默认地址或默认目标.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;base href=&quot;http://www.w3school.com.cn/i/&quot; /&amp;gt;

&amp;lt;img src=&quot;eg_smile.gif&quot; /&amp;gt;&amp;lt;br /&amp;gt;  #引入图片时，会和base进行拼接后再查找图片。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2、body部分的标签&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一、常用标签:&amp;lt;h1&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;h1~h6&amp;gt;:从大到小. 表示标题.

&amp;lt;p&amp;gt;: 段落标签. 包裹的内容被换行.并且也上下内容之间有一行空白.

&amp;lt;b&amp;gt; &amp;lt;strong&amp;gt;: 加粗标签.

&amp;lt;strike&amp;gt;: 为文字加上一条中线.

&amp;lt;em&amp;gt;: 文字变成斜体.

&amp;lt;sup&amp;gt;和&amp;lt;sub&amp;gt;: 上角标 和 下角表.

&amp;lt;br/&amp;gt;:换行. 单标签

&amp;lt;hr&amp;gt;:水平线

 &amp;lt;div&amp;gt; :块，主要用于布局

&amp;lt;span&amp;gt;：内联标签
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;块级标签和内联标签区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
块级标签和内联标签

块级标签：&amp;lt;p&amp;gt;&amp;lt;h1&amp;gt;&amp;lt;table&amp;gt;&amp;lt;ol&amp;gt;&amp;lt;ul&amp;gt;&amp;lt;form&amp;gt;&amp;lt;div&amp;gt;

内联标签：&amp;lt;a&amp;gt;&amp;lt;input&amp;gt;&amp;lt;img&amp;gt;&amp;lt;sub&amp;gt;&amp;lt;sup&amp;gt;&amp;lt;textarea&amp;gt;&amp;lt;span&amp;gt;

block（块）元素的特点
① 占领一整行，新增元素新起一行；
② 高度，行高以及外边距和内边距都可调整；
③ 宽度缺省是它的容器的100%，除非设定一个宽度，一般都是占满一行。
④ 它可以容纳内联元素和其他块元素

inline元素的特点
① 和其他元素都在一行上；
② 高，行高及外边距和内边距不可改变；
③ 宽度就是它的文字或图片的宽度，不可改变
④ 内联元素只能容纳文本或者其他内联元素

对inline元素，需要注意如下 
设置宽度width 无效。
设置高度height 无效，可以通过line-height来设置。
设置margin 只有左右margin有效，上下无效。
设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;二 、图形标签: &amp;lt;img&amp;gt; &lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;src: 要显示图片的路径.&lt;/li&gt;
&lt;li&gt;alt: 图片没有加载成功时的提示.&lt;/li&gt;
&lt;li&gt;title: 鼠标悬浮时的提示信息.&lt;/li&gt;
&lt;li&gt;width: 图片的宽&lt;/li&gt;
&lt;li&gt;height:图片的高 (宽高两个属性只用一个会自动等比缩放.)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3school.com.cn/i/eg_tulip.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;花朵&quot;&lt;/span&gt;&lt;span&gt; title&lt;/span&gt;&lt;span&gt;=&quot;图片标题&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;100px&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;100px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128223829194-908098046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;三、 超链接标签:&amp;lt;a&amp;gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;href:要连接的资源路径 格式如下: href=&quot;http://www.baidu.com&quot; &lt;/li&gt;
&lt;li&gt;target: _blank : 在新的窗口打开超链接. 框架名称: 在指定框架中打开连接内容.&lt;/li&gt;
&lt;li&gt;name: 定义一个页面的书签.&lt;/li&gt;
&lt;li&gt;用于跳转 href : #书签名称.&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点击我跳转到百度哦&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;_blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点击在本页&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;四 、列表标签:&amp;lt;ul&amp;gt;&amp;lt;ol&amp;gt;&amp;lt;dl&amp;gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;ul&amp;gt;: 无序列表&lt;/li&gt;
&lt;li&gt;&amp;lt;ol&amp;gt;:有序列表&lt;/li&gt;
&lt;li&gt;         &amp;lt;li&amp;gt;:列表中的每一项.&lt;/li&gt;
&lt;li&gt;&amp;lt;dl&amp;gt; 定义列表&lt;/li&gt;
&lt;li&gt;         &amp;lt;dt&amp;gt; 列表标题&lt;/li&gt;
&lt;li&gt;         &amp;lt;dd&amp;gt; 列表项&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;First term&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Definition&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Next term&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Definition&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;circle&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background:pink&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;无序列表1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;无序列表2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;无序列表3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;无序列表4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;无序列表5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ol &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;a&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background:green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;有序列表1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;有序列表2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;有序列表3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;有序列表4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;有序列表5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ol&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128224153897-1211653992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128224213647-974603126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128224224834-1788521803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;五 、表格标签: &amp;lt;table&amp;gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;border: 表格边框.&lt;/li&gt;
&lt;li&gt;cellpadding: 内边距&lt;/li&gt;
&lt;li&gt;cellspacing: 外边距.&lt;/li&gt;
&lt;li&gt;width: 像素 百分比.（最好通过css来设置长宽）&lt;/li&gt;
&lt;li&gt;&amp;lt;tr&amp;gt;: table row&lt;/li&gt;
&lt;li&gt;         &amp;lt;th&amp;gt;: table head cell&lt;/li&gt;
&lt;li&gt;         &amp;lt;td&amp;gt;: table data cell&lt;/li&gt;
&lt;li&gt;rowspan: 单元格竖跨多少行&lt;/li&gt;
&lt;li&gt;colspan:  单元格横跨多少列（即合并单元格）&lt;/li&gt;
&lt;li&gt;&amp;lt;th&amp;gt;: table header &amp;lt;tbody&amp;gt;(不常用): 为表格进行分区.&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; cellpadding&lt;/span&gt;&lt;span&gt;=&quot;20px&quot;&lt;/span&gt;&lt;span&gt; cellspacing&lt;/span&gt;&lt;span&gt;=&quot;10px&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background:green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;性别&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;colspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;color:red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;胖子 男占2列&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;男&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;rowspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;color:red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;高个占2行&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;男&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;qq&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;女&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128224136475-969879211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;六 、表单标签：&amp;lt;form&amp;gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fieldset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;legend&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;legend&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
           用户名：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;='username' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;defaultname&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
           密码:&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;='password' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
            性别:男&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;男&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                 女&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;女&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
            兴趣:篮球&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;hobby&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                 足球&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;hobby&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                 水球&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;hobby&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                 玻璃球&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;hobby&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
            上传文件:&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
            所属部门：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;department&quot;&lt;/span&gt;&lt;span&gt; multiple&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;optgroup  &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;研发部&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;de_01&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;研发1部&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;de_02&quot;&lt;/span&gt;&lt;span&gt; selected&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;研发2部&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;de_03&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;研发3部&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;optgroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;optgroup &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;技术部&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;mercedes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;运维&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;audi&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;开发&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;optgroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           　　　　 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
            个人说明：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;cols&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt; rows&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是个人说明个人说明&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fieldset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fieldset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128224311975-1563416911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;七、框架:&amp;lt;frameset&amp;gt; &lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;frameset &lt;/span&gt;&lt;span&gt;cols&lt;/span&gt;&lt;span&gt;=&quot;25%,50%,25%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;frame &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/example/html/frame_a.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;frame &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/example/html/frame_b.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;frame &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/example/html/frame_c.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;frameset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128224540990-339371150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;八、布局:&amp;lt;div+css&amp;gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&amp;lt;div&amp;gt; 元素常用作布局工具，因为能够轻松地通过 CSS 对其进行定位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
body &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
#header &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
#nav &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;30px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#eeeeee&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;          
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
#section &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;350px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;          
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
#footer &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    clear&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
   padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;          
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;中国&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;nav&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
北京&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
上海&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
深圳&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;section&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;上海&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
上海市总面积6340平方公里，辖16个市辖区，属亚热带湿润季风气候，四季分明，日照充分，雨量充沛。
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
上海，简称“沪”或“申”，是gcd的诞生地，中华人民共和国直辖市，国家中心城市，超大城市，国际经济、金融、贸易、航运、科技创新中心[1]  ，首批沿海开放城市。上海地处长江入海口，是长江经济带的龙头城市，隔东中国海与日本九州岛相望，南濒杭州湾，北、西与江苏、浙江两省相接。

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;footer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
www.example.com
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/462684/201801/462684-20180128230213678-1051904799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 28 Jan 2018 15:06:00 +0000</pubDate>
<dc:creator>skyflask</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyflask/p/8325035.html</dc:identifier>
</item>
<item>
<title>Android查缺补漏（View篇）--事件分发机制源码分析 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/8372807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/8372807.html</guid>
<description>&lt;p&gt;在上一篇博文中分析了事件分发的流程及规则，本篇会从源码的角度更进一步理解事件分发机制的原理，如果对事件分发规则还不太清楚的童鞋，建议先看一下上一篇博文 &lt;a href=&quot;http://www.cnblogs.com/codingblock/p/8227647.html&quot;&gt;《Android查缺补漏（View篇）--事件分发机制》&lt;/a&gt; ，先来看一下本篇的分析思路，一会儿会按照事件传递的顺序，针对以下几点进行源码分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Activity对点击事件的分发过程&lt;/li&gt;
&lt;li&gt;PhoneWindow是如何处理点击事件的&lt;/li&gt;
&lt;li&gt;顶级View对点击事件的分发过程&lt;/li&gt;
&lt;li&gt;View对点击事件的处理过程&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;activity对点击事件的分发过程&quot;&gt;Activity对点击事件的分发过程&lt;/h3&gt;
&lt;p&gt;通过上一篇博文中我们就知道了当一个点击事件发生后，最先传递给当前的Activity，并有Activity的dispatchTouchEvent方法来分发，其具体的分发工作时由Activity内部的Window处理的。&lt;/p&gt;
&lt;p&gt;Activity的dispatchTouchEvent方法源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction(); // 这是一个空方法，不用理会
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在dispatchTouchEvent内部我们看到通过getWindow获取了Window，然后将事件分发的处理操作交给了Window，通过上述源码我们即可看出从大的流程上Window将分发给顶级View，如果在getWindow().superDispatchTouchEvent(ev)这一步返回了true，那么事件循环就此结束，返回false意味着各界的View的onTouchEvent都返回了false，最终会去调用当前Activity的onTouchEvent。&lt;/p&gt;
&lt;h3 id=&quot;phonewindow是如何处理点击事件的&quot;&gt;PhoneWindow是如何处理点击事件的&lt;/h3&gt;
&lt;p&gt;接着详细看一下在getWindow().superDispatchTouchEvent(ev)中都干了啥，我们知道Window是一个抽象类，我们必须找出他们实现类才可以进行下一步分析，很简单，通过在Activity中搜索mWindow变量，很快我们就在Activity的attch方法中找到了它的赋值过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        ...// 省略其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，Window的实现类就是PhoneWindow，接下来直接去看PhoneWindow的superDispatchTouchEvent方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PhoneWindow什么都没做，直接把DecorView，DecorView就是Activity的顶级View，在Activity中可以通过getWindow().getDecorView()获取。&lt;/p&gt;
&lt;h3 id=&quot;顶级viewdecorview对点击事件的分发过程&quot;&gt;顶级View（DecorView）对点击事件的分发过程&lt;/h3&gt;
&lt;p&gt;DecorView的superDispatchTouchEvent源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实DecorView继承了FrameLayout，当然也是一个ViewGroup，所以这里我们再跳转到ViewGroup的dispatchTouchEvent方法中进一步分析，在上一篇博文&lt;a href=&quot;http://www.cnblogs.com/codingblock/p/8227647.html&quot;&gt;《Android查缺补漏（View篇）--事件分发机制》&lt;/a&gt; 中已经详细介绍了ViewGroup的dispatchTouchEvent对点击事件分发的流程，这里再通过源代码了解一下它的实现过程。&lt;/p&gt;
&lt;p&gt;这个方法非常长，但我们一步步分析还是能找到一些头绪的，请着重看代码中注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    
    ...

    boolean handled = false;
    // 对事件进行安全过滤
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;

        // 初始化事件流的状态，当有down类型的touch事件传来时说明是一个新的事件流，此时需要重置事件状态。
        
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }

        // 检查是否拦截事件，当事件交由ViewGroup的子元素处理时，就会将mFirstTouchTarget赋值并指向子元素。
        // 更详细来说就是，当ViewGroup拦截事件时，mFirstTouchTarget为null，这时候除了down以外的事件类型到来时将不再调用onInterceptTouchEvent，同一事件流中的其他时间类型都会讲给ViewGroup处理。当ViewGroup不拦截事件时，mFirstTouchTarget将会被赋值指向为子元素。
        
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
                // 这里包含了一种特殊情况，那就是在子View中可以通过requesetDisallowInterceptTouchEvent方法来干预ViewGroup对除了down以外的事件的分发过程，
                // 这里的FLAG_DISALLOW_INTERCEPT标记为就是通过在requestDisallowInterceptTouchEvent方法来设置的，FLAG_DISALLOW_INTERCEPT被设置后，ViewGroup就不在对事件拦截。
                // 当down事件传来后，在前面的resetTouchState方法中会对FLAG_DISALLOW_INTERCEPT重置，所以说子View无法影响ViewGroup对down事件的处理。
                
            final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }

        // If intercepted, start normal event dispatch. Also if there is already
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }

        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this)
                || actionMasked == MotionEvent.ACTION_CANCEL;

        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags &amp;amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled &amp;amp;&amp;amp; !intercepted) {

            // If the event is targeting accessiiblity focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                    ? findChildWithAccessibilityFocus() : null;

            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                final int actionIndex = ev.getActionIndex(); // always 0 for down
                final int idBitsToAssign = split ? 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList&amp;lt;View&amp;gt; preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null
                            &amp;amp;&amp;amp; isChildrenDrawingOrderEnabled();
                            
                            // 当ViewGroup不拦截事件的情况下，事件就会交给子View处理
                            // 首先遍历ViewGroup的所有子View，判断子View是否能够接收到点击事件：
                            // 判断的依据是：子元素是否在播放动画和点击事件的坐标是否落在子元素的范围内。
                            
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(
                                childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                                preorderedList, children, childIndex);

                        // If there is a view that has accessibility focus we want it
                        // to get the event first and if not handled we will perform a
                        // normal dispatch. We may do a double iteration but this is
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }

                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        resetCancelNextUpFlag(child);
                        
                        /*
                         这里的dispatchTransformedTouchEvent方法实际调用的就是子元素的dispatchTouchEvent方法。
                         这个方法内部有一段逻辑是这样：
                            if (child == null) {
                                handled = super.dispatchTouchEvent(event);
                            } else {
                                handled = child.dispatchTouchEvent(event);
                            }
                        由于这里传入的child非null，所以此时事件就交给了子view处理。
                        
                        如果子View的dispatchTouchEvent方法返回了true，那么mFirstTouchTarget就会被赋值（在addTouchTarget()中被赋值），同时跳出for循环。
                        如果子View返回了false，那就继续循环，按同样的套路将调用下一个子View的dispatchTouchEvent方法。（例如：多个View重叠在一起时，这样在该区域就有多个满足接收点击事件的条件的控件）
                         
                         */
                         
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j &amp;lt; childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null) preorderedList.clear();
                }

                if (newTouchTarget == null &amp;amp;&amp;amp; mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }

        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            /*
            mFirstTouchTarget为null时，ViewGroup就会拦截接下来的同一序列中的所有事件。
            如果遍历了所有的子元素事件都没有被合适的处理（可能是因为该ViewGroup没有子View，或者在子View的dispatchTouchEvent方法返回了false），ViewGroup就会自己处理事件。
            
            这里的第三个参数传入了null，在dispatchTransformedTouchEvent中通过以下逻辑即可知道会调用super.dispatchTouchEvent(event);
            
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            */
        
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
            ...
        }
        ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码是对顶级View（其实也是ViewGroup）事件分发的分析，接下来再看看当事件传递给View时，View对事件的处理代码。&lt;/p&gt;
&lt;h3 id=&quot;view对点击事件的处理过程&quot;&gt;View对点击事件的处理过程&lt;/h3&gt;
&lt;p&gt;从上面的分析我们可知，ViewGroup是通过调用View的dispatchTouchEvent方法将事件传递给View的，那么就来看一下View的dispatchTouchEvent方法源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
    
    ...

    if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; handleScrollBarDragging(event)) {
            result = true;
        }
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
                &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {
            result = true;
        }
    }

    ...

    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的源码中，首先会获取View的ListenerInfo判断有没有设置OnTouchListener，如果设置了并且在OnTouchListener中的onTouch方法返回了true，那么就不再调用View自身的onTouchEvent方法，至此我们也找到了OnTouchListener监听器中的onTouch方法优先于onTouchEvent方法的原因。&lt;/p&gt;
&lt;p&gt;接着再看onTouchEvent方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    final boolean clickable = ((viewFlags &amp;amp; CLICKABLE) == CLICKABLE
            || (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags &amp;amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    
    // 从这段代码可知，即使不可用状态的控件也会消费事件。
    if ((viewFlags &amp;amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;amp;&amp;amp; (mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn't respond to them.
        return clickable;
    }
    
    // mTouchDelegate是View的代理，有代理的情况下回调用代理的onTouchEvent方法。
    
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 从上面代码为clickable赋值时我们可以知道，不管View是不是disable状态，只要它的CLICKABLE和LONG_CLICKABLE有一个为true时，它就会消耗这个事件。

    if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags &amp;amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;amp;&amp;amp; isFocusableInTouchMode() &amp;amp;&amp;amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }

                    if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                            
                                // action_up事件会触发performClick方法，在performClick方法中调用了View的onClickListener监听器的onClick方法。
                                
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;

                if (!clickable) {
                    checkForLongClick(0, x, y);
                    break;
                }

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                break;

            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                }
                break;
        }

        return true;
    }

    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当action_up事件到来时会触发performClick方法，在performClick方法中调用了View的onClickListener监听器的onClick方法，所以至此我们应该知道onClick方法是在up事件发生后调用的，优先级最低。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean performClick() {
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null &amp;amp;&amp;amp; li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }

    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);

    notifyEnterOrExitForAutoFillIfNeeded(true);

    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;到这里整个事件分发的源码基本分析完毕，大体总结一下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当点击事件产生后，会首先触发Activity的dispatchTouchEvent方法，在此方法中会将事件传递个PhoneWindow处理;&lt;/li&gt;
&lt;li&gt;在PhoneWindow的dispatch方法中又将事件传递个了DecorView的dispatchTouchEvent;&lt;/li&gt;
&lt;li&gt;接着DecorView又调用了父类ViewGroup的dispatchTouchEvent方法对事件进行了分发;&lt;/li&gt;
&lt;li&gt;在ViewGroup的dispatchTouchEvent方法中，首先先判断了自身是否拦截事件，如果拦截那么事件不再向其子View传递，如果不拦截就会遍历其所有的子View找到可以适合接收事件的子View并调用子View的dispatchTouchEvent方法。&lt;/li&gt;
&lt;li&gt;在子View的dispatchTouchEvent方法中对事件做相应处理。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;em&gt;最后想说的是，本系列文章为博主对Android知识进行再次梳理，查缺补漏的学习过程，一方面是对自己遗忘的东西加以复习重新掌握，另一方面相信在重新学习的过程中定会有巨大的新收获，如果你也有跟我同样的想法，不妨关注我一起学习，互相探讨，共同进步！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考文献：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;《Android开发艺术探索》&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 28 Jan 2018 15:04:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/8372807.html</dc:identifier>
</item>
</channel>
</rss>