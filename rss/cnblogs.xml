<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>后缀表达式做计算器程序 - kami_coder</title>
<link>http://www.cnblogs.com/kamicoder/p/8593627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kamicoder/p/8593627.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;概念：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后缀表达式是相较于中缀表达式而言的，像我们平时写的2+3*(4-(5+6))/7就是一个中缀表达式，那么如何将之变为后缀表达式呢？后缀表达式如何用来求解呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;先来第一个问题（中缀-&amp;gt;后缀）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;变为后缀表达式方法&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span&gt;规则&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;/span&gt;&lt;span&gt;遇到操作数：直接添加到后缀表达式中&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;/span&gt;&lt;span&gt;栈为空时，遇到运算符，直接入栈&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.&lt;/span&gt;&lt;span&gt;遇到左括号：将其入栈&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.&lt;/span&gt;&lt;span&gt;遇到右括号：执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.&lt;/span&gt;&lt;span&gt;遇到其他运算符：加减乘除：弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.&lt;/span&gt;&lt;span&gt;最终将栈中的元素依次出栈，输出。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;用一个实例来分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;X = 2+3*(4-(5+6))/7&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;、遇到操作数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;，添加到后缀表达式中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                          　　 2 （此时的后缀表达式，下同）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;、栈为空，遇到加号‘&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;+&lt;/span&gt;&lt;span&gt;’，将‘&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;+&lt;/span&gt;&lt;span&gt;’入栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                        　 2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;、遇到操作数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;，添加到后缀表达式中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                           　　23&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;、遇到操作符&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘*’&lt;/span&gt;&lt;span&gt;，栈顶为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘+’&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘*’&lt;/span&gt;&lt;span&gt;优先级大于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘-’&lt;/span&gt;&lt;span&gt;，不出栈，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘*’&lt;/span&gt;&lt;span&gt;入栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; 　　　　　　　 23&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;&lt;span&gt;、遇到左括号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;’&lt;/span&gt;&lt;span&gt;，直接入栈。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                                   　　   23&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6&lt;/span&gt;&lt;span&gt;、遇到操作数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;，添加到后缀表达式中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                         　　  234&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;7&lt;/span&gt;&lt;span&gt;、遇到减号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘-’&lt;/span&gt;&lt;span&gt;，栈顶为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;’&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘-’&lt;/span&gt;&lt;span&gt;入栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                              　　   234&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;8&lt;/span&gt;&lt;span&gt;、遇到左括号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;’&lt;/span&gt;&lt;span&gt;，直接入栈。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                                    　　   234&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;9&lt;/span&gt;&lt;span&gt;、遇到操作数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;&lt;span&gt;，添加到后缀表达式中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                           　　 2345&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;10&lt;/span&gt;&lt;span&gt;、遇到加号‘&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;+&lt;/span&gt;&lt;span&gt;’，栈顶为‘（’，&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;‘+’&lt;/span&gt;&lt;span&gt;入栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                     　2345&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;11&lt;/span&gt;&lt;span&gt;、遇到操作数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;6&lt;/span&gt;&lt;span&gt;，添加到后缀表达式中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                         　　 23456&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;12&lt;/span&gt;&lt;span&gt;、遇到右括号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;’(&lt;/span&gt;&lt;span&gt;不入栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span&gt;，出栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘+’&lt;/span&gt;&lt;span&gt;，出栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;’&lt;/span&gt;&lt;span&gt;（不添加到后缀表达式中）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;  　　  23456+&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;13&lt;/span&gt;&lt;span&gt;、遇到右括号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;’(&lt;/span&gt;&lt;span&gt;不入栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span&gt;，出栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘-’&lt;/span&gt;&lt;span&gt;，出栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;’&lt;/span&gt;&lt;span&gt;（不添加到后缀表达式中）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;   　　  23456+-&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;14&lt;/span&gt;&lt;span&gt;、遇到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘/’&lt;/span&gt;&lt;span&gt;，栈顶为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘*’&lt;/span&gt;&lt;span&gt;，&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;‘/’&lt;/span&gt;&lt;span&gt;优先级大于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘*’&lt;/span&gt;&lt;span&gt;，将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘*’&lt;/span&gt;&lt;span&gt;出栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                          　   23456+-*&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;15&lt;/span&gt;&lt;span&gt;、遇到操作时&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;7&lt;/span&gt;&lt;span&gt;，添加到后缀表达式中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                         　　 23456+-*7&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;16&lt;/span&gt;&lt;span&gt;、把栈中剩下的符号都出栈&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;                                                                          　　 23456+-*7/+&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104884/201803/1104884-20180317231538932-1916577992.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;190&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104884/201803/1104884-20180317231617196-773480549.png&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;189&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104884/201803/1104884-20180317234118568-395991920.png&quot; alt=&quot;&quot; width=&quot;59&quot; height=&quot;190&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
char* postfix_expression(string str)
{
        char *temp=new char(100);
        int j=0;
        for(int i=0; i&amp;lt;str.size(); i++)
        {
                if(str[i]&amp;gt;='0' &amp;amp;&amp;amp; str[i]&amp;lt;='9')
                        temp[j++]=str[i];
                else
                {
                        if(str[i]==')')
                        {
                                while(S_c.top()!='(')
                                {
                                        temp[j++] = S_c.top();
                                        S_c.pop();
                                }
                                S_c.pop();
                        }
                        //如果符号是*或/高优先级，弹出所有*和/ 
                        else if(str[i]=='*'||str[i]=='/')
                        {
                                if(!S_c.empty())
                                        if(S_c.top()=='*'||S_c.top()=='/')
                                        {
                                                temp[j++] = S_c.top();
                                                S_c.pop();
                                        }
                                S_c.push(str[i]);
                        }
                        //如果符号是+或-低优先级，弹出所有*/+- 
                        else if(str[i]=='+'||str[i]=='-')
                        {
                                if(!S_c.empty())
                                        if(S_c.top()=='*'||S_c.top()=='/'||S_c.top()=='+'||S_c.top()=='-')
                                        {
                                                temp[j++] = S_c.top();
                                                S_c.pop();
                                        }
                                S_c.push(str[i]);
                        }
                        else
                                S_c.push(str[i]);       
                }
        }
        while(!S_c.empty())
        {
                temp[j++] = S_c.top();
                S_c.pop();
        }
        return temp;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二个问题，如何使用后缀表达式来解表达式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后缀表达式已经将计算的优先顺序排好，只需要将后缀表达式的数字逐个入栈，直到遇到符号，将前栈顶两个元素运算放回栈顶即可。&lt;/p&gt;
&lt;p&gt;以上面的后缀表达式为例：&lt;/p&gt;
&lt;p&gt;23456+-*7/+&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104884/201803/1104884-20180317232603425-394544590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上代码~&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;

stack&amp;lt;int&amp;gt; S_n;
stack&amp;lt;char&amp;gt; S_c;
&lt;br/&gt;//上面的后缀表达式转换函数
char* postfix_expression(string str)；

int main()
{
        string str;
        char *pe;
        int temp;
        cin&amp;gt;&amp;gt;str;
        //将str转为后缀表达式 
        pe = postfix_expression(str);
        for(int i=0; i&amp;lt;strlen(pe); i++)
        {
                if(pe[i]&amp;gt;='0'&amp;amp;&amp;amp;pe[i]&amp;lt;='9')
                {
                        S_n.push(pe[i]-'0');
                }
                else if(pe[i]=='*')
                {
                        temp = S_n.top();
                        S_n.pop();
                        temp *= S_n.top();
                        S_n.pop();
                        S_n.push(temp);
                }
                else if(pe[i]=='/')
                {
                        temp = S_n.top();
                        S_n.pop();
                        temp = S_n.top()/temp;
                        S_n.pop();
                        S_n.push(temp);
                }
                else if(pe[i]=='+')
                {
                        temp = S_n.top();
                        S_n.pop();
                        temp += S_n.top();
                        S_n.pop();
                        S_n.push(temp);
                }
                else if(pe[i]=='-')
                {
                        temp = S_n.top();
                        S_n.pop();
                        temp = S_n.top()-temp;
                        S_n.pop();
                        S_n.push(temp);
                }
        }
        cout&amp;lt;&amp;lt;pe&amp;lt;&amp;lt;endl; 
        cout&amp;lt;&amp;lt;S_n.top()&amp;lt;&amp;lt;endl;
        return 0;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104884/201803/1104884-20180317233027222-1960729449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>kami_coder</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kamicoder/p/8593627.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（八）WPF窗体之间的交互 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8593531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8593531.html</guid>
<description>&lt;p&gt;          今天我们一起来看一下WPF窗体之间的交互-窗体之间的传值。有两个窗体，一个是父窗体，一个是子窗体。要将父窗体的文本框中的值传递给子窗体中的控件。我们该怎么实现？&lt;/p&gt;
&lt;p&gt;       接下来我们一起来实现窗体之间的传值，在父窗体上我们放两个控件，一个文本框TxtMessage，另一个是按钮BtnSend.子窗体上放一个文本框TxtInput。&lt;/p&gt;
&lt;p&gt;父窗体的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231435725-1502930886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;子窗体的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231446110-739943999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      要实现传值，我们首先要在子窗体中定义一个可读可写的公用的字符串：getMessage。然后在父窗体中按下按钮的时候，定义一个字符串Message，用来存放输入框的文字。再将Message中存放的输入框的文字传递给子窗体中定义的可读可写的公用字符串getMessage。下面看一下实现的后台代码：&lt;/p&gt;
&lt;p&gt;父窗体的后台代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231455483-1361680844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;子窗体的后台代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231502604-1013659110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看一下运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231511120-377523635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       看到这里是不是感觉很简单咧?当然在我们写程序时，可能使用的就不只是单纯的传递一个值那么简单的。因为本人还刚接触到一个WPF项目，没有想过的场景。这里我进行假设一个场景，依然还是有父子窗体，子窗体是父窗体中一个按钮的属性设置器，在子窗体中添上要设置属性的值，然后按设置完成，子窗体关闭，父窗体的相应按钮的属性也根据子窗体中的设置值而改变！不知道大家明不明白我的意思，这个场景不明白的多看一次应该知道了，上面是简单传值，这个场景简单地说就是窗体之间的信息交互。下面就进入正题，怎么进行交互？其实这里只是实现这个场景的一种方法，也是比较简单的方法，用到的知识是C#中的委托。这里演示一个最简单的例子：&lt;/p&gt;
&lt;p&gt;下面看一下具体实现&lt;/p&gt;
&lt;p&gt;在上一个例子中的子窗体新增一个按钮返回BtnReturn。&lt;/p&gt;
&lt;p&gt;首先，自定义一个公共类MessageHelp，用来封装委托类型的。&lt;/p&gt;
&lt;p&gt;public class MessageHelp&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        public delegate void delegateMessage(int num);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;然后，我们看一下子窗体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231520541-1313890076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;新增数值验证规则类，这个在前面一篇中已经讲了验证规则，这里就不在细说了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231530381-217905132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;好了，设定了回调函数，然后看一下主窗口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231537810-311163971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先声明了子窗体，然后child.CallBackMethod设置为自己的函数Method，当然这个Method和委托的参数是一致的，然后就在这里响应委托给过来的参数，处理。大概就这样了，效果图是这样：&lt;/p&gt;
&lt;p&gt;先输入一个 12，按返回。父窗体的文本框也是12&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180317231550192-1722995763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 15:21:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8593531.html</dc:identifier>
</item>
<item>
<title>UWP 使用Telerik Chart控件 - 星期八再娶你</title>
<link>http://www.cnblogs.com/hupo376787/p/8593346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hupo376787/p/8593346.html</guid>
<description>&lt;p&gt;Telerik开发的chart功能异常强大 用户可以自行在商店搜索“UI for uwp demos”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/298986/201803/298986-20180317224058870-1394257034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;下面我就结合以下我的软件，来说明一下饼状图的实现。&lt;/p&gt;
&lt;p&gt;看看效果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/298986/201803/298986-20180317224207619-1636928718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 先看一下Xaml代码实现&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ScrollViewer &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; VerticalScrollBarVisibility&lt;/span&gt;&lt;span&gt;=&quot;Hidden&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;spBalanceAndChart&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;0,17,0,0&quot;&lt;/span&gt;&lt;span&gt; CornerRadius&lt;/span&gt;&lt;span&gt;=&quot;7&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;x:Uid&lt;/span&gt;&lt;span&gt;=&quot;tbChartHeader&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;tbChartHeader&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;ChartHeader&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt; FontWeight&lt;/span&gt;&lt;span&gt;=&quot;ExtraBold&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Stretch&quot;&lt;/span&gt;&lt;span&gt; TextAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; TextWrapping&lt;/span&gt;&lt;span&gt;=&quot;Wrap&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;chart:RadPieChart &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;chart&quot;&lt;/span&gt;&lt;span&gt; ClipToBounds&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt; PaletteName&lt;/span&gt;&lt;span&gt;=&quot;DefaultDark&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;38,38,38,0&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;270&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;270&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;chart:DoughnutSeries &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;MyDoughnutSeries&quot;&lt;/span&gt;&lt;span&gt; ShowLabels&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;chart:DoughnutSeries.ValueBinding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;chart:PropertyNameDataPointBinding &lt;/span&gt;&lt;span&gt;PropertyName&lt;/span&gt;&lt;span&gt;=&quot;Value&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;chart:DoughnutSeries.ValueBinding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;chart:DoughnutSeries.LegendTitleBinding &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;chart:PropertyNameDataPointBinding &lt;/span&gt;&lt;span&gt;PropertyName&lt;/span&gt;&lt;span&gt;=&quot;Title&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;chart:DoughnutSeries.LegendTitleBinding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;chart:DoughnutSeries&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;chart:RadPieChart&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;primitives:RadLegendControl &lt;/span&gt;&lt;span&gt;LegendProvider&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=chart}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;primitives:RadLegendControl.ItemsPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;primitives:RadLegendControl.ItemsPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;primitives:RadLegendControl.ItemTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Ellipse &lt;/span&gt;&lt;span&gt;Fill&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Fill}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Stroke&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Stroke}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                                    StrokeThickness&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Title}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Foreground&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Fill}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                                    Margin&lt;/span&gt;&lt;span&gt;=&quot;10,0,0,0&quot;&lt;/span&gt;&lt;span&gt; FontStyle&lt;/span&gt;&lt;span&gt;=&quot;Italic&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;primitives:RadLegendControl.ItemTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;primitives:RadLegendControl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ScrollViewer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解释一下，之所以在最外层用ScrollViewer包一下，是因为怕有些设备宽高不够用、或者用户将窗口调节的非常小，导致不能查看的情况。最好把滚动条隐藏了，这样好看。&lt;/p&gt;
&lt;p&gt;开头引用xmlns:chart=&quot;using:Telerik.UI.Xaml.Controls.Chart&quot;&lt;/p&gt;

&lt;p&gt;后台，我的操作逻辑是，通过上一篇的签到数据，选择一行数据，然后生成累计的签到图。&lt;/p&gt;
&lt;p&gt;所以先写一个LoadData的函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LoadChartData(SignInSummaryData sid)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; chartItems = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ChartDataPoint&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Application.Current &lt;span&gt;as&lt;/span&gt; App).strCurrentLanguage.ToLower().Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a new chart data point for each value you want in the PieSeries&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; sliceOne = &lt;span&gt;new&lt;/span&gt; ChartDataPoint { Value = sid.SignInAttendanceRate, Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;到席&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sliceTwo = &lt;span&gt;new&lt;/span&gt; ChartDataPoint { Value = &lt;span&gt;1&lt;/span&gt; - sid.SignInAttendanceRate, Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;缺席&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add those items to the list&lt;/span&gt;
&lt;span&gt;                chartItems.Add(sliceOne);
                chartItems.Add(sliceTwo);

                tbChartHeader.Text &lt;/span&gt;= sid.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sid.PersonId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sid.SignInItemName + sid.SignInItemTimes + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;签到情况&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a new chart data point for each value you want in the PieSeries&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; sliceOne = &lt;span&gt;new&lt;/span&gt; ChartDataPoint { Value = sid.SignInAttendanceRate, Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Attendance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sliceTwo = &lt;span&gt;new&lt;/span&gt; ChartDataPoint { Value = &lt;span&gt;1&lt;/span&gt; - sid.SignInAttendanceRate, Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Absence&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add those items to the list&lt;/span&gt;
&lt;span&gt;                chartItems.Add(sliceOne);
                chartItems.Add(sliceTwo);

                tbChartHeader.Text &lt;/span&gt;= sid.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sid.PersonId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sid.SignInItemName + sid.SignInItemTimes + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Attendance Chart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }

            MyDoughnutSeries.ItemsSource &lt;/span&gt;=&lt;span&gt; chartItems;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在 OnNavigatedTo 中调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNavigatedTo(NavigationEventArgs e)
        {
            SignInSummaryData sid &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Parameter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                sid &lt;/span&gt;= e.Parameter &lt;span&gt;as&lt;/span&gt;&lt;span&gt; SignInSummaryData;
                LoadChartData(sid);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以和上一篇文章联系气来，连贯的操作gif如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/298986/201803/298986-20180317225337873-757852142.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 14:54:00 +0000</pubDate>
<dc:creator>星期八再娶你</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hupo376787/p/8593346.html</dc:identifier>
</item>
<item>
<title>用Go自己实现配置文件热加载功能 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8593204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8593204.html</guid>
<description>&lt;p&gt;说到配置文件热加载，这个功能在很多框架中都提供了，如beego，实现的效果就是当你修改文件后，会把你修改后的配置重新加载到配置文件中，而不用重启程序，这个功能在日常中还是非常实用的，毕竟很多时候，线上的配置文件不是想改就能改的。&lt;/p&gt;
&lt;p&gt;这次就自己实现一个配置文件的热加载功能的包，并通过一个简单的例子对完成的包进行使用验证&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;配置文件热加载包的是实现&lt;/h2&gt;
&lt;p&gt;其实整体的思路还是比较简单的，当获取配置文件内容后，会开启一个goroutine，去 循环读配置文件，当然这里不可能不限制的一直循环，而是设置了一个定时器，定时去读文件，根据文件的修改时间是否变化，从而确定是否重新reload配置文件&lt;/p&gt;
&lt;p&gt;实现的config 包的文件结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── config.go
└── config_notify.go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;config.go：代码的主要处理逻辑&lt;br/&gt;config_notify.go：主要定义了一个接口，用于当文件修改时间变化的时候执行回调&lt;/p&gt;
&lt;p&gt;config_notify.go的代码相对来说比较简单，我们先看看这个代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package config

&lt;/span&gt;//&lt;span&gt; 定义一个通知的接口
type Notifyer interface {
    Callback(&lt;/span&gt;*&lt;span&gt;Config)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样当我们实现了Callback这个方法的时候，我们就实现了Notifyer这个接口，具体的调用在后面会说&lt;/p&gt;
&lt;p&gt;在config.go中我们顶一个了一个结构体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;type Config struct {
    filename string
    lastModifyTime int64
    data map[string]string
    rwLock sync.RWMutex
    notifyList []Notifyer
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结构体中主要包含几个字段：&lt;br/&gt;filename:配置文件名字&lt;br/&gt;lastModifyTime:配置文件的最后修改时间&lt;br/&gt;data:用于将从配置文件中读取的内容存储为map&lt;br/&gt;rwlock:读写锁&lt;br/&gt;notifyList:用于将调用该包的程序追加到切片中，用于通知调用上面在config_notify.go定义的callback回调函数&lt;/p&gt;
&lt;p&gt;关于读取配置文件中的内容并存储到map中，这里定义了一个方法实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
func (c *&lt;span&gt;Config) parse()(m map[string]string,err error){
    &lt;/span&gt;// 读文件并或将文件中的数据以k/&lt;span&gt;v的形式存储到map中
    m &lt;/span&gt;= make(map[string]string,1024&lt;span&gt;)
    file,err :&lt;/span&gt;=&lt;span&gt; os.Open(c.filename)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        return
    }
    var lineNo &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
    reader :&lt;/span&gt;=&lt;span&gt; bufio.NewReader(file)
    for{
        &lt;/span&gt;//&lt;span&gt; 一行行的读文件
        line,errRet :&lt;/span&gt;= reader.ReadString('\n'&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; errRet ==&lt;span&gt; io.EOF{
            &lt;/span&gt;//&lt;span&gt; 表示读到文件的末尾
            break
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; errRet !=&lt;span&gt; nil{
            &lt;/span&gt;//&lt;span&gt; 表示读文件出问题
            err &lt;/span&gt;=&lt;span&gt; errRet
            return
        }
        lineNo&lt;/span&gt;++&lt;span&gt;
        line &lt;/span&gt;= strings.TrimSpace(line) //&lt;span&gt; 取出空格
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(line) == 0 || line[0] == '\n' || line[0] == '+' || line[0] == ';'&lt;span&gt;{
            &lt;/span&gt;//&lt;span&gt; 当前行为空行或者是注释行等
            continue
        }
        arr :&lt;/span&gt;= strings.Split(line,&quot;=&quot;) // 通过=进行切割取出k/&lt;span&gt;v结构
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(arr) == 0&lt;span&gt;{
            fmt.Printf(&lt;/span&gt;&quot;invalid config,line:%d\n&quot;&lt;span&gt;,lineNo)
            continue
        }
        key :&lt;/span&gt;= strings.TrimSpace(arr[0&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(key) == 0&lt;span&gt;{
            fmt.Printf(&lt;/span&gt;&quot;invalid config,line:%d\n&quot;&lt;span&gt;,lineNo)
            continue
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(arr) == 1&lt;span&gt;{
            m[key] &lt;/span&gt;= &quot;&quot;&lt;span&gt;
            continue
        }
        value :&lt;/span&gt;= strings.TrimSpace(arr[1&lt;span&gt;])
        m[key] &lt;/span&gt;=&lt;span&gt; value
    }
    return
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而最后我们就需要一个定时器，每隔一段时间判断配置文件的最后修改时间是否变化，如果变化则重新读取一次文件并将文件内容存储到map中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
func (c *&lt;span&gt;Config) reload(){
    &lt;/span&gt;//&lt;span&gt; 这里启动一个定时器，每5秒重新加载一次配置文件
    ticker :&lt;/span&gt;= time.NewTicker(time.Second*5&lt;span&gt;)
    for _ &lt;/span&gt;=&lt;span&gt; range ticker.C{
        func(){
            file,err :&lt;/span&gt;=&lt;span&gt; os.Open(c.filename)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
                fmt.Printf(&lt;/span&gt;&quot;open %s failed,err:%v\n&quot;&lt;span&gt;,c.filename,err)
                return
            }
            defer file.Close()
            fileInfo,err :&lt;/span&gt;=&lt;span&gt; file.Stat()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
                fmt.Printf(&lt;/span&gt;&quot;stat %s failed,err:%v\n&quot;&lt;span&gt;,c.filename,err)
                return
            }
            curModifyTime :&lt;/span&gt;=&lt;span&gt; fileInfo.ModTime().Unix()
            fmt.Printf(&lt;/span&gt;&quot;%v --- %v\n&quot;&lt;span&gt;,curModifyTime,c.lastModifyTime)
            &lt;/span&gt;//&lt;span&gt;判断文件的修改时间是否大于最后一次修改时间
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; curModifyTime &amp;gt;&lt;span&gt; c.lastModifyTime{
                m,err :&lt;/span&gt;=&lt;span&gt; c.parse()
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
                    fmt.Println(&lt;/span&gt;&quot;parse failed,err:&quot;&lt;span&gt;,err)
                    return
                }
                c.rwLock.Lock()
                c.data &lt;/span&gt;=&lt;span&gt; m
                c.rwLock.Unlock()
                for _, n:&lt;/span&gt;=&lt;span&gt;range c.notifyList{
                    n.Callback(c)
                }
                c.lastModifyTime &lt;/span&gt;=&lt;span&gt; curModifyTime
            }
        }()
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于config完整的代码地址：&lt;a href=&quot;https://github.com/pythonsite/go_simple_code/tree/master/config&quot;&gt;https://github.com/pythonsite/go_simple_code/tree/master/config&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;一个演示上述包的例子&lt;/h2&gt;
&lt;p&gt;这里一个简单的例子，代码的逻辑也非常简单就是写一个循环从配置文件读取配置信息，当然这里是为了测试效果，写成了循环。这里有个问题需要注意，就是在配置文件中存放数据的时候应该是如下格式存储&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
listen_addr =&lt;span&gt; localhost
server_port &lt;/span&gt;= 1000&lt;span&gt;

# Nginx addr
nginx_addr &lt;/span&gt;= 192.168.1.2:9090
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码的主要结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── config.conf
└── main.go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;config.conf为配置文件&lt;br/&gt;main.go 为主要测试代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;type AppConfig struct {
    port &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
    nginxAddr string
}

type AppconfigMgr struct {
    config atomic.Value
}

var appConfigMgr &lt;/span&gt;= &amp;amp;&lt;span&gt;AppconfigMgr{}


func(a &lt;/span&gt;*AppconfigMgr)Callback(conf *&lt;span&gt;config.Config){

    var appConfig &lt;/span&gt;= &amp;amp;&lt;span&gt;AppConfig{}

    port,err :&lt;/span&gt;= conf.GetInt(&quot;server_port&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;get port failed,err:&quot;&lt;span&gt;,err)
        return
    }
    appConfig.port &lt;/span&gt;=&lt;span&gt; port
    fmt.Println(&lt;/span&gt;&quot;port:&quot;&lt;span&gt;,appConfig.port)
    nginxAddr,err :&lt;/span&gt;= conf.GetString(&quot;nginx_addr&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;get nginx addr failed,err:&quot;&lt;span&gt;,err)
        return
    }
    appConfig.nginxAddr &lt;/span&gt;=&lt;span&gt; nginxAddr
    fmt.Println(&lt;/span&gt;&quot;nginx addr :&quot;&lt;span&gt;,appConfig.nginxAddr)

    appConfigMgr.config.Store(appConfig)

}

func run(){
    for {
        &lt;/span&gt;//&lt;span&gt; 每5秒打印一次数据，查看自己更改配置文件后是否可以热刷新
        appConfig :&lt;/span&gt;= appConfigMgr.config.Load().(*&lt;span&gt;AppConfig)
        fmt.Println(&lt;/span&gt;&quot;port:&quot;&lt;span&gt;,appConfig.port)
        fmt.Println(&lt;/span&gt;&quot;nginx addr:&quot;&lt;span&gt;,appConfig.nginxAddr)
        time.Sleep(&lt;/span&gt;5*&lt;span&gt; time.Second)
    }
}

func main() {
    conf,err :&lt;/span&gt;= config.NewConfig(&quot;/Users/zhaofan/go_project/src/go_dev/13/config_test/config.conf&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;parse config failed,err:&quot;&lt;span&gt;,err)
        return
    }
    &lt;/span&gt;//&lt;span&gt;打开文件获取内容后，将自己加入到被通知的切片中
    conf.AddNotifyer(appConfigMgr)

    var appConfig &lt;/span&gt;= &amp;amp;&lt;span&gt;AppConfig{}

    appConfig.port,err &lt;/span&gt;= conf.GetInt(&quot;server_port&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;get port failed,err:&quot;&lt;span&gt;,err)
        return
    }
    fmt.Println(&lt;/span&gt;&quot;port:&quot;&lt;span&gt;,appConfig.port)

    appConfig.nginxAddr,err &lt;/span&gt;= conf.GetString(&quot;nginx_addr&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;get nginx addr failed,err:&quot;&lt;span&gt;,err)
        return
    }
    fmt.Println(&lt;/span&gt;&quot;nginx addr:&quot;&lt;span&gt;,appConfig.nginxAddr)
    appConfigMgr.config.Store(appConfig)
    run()

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中有一段代码非常重要：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
func(a *AppconfigMgr)Callback(conf *&lt;span&gt;config.Config){

    var appConfig &lt;/span&gt;= &amp;amp;&lt;span&gt;AppConfig{}

    port,err :&lt;/span&gt;= conf.GetInt(&quot;server_port&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;get port failed,err:&quot;&lt;span&gt;,err)
        return
    }
    appConfig.port &lt;/span&gt;=&lt;span&gt; port
    fmt.Println(&lt;/span&gt;&quot;port:&quot;&lt;span&gt;,appConfig.port)
    nginxAddr,err :&lt;/span&gt;= conf.GetString(&quot;nginx_addr&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;get nginx addr failed,err:&quot;&lt;span&gt;,err)
        return
    }
    appConfig.nginxAddr &lt;/span&gt;=&lt;span&gt; nginxAddr
    fmt.Println(&lt;/span&gt;&quot;nginx addr :&quot;&lt;span&gt;,appConfig.nginxAddr)

    appConfigMgr.config.Store(appConfig)

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们实现了Callback方法，同时就实现了我们在config包中定义的那个接口&lt;/p&gt;
&lt;p&gt;测试效果如下，当我们更改配置文件后，程序中的配置文件也被重新加载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180317223531971-1737902271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的测试代码地址：&lt;a href=&quot;https://github.com/pythonsite/go_simple_code/tree/master/config_test&quot;&gt;https://github.com/pythonsite/go_simple_code/tree/master/config_test&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 14:36:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8593204.html</dc:identifier>
</item>
<item>
<title>从头编写asp.net core 2.0 web api 基础框架 (5) + 使用Identity Server 4建立Authorization Server (7) 可运行前后台源码 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8592792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8592792.html</guid>
<description>&lt;p&gt;前台使用angular 5, 后台是asp.net core 2.0 web api + identity server 4.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从头编写asp.net core 2.0 web api 基础框架:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Identity Server 4建立Authorization Server&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;源码的使用:&lt;/p&gt;
&lt;p&gt;后台源码: &lt;a href=&quot;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后台解决方案同时启动这两个项目:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317210920679-1205449843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行即可, 需要的环境变量我写到了launchSettings.json文件.&lt;/p&gt;
&lt;p&gt;默认使用的是localdb.&lt;/p&gt;
&lt;p&gt;启动后如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211046852-499672052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211054934-1540556379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211102630-1645876456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211109065-1564293008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211114171-1590335432.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211339158-981758915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前台源码: &lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1oClvI7IGNO1u1Ryozi0T9Q&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1oClvI7IGNO1u1Ryozi0T9Q&lt;/a&gt; 密码: ywdb&lt;/p&gt;
&lt;p&gt;然后执行npm install, 你可能需要全局安装angular cli.&lt;/p&gt;
&lt;p&gt;安装后执行 npm start 即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211214067-731359119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211222752-1463843527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211228026-126377378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211234020-1447547957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180317211241112-1428300095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 13:15:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8592792.html</dc:identifier>
</item>
<item>
<title>SpringMVC【校验器、统一处理异常、RESTful、拦截器】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8592769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8592769.html</guid>
<description>&lt;p&gt;本博文主要讲解的知识点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;校验器&lt;/li&gt;
&lt;li&gt;统一处理异常&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;拦截器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我们的Struts2中，我们是继承ActionSupport来实现校验的...它有两种方式来实现校验的功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;手写代码&lt;/li&gt;
&lt;li&gt;XML配置
&lt;ul&gt;&lt;li&gt;这两种方式也是可以特定处理方法或者整个Action的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而SpringMVC使用JSR-303（javaEE6规范的一部分）校验规范，&lt;strong&gt;springmvc使用的是Hibernate Validator（和Hibernate的ORM无关）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速入门&quot;&gt;快速入门&lt;/h2&gt;
&lt;p&gt;导入jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811105256919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置校验器&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;

    
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 校验器 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;validator&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 校验器 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;providerClass&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.hibernate.validator.HibernateValidator&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 指定校验使用的资源文件，如果不指定则默认使用classpath下的ValidationMessages.properties --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;validationMessageSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;messageSource&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;错误信息的校验文件配置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 校验错误信息配置文件 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;messageSource&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 资源文件名 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;basenames&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;list&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;classpath:CustomValidationMessages&lt;span class=&quot;kw&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/list&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 资源文件编码格式 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;fileEncodings&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;utf-8&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 对资源文件内容缓存时间，单位秒 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheSeconds&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;120&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加到自定义参数绑定的WebBindingInitializer中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 自定义webBinder --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;customBinder&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 配置validator --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;validator&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;validator&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终添加到适配器中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 注解适配器 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 在webBindingInitializer中注入自定义属性编辑器、自定义转换器 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;webBindingInitializer&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;customBinder&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;创建CustomValidationMessages配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811105836262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义规则&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package entity;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.validation.constraints.NotNull;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.validation.constraints.Size;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Items {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Integer id;

    &lt;span class=&quot;co&quot;&gt;//商品名称的长度请限制在1到30个字符&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Size&lt;/span&gt;(min=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,max=&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;,message=&lt;span class=&quot;st&quot;&gt;&quot;{items.name.length.error}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String name;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Float price;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String pic;

    &lt;span class=&quot;co&quot;&gt;//请输入商品生产日期&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@NotNull&lt;/span&gt;(message=&lt;span class=&quot;st&quot;&gt;&quot;{items.createtime.is.notnull}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Date createtime;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String detail;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; id;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(Integer id) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt; = id;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; name;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(String name) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt; = name == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : name.&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Float &lt;span class=&quot;fu&quot;&gt;getPrice&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; price;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPrice&lt;/span&gt;(Float price) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;price&lt;/span&gt; = price;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getPic&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; pic;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPic&lt;/span&gt;(String pic) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;pic&lt;/span&gt; = pic == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : pic.&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Date &lt;span class=&quot;fu&quot;&gt;getCreatetime&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; createtime;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setCreatetime&lt;/span&gt;(Date createtime) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createtime&lt;/span&gt; = createtime;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getDetail&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; detail;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDetail&lt;/span&gt;(String detail) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;detail&lt;/span&gt; = detail == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : detail.&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;


&lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;%--
  Created by IntelliJ IDEA.
  User: ozc
  Date: 2017/8/11
  Time: 9:56
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;测试文件上传&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;&amp;lt;form&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; action=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${pageContext.request.contextPath}/validation.action&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    名称：&lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    日期：&lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;createtime&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;mailto:Controller需要在校验的参数上添加@validation注解&quot;&gt;Controller需要在校验的参数上添加@Validation注解&lt;/a&gt;...拿到BindingResult对象...&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/validation&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;validation&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@Validated&lt;/span&gt; Items items, BindingResult bindingResult) {

        List&amp;lt;ObjectError&amp;gt; allErrors = bindingResult.&lt;span class=&quot;fu&quot;&gt;getAllErrors&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ObjectError allError : allErrors) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(allError.&lt;span class=&quot;fu&quot;&gt;getDefaultMessage&lt;/span&gt;());
        }

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我在测试的时候，已经把日期转换器关掉了，因此提示了字符串不能转换成日期，但是名称的校验已经是出来了...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811203108659?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;分组校验&quot;&gt;分组校验&lt;/h2&gt;
&lt;p&gt;分组校验其实就是为了我们的校验更加灵活，有的时候，我们&lt;strong&gt;并不需要把我们当前配置的属性都进行校验，而需要的是当前的方法仅仅校验某些的属性&lt;/strong&gt;。那么此时，我们就可以用到分组校验了...&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义分组的接口【主要是标识】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定于校验规则属于哪一各组&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在Controller方法中定义使用校验分组&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811203513514?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811203520645?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811203532542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;在我们之前SSH，使用Struts2的时候也配置过统一处理异常...&lt;/p&gt;
&lt;p&gt;当时候是这么干的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在service层中自定义异常&lt;/li&gt;
&lt;li&gt;在action层也自定义异常&lt;/li&gt;
&lt;li&gt;对于Dao层的异常我们先不管【因为我们管不着，dao层的异常太致命了】&lt;/li&gt;
&lt;li&gt;service层抛出异常，Action把service层的异常接住，通过service抛出的异常来判断是否让请求通过&lt;/li&gt;
&lt;li&gt;如果不通过，那么接着抛出Action异常&lt;/li&gt;
&lt;li&gt;在Struts的配置文件中定义全局视图，页面显示错误信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;详情可看：&lt;a href=&quot;http://blog.csdn.net/hon_3y/article/details/72772559&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/hon_3y/article/details/72772559&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么我们这次的统一处理异常的方案是什么呢？？？？&lt;/p&gt;
&lt;p&gt;我们知道Java中的异常可以分为两类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译时期异常&lt;/li&gt;
&lt;li&gt;运行期异常&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;对于运行期异常我们是无法掌控的，只能通过代码质量、在系统测试时详细测试等排除运行时异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而对于编译时期的异常，我们可以在代码手动处理异常可以try/catch捕获，可以向上抛出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以换个思路，自定义一个模块化的异常信息，比如：&lt;strong&gt;商品类别的异常&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomException &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Exception {
    
    &lt;span class=&quot;co&quot;&gt;//异常信息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String message;
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomException&lt;/span&gt;(String message){
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(message);
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;message&lt;/span&gt; = message;
        
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; message;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setMessage&lt;/span&gt;(String message) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;message&lt;/span&gt; = message;
    }
    
    

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在查看Spring源码的时候发现：前端控制器DispatcherServlet在进行HandlerMapping、调用HandlerAdapter执行Handler过程中，如果遇到异常，&lt;strong&gt;在系统中自定义统一的异常处理器，写系统自己的异常处理代码。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811205328153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811205341421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以学着点，定义一个统一的处理器类来处理异常...&lt;/p&gt;
&lt;h2 id=&quot;定义统一异常处理器类&quot;&gt;定义统一异常处理器类&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomExceptionResolver &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; HandlerExceptionResolver  {

    &lt;span class=&quot;co&quot;&gt;//前端控制器DispatcherServlet在进行HandlerMapping、调用HandlerAdapter执行Handler过程中，如果遇到异常就会执行此方法&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//handler最终要执行的Handler，它的真实身份是HandlerMethod&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//Exception ex就是接收到异常信息&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ModelAndView &lt;span class=&quot;fu&quot;&gt;resolveException&lt;/span&gt;(HttpServletRequest request,
            HttpServletResponse response, Object handler, Exception ex) {
        &lt;span class=&quot;co&quot;&gt;//输出异常&lt;/span&gt;
        ex.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        
        &lt;span class=&quot;co&quot;&gt;//统一异常处理代码&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//针对系统自定义的CustomException异常，就可以直接从异常类中获取异常信息，将异常处理在错误页面展示&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//异常信息&lt;/span&gt;
        String message = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        CustomException customException = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;//如果ex是系统 自定义的异常，直接取出异常信息&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(ex &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; CustomException){
            customException = (CustomException)ex;
        }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
            &lt;span class=&quot;co&quot;&gt;//针对非CustomException异常，对这类重新构造成一个CustomException，异常信息为“未知错误”&lt;/span&gt;
            customException = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;未知错误&quot;&lt;/span&gt;);
        }

        &lt;span class=&quot;co&quot;&gt;//错误 信息&lt;/span&gt;
        message = customException.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;();
        
        request.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;message&quot;&lt;/span&gt;, message);

        
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;//转向到错误 页面&lt;/span&gt;
            request.&lt;span class=&quot;fu&quot;&gt;getRequestDispatcher&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/WEB-INF/jsp/error.jsp&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(request, response);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ServletException e) {
            &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ModelAndView&lt;/span&gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;配置统一异常处理器&quot;&gt;配置统一异常处理器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 定义统一异常处理器 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cn.itcast.ssm.exception.CustomExceptionResolver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170811205621002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们在学习webservice的时候可能就听过RESTful这么一个名词，当时候与SOAP进行对比的...那么RESTful究竟是什么东东呢？？？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RESTful(Representational State Transfer)软件开发理念，RESTful对http进行非常好的诠释&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果一个架构支持RESTful，那么就称它为RESTful架构...&lt;/p&gt;
&lt;p&gt;以下的文章供我们了解：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/09/restful&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2011/09/restful&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;综合上面的解释，我们总结一下什么是RESTful架构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　（1）&lt;strong&gt;每一个URI代表一种资源；&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;　　（2）&lt;strong&gt;客户端和服务器之间，传递这种资源的某种表现层；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;　　（3）&lt;strong&gt;客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于RESTful幂等性的理解:&lt;a href=&quot;http://www.oschina.net/translate/put-or-post&quot; class=&quot;uri&quot;&gt;http://www.oschina.net/translate/put-or-post&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说，如果对象在请求的过程中会发生变化(以Java为例子，属性被修改了)，那么此是非幂等的。多次重复请求，结果还是不变的话，那么就是幂等的。&lt;/p&gt;
&lt;p&gt;PUT用于幂等请求，因此在更新的时候把所有的属性都写完整，那么多次请求后，我们其他属性是不会变的&lt;/p&gt;
&lt;p&gt;在上边的文章中，幂等被翻译成“状态统一性”。这就更好地理解了。&lt;/p&gt;
&lt;p&gt;其实一般的架构并不能完全支持RESTful的，因此，&lt;strong&gt;只要我们的系统支持RESTful的某些功能，我们一般就称作为支持RESTful架构&lt;/strong&gt;...&lt;/p&gt;
&lt;h2 id=&quot;url的restful实现&quot;&gt;url的RESTful实现&lt;/h2&gt;
&lt;p&gt;非RESTful的http的url：&lt;a href=&quot;http://localhost:8080/items/editItems.action?id=1&quot; class=&quot;uri&quot;&gt;http://localhost:8080/items/editItems.action?id=1&lt;/a&gt;&amp;amp;....&lt;/p&gt;
&lt;p&gt;RESTful的url是简洁的：&lt;a class=&quot;uri&quot;&gt;http://&lt;/a&gt; localhost:8080/items/editItems/1&lt;/p&gt;
&lt;h3 id=&quot;更改dispatcherservlet的配置&quot;&gt;&lt;strong&gt;更改DispatcherServlet的配置&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;从上面我们可以发现，url并没有.action后缀的，因此我们要修改核心分配器的配置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- restful的配置 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;springmvc_rest&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 加载springmvc配置 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;kw&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 配置文件的地址 如果不配置contextConfigLocation， 默认查找的配置文件名称classpath下的：servlet名称+&quot;-serlvet.xml&quot;即：springmvc-serlvet.xml --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:spring/springmvc.xml&lt;span class=&quot;kw&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;springmvc_rest&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- rest方式配置为/ --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;kw&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在Controller上使用PathVariable注解来绑定对应的参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;//根据商品id查看商品信息rest接口&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//@RequestMapping中指定restful方式的url中的参数，参数需要用{}包起来&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//@PathVariable将url中的{}包起参数和形参进行绑定&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/viewItems/{id}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@ResponseBody&lt;/span&gt; ItemsCustom &lt;span class=&quot;fu&quot;&gt;viewItems&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@PathVariable&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;) Integer id) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        &lt;span class=&quot;co&quot;&gt;//调用 service查询商品信息&lt;/span&gt;
        ItemsCustom itemsCustom = itemsService.&lt;span class=&quot;fu&quot;&gt;findItemsById&lt;/span&gt;(id);
        
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; itemsCustom;
        
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;当DispatcherServlet拦截/开头的所有请求，对静态资源的访问就报错：我们需要配置对静态资源的解析&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 静态资源 解析 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:resources&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/js/&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; mapping=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/js/**&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:resources&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/img/&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; mapping=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/img/**&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;/**&lt;/code&gt;就表示不管有多少层，都对其进行解析，&lt;code&gt;/*&lt;/code&gt;代表的是当前层的所有资源..&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;在Struts2中拦截器就是我们当时的核心，原来在SpringＭＶＣ中也是有拦截器的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户请求到DispatherServlet中，DispatherServlet调用HandlerMapping查找Handler，HandlerMapping返回一个拦截的链儿（多个拦截），springmvc中的拦截器是通过HandlerMapping发起的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现拦截器的接口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HandlerInterceptor1 &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; HandlerInterceptor {

    &lt;span class=&quot;co&quot;&gt;//在执行handler之前来执行的&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//用于用户认证校验、用户权限校验&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;preHandle&lt;/span&gt;(HttpServletRequest request,
            HttpServletResponse response, Object handler) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;HandlerInterceptor1...preHandle&quot;&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;//如果返回false表示拦截不继续执行handler，如果返回true表示放行&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }
    &lt;span class=&quot;co&quot;&gt;//在执行handler返回modelAndView之前来执行&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//如果需要向页面提供一些公用 的数据或配置一些视图信息，使用此方法实现 从modelAndView入手&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;postHandle&lt;/span&gt;(HttpServletRequest request,
            HttpServletResponse response, Object handler,
            ModelAndView modelAndView) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;HandlerInterceptor1...postHandle&quot;&lt;/span&gt;);
        
    }
    &lt;span class=&quot;co&quot;&gt;//执行handler之后执行此方法&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//作系统 统一异常处理，进行方法执行性能监控，在preHandle中设置一个时间点，在afterCompletion设置一个时间，两个时间点的差就是执行时长&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//实现 系统 统一日志记录&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;afterCompletion&lt;/span&gt;(HttpServletRequest request,
            HttpServletResponse response, Object handler, Exception ex)
            &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;HandlerInterceptor1...afterCompletion&quot;&lt;/span&gt;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置拦截器&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--拦截器 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:interceptors&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!--多个拦截器,顺序执行 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- &amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            &amp;lt;mvc:mapping path=&quot;/**&quot; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            &amp;lt;bean class=&quot;cn.itcast.ssm.controller.interceptor.HandlerInterceptor1&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        &amp;lt;/mvc:interceptor&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        &amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            &amp;lt;mvc:mapping path=&quot;/**&quot; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            &amp;lt;bean class=&quot;cn.itcast.ssm.controller.interceptor.HandlerInterceptor2&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        &amp;lt;/mvc:interceptor&amp;gt; --&amp;gt;&lt;/span&gt;
        
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- /**可以拦截路径不管多少层 --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; path=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/**&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cn.itcast.ssm.controller.interceptor.LoginInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/mvc:interceptor&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/mvc:interceptors&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试执行顺序&quot;&gt;测试执行顺序&lt;/h2&gt;
&lt;p&gt;如果两个拦截器都放行&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
测试结果：
HandlerInterceptor1...&lt;span class=&quot;fu&quot;&gt;preHandle&lt;/span&gt;
HandlerInterceptor2...&lt;span class=&quot;fu&quot;&gt;preHandle&lt;/span&gt;

HandlerInterceptor2...&lt;span class=&quot;fu&quot;&gt;postHandle&lt;/span&gt;
HandlerInterceptor1...&lt;span class=&quot;fu&quot;&gt;postHandle&lt;/span&gt;

HandlerInterceptor2...&lt;span class=&quot;fu&quot;&gt;afterCompletion&lt;/span&gt;
HandlerInterceptor1...&lt;span class=&quot;fu&quot;&gt;afterCompletion&lt;/span&gt;

总结：
执行preHandle是顺序执行。
执行postHandle、afterCompletion是倒序执行&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1 号放行和2号不放行&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
测试结果：
HandlerInterceptor1...&lt;span class=&quot;fu&quot;&gt;preHandle&lt;/span&gt;
HandlerInterceptor2...&lt;span class=&quot;fu&quot;&gt;preHandle&lt;/span&gt;
HandlerInterceptor1...&lt;span class=&quot;fu&quot;&gt;afterCompletion&lt;/span&gt;

总结：
如果preHandle不放行，postHandle、afterCompletion都不执行。
只要有一个拦截器不放行，controller不能执行完成&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1 号不放行和2号不放行&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
测试结果：
HandlerInterceptor1...&lt;span class=&quot;fu&quot;&gt;preHandle&lt;/span&gt;
总结：
只有前边的拦截器preHandle方法放行，下边的拦截器的preHandle才执行。&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;日志拦截器或异常拦截器要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将日志拦截器或异常拦截器放在拦截器链儿中第一个位置，且preHandle方法放行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;拦截器应用-身份认证&quot;&gt;拦截器应用-身份认证&lt;/h2&gt;
&lt;p&gt;拦截器拦截&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; LoginInterceptor &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; HandlerInterceptor {

    &lt;span class=&quot;co&quot;&gt;//在执行handler之前来执行的&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//用于用户认证校验、用户权限校验&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;preHandle&lt;/span&gt;(HttpServletRequest request,
            HttpServletResponse response, Object handler) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        
        &lt;span class=&quot;co&quot;&gt;//得到请求的url&lt;/span&gt;
        String url = request.&lt;span class=&quot;fu&quot;&gt;getRequestURI&lt;/span&gt;();
        
        &lt;span class=&quot;co&quot;&gt;//判断是否是公开 地址&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//实际开发中需要公开 地址配置在配置文件中&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//...&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(url.&lt;span class=&quot;fu&quot;&gt;indexOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;login.action&quot;&lt;/span&gt;)&amp;gt;=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;){
            &lt;span class=&quot;co&quot;&gt;//如果是公开 地址则放行&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
        
        &lt;span class=&quot;co&quot;&gt;//判断用户身份在session中是否存在&lt;/span&gt;
        HttpSession session = request.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;();
        String usercode = (String) session.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;usercode&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//如果用户身份在session中存在放行&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(usercode!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
        &lt;span class=&quot;co&quot;&gt;//执行到这里拦截，跳转到登陆页面，用户进行身份认证&lt;/span&gt;
        request.&lt;span class=&quot;fu&quot;&gt;getRequestDispatcher&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/WEB-INF/jsp/login.jsp&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(request, response);
        
        &lt;span class=&quot;co&quot;&gt;//如果返回false表示拦截不继续执行handler，如果返回true表示放行&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }
    &lt;span class=&quot;co&quot;&gt;//在执行handler返回modelAndView之前来执行&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//如果需要向页面提供一些公用 的数据或配置一些视图信息，使用此方法实现 从modelAndView入手&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;postHandle&lt;/span&gt;(HttpServletRequest request,
            HttpServletResponse response, Object handler,
            ModelAndView modelAndView) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;HandlerInterceptor1...postHandle&quot;&lt;/span&gt;);
        
    }
    &lt;span class=&quot;co&quot;&gt;//执行handler之后执行此方法&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//作系统 统一异常处理，进行方法执行性能监控，在preHandle中设置一个时间点，在afterCompletion设置一个时间，两个时间点的差就是执行时长&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//实现 系统 统一日志记录&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;afterCompletion&lt;/span&gt;(HttpServletRequest request,
            HttpServletResponse response, Object handler, Exception ex)
            &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;HandlerInterceptor1...afterCompletion&quot;&lt;/span&gt;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; LoginController {
    
    
    &lt;span class=&quot;co&quot;&gt;//用户登陆提交方法&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/login&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;login&lt;/span&gt;(HttpSession session, String usercode,String password)&lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        
        &lt;span class=&quot;co&quot;&gt;//调用service校验用户账号和密码的正确性&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//..&lt;/span&gt;
        
        &lt;span class=&quot;co&quot;&gt;//如果service校验通过，将用户身份记录到session&lt;/span&gt;
        session.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;usercode&quot;&lt;/span&gt;, usercode);
        &lt;span class=&quot;co&quot;&gt;//重定向到商品查询页面&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:/items/queryItems.action&quot;&lt;/span&gt;;
    }
    
    &lt;span class=&quot;co&quot;&gt;//用户退出&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/logout&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;logout&lt;/span&gt;(HttpSession session)&lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        
        &lt;span class=&quot;co&quot;&gt;//session失效&lt;/span&gt;
        session.&lt;span class=&quot;fu&quot;&gt;invalidate&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//重定向到商品查询页面&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:/items/queryItems.action&quot;&lt;/span&gt;;
        
    }
    

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用Spring的校验方式就是将要校验的属性前边加上注解声明。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;mailto:**在Controller中的方法参数上加上@validation注解&quot;&gt;**在Controller中的方法参数上加上@Validation注解&lt;/a&gt;。那么SpringMVC内部就会帮我们对其进行处理(创建对应的bean，加载配置文件)**&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BindingResult可以拿到我们校验错误的提示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分组校验就是将让我们的校验更加灵活:某方法需要校验这个属性，而某方法不用校验该属性。我们就可以使用分组校验了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于处理异常，SpringMVC是用一个统一的异常处理器类的。实现了HandlerExceptionResolver接口。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对模块细分多个异常类，都交由我们的统一异常处理器类进行处理。&lt;/li&gt;
&lt;li&gt;对于RESTful规范，我们可以使用SpringMVC简单地支持的。&lt;strong&gt;将SpringMVC的拦截.action改成是任意的。同时，如果是静态的资源文件，我们应该设置不拦截。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于url上的参数，&lt;a&gt;**我们可以使用@PathVariable将url中的{}包起参数和形参进行绑定*&lt;/a&gt;*&lt;/li&gt;
&lt;li&gt;SpringMVC的拦截器和Struts2的拦截器差不多。不过SpringMVC的拦截器配置起来比Struts2的要简单。
&lt;ul&gt;&lt;li&gt;至于他们的&lt;strong&gt;拦截器链的调用顺序，和Filter的是没有差别的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 17 Mar 2018 13:08:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8592769.html</dc:identifier>
</item>
<item>
<title>javascript 原型及原型链详解 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8592718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8592718.html</guid>
<description>
&lt;p&gt;我们创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向一个原型对象，而这个原型对象中拥有的属性和方法可以被所以实例共享。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(){
}
Person.prototype.name &lt;/span&gt;= &quot;Nicholas&quot;&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 29&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.sayName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Nicholas&quot;&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person2.sayName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Nicholas&quot;&lt;/span&gt;
alert(person1.sayName == person2.sayName); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;一、理解原型对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫 [[Prototype]] 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然在脚本中没有标准的方式访问 [[Prototype]] ，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性__proto__ ；而在其他实现中，这个属性对脚本则是完全不可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过，要明确的真正重要的一点就是，&lt;span&gt;这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以前面使用 Person 构造函数和 Person.prototype 创建实例的代码为例，图 6-1 展示了各个对象之间的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180317210058665-719590719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此， Person.prototype 指向了原型对象，而 Person.prototype.constructor 又指回了 Person 。&lt;/p&gt;
&lt;p&gt;person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype ；换句话说，它们与构造函数没有直接的关系。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以调用 person1.sayName() 。这是通过查找对象属性的过程来实现的。（会先在实例上搜索，如果搜索不到就会继续搜索原型。）&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;span&gt;用isPrototypeOf()方法判断实例与原型对象之间的关系&lt;/span&gt;&lt;br/&gt;alert(Person.prototype.isPrototypeOf(person1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
alert(Person.prototype.isPrototypeOf(person2)); &lt;span&gt;//&lt;/span&gt;&lt;span readability=&quot;7&quot;&gt;true&lt;p&gt;&lt;span&gt;用Object.getPrototypeOf() 方法返回实例的原型对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;alert(Object.getPrototypeOf(person1) == Person.prototype);&lt;/span&gt; //true&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;alert(person1.hasOwnProperty(&quot;name&quot;));&lt;/span&gt; //false　　来着原型&lt;br/&gt;&lt;span&gt;person1.name = &quot;Greg&quot;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;alert(person1.name);&lt;/span&gt; //&quot;Greg&quot;——来自实例&lt;br/&gt;&lt;span&gt;alert(person1.hasOwnProperty(&quot;name&quot;));&lt;/span&gt; //true&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  &lt;strong&gt;二、更简单的原型语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(){
}
Person.prototype &lt;/span&gt;=&lt;span&gt; {
　　name : &lt;/span&gt;&quot;Nicholas&quot;&lt;span&gt;,
　　age : &lt;/span&gt;29&lt;span&gt;,
　　job: &lt;/span&gt;&quot;Software Engineer&quot;&lt;span&gt;,
　　sayName : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
　　　　alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
　　}
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在上面的代码中，我们将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。最终结果相同，&lt;span&gt;但有一个例外： constructor 属性不再指向 Person 了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; friend = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
alert(friend &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt; Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
alert(friend &lt;span&gt;instanceof&lt;/span&gt; Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;alert(friend.constructor == Person);&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
alert(friend.constructor == Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true ，但 constructor 属性则等于 Object 而不等于 Person 了。&lt;/p&gt;
&lt;p&gt;如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(){
}
Person.prototype &lt;/span&gt;=&lt;span&gt; {
    &lt;span&gt;constructor : Person,&lt;/span&gt;
    name : &lt;/span&gt;&quot;Nicholas&quot;&lt;span&gt;,
    age : &lt;/span&gt;29&lt;span&gt;,
    job: &lt;/span&gt;&quot;Software Engineer&quot;&lt;span&gt;,
    sayName : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
};    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;三、原生对象的原型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有原生引用类型（ Object 、 Array 、 String ，等等）都在其构造函数的原型上定义了方法。&lt;/p&gt;
&lt;p&gt;例如，在 Array.prototype 中可以找到 sort() 方法，而在 String.prototype 中可以找到substring() 方法。尽管可以这样做，但不推荐修改原生对象的原型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、原型对象的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原型模式的最大问题是由其共享的本性所导致的。 修改其中的一个，另一个也会受影响。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(){
}
Person.prototype &lt;/span&gt;=&lt;span&gt; {
constructor: Person,
name : &lt;/span&gt;&quot;Nicholas&quot;&lt;span&gt;,
age : &lt;/span&gt;29&lt;span&gt;,
job : &lt;/span&gt;&quot;Software Engineer&quot;&lt;span&gt;,
friends : [&lt;/span&gt;&quot;Shelby&quot;, &quot;Court&quot;&lt;span&gt;],
sayName : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;span&gt;person1.friends.push(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;Van&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
alert(person1.friends); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Shelby,Court,Van&quot;&lt;/span&gt;
alert(person2.friends); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Shelby,Court,Van&quot;&lt;/span&gt;
alert(person1.friends === person2.friends); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;五、原型链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其基本思想是&lt;span&gt;利用原型&lt;/span&gt;让一个引用类型&lt;span&gt;继承另一个引用类型的属性和方法&lt;/span&gt;。然后层层递进，就构成了实例与原型的链条，这就是所谓原型链的基本概念。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(){
　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.property = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
SuperType.prototype.getSuperValue &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.property;
};
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(){
　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subproperty = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承了 SuperType&lt;/span&gt;
&lt;span&gt;SubType.prototype = new&lt;/span&gt;&lt;span&gt;&lt;span&gt; SuperType();&lt;/span&gt;
SubType.prototype.getSubValue &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subproperty;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubType();
alert(instance.getSuperValue()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　一张图说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180317210209749-1226732938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; property 则位于 SubType.prototype 中。这是因为 property 是一个实例属性，而 getSuperValue() 则是一个原型方法。&lt;span&gt;既然 SubType.prototype 现在是 SuperType的实例&lt;/span&gt;，那么 property 当然就位于该实例中了。&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 12:56:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8592718.html</dc:identifier>
</item>
<item>
<title>R实战 第五篇：绘图（ggplot2） - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4954353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4954353.html</guid>
<description>&lt;p&gt;ggplot2包实现了基于语法的、连贯一致的创建图形的系统，由于ggplot2是基于语法创建图形的，这意味着，它由多个小组件构成，通过底层组件可以构造前所未有的图形。ggplot2可以把绘图拆分成多个面板，且能够按照顺序创建多重图形，基本上，无所不能，是R开发人员必学必会的包。&lt;/p&gt;
&lt;p&gt;ggplot2图形系统的核心理念是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把绘图与数据分离，把数据相关的绘图与数据无关的绘图分离；&lt;/li&gt;
&lt;li&gt;按图层作图，有利于结构化思维；&lt;/li&gt;
&lt;li&gt;具有命令式作图的调整函数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用ggplot2包创建图形时，每个图形都是由函数ggplot()创建的，由几何对象来控制绘制的几何图形，通过符号“+”来增加图形的元素，这使得绘制图形的过程结构化，同时使绘图更具灵活性，绘制出来的图形美观，避免繁琐的细节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，初始化图形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用函数ggplot()初始化图形对象，并指定绘制图形的数据集和坐标轴的映射，在ggplot()函数中，指定数据集的默认设置，便于后续图形选项的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ggplot(data = NULL, mapping = aes())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数data： 用于指定要用到的数据源；&lt;/p&gt;
&lt;p&gt;参数mapping：使用aes()函数指定每个变量的角色，除x和y之外的其他参数，例如，size、color、shape等，必须采用name=value的形式，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
aes(x, y, ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常见的图形美学选项是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;color&lt;/strong&gt;：对点、线和填充区域的边界进行着色&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fill&lt;/strong&gt;：对填充区域着色&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alpha&lt;/strong&gt;：演示的透明度，从透明（0）到不透明（1）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;linetype&lt;/strong&gt;：图案的线条（1=实线、2=虚线、3=点、4=点破折号、5=长破折号、6=双破折号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;size&lt;/strong&gt;：点的尺寸和线的宽度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shape&lt;/strong&gt;：点的形状（和par()函数的pch参数相同）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201803/628084-20180317194650888-1810632902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;position&lt;/strong&gt;：绘制条形图和点等对象的位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;binwidth&lt;/strong&gt;：直方图的宽度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;notch&lt;/strong&gt;：表示方块图是否应该有缺口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sides&lt;/strong&gt;：地毯图的位置（&quot;b&quot;=底部、&quot;l&quot;=左部、&quot;r&quot;=右部、&quot;bl&quot;=左下部，等)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;width&lt;/strong&gt;：箱线图的宽度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;group&lt;/strong&gt;：分组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stroke&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在下面的小节中，使用数据集mtcars作为ggplot的输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(ggplot2)
data(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtcars&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二，几何对象（geometric）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数ggplot()可以设置图形，但是没有视觉输出，需要使用一个或多个几何函数向图形中添加几何对象（geometric，简写为geom），包括&lt;strong&gt;点（point）、线（line）、条（bar）&lt;/strong&gt;等，而添加几何图形的格式十分简单，通过符号“+”把几何图形添加到plot中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ggplot()+&lt;span&gt;
geom_xxx()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，使用geom_point()函数输出点状图形，并接收以下美学参数：alpha、colour、fill、group、shape、size和stroke，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ggplot(data&lt;/span&gt;=mtcars, aes(x=wt,y=mpg))+&lt;span&gt;
  geom_point(color&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,size=&lt;span&gt;1&lt;/span&gt;,shape=&lt;span&gt;0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在一个图形中，可以绘制多个几何图形，只需要通过符号“+”添加就可以实现，例如，使用geom_smooth()函数添加一条平滑曲线和置信区间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
ggplot(data=mtcars, aes(x=wt,y=mpg))+&lt;span&gt;
  geom_point(color&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,size=&lt;span&gt;1&lt;/span&gt;,shape=&lt;span&gt;0&lt;/span&gt;)+&lt;span&gt;
  geom_smooth(method&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,linetype=&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该平滑函数的定义是几何平滑函数，语法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
geom_smooth(mapping = NULL, data = NULL, stat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smooth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  position &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ..., method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, formula = y ~&lt;span&gt; x,
  se &lt;/span&gt;= TRUE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;method：指定回归函数&lt;/li&gt;
&lt;li&gt;formula：在光滑函数中指定公式&lt;/li&gt;
&lt;li&gt;se：绘制置信区间&lt;/li&gt;
&lt;li&gt;level：使用的置信区间的水平&lt;/li&gt;
&lt;li&gt;fullrange：指定拟合应该涵盖全图（TRUE）或仅仅数据（FALSE），默认是FALSE；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三，主题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主题（Theme）用于控制图形的美学特征，ggplot图形的主题（theme）元素主要有三大类：&lt;strong&gt;布局（plot）、面板（panel）和坐标轴（axis）&lt;/strong&gt;，还有两个成分元素附着于面板上，主要包括两类：&lt;strong&gt;图例（legend）和带状区域（strip）&lt;/strong&gt;，ggplot2包通过theme()函数来统一控制图形的美学和文本特征，可以用于调整字体，背景色，前景色和网格线等。&lt;/p&gt;
&lt;p&gt;对于面板的网格线，分为主线（panel.grid.major）和 次线（panel.grid.minor ）,用户可以根据绘制图形的需要，显示或隐藏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，主题函数的参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;theme()函数的参数如下所示，每个参数的具体含义，请阅读文档：&lt;a href=&quot;http://ggplot2.tidyverse.org/reference/theme.html&quot; target=&quot;_blank&quot;&gt;Modify components of a theme&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
&lt;span&gt;theme(line, rect, text, title, aspect.ratio, axis.title, axis.title.x,
  axis.title.x.top, axis.title.y, axis.title.y.right, axis.text, axis.text.x,
  axis.text.x.top, axis.text.y, axis.text.y.right, axis.ticks, axis.ticks.x,
  axis.ticks.y, axis.ticks.length, axis.line, axis.line.x, axis.line.y,
  legend.background, legend.margin, legend.spacing, legend.spacing.x,
  legend.spacing.y, legend.key, legend.key.size, legend.key.height,
  legend.key.width, legend.text, legend.text.align, legend.title,
  legend.title.align, legend.position, legend.direction, legend.justification,
  legend.box, legend.box.just, legend.box.margin, legend.box.background,
  legend.box.spacing, panel.background, panel.border, panel.spacing,
  panel.spacing.x, panel.spacing.y, panel.grid, panel.grid.major,
  panel.grid.minor, panel.grid.major.x, panel.grid.major.y, panel.grid.minor.x,
  panel.grid.minor.y, panel.ontop, plot.background, plot.title, plot.subtitle,
  plot.caption, plot.margin, strip.background, strip.placement, strip.text,
  strip.text.x, strip.text.y, strip.&lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;.pad.grid, strip.&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;.pad.wrap, ...,
  complete &lt;/span&gt;= FALSE, validate =&lt;span&gt; TRUE)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，元素函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个参数的赋值，可以通过元素函数来实现，其中 &lt;code&gt;rel()&lt;/code&gt; 函数用于指定相对于父对象的相对值，而&lt;code&gt;margins()&lt;/code&gt; 函数用于指定元素的边界。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
margin(t = &lt;span&gt;0&lt;/span&gt;, r = &lt;span&gt;0&lt;/span&gt;, b = &lt;span&gt;0&lt;/span&gt;, l = &lt;span&gt;0&lt;/span&gt;, unit = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

element_blank()

element_rect(fill &lt;/span&gt;= NULL, colour = NULL, size = NULL, linetype =&lt;span&gt; NULL,
  color &lt;/span&gt;= NULL, inherit.blank =&lt;span&gt; FALSE)

element_line(colour &lt;/span&gt;= NULL, size = NULL, linetype =&lt;span&gt; NULL,
  lineend &lt;/span&gt;= NULL, color = NULL, arrow = NULL, inherit.blank =&lt;span&gt; FALSE)

element_text(family &lt;/span&gt;= NULL, face = NULL, colour = NULL, size =&lt;span&gt; NULL,
  hjust &lt;/span&gt;= NULL, vjust = NULL, angle = NULL, lineheight =&lt;span&gt; NULL,
  color &lt;/span&gt;= NULL, margin = NULL, debug = NULL, inherit.blank =&lt;span&gt; FALSE)

rel(x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;元素函数的详细使用示例，请参考：&lt;a href=&quot;http://ggplot2.tidyverse.org/reference/element.html&quot; target=&quot;_blank&quot;&gt;Theme elements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，向图形中添加主题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用ggplot2包绘制图形时，可以单独定义一个theme对象，然后添加到ggplot中，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
mytheme &amp;lt;-theme(panel.grid.major.x =&lt;span&gt; element_blank(),
                  panel.grid.minor.x &lt;/span&gt;=&lt;span&gt; element_blank(),
                  panel.grid.major.y &lt;/span&gt;= element_line(color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lightblue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,size =&lt;span&gt;0.1&lt;/span&gt;,linetype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;solid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,lineend=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                  panel.grid.minor.y &lt;/span&gt;=&lt;span&gt; element_blank(),
                  panel.background &lt;/span&gt;=&lt;span&gt; element_blank(),
                  axis.ticks&lt;/span&gt;=&lt;span&gt;element_blank()&lt;br/&gt;ggplot(data&lt;/span&gt;=mtcars, aes(x=wt,y=mpg))+&lt;span&gt;
  geom_point(color&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,size=&lt;span&gt;1&lt;/span&gt;,shape=&lt;span&gt;0&lt;/span&gt;)+&lt;span&gt;
  mytheme&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三，坐标（scale）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ggplot2包使用函数scale_x_xxx()和scale_y_xxx()分别控制坐标轴的数据，常用的函数有三个：scale_x_date,scale_x_discrete,scale_y_continuous，其中discrete表示坐标轴的值是可罗列的散列值，而continuous表示是不可罗列的连续值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
scale_y_continuous(name = waiver(), breaks =&lt;span&gt; waiver(),
  minor_breaks &lt;/span&gt;= waiver(), labels = waiver(), limits =&lt;span&gt; NULL,
  expand &lt;/span&gt;= waiver(), oob = censor, na.value =&lt;span&gt; NA_real_,
  trans &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bottom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sec.axis = waiver())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name：坐标轴上的文字&lt;/li&gt;
&lt;li&gt;breaks：间距，如何对坐标轴的值进行间断，如果不设置，那么使用默认值，显示设置：NULL（不间断），数值向量，函数（输入是范围，输出是间距）&lt;/li&gt;
&lt;li&gt;minor_breaks ：同breaks参数，表示最小的间距&lt;/li&gt;
&lt;li&gt;labels：标签，间距的文字显示；数量必须同breaks相同；&lt;/li&gt;
&lt;li&gt;limits：数值向量，用于指定坐标轴的最小值和最大值 &lt;/li&gt;
&lt;li&gt;expand：数值向量，默认值是c(0.05,0)，用于指定数据离坐标轴的距离&lt;/li&gt;
&lt;li&gt;oob：函数对象，Function that handles limits outside of the scale limits (out of bounds). &lt;/li&gt;
&lt;li&gt;na.value ：用于替换缺失值的值&lt;/li&gt;
&lt;li&gt;trans ：指定转化对象，用于产生breaks和labels；&lt;/li&gt;
&lt;li&gt;position：指定坐标轴的位置；&lt;/li&gt;
&lt;li&gt;sec.axis：指定辅助坐标轴（secondary axis）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，x轴是以日期（date）为值的坐标轴，而y轴按照pretty_breaks()函数进行间断，标签按照特定的格式显示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
library(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scales&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

ggplot(data&lt;/span&gt;=mtcars, aes(x=wt,y=mpg))+&lt;span&gt;
  geom_point(color&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,size=&lt;span&gt;1&lt;/span&gt;,shape=&lt;span&gt;0&lt;/span&gt;)+&lt;span&gt;
  scale_x_date(date_labels&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,date_breaks=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1 month&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+&lt;span&gt;
  scale_y_continuous(breaks&lt;/span&gt;=pretty_breaks(n=&lt;span&gt;3&lt;/span&gt;), labels=scales::unit_format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1e-&lt;span&gt;3&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用函数pretty_breaks()之前，请首先加载scales包；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
install.packages(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scales&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四，标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过函数labs()来指定图形的标题（title)，子标题（subtitle），坐标轴的标签（x，y）等，并可以指定标签的美学选项：&lt;/p&gt;

&lt;p&gt;参数是美学（aesthetic）选项，使用name=value模式，可以使用的选项是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指定文字：title、subtitle、caption、x和y&lt;/li&gt;
&lt;li&gt;指定美学选项：color、size等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;五，多重图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要同时绘制多个图形，可以使用gridExtra包中的grid.arrange()函数，绘制多重图时，需要定义一个ggplot()的列表，并把列表传递给grid.arrange()函数，在该函数中指定图形的布局（layout）例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
library(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gridExtra&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

gs&lt;/span&gt;=&lt;span&gt;list(NULL)

gs[[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]]&amp;lt;-&lt;span&gt;ggplot()
gs[[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;]]&amp;lt;-&lt;span&gt;ggplot()
gs[[n]]&lt;/span&gt;&amp;lt;-&lt;span&gt;ggplot()

grid.arrange(grobs&lt;/span&gt;=gs,ncol=&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六，分组和刻面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分组和刻面，都是把数据分组，便于观察各自的规律、趋势和模式，不同的是，分组是把图形绘制到一个大的图形中，通过美学特征来区分，而刻面是把图形绘制到不同的网格中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，分组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分组使通过ggplot2图把一个或多个带有形状、颜色、填充、尺寸和线类型等视觉特征的分组变量来实现的。&lt;/p&gt;
&lt;p&gt;在一个图形中画出两个或多个组的图形，使图形重叠为单一的图形，并用不同的颜色来区分，分组通常使用因子来实现，这就要求在数据集中存在因子变量，用于对数据分类，实现数据的分组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ggplot(data=ds,aes(x=var1,y=var2,fill=var3,shape=var4))+&lt;span&gt;
    geom_point()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，刻面（facet）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用函数facet_grid()和facet_wrap()创建网格图形，把多个图形分布在不同的网格中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
facet_wrap(~&lt;span&gt;var&lt;/span&gt;&lt;span&gt;,ncol)
facet_wrap(&lt;/span&gt;~&lt;span&gt;var&lt;/span&gt;&lt;span&gt;,nrowl)

facet_grid(rowvar&lt;/span&gt;~&lt;span&gt;colvar)
facet_grid(.&lt;/span&gt;~&lt;span&gt;colvar)
facet_grid(rowvar&lt;/span&gt;~.)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中在facet_grid()中的点号（ &lt;span&gt;&lt;strong&gt;.&lt;/strong&gt; &lt;/span&gt;）表示单行或单列。&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ggplot2.tidyverse.org/reference/theme.html&quot; target=&quot;_blank&quot;&gt;Modify components of a theme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ggplot2.tidyverse.org/reference/element.html&quot; target=&quot;_blank&quot;&gt;Theme elements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/24779017&quot; target=&quot;_blank&quot;&gt;如何使用 ggplot2 ？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wzgl__wh/article/details/51901093&quot; target=&quot;_blank&quot;&gt;快速学习ggplot2&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 12:41:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4954353.html</dc:identifier>
</item>
<item>
<title>如何在原生微信小程序中实现数据双向绑定 - iKcamp</title>
<link>http://www.cnblogs.com/ikcamp/p/8592252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ikcamp/p/8592252.html</guid>
<description>&lt;blockquote readability=&quot;1.0714285714286&quot;&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://qiu8310.github.io/minapp/&quot; class=&quot;uri&quot;&gt;https://qiu8310.github.io/minapp/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://github.com/qiu8310&quot;&gt;Mora&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在原生小程序开发中，数据流是单向的，无法双向绑定，但是要实现双向绑定的功能还是蛮简单的！&lt;/p&gt;
&lt;blockquote readability=&quot;7.5485893416928&quot;&gt;
&lt;p&gt;下文要讲的是小程序框架 &lt;a href=&quot;https://github.com/qiu8310/minapp&quot;&gt;minapp&lt;/a&gt; 中实现双向绑定的原理，在 &lt;a href=&quot;https://github.com/qiu8310/minapp&quot;&gt;minapp&lt;/a&gt; 中，你只需要在 wxml 模板中给组件的属性名后加上 &lt;code&gt;.sync&lt;/code&gt; 就可以实现双向绑定。下面为了解释其原理，过程可能会说的稍微复杂些，但其实 &lt;a href=&quot;https://github.com/qiu8310/minapp&quot;&gt;minapp&lt;/a&gt; 框架已经处理了那些繁杂的细节！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，&lt;strong&gt;要使数据双向绑定，应该避免过多的数据源&lt;/strong&gt;。&lt;br/&gt;在数据从上到下自然流动的情况下，如果每个组件中都维护它们自己的数据，而又要保持它们数据值的一致，这虽然可以做到，但实现过程并不会简单。&lt;br/&gt;但是也没必要说为了有一个统一的数据源就使用 &lt;strong&gt;mobx&lt;/strong&gt; 或 &lt;strong&gt;redux&lt;/strong&gt; 来全局管理数据，这就有点杀鸡用牛刀的感觉了。&lt;br/&gt;由于双向绑定只存在于父子组件之间，而数据又是从父到子传递的，所以可以优先使用父组件中的数据为数据源，&lt;br/&gt;子组件每次更新数据并不更新它自己内部的数据，而是通过事件机制触发父组件更新它的数据，而父组件更新数据后又会将更新的数据自然地传给子组件，&lt;br/&gt;由此达到数据的双向流动！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/13/1621e2bf6ada3ffb?w=320&amp;amp;h=320&amp;amp;f=png&amp;amp;s=5298&quot; alt=&quot;data-stream&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并不是所有数据都需要双向绑定，也并不是所有数据都是对外的，子组件还可以有它自己的一个内部数据。所以这就涉及到我们要说的第二个问题：&lt;strong&gt;区分哪些数据需要双向绑定，哪些数据又需要子组件自己维护&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;用过 &lt;strong&gt;vue&lt;/strong&gt; 的应该都知道，在 vue 中要实现双向绑定，需要在模板中做特殊处理。比如要将父组件的 &lt;code&gt;parentAttr&lt;/code&gt; 双向绑定到子组件的 &lt;code&gt;childAttr&lt;/code&gt; 上，需要在父组件的模板中这样写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;child&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; childAttr.sync=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;parentAttr&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是小程序并没有这样的简单的语法，小程序的 wxml 语言的属性名中甚至都不允许出现 &quot; . &quot; 这样的字符。回到我们的问题上来，&lt;strong&gt;子组件需要知道哪些属性需要双向绑定，哪些属性需要自己维护&lt;/strong&gt;，&lt;br/&gt;给模板加个字段（&lt;code&gt;syncAttrMap&lt;/code&gt;）专门来告诉子组件需要双向绑定的数据集合不就行了么。如，可以将上面的示例写成微信小程序支持的写法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;child&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; childAttr=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{{parentAttr}}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; syncAttrMap=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;childAttr=parentAttr&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;  如果同时存在多个双向绑定和不需要双向绑定的属性时，可以写成下面这样：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;  p1, p2 分别双向绑定到子组件的 c1, c2，而 p3 单向绑定到 c3 上&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;child&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; c1=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{{p1}}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; c2=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{{p2}}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; c3=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{{p3}}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; syncAttrMap=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c1=p1&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;c2=p2&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，就需要处理&lt;strong&gt;子组件数据更新的问题&lt;/strong&gt;了，在子组件中有两部分数据，一部分是内部数据，另一部分是父组件中的数据，&lt;br/&gt;子组件可以通过读取属性 &lt;code&gt;syncAttrMap&lt;/code&gt; 来得到哪些数据是内部的数据，哪些数据是父组件的数据，并且可以知道对应&lt;br/&gt;的父组件中的数据的键名是什么。由于原生的组件方法 &lt;code&gt;setData&lt;/code&gt; 不会管你是内部数据，还是父组件中的数据，只要&lt;br/&gt;你调用它去更新数据，它只会更新内部的数据。所以需要另外实现一个新的方法，来自动判断数据源，如果是内部数据，&lt;br/&gt;则直接调用 &lt;code&gt;setData&lt;/code&gt; ；如果是双向绑定中的父组件数据，则可以触发一个事件去通知父组件去更新对应的值。&lt;/p&gt;
&lt;p&gt;所以根据上面的描述，父组件需要有个监听函数，子组件需要有个智能的 &lt;code&gt;setData&lt;/code&gt; 函数。不防将父组件的监听函数&lt;br/&gt;命名为 &lt;code&gt;onSyncAttrUpdate&lt;/code&gt;，将子组件的智能 &lt;code&gt;setData&lt;/code&gt; 函数命名为 &lt;code&gt;setDataSmart&lt;/code&gt;，则可以有如下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 父组件&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;onSyncAttrUpdate&lt;/span&gt;(e) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setData&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;detail&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 子组件传来的需要更新的数据&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 父组件的模板 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;child&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; childAttr=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{{parentAttr}}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; syncAttrMap=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;childAttr=parentAttr&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; bind:syncAttrUpdate=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;onSyncAttrUpdate&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 子组件&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;childAttr&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; String&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;syncAttrMap&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; String
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 子组件更新数据时，只要调用此方法即可，而不是 `setData`&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setDataSmart&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// splitDataBySyncAttrMap 函数的实现过程就不说了，只是将对象拆分，大家应该都能实现&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;parentData&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; innerData&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;splitDataBySyncAttrMap&lt;/span&gt;(data&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;syncAttrMap&lt;/span&gt;)

      &lt;span class=&quot;co&quot;&gt;// 内部数据使用 setData 更新&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;keys&lt;/span&gt;(innerData).&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setData&lt;/span&gt;(innerData) &lt;span class=&quot;co&quot;&gt;// setData 中还支持 callback 的回调，为了简化代码，这里不讨论&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;co&quot;&gt;// 双向绑定的父组件数据触发事件让父组件自己去更新&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;keys&lt;/span&gt;(parentData).&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;triggerEvent&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'syncAttrUpdate'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; parentData)
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，一个简单的双向绑定功能就完成了。但是由于子组件也有可能包含其它组件，也就是说子组件也可以是父组件，而父组件同样也&lt;br/&gt;可以是子组件。所以上面的 &lt;code&gt;onSyncAttrUpdate&lt;/code&gt; &lt;code&gt;setDataSmart&lt;/code&gt; 函数需要在每个组件中都实现，所以不防&lt;br/&gt;定义一个公共对象 &lt;code&gt;BaseComponent&lt;/code&gt; 来实现上面的所有功能，如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// BaseComponent&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; BaseComponent &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;syncAttrMap&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; String
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setDataSmart&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;onSyncAttrUpdate&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后将 BaseComponent minin 到每个组件的对象上去就可以了；另外小程序中还有一个特殊的组件：&lt;strong&gt;Page&lt;/strong&gt;，虽然 Page 和 Component 结构是两样的，&lt;br/&gt;但它也应该算是一个组件，不过它一定是父组件，不可能是别的组件的子组件，所以还需要将 &lt;code&gt;onSyncAttrUpdate&lt;/code&gt; 方法写了所有的 Page 定义中。&lt;br/&gt;所有这些就是 &lt;a href=&quot;https://github.com/qiu8310/minapp&quot;&gt;minapp&lt;/a&gt; 的双向绑定的基本原理了。&lt;/p&gt;
&lt;p&gt;等等，最后还有一件事：&lt;strong&gt;wxml 模板&lt;/strong&gt;，不能让用户每次写双向绑定的时候都要写那么复杂语句吧？当然不用，&lt;a href=&quot;https://github.com/qiu8310/minapp&quot;&gt;minapp&lt;/a&gt; 在编译时，会将模板做个简单的转化：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;child&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; childAttr.sync=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;parentAttr&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 由于属性名 syncAttrMap 是固定的，所以完全可以通过编译手段，将上面的模板转成下面这个模板 --&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;child&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; childAttr=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{{parentAttr}}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; syncAttrMap=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;childAttr=parentAttr&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;谢谢，文章到此结束，欢迎关注 &lt;a href=&quot;https://github.com/qiu8310/minapp&quot;&gt;minapp：重新定义微信小程序的开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/14/1605309af5a7dfa2?w=1426&amp;amp;h=778&amp;amp;f=png&amp;amp;s=414615&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 11:48:00 +0000</pubDate>
<dc:creator>iKcamp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ikcamp/p/8592252.html</dc:identifier>
</item>
<item>
<title>EntityFramework Core 1.1+ Backing Fields（返回字段） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8586347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8586347.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;通过我发表的博文可知最近一段时间会将持续讲解EntityFramework Core特性，在此之前我提到过Backing Fields，回头翻了翻感觉写的还不够好，于是乎再来讲解一番，也是自己再一次巩固，废话少说，开门见山。&lt;/p&gt;
&lt;h2&gt;EntityFramework Core Backing Fields基础&lt;/h2&gt;
&lt;p&gt;Backing Fields特性出现于EF Core 1.1，我们姑且将其翻译为返回字段，这样翻译和实际作用对应，Backing Fields允许EF Core读或者写到一个字段而非属性，说的通俗易懂一点则是允许对字段进行映射。当属性只有一个GET访问器利用此特性将非常有用，在之前版本我们必须同时需要设置GET和SET访问器，接下来我们详细来讲解Backing Fields（对字段进行映射）。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;Backing Fields特性允许EF Core读或者写数据到字段中而不是属性中。默认情况下满足以下四种规则都会配置成Backing Fields。&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;16&quot;&gt;_&amp;lt;camel-cased property name&amp;gt;&lt;/li&gt;
&lt;li class=&quot;16&quot;&gt;_&amp;lt;property name&amp;gt;&lt;/li&gt;
&lt;li class=&quot;16&quot;&gt; m_&amp;lt;camel-cased property name&amp;gt;&lt;/li&gt;
&lt;li class=&quot;16&quot;&gt; m_&amp;lt;property name&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们首先给出本节需要用到的两个类Blog和Post，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreatedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime ModifiedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CommentCount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreatedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime ModifiedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 根据如上对Backing Fields的约定来我们将Blog中的Url配置成Backing Fields，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Url
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _url; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { _url =&lt;span&gt; value; }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreatedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime ModifiedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;官网对于如上配置Backing Fields即（_url）如此解释，在配置Backing Fields后，EF Core会将数据库表中数据直接写入该字段即（_url）。如果我们需要EF Core读取或写入值，那么将尽可能使用该属性。 例如，如果需要EF Core更新某个属性的值，那么它将使用属性设置器（若已定义）， 如果该属性是只读的，则将它写入到字段中。想必如上解释已经很明了，无需过多再阐述。我们来演示此种情况通过字段来设置属性值，现在我们假设这样一种情况，在创建我们自己博客时，此时我们的博客Url就需要确定下来，所以在添加Blog时我们将Ur以构造函数参数传入给Backing Fields即_url，所以我们在上述基础上添加构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;public&lt;/span&gt; Blog(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url)
        {
            _url &lt;/span&gt;=&lt;span&gt; url;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们在控制台中创建Blog并添加到数据库中，您可以先想象一下将会发生什么，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                context.Blogs.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Blog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs/CreateMyself&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                });
                context.SaveChanges();
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; blog &lt;span&gt;in&lt;/span&gt;&lt;span&gt; context.Blogs)
                {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{blog.Id} {blog.Name} {blog.Url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201803/589642-20180317133304707-1201577679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为EF Core默认是用无参构造函数实例化对象，既然我们自定义调用有参构造函数，所以必须显式声明无参构造函数&lt;/span&gt;。否则在遍历数据时将抛出异常：System.InvalidOperationException:“A parameterless constructor was not found on entity type 'Blog'. In order to create an instance of 'Blog' EF requires that a parameterless constructor be declared.”。&lt;/p&gt;
&lt;p&gt;除了上述我们根据给出的约定EF Core将其看作为返回字段外，我们仍然可以手动利用HasField进行配置，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
builder.Property(p =&amp;gt; p.Url).HasField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除此之外我们还可通过UsePropertyAccessMode方法中的参数枚举来配置对属性的访问模式，该参数枚举存在如下三种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201803/589642-20180317180355132-645024103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如我们需要对字段访问模式为在构造函数中，那么我们可以进行如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 builder.Property(p =&amp;gt; p.Url).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VARCHAR(100)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).UsePropertyAccessMode(PropertyAccessMode.FieldDuringConstruction);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是所有访问模式依然是通过GET或者SET访问器，比如属性设置为只读即使进行了如上配置，依然是字段。上述参数枚举说明详情请见其具体定义而定。&lt;/p&gt;
&lt;p&gt;上述我们是将属性的字段进行映射，同时EF Core 1.1也支持不需要属性而直接映射字段，比如我们在Blog中再定义如下字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _NonPropertyField;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们进行如下映射配置，迁移后将在数据库表中生成NonPropertyBackingField列并对应字段指向_NonPropertyField。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
builder.Property&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NonPropertyBackingField&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).HasField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_NonPropertyField&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;EntityFramework Core Backing Fields思考&lt;/h2&gt;
&lt;p&gt; 到此是不是就这么简单结束了呢？显然不是，当学习任何一门技术时，所出现技术特性是为了解决问题而不是凭空产出，什么意思呢？当我们在自学过程中看官网例子时，官网将基础知识一股脑全部灌输给我们，那我们是不是应该不假思索下，它有什么用呢？比如上述Backing Fields特性的出现，因为我给您讲解了，您就知道有这么个特性，但是不知道怎么用那和知道、了解有和区别呢？还不明白，接下来我们利用EF 6来看一个例子，通过此例子您就会顿悟了。请继续往下看。&lt;/p&gt;
&lt;h3&gt;EntityFramework 6.x 没有Backing Fields所带来问题&lt;/h3&gt;
&lt;p&gt;我们创建EF 6.x控制台程序，给出如下测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseCase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Url
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _url; }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetUrl()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/CreateMyself&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们来添加数据看看，看看数据库表是否能正常添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            { 
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; useCases =&lt;span&gt; ctx.UseCases;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; useCase = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UseCase();
                useCase.GetUrl();
                useCases.Add(useCase);
                ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201803/589642-20180317151213918-606290499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201803/589642-20180317150813473-923258503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在客户端我们通过C#代码设置了Url值，但是并未同步到数据库表中，这也是EF 6.x中没有解决的问题而在EF Core利用Backing Fields轻而易举。&lt;span&gt;我们能够看到当访问器GET或者SET中包含业务逻辑时这个时候就很能凸显Backing Fields的实际作用&lt;/span&gt;。下面我们来看看在EF Core中的实际用途。&lt;/p&gt;
&lt;h3&gt;EntityFramework Core Backing Fields用途&lt;/h3&gt;
&lt;p&gt;我们知道在EntityFramework中导航属性必须是ICollection&amp;lt;T&amp;gt;集合类型，如文章开头我们定义Blog中的Posts导航属性，我们也知道在ICollection&amp;lt;T&amp;gt;集合类型中存在Add、Remove、Clear等方法，这也就意味着有该集合类型的导航属性我们都可以对其进行添加或删除对象甚至于清除对象。正常情况下我们需要将实际业务行为代码封装在实体模型中，从这个角度出发，很显然我们不能这么做。我们希望公开一个接口，通过该接口控制业务行为以及何时进行控制，以及何时应该发生怎样的行为，这不仅仅是良好的领域驱动设计行为，也是很好的面向对象的设计行为。幸运的是在EntityFramework Core中对集合导航属性不仅仅支持ICollection&amp;lt;T&amp;gt;，同时也支持IEnumerable&amp;lt;T&amp;gt;，此时我们将Blog中的Posts集合导航属性修改成IEnemerable&amp;lt;Posts&amp;gt;，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201803/589642-20180317160208580-1258366021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们定义集合类型为IEnumerable&amp;lt;T&amp;gt;，紧接着我们修改成如下形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreatedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime ModifiedTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;Post&amp;gt; _posts = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Post&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;Post&amp;gt; Posts =&amp;gt;&lt;span&gt; _posts.ToList();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么问题就随之而来，我们为何要修改成如上形式呢？如上定义私有的_posts返回字段并通过Posts来公开暴露，从安全角度看非常必须而且很有必要，当定义集合类型为ICollection&amp;lt;T&amp;gt;，此时我们能完全控制Post对象，也就是说能够任意进行添加、删除、清除操作。因为这完全属于内部行为，无需对外暴露。当添加Post对象时，我们在Blog对象内部定义添加方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddPost(Post post)
        {
            _posts.Add(post);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么问题又来了，我们定义了返回字段_posts后为何传递给对外暴露的Posts时要创建副本呢？因为对外暴露的Posts最终返回的是实际List&amp;lt;T&amp;gt;集合，所以最终还是会转换成ICollection&amp;lt;T&amp;gt;集合类型，毫无疑问会造成性能的下降，所以我们需要通过创建副本来进行修正所以要ToList。还需要说明一点的是在EF Core 1.1版本中并不会映射上述私有的返回字段到数据存储中，我们需要在OnModelCreating方法中进行如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; navigation = modelBuilder.Entity&amp;lt;Blog&amp;gt;&lt;span&gt;().Metadata.FindNavigation(nameof(Blog.Posts));

            navigation.SetPropertyAccessMode(PropertyAccessMode.Field);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码告诉EF Core通过命名约定发现它的字段并访问Post属性。直到EF Core 2.0仍然无法对导航属性进行返回字段配置，只能对标量属性进行返回字段配置。通过如下配置抛出异常可得知：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
builder.Property(p =&amp;gt; p.Posts).HasField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_posts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201803/589642-20180317174703507-58695136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过github上提交的Issue得知对导航属性进行返回字段的配置会在EF Core  2.1中实现，推荐为如下配置形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
modelBuilder.Entity&amp;lt;Blog&amp;gt;&lt;span&gt;()
    .HasMany(
        e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.Posts, 
        nb &lt;/span&gt;=&amp;gt;&lt;span&gt; nb.UsePropertyAccessMode(PropertyAccessMode.Field))
    .WithOne(
        e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.Blog, 
        nb &lt;/span&gt;=&amp;gt; nb.UsePropertyAccessMode(PropertyAccessMode.Field))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此关于Backing Fields详细说明就已结束，这里我们来一个完整性总结。使用Backing Fields的时机是：&lt;span&gt;大部分情况下当属性中访问器存在业务逻辑时可能会用到Backing Fields，同时对于集合导航属性 推荐使用如下组合方式。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义私有只读的返回字段（Backing Fields）。&lt;/li&gt;
&lt;li&gt;定义公共的IEnumerable&amp;lt;T&amp;gt;接口属性。&lt;/li&gt;
&lt;li&gt;对返回字段创建副本传递给对外暴露的公共接口属性&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;侃侃而谈如上诸多理论，在实际项目中或许直接定义集合导航属性为ICollection&amp;lt;T&amp;gt;更加简单粗暴，又或者赶项目进度谁会顾及那么多呢，能实现就行。精简的内容，深入的讲解，我们下节再会。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 10:27:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8586347.html</dc:identifier>
</item>
</channel>
</rss>