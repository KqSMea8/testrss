<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring DAO模块 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9744729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9744729.html</guid>
<description>&lt;p&gt;Spring的DAO模块提供了对JDBC、Hibernate、Mybatis等DAO层支持，本节介绍DAO模块对JDBC的支持。DAO模块依赖ommons-dbcp.jar、commons-pool.jar。&lt;/p&gt;
&lt;p&gt;一、JdbcDaoSupport的使用&lt;/p&gt;
&lt;p&gt;传统的JDBC时需要创建连接、打开、执行sql、关闭连接这一系列的步骤，Spring框架对JDBC进行了封装，我们只需使用封装好的JdbcTemplate执行sql语句。既然是JdbcDaoSupport的使用，为什么是使用JdbcTemplate呢？因为JdbcDaoSupport提供了JdbcTemplate对象，通过JdbcTemplate对象进行数据库操作。可以转到定义，查看JdbcDaoSupport、JdbcTemplate两个类的具体实现。我们通过下面的例子来了解JdbcDaoSupport的使用，这里还是使用JDBC章节的数据库daodemodb和表t_user信息。&lt;/p&gt;
&lt;p&gt;第一步，根据t_user表信息准备Model类User。定义了id、name、age、money属性，并声明了两个构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_090e0986-390d-472f-99bf-a3dc7eff2420&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_090e0986-390d-472f-99bf-a3dc7eff2420&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_090e0986-390d-472f-99bf-a3dc7eff2420&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Id:&quot;+&lt;span&gt;this&lt;/span&gt;.getId()+&quot; Name:&quot;+&lt;span&gt;this&lt;/span&gt;.getName()+&quot; Age:&quot;+&lt;span&gt;this&lt;/span&gt;.getAge()+&quot; Money:&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMoney();
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Age; 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; Money;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User()
    {
        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User(String name, &lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        
        Name &lt;/span&gt;=&lt;span&gt; name;
        Age &lt;/span&gt;=&lt;span&gt; age;
        Money &lt;/span&gt;=&lt;span&gt; money;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Id;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        Id &lt;/span&gt;=&lt;span&gt; id;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        Name &lt;/span&gt;=&lt;span&gt; name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Age;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        Age &lt;/span&gt;=&lt;span&gt; age;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getMoney() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Money;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMoney(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        Money &lt;/span&gt;=&lt;span&gt; money;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第二步，定义接口类IUserDAO，在接口中声明了两个方法，QueryAllUser方法属于查询操作，查询所有User，AddUser属于更新操作，新增User。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_832ef21a-31d7-44c3-bada-281da871c66b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_832ef21a-31d7-44c3-bada-281da871c66b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_832ef21a-31d7-44c3-bada-281da871c66b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserDAO {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt;QueryAllUser();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean AddUser(User user);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean transfer(&lt;span&gt;int&lt;/span&gt; fromUserId, &lt;span&gt;int&lt;/span&gt; toUserId, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; transferMoney);
       
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第三步，就是JdbcDaoSupport的使用了，在下面的SpringDAODemo类中首先继承了JdbcDaoSupport，同时实现了IUserDAO 接口中的方法。JdbcDaoSupport提供了JdbcTemplate对象，SpringDAODemo继承了JdbcDaoSupport,所以也就可以直接获取到JdbcTemplate对象，然后执行该对象的方法进行数据库操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_750dd1b9-3da3-4ed1-8f44-ba28adc806f9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_750dd1b9-3da3-4ed1-8f44-ba28adc806f9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_750dd1b9-3da3-4ed1-8f44-ba28adc806f9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.support.JdbcDaoSupport;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpringDAODemo &lt;span&gt;extends&lt;/span&gt; JdbcDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IUserDAO {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;ApplicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        IUserDAO userDao&lt;/span&gt;=(IUserDAO)factory.getBean(&quot;userDao&quot;&lt;span&gt;);
        User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; User(&quot;JdbcDaoSupportTest&quot;,26,333.33&lt;span&gt;);
        userDao.AddUser(user);
        List&lt;/span&gt;&amp;lt;User&amp;gt; list=&lt;span&gt;userDao.QueryAllUser(); 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User u:list)
        {
            System.out.println(u.toString());
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; QueryAllUser() {
        String sql&lt;/span&gt;=&quot;select id,name,age,money from t_user order by id desc&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list=&lt;span&gt;getJdbcTemplate().queryForList(sql);
        List&lt;/span&gt;&amp;lt;User&amp;gt; userList=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;User&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Map&amp;lt;String,Object&amp;gt;&lt;span&gt; row:list)
        {
            User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            user.setId((Integer)row.get(&lt;/span&gt;&quot;id&quot;&lt;span&gt;));
            user.setName((String)row.get(&lt;/span&gt;&quot;name&quot;&lt;span&gt;));
            user.setAge((Integer)row.get(&lt;/span&gt;&quot;age&quot;&lt;span&gt;));
            user.setMoney(Double.parseDouble(row.get(&lt;/span&gt;&quot;money&quot;&lt;span&gt;).toString()));
            userList.add(user);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userList;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean AddUser(User user) {
        String sql&lt;/span&gt;=&quot;insert into t_user (name,age,money) values (?,?,?)&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; row=getJdbcTemplate().update(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{user.getName(),user.getAge(),user.getMoney()});
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(row&amp;gt;0&lt;span&gt;)
        {
            System.out.println(&lt;/span&gt;&quot;数据新增成功!&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第四步，配置属性。在上面的main方法中先通过上下文获取到bean对象，然后执行新增操作和查询操作。但是上面的代码并未看到数据库信息，这里还需要在ApplicationContext.xml中配置数据库信息，并为JdbcDaoSupportDemo设置数据源。为什么会有dataSource属性呢，因为JdbcDaoSupport中包含这个属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d2be1526-6e8a-4981-ad62-db2b8fcc06c2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d2be1526-6e8a-4981-ad62-db2b8fcc06c2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d2be1526-6e8a-4981-ad62-db2b8fcc06c2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClassName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.mysql.jdbc.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc:mysql://127.0.0.1:3306/daodemodb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;123456&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userDao&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.SpringDAODemo&quot;&lt;/span&gt;&lt;span&gt; depends-on&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第五步，pom.xml中配置的依赖信息。例子是Spring中DAO的实现，而且是对jdbc的封装，所以包含Spring相关依赖和jdbc的相关依赖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_5ae48952-3743-46a6-85e1-ac1c9fb29c94&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5ae48952-3743-46a6-85e1-ac1c9fb29c94&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5ae48952-3743-46a6-85e1-ac1c9fb29c94&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringDAO&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.0.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-context&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-jdbc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-dbcp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-dbcp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-pool&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-pool&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/mysql/mysql-connector-java &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.1.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行SpringDAODemo，可以发现数据库和打印结果中增加了一条记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201810/733213-20181005134745642-442261352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二.MappingSqlQuery的使用&lt;/p&gt;
&lt;p&gt;在JdbcDaoSupport的使用小节获取所有User的方法QueryAllUser()中，使用getJdbcTemplate().queryForList()返回的是List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;类型，需要遍历转换成Java对象，那问题来了，查询的不止这一个方法，可能以后会有条件查询的方法，那每次都要把从数据库返回的List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;类型的List转一遍，当然也可以专门写一个转换的方法，这样每次传List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;类型的参数，然后返回List&amp;lt;User&amp;gt;类型的值。其实还有一种方式，就是使用MappingSqlQuery。MappingSqlQuery是一个抽象类，需要实现它的方法mapRow()。&lt;br/&gt;第一步，实现MappingSqlQuery抽象类，这里在UserMappingSqlQuery类中实现了mapRow()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_39fbd945-cf43-45f1-b8cd-0933dbbffa7e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_39fbd945-cf43-45f1-b8cd-0933dbbffa7e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_39fbd945-cf43-45f1-b8cd-0933dbbffa7e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.object.MappingSqlQuery;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserMappingSqlQuery &lt;span&gt;extends&lt;/span&gt; MappingSqlQuery&amp;lt;User&amp;gt;&lt;span&gt;{
    
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; User mapRow(ResultSet rs, &lt;span&gt;int&lt;/span&gt; rowNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setId((Integer)rs.getInt(&lt;/span&gt;&quot;id&quot;&lt;span&gt;));
        user.setName((String)rs.getString(&lt;/span&gt;&quot;name&quot;&lt;span&gt;));
        user.setAge((Integer)rs.getInt(&lt;/span&gt;&quot;age&quot;&lt;span&gt;));
        user.setMoney((Double)rs.getDouble(&lt;/span&gt;&quot;money&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第二步，UserMappingSqlQuery类的使用。这里重写SpringDAODemo类中的QueryAllUser()方法。UserMappingSqlQuery需要传入DataSource和sql，并执行compile()编译。这里通过getDataSource()获取的是JdbcDaoSupport的DataSource属性。如果有参数，可以使用setParameters()设置参数，下面的代码为了演示设置参数，增加了where 1=1的查询条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_436f8fbe-57db-472e-9470-88b237f83919&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_436f8fbe-57db-472e-9470-88b237f83919&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_436f8fbe-57db-472e-9470-88b237f83919&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; QueryAllUser() {
        String sql&lt;/span&gt;=&quot;select id,name,age,money from t_user where ?&quot;&lt;span&gt;;
        UserMappingSqlQuery userQuery&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserMappingSqlQuery();
        userQuery.setDataSource(getDataSource());
        userQuery.setSql(sql);
        userQuery.setParameters(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlParameter(java.sql.Types.VARCHAR));
        userQuery.compile();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; userQuery.execute(&lt;span&gt;new&lt;/span&gt; Object[]{&lt;span&gt;new&lt;/span&gt; String(&quot;1=1&quot;&lt;span&gt;)});
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;三.SqlUpdate的使用&lt;/p&gt;
&lt;p&gt;SqlUpdate主要是用来更新，可以设置参数。SqlUpdate可以将某个功能模块化。通过下面的例子来了解下SqlUpdate的使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_744b5dac-e65d-4a88-915f-e24415d192f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_744b5dac-e65d-4a88-915f-e24415d192f8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_744b5dac-e65d-4a88-915f-e24415d192f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.sql.DataSource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.SqlParameter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.object.SqlUpdate;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserSqlUpdate &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SqlUpdate{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;ApplicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        UserSqlUpdate userSqlUpdate&lt;/span&gt;=(UserSqlUpdate)factory.getBean(&quot;userSqlUpdate&quot;&lt;span&gt;);
        userSqlUpdate.updateUserMoney(&lt;/span&gt;&quot;小李&quot;,666.66&lt;span&gt;); 
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserSqlUpdate(DataSource ds) {
        setDataSource(ds);
        setSql(&lt;/span&gt;&quot;update t_user set money=? where name=?&quot;&lt;span&gt;);
        declareParameter(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlParameter(java.sql.Types.DOUBLE) );
        declareParameter(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlParameter(java.sql.Types.VARCHAR) );
        compile();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean updateUserMoney(String name,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; money)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; row= update(&lt;span&gt;new&lt;/span&gt; Object[]{&lt;span&gt;new&lt;/span&gt; Double(money),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(name)});
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(row&amp;gt;0&lt;span&gt;)
        {
            System.out.println(&lt;/span&gt;&quot;数据新增成功!&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在ApplicationContext.xml中配置userSqlUpdate对应的bean节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_82d3edae-e25b-46f2-acc2-2e40b6453274&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_82d3edae-e25b-46f2-acc2-2e40b6453274&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82d3edae-e25b-46f2-acc2-2e40b6453274&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userSqlUpdate&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.UserSqlUpdate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; index&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在上面的UserSqlUpdate中继承了SqlUpdate，通过setDataSource、setSql分别设置SqlUpdate的数据源和要执行的sql。在main方法中将name为小李的money修改为666.66，执行main方法之后会打印出数据新增成功，数据库中小李的money改成了666.66。&lt;/p&gt;
&lt;p&gt;四.SqlFunction的使用&lt;/p&gt;
&lt;p&gt;SqlFunction返回单一行的查询结果，默认返回int，也可以重载返回其他类型。下面直接在main函数中使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_d6d1e472-e75f-42c8-927d-18495f878b40&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d6d1e472-e75f-42c8-927d-18495f878b40&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d6d1e472-e75f-42c8-927d-18495f878b40&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbcp.BasicDataSource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.object.SqlFunction;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlFunctionDemo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;ApplicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        BasicDataSource dataSource&lt;/span&gt;=(BasicDataSource)factory.getBean(&quot;dataSource&quot;&lt;span&gt;);
        SqlFunction sf&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; SqlFunction(dataSource,&quot;select count(1) from t_user;&quot;&lt;span&gt;);
        sf.compile();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=&lt;span&gt;sf.run();
        System.out.println(&lt;/span&gt;&quot;User Count:&quot;+&lt;span&gt;count);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;五、事务管理&lt;/p&gt;
&lt;p&gt;至于什么是事务在JDBC章节已经介绍，这里就不再说。JDBC中有事务管理，Spring使用DataSourceTransactionManager 作为JDBC的事务管理者，同时把被管理的对象使用 TransactionProxyFactoryBean配置。从名字也能猜出这里使用的设计模式是代理设计模式。这是一个事务代理Bean，能够使用IOC、AOP等注入事务管理代码。在JDBC中介绍事务时用的转账操作，这里为了更好理解，还是使用转账操作。&lt;br/&gt;第一步，在IUserDAO接口中增加转账方法transfer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Boolean transfer(&lt;span&gt;int&lt;/span&gt; fromUserId, &lt;span&gt;int&lt;/span&gt; toUserId, &lt;span&gt;float&lt;/span&gt; transferMoney);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步，在SpringDAODemo类中实现transfer。从fromUserId这个用户转账到toUserId这个用户，outInMoney方法就是执行sql更新数据库用户的money。这里如果人为制造一个异常，把int i=1/0;这行注释取消，就会在后面执行转账时自动回滚，转账不会成功。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_2aae4478-a3c2-4936-aff2-c14e352c2fc0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2aae4478-a3c2-4936-aff2-c14e352c2fc0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2aae4478-a3c2-4936-aff2-c14e352c2fc0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; Boolean transfer(&lt;span&gt;int&lt;/span&gt; fromUserId, &lt;span&gt;int&lt;/span&gt; toUserId, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; transferMoney) {
        
        Boolean out&lt;/span&gt;= outInMoney(fromUserId,-&lt;span&gt;transferMoney);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=1/0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事务回滚&lt;/span&gt;
        Boolean in=&lt;span&gt;outInMoney(toUserId,transferMoney);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; out&amp;amp;&lt;span&gt;in;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Boolean outInMoney(&lt;span&gt;int&lt;/span&gt; toUserId,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; money)
    {
        String sql&lt;/span&gt;=&quot;update  t_user set money=money+? where id=? &quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; row=getJdbcTemplate().update(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{money,toUserId});
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(row&amp;gt;0&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第三步，配置事务，在ApplicationContext.xml中配置事务管理对象DataSourceTransactionManager，设置事务代理对象TransactionProxyFactoryBean。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_20aefe57-2361-4178-9a2e-5398003ad7f9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20aefe57-2361-4178-9a2e-5398003ad7f9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20aefe57-2361-4178-9a2e-5398003ad7f9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置业务层代理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userDaoProxy&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置目标对象 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;target&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;userDao&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入事务管理器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入事务的属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionAttributes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;transfer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PROPAGATION_REQUIRED&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第四步，执行转账操作，在main方法中执行transfer方法，为用户1、2进行转账，如果transfer方法中人为制造的异常注释的话是可以正常转账，取消注释则转账失败，打印事务回滚。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_4205b285-f796-4086-bcf9-57b4b3940f0f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4205b285-f796-4086-bcf9-57b4b3940f0f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4205b285-f796-4086-bcf9-57b4b3940f0f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;ApplicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        IUserDAO userDao&lt;/span&gt;=(IUserDAO)factory.getBean(&quot;userDaoProxy&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
          userDao.transfer(&lt;/span&gt;1, 2, 100&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
        {
            System.out.println(&lt;/span&gt;&quot;事务回滚&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 05 Oct 2018 07:16:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>Spring的DAO模块提供了对JDBC、Hibernate、Mybatis等DAO层支持，本节介绍DAO模块对JDBC的支持。DAO模块依赖ommons-dbcp.jar、commons-pool.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9744729.html</dc:identifier>
</item>
<item>
<title>scrapydweb：实现 Scrapyd 服务器集群监控和交互，Scrapy 日志分析和可视化 - my8100</title>
<link>http://www.cnblogs.com/my8100/p/scrapydweb.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/my8100/p/scrapydweb.html</guid>
<description>&lt;div class=&quot;article-content&quot; data-v-13f76525=&quot;&quot; data-id=&quot;5bb60c7fe51d450e5e0c9bc5&quot; readability=&quot;36.695459579181&quot;&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;GitHub&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/my8100/scrapydweb&quot; target=&quot;_blank&quot;&gt;scrapydweb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎 Star 和提交 Issue&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;通过 pip 安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip &lt;span&gt;install&lt;/span&gt; scrapydweb
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;启动&lt;/h2&gt;
&lt;p&gt;通过命令行终端运行 &quot;scrapydweb -h&quot; 以查看帮助和选项. 第一次运行将在当前工作目录生成配置文件 &quot;scrapydweb_settings.py&quot;，可用于自定义 Scrapyd 服务器列表等选项.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
scrapydweb
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过浏览器访问 &lt;a href=&quot;http://127.0.0.1:5000/&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:5000&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;运行界面截图&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;集群监控和交互&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/overview.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;918&quot;/&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前节点任务列表&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/dashboard.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;918&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志分析&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;统计信息输出&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/log_stats.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;1050&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爬虫进度可视化&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/log_chart.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;1050&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键日志分类&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/log_extracted.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;1050&quot;/&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署项目&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/deploy.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;918&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行爬虫&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/run.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;1565&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管理项目&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/my8100/scrapydweb/master/screenshot/manage.png&quot; alt=&quot;&quot; width=&quot;1680&quot; height=&quot;918&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 05 Oct 2018 05:58:00 +0000</pubDate>
<dc:creator>my8100</dc:creator>
<og:description>功能特性 Scrapyd 服务器集群监控和交互 支持通过分组和过滤选中特定服务器节点 一次点击，批量执行 Scrapy 日志分析 统计信息展示 爬虫进度可视化 关键日志分类 支持所有 Scrapyd</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/my8100/p/scrapydweb.html</dc:identifier>
</item>
<item>
<title>朱晔和你聊Spring系列S1E5：Spring WebFlux小探 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/9744693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/9744693.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/lovecindywang/ZHUYE_Spring_S1E5.pdf&quot;&gt;阅读PDF版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文会来做一些应用对比Spring MVC和Spring WebFlux，观察线程模型的区别，然后做一下简单的压力测试。&lt;/p&gt;
&lt;h2 id=&quot;创建一个传统的spring-mvc应用&quot;&gt;创建一个传统的Spring MVC应用&lt;/h2&gt;
&lt;p&gt;先来创建一个新的webflux-mvc的模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;me.josephzhu&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring101-webflux-mvc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;spring101-webflux-mvc&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;me.josephzhu&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring101&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在项目里定义一个我们会使用到的POJO：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101webfluxmvc;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Document(collection = &quot;mydata&quot;)
public class MyData {
    @Id
    private String id;
    private String payload;
    private long time;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的@Document和@Id是为Mongodb服务的，我们定义了MyData将会以mydata作为Collection的名字，然后id字段是Document的Id列。&lt;br/&gt;然后我们来创建Controller，在这个Controller里面我们尝试三种不同的操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Sleep 100ms的纯获取数据的方法。从请求中获得length参数作为payload字符串的长度，从请求中获得size参数作为MyData的个数。我们在之后的测试过程中可以随意调节这两个参数来调整我们的数据量。&lt;/li&gt;
&lt;li&gt;从Mongodb获取数据的方法，获取到数据后直接返回。&lt;/li&gt;
&lt;li&gt;复合逻辑。先走HTTP请求从data方法获取数据，然后把数据保存进入Mongodb，最后返回这些数据。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101webfluxmvc;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@RestController
public class MyController {
    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private MyRepository myRepository;

    @GetMapping(&quot;/data&quot;)
    public List&amp;lt;MyData&amp;gt; getData(@RequestParam(value = &quot;size&quot;, defaultValue = &quot;10&quot;) int size,@RequestParam(value = &quot;length&quot;, defaultValue = &quot;100&quot;) int length) {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {

        }
        String payload = IntStream.rangeClosed(1,length).mapToObj(i-&amp;gt;&quot;a&quot;).collect(Collectors.joining());
        return IntStream.rangeClosed(1, size)
                .mapToObj(i-&amp;gt;new MyData(UUID.randomUUID().toString(), payload, System.currentTimeMillis()))
                .collect(Collectors.toList());
    }

    @GetMapping(&quot;/dbData&quot;)
    public List&amp;lt;MyData&amp;gt; getDbData() {
        return myRepository.findAll();
    }

    @GetMapping(&quot;/saveData&quot;)
    public List&amp;lt;MyData&amp;gt; saveData(@RequestParam(value = &quot;size&quot;, defaultValue = &quot;10&quot;) int size,@RequestParam(value = &quot;length&quot;, defaultValue = &quot;100&quot;) int length){
        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(&quot;http://localhost:8080/data&quot;)
                .queryParam(&quot;size&quot;, size)
                .queryParam(&quot;length&quot;, length);
        ResponseEntity&amp;lt;List&amp;lt;MyData&amp;gt;&amp;gt; responseEntity =
                restTemplate.exchange(builder.toUriString(),
                        HttpMethod.GET, null, new ParameterizedTypeReference&amp;lt;List&amp;lt;MyData&amp;gt;&amp;gt;() {});
        return responseEntity.getBody().stream().map(myRepository::save).collect(Collectors.toList());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，在这里我们使用了Java 8的Steam来做一些操作避免使用for循环：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过length参数构建payload（payload由length个字符a构成）。&lt;/li&gt;
&lt;li&gt;通过size参数构建MyData的List。&lt;/li&gt;
&lt;li&gt;在RestTemplate获取到MyData的List后，把每一个对象交由myRepository的save方法来处理，然后统一收集返回结果。&lt;br/&gt;这些Stream的代码都是同步处理，也不涉及外部IO，和非阻塞没有任何关系，只是方便代码编写。为了让代码可以运行，我们还需要继续来配置下Mongodb的Repository：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101webfluxmvc;

import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MyRepository extends MongoRepository&amp;lt;MyData, String&amp;gt; { }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们没有用到复杂的查询，在代码里只是用到了findAll方法，所以这里我们无需定义额外的方法，只是声明接口即可。&lt;br/&gt;最后，我们创建主应用程序，顺便配置一下Mongodb和RestTemplate：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101webfluxmvc;

import com.mongodb.MongoClientOptions;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@Configuration
public class Spring101WebfluxMvcApplication {

   @Bean
   MongoClientOptions mongoClientOptions(){
       return MongoClientOptions.builder().connectionsPerHost(1000).build();
   }

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }

    public static void main(String[] args) {
        SpringApplication.run(Spring101WebfluxMvcApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们配置了Mongodb客户端使得之后在进行压力测试的时候能有超过100个连接连接到Mongodb，否则会出现无法获取连接的问题。&lt;/p&gt;
&lt;h2 id=&quot;创建webflux版本的应用&quot;&gt;创建WebFlux版本的应用&lt;/h2&gt;
&lt;p&gt;现在我们再来新建一个webflux模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;me.josephzhu&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring101-webflux&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;spring101-webflux&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;me.josephzhu&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring101&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb-reactive&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;reactor-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以注意到，我们引入了webflux这个starter以及data-mongodb-reactive这个starter。在之前的Spring MVC项目中，我们引入的是mvc和data-mongodb两个starter。&lt;br/&gt;然后，我们同样需要创建一下MyData类（代码和之前一模一样，这里省略）。&lt;br/&gt;最关键的一步，我们来创建三个Controller方法的定义：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101webflux;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.springframework.web.reactive.function.server.ServerResponse.ok;

@Component
public class MyHandler {
    @Autowired
    private MyReactiveRepository myReactiveRepository;

    public Mono&amp;lt;ServerResponse&amp;gt; getData(ServerRequest serverRequest) {
        int size = Integer.parseInt(serverRequest.queryParam(&quot;size&quot;).orElse(&quot;10&quot;));
        int length = Integer.parseInt(serverRequest.queryParam(&quot;length&quot;).orElse(&quot;100&quot;));

        String payload = IntStream.rangeClosed(1,length).mapToObj(i-&amp;gt;&quot;a&quot;).collect(Collectors.joining());
        Flux&amp;lt;MyData&amp;gt; data = Flux.fromStream(IntStream.rangeClosed(1, size)
                .mapToObj(i-&amp;gt;new MyData(UUID.randomUUID().toString(), payload, System.currentTimeMillis()))).delaySequence(Duration.ofMillis(100));

        return ok()
                .contentType(MediaType.APPLICATION_JSON)
                .body(data, MyData.class);
    }

    public Mono&amp;lt;ServerResponse&amp;gt; getDbData(ServerRequest serverRequest) {
        Flux&amp;lt;MyData&amp;gt; data = myReactiveRepository.findAll();
        return ok()
                .contentType(MediaType.APPLICATION_JSON)
                .body(data, MyData.class);
    }

    public Mono&amp;lt;ServerResponse&amp;gt; saveData(ServerRequest serverRequest) {
        int size = Integer.parseInt(serverRequest.queryParam(&quot;size&quot;).orElse(&quot;10&quot;));
        int length = Integer.parseInt(serverRequest.queryParam(&quot;length&quot;).orElse(&quot;100&quot;));

        Flux&amp;lt;MyData&amp;gt; data = WebClient.create().get()
                .uri(builder -&amp;gt; builder
                        .scheme(&quot;http&quot;)
                        .host(&quot;localhost&quot;)
                        .port(8080)
                        .path(&quot;data&quot;)
                        .queryParam(&quot;size&quot;, size)
                        .queryParam(&quot;length&quot;, length)
                        .build())
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToFlux(MyData.class)
                .flatMap(myReactiveRepository::save);

        return ok()
                .contentType(MediaType.APPLICATION_JSON)
                .body(data, MyData.class);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要说明几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在WebFlux中，我们可以采用传统的@Controller方式来定义Controller，也可以采用函数式方式来声明对外的Endpoint，也就是声明Handler+Router。我们这里采用的是更有特色的后者来演示。&lt;/li&gt;
&lt;li&gt;请你比较一下三个方法的实现对于两个版本的区别。最主要的区别，我们返回的实际数据是Mono&amp;lt;&amp;gt;和Flux&amp;lt;&amp;gt;，分别代表0~1个对象和0~N对象的响应式流。&lt;/li&gt;
&lt;li&gt;在saveData方法中，对于Spring MVC我们使用的是阻塞的RestTemplate来从远端获取数据，对于Spring WebFlux我们使用的是非阻塞的WebClient来获取数据。获取数据后，我们直接使用flatMap获取到了所有的MyData转给我们的响应式的Mongodb Repository来处理数据。&lt;/li&gt;
&lt;li&gt;对于saveData方法中插入Mongodb的操作，这里和MVC的例子有很大的不同需要注意。在MVC中，我们把远程服务返回的结果转为Stream数据流，同步依次调用save方法，整个过程只会有占用一个Mongodb的连接。而在这里，直接对Flux流进行了Map，整个过程相当于并发进行了Mongodb的调用。在之后做压测的时候，我们会再次提到这点。&lt;br/&gt;刚才有提到，采用函数式声明对外的Endpoint的话除了定义Handler，还需要配置Router来和Handler关联，配置如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101webflux;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.ServerResponse;

import static org.springframework.web.reactive.function.server.RequestPredicates.GET;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

@Configuration
public class RouterConfig {
    @Autowired
    private MyHandler myHandler;

    @Bean
    public RouterFunction&amp;lt;ServerResponse&amp;gt; config() {
        return route(GET(&quot;/data&quot;), myHandler::getData)
                .andRoute(GET(&quot;/dbData&quot;), myHandler::getDbData)
                .andRoute(GET(&quot;/saveData&quot;), myHandler::saveData);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码没有太多需要说明，这里我们定义了三个GET请求（相当于MVC的@GetMapping），然后对应到注入的myHandler的三个方法上。&lt;br/&gt;然后我们还需要创建Mongodb的Repository：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package me.josephzhu.spring101webflux;

import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MyReactiveRepository extends ReactiveMongoRepository&amp;lt;MyData, String&amp;gt; { }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及配置和启动类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101webflux;

import com.mongodb.ConnectionString;
import com.mongodb.async.client.MongoClientSettings;
import com.mongodb.connection.ClusterSettings;
import com.mongodb.connection.ConnectionPoolSettings;
import com.mongodb.reactivestreams.client.MongoClient;
import com.mongodb.reactivestreams.client.MongoClients;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@SpringBootApplication
@Configuration
public class Spring101WebfluxApplication {

    @Bean
    MongoClient mongoClient(){
        return MongoClients.create(mongoClientSettings());
    }

    @Bean
    MongoClientSettings mongoClientSettings(){
        return MongoClientSettings.builder()
                .clusterSettings(ClusterSettings.builder().applyConnectionString(new ConnectionString(&quot;mongodb://localhost&quot;)).build())
                .connectionPoolSettings(ConnectionPoolSettings.builder().minSize(200).maxSize(1000).maxWaitQueueSize(1000000).build())
                .build();
    }

    public static void main(String[] args) {
        SpringApplication.run(Spring101WebfluxApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对Mongodb做了一些配置，主要也是希望放大连接池这块的默认限制，为今后的压测服务。注意，在这里配置的Bean是com.mongodb.reactivestream.client下的MongoClient，如下图所示，还有其它两个MongoClient，如果修改了不匹配的MongoClient的话是不会有作用的，我在这个坑里躺了两小时。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642abf8a9d577f?w=830&amp;amp;h=70&amp;amp;f=png&amp;amp;s=45181&quot;/&gt;&lt;br/&gt;完成后可以打开浏览器测试一下接口：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642abe9f4979d2?w=830&amp;amp;h=458&amp;amp;f=png&amp;amp;s=122606&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-mvc还是webflux&quot;&gt;Spring MVC还是WebFlux？&lt;/h2&gt;
&lt;p&gt;下图是官网的一个图说明了两者的关系，然后官网也给出了一些建议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果你现在的Spring MVC运行的没啥问题的话就别改了，有大量的类库可以使用，实现简单易于理解。&lt;/li&gt;
&lt;li&gt;如果你希望实现轻量级的，函数式Web框架，那么可以考虑WebFlux的函数Web端点。&lt;/li&gt;
&lt;li&gt;如果你依赖阻塞的持久化API比如JPA和JDBC那么也就只能选择Spring MVC了。目前对于非阻塞的JDBC实现有一些早期的项目在探索，但是没有到可以上生产的成熟度。&lt;/li&gt;
&lt;li&gt;在Spring MVC应用程序中进行远程调用也是可以使用响应式的WebClient的。Spring MVC也可以使用其它的响应式组件。每次调用延迟越厉害受益越大。&lt;/li&gt;
&lt;li&gt;对于大型应用程序要考虑到非阻塞方式实现的学习曲线。最简单的起步方式就是使用WebClient，完全切换到非阻塞需要花时间熟悉函数式声明式的编程API。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642ac76fdc96d8?w=432&amp;amp;h=243&amp;amp;f=png&amp;amp;s=57633&quot;/&gt;&lt;br/&gt;官方的意思也是可以在一些小引用上尝试WebFlux，对于大型应用不建议冒然转到WebFlux。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;观察线程模型&quot;&gt;观察线程模型&lt;/h2&gt;
&lt;p&gt;我们知道对于阻塞的实现方式，我们采用线程池来服务请求（线程池中的会维护一组普通的线程，线程池只是节省线程创建的时间），对于每一个请求的处理，至始至终都是在一个线程中进行，如果处理的过程中我们需要访问外部的网络或数据库，那么线程就处于阻塞状态，这个线程无法服务其它请求，如果当时还有更多的并发的话，就需要创建更多的线程来服务其它请求。这种实现方式是非常简单的，应对压力的增长扩容方式也是粗暴的，那就是增加更多线程。&lt;br/&gt;对于非阻塞的方式，采用的是EventLoop的方式，IO操作的时候是不占用工作线程的，因此只会创建一组和CPU核数相当的工作线程用于工作处理（NodeJS甚至是单线程的，这种就更危险了，就那么一个工作线程，一旦被长时间占用其它请求都无法处理）。由于整个处理过程中IO请求不占用线程时间，线程不会阻塞等待，再增加超过CPU核数的工作线程也是没有意义的（只会白白增加线程切换的开销）。对于这种方式在压力增长后，因为我们不需要增加额外的线程，也就没有了绝对的瓶颈。&lt;br/&gt;试想一下在阻塞模型下，对于5000的并发，而且每一个并发阻塞的时间非常长，那么我们其实需要5000个线程来服务（这么多线程99%其实都是在等待，属于空耗系统资源），创建5000的线程不谈其它的，如果线程栈大小是1M的话就需要5GB的内存。对于非阻塞的线程模型在8核机器上还是8个工作线程，内存占用还是这么小，可以以最小的开销应对大并发，系统的损耗很少。非阻塞的Reactive模式是内耗非常小的模式，但是这是有代价的，在实现上我们需要确保处理过程中没有阻塞产生，否则就会浪费宝贵的数目固定的工作线程，也就是说我们需要依赖配套的非阻塞IO类库来使用。&lt;br/&gt;在默认情况下tomcat的工作线程池初始化为10，最大200，我们通过启动本文创建的Spring101WebfluxMvcApplication程序，用jvisualvm工具来看下初始的情况（35个线程）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642ad89495a2b8?w=830&amp;amp;h=600&amp;amp;f=png&amp;amp;s=177165&quot;/&gt;&lt;br/&gt;在项目的application.properties文件中我们配置tomcat的最大线程数：&lt;br/&gt;server.tomcat.max-threads=250&lt;br/&gt;在压力的情况下，我们再来观察一下线程的情况（272个线程）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642add624c0640?w=830&amp;amp;h=598&amp;amp;f=png&amp;amp;s=178573&quot;/&gt;&lt;br/&gt;的确是创建多达250个工作线程。这里看到大部分线程都在休眠，因为我们这里运行的是刚才的data()方法，在方法内我们休眠了100毫秒。对于同样的压力，我们再来看一下Spring101WebfluxApplication程序的线程情况（44个线程）：&lt;br/&gt;可以看到用于处理HTTP的Reactor线程只有8个，和本机CPU核数量一致（下面有十个Thread打头的线程是处理和Mongodb交互的，忽略），只需要这8个线程处理HTTP请求足以，因为HTTP请求的IO处理不会占用线程。&lt;/p&gt;
&lt;h2 id=&quot;使用gatling进行压力测试&quot;&gt;使用Gatling进行压力测试&lt;/h2&gt;
&lt;p&gt;我们可以使用Gatling类库进行压力测试，我个人感觉比Jmeter方便。配置很简单，首先我们要安装Scala的SDK，然后我们新建一个模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;me.josephzhu&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring101-webstresstest&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;spring101-webstresstest&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.gatling.highcharts&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;gatling-charts-highcharts&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;io.gatling&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;gatling-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.2.4&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;simulationClass&amp;gt;me.josephzhu.spring101.webstresstest.StressTest&amp;lt;/simulationClass&amp;gt;
                    &amp;lt;resultsFolder&amp;gt;/Users/zyhome/gatling&amp;lt;/resultsFolder&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入了garling的maven插件，在这里配置了测试结果输出路径以及压测的类。接下去创建一下这个Scala测试类：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;package me.josephzhu.spring101.webstresstest

import io.gatling.core.Predef._
import io.gatling.core.scenario.Simulation
import io.gatling.http.Predef._

class StressTest extends Simulation {

  val scn = scenario(&quot;data&quot;).repeat(1000) {
    exec(
      http(&quot;data&quot;)
        .get(&quot;http://localhost:8080/data?size=10&amp;amp;length=1000&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .check(status.is(200)).check(substring(&quot;payload&quot;)))
  }

  setUp(scn.inject(atOnceUsers(200)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码定义了如下的测试行为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;声明一个data测试场景，重复进行1000次测试，发起一个远程调用，验证调用结果的响应状态码是200并且返回的结果包含字符串payload。&lt;/li&gt;
&lt;li&gt;测试启动的时候直接压上去200个用户，每一个用户运行完这1000次测试后结束了，所以这种方式一开始会是200用户到测试最后阶段用户数会慢慢减少。当然还有其它一些测试方式（比如慢慢递增用户的方式），详见官网：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    nothingFor(4 seconds), // 1
    atOnceUsers(10), // 2
    rampUsers(10) over (5 seconds), // 3
    constantUsersPerSec(20) during (15 seconds), // 4
    constantUsersPerSec(20) during (15 seconds) randomized, // 5
    rampUsersPerSec(10) to 20 during (10 minutes), // 6
    rampUsersPerSec(10) to 20 during (10 minutes) randomized, // 7
    splitUsers(1000) into (rampUsers(10) over (10 seconds)) separatedBy (10 seconds), // 8
    splitUsers(1000) into (rampUsers(10) over (10 seconds)) separatedBy atOnceUsers(30), // 9
    heavisideUsers(1000) over (20 seconds) // 10&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;压力测试一&quot;&gt;压力测试一&lt;/h2&gt;
&lt;p&gt;先来进行第一个测试，1000并发对data接口进行100次循环（还记得吗，接口有100ms休眠or延迟的）：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;class StressTest extends Simulation {

  val scn = scenario(&quot;data&quot;).repeat(100) {
    exec(
      http(&quot;mvc data&quot;)
        .get(&quot;http://localhost:8080/data?size=10&amp;amp;length=1000&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .check(status.is(200)).check(substring(&quot;payload&quot;)))
  }

  setUp(scn.inject(atOnceUsers(1000)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面两个图分别是MVC和WebFlux的测试结果（因为都是8080端口，所以测试的时候记得切换重启两个应用哦）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642af59a9d22c1?w=626&amp;amp;h=752&amp;amp;f=png&amp;amp;s=94358&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642af6dfa4fa92?w=606&amp;amp;h=756&amp;amp;f=png&amp;amp;s=103353&quot;/&gt;&lt;br/&gt;可以看到WebFlux的吞吐几乎是MVC的翻倍，平均响应时间少了两倍不止，很明显，在等待的时候，2000个并发用户大大超过了我们配置的250个线程池的线程数量，这个时候只能排队，对于非阻塞的方式，延迟是不会占用处理线程的，在延迟结束后才会去占用处理线程的资源进行处理，不会收到并发用户数受限于线程池线程数的情况。&lt;br/&gt;我们把Sleep相关代码注释再进行一次测试看看情况，分别是MVC和WebFlux：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642afb877ce57c?w=606&amp;amp;h=756&amp;amp;f=png&amp;amp;s=96836&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642afcbe668a10?w=606&amp;amp;h=756&amp;amp;f=png&amp;amp;s=101592&quot;/&gt;&lt;br/&gt;这个时候WebFlux优势没有那么明显了。&lt;/p&gt;
&lt;h2 id=&quot;性能测试二&quot;&gt;性能测试二&lt;/h2&gt;
&lt;p&gt;现在我们来访问一下http://localhost:8080/saveData?size=100&amp;amp;length=1000 接口往Mongodb来初始化100条数据，然后修改一下测试脚本压测dbData接口：&lt;br/&gt;class StressTest extends Simulation {&lt;/p&gt;
&lt;p&gt;val scn = scenario(&quot;data&quot;).repeat(100) {&lt;br/&gt;exec(&lt;br/&gt;http(&quot;data&quot;)&lt;br/&gt;.get(&quot;http://localhost:8080/dbData&quot;)&lt;br/&gt;.header(&quot;Content-Type&quot;, &quot;application/json&quot;)&lt;br/&gt;.check(status.is(200)).check(substring(&quot;payload&quot;)))&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;setUp(scn.inject(atOnceUsers(1000)))&lt;br/&gt;}&lt;br/&gt;下面看下这次的测试结果 ，分别是MVC和WebFlux：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b0813f66880?w=602&amp;amp;h=750&amp;amp;f=png&amp;amp;s=100050&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b094867b160?w=600&amp;amp;h=744&amp;amp;f=png&amp;amp;s=107578&quot;/&gt;&lt;br/&gt;吞吐量没有太多提高，平均响应时间快不少。&lt;/p&gt;
&lt;h2 id=&quot;性能测试三&quot;&gt;性能测试三&lt;/h2&gt;
&lt;p&gt;再来试一下第三个saveData接口的情况。修改测试代码：&lt;br/&gt;class StressTest extends Simulation {&lt;/p&gt;
&lt;p&gt;val scn = scenario(&quot;data&quot;).repeat(100) {&lt;br/&gt;exec(&lt;br/&gt;http(&quot;data&quot;)&lt;br/&gt;.get(&quot;http://localhost:8080/saveData?size=5&amp;amp;length=100000&quot;)&lt;br/&gt;.header(&quot;Content-Type&quot;, &quot;application/json&quot;)&lt;br/&gt;.check(status.is(200)).check(substring(&quot;payload&quot;)))&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;setUp(scn.inject(atOnceUsers(200)))&lt;br/&gt;}&lt;br/&gt;这里我们修改并发用户为200，每个用户进行100次测试，每次测试存入Mongodb 5条100KB的数据，一次测试后总数据量在10万条。这次测试我们并没有使用1000并发用户，原因是这个测试我们会先从远端获取数据然后再存入Mongodb，远端的服务也是来自于当前应用程序，我们的Tomcat最多只有250个线程，在启动1000个用户后，一些线程服务于saveData接口，一些线程服务于data接口（saveData接口用到的），这样相当于造成了循环依赖问题，请求在等待更多的可用线程执行服务data接口的响应，而这个时候线程又都被占了导致无法分配更多的请求，测试几乎全部超时。&lt;br/&gt;下面看下这次的测试结果 ，分别是MVC和WebFlux：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b0ecebb9eca?w=600&amp;amp;h=750&amp;amp;f=png&amp;amp;s=100836&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b1026dbe428?w=600&amp;amp;h=742&amp;amp;f=png&amp;amp;s=114296&quot;/&gt;&lt;br/&gt;WebFlux也是并发略高，性能略好的优势。对于响应时间的分布我们再来细看下下面的图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b11dacc54e0?w=830&amp;amp;h=328&amp;amp;f=png&amp;amp;s=138541&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b1303aa3725?w=830&amp;amp;h=328&amp;amp;f=png&amp;amp;s=127193&quot;/&gt;&lt;br/&gt;第一个图是MVC版本的响应时间分布，可以看到抖动比第二个图的WebFlux的大不少。&lt;br/&gt;最后来看看测试过程中MVC的JVM情况（263个线程）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b23efec4f1d?w=830&amp;amp;h=580&amp;amp;f=png&amp;amp;s=145570&quot;/&gt;&lt;br/&gt;以及WebFlux的（41线程）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16642b2579465d11?w=830&amp;amp;h=600&amp;amp;f=png&amp;amp;s=177476&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能测试四&quot;&gt;性能测试四：&lt;/h2&gt;
&lt;p&gt;我们来测试一下下面两种情况下对于WebFlux版本Mongodb侧的情况：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;class StressTest extends Simulation {

  val scn = scenario(&quot;data&quot;).repeat(1000) {
    exec(
      http(&quot;data&quot;)
        .get(&quot;http://localhost:8080/saveData?size=1&amp;amp;length=1000&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .check(status.is(200)).check(substring(&quot;payload&quot;)))
  }

  setUp(scn.inject(atOnceUsers(200)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;class StressTest extends Simulation {

  val scn = scenario(&quot;data&quot;).repeat(1000) {
    exec(
      http(&quot;data&quot;)
        .get(&quot;http://localhost:8080/saveData?size=5&amp;amp;length=1000&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .check(status.is(200)).check(substring(&quot;payload&quot;)))
  }

  setUp(scn.inject(atOnceUsers(200)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;区别就在远程服务返回的Flux是1个还是5个。在1个的时候运行测试可以看到我们Mongodb有64个连接（需要把之前连接池的配置最小设置为小一点，比如50）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; db.serverStatus().connections
{ &quot;current&quot; : 64, &quot;available&quot; : 3212, &quot;totalCreated&quot; : 8899 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在size为5的时候，Flux&lt;data&gt;返回的是5个对象，使用这个请求压测的时候Mongodb的连接数如下：&lt;/data&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;data&gt;&lt;code&gt;&amp;gt; db.serverStatus().connections
{ &quot;current&quot; : 583, &quot;available&quot; : 2693, &quot;totalCreated&quot; : 10226 }&lt;/code&gt;&lt;/data&gt;&lt;/pre&gt;
&lt;p&gt;&lt;data&gt;这是因为Flux拿到的数据直接以响应式进入Mongodb，并没有等到所有数据拿到之后串行调用方法。&lt;br/&gt;总结一下这几次的测试，我们发现WebFlux方式对于MVC方式能有略微的性能提升，对于请求阻塞的时候性能优势明显。我本金的测试并没有看到现象中的几倍甚至几十倍的性能提升，我猜原因如下：&lt;/data&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;data&gt;本机有性能瓶颈了，压测客户端、Mongodb服务器、服务端都在本机运行，干扰因素太多，CPU的使用你争我夺，测试不公平&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;&lt;data&gt;测试的时候CPU永远是100%还死机好几次，我根本无法测试更高的并发，无法完全把非阻塞的性能压出来&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;&lt;data&gt;我本机测试的时候走的是localhost而不是内网，不经过物理网卡，可能无法体现非阻塞的性能&lt;br/&gt;如果有条件可以使用三台独立服务器在内网进行1万以上并发用户的性能测试或许可以得到更科学的结果。&lt;/data&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;data&gt;总结&lt;/data&gt;&lt;/h2&gt;
&lt;p&gt;&lt;data&gt;本文我们创建了WebFlux和MVC两套应用对比演示了简单返回数据、发出远程请求、使用Mongodb等一些简单的应用场景，然后来看了一下ThreadPerRequest和EventLoop方式线程模型的区别，最后使用Gatling进行了几个Case的压力测试并且观察结果。我觉得：&lt;/data&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;data&gt;非阻塞模型肯定是好东西，在IO压力和IO延迟很大的情况下，非阻塞模型因为不需要更多的线程，内耗小，性能略好，而且也稳定，所以更利于高并发&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;&lt;data&gt;WebFlux的函数式和声明方式实现需要有很高的API熟悉使用门槛，对于复杂的逻辑这种方式的实现比回调地狱更容易绕晕，而且容易产生Bug（或许以后有可能响应式的编程在API上有可能和传统方式进行统一）&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;&lt;data&gt;目前和WebFlux配套的其它一些Reactive的库还不是很全面成熟，要对复杂的业务逻辑全面启用响应式编程有点难，阻塞调用不是不能在WebFlux中混用，但是这种方式还是采用了线程池来处理，现在容器也是NIO的了，有又多大区别&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;&lt;data&gt;采用阻塞方式实现，由阻塞的线程进行天然背压进行流控，非阻塞方式很直接一竿子到底，从外部请求直接到最底层存储，需要做好流控，这是非常容易产生问题的一个点，当请求的处理无需通过线程来承载的时候，前端压力会直通最底层数据源，不收任何扩容方面的限制，直接击溃底层&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;&lt;data&gt;对于阻塞的方式，多线程的调度天然就是一个任务的负载均衡，并不会出现太严重的卡死工作线程的问题，非阻塞应用编程我们要有意识代码在哪个线程上运行，如果是reactor线程的话千万不能长时间阻塞&lt;br/&gt;综上所述，使用WebFlux进行响应式编程我个人认为目前只适合做类IO转发的高并发的又看中资源使用效率的应用场景（比如Gateway网关服务），对于复杂的业务逻辑不太适合，在90%的情况下响应式的编程模型和线程模型不会享受大幅性能优势，更不建议盲目把现有的应用使用WebFlux来重写。当然，这肯定是一个会持续发展的方向，可以先接触研究起来。&lt;/data&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 05 Oct 2018 05:41:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/9744693.html</dc:identifier>
</item>
<item>
<title>Spring系列(七) Spring MVC 异常处理 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9744656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9744656.html</guid>
<description>&lt;h2 id=&quot;servlet传统异常处理&quot;&gt;Servlet传统异常处理&lt;/h2&gt;
&lt;p&gt;Servlet规范规定了当web应用发生异常时必须能够指明, 并确定了该如何处理, 规定了错误信息应该包含的内容和展示页面的方式.(详细可以参考servlet规范文档)&lt;/p&gt;
&lt;h3 id=&quot;处理方式&quot;/&gt;
&lt;ul&gt;&lt;li&gt;处理状态码&lt;code&gt;&amp;lt;error-code&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;处理异常信息&lt;code&gt;&amp;lt;exception-type&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;处理服务地址&lt;code&gt;&amp;lt;location&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-mvc-处理方式&quot;&gt;Spring MVC 处理方式&lt;/h2&gt;
&lt;p&gt;所有的请求必然以某种方式转化为响应.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring中特定的异常将自动映射为特定的HTTP状态码&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@ResponseStatus&lt;/code&gt;注解可以映射某一异常到特定的HTTP状态码&lt;/li&gt;
&lt;li&gt;Controller方法上可以使用&lt;code&gt;@ExceptionHandler&lt;/code&gt;注解使其用来处理异常&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@ControllerAdvice&lt;/code&gt; 方式可以统一的方式处理全局异常&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-boot-方式&quot;&gt;Spring boot 方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;实现ErrorPageRegistrar: 确定是页面处理的路径必须固定,优点是比较通用&lt;/li&gt;
&lt;li&gt;注册ErrorPage&lt;/li&gt;
&lt;li&gt;实现ErrorPage对应的服务&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;源码分析&quot;&gt;　源码分析&lt;/h2&gt;
&lt;p&gt;一．接口&lt;code&gt;HandlerExceptionResolver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该接口定义了Spring中该如何处理异常. 它只有一个方法&lt;code&gt;resolveException()&lt;/code&gt;, 接口源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; // 由对象实现的接口，这些对象可以解决在处理程序映射或执行期间引发的异常，在典型的情况下是错误视图。在应用程序上下文中，实现器通常被注册为bean。
 // 错误视图类似于JSP错误页面，但是可以与任何类型的异常一起使用，包括任何已检查的异常，以及针对特定处理程序的潜在细粒度映射。
public interface HandlerExceptionResolver {
    @Nullable
    ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring 为该接口提供了若干实现类如下:&lt;/p&gt;
&lt;pre&gt;
HandlerExceptionResolverComposite               委托给其他HandlerExceptionResolver的实例列表
AbstractHandlerExceptionResolver                抽象基类
    AbstractHandlerMethodExceptionResolver      支持HandlerMethod处理器的抽象基类
        ExceptionHandlerExceptionResolver       通过 @ExceptionHandler 注解的方式实现的异常处理
    DefaultHandlerExceptionResolver             默认实现, 处理spring预定义的异常并将其对应到错误码
    ResponseStatusExceptionResolver             通过 @ResponseStatus 注解映射到错误码的异常
    SimpleMappingExceptionResolver              允许将异常类映射到视图名
&lt;/pre&gt;
&lt;p&gt;二. &lt;code&gt;DefaultHandlerExceptionResolver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个类是Spring提供的默认实现, 用于将一些常见异常映射到特定的状态码. 这些状态码定义在接口&lt;code&gt;HttpServletResponse&lt;/code&gt;中, 下面是几个状态码的代码片段&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface HttpServletResponse extends ServletResponse {
    ...
    public static final int SC_OK = 200;
    public static final int SC_MOVED_PERMANENTLY = 301;
    public static final int SC_MOVED_TEMPORARILY = 302;
    public static final int SC_FOUND = 302;
    public static final int SC_UNAUTHORIZED = 401;
    public static final int SC_INTERNAL_SERVER_ERROR = 500;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上, &lt;code&gt;DefaultHandlerExceptionResolver&lt;/code&gt;中并没有直接实现接口的&lt;code&gt;resolveException&lt;/code&gt;方法, 而是实现了抽象类&lt;code&gt;AbstractHandlerExceptionResolver&lt;/code&gt;的&lt;code&gt;doResolveException()&lt;/code&gt;方法, 后者则在实现了接口的方法中委托给抽象方法&lt;code&gt;doResolveException&lt;/code&gt;, 这个方法由子类去实现.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractHandlerExceptionResolver&lt;/code&gt;的&lt;code&gt;resolveException&lt;/code&gt;方法代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
@Nullable
public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {

    // 判断是否当前解析器可用于handler
    if (shouldApplyTo(request, handler)) { 
        prepareResponse(ex, response);
        ModelAndView result = doResolveException(request, response, handler, ex);
        if (result != null) {
            // Print warn message when warn logger is not enabled...
            if (logger.isWarnEnabled() &amp;amp;&amp;amp; (this.warnLogger == null || !this.warnLogger.isWarnEnabled())) {
                logger.warn(&quot;Resolved [&quot; + ex + &quot;]&quot; + (result.isEmpty() ? &quot;&quot; : &quot; to &quot; + result));
            }
            // warnLogger with full stack trace (requires explicit config)
            logException(ex, request);
        }
        return result;
    }
    else {
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们看&lt;code&gt;DefaultHandlerExceptionResolver&lt;/code&gt;实现的&lt;code&gt;doResolveException&lt;/code&gt;方法. 代码如下;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    @Nullable
    protected ModelAndView doResolveException(
            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {

        try {
            if (ex instanceof HttpRequestMethodNotSupportedException) {
                return handleHttpRequestMethodNotSupported(
                        (HttpRequestMethodNotSupportedException) ex, request, response, handler);
            }
            else if (ex instanceof HttpMediaTypeNotSupportedException) {
                return handleHttpMediaTypeNotSupported(
                        (HttpMediaTypeNotSupportedException) ex, request, response, handler);
            }
            ....
            else if (ex instanceof NoHandlerFoundException) {
                return handleNoHandlerFoundException(
                        (NoHandlerFoundException) ex, request, response, handler);
            }
            .....
        }
        catch (Exception handlerEx) {
            if (logger.isWarnEnabled()) {
                logger.warn(&quot;Failure while trying to resolve exception [&quot; + ex.getClass().getName() + &quot;]&quot;, handlerEx);
            }
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到代码中使用了大量的分支语句, 实际上是将方法传入的异常类型通过instanceof运算符测试, 通过测试的转化为特定的异常. 并调用处理该异常的特定方法. 我们挑一个比如处理&lt;code&gt;NoHandlerFoundException&lt;/code&gt;这个异常类的方法, 这个方法将异常映射为404错误.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,
        HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {

    pageNotFoundLogger.warn(ex.getMessage());
    response.sendError(HttpServletResponse.SC_NOT_FOUND); //设置为404错误
    return new ModelAndView(); //返回个空视图
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面分析了Spring默认的异常处理实现类&lt;code&gt;DefaultHandlerExceptionResolver&lt;/code&gt;.它处理的异常是Spring预定义的几种常见异常, 它将异常对应到HTTP的状态码. 而对于不属于这些类型的其他异常, 我们可以使用&lt;code&gt;ResponseStatusExceptionResolver&lt;/code&gt;来处理, 将其对应到HTTP状态码.&lt;/p&gt;
&lt;p&gt;三. &lt;code&gt;ResponseStatusExceptionResolver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如何使用?&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;/responseStatus&quot;)
@ResponseBody
public String responseStatus() throws MyException {
    throw new MyException();
}

@ResponseStatus(code = HttpStatus.BAD_GATEWAY)
public class MyException extends Exception{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要在异常上使用&lt;code&gt;@ResponseStatus&lt;/code&gt;注解即可将特定的自定义异常对应到Http的状态码.&lt;/p&gt;
&lt;p&gt;四. &lt;code&gt;ExceptionHandlerExceptionResolver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用类似于普通的controller方法, 使用&lt;code&gt;@ExceptionHandler&lt;/code&gt;注解的方法将作为处理该注解参数中异常的handler. 比如, 在一个controller中, 我们定义一个处理NPE的异常处理handler方法, 可以用来处理该controller中抛出的NPE. 代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @GetMapping(&quot;/npe1&quot;)
@ResponseBody
public String npe1() throws NullPointerException {
    throw new NullPointerException();
}

@GetMapping(&quot;/npe2&quot;)
@ResponseBody
public String npe2() throws NullPointerException {
    throw new NullPointerException();
}

@ExceptionHandler(value = {NullPointerException.class})
@ResponseBody
public String npehandler(){
    return &quot;test npe handler&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论是请求/npe1还是请求/npe2, 系统都会抛出异常, 并交给对应的处理程序&lt;code&gt;npehandler&lt;/code&gt;去处理. 使用&lt;code&gt;@ExceptionHandler(value = {NullPointerException.class})&lt;/code&gt;注解的方法可以处理本controller范围内的所有方法排除的npe异常, 如果要将其作为应用中所有controller的异常处理器, 就要将其定义在&lt;code&gt;@ControllerAdvice&lt;/code&gt;注解的类中.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ControllerAdvice
public class ControllerAdvicer {

    @ExceptionHandler(value = {NullPointerException.class})
    @ResponseBody
    public String npehandler(){
        return &quot;test npe handler in advice&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要了解其原理, 需要查看&lt;code&gt;ExceptionHandlerExceptionResolver&lt;/code&gt;中的方法&lt;code&gt;doResolveHandlerMethodException&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
@Nullable
protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,
        HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) {
    
    // 获取异常对用的处理器, 就是@ExceptionHandler注解的方法包装, 注意参数handlerMethod, 在方法内部, 它将用来获取所在Controller的信息
    ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);
    if (exceptionHandlerMethod == null) {
        return null;
    }

    if (this.argumentResolvers != null) {
        exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
    }
    if (this.returnValueHandlers != null) {
        exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
    }

    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    ModelAndViewContainer mavContainer = new ModelAndViewContainer();

    try {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Invoking @ExceptionHandler method: &quot; + exceptionHandlerMethod);
        }
        Throwable cause = exception.getCause();
        // 调用异常处理handler的方法.
        if (cause != null) {
            // Expose cause as provided argument as well
            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);
        }
        else {
            // Otherwise, just the given exception as-is
            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);
        }
    }
    catch (Throwable invocationEx) {
        // Any other than the original exception is unintended here,
        // probably an accident (e.g. failed assertion or the like).
        if (invocationEx != exception &amp;amp;&amp;amp; logger.isWarnEnabled()) {
            logger.warn(&quot;Failed to invoke @ExceptionHandler method: &quot; + exceptionHandlerMethod, invocationEx);
        }
        // Continue with default processing of the original exception...
        return null;
    }

    if (mavContainer.isRequestHandled()) {
        return new ModelAndView();
    }
    else {
        ModelMap model = mavContainer.getModel();
        HttpStatus status = mavContainer.getStatus();
        ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status);
        mav.setViewName(mavContainer.getViewName());
        if (!mavContainer.isViewReference()) {
            mav.setView((View) mavContainer.getView());
        }
        if (model instanceof RedirectAttributes) {
            Map&amp;lt;String, ?&amp;gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
            RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
        }
        return mav;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在两个中文注释的地方, 其一是方法的开始部分获取到了异常的handler, 其二是调用这个handler的方法. 调用方法应该很好理解, 我们接下来查看方法&lt;code&gt;getExceptionHandlerMethod&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 找到给定异常对应的@ExceptionHandler注解方法, 默认先在controller类的继承结构中查找, 否则继续在@ControllerAdvice注解的 bean中查找.
@Nullable
protected ServletInvocableHandlerMethod getExceptionHandlerMethod(
        @Nullable HandlerMethod handlerMethod, Exception exception) {

    Class&amp;lt;?&amp;gt; handlerType = null;

    if (handlerMethod != null) {
        // Local exception handler methods on the controller class itself.
        // To be invoked through the proxy, even in case of an interface-based proxy.
        handlerType = handlerMethod.getBeanType();
        ExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(handlerType);
        if (resolver == null) {
            resolver = new ExceptionHandlerMethodResolver(handlerType);
            this.exceptionHandlerCache.put(handlerType, resolver);
        }
        Method method = resolver.resolveMethod(exception);
        if (method != null) {
            return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method);
        }
        // For advice applicability check below (involving base packages, assignable types
        // and annotation presence), use target class instead of interface-based proxy.
        if (Proxy.isProxyClass(handlerType)) {
            handlerType = AopUtils.getTargetClass(handlerMethod.getBean());
        }
    }

    // 在@ControllerAdvice注解的类中遍历查找
    for (Map.Entry&amp;lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&amp;gt; entry : this.exceptionHandlerAdviceCache.entrySet()) {
        ControllerAdviceBean advice = entry.getKey();
        if (advice.isApplicableToBeanType(handlerType)) {
            ExceptionHandlerMethodResolver resolver = entry.getValue();
            Method method = resolver.resolveMethod(exception);
            if (method != null) {
                return new ServletInvocableHandlerMethod(advice.resolveBean(), method);
            }
        }
    }

    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到,它会首先查找controller中的方法, 如果找不到才去查找@ControllerAdvice注解的bean. 也就是说controller中的handler的优先级要高于advice.&lt;/p&gt;
&lt;p&gt;上面我们了解了几个Exceptionresolver的使用, 并通过源代码简单看了他们各自处理的原理. 但这些Resolver如何加载我们还不知道, 接下来我们重点看下他们是如何加载进去的.&lt;/p&gt;
&lt;p&gt;四. ExceptionResolver的加载&lt;/p&gt;
&lt;p&gt;在本系列的上一篇&lt;a href=&quot;https://www.cnblogs.com/walkinhalo/p/9732125.html&quot;&gt;Spring系列(六) Spring Web MVC 应用构建分析&lt;/a&gt;中, 我们大致提到了DispatcherServlet的启动调用关系如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整理下调用关系&lt;/strong&gt;: &lt;code&gt;DispatcherServlet&lt;/code&gt; initHandlerMappings &amp;lt;-- initStrategies &amp;lt;-- onRefresh &amp;lt;--&lt;br/&gt;&lt;code&gt;FrameworkServlet&lt;/code&gt; initWebApplicationContext &amp;lt;-- initServletBean &amp;lt;--&lt;br/&gt;&lt;code&gt;HttpServletBean&lt;/code&gt; init &amp;lt;--&lt;br/&gt;&lt;code&gt;GenericServlet&lt;/code&gt; init(ServletConfig config)&lt;br/&gt;最后的&lt;code&gt;GenericServlet&lt;/code&gt;是servlet Api的.&lt;/p&gt;
&lt;p&gt;正是在&lt;code&gt;initStrategies&lt;/code&gt;方法中, &lt;code&gt;DispatcherServlet&lt;/code&gt;做了启动的一系列工作, 除了&lt;code&gt;initHandlerMappings&lt;/code&gt;还可以看到一个&lt;code&gt;initHandlerExceptionResolvers&lt;/code&gt;的方法, 其源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 初始化HandlerExceptionResolver, 如果没有找到任何命名空间中定义的bean, 默认没有任何resolver
private void initHandlerExceptionResolvers(ApplicationContext context) {
    this.handlerExceptionResolvers = null;

    if (this.detectAllHandlerExceptionResolvers) {
        // 找到所有ApplicationContext中定义的 HandlerExceptionResolvers 包括在上级上下文中.
        Map&amp;lt;String, HandlerExceptionResolver&amp;gt; matchingBeans = BeanFactoryUtils
                .beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);
        if (!matchingBeans.isEmpty()) {
            this.handlerExceptionResolvers = new ArrayList&amp;lt;&amp;gt;(matchingBeans.values());
            // 保持有序.
            AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);
        }
    }
    else {
        try {
            HandlerExceptionResolver her =
                    context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);
            this.handlerExceptionResolvers = Collections.singletonList(her);
        }
        catch (NoSuchBeanDefinitionException ex) {
            // Ignore, no HandlerExceptionResolver is fine too.
        }
    }

    // 确保有Resolver, 否则使用默认的
    if (this.handlerExceptionResolvers == null) {
        this.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;No HandlerExceptionResolvers declared in servlet '&quot; + getServletName() +
                    &quot;': using default strategies from DispatcherServlet.properties&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了, 现在我们加载了应用程序中所有定义的Resolver. 当有请求到达时, &lt;code&gt;DispatcherServlet&lt;/code&gt;的&lt;code&gt;doDispatch&lt;/code&gt;方法使用请求特定的handler处理, 当handler发生异常时, 变量&lt;code&gt;dispatchException&lt;/code&gt;的值赋值为抛出的异常, 并委托给方法&lt;code&gt;processDispatchResult&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;doDispatch的代码, 只摘录出与本议题有关的.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    ....
    try {
        ModelAndView mv = null;
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    }catch (Exception ex) {
        dispatchException = ex;
    }
    catch (Throwable err) {
        // As of 4.3, we're processing Errors thrown from handler methods as well,
        // making them available for @ExceptionHandler methods and other scenarios.
        dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
    }
    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    ....
}

// 处理handler的结果
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
        @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
        @Nullable Exception exception) throws Exception {

    boolean errorView = false;

    // 异常处理
    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

    // handler是否返回了view
    if (mv != null &amp;amp;&amp;amp; !mv.wasCleared()) {
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);
        }
    }

    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        // Concurrent handling started during a forward
        return;
    }

    if (mappedHandler != null) {
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;processDispatchResult&lt;/code&gt;方法中可以看到, 如果参数&lt;code&gt;exception&lt;/code&gt;不为null, 则会处理异常, 对于&lt;code&gt;ModelAndViewDefiningException&lt;/code&gt;类型的异常单独处理, 对于其他类型的异常, 转交给&lt;code&gt;processHandlerException&lt;/code&gt;方法处理, 这个方法就是异常处理逻辑的核心.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Nullable
protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
        @Nullable Object handler, Exception ex) throws Exception {

    // Success and error responses may use different content types
    request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);

    // 使用注册的Resolver处理
    ModelAndView exMv = null;
    if (this.handlerExceptionResolvers != null) {
        for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {
            exMv = resolver.resolveException(request, response, handler, ex);
            if (exMv != null) {
                break;
            }
        }
    }
    if (exMv != null) {
        if (exMv.isEmpty()) {
            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
            return null;
        }
        // We might still need view name translation for a plain error model...
        if (!exMv.hasView()) {
            String defaultViewName = getDefaultViewName(request);
            if (defaultViewName != null) {
                exMv.setViewName(defaultViewName);
            }
        }
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Using resolved error view: &quot; + exMv, ex);
        }
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Using resolved error view: &quot; + exMv);
        }
        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
        return exMv;
    }

    throw ex;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码可以看到, &lt;code&gt;this.handlerExceptionResolvers&lt;/code&gt;就是在程序启动时初始化注册的, spring通过遍历Resolver列表的方式处理异常, 如果返回结果不为null, 说明处理成功, 就跳出循环.&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Spring的异常解析器实现全部继承自接口&lt;code&gt;ResponseStatusExceptionResolver&lt;/code&gt;, 上面我们详细了解了该接口在Spring中的几种实现, 比如处理预定义异常的&lt;code&gt;DefaultHandlerExceptionResolver&lt;/code&gt;, 可以映射异常到状态码的&lt;code&gt;ResponseStatusExceptionResolver&lt;/code&gt;, 还有功能更为强大的&lt;code&gt;ExceptionHandlerExceptionResolver&lt;/code&gt;. 同时也简单了解了其使用方式,使用&lt;code&gt;@ExceptionHandler&lt;/code&gt;来将方法标记为异常处理器, 结合&lt;code&gt;@ControllerAdvice&lt;/code&gt;处理全局异常.&lt;/p&gt;
&lt;p&gt;最后我们探究了异常处理器的加载和处理方式, 我们知道了其通过 &lt;code&gt;DispatcherServlet&lt;/code&gt; 的初始化方法&lt;code&gt;initHandlerMappings&lt;/code&gt;完成加载器列表的注册初始化, 并且在具体处理请求的&lt;code&gt;doDispatch&lt;/code&gt;中检测异常, 最终&lt;code&gt;processDispatchResult&lt;/code&gt;方法委托给&lt;code&gt;processHandlerException&lt;/code&gt;, 该方法循环注册的异常处理器列表完成处理过程.&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 05:16:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>Servlet传统异常处理 Servlet规范规定了当web应用发生异常时必须能够指明, 并确定了该如何处理, 规定了错误信息应该包含的内容和展示页面的方式.(详细可以参考servlet规范文档) 处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9744656.html</dc:identifier>
</item>
<item>
<title>重构后端模板文件的一种实践 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9744640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9744640.html</guid>
<description>&lt;h3&gt;后端的动态模板&lt;/h3&gt;
&lt;p&gt;Java后端通常会使用&lt;code&gt;ftl&lt;/code&gt;（freemarker template language）模板文件来动态返回前端页面。这个工作，通常还可以用&lt;code&gt;jsp&lt;/code&gt;、&lt;code&gt;php&lt;/code&gt;文件来实现。但这些动态模板的实现，通常是在已有的html文件上对特定的、需要做动态处理的部分做改写。这对小项目来讲没什么不对。可如果你的页面数量足够多，维护它们将成为一件异常困难的事情。&lt;/p&gt;

&lt;h3&gt;Nodejs大前端技术&lt;/h3&gt;
&lt;p&gt;在目前的大前端技术栈下，Nodejs的各种框架让前端开发变得规矩不少：传统前端的html+css+js的技术栈的最大问题在于其模块化、组织能力像是一个教学语言，应有的语句控制和代码复用的技术，都显得苍白无力。&lt;/p&gt;
&lt;p&gt;就html的编写来讲，几乎不存在一种类似函数的复用方式，能够简化重复的UI component的生成。你只能不断地去写一些重复的、杂乱的代码。整体上来讲，这不仅难以做后期的维护，也无法轻易地看懂其间的代码逻辑。&lt;/p&gt;
&lt;p&gt;一句话来讲，这些代码非常类似于机器代码或者汇编代码。没有高级语言的精准控制和抽象层去对代码做宏观把控。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pugjs&lt;/code&gt;是一个很好的html预处理项目。它的基本想法是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不要去直接编写“底层”的html代码，而是用自己定义的一套语法去编写&lt;code&gt;pug&lt;/code&gt;文件。通过这个&lt;code&gt;pug&lt;/code&gt;文件去生成出html代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特别地，在它的语法中，你不必再写一大堆的尖括号和与前后呼应的tag。如同Python，仅仅依靠代码的对齐方式，就可以自动识别相应的作用域范围。例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div&amp;gt; 
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt; First tip &amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt; Second tip &amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt; Third tip &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样语义简单、语法繁琐的一堆代码，在&lt;code&gt;pug&lt;/code&gt;下可以简化为&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
div
    ul
        li First tip
        li Second tip
        li Third tip
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但这还不是最诱人的技术，因为这无非是加入了一些语法糖。最为诱人的是&lt;code&gt;pug&lt;/code&gt;提供的函数，它能够定义一个函数去生成某个组件。&lt;/p&gt;
&lt;p&gt;例如，如果你需要定义一组&lt;code&gt;table&lt;/code&gt;，每个&lt;code&gt;table&lt;/code&gt;仅仅是表头或者其中一部分的数据不一样，你该如何处理？传统的方式当然是复制粘贴一堆模板代码，然后一个个地去修改里面的数据。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;pug&lt;/code&gt;的处理方式就要好太多，完全符合将数据和代码分离的思想。定义函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
mixin leftbox-gen(dataObj)
        table.table
            thead
                tr
                    th(scope=&quot;col&quot;) #{dataObj.title}
            tbody
                each area in dataObj.areas
                    tr
                        td
                            .box-title #{area.name}
                            ul
                                each subarea in area.subareas
                                    li
                                        a(id=subarea.id, href=subarea.url) #{subarea.name}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样就可以根据通过定义&lt;code&gt;json&lt;/code&gt;格式的&lt;code&gt;dataObj&lt;/code&gt;去引用函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
+leftbox-gen(cs_leftbox_data)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你通过不同的&lt;code&gt;json&lt;/code&gt;数据，就能够生成不同的&lt;code&gt;table&lt;/code&gt;出来。这就实现了代码的模块化和以及数据和业务代码的分离。要做出新的&lt;code&gt;table&lt;/code&gt; component，你只需要改变数据就可以了。&lt;/p&gt;
&lt;p&gt;这样的实现方式在别的高级语言中是很常见的，但是在传统的前端代码中，这常常难以见到。原因就在于，html代码更像是没有抽象层的机器代码，只是一大堆的实际操作，而缺少抽象层的高效管理。&lt;/p&gt;

&lt;h3&gt;前端预处理和后端动态模板的结合&lt;/h3&gt;
&lt;p&gt;像&lt;code&gt;pug&lt;/code&gt;这样优秀的工具，如果能够用来管理后端的&lt;code&gt;ftl&lt;/code&gt;模板当然会相当合适。优秀的语法糖、代码模块化、数据和业务逻辑的分离，实在是相当诱人的选择。&lt;/p&gt;
&lt;p&gt;但这样的理念真要实施在生产代码中，特别是用来重构已有的legacy code时，就不大容易了。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;pug&lt;/code&gt;只能生成html代码，且生成出来的位置通常是在一个统一的地方。可&lt;code&gt;ftl&lt;/code&gt;代码却分散在各个不同Java工程的不同目录之下。这两者很难统一到一起。&lt;/p&gt;
&lt;p&gt;或许一个直接的想法是，不如直接把所有的&lt;code&gt;ftl&lt;/code&gt;都放到一个地方，这样就不用把模板语言分散到各个不同项目的不同文件夹里，而难以维护。&lt;/p&gt;
&lt;p&gt;但这种方案带来的一个麻烦是，如果真的把后端的&lt;code&gt;ftl&lt;/code&gt;文件挪动了位置，那么后端代码的接口部分就不得不做修改。而这样的接口部分其数量并不少。既要做出大量的修改，还要保证它们的正确性，并不是一件轻松的事情。&lt;/p&gt;
&lt;p&gt;经过大量的思考和尝试得出的一个解决方案是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用&lt;code&gt;Pugjs&lt;/code&gt;生成出统一的&lt;code&gt;ftl&lt;/code&gt;文件，放在同一个公共资源文件夹下。让每一个具体项目下的&lt;code&gt;ftl&lt;/code&gt;文件中，直接&lt;code&gt;include&lt;/code&gt;这个公共资源文件夹中&lt;code&gt;ftl&lt;/code&gt;内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种做法的一个精妙之处是：它将&lt;code&gt;ftl&lt;/code&gt;文件当作函数接口来使用。后端Java代码调用&lt;code&gt;ftl&lt;/code&gt;文件可以看作是函数调用。而函数实现并不需要直接放在这个&lt;code&gt;ftl&lt;/code&gt;文件里，而是可以放在别的地方做引用。这就把实现和调用部分，通过一个单独的文件分离开了。&lt;/p&gt;
&lt;p&gt;这里虽然处理的是后端模板文件和前端的一个结合，但其思想可以利用在别的地方。如果一个模板文件具备了&lt;code&gt;include&lt;/code&gt;功能，便可以把模板文件本身当作接口，从而将实现与定义分离。&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484542&amp;amp;idx=1&amp;amp;sn=fa2de4fe6a1ebefef07717db97013c6d&amp;amp;chksm=ec20e3c2db576ad46ef5481aa3e6e17b999c710171802a875500e1759243426740047ca9ed01&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;为什么程序员需要知道互联网行业发展史&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484537&amp;amp;idx=1&amp;amp;sn=d1d63e7ea9c7c637e37da2cfdb473a1b&amp;amp;chksm=ec20e3c5db576ad36ebaa14b8a6e31eb5de31bf668411b607eaa1ff579c4eb2c22cde5d35e00&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;是大家突然变low了吗？&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484529&amp;amp;idx=1&amp;amp;sn=fe3fc746cd5e7487e2285dc99b3b5335&amp;amp;chksm=ec20e3cddb576adba9051c4f1b235ecea46ab4f42370667dc9e8befe46c4513e1bbc7b6a1ae2&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;至暗时刻&lt;/a&gt;》&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181005130101704-1439873035.jpg&quot; alt=&quot;&quot; width=&quot;654&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181005130136938-1123827792.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 05:04:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<og:description>后端的动态模板 Java后端通常会使用ftl（freemarker template language）模板文件来动态返回前端页面。这个工作，通常还可以用jsp、php文件来实现。但这些动态模板的实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9744640.html</dc:identifier>
</item>
<item>
<title>c语言数字图像处理（五）：空间滤波 - GoleBeetle</title>
<link>http://www.cnblogs.com/GoldBeetle/p/9744625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GoldBeetle/p/9744625.html</guid>
<description>&lt;h2&gt; 空间滤波原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005111634112-131209416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用大小为m*n的滤波器对大小为M*N的图像进行线性空间滤波，将滤波器模板乘以图像中对应灰度值，相加得模板中心灰度值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005112224539-1605803061.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                             a = (m-1)/2, b = (n-1)/2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若f(x+s, y+t)不在原图内，补0&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;平滑线性滤波器&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;滤波过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005113710064-1366573803.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分母为滤波器模板和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; is_in_array(&lt;span&gt;short&lt;/span&gt; x, &lt;span&gt;short&lt;/span&gt; y, &lt;span&gt;short&lt;/span&gt; height, &lt;span&gt;short&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; x &amp;lt; width &amp;amp;&amp;amp; y &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; y &amp;lt;&lt;span&gt; height)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * element
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * v0  v1  v2
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * v3  v4  v5
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * v6  v7  v8
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; filtering(&lt;span&gt;short&lt;/span&gt;** in_array, &lt;span&gt;short&lt;/span&gt;** out_array, &lt;span&gt;long&lt;/span&gt; height, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;short&lt;/span&gt; value[&lt;span&gt;9&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; linear filtering &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;short&lt;/span&gt;&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ARRAY_SIZE; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; ARRAY_SIZE; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;              sum +=&lt;span&gt; average[i][j];
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             value[&lt;span&gt;0&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             value[&lt;span&gt;1&lt;/span&gt;] = is_in_array(j, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             value[&lt;span&gt;2&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             value[&lt;span&gt;3&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             value[&lt;span&gt;4&lt;/span&gt;] =&lt;span&gt; in_array[i][j];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             value[&lt;span&gt;5&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             value[&lt;span&gt;6&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             value[&lt;span&gt;7&lt;/span&gt;] = is_in_array(j, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             value[&lt;span&gt;8&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; linear filtering &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;              out_array[i][j] = (value[&lt;span&gt;0&lt;/span&gt;] * average[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;1&lt;/span&gt;] * average[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;2&lt;/span&gt;] * average[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;40&lt;/span&gt;                                 value[&lt;span&gt;3&lt;/span&gt;] * average[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;4&lt;/span&gt;] * average[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;5&lt;/span&gt;] * average[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;41&lt;/span&gt;                                 value[&lt;span&gt;6&lt;/span&gt;] * average[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;7&lt;/span&gt;] * average[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;8&lt;/span&gt;] * average[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;]) /&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005113142092-1673940996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005113212585-757942272.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005113302310-340649240.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出线性滤波器会较大程度地影响原图，降低对比度，对与图片右上角的噪声没有明显的去除效果&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;统计排序（非线性）滤波器&lt;/h2&gt;
&lt;h3&gt; 中值滤波器&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;中值滤波器对处理脉冲噪声非常有效，这种噪声被称为椒盐噪声&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现方法：取该像素某邻域中值（本次测试取3*3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;short&lt;/span&gt; mid_val(&lt;span&gt;short&lt;/span&gt;* a, &lt;span&gt;short&lt;/span&gt;&lt;span&gt; num)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;short&lt;/span&gt;&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         temp =&lt;span&gt; a[i];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (; j &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; a[j - &lt;span&gt;1&lt;/span&gt;] &amp;gt; temp; j--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             a[j] = a[j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         a[j] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a[num/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; is_in_array(&lt;span&gt;short&lt;/span&gt; x, &lt;span&gt;short&lt;/span&gt; y, &lt;span&gt;short&lt;/span&gt; height, &lt;span&gt;short&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; x &amp;lt; width &amp;amp;&amp;amp; y &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; y &amp;lt;&lt;span&gt; height)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt; * element
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt; * v0  v1  v2
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt; * v3  v4  v5
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt; * v6  v7  v8
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; filtering(&lt;span&gt;short&lt;/span&gt;** in_array, &lt;span&gt;short&lt;/span&gt;** out_array, &lt;span&gt;long&lt;/span&gt; height, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;short&lt;/span&gt; value[&lt;span&gt;9&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             value[&lt;span&gt;0&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             value[&lt;span&gt;1&lt;/span&gt;] = is_in_array(j, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             value[&lt;span&gt;2&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             value[&lt;span&gt;3&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             value[&lt;span&gt;4&lt;/span&gt;] =&lt;span&gt; in_array[i][j];
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             value[&lt;span&gt;5&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             value[&lt;span&gt;6&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             value[&lt;span&gt;7&lt;/span&gt;] = is_in_array(j, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             value[&lt;span&gt;8&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; median filtering &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             out_array[i][j] = mid_val(value, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005114112867-1833190411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;锐化空间滤波器&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一阶微分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005122730645-1871395317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二阶微分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005122818362-1952915273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二阶微分在增强细节方面比一阶微分好很多，适合锐化图像&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;使用二阶微分进行图像锐化-拉普拉斯算子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005122936817-1578500708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; is_in_array(&lt;span&gt;short&lt;/span&gt; x, &lt;span&gt;short&lt;/span&gt; y, &lt;span&gt;short&lt;/span&gt; height, &lt;span&gt;short&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; x &amp;lt; width &amp;amp;&amp;amp; y &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; y &amp;lt;&lt;span&gt; height)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * element
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * v0  v1  v2
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * v3  v4  v5
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * v6  v7  v8
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; filtering(&lt;span&gt;short&lt;/span&gt;** in_array, &lt;span&gt;short&lt;/span&gt;** out_array, &lt;span&gt;long&lt;/span&gt; height, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;short&lt;/span&gt; value[&lt;span&gt;9&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             value[&lt;span&gt;0&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             value[&lt;span&gt;1&lt;/span&gt;] = is_in_array(j, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             value[&lt;span&gt;2&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             value[&lt;span&gt;3&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             value[&lt;span&gt;4&lt;/span&gt;] =&lt;span&gt; in_array[i][j];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             value[&lt;span&gt;5&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             value[&lt;span&gt;6&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             value[&lt;span&gt;7&lt;/span&gt;] = is_in_array(j, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             value[&lt;span&gt;8&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; sharpening filtering &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             out_array[i][j] = value[&lt;span&gt;0&lt;/span&gt;] * sharpen[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;1&lt;/span&gt;] * sharpen[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;2&lt;/span&gt;] * sharpen[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;34&lt;/span&gt;                               value[&lt;span&gt;3&lt;/span&gt;] * sharpen[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;4&lt;/span&gt;] * sharpen[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;5&lt;/span&gt;] * sharpen[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;35&lt;/span&gt;                               value[&lt;span&gt;6&lt;/span&gt;] * sharpen[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;7&lt;/span&gt;] * sharpen[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;8&lt;/span&gt;] * sharpen[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             out_array[i][j] +=&lt;span&gt; in_array[i][j];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;原图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005124606398-2131076792.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;锐化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005124643361-1297540318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用一阶微分对（非线性）图像锐化-梯度&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;实现边缘增强&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005124906152-1182784787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; is_in_array(&lt;span&gt;short&lt;/span&gt; x, &lt;span&gt;short&lt;/span&gt; y, &lt;span&gt;short&lt;/span&gt; height, &lt;span&gt;short&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; x &amp;lt; width &amp;amp;&amp;amp; y &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; y &amp;lt;&lt;span&gt; height)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * element
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * v0  v1  v2
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * v3  v4  v5
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * v6  v7  v8
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; filtering(&lt;span&gt;short&lt;/span&gt;** in_array, &lt;span&gt;short&lt;/span&gt;** out_array, &lt;span&gt;long&lt;/span&gt; height, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;short&lt;/span&gt; value[&lt;span&gt;9&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             value[&lt;span&gt;0&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             value[&lt;span&gt;1&lt;/span&gt;] = is_in_array(j, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             value[&lt;span&gt;2&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i-&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             value[&lt;span&gt;3&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             value[&lt;span&gt;4&lt;/span&gt;] =&lt;span&gt; in_array[i][j];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             value[&lt;span&gt;5&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i, height, width) ? in_array[i][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             value[&lt;span&gt;6&lt;/span&gt;] = is_in_array(j-&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             value[&lt;span&gt;7&lt;/span&gt;] = is_in_array(j, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             value[&lt;span&gt;8&lt;/span&gt;] = is_in_array(j+&lt;span&gt;1&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;, height, width) ? in_array[i+&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; sharpening using grad &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             out_array[i][j] = (&lt;span&gt;short&lt;/span&gt;)abs(value[&lt;span&gt;0&lt;/span&gt;] * soble1[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;1&lt;/span&gt;] * soble1[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;2&lt;/span&gt;] * soble1[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;34&lt;/span&gt;                                          value[&lt;span&gt;3&lt;/span&gt;] * soble1[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;4&lt;/span&gt;] * soble1[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;5&lt;/span&gt;] * soble1[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;35&lt;/span&gt;                                          value[&lt;span&gt;6&lt;/span&gt;] * soble1[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;7&lt;/span&gt;] * soble1[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;8&lt;/span&gt;] * soble1[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;]) + 
&lt;span&gt;36&lt;/span&gt;                               (&lt;span&gt;short&lt;/span&gt;)abs(value[&lt;span&gt;0&lt;/span&gt;] * soble2[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;1&lt;/span&gt;] * soble2[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;2&lt;/span&gt;] * soble2[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;37&lt;/span&gt;                                          value[&lt;span&gt;3&lt;/span&gt;] * soble2[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;4&lt;/span&gt;] * soble2[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;5&lt;/span&gt;] * soble2[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;] +
&lt;span&gt;38&lt;/span&gt;                                          value[&lt;span&gt;6&lt;/span&gt;] * soble2[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] + value[&lt;span&gt;7&lt;/span&gt;] * soble2[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;] + value[&lt;span&gt;8&lt;/span&gt;] * soble2[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;原图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005125152716-1002156878.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;边缘图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005125231781-1046953865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;边缘图与原图相加可得边缘增强后的图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181005133404749-617236159.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 05 Oct 2018 04:54:00 +0000</pubDate>
<dc:creator>GoleBeetle</dc:creator>
<og:description>空间滤波原理 使用大小为m*n的滤波器对大小为M*N的图像进行线性空间滤波，将滤波器模板乘以图像中对应灰度值，相加得模板中心灰度值 a = (m-1)/2, b = (n-1)/2 若f(x+s, y</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GoldBeetle/p/9744625.html</dc:identifier>
</item>
<item>
<title>MyBatis(1)优点&amp;介绍&amp;工程 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9744522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9744522.html</guid>
<description>&lt;pre&gt;
insert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,'台式机',3000.0,'该电脑质量非常好！！！！',NULL,'2015-02-03 13:22:53'),(2,'笔记本',6000.0,'笔记本性能好，质量好！！！！！',NULL,'2015-02-09 13:22:57'),(3,'背包',200.0,'名牌背包，容量大质量好！！！！',NULL,'2015-02-06 13:23:02'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Data for the table `orderdetail` &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

insert  into `orderdetail`(`id`,`orders_id`,`items_id`,`items_num`) values (&lt;/span&gt;1,3,1,1),(2,3,2,3),(3,4,3,4),(4,4,2,3&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Data for the table `orders` &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

insert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (&lt;/span&gt;3,1,'1000010','2015-02-04 13:22:35',NULL),(4,1,'1000011','2015-02-03 13:22:41',NULL),(5,10,'1000012','2015-02-12 16:13:23'&lt;span&gt;,NULL);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Data for the table `user` &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (&lt;/span&gt;1,'王五',NULL,'2',NULL),(10,'张三','2014-07-10','1','北京市'),(16,'张小明',NULL,'1','河南郑州'),(22,'陈小明',NULL,'1','河南郑州'),(24,'张三丰',NULL,'1','河南郑州'),(25,'陈小明',NULL,'1','河南郑州'),(26,'王五',NULL,NULL,NULL);
&lt;/pre&gt;</description>
<pubDate>Fri, 05 Oct 2018 03:53:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>本次全部学习内容：MyBatisLearning 一：jabc的相关说明： jdbc编程步骤： 加载数据库驱动 创建并获取数据库链接 创建jdbc statement对象 设置sql语句 设置sql语</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9744522.html</dc:identifier>
</item>
<item>
<title>深度学习论文翻译解析（一）：YOLOv3: An Incremental Improvement - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9744146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9744146.html</guid>
<description>&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;原标题： YOLOv3: An Incremental Improvement&lt;/p&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;原作者： Joseph Redmon Ali Farhadi&lt;/p&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;YOLO官网：&lt;span&gt;&lt;a class=&quot;Link&quot; href=&quot;https://pjreddie.com/darknet/yolo/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;YOLO: Real-Time Object Detection&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;&lt;span&gt; https://pjreddie.com/darknet/yolo/&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;论文链接：&lt;span&gt;&lt;a class=&quot;Link&quot; href=&quot;https://pjreddie.com/media/files/papers/YOLOv3.pdf&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pjreddie.com/media/files/papers/YOLOv3.pdf&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;YOLOv3论文地址：&lt;a href=&quot;https://arxiv.org/abs/1804.02767&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/abs/1804.02767&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;            小编是一个机器学习初学者，打算认真研究论文，但是英文水平有限，所以论文翻译中用到了Google，并自己逐句检查过，但还是会有显得晦涩的地方，如有语法/专业名词翻译错误，还请见谅，并欢迎及时指出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005094657369-199677023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;摘要&lt;/h3&gt;
&lt;p&gt;　　我们为YOLO提供了一系列更新！它包含一堆小设计，可以是系统的性能得到更新；也包含一个新训练的，非常好的神经网络。虽然比上一版更大一些，但是精度也提高了。不用担心，虽然体量大了，它的速度还是有保障的。在输入320×320的图片后，YOLOv3能在22毫秒内完成处理，并取得28.2mAP的成绩。它的精度和SSD相当，但速度要快上3倍。和旧版数据相比，v3版进步明显。在Titan X环境下，YOLOv3的检测精度为57.9 AP50，用时51ms；而RetinaNet的精度只有57.5 AP50，但却需要198ms，相当于YOLOv3的3.8倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005095435090-384464714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;一，引言&lt;/h3&gt;
&lt;div class=&quot;Editable-unstyled&quot; readability=&quot;10&quot;&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;    有时候，一年你主要只是在玩手机，你知道吗？今年我没有做很多研究。我在Twitter上花了很多时间。玩了一下GAN。去年我留下了一点点的精力[12] [1]；我设法对YOLO进行了一些改进。但是诚然，没有什么比这超级有趣的了，只是一小堆（bunch）改变使它变得更好。我也帮助了其他人的做一些研究。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　其实，这就是今天我要讲的内容。我们有一篇论文快截稿了，但还缺一篇关于YOLO更新内容的文章作为引用来源，我们没写，所以以下就是我们的&lt;strong&gt;技术报告&lt;/strong&gt;！&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; readability=&quot;147&quot;&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;　　关于技术报告的好处是他们不需要介绍，你们都知道我写这个的目的，对吧。所以这段“引言”可以作为你阅读的一个指引。首先我们会告诉你YOLOv3的更新情况，其次我们会展示更新的方法以及一些失败的尝试，最后就是对这轮更新的意义的总结。&lt;/p&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005100324684-310951298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot;&gt;二，更新&lt;/h3&gt;
&lt;p&gt;　　谈到YOLOv3的更新情况，其实大多数时候我们就是直接把别人的好点子拿来用了。我们还训练了一个新的，比其他网络更好的分类网络。为了方便你理解，让我们从头开始慢慢介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005100805387-1737091800.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;448&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005101043239-312637635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.1 边界框预测&lt;/h4&gt;
&lt;p&gt;　　在YOLO9000后，我们的系统开始用dimension clusters固定anchor box来选定边界框。神经网络回味每个边界框预测4个坐标：tx,ty,tw,th。如果目标cell距离图像左上角的边距是(cx,cy)，且它对应边界框的宽和高为pw,ph，那么网络的预测值会是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005101514284-12477390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在训练期间，我们会计算方差。如果预测坐标的ground truth是t^*，那么响应的梯度就是ground truth值和预测值的差：t^*-t*。利用上述公式，我们能轻松推出这个结论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005101807557-1414355343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005102110607-1639471195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　YOLOv3用逻辑回归预测每个边界框的objectness score。如果当前预测的边界框比之前的更好地与ground truth对象重合，那它的分数就是1。如果当前的预测不是最好的，但它和ground truth对象重合到了一定阈值以上，神经网络会忽视这个预测[15]。我们使用的阈值是.5。与[15]不同，我们的系统只为每个ground truth对象分配一个边界框。如果先前的边界框并未分配给相应对象，那它只是检测错了对象，而不会对坐标或分类预测造成影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005102333844-1867190245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2 分类预测&lt;/h3&gt;
&lt;p&gt;　　每个边界框都会使用多标记分类来预测框中可能包含的类。我们不用softmax，而是用单独的逻辑分类器，因为我们发现前者对于提升网络性能没什么作用。在训练过程中，我们用二元交叉熵损失来预测类别。&lt;/p&gt;
&lt;p&gt;　　这个规划有助于我们把YOLO用于更复杂的领域，如开放的图像数据集。这个数据集中包含了大量重叠的标签（如女性和人）。如果我们用的是softmax，它会强加一个假设，使得每个框只包含一个类别。但通常情况下这样的做法是不妥的，相比之下，多标记的分类方法能更好的模拟数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005103452526-541556085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.3 跨尺度预测&lt;/h4&gt;
&lt;p&gt;　　YOLOv3提供3种尺寸不一的边界框。我们的系统用相似的概念提取这些尺寸的特征，以形成金字塔形网络。我们在基本特征提取器中增加了几个卷积层，并用最后的卷积层预测一个三维张量编码：边界框，框中目标和分类预测。在COCO数据集实验中，我们的神经网络分别为每种尺寸各预测了三个边界框，所以得到的张量是N ×N ×[3∗(4+ 1+ 80)]，其中包含4个边界框offset、1个目标预测以及80种分类预测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005104313438-406488382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接着，我们从前两个图层中得到特征图，并对它进行2次上采样。再从网络更早的图层中获得特征图，用element-wise把高低两种分辨率的特征图连接到一起。这样做能使我们找到早期特征映射中的上采样特征和细粒度特征，并获得更有意义的语义信息。之后，我们添加几个卷积层来处理这个特征映射组合，并最终预测出一个相似的、大小是原先两倍的张量。&lt;/p&gt;
&lt;p&gt;　　我们用同样的网络设计来预测边界框的最终尺寸，这个过程其实也有助于分类预测，因为我们可以从早期图像中筛选出更精细的特征。&lt;/p&gt;
&lt;p&gt;　　和上一版一样，YOLOv3使用的聚类方法还是K-Means，它能用来确定边界框的先验。在实验中，我们选择了9个聚类和3个尺寸，然后在不同尺寸的边界框上均匀分割维度聚类。在COCO数据集上，这9个聚类分别是：(10×13)、(16×30)、(33×23)、(30×61)、(62×45)、(59×119)、(116 × 90)、(156 × 198)、(373 × 326)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005104711977-742787338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.4 特征提取器&lt;/h4&gt;
&lt;p&gt;　　我们使用一个新的网络来提取特征，它融合了YOLOv2，Darknet-19以及其他新型残差网络，由连续的3x3和1x1卷积层组合而成，当然，其中也添加了一些shortcut connection，整体体量也更大。因为一共有53个卷积层，所以我们称它为……别急哦…… &lt;strong&gt;Darknet-53&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005105019707-390731770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005105043150-1568948975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个新网络在性能上远超Darknet-19 ，但是在效率上同样由于ResNet-101和ResNet-152。下表是在ImageNet上的实验结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005105456984-1560053330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　每个网络都使用相同的设置进行训练，输入256×256的图片，并进行单精度测试。运行环境为Titan X。我们得出的结论是Darknet-53在精度上可以与最先进的分类器相媲美，同时它的浮点运算更少，速度也更快。和ResNet-101相比，Darknet-53的速度是前者的1.5倍；而ResNet-152和它性能相似，但用时却是它的2倍以上。&lt;/p&gt;
&lt;p&gt;　　Darknet-53也可以实现每秒最高的测量浮点运算。这意味着网络结构可以更好地利用GPU，使其预测效率更高，速度更快。这主要是因为ResNets的层数太多，效率不高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005105721899-1810239502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.5 训练&lt;/h4&gt;
&lt;p&gt;　　我们只是输入完整的图像，并没有做其他处理。实验过程中设计的多尺寸训练，大量数据增强和batch normalization等操作均符合标准。模型训练和测试的框架是Darknet神经网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005110032937-1402922437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005110045809-1496280805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3 我们做了什么&lt;/h3&gt;
&lt;p&gt;　　YOLOv3的表现非常好！请参见表3，就COCO奇怪的平均mAP成绩而言，它与SSD变体相当，但速度提高了3倍。尽管如此，它仍然比像RetinaNet这样的模型要差一点。&lt;/p&gt;
&lt;p&gt;　　如果仔细看这个表，我们可以发现在IOU=.5（即表中的AP50）时，YOLOv3非常强大。它几乎与RetinaNet相当，并且远高于SSD变体。这就证明了它其实是一款非常灵活的检测器，擅长为检测对象生成合适的边界框。然而，随着IOU阈值增加，YOLOv3的性能开始同步下降，这时它预测的边界框就不能做到完美对齐了。&lt;/p&gt;
&lt;p&gt;　　在过去，YOLO一直被用于小型对象检测。但现在我们可以预见其中的演变趋势，随着新的多尺寸预测功能上线，YOLOv3将具备更高的APS性能。但是它目前在中等尺寸或大尺寸物体上的表现还相对较差，仍需进一步的完善。&lt;/p&gt;
&lt;p&gt;　　当我们基于AP50指标绘制精度和速度时（见图3），我们发现YOLOv3与其他检测系统相比具有显着优势。也就是说，它的速度正在越来越快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005110203324-546957772.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005110821753-1864883536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4 失败的尝试&lt;/h3&gt;
&lt;p&gt;　　我们在研究YOLOv3时尝试了很多东西，以下是我们还记得的一些失败案例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Anchor box坐标的偏移预测。&lt;/strong&gt;我们尝试了常规的Anchor box预测方法，比如利用线性激活将坐标x、y的偏移程度预测为边界框宽度或高度的倍数。但我们发现这种做法降低了模型的稳定性，且效果不佳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　用线性方法预测x,y，而不是使用逻辑方法。&lt;/strong&gt;我们尝试使用线性激活来直接预测x，y的offset，而不是逻辑激活。这降低了mAP成绩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　focal loss。&lt;/strong&gt;我们尝试使用focal loss，但它使我们的mAP降低了2点。 对于focal loss函数试图解决的问题，YOLOv3从理论上来说已经很强大了，因为它具有单独的对象预测和条件类别预测。因此，对于大多数例子来说，类别预测没有损失？或者其他的东西？我们并不完全确定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005110954514-175777449.png&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;449&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005111017964-101452998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双IOU阈值和真值分配。&lt;/strong&gt;在训练期间，Faster RCNN用了两个IOU阈值，如果预测的边框与.7的ground truth重合，那它是个正面的结果；如果在[.3—.7]之间，则忽略；如果和.3的ground truth重合，那它就是个负面的结果。我们尝试了这种思路，但效果并不好。&lt;/p&gt;
&lt;p&gt;　　我们对现在的更新状况很满意，它看起来已经是最佳状态。有些技术可能会产生更好的结果，但我们还需要对它们做一些调整来稳定训练。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005111216321-84686512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181005111238659-1909591848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5 更新的意义&lt;/h3&gt;
&lt;p&gt;　　YOLOv3是一个很好的检测器，它速度快，精度又高。虽然基于.3和.95的新指标，它在COCO上的成绩不如人意，但对于旧的检测指标.5 IOU，它还是非常不错的。&lt;/p&gt;
&lt;p&gt;　　所以为什么我们要改变指标呢？最初的COCO论文里只有这样一句含糊其词的话：一旦评估完成，就会生成评估指标结果。Russakovsky等人曾经有一份报告，说人类很难区分.3与.5的IOU：“训练人们用肉眼区别IOU值为0.3的边界框和0.5的边界框是一件非常困难的事”。[16]如果人类都难以区分这种差异，那这个指标有多重要？&lt;/p&gt;
&lt;p&gt;　　但也许更好的一个问题是：现在我们有了这些检测器，我们能用它们来干嘛？很多从事这方面研究的人都受雇于Google和Facebook，我想至少我们知道如果这项技术发展得完善，那他们绝对不会把它用来收集你的个人信息然后卖给……等等，你把事实说出来了！！哦哦。&lt;/p&gt;
&lt;p&gt;　　那么其他巨资资助计算机视觉研究的人还有军方，他们从来没有做过任何可怕的事情，比如用新技术杀死很多人……呸呸呸&lt;/p&gt;
&lt;p&gt;　　我有很多希望！我希望大多数人会把计算机视觉技术用于快乐的、幸福的事情上，比如计算国家公园里斑马的数量[13]，或者追踪小区附近到底有多少猫[19]。但是计算机视觉技术的应用已经步入歧途了，作为研究人员，我们有责任思考自己的工作可能带给社会的危害，并考虑怎么减轻这种危害。我们非常珍惜这个世界。&lt;/p&gt;
&lt;p&gt;　　最后，不要在Twitter上@我，我已经弃坑了！！！！&lt;/p&gt;

&lt;p&gt;参考文献：https://zhuanlan.zhihu.com/p/35023499&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 05 Oct 2018 03:30:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>原标题： YOLOv3: An Incremental Improvement 原作者： Joseph Redmon Ali Farhadi YOLO官网：YOLO: Real-Time Object</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/9744146.html</dc:identifier>
</item>
<item>
<title>TCP协议学习总结（中） - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/9743637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/9743637.html</guid>
<description>&lt;p&gt;&lt;span&gt;很多人都说TCP协议是一个十分复杂的协议，在学习当中，我对协议每一个问题都分解学习后，每一个分解我都能体会和理解它的要点，并不难理解。但我把这些拆分的细节合并后，确认感觉这样一个协议相对“臃肿”但又好像不得不这样做的感觉。也写过那么多年代码，我也十分理解这种“分布”和“一致”的协调，就好像CAP理论一样，更关键的是许多的CAP选择都是依赖于TCP这样可靠的协议之上，可想而知它“可靠性”的重中之中，我也看到了根基扎实稳重的重要性。当然技术还在不断进步，协议的完善和优化从没有停止，无论如何，学习还得继续。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP的交互数据流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、交互式输入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有些场景比如聊天，对信息交互的时效性非常敏感，又还比如远程操作，我们在本地点击一下鼠标的远程操作，需要被操作设备非常及时的响应，这样一些场景就是交互式输入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221537536-1516715831.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;交互式输入是场景需要之一，它是牺牲了网络利用率而满足了时间的一种选择，试想一下如果客户端每一个小小的动作（如点击ENTER键产生1个字节）就要带着20个字节的TCP头部以及20个自己的IP头部，一共41个字节在网络上跑，如果每种交互都是这样的话，网络的利用率大大降低，所以这种情况更多适用于局域网内。而且在这种交互式交互时还可以看到TCP头部的PSH标识被设置了，它的意思是赶紧把数据交给应用程序，而不是先放缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端的实时推送请求以及服务端的及时响应确实能保证了“实时交互”的效果，但这里会隐藏了一个客户端对服务端数据回显确认报文（ACK）的一个延迟发送。我们都知道TCP交互是一个可靠的协议，所以对数据的接收和确认是必然的要做的事情，我觉得既然客户端已经得到了服务端的及时响应，对服务端数据的确认响应已经不需要那么及时了。好好地在这一个点上的优化可以节省了网络的不必要浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221603917-1823252647.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常TCP在接收到数据时并不会立刻发送ACK，相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时这种现象为数据捎带ACK）。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送，这样做就节省了不必要的网络开销，从这一点看，TCP协议也是想绝了，毕竟资源珍贵，容不得半丁点的浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、Nagle算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然交互式输入更多适用在局域网，但广域网就不能用这是不可能的，实时交互式这种场景会产生许多的（微）小分组，例如41字节中的真正数据才1字节。这确实会增加广域网拥塞的可能性。但是“道高一尺，魔高一丈”，一种简单和好的方法应运而生，那就是Nagle算法。&lt;strong&gt;&lt;em&gt;该算法要求一个TCP连接上最多只有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其它的小分组，相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。&lt;/em&gt;&lt;/strong&gt;该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。而在希望减少微小分组数目的低速广域网上则会发送更少的分组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221647922-356300656.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图可以看到，因为Nagle算法的生效，所以在“按键”输出后没有等到服务端响应确认前的后续4次数据输入都无法发送，而是等到服务端确认ACK到达后一起打包发送。有一点需要注意的是，这里的输入假设都是小分组输入，并没有很大的数据输入（不超过MSS）。Nagle算法算是在广域网上做了一个这种的选择，对数据交互实时性的影响不会太大，而又对互联网做了一层较好的保护，让交互的效果自适应网络的状态。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP的成块数据流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 1、滑动窗口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;交互式输入我觉得从综合场景来看，相对少数。大部分情况下，大块的数据流交互才是“王道”，这里并不是说我们平时的应用交互就不需要实时，只不过这个“实时”是相对的，在数据量大的情况下如何才是最佳的交互体验，具体问题具体分析才是王道。在TCP头部中我们知道有一个叫做“16位窗口大小”的属性，这个窗口在上一节也介绍过相当于数据接收的“缓存区”，数据交互的双方（无论主动还是被动）都会维护着自己的一个窗口，应用程序没有消费数据之前都是停留在这个缓冲区中。所以，窗口可以看做TCP交互限流的一个关键所在，如果窗口爆满的一方是无法接收数据了，发送方也只能暂停发送，等待对方窗口的空闲才继续发送。毕竟双方应用程序处理数据的速度不一或者网络网速的客观影响，很难确认完美的状态，所以很需要一个像窗口一样的概念去维护双方之间的一个传送速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221759584-205023532.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上图可以看到，这次大块数据交互不像“交互式输入”那样小分组发送，而是每次发送都会充满整个报文段允许的最大值（MSS）从而达到更加的效率，当然这已经是另一次场景了，而这个场景才是我们平常使用到的场景，例如你看个新闻，刷个微博等。从图中也可以看得到窗口的真实作用，服务端一开始就告诉客户端它的窗口大小为4096，客户端要发送的数据远远大于4096（例如一张图片可以就不止了），客户端可以连续以最大报文段的容量连续发送，直到服务端的窗口（缓冲区）被沾满时，才会停止发送，等待服务端的窗口大小变更通知，再继续发送。其实这里的成块数据传送隐藏了许多的规则细节，例如发送的数据不够MSS怎么办，需要等么？又或者服务端的窗口可以腾出了1个字节的空间也要告诉客户端的话就会引发“糊涂窗口综合症”的问题。这些细节后续会慢慢介绍，这里更多先总结窗口的基本作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221821516-1489335020.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;窗口（缓冲区）的总大小是固定的，只不过因为窗口的“空闲”是随着接收方的确认而变动，从而让窗口看起来是动态变化的，这个动态（左右收缩）其实是站在双方的视觉看窗口的空闲状态而言，双方都会计算和维护当前窗口的大小， 例如发送方会计算它到底还有多少数据可以发送，而接收方会计算它到底还有多少窗口空间可以接收数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、称窗口左边沿向右边沿靠近为&lt;strong&gt;窗口靠拢&lt;/strong&gt;，这种现象发生在数据被发送和确实时；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、当窗口右边沿向右移动时将允许发送更多的数据，我们称之为&lt;strong&gt;窗口张开&lt;/strong&gt;。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）、当右边沿向左移动时，我们称之为&lt;strong&gt;窗口收缩&lt;/strong&gt;。RPC强烈建议不要使用这种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。就像“TCP窗口样例”显示的那样。不同系统默认的窗口大小不一样，例如有些是2048字节，有些是4096、8192或更大。但重要是&lt;strong&gt;&lt;em&gt;“插口API允许进程设置发送和接收缓存的大小，接收缓存的大小是该连接上所能通告的最大窗口大小，有一些应用程序通过修改插口缓存大小来增加性能”&lt;/em&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、慢启动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“接收窗口”并非万能，虽然可以通过增加缓存大小提高性能，但影响性能的远不止“接收窗口”的大小，还有网速、路由器等。迄今为止，发送方一开始便向网络发送多个报文段，直至达到接收方通告窗口大小为止。当发送方和接收方处于同一个局域网时这种方式是可以的，但是如果在发送方和接收方之间存在多个路由器时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在TCP需要支持一种被称为“慢启动（slow start）”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。慢启动为发送方的TCP增加了另一个窗口叫“拥塞窗口（congestion window）”，记为cwnd。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221934526-499875474.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小），收到一个ACK后，拥塞窗口从1个报文段增加为2，即可发送两个报文段，当继续收到这两个报文段的ACK时，拥塞窗口就增加为4，这是一种指数增加关系。发送方去拥塞窗口与通告窗口中最小值作为发送上限。其实这宗一种渐进循环的策略，当吞吐量在某些点上达到了互联网的容量时，于是中间路由器开始丢弃分组，而通知发送方它的拥塞窗口开得过大了。这里又隐藏了许多的实现细节，如丢失重传问题以及如何避免一下子又从慢启动起步这种慢效率的传输过程。这些后续会学习到。这里更多先对慢启动算法的一个初步认识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;窗口的大小应该设置为多大呢？也就是我们的TCP缓存应该设置多大呢？按理论计算，这个应该跟“带宽时延乘积”有关，具体公式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;capacity（bit）=bandwidth（b/s）* round-trip time（s）&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这个值依赖于网络速度和两端的RTT，可以有很大的变动。例如一条穿越美国（RTT约为60ms）的T1的电话线路（1544000b/s）的带宽延迟乘积为11580字节。这是没有问题的，但对于一条穿越美国的T3电话线路（45000000b/s）的带宽时延乘积则为337500字节，这个值远远超过了最大所允许的TCP通告窗口大小（16字节窗口大小=65535字节）。别忘记了TCP头部还有一各选项可以补充，后续会介绍如果通过选项解决这种超大型窗口问题。“带宽时延乘积”是一个理论值，就是我们能往发送到到接收端之间的网络最多塞满多少数据。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;学习总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 本此总结主要是学习了基于TCP协议交互的一些流程与细节问题，如“交互式输入”以及“成块数交互”的场景介绍，在“成块式传送”中是如何利用“通告窗口”作为接收方的限流以及发送方如何利用“拥塞窗口”进行限流并借助“慢启动”的方式渐进循环的摸索互联网的最大极限。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 02:20:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>很多人都说TCP协议是一个十分复杂的协议，在学习当中，我对协议每一个问题都分解学习后，每一个分解我都能体会和理解它的要点，并不难理解。但我把这些拆分的细节合并后，确认感觉这样一个协议相对“臃肿”但又好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcd144140/p/9743637.html</dc:identifier>
</item>
<item>
<title>永恒不变的，是变化 - 何必诗债换酒钱</title>
<link>http://www.cnblogs.com/backwords/p/9680296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/backwords/p/9680296.html</guid>
<description>&lt;h2 id=&quot;永恒不变的是变化&quot;&gt;永恒不变的，是变化&lt;/h2&gt;
&lt;p&gt;​ 前几日在博客园随便逛逛，读到了 &lt;a href=&quot;http://www.cnblogs.com/ityouknow/&quot;&gt;纯洁的微笑&lt;/a&gt; 的一篇文章 &lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/6634350.html&quot;&gt;你看那个人，他好像一条狗&lt;/a&gt;，文中以他三十之年的迷茫，谈到了他人生中所面临过的几个迷茫点，这激起了我的思考。&lt;/p&gt;
&lt;p&gt;​ 第一次自己做决定，是在高中，高二文理分班，决定自己学文，还是学理。 &lt;strong&gt;因为不喜欢文科，选择了理科&lt;/strong&gt; 。紧接着更为重要的决定，是高考报取什么专业。当时喜欢中医和计算机，简单的考量下，我认为计算机与互联网将是未来的趋势，所以所有的第一志愿都填了计算机，并且为了能不被调剂稳稳的录到计算机专业，也是选了一个肯定能被录取到的学校。然后眨眼间就乘上了开往异乡的火车。。。&lt;/p&gt;
&lt;p&gt;​ 大学生活，没有想象中的浪漫，也没有想象中的充满青春的激情和躁动。一切都显得，很平常。（也许是因为太宅吧）&lt;/p&gt;
&lt;p&gt;​ 第三个重要的选择，也是迄今为止最为重要的抉择，从大二困扰至今，就是考研否。&lt;/p&gt;
&lt;p&gt;​ 可能是高考的失利（好吧我知道你们都失利了），给我的影响有些大，现在有些反感应试考试。当然这只是情感因素上的原因，没什么参考价值。（但情感左右人意志的能力绝不可小瞧）&lt;/p&gt;
&lt;p&gt;另一个因素就是，我不知道为什么要考研。（除了能在考好的情况下给自己简历贴金）。我喜欢计算机技术，在学校从来都是自学，既然都是自学，我认为在社会实际生产环境中工作技术成长的要比在学校快的多。这也算是不想考研的原因之一吧。&lt;/p&gt;
&lt;p&gt;这是我大二时的思考。&lt;/p&gt;
&lt;p&gt;到了大三，考研的问题我仍未得解。这是考研与否不再是当初简单的思考，他似乎成为了我人生的岔道口，决定我未来的生活是怎样的。而且，考研与否的&lt;br/&gt;&lt;strong&gt;决定因素不再是最初的几点了&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;我们怎么做决定&quot;&gt;我们怎么做决定？&lt;/h3&gt;
&lt;p&gt;​ 我们做决定，绝大多数情况下都是依靠曾经的经验和可能有的非理智因素。但是对于未知的事物，我们无经验可依托（所以过来人的经验很值钱）。对于完全未知的两件事物，我们可以很轻松的选择，因为选哪个都一样。但是就像任何事物都不会是完全已知的一样，任何事物也都不会是完全未知的。当有 A 和 B 两个选择，每当我们多获得一些关于 A 或者 B 信息，我们就能趋利避害，选择得分更高的那个选项。信息增益帮助我们做选择，但是他也是我们 &lt;strong&gt;迷茫的来源&lt;/strong&gt;。因为，每当我们获得对 A 有利的信息后，我们开心又放心的打算选择 A，但是不久，我们又获得了关于 B 比 A 更有利的信息，于是我们还是决定选 B。如此往复，我就变成了一个畏手畏脚，不敢做决定的选择恐惧症患者了。所以这也许可以解释，那些很少考虑信息对未来事物判断作业的乐天派，为什么活的那么快乐自由。如果他们同时还能解决温饱和父母赡养，子女教育问题，那真的是当之无愧的人生赢家。&lt;/p&gt;
&lt;p&gt;​ 回到之前考研的问题上，在大三，我考量的因素有很多。&lt;/p&gt;
&lt;p&gt;首先必须提一下，在这个时期对我影响较大的一本书《穷查理智慧书》。查理先生认为所有的学科都是相互交融并且完全可以自学的（参考上个世纪的科学家，往往在多个领域成绩斐然。当然在当代很难有人做到。我们也许会称当代的这类人为“知识渊博”，但绝不会是科学家）。这的确给是对我的自学想法的一种肯定，而且我相信事实也的确如此。&lt;/p&gt;
&lt;p&gt;然后，就是实际的关于考研与不考研的因素。&lt;/p&gt;
&lt;p&gt;考研，能获得的，三年的技术沉淀，理论深掘，可能认识很多优秀的人， &lt;strong&gt;可能&lt;/strong&gt; 有很厉害 人也 nice 的导师指导着你，甚至也许可以接触到省级、国家级的项目。毫无疑问，视野和格局被极大的开阔了，也丰富了优质的人脉资源。 当然，这都是理想情况。（若能考上名校，可以认为实现了跨越阶层？）&lt;/p&gt;
&lt;p&gt;工作，能获得的，三年的工作经验，对于各种技术，工具，项目架构掌握的更加娴熟，甚至可能单独带领团队，可能认识很多优秀的人，也 &lt;strong&gt;可能&lt;/strong&gt; 有很厉害 人也很 nice 的大牛 or Boss 指导你。毫无疑问，技术成长飞快，对实际的开发环境有着深切的体会，对工业界的生产情况和行情有着一定的了解，丰富了人脉资源。当然，这都是理想情况。&lt;/p&gt;
&lt;p&gt;从上面两段比较能看出，其实两种选择都充满了不确定性。人生际遇充满不确定性实在是太正常不过，但是如此多的不确定性又怎么能够不让面临选择的人迷茫呢？&lt;/p&gt;
&lt;p&gt;​ 观察从高中到现在的我，每次所做的选择都是越来越重要，对未来影响越来越大，影响做决定的因素也是越来越多，可想，到了而立之年，我们再次做决定怎么能不迷茫呢？（选择机会成本更大）&lt;/p&gt;

&lt;h3 id=&quot;不变的是变化&quot;&gt;不变的是变化&lt;/h3&gt;
&lt;p&gt;​ 我虽然一直未能规划好未来的人生走向，但是在潜意识中我相信未来的生活还是稳定的，平衡的。可在读完 &lt;a href=&quot;http://www.cnblogs.com/ityouknow/&quot;&gt;纯洁的微笑&lt;/a&gt; 的那篇文章后，我改变了观点。我发现，原来不只是我，不只是在我这个年纪，会迷茫，原来即便经历了十年工作，社会洗礼的（成功）职场人也在迷茫。&lt;/p&gt;
&lt;p&gt;​ 之前我说到，迷茫的原因之一是因为我们始终不能获得足够的信息帮助我们做决定，那现在，我想说的第二点使我们迷茫的原因，就是 &lt;strong&gt;变化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果时代都是一成不变的，所有的事物都是一成不变的，那么就不会有如今这么多而纷杂的信息来干扰我们做决定时的视听。这时应该会有一本 当代社会知识百科全书，只要遵循里面的知识，就可以完美应付工作和生活中的所有问题。每当一个问题出现，我们都可以自信的笑着说，easy，I know it（最理想的养老方式？后悔没学中医？）。可这当然不存在。与之相反，我们的社会处于急速的变化中，以至于很多人都被甩下了车（或者在车尾挣扎）。各种各样的变化，打乱了我们的手脚。一时之间，竟不知所措。&lt;/p&gt;
&lt;p&gt;也许你一直工作的企业很稳定，但没准哪天因为某些原因就突然倒闭（这不罕见），你也就面临失业，曾经的稳定因为一场变化而被完全打破。迷茫随之而来。种种变化不一列举。好像很多人都会忽略掉对于未来会发生的变化的这种可能性，如果你随便揪一个正在工作的人问他，你有失去现在的工作后的规划吗，我猜很多人的答案都是 “No”。也许是我们太长时间的处于一种稳定状态，处于历史的制造者身份，以至于看不到历史，一直在发生变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1131119/201810/1131119-20181005100017599-1350878158.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的轴线表示时间，每一个矩形代表一个区间，或者一个时期，可能是你在某家公司工作的期间，可能是你的身体状况，可能是你刚买的股票保险，也可能是逝去的一段王朝历史。我觉得这张图能很好的说明变化的持续性，和我们自身的关系。我们，就在那一个个的矩形里。也许你很幸运，一生都在一个矩形里，那真是稳定的一生。如果我们长期的在某个矩形中，那么时间久了，我们就会忘记还有其他的矩形这回事（以为世界还是稳定性居多），当我们之前的矩形突然坍塌了，我们才会意识到，我们不过是在某个变化后持续较长的情形中罢了。其实这种观点我觉得从历史角度来解释是最为贴切的，历史的变革和迭代总是频繁又出人意料的,但是当事人也许在发生变革前夕都没有任何察觉。实际上我的观点也是源于此——历史的变迭。永恒不变的，是变化。想要舒服的生活，就得学会适应变化，妥善处理变化。适者生存依旧适用。&lt;/p&gt;
&lt;h3 id=&quot;应对迷茫的方法&quot;&gt;应对迷茫的方法。&lt;/h3&gt;
&lt;p&gt;​ 迷茫的最后一个原因，就是由于能力不足而导致的缺乏自信。如果足够有能力，那么应对未知时便会有更多的迂回余地和处理手段，有了这些手段和处理变化的经历，也会减少未来迷茫的程度。&lt;br/&gt;下面两个方法，分别是用来针对产生迷茫的两个原因：&lt;/p&gt;
&lt;p&gt;1、做决定时，在时间允许范围内，尽可能的获取信息。（互联网有所有你想要的）&lt;/p&gt;
&lt;p&gt;2、不断提升自身能力，抗风险能力，保持危机意识。（说和做是两种感觉）&lt;/p&gt;
&lt;p&gt;作者：何必诗债换酒钱&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/backwords/p/9680296.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/backwords/p/9680296.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;本博客中未标明转载的文章归作者何必诗债换酒钱和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 02:11:00 +0000</pubDate>
<dc:creator>何必诗债换酒钱</dc:creator>
<og:description>一篇文章引发的思考。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/backwords/p/9680296.html</dc:identifier>
</item>
</channel>
</rss>