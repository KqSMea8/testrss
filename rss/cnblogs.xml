<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>03 持续集成和部署/基础设施 - DevOps之路 - 愤怒的TryCatch</title>
<link>http://www.cnblogs.com/likeli/p/8964694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/likeli/p/8964694.html</guid>
<description>&lt;blockquote readability=&quot;2.3972602739726&quot;&gt;
&lt;p&gt;文章Github地址，欢迎&lt;code&gt;start&lt;/code&gt;：&lt;a href=&quot;https://github.com/li-keli/DevOps-WiKi&quot; class=&quot;uri&quot;&gt;https://github.com/li-keli/DevOps-WiKi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务的持续集成和部署这里有两套选择方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Gitlab Runner&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jenkins&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;gitlab-runner&quot;&gt;Gitlab Runner&lt;/h2&gt;
&lt;p&gt;此处采用Gitlab Runner进行&lt;code&gt;CI/CD&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/li-keli/DevOps-WiKi/raw/master/01%20%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/img.resource/cicd_pipeline_infograph.png&quot; alt=&quot;cicd_pipeline_infograph&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://about.gitlab.com/features/gitlab-ci-cd/&quot; class=&quot;uri&quot;&gt;https://about.gitlab.com/features/gitlab-ci-cd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在node02节点上安装Gitlab Runner，首先下载Runner程序，这个程序是由go开发，所以部署很方便，就一个二进制可执行程序。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://docs.gitlab.com/runner/install/bleeding-edge.html&quot; class=&quot;uri&quot;&gt;https://docs.gitlab.com/runner/install/bleeding-edge.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/li-keli/DevOps-WiKi/raw/master/01%20%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/img.resource/2018-04-08_150317.png&quot; alt=&quot;2018-04-08_150317&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据自己服务器的架构版本来选择二进制的可执行程序下载。&lt;/p&gt;
&lt;p&gt;最终shell脚本如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通用户运行&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/master/binaries/gitlab-runner-linux-amd64 &amp;amp;&amp;amp; \
chmod +x gitlab-runner &amp;amp;&amp;amp; \
useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash &amp;amp;&amp;amp; \
gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner &amp;amp;&amp;amp; \
gitlab-runner start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;以ROOT用户运行&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/master/binaries/gitlab-runner-linux-amd64 &amp;amp;&amp;amp; \
chmod +x gitlab-runner &amp;amp;&amp;amp; \
mkdir /home/gitlab-runner &amp;amp;&amp;amp; \
gitlab-runner install --user=root --working-directory=/home/gitlab-runner &amp;amp;&amp;amp; \
gitlab-runner start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么Runner部署就完成了，接下来配置Runner：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Gitlab &amp;gt; 项目 &amp;gt; settings &amp;gt; CI/CD &amp;gt; Runners settings&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个页面上有详细的Runner介绍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/li-keli/DevOps-WiKi/raw/master/01%20%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/img.resource/2018-04-08_152128.png&quot; alt=&quot;2018-04-08_152128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照说明进行配置，这里整理成了一个shell脚本：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shell构建&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;gitlab-runner register \
  --url &quot;http://git.examlpe.com&quot; \
  --registration-token &quot;PROJECT_REGISTRATION_TOKEN&quot; \
  --description &quot;this is a runner&quot; \
  --tag-list &quot;build&quot; \
  --executor &quot;shell&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上配置完成后，在gitlab项目setting中即可看到运行中的Runner。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注：此处最后异步选择执行方式为shell，选择shell是为了方便初次使用CI部署，了解配置脚本，后期会使用docker执行执行&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6.7951219512195&quot;&gt;
&lt;p&gt;另外由于作者本身知识有限，都是摸索着来的，所以不一定所有的做法都对，或者某些实践会有更好的方案，望各位读者不吝指正，有任何疑问，请留 &lt;a href=&quot;https://github.com/li-keli/DevOps-WiKi/issues&quot;&gt;issues&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 27 Apr 2018 23:09:00 +0000</pubDate>
<dc:creator>愤怒的TryCatch</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/likeli/p/8964694.html</dc:identifier>
</item>
<item>
<title>C++框架_之Qt的信号和槽的详解 - 我举个栗子</title>
<link>http://www.cnblogs.com/wanghui1234/p/8964968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghui1234/p/8964968.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。&lt;span&gt;&lt;strong&gt;当某个事件发生之后&lt;/strong&gt;&lt;/span&gt;，比如，按钮检测到自己被点击了一下，&lt;span&gt;&lt;strong&gt;它就会发出一个信号（signal）&lt;/strong&gt;&lt;/span&gt;。这种发出是没有目的的，类似广播。&lt;span&gt;&lt;strong&gt;如果有对象对这个信号感兴趣，它就会使用连接（connect）函数&lt;/strong&gt;&lt;/span&gt;，意思是，&lt;span&gt;&lt;strong&gt;将想要&lt;/strong&gt;&lt;strong&gt;处理的信号和&lt;/strong&gt;&lt;strong&gt;自己的一个函数（称为槽（slot））绑定来处理这个信号&lt;/strong&gt;&lt;/span&gt;。也就是说，&lt;span&gt;&lt;strong&gt;当信号发出时，被连接的槽函数会自动被回调&lt;/strong&gt;&lt;/span&gt;。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：&lt;strong&gt;&lt;span&gt;槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.1对象树&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;参考连接：&lt;a title=&quot;对象树&quot; href=&quot;https://blog.csdn.net/fzu_dianzi/article/details/6949081&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/fzu_dianzi/article/details/6949081&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201804/1322549-20180428001405501-1803978009.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;341&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Qt提供了一种机制，能够自动、有效的组织和管理继承自QObject的Qt对象，这种机制就是对象树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Qt对象树在用户界面编程上是非常有用的。它能够帮助程序员减轻内存泄露的压力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面笔者将简单分析对象树。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QApplication app(argc, argv);
    QDialog &lt;/span&gt;*dlg = &lt;span&gt;new&lt;/span&gt; QDialog(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    QPushButton &lt;/span&gt;*btn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QPushButton(dlg);
    qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dlg = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; dlg;
    qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; btn;
    dlg&lt;/span&gt;-&amp;gt;&lt;span&gt;exec();
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; btn;
    qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dlg = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; dlg;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
dlg &lt;/span&gt;= QDialog(&lt;span&gt;0x3ea1a0&lt;/span&gt;&lt;span&gt;) 
btn &lt;/span&gt;= QPushButton(&lt;span&gt;0x3ea228&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;关闭窗口后，dlg = QDialog(0x3ea1a0)
这说明关闭窗口，不会销毁该窗口部件，而是将其隐藏起来。
我们在qDebug() &amp;lt;&amp;lt; &quot;dlg = &quot; &amp;lt;&amp;lt; dlg;
之后加上
qDebug() &amp;lt;&amp;lt; &quot;btn = &quot; &amp;lt;&amp;lt; btn;
明显的，我们之前已经delete btn，btn指针没有被赋值为0，这是编译器决定的。
执行程序后，必然出现段错误。
2、
将程序稍微修改下。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QApplication app(argc, argv);
    QDialog &lt;/span&gt;*dlg = &lt;span&gt;new&lt;/span&gt; QDialog(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    QPushButton &lt;/span&gt;*btn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QPushButton(dlg);
    qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dlg = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; dlg;
    qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; btn;
    dlg&lt;/span&gt;-&amp;gt;&lt;span&gt;exec();
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; dlg;
    qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; btn;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;为了体验一下信号槽的使用，我们以一段简单的代码说明：&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;15&quot;&gt;&lt;span&gt;Qt5 的书写方式：（推荐的使用）&lt;span&gt;★★★★★&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;QApplication&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QPushButton&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QApplication app(argc, argv);

    QPushButton button(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
QObject::connect(&lt;/span&gt;&amp;amp;button, &amp;amp;&lt;span&gt;QPushButton::clicked,
&lt;/span&gt;&amp;amp;app, &amp;amp;&lt;span&gt;QApplication::quit);
    button.show();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; app.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们按照前面文章中介绍的在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connect()函数最常用的一般形式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
connect(sender, signal, receiver, slot);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt; sender：发出信号的对象&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt; signal：发送对象发出的信号&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt; receiver：接收信号的对象&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt; slot：接收对象在接收到信号之后所需要调用的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;槽函数的参数可以比信号的少&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;，即便如此，槽函数存在的那些&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;参数的顺序也必须和信号的前面几个一致起来&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果信号槽不符合，或者根本找不到这个信号或者槽函数，比如我们改成：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
connect(&amp;amp;button, &amp;amp;QPushButton::clicked, &amp;amp;QApplication::quit2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于 QApplication 没有 quit2 这样的函数，因此在编译时会有编译错误：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; not a member of QApplication
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样，使用成员函数指针我们就不会担心在编写信号槽的时候出现函数错误。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;15&quot;&gt;&lt;span&gt;Qt4 的书写方式：&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]) 
{ 
        QApplication a(argc, argv); 
        QPushButton &lt;/span&gt;*button = &lt;span&gt;new&lt;/span&gt; QPushButton(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
        connect(button, SIGNAL(clicked()), &lt;/span&gt;&amp;amp;&lt;span&gt;a, SLOT(quit())); 
        button&lt;/span&gt;-&amp;gt;&lt;span&gt;show(); 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec(); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里使用了&lt;span&gt;&lt;strong&gt;SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串&lt;/strong&gt;&lt;/span&gt;。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;16&quot;&gt;&lt;span&gt;Qt5在语法上完全兼容Qt4&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;小总结：&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;　　1&amp;gt;. 格式: connect(信号发出者对象(指针), &amp;amp;className::clicked, 信号接收者对象(指针), &amp;amp;classB::slot);&lt;br/&gt;　　2&amp;gt;. 标准信号槽的使用:&lt;br/&gt;　　　　connect(sender, &amp;amp;Send::signal, receiver, &amp;amp;Receiver::slot)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们看看使用 Qt 的信号槽，实现一个报纸和订阅者的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一个报纸类Newspaper，有一个订阅者类Subscriber。Subscriber可以订阅Newspaper。这样，当Newspaper有了新的内容的时候，Subscriber可以立即得到通知。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &amp;lt;QObject&amp;gt;
 &lt;span&gt;/////////&lt;/span&gt;&lt;span&gt;/ newspaper.h &lt;/span&gt;&lt;span&gt;/////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Newspaper : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QObject
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Newspaper(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; QString &amp;amp;&lt;span&gt; name) :
        m_name(name)
    {
    }
 
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; send()
    {
        emit newPaper(m_name);
    }
 
signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; newPaper(&lt;span&gt;const&lt;/span&gt; QString &amp;amp;&lt;span&gt;name);
 
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    QString m_name;
};
 
&lt;/span&gt;&lt;span&gt;/////////&lt;/span&gt;&lt;span&gt;/ reader.h &lt;/span&gt;&lt;span&gt;/////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
#include &amp;lt;QObject&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QDebug&amp;gt;
 
&lt;span&gt;class&lt;/span&gt; Reader : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QObject
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Reader() {}
 
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; receiveNewspaper(&lt;span&gt;const&lt;/span&gt; QString &amp;amp;&lt;span&gt; name)
    {
        qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Receives Newspaper: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; name;
    }
};
 
&lt;/span&gt;&lt;span&gt;/////////&lt;/span&gt;&lt;span&gt;/ main.cpp &lt;/span&gt;&lt;span&gt;/////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
#include &amp;lt;QCoreApplication&amp;gt;&lt;span&gt;
 
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newspaper.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reader.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
 
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QCoreApplication app(argc, argv);
 
    Newspaper newspaper(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Newspaper A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Reader reader;
    QObject::connect(&lt;/span&gt;&amp;amp;newspaper, &amp;amp;&lt;span&gt;Newspaper::newPaper,
                     &lt;/span&gt;&amp;amp;reader,    &amp;amp;&lt;span&gt;Reader::receiveNewspaper);
    newspaper.send();
 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; app.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;●首先看Newspaper这个类。这个类继承了QObject类。&lt;strong&gt;&lt;span&gt;只有继承了QObject类的类，才具有信号槽的能力&lt;/span&gt;。&lt;/strong&gt;所以，为了使用信号槽，必须继承QObject。&lt;span&gt;&lt;strong&gt;凡是QObject类（不管是直接子类还是间接子类），都应该在第一行代码写上Q_OBJECT&lt;/strong&gt;。&lt;/span&gt;不管是不是使用信号槽，都应该添加这个宏。这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;● Newspaper类的 public 和 private 代码块都比较简单，只不过它新加了一个 signals。signals 块所列出的，就是该类的信号。&lt;strong&gt;&lt;span&gt;信号就是一个个的函数名，返回值是 void（因为无法获得信号的返回值，所以也就无需返回任何值），参数是该类需要让外界知道的数据。信号作为函数名，不需要在 cpp 函数中添加任何实现。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;●Newspaper类的send()函数比较简单，只有一个语句emit newPaper(m_name);。emit 是 Qt 对 C++ 的扩展，是一个关键字（其实也是一个宏）。emit 的含义是发出，也就是发出newPaper()信号。感兴趣的接收者会关注这个信号，可能还需要知道是哪份报纸发出的信号？所以，我们将实际的报纸名字m_name当做参数传给这个信号。当接收者连接这个信号时，就可以通过槽函数获得实际值。这样就完成了数据从发出者到接收者的一个转移。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;● Reader类更简单。因为这个类需要接受信号，所以我们将其继承了QObject，并且添加了Q_OBJECT宏。后面则是默认构造函数和一个普通的成员函数。&lt;span&gt;&lt;strong&gt;Qt 5 中，任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数。&lt;/strong&gt;&lt;/span&gt;与信号函数不同，槽函数必须自己完成实现代码。槽函数就是普通的成员函数，因此作为成员函数，也会受到 public、private 等访问控制符的影响。（如果信号是 private 的，这个信号就不能在类的外面连接，也就没有任何意义。）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.1自定义信号槽需要注意的事项&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;●发送者和接收者都需要是&lt;/span&gt;QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;●使用&lt;/span&gt; signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;●槽函数是普通的成员函数，作为成员函数，会受到&lt;/span&gt; public、private、protected 的影响；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;●使用&lt;/span&gt; emit 在恰当的位置发送信号；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;●使用&lt;/span&gt;QObject::connect()函数连接信号和槽。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;●任何成员函数、&lt;/span&gt;static 函数、全局函数和 Lambda 表达式都可以作为槽函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.2信号槽&lt;/strong&gt;&lt;strong&gt;的更多用法&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;strong&gt;●&lt;/strong&gt; 一个信号可以和多个槽相连&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;如果是这种情况，这些槽会一个接一个的被调用，但是它们的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;调用顺序是不确定的。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;strong&gt;●&lt;/strong&gt;多个信号可以连接到一个槽&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;strong&gt;　　只要任意一个信号发出，这个槽就会被调用&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;●一个信号可以连接到另外的一个信号&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;●槽可以被取消链接&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　这种情况并不经常出现，因为&lt;span&gt;当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;●使用Lambda 表达式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　我们的代码可以写成下面这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
QObject::connect(&amp;amp;newspaper, static_cast&amp;lt;&lt;span&gt;void&lt;/span&gt; (Newspaper:: *&lt;span&gt;)
(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; QString &amp;amp;)&amp;gt;(&amp;amp;&lt;span&gt;Newspaper::newPaper),
[&lt;/span&gt;=](&lt;span&gt;const&lt;/span&gt; QString &amp;amp;&lt;span&gt;name) 
{ &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Your code here. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;C++11中的Lambda表达式&lt;strong&gt;用于定义并创建匿名的函数对象&lt;/strong&gt;，以简化编程工作。首先看一下Lambda表达式的基本构成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201804/1322549-20180427235617901-820490928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;strong&gt;　　&lt;span&gt;　[函数对象参数](操作符重载函数参数)mutable或exception -&amp;gt;返回值{函数体}&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; ①函数对象参数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[]，标识一个&lt;strong&gt;Lambda的开始&lt;/strong&gt;，这部分必须存在，&lt;strong&gt;不能省略&lt;/strong&gt;。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲空。没有使用任何函数对象参数。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是&lt;strong&gt;值传递方式&lt;/strong&gt;（相当于编译器自动为我们按值传递了所有局部变量）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲&amp;amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是&lt;strong&gt;引用传递方式&lt;/strong&gt;（相当于编译器自动为我们按引用传递了所有局部变量）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲ this。函数体内可以使用Lambda所在类中的成员变量。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲ a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲ &amp;amp;a。将a按引用进行传递。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　    ▲ a, &amp;amp;b。将a按值进行传递，b按引用进行传递。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲ =，&amp;amp;a, &amp;amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　　　 ▲ &amp;amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;0&lt;/span&gt;, n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
[&lt;/span&gt;=] (&lt;span&gt;int&lt;/span&gt; a) mutable { m = ++n + a; }(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
      [&lt;/span&gt;&amp;amp;] (&lt;span&gt;int&lt;/span&gt; a) { m = ++n + a; }(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

      [&lt;/span&gt;=,&amp;amp;m] (&lt;span&gt;int&lt;/span&gt; a) mutable { m = ++n + a; }(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
      [&lt;/span&gt;&amp;amp;,m] (&lt;span&gt;int&lt;/span&gt; a) mutable { m = ++n + a; }(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

      [m,n] (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a) mutable { m = ++n + a; }(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
      [&lt;/span&gt;&amp;amp;m,&amp;amp;n] (&lt;span&gt;int&lt;/span&gt; a) { m = ++n + a; }(&lt;span&gt;4&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;② 操作符重载函数参数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;amp;a,&amp;amp;b)）两种方式进行传递。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ 可修改标示符；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ 错误抛出标示符；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;exception声明，这部分也可以省略。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑤ 函数返回值；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&amp;gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑥ 是函数体；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{}，标识函数的实现，这部分不能省略，但函数体可以为空。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201804/1322549-20180428000327474-1817439518.png&quot; alt=&quot;&quot; width=&quot;664&quot; height=&quot;649&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例代码：&lt;/p&gt;
&lt;p&gt;mainwidget.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef MAINWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MAINWIDGET_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QPushButton&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子窗口头文件&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; MainWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MainWidget(QWidget &lt;/span&gt;*parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;~&lt;span&gt;MainWidget();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; mySlot();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeWin();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; dealSub();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dealSlot(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;, QString);

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    QPushButton b1;
    QPushButton &lt;/span&gt;*&lt;span&gt;b2;
    QPushButton b3;

    SubWidget subWin;
};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MAINWIDGET_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;subwidget.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef SUBWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; SUBWIDGET_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QPushButton&amp;gt;

&lt;span&gt;class&lt;/span&gt; SubWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; SubWidget(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendSlot();

signals:
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 信号必须有signals关键字来声明
      * 信号没有返回值，但可以有参数
      * 信号就是函数的声明，只需声明，无需定义
      * 使用：emit mySignal();
      * 信号可以重载
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; mySignal();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; mySignal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;, QString);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; slots:

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    QPushButton b;
};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SUBWIDGET_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mainwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QApplication&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QApplication a(argc, argv);
    MainWidget w;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行MainWidget的构造函数&lt;/span&gt;
&lt;span&gt;    w.show();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mainwidget.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mainwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QPushButton&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QDebug&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印&lt;/span&gt;
&lt;span&gt;
MainWidget::MainWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent)
    : QWidget(parent)
{
    b1.setParent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    b1.setText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    b1.move(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

    b2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; QPushButton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    b2&lt;/span&gt;-&amp;gt;setText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    connect(&lt;/span&gt;&amp;amp;b1, &amp;amp;QPushButton::pressed, &lt;span&gt;this&lt;/span&gt;, &amp;amp;&lt;span&gt;MainWidget::close);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; &amp;amp;b1: 信号发出者，指针类型
     * &amp;amp;QPushButton::pressed：处理的信号，  &amp;amp;发送者的类名::信号名字
     * this: 信号接收者
     * &amp;amp;MainWidget::close： 槽函数，信号处理函数  &amp;amp;接收的类名::槽函数名字
     * 发送-处理-接收-处理
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 自定义槽，普通函数的用法
     * Qt5：任意的成员函数，普通全局函数，静态函数
     * 槽函数需要和信号一致（参数，返回值）
     * 由于信号都是没有返回值，所以，槽函数一定没有返回值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    connect(b2, &lt;/span&gt;&amp;amp;QPushButton::released, &lt;span&gt;this&lt;/span&gt;, &amp;amp;&lt;span&gt;MainWidget::mySlot);

    connect(b2, &lt;/span&gt;&amp;amp;QPushButton::released, &amp;amp;b1, &amp;amp;&lt;span&gt;QPushButton::hide);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 信号：短信
     * 槽函数：接收短信的手机
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    setWindowTitle(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this-&amp;gt;setWindowTitle(&quot;老大&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等价同上&lt;/span&gt;
&lt;span&gt;
    b3.setParent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    b3.setText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;切换到子窗口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    b3.move(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示子窗口
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;subWin.show();&lt;/span&gt;
&lt;span&gt;
    connect(&lt;/span&gt;&amp;amp;b3, &amp;amp;QPushButton::released, &lt;span&gt;this&lt;/span&gt;, &amp;amp;&lt;span&gt;MainWidget::changeWin);


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理子窗口的信号
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    void (SubWidget::*funSignal)() = &amp;amp;SubWidget::mySignal;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    connect(&amp;amp;subWin, funSignal, this, &amp;amp;MainWidget::dealSub);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     void (SubWidget::*testSignal)(int, QString) = &amp;amp;SubWidget::mySignal;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    connect(&amp;amp;subWin, testSignal, this, &amp;amp;MainWidget::dealSlot);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Qt4信号连接
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Qt4槽函数必须有slots关键字来修饰&lt;/span&gt;
    connect(&amp;amp;subWin, SIGNAL(mySignal()), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, SLOT(dealSub()) );

    connect(&lt;/span&gt;&amp;amp;subWin, SIGNAL(mySignal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,QString)),
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, SLOT(dealSlot(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,QString)) );
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缺点： SIGNAL SLOT 将函数名字 -&amp;gt; 字符串  不进行错误检查

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Lambda表达式, 匿名函数对象
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;C++11增加的新特性， 项目文件： CONFIG += C++11
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Qt配合信号一起使用，非常方便&lt;/span&gt;
&lt;span&gt;
    QPushButton &lt;/span&gt;*b4 = &lt;span&gt;new&lt;/span&gt; QPushButton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    b4&lt;/span&gt;-&amp;gt;setText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lambda表达式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    b4&lt;/span&gt;-&amp;gt;move(&lt;span&gt;150&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt;, b = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    connect(b4, &lt;/span&gt;&amp;amp;&lt;span&gt;QPushButton::clicked,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; = :把外部所有局部变量、类中所有成员以值传递方式
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this: 类中所有成员以值传递方式
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;amp; : 把外部所有局部变量， 引用符号&lt;/span&gt;
            [=](&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isCheck)
            {
                qDebug() &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; isCheck;
            }


            );


    resize(&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MainWidget::dealSlot(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a, QString str)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; str.toUtf8() -&amp;gt; 字节数组QByteArray
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ……data()  -&amp;gt; QByteArray -&amp;gt; char *&lt;/span&gt;
    qDebug() &amp;lt;&amp;lt; a &amp;lt;&amp;lt;&lt;span&gt; str.toUtf8().data();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MainWidget::mySlot()
{
    b2&lt;/span&gt;-&amp;gt;setText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MainWidget::changeWin()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子窗口显示&lt;/span&gt;
&lt;span&gt;    subWin.show();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本窗口隐藏&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;hide();
}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MainWidget::dealSub()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子窗口隐藏&lt;/span&gt;
&lt;span&gt;    subWin.hide();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本窗口显示&lt;/span&gt;
&lt;span&gt;    show();
}

MainWidget::&lt;/span&gt;~&lt;span&gt;MainWidget()
{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;subwidget.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

SubWidget::SubWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent) : QWidget(parent)
{
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;setWindowTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小弟&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    b.setParent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    b.setText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;切换到主窗口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    connect(&lt;/span&gt;&amp;amp;b, &amp;amp;QPushButton::clicked, &lt;span&gt;this&lt;/span&gt;, &amp;amp;&lt;span&gt;SubWidget::sendSlot);

    resize(&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; SubWidget::sendSlot()
{
    emit mySignal();
    emit mySignal(&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是子窗口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SingnalAndSlot.pro&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
QT       +=&lt;span&gt; core gui

greaterThan(QT_MAJOR_VERSION, &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;): QT +=&lt;span&gt; widgets

TARGET &lt;/span&gt;=&lt;span&gt; 03_SignalAndSlot
TEMPLATE &lt;/span&gt;=&lt;span&gt; app


SOURCES &lt;/span&gt;+=&lt;span&gt; main.cpp\
        mainwidget.cpp \
    subwidget.cpp

HEADERS  &lt;/span&gt;+=&lt;span&gt; mainwidget.h \
    subwidget.h

CONFIG &lt;/span&gt;+= C++&lt;span&gt;11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上资料来源于互联网和自己的见解。如有雷同，不胜荣幸。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Apr 2018 16:32:00 +0000</pubDate>
<dc:creator>我举个栗子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanghui1234/p/8964968.html</dc:identifier>
</item>
<item>
<title>项目目录标准结构（前端） - 姜皓</title>
<link>http://www.cnblogs.com/jianghao233/p/8965577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianghao233/p/8965577.html</guid>
<description>&lt;p&gt;（学习自慕课网中《所向披靡的响应式开发》课程中）&lt;/p&gt;
&lt;p&gt;一.如何组织项目目录结构&lt;/p&gt;
&lt;p&gt;1.约定优于配置&lt;/p&gt;
&lt;p&gt;2.约定代码结构或命名规范来减少配置数量&lt;/p&gt;
&lt;p&gt;（没有最好的组织方式，只有合适的组织方式）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427234925090-761035919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;样式放入CSS文件下，main.css是通用样式，normalize.css是引用样式，login是的登录样式。&lt;/p&gt;
&lt;p&gt;脚本放入js文件下，main.js是通用脚本，vendor文件夹来存放第三方库和框架；压缩版可加上min前缀。&lt;/p&gt;
&lt;p&gt;othersrc为大、中型项目中，home为主页，login为登录页，customer为用户模块，common为通用文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235151063-1013256629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tpl文件夹用来存放模板文件，swf文件夹用来存放flash文件，less和sass存放该工具文件。（都在根目录下）&lt;/p&gt;
&lt;p&gt;二、JS文件夹下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428000440776-1026429265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235300747-1895368248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;错误页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235332054-1276020398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;爬虫访问时告诉爬虫的爬取范围（不具有强制性，只是一种约定）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235436985-12394764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;都可以访问爬取，除了admin下的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235640941-141370742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用于网站的标志，在地址栏显示（常用logo）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235738184-1899004304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;介绍团队信息，网站信息，是给“人”看的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235914298-284944712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180427235958396-511265431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 三、根目录下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001612057-2066152404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428000500235-1143781048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;统一代码解决方案的文件，用来帮助开发者在不同浏览器、IDE下更好地维护代码，主要是各种代码规范。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001016846-1141096778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.charst = utf-8(所有文件编码格式为utf-8)&lt;/p&gt;
&lt;p&gt;2.indent_size(代码缩进尺寸）&lt;/p&gt;
&lt;p&gt;3.indent_style = space(代码缩进方式为空格）&lt;/p&gt;
&lt;p&gt;4.insert_final_newline = true(每一个文件以空白行结尾）&lt;/p&gt;
&lt;p&gt;5.trim_trailing_whitespace = true(去除换行行首的空白字符）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001125437-1195185753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.trim_teailing_whitespace = flase(不去除换行行首的空白字符）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001206264-1921630856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;告诉 git 来管理版本文件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001316641-1919363911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001355900-1556694783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存版权声明，开源协议等信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001536802-1991007755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201804/1146559-20180428001524288-1113395991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Markdown 具体语法可参见本人&lt;a title=&quot;五分钟上手Markdown&quot; href=&quot;http://www.cnblogs.com/jianghao233/p/7747562.html&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Apr 2018 16:30:00 +0000</pubDate>
<dc:creator>姜皓</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jianghao233/p/8965577.html</dc:identifier>
</item>
<item>
<title>树的遍历与递归 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/8965512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/8965512.html</guid>
<description>&lt;p&gt;最近做一个统计工作，需要遍历一些文件，一个文件夹下面有很多层的小文件，如何算出这个文件夹下面有多少文件？相信很多人第一时间都能想到递归遍历，这是最直接，最简单的办法。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，可能会导致栈溢出。当文件夹深度足够深，递归的反复调用会导致方法一直无法释放，造成jvm的栈溢出。那我们该怎么办？&lt;/p&gt;
&lt;h2 id=&quot;如何遍历文件夹&quot;&gt;如何遍历文件夹&lt;/h2&gt;
&lt;p&gt;学过数据结构的都知道，文件夹就类似于数据结构的中的树，遍历文件夹就如同遍历树。常见的遍历思想有深度优先遍历和广度优先遍历，其中递归遍历就属于深度优先遍历的一种。&lt;/p&gt;
&lt;h3 id=&quot;一递归遍历&quot;&gt;一、递归遍历&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public void traverseFile_recursion(File root) {
    if (root != null) {
        if (root.isDirectory()) {
            File[] files = root.listFiles();
            for (File f : files) {
                traverseFile_recursion(f);
            }
        } else {
            System.out.println(root.getPath());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;递归方法遍历很容易看懂，递归函数的优点是定义简单，逻辑清晰。这里不细说了，看上面代码就OK了。&lt;/p&gt;
&lt;h3 id=&quot;二非递归的深度优先遍历&quot;&gt;二、非递归的深度优先遍历&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public void traverseFile_depth(File root) {
    Stack&amp;lt;File&amp;gt; fileStack = new Stack&amp;lt;&amp;gt;();
    File file;
    if (root != null &amp;amp;&amp;amp; root.isDirectory()) {
        fileStack.push(root);
    }
    while (!fileStack.isEmpty()) {
        file = fileStack.pop();
        File[] files = file.listFiles();
        for (File f : files) {
            if (f.isDirectory()) {
                fileStack.push(f);
            } else {
                System.out.println(f.getPath());
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;深度优先遍历，借助了一个栈，然后按次序读取文件夹的元素，并判断如果是文件夹则把该文件夹入栈。然后栈顶的文件夹再出栈，遍历，以此类推，直到所有的文件夹都出栈，再也没有文件夹入栈。&lt;/p&gt;
&lt;h3 id=&quot;三广度优先遍历&quot;&gt;三、广度优先遍历&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public void traverseFile_Width(File root) {
    Queue&amp;lt;File&amp;gt; fileQueue = new ArrayDeque&amp;lt;&amp;gt;();
    File file;
    if (root != null &amp;amp;&amp;amp; root.isDirectory()) {
        fileQueue.add(root);
    }
    while (!fileQueue.isEmpty()) {
        file = fileQueue.remove();
        File[] files = file.listFiles();
        for (File f : files) {
            if (f.isDirectory()) {
                fileQueue.add(f);
            } else {
                System.out.println(f.getPath());
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;广度优先遍历，借助了一个队列，然后按次序读取文件夹的元素，并判断如果是文件夹则把该文件夹加入队尾，然后队首的文件夹再出队，遍历，以此类推，直到所有的文件夹都出队，再也没有文件夹入队。&lt;/p&gt;
&lt;h2 id=&quot;关于递归的性能问题&quot;&gt;关于递归的性能问题&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;虽然递归方法在解决一些问题时，逻辑思路很清晰，在很多情况下递归还是不建议使用的，效率偏低，严重的情况下，会造成栈溢出。解决办法是使用尾递归或者使用循环方式。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。下面，举例子说明一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一斐波拉契数列&quot;&gt;一、斐波拉契数列&lt;/h3&gt;
&lt;p&gt;斐波拉契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……第1个和第2个数是1，从第3个位置起，每个数等于它前面两个数的和。求第 n 个位置的数是多少？&lt;br/&gt;使用递归方法实现很简单，方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public long fun1(int x) {
    if (x == 1)
        return 1;
    else if (x == 2)
        return 1;
    else {
        return fun1(x - 1) + fun1(x - 2);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    long start_time = System.currentTimeMillis();
    long result = new Fibo().fun1(46);
    System.out.println(&quot;结果:  &quot; + result);
    long end_time = System.currentTimeMillis();
    System.out.println(&quot;耗时： &quot; + (end_time - start_time));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是基于我的PC（i7-7700,16G-DDR4-2400）的执行结果:&lt;br/&gt;位置：46&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  1836311903
耗时： 5170&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位置：47&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  2971215073
耗时： 8355&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位置：48&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  4807526976
耗时： 13377&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位置：49&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  7778742049
耗时： 21941&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位置：50&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  12586269025
耗时： 34915&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位置：51&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  20365011074
耗时： 57158&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看这个时间增加，你还想用递归求吗？求位置51的用时接近一分钟。&lt;br/&gt;下面用循环来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public long fun2(int x) {
    long num1 = 1;
    long num2 = 1;
    long result = 0;
    if (x == 1) {
        return 1;
    } else if (x == 2) {
        return 1;
    } else {
        for (int i = 3; i &amp;lt;= x; i++) {
            result = num1 + num2;
            num1 = num2;
            num2 = result;
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样测试位置 51 的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  20365011074
耗时： 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几乎是秒算出结果。再看看100位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结果:  3736710778780434371
耗时： 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样几乎是秒出结果。这说明，用循环的方式，时间几乎是常数级的。若要用递归方式求100位置的，我想我可以让程序执行，然后去睡觉了。&lt;/p&gt;
&lt;h3 id=&quot;二遍历打印-list-元素&quot;&gt;二、遍历打印 List 元素&lt;/h3&gt;
&lt;p&gt;上面关于递归使用，由于迭代层次还没到一定级别，所以只能时间长，还没到栈溢出的地步，下面我们测试一下遍历上万元素的了 List ,来说明，上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void printElement(Iterator&amp;lt;Integer&amp;gt; iterator) {
    if (!iterator.hasNext()) {
        return;
    } else {
        System.out.println(iterator.next());
        printElement(iterator);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    List&amp;lt;Integer&amp;gt; list = new ArrayList();
    for (int i = 0; i &amp;lt; 20000; i++) {
        list.add(i);
    }
    long start_time = System.currentTimeMillis();
    printElement(list.iterator());
    long end_time = System.currentTimeMillis();
    System.out.println(&quot;耗时： &quot; + (end_time - start_time));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们用递归的方式遍历 List ,运行结果部分截图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758949/201804/758949-20180428001157116-1074215121.png&quot;/&gt;&lt;br/&gt;程序崩了，报的错，正是栈溢出。下面用循环方式遍历：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void printElement2(Iterator&amp;lt;Integer&amp;gt; iterator) {
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果部分截图如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758949/201804/758949-20180428001204715-501026922.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;方法调用时的内存情况&quot;&gt;方法调用时的内存情况&lt;/h2&gt;
&lt;p&gt;下面摘录《数据结构预算法分析-Java语言描述》中的几段话：&lt;br/&gt;说明了方法调用的过程，由此也解释了深层次递归性能低的原因。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当调用一个新方法时，主调例程的所有局部变量需要由系统存储起来，否则被调用的新方法将会重写由主调例程的变量所使用的内存。不仅如此，该主调例程的当前位置也必须要存储，以便在新方法运行完后知道向哪里转移。这些变量一般由编译器指派给机器的寄存器，但存在某些冲突（通常所有的方法都是获取指定给1号寄存器的某些变量），特别是涉及到递归的时候。该问题类似于平衡符号的原因在于，方法调用和方法返回基本上类似于开括号和闭括号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当存在方法调用的时候，需要存储的所有重要信息，诸如寄存器的值（对应变量的名字）和返回地址 （它可从程序计数器得到，一般情况是在一个寄存器中）等， 都要以抽象的方法存在“一张纸上”并被置于一个堆（pile）的顶部。然后控制转移到新方法，该方法自由地用它的一些值替代这些寄存器。如果它又进行其它的方法调用，那么它也遵循相同的过 程。当该方法要返回时，它查看堆顶部的那张“纸”并复原所有的寄存器，然后进行返回转移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;显然，所有全部工作均可由一个栈来完成，而这正是在实现递归的每一种程序设计语言中实际发生的事实。所储存的信息或称为活动记录（activation record），或叫做帧栈（stack frame）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在实际计算机中的栈常常是从内存分区的高端向下增长，而在许多非Java系统中是不检测溢出的。失控递归可能导致栈溢出。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 27 Apr 2018 16:21:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy99/p/8965512.html</dc:identifier>
</item>
<item>
<title>VueJs(4)---V-model指令 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8964645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8964645.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;    摘要&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;  &lt;span&gt;限制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      v-model只能用在：&amp;lt;input&amp;gt;    &amp;lt;select&amp;gt;    &amp;lt;textarea&amp;gt;  &amp;lt;components&amp;gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;&lt;span&gt;修饰符&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/forms.html#lazy&quot;&gt;&lt;code&gt;.lazy&lt;/code&gt;&lt;/a&gt; - 取代 &lt;code&gt;input&lt;/code&gt; 监听 &lt;code&gt;change&lt;/code&gt; 事件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/forms.html#number&quot;&gt;&lt;code&gt;.number&lt;/code&gt;&lt;/a&gt; - 输入字符串转为数字&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/forms.html#trim&quot;&gt;&lt;code&gt;.trim&lt;/code&gt;&lt;/a&gt; - 输入首尾空格过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础用法&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  基础用法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;     &lt;span&gt;&lt;strong&gt;&lt;code&gt;v-model&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt; 会忽略所有表单元素的 &lt;span&gt;&lt;code&gt;value&lt;/code&gt;、&lt;code&gt;checked&lt;/code&gt;、&lt;code&gt;selected&lt;/code&gt;&lt;/span&gt; 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 &lt;code&gt;data&lt;/code&gt; 选项中声明初始值。&lt;/p&gt;
&lt;h4 id=&quot;文本&quot;&gt;   &lt;span/&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;edit me&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Message is: {{ message }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-scroll-id=&quot;多行文本&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427214924138-858188279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;多行文本&quot; data-scroll-id=&quot;多行文本&quot;/&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Multiline message is:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;white-space: pre-line;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ message }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;add multiple lines&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427214959864-1031697464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;复选框&quot;/&gt;
&lt;p&gt;      &lt;strong&gt; &lt;span&gt;单个复选框，绑定到布尔值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ checked }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427215026907-1967622037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;多个复选框，绑定到同一个数组&lt;/span&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='example-3'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;jack&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Jack&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;jack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Jack&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;john&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;John&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;john&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;John&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;mike&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Mike&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;mike&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Mike&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Checked names: {{ checkedNames }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427215058643-1284740212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;单选按钮&quot;/&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example-4&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;One&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;picked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;One&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;two&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Two&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;picked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;two&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Two&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Picked: {{ picked }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427215143085-2098280514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;选择框&quot;/&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;单选时&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example-5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;disabled value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Selected: {{ selected }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
new Vue({
  el: '#example-5',
  data: {
    selected: ''
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427215427795-51990162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;       注意&lt;/span&gt;&lt;/strong&gt;：如果 &lt;code&gt;v-model&lt;/code&gt; 表达式的初始值未能匹配任何选项，&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;    多选时 (绑定到一个数组)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt; multiple style&lt;/span&gt;&lt;span&gt;=&quot;width: 50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Selected: {{ selected }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427215717645-1465050756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    用 &lt;code&gt;v-for&lt;/code&gt; 渲染的动态选项&lt;/span&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;option in options&quot;&lt;/span&gt;&lt;span&gt; v-bind:value&lt;/span&gt;&lt;span&gt;=&quot;option.value&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{ option.text }}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Selected: {{ selected }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427220203064-2103277948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;值绑定&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 对于单选按钮，复选框及选择框的选项，&lt;code&gt;v-model&lt;/code&gt; 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--看到这里上面的你都应该明白了--&amp;gt;&lt;br/&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 当选中时，`picked` 为字符串 &quot;a&quot; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;picked&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;a&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; `toggle` 为 true 或 false &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;toggle&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;abc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ABC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 思考：&lt;/strong&gt;&lt;/span&gt;有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 &lt;code&gt;v-bind&lt;/code&gt; 实现，并且这个属性的值可以不是字符串。&lt;/p&gt;

&lt;h2 id=&quot;修饰符&quot;&gt;&lt;span&gt;修饰符&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;lazy&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt; &lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt; &lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;code/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;     在默认情况下，&lt;code&gt;v-model&lt;/code&gt; 在每次 &lt;code&gt;input&lt;/code&gt; 事件触发后将输入框的值与数据进行同步 (除了&lt;a href=&quot;https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip&quot;&gt;上述&lt;/a&gt;输入法组合文字时)。你可以添加 &lt;code&gt;lazy&lt;/code&gt; 修饰符，从而转变为使用 &lt;code&gt;change&lt;/code&gt; 事件进行同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在“change”时而非“input”时更新 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model.lazy&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;number&quot;&gt;&lt;span&gt;&lt;code&gt; &lt;span&gt; &lt;a title=&quot;.number&quot; href=&quot;https://cn.vuejs.org/v2/guide/forms.html#number&quot; data-scroll=&quot;&quot;&gt;&lt;span&gt;.number&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  如果想自动将用户的输入值转为数值类型，可以给&lt;span&gt; &lt;code&gt;v-model&lt;/code&gt; &lt;span&gt;添加 &lt;/span&gt;&lt;code&gt;number&lt;/code&gt;&lt;/span&gt; 修饰符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model.number&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;number&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;这通常很有用，因为即使在 type=&quot;number&quot; 时，HTML 输入元素的值也总会返回字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;我想它主要是用来限制用户输入的时候只能是数字&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;trim&quot;&gt;&lt;span&gt;&lt;code&gt; &lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt; &lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt;&lt;a title=&quot;.trim&quot; href=&quot;https://cn.vuejs.org/v2/guide/forms.html#trim&quot; data-scroll=&quot;&quot;&gt;&lt;span&gt;.trim&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符-&amp;gt;
&lt;span&gt;&amp;lt;input v-model.trim=&quot;msg&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;h4 id=&quot;使用自定义事件的表单输入组件&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;p&gt;     讲这个前，首先我们要明白的是：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;something&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;它其实是个语法糖，而真正的其实如下：&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input
  &lt;/span&gt;&lt;span&gt;v-bind:value&lt;/span&gt;&lt;span&gt;=&quot;something&quot;&lt;/span&gt;&lt;span&gt;
  v-on:input&lt;/span&gt;&lt;span&gt;=&quot;something = $event.target.value&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;所以在组件中使用时，它相当于下面的简写&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;custom-input
  &lt;/span&gt;&lt;span&gt;v-bind:value&lt;/span&gt;&lt;span&gt;=&quot;something&quot;&lt;/span&gt;&lt;span&gt;
  v-on:input&lt;/span&gt;&lt;span&gt;=&quot;something = arguments[0]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;custom-input&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    看了上面我们就明白，父主键是无法直接向子主键传值的，它其实绑定了父主键的click事件。&lt;/p&gt;
&lt;p&gt;    所以要让组件的 &lt;code&gt;v-model&lt;/code&gt; 生效，它应该 (从 2.2.0 起是可配置的)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;接受一个 &lt;code&gt;value&lt;/code&gt; prop&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在有新的值时触发 &lt;code&gt;input&lt;/code&gt; 事件并将新值作为参数&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;案例：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;   货币输入的自定义控件，限制最多小数点保留两位&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;currency-input v-model=&quot;price&quot;&amp;gt;&amp;lt;/currency-input&amp;gt;&lt;br/&gt;Vue.component('currency-input'&lt;span&gt;, {
  template: &lt;/span&gt;'&lt;span&gt;\
    &amp;lt;span&amp;gt;\
      $\
      &amp;lt;input\
        ref=&quot;input&quot;\
        v-bind:value=&quot;value&quot;\
        v-on:input=&quot;updateValue($event.target.value)&quot;\
      &amp;gt;\
    &amp;lt;/span&amp;gt;\
  &lt;/span&gt;'&lt;span&gt;,
  props: [&lt;/span&gt;'value'&lt;span&gt;],
  methods: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制&lt;/span&gt;
    updateValue: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formattedValue =&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除两侧的空格符&lt;/span&gt;
&lt;span&gt;        .trim()
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保留 2 位小数&lt;/span&gt;
&lt;span&gt;        .slice(
          &lt;/span&gt;0&lt;span&gt;,
          value.indexOf(&lt;/span&gt;'.') === -1
            ?&lt;span&gt; value.length
            : value.indexOf(&lt;/span&gt;'.') + 3&lt;span&gt;
        )
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果值尚不合规，则手动覆盖为合规的值&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (formattedValue !==&lt;span&gt; value) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.input.value =&lt;span&gt; formattedValue
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 input 事件带出数值&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.$emit('input'&lt;span&gt;, Number(formattedValue))
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     最后结果，就你可以没有小数，但如果有小数后面最后只能有两位小数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427230039347-1753121984.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上面案例我是看官方API有三点不理解，希望知道的能留言告诉我，一点也是好的，万分感谢！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1：这里为什么要加反斜线？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2：ref=&quot;input&quot; 具体用意是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3：this.$emit('input', Number(formattedValue)) 为什么还要带出值？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面案例我理解的：&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;  &lt;strong&gt;&lt;span&gt;  slice方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180427233730702-404364636.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;$emit理解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  关于$emit的用法&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;1、父组件可以使用 props 把数据传给子组件。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt; 2、子组件可以使用 $emit 触发父组件的自定义事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;子组件&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;  
  &amp;lt;div class=&quot;train-city&quot;&amp;gt;  
    &amp;lt;span @click='select(`大连`)'&amp;gt;大连&amp;lt;/span&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/template&amp;gt;  
&amp;lt;script&amp;gt;&lt;span&gt;  
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {  
  name:&lt;/span&gt;'trainCity'&lt;span&gt;,  
  methods:{  
    select(val) {  
      let data &lt;/span&gt;=&lt;span&gt; {  
        cityname: val  
      };  
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('showCityName',data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;select事件触发后，自动触发showCityName事件  &lt;/span&gt;
&lt;span&gt;    }  
  }  
}  
&lt;/span&gt;&amp;lt;/script&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;父组件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;  
    &amp;lt;trainCity @showCityName=&quot;updateCity&quot; :index=&quot;goOrtoCity&quot;&amp;gt;&amp;lt;/trainCity&amp;gt; //监听子组件的showCityName事件。  
&amp;lt;template&amp;gt;  
&amp;lt;script&amp;gt;&lt;span&gt;  
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {  
  name:&lt;/span&gt;'index'&lt;span&gt;,  
  data () {  
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {  
      toCity:&lt;/span&gt;&quot;北京&quot;&lt;span&gt;  
    }  
  }  
  methods:{  
    updateCity(data){&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发子组件城市选择-选择城市的事件    &lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.toCity = data.cityname;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变了父组件的值  &lt;/span&gt;
      console.log('toCity:'+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toCity)        
    }  
  }  
}  
&lt;/span&gt;&amp;lt;/script&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结果为&lt;/strong&gt;&lt;/span&gt;：toCity: 大连&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;在找个例子：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;counter-event-example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ total }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button-counter &lt;/span&gt;&lt;span&gt;v-on:increment1&lt;/span&gt;&lt;span&gt;=&quot;incrementTotal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button-counter &lt;/span&gt;&lt;span&gt;v-on:increment2&lt;/span&gt;&lt;span&gt;=&quot;incrementTotal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;vue/vue.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{
            template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button v-on:click=&quot;increment&quot;&amp;gt;{{ counter }}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            data:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {counter: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;组件数据就是这样的，函数式的，请注意&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
            },
            methods:{
                increment:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.counter &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$emit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;increment1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,[&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kkk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;$emit&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#counter-event-example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            data:{
                total:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            },
            methods:{
                incrementTotal:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.total &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    console.log(e);
                }
            }
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看组件 button-counter&lt;/p&gt;
&lt;p&gt;绑定了事件click————&amp;gt;increment&lt;/p&gt;
&lt;p&gt;然后 this.counter += 1; this.$emit('increment1',[12,'kkk']);&lt;/p&gt;
&lt;p&gt;这边就是触发事件 increment1，参考文献里面有点乱，这边是不是清晰多了&lt;/p&gt;
&lt;p&gt;然后 &amp;lt;button-counter v-on:increment1=&quot;incrementTotal&quot;&amp;gt;&amp;lt;/button-counter&amp;gt; &lt;/p&gt;
&lt;p&gt;v-on相当于监听吧，就触发 incrementTotal&lt;/p&gt;
&lt;p&gt;输出// [12, &quot;kkk&quot;]&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;strong&gt;中尉【13】&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;


</description>
<pubDate>Fri, 27 Apr 2018 15:55:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8964645.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(三)  表达式的！(绑定表达式)与 #(非绑定表达式) - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/8947726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/8947726.html</guid>
<description>&lt;p&gt;在salesforce的classic中，我们使用{!expresion}在前台页面展示信息，在lightning中，上一篇我们也提及了，如果展示attribute的值，可以使用{!v.expresion}展示信息。&lt;/p&gt;
&lt;p&gt;lightning在component中解析动态值的时候，会将{!} 这个里面的变量进行动态的解析以及展示。当然这个变量可以是基础类型，自定义类型，数组集合等等，当然如果表达式为空字符串或者是空格则不会解析。偶尔特殊的要求为需要输出‘{!}’这个字符串，官方文档说可以使用&amp;lt;aura:text/&amp;gt;进行展示，因为这个标签不会将‘{!’作为头进行解析。当然，不要被这句话所欺骗，正常的理解应该为当value的值非tag或者attribute值的情况下，才会被解析成平滑的字符串。这里做个demo看一下渲染效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;testValue&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {!v.test}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.test}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {!}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.test2}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!test2}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;demo中分了几种情况：输出正常的attribute值、通过aura:text输出attribute值、输出{!}值、输出一个不存在的属性的值、输出一个不存在的变量的值。结果展示如下图所示。&lt;/p&gt;
&lt;p&gt;通过结果我们可以看出来，aura:text并不是不解析{!开头的内容，而是如果{!}不包含任何表达式情况下，会默认作为文本进行输出，其实不是用aura:text 直接输出{!}也可以作为文本进行输出。如果解析的内容不存在情况下，则默认返回null。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180425221403681-2092725380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用{!}方式标签仅能用于在.cmp 以及.app文件中，即只能用在lightning component以及lightning application中。&lt;/p&gt;
&lt;p&gt;表达式除了简单的通过{!v.attribute} 展示attribute的内容或者{!123}等展示字面内容的内容外，还可以使用条件表达式这种方式展示内容，通常有两种常用的方式：三目运算和使用&amp;lt;aura:if&amp;gt;。&lt;/p&gt;
&lt;p&gt;三目运算：下面的代码为当attribute xxx的值为xxx的情况下，这个classs设置为'xxx'，否则，class为空。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;{!v.xxx == 'xxx' ? 'xxx' : ''}&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;test &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &amp;lt;aura:if&amp;gt;：此标签通常和aura:set一起用。当aura:if判断部分为true，显示aura:if为true的逻辑，否则使用aura:set设置attribute为else，走false的逻辑。下面的例子为如果有edit权限则展示Edit的Button，否则展示'You can't edit this'的文字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;edit&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Boolean&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:if &lt;/span&gt;&lt;span&gt;isTrue&lt;/span&gt;&lt;span&gt;=&quot;{!v.edit}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ui:button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Edit&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:set &lt;/span&gt;&lt;span&gt;attribute&lt;/span&gt;&lt;span&gt;=&quot;else&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;       You can’t edit this.
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们在项目中会经常用到lightning component中嵌套其他的子的lightning component情况，比如列表中包含&amp;lt;aura:iterator&amp;gt; 标签嵌套item的lightning component从而实现一个自定义列表展示。&lt;/p&gt;
&lt;p&gt;嵌套lightning component就会涉及到attribute 赋值的部分，针对attribute赋值，可以赋值一个写死的值，比如赋值‘123’等。lightning也提供了两种动态方式赋值：{!attributeValue}以及{#attributeValue}。两者赋值区别还是很大的，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.   !方式：&lt;/strong&gt;此种方式又可以理解为绑定的表达式，即对attribute的赋值非一次性的，改变会贯穿着始终。子项如果修改了这个attribute的赋值，也会影响到父中此attribute的值；同样的，如果父中对此attribute有更改，也会作用到子component中的引用上。&lt;/p&gt;
&lt;p&gt;这里做一个例子：&lt;/p&gt;
&lt;p&gt;1.boundSonComponent.cmp：声明一个attribute名称为sonAttribute，使用一个aura:text展示这个值，点击按钮后更新这个sonAttribute的value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sonAttribute&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    son attribute : &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.sonAttribute}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.handleSonClick}&quot;&lt;/span&gt;&lt;span&gt; label&lt;/span&gt;&lt;span&gt;=&quot;son button&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.boundSonComponentController.js : 更新sonAttribute的value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    handleSonClick : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sonAttributeValue = 'Updated Son Attribute'&lt;span&gt;;
        component.set(&lt;/span&gt;'v.sonAttribute'&lt;span&gt;, sonAttributeValue);
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.boundParentComponent.cmp ：声明一个attribute名称为parentAttribute,展示此attribute的值并且提供按钮可以修改值，在这个基础上引入了一个boundSonComponent，并且将parentAttribute的值传给了sonAttribute。注意，这里通过‘！’方式进行传递值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;parentAttribute&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;parentAttributeValue&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    parentAttribute : &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.parentAttribute}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;parent button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.handleParentClick}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:boundSonComponent &lt;/span&gt;&lt;span&gt;sonAttribute &lt;/span&gt;&lt;span&gt;= '{!v.parentAttribute}'&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.boundParentComponentController.js ：更新parentAttribute的value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    handleParentClick : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        component.set(&lt;/span&gt;'v.parentAttribute', 'updated parent attribute'&lt;span&gt;);
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 因为lightning无法直接运行lightning:component，所以需要将lightning:component放在 lightning app builder视图中或者放在Lightning application中，lightning app builder 可以重新定义 page layout，分为App Page, Home Page 和Record Page。这个和page layout 很像，需要注意的一点为显示在不同类型的页面需要实现不同的接口，具体可以查看上一篇内容，感兴趣的可以自己玩一玩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427214430357-929209396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;demo以创建Lightning application为主。&lt;/p&gt;
&lt;p&gt;5.创建boundApplication.app 用来包含boundParentComponent从而展示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:boundParentComponent&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行lightning application可以通过developer console -&amp;gt; File -&amp;gt; Opening Lighting Resource 找到此bundle，然后Open Selected，打开后点击Preview便可以看到显示方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427221352979-1295092137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.默认进来情况：&lt;/strong&gt;因为parentAttribute的值作为了sonAttribute的值，所以二者显示相同的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427224547544-1652821582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 2.点击 parent button：&lt;/strong&gt;点击parent button后，后台会更新parentAttribute的value。由于sonAttribute传递的值通过parentAttribute值传递，并且是通过！（bound）方式，所以当更改了parentAttribute后，sonAttribute也同样的改变成了parentAttribute的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427224638807-181477913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;3. 点击son button：&lt;/strong&gt;点击son button后，后台会更新sonAttribute的值。由于sonAttribute是通过parentAttribute值传递，并且是通过！（bound）方式，所以当更改了sonAttribute后，parentAttribute也同样的受到了改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427224716781-1390897220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这种操作结果可能让人感到意外，因为我们有的时候只是想将attribute的值作为一个一次性初始化的值传递给子的component 的attribute，针对父或者针对子的改动并不希望后期在影响当前component外的其他的父或者子的component attribute。接下来的方式即可以做到非绑定表达式，即使用 # 方式进行值的传递。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.   # 方式：&lt;/strong&gt;可以理解成非绑定的表达式，即有嵌套的lightning component,父对子传值仅初始化有效，后期父对这个attribute value的变化不会影响到子，同样子对这个attribute value的变化同样不会影响到父。&lt;/p&gt;
&lt;p&gt; 在这里重用boundSonComponent,新建unboundParentComponent,使用#方式传递值。&lt;/p&gt;
&lt;p&gt;1.unboundParentComponent:和boundParentComponent唯一的区别为在对boundSonComponent传值的时候，将! 修改成了 # . &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;parentAttribute&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;parentAttributeValue&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    parentAttribute : &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.parentAttribute}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;parent button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.handleParentClick}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:boundSonComponent &lt;/span&gt;&lt;span&gt;sonAttribute &lt;/span&gt;&lt;span&gt;= '{#v.parentAttribute}'&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果展示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.当点击parent button时&lt;/strong&gt;，仅更改了parentAttribute的值，sonAttribute值不会受到影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427233028026-2022116234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.当点击son button时&lt;/strong&gt;，金更改了sonAttribute的值，parentAttribute的值同样不会受到影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427233151729-1880459600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 通过上述的两个例子的展示结果可以看出来：对子component的attribute进行动态赋值时， ！(绑定表达式) 与 #(非绑定表达式)差距还是很大的。使用！方式关系贯穿始终，无论父还是子对attribute改动都会对其关联的受到影响。使用#方式仅在初始化时有效，后期针对引用的attribute的值进行任何修改，都不会同步修改引用的地方。具体使用哪种方式看项目中用到的场景，同步操作则使用！方式传值；仅需要其传值作为初始化，后期改动无关则选择#方式传值。篇中有错误地方欢迎指出，有问题欢迎留言。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 15:50:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/8947726.html</dc:identifier>
</item>
<item>
<title>Java不走弯路教程（1.环境搭建） - java123.vip</title>
<link>http://www.cnblogs.com/java123vip/p/8965182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java123vip/p/8965182.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.环境搭建&lt;/strong&gt;&lt;br/&gt;在开始写第一个Java程序之前，我们需要做一些简单的准备工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 还记得DOS吗&lt;/strong&gt;&lt;br/&gt;我们可以通过图形界面来操作我们的电脑。但作为程序员，你首先需要学会用命令行的方式来操作电脑，因为不是所有的电脑都提供图形界面的。&lt;br/&gt;Windows环境下可以通过DOS来执行命令。&lt;br/&gt;你只需要记住大概5个命令，即可完成电脑的基本操作。&lt;/p&gt;
&lt;p&gt;我们首先启动DOS环境：在文件浏览器的地址栏中输入cmd，回车，如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232520433-1179899161.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;&lt;p&gt;光标左边显示的是当前所在目录。&lt;br/&gt;本教程实例均在C盘下操作，所以如果不是C盘，输入c:回车，切换到C盘下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232634248-1175003207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来我们要学习5个命令：&lt;br/&gt;目录创建&lt;br/&gt;目录切换&lt;br/&gt;查看当前目录下文件/文件夹列表&lt;br/&gt;打开指定文件&lt;br/&gt;帮助&lt;/p&gt;&lt;p&gt;注：目录和文件夹是一个概念，后续将不再说明&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1.目录创建&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：md 目录名&lt;br/&gt;(Make Directory的缩写)&lt;br/&gt;注：命令之间用空格分隔，后续将不再说明。&lt;br/&gt;我们要创建的目录结构如下：&lt;br/&gt;c:&lt;br/&gt;-work&lt;br/&gt;-001&lt;br/&gt;-002&lt;br/&gt;在DOS窗口输入如下命令来创建上述目录&lt;br/&gt;md c:\work&lt;br/&gt;md c:\work\001&lt;br/&gt;md c:\work\002&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232720694-483980708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2.目录切换&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：cd 目录名&lt;br/&gt;(Change Directory的缩写)&lt;br/&gt;我们输入如下命令进入刚才创建的目录下&lt;br/&gt;cd c:\work&lt;br/&gt;可以看到当前目录变成了c:\work&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232739346-1341479782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;3.查看当前目录下文件/文件夹列表&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：dir&lt;br/&gt;(Directory的缩写)&lt;br/&gt;输入dir显示如下&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232801132-1192125792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有四个文件夹分别是.,..,001,002&lt;br/&gt;其中001,002为我们刚才创建的文件夹&lt;br/&gt;.为当前目录&lt;br/&gt;..为上一级目录&lt;/p&gt;&lt;p&gt;我们输入cd .&lt;br/&gt;可以看到还是在当前目录下，&lt;br/&gt;输入cd ..&lt;br/&gt;可以看到转到了上一级目录&lt;br/&gt;输入cd work\001&lt;br/&gt;可以看到转到了c:\work\001下&lt;br/&gt;输入cd ..\..\&lt;br/&gt;可以看到转到了上上级目录下&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232833511-1054585301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;4.打开指定文件&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：more&lt;br/&gt;我们在Window下创建文件a.txt，内容为abc，放到c:\work目录下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232853057-1713954000.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DOS环境下进入work目录输入后输入如下命令&lt;br/&gt;more a.txt&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232915753-1613339020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到显示了文件内容&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;5.help&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;输入help,则显示DOS环境下所有支持的命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233352754-1634278352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不知道命令的使用方法，则输入命令名称 /? 即显示该命令的使用方法。&lt;br/&gt;比如 dir /?&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233404110-1366952357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动某个程序&lt;br/&gt;在Window下我们双击a.txt可以启动记事本来显示文件内容。&lt;br/&gt;在DOS下我们也可以实现上述操作：&lt;br/&gt;输入notepad.exe a.txt&lt;br/&gt;为了简单，我们通常省略.exe&lt;br/&gt;notepad a.txt&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233421625-1491586522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们在DOS下启动了记事本来打开a.txt文件&lt;br/&gt;其中notepad为程序名，a.txt为给程序传入的参数，如果不传任何参数，则默认打开程序&lt;br/&gt;notepad&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233442189-1688392160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;WHY&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;现在我们基本上掌握了DOS的操作。&lt;br/&gt;开动脑筋想一想，为什么输入notepad后，DOS可以启动记事本程序？&lt;br/&gt;是的，DOS需要知道notepad.exe的位置，然后启动它。&lt;/p&gt;&lt;p&gt;我们看一下DOS是否知道记事本程序在哪里，输入where notepad回车，如下图&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233508980-27516028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，也就是DOS知道notepad记事本程序位于如下路径下：&lt;br/&gt;C:\Windows\System32\notepad.exe&lt;/p&gt;&lt;p&gt;那么这种程序坐在的路径是在哪里设置的呢？&lt;/p&gt;&lt;p&gt;在DOS环境下，有个变量名叫PATH，它存储了程序的路径信息。&lt;br/&gt;我们输入如下命令来查看变量PATH的值：（echo命令可以输出指定变量的内容，其中变量名用%括起来）&lt;br/&gt;echo %PATH%&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233532987-1894796092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到C:\Windows\system32在其中。&lt;br/&gt;也就是说在DOS启动一个程序时，依次查找变量PATH下面的相应文件，如果找到则执行该文件，因为是启动环境相关，所以我们可以称这个为环境变量。&lt;/p&gt;&lt;p&gt;那么，如何增加或修改环境变量PATH的值？&lt;br/&gt;在Windows中可以右键单击我的电脑-〉系统属性-〉高级系统设置-&amp;gt;环境变量，点击新建或双击已有的环境变量来修改或增加新的环境变量。&lt;br/&gt;环境变量之间用分号来分隔。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233553039-1416338205.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233600393-1583874310.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们掌握了写Java程序所必备的DOS基础，请大家熟记于心。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.2 Java环境搭建&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在上一节我们学习了在DOS环境下启动指定程序的方法，在本节中我们将在DOS环境下启动Java程序。&lt;/p&gt;&lt;p&gt;首先，和其他Windos程序一样，我们要安装Java程序，在Oracle的官方网站上下载Java程序到本地，和其他程序一样双击完成安装，注意记下程序安装的路径。&lt;br/&gt;我安装在C:\Program Files\Java\jdk1.8.0_161下&lt;/p&gt;&lt;p&gt;验证安装是否成功：&lt;br/&gt;在DOS下输入如下命令（请自行替换为自己的安装目录，以后略）&lt;br/&gt;C:\Program Files\Java\jdk1.8.0_161\bin\java -version&lt;br/&gt;C:\Program Files\Java\jdk1.8.0_161\bin\javac -version&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233655636-1047024382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如能正确地显示版本号，则表示安装成功。&lt;br/&gt;上述java,javac命令存在于安装目录的bin目录下，其中javac为编译java程序命令，java为运行java程序命令。&lt;br/&gt;但如果每次运行都要输入全路径的话，很不方便，我们可以向上节中运行记事本程序一样，在任意目录下，直接输入java或javac即可。&lt;br/&gt;是的，我们需要把安装路径加入到环境变量PATH中。&lt;/p&gt;&lt;p&gt;新版本的JDK会自动配置上述PATH变量，如果你用的是旧版本的JDK，在配置PATH的同时，还需要配置CLASSPATH环境变量。&lt;br/&gt;在java的编译过程中，会查找一个名为CLASSPATH的环境变量来完成Java的编译，该环境变量中应该包含Java编译所需要的类文件。&lt;br/&gt;所以我们还需要添加如下环境变量：&lt;br/&gt;变量名：CLASSPATH&lt;br/&gt;变量值：.;C:\Program Files\Java\jdk1.8.0_161\lib\tools.jar&lt;br/&gt;其中.表示记载程序执行的当前目录下的类文件，tools.jar表示加载java的系统类文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233727025-757110381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233737497-1434518022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233718460-1224843150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新启动DOS环境，输入java -version和javac -version正确的显示版本号，则完成Java的环境搭建。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233816750-1883212177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：虽然新版本不需要上述配置，但建议读者还是按上述方法自己做一遍，千万不要省略这个步骤，这是启动Java程序的第一步。&lt;br/&gt;因为在实际环境中你会遇到各种版本的JDK，好多启动加载问题都是环境变量的不正确造成的。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;版权声明：本教程版权归java123.vip所有，禁止任何形式的转载与引用。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 15:42:00 +0000</pubDate>
<dc:creator>java123.vip</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java123vip/p/8965182.html</dc:identifier>
</item>
<item>
<title>设计模式之中介者模式（Mediator ） - chencarl</title>
<link>http://www.cnblogs.com/chencarl/p/8965150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chencarl/p/8965150.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;中介者模式是关于数据交互的设计模式，该模式的核心是一个中介者对象，负责协调一系列对象之间的不同的数据请求，这一系列对象成为同事类。如房产中介（简直不想提它），买房的卖房的，租房的放租的都到房产中介那里去登记。如果有卖房的就会通知买房的去买房，如果有放租的就会通知租房的去租房。所有的事物都是通过中介进行通知转换，这样就形成了一个典型的星型结构，说道星型结构，网络中的交换机路由器不就是个大大的中介者么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;作用&quot;&gt;作用&lt;/h2&gt;
&lt;p&gt;中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使它们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。&lt;/p&gt;
&lt;h2 id=&quot;类视图&quot;&gt;类视图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1183944/201804/1183944-20180427232402716-1594274406.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;中介者模式为拍卖行角色，负责买家、卖家和货币转换的协调工作，其中印度买家和法国买家想拍卖美国卖家的东西，印度使用的是卢比，法国使用的是美元，而美国使用的是美元，所有的出价都要以美元进行结算；这样就需要拍卖行来协调进行价格换算，拍卖竞价等工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//头文件mediator.h
#include &amp;lt;string&amp;gt;

class  Mediator;
 
class Colleage //同事类
{
public:
    Colleage(Mediator* md);
protected:
    Mediator *m_mediator;
};

class IndianBuyer: public Colleage
{
public:
    IndianBuyer(Mediator* md);
    void setTotalMoney(float fall);
    int Purchase(float bid);
private:
    float m_total_money; //买家的心理价位
};

class FrenchBuyer: public Colleage
{
public:
    FrenchBuyer(Mediator* md);
    void setTotalMoney(float fall);
    int Purchase(float bid);
private:
    float m_total_money;
};

class AmericanSeller: public Colleage
{
public:
    AmericanSeller(Mediator* md);
    void SetWantPrice(float price);
    bool IsBidAccept(float bidInDollars);
private:
    float m_priceInDollars; //卖家的心理价位
};

class DollorConver: public Colleage
{
public:
    DollorConver(Mediator* md);
    float ConverToDollars(float bid, std::string strName);
private:
    float ConverRupeetoDollar(float bid);
    float ConverEurotoDollar(float bid);
private:
    float dollor_unit; //美元换算比例
    float euro_unit;  //欧元换算比例
    float rupee_unit;//卢比换算比例
};

class Mediator
{
public:
    Mediator();
    void RegisterIndianBuyer(IndianBuyer* buyer);
    void RegisterFrenchBuyer(FrenchBuyer* buyer);
    void RegisterAmericanSeller(AmericanSeller* seller);
    void RegisterDollorConver(DollorConver* conver);
    bool placeBid(float bid,std::string strName);
private:
    IndianBuyer* m_pIndian;
    FrenchBuyer* m_pFrench;
    AmericanSeller* m_pAmerican;
    DollorConver* m_pConver;

};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mediator.cpp&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;mediator.h&quot;
using namespace std;

Colleage::Colleage(Mediator* md):m_mediator(md)
{
}
IndianBuyer::IndianBuyer(Mediator* md):Colleage(md),m_total_money(-1){
    m_mediator-&amp;gt;RegisterIndianBuyer(this);
}
void IndianBuyer::setTotalMoney(float fall)
{
    m_total_money = fall;
}
int IndianBuyer::Purchase(float bid)
{
    //价格合适就出价一次
    if (m_total_money&amp;lt;0 || bid&amp;lt;= m_total_money)
    {
       return (int)m_mediator-&amp;gt;placeBid(bid,&quot;RUPEE&quot;); 
    }
    else
    {
        return 2;//价格太高了  不要啦
    }
    
}

FrenchBuyer::FrenchBuyer(Mediator* md):Colleage(md),m_total_money(-1){
    m_mediator-&amp;gt;RegisterFrenchBuyer(this);
}
void FrenchBuyer::setTotalMoney(float fall)
{
    m_total_money = fall;
}
int FrenchBuyer::Purchase(float bid)
{
    if (m_total_money&amp;lt;0 || bid&amp;lt;= m_total_money)
    {
       return (int)m_mediator-&amp;gt;placeBid(bid,&quot;EURO&quot;); 
    }
    else
    {
        return 2;
    }
    
}

AmericanSeller::AmericanSeller(Mediator* md):Colleage(md),m_priceInDollars(0){
    m_mediator-&amp;gt;RegisterAmericanSeller(this);
}
void AmericanSeller::SetWantPrice(float price)
{
    m_priceInDollars = price;
}
bool AmericanSeller::IsBidAccept(float bidInDollars)
{
    if (bidInDollars&amp;gt;=m_priceInDollars)
    {
       //当遇到价格增长时记录最高的价格，没有人超过这个价格就按照这个价格出售
        m_priceInDollars = bidInDollars;
        return true;
    }
    return false;
}

DollorConver::DollorConver(Mediator* md):Colleage(md)
,dollor_unit(1.0),euro_unit(0.7),rupee_unit(45.0){
    m_mediator-&amp;gt;RegisterDollorConver(this);
}
float DollorConver::ConverToDollars(float bid, std::string strName)
{
    if (strName.compare(&quot;RUPEE&quot;)==0)
    {
        return ConverRupeetoDollar(bid);
    }
    else
    {
        return ConverEurotoDollar(bid);
    }
}
float DollorConver::ConverRupeetoDollar(float bid)
{
    return bid*(dollor_unit/rupee_unit);
}
float DollorConver::ConverEurotoDollar(float bid)
{
    return bid*(dollor_unit/euro_unit);
}


Mediator::Mediator():m_pIndian(NULL),m_pFrench(NULL)
,m_pAmerican(NULL),m_pConver(NULL){

}
void Mediator::RegisterIndianBuyer(IndianBuyer* buyer)
{
    m_pIndian = buyer;
}
void Mediator::RegisterFrenchBuyer(FrenchBuyer* buyer)
{
    m_pFrench = buyer;
}
void Mediator::RegisterAmericanSeller(AmericanSeller* seller)
{
    m_pAmerican = seller;
}
void Mediator::RegisterDollorConver(DollorConver* conver)
{
    m_pConver = conver;
}
bool Mediator::placeBid(float bid,std::string strName)
{
    float dollars =  m_pConver-&amp;gt;ConverToDollars(bid,strName);
    return m_pAmerican-&amp;gt;IsBidAccept(dollars);
}


int main(int argc,char *argv[])
{
    Mediator mediatior;

    IndianBuyer indian(&amp;amp;mediatior);
    FrenchBuyer french(&amp;amp;mediatior);
    AmericanSeller american(&amp;amp;mediatior);
    DollorConver conver(&amp;amp;mediatior);
    
    indian.setTotalMoney(6000);
    french.setTotalMoney(100);

    american.SetWantPrice(50);
    
    int  nIndian = 0;
    int  nFrench = 0;
    float IndianBid = 2000;
    float FrenchBid = 30;
    //一轮一轮进行出价，当有一个出不起的时候，就结束竞价。
    while(nIndian+nFrench&amp;lt;=2)
    {
        do{
            nIndian = indian.Purchase(IndianBid);
            IndianBid+=100;
            if (nIndian == 1)
            {
                cout&amp;lt;&amp;lt;&quot;indian purchase : &quot;&amp;lt;&amp;lt; IndianBid &amp;lt;&amp;lt;endl;
            }
            
        }
        while(nIndian==0);

        do{
            nFrench = french.Purchase(FrenchBid);
            FrenchBid+=1.5;
            if (nFrench == 1)
            {
                cout&amp;lt;&amp;lt;&quot;french purchase : &quot;&amp;lt;&amp;lt; FrenchBid &amp;lt;&amp;lt;endl;
            }
        }
        while(nFrench==0);

    }

    return 0;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们开始任何产品研发的时候总会有一些类，这些类会使用到之前产品的研发成果，随着功能的增加，逻辑会变得更加复杂，我们会添加更多的类和之前的类互相作用，知道难以维护所有的代码。中介者模式关心的就是这个问题，它会使代码更容易维护。它能够实现类之间的松散耦合。只有中介者这一个类知道所有的类，其他类只需要与中介者进行交互即可，当然更加集中的控制也会带来中枢的庞大，还是需要避免过度的集成。&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;一组对象使用了标准的通信方式，但整体通信的连接都非常复杂，由此产生的相互依赖的结构导致系统难以结构化，也很难理解；&lt;/li&gt;
&lt;li&gt;由于对象之间的通信和相互引用，导致对象难以重用。&lt;/li&gt;
&lt;li&gt;分布于对个类中间的行为能够统一定制化，而无需创建过多的子类。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 27 Apr 2018 15:25:00 +0000</pubDate>
<dc:creator>chencarl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chencarl/p/8965150.html</dc:identifier>
</item>
<item>
<title>Microsoft Visual Studio 2017 编译最新版 libuv 1.x - 9571</title>
<link>http://www.cnblogs.com/e9571/p/8965118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/e9571/p/8965118.html</guid>
<description>

&lt;p&gt;步骤很简单&lt;/p&gt;
&lt;p&gt;1 下载最新版的 libuv （地址：https://github.com/libuv/libuv）&lt;/p&gt;
&lt;p&gt;2 安装Git，Python 2.7 ，cmake（这里使用的是 3.11.0-win64-x64 版本）并且添加到环境变量，也就是直接敲命令，git，python，cmake，系统提示让需要输入参数&lt;/p&gt;
&lt;p&gt;3 使用 Microsoft Visual Studio 2017 （15.4.4 版本）命令行工具进入到文件的解压目录&lt;/p&gt;
&lt;p&gt;4 打开科学上网工具，在浏览器中输入 Google，确保能正确访问 Google（因为要从 Google Source 下载 GYP）&lt;/p&gt;
&lt;p&gt;5 切换到目录下执行 &lt;code class=&quot;language-cmd&quot;&gt;vcbuild.bat x64 &lt;span class=&quot;hljs-keyword&quot;&gt;static，（生成过程中会提示变量转换警告，但是不影响使用）&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-cmd&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;执行完成后使用 Microsoft Visual Studio 2017 打开目录下的工程文件即可&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;最后有图有真相&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;如果不是为了能够调试 XMR 挖矿程序 需要 libuv.pdb 文件，好市民是不是去 从源码编译的，为什么？因为可以直接从官方下载编译好的文件......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;文件名：libuv-x64-v1.18.0.build20&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/365739/201804/365739-20180427231313491-1518253320.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;使用  Microsoft Visual Studio 2015 的编译参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;https://my.oschina.net/fenying/blog/751299&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;2018年4月27日 23:15:15&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 27 Apr 2018 15:16:00 +0000</pubDate>
<dc:creator>9571</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/e9571/p/8965118.html</dc:identifier>
</item>
<item>
<title>linux系统运维面试题简答 - 青竹博客</title>
<link>http://www.cnblogs.com/hystj/p/8965106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hystj/p/8965106.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.     &lt;/strong&gt;&lt;strong&gt;简述常用高可用技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Keepalived：Keepalived是一个保证集群高可用的服务软件，用来防止单点故障，使用VRRP协议实现。在master和backup之间通过master主动降低自己的权值或者backup检测到master出现故障时，backup将会接管master的工作，继续服务。&lt;/p&gt;
&lt;p&gt;HAproxy：HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。&lt;/p&gt;
&lt;p&gt;heartbeat+ DRBD：&lt;/p&gt;
&lt;p&gt;heartbeat （Linux-HA）的工作原理：heartbeat最核心的包括两个部分，心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗 余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未收到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运行在对方主机上的资源或者服务。&lt;/p&gt;
&lt;p&gt;Distributed Replicated Block Device(DRBD)是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。&lt;/p&gt;
&lt;p&gt;数据镜像：实时、透明、同步（所有服务器都成功后返回）、异步（本地服务器成功后返回）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.     &lt;/strong&gt;&lt;strong&gt;简述一下DNS的解析过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。&lt;/p&gt;
&lt;p&gt;2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。&lt;/p&gt;
&lt;p&gt;3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。&lt;/p&gt;
&lt;p&gt;4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。&lt;/p&gt;
&lt;p&gt;5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。&lt;/p&gt;
&lt;p&gt;6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。&lt;/p&gt;
&lt;p&gt;从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.     &lt;/strong&gt;&lt;strong&gt;简单介绍下你使用过的服务器监控软件，并简要说明下它们各自的特点，介绍下常用的监控指标。查看当前Linux系统的状态，如CPU使用，内存使用，负载情况等，查看占用内存最大的5个进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nagios，&lt;/p&gt;
&lt;p&gt;Nagios 可以监控的功能有：&lt;/p&gt;
&lt;p&gt;1、监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）；&lt;/p&gt;
&lt;p&gt;2、监控主机资源（处理器负荷、磁盘利用率等）；&lt;/p&gt;
&lt;p&gt;3、简单地插件设计使得用户可以方便地扩展自己服务的检测方法；&lt;/p&gt;
&lt;p&gt;4、并行服务检查机制；&lt;/p&gt;
&lt;p&gt;5、具备定义网络分层结构的能力，用&quot;parent&quot;主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态；&lt;/p&gt;
&lt;p&gt;6、当服务或主机问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）；&lt;/p&gt;
&lt;p&gt;7、可以定义一些处理程序，使之能够在服务或者主机发生故障时起到预防作用；&lt;/p&gt;
&lt;p&gt;8、自动的日志滚动功能；&lt;/p&gt;
&lt;p&gt;9、可以支持并实现对主机的冗余监控；&lt;/p&gt;
&lt;p&gt;10、可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等；&lt;/p&gt;
&lt;p&gt;11、可以通过手机查看系统监控信息；&lt;/p&gt;
&lt;p&gt;12、可指定自定义的事件处理控制器；&lt;/p&gt;
&lt;p&gt;查看当前系统的状态：top&lt;/p&gt;
&lt;p&gt;查看占用内存最大的5个进程：top，然后按M（大写）键。方法二：ps -aux | sort -k4nr | head -5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.     &lt;/strong&gt;&lt;strong&gt;使用Windows服务管理命令开启BEASD的服务，并查看当前建立的连接数，默认端口为80&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动服务：net start BEASD&lt;/p&gt;
&lt;p&gt;如果服务被禁止启动，使用该命令：sc config BEASD=demand(手动)|auto(自动)|disabled（禁用）；sc start BEASD&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.     &lt;/strong&gt;&lt;strong&gt;简述Linux系统的开机启动顺序，查询程序运行级别和修改运行级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;POST加电自检--》MBR引导--》GRUB--》加载内核--》启动init进程--》读取/etc/inittab文件，/etc/init/*.conf文件--》使用/etc/rc.d/rc.sysinit初始化脚本--》执行/etc/rc.d/rc脚本（加载/etc/rc3.d/下所有脚本）--》执行/etc/rc.d/rc.local--》执行/bin/login登录程序&lt;/p&gt;
&lt;p&gt;查询程序运行级别：runlevel&lt;/p&gt;
&lt;p&gt;修改运行级别：init [0123456]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.     &lt;/strong&gt;&lt;strong&gt;简述软链接和硬链接的区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软链接是指创建一个新的文件，block里存放的是被链接文件的文件名指向，软链接的inode与源文件的inode不同，将源文件删除，然后重建，改变了inode，软链接文件仍然有效。&lt;/p&gt;
&lt;p&gt;硬链接是创建一个新的文件名，将它的inode指向源文件的inode，所以硬链接的inode和源文件是相同的，源文件被删除后，硬链接仍然可以有效，。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.     &lt;/strong&gt;&lt;strong&gt;主机A需要给主机B传输一份100G的数据，可以做哪些传输优化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;数据打包压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据分片，同步传输&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增大传输带宽，网络端口聚合&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;8.     &lt;/strong&gt;&lt;strong&gt;简述LVS的工作模式和调度算法，大并发环境推荐架构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作模式：NAT，TUNNEL，DR，FULLNAT&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;rr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;轮询调度（Round-Robin），它将请求依次分配不同的RS节点，也就是在RS节点中均摊请求。这种算法简答，但是只适合于RS节点处理性能相差不大的情况&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;wrr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;加权轮询调度（Weighted  Round-Robin）它将依据不同RS节点的权值分配任务。权值较高的RS将优先获得任务，并且分配到的连接数将比权值较低的RS节点更多。相同权值的RS得到相同数目的连接数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;dh&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;目的地址哈希调度（Destination  Hashing）以目的地址为关键字查找一个静态hash表来获得需要的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;sh&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;源地址哈希调度（Source  Hashing）以源地址为关键字查找一个静态hash表来获得需要的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;lc&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;最小连接数调度（Least-Connection），IPVS表存储了所有的活动的连接。把新的连接请求发送到当前连接数最小的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;wlc&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;加权最小连接数调度（Weighted  Least-Connection）假设各台RS的权值依次为Wi(I=1..n),当前的TCP连接数依次为Ti(I=1..n),依次选取Ti/Wi为最小的RS作为下一个分配的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;lblc&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;基于地址的最小连接数调度（Locality-Based Least-Connection），将来自同一目的地址的请求分配给同一台RS节点，如果这台服务器已满负荷，分配给连接数最小的RS，并以它为下一次分配的首先考虑&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;lblcr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;基于地址带重复最小连接数调度（Locality-Based Least-Connection with Replication），对于某一目的地址，对应的一个RS子集。对此地址请求，为它分配子集中连接数最小RS；如果子集中所有服务器均已满负荷，则从集群中选择一个连接数较小服务器，将它加入到此子集并分配连接；若一定时间内，未被做任何修改，则将子集中负载最大的节点从子集删除&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;SED&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;最短的期望的延迟（Shortest  Expected Delay Scheduling SED）&lt;/p&gt;
&lt;p&gt;基于wlc算法。举例：&lt;/p&gt;
&lt;p&gt;ABC三台机器分别权重123，连接数也分别是123.那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行这样的运算：&lt;/p&gt;
&lt;p&gt;A(1+1)/1&lt;/p&gt;
&lt;p&gt;B(1+2)/2&lt;/p&gt;
&lt;p&gt;C(1+3)/3&lt;/p&gt;
&lt;p&gt;根据运算结果，把连接交给C&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;NQ&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;最少队列调度（Never  Queue Scheduling NQ）&lt;/p&gt;
&lt;p&gt;无需队列。如果RS的连接数=0就直接分配过去，不需要再进行SED运算&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;大并发环境推荐：DR模式，rr调度算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9.     &lt;/strong&gt;&lt;strong&gt;简述TCP三次握手的过程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://s5.51cto.com/wyfs02/M02/8D/9A/wKiom1ii9qjCscn2AAEEMO9NDeg316.jpg-wh_500x0-wm_3-wmp_4-s_1158167094.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;111.jpg&quot; src=&quot;https://s5.51cto.com/wyfs02/M02/8D/9A/wKiom1ii9qjCscn2AAEEMO9NDeg316.jpg-wh_500x0-wm_3-wmp_4-s_1158167094.jpg&quot; alt=&quot;wKiom1ii9qjCscn2AAEEMO9NDeg316.jpg-wh_50&quot;/&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. &lt;/strong&gt;&lt;strong&gt;sed将文件test.txt中的所有”/opt/tmp”改为”/root/tmp”,并删除所有空行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sed -i ‘s#/opt/tmp #/root/tmp #g’test.txt|sed -i ‘/^\s*$/d’&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11. &lt;/strong&gt;&lt;strong&gt;将192.168.16.3这台Windows的server文件夹挂载到linux本地/mnt/server目录，Windows的账户为：administrator，密码为：123456&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、先在windows下面共享需要挂载的目录server。&lt;/p&gt;
&lt;p&gt;2、确保linux与windows是在同一个局域网当中。&lt;/p&gt;
&lt;p&gt;3、在linux下面创建一个需要挂载到的目录/mnt/server。&lt;/p&gt;
&lt;p&gt;4、利用mount命令进行挂载。&lt;/p&gt;
&lt;p&gt;挂载命令：mount -t cifs -o username=administrator,password=123456//192.168.16.3/server /mnt/server&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12. &lt;/strong&gt;&lt;strong&gt;写一个防火墙配置脚本，只允许远程主机访问本机的80端口。（linux iptables）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; a server firewall

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

IPT&lt;/span&gt;=/sbin/&lt;span&gt;iptables

 

#Remove any existing rules

$IPT &lt;/span&gt;-&lt;span&gt;F

$IPT &lt;/span&gt;-&lt;span&gt;X

$IPT &lt;/span&gt;-&lt;span&gt;Z

#setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; firewallpolicy

$IPT &lt;/span&gt;--&lt;span&gt;policy OUTPUT ACCEPT

$IPT &lt;/span&gt;--&lt;span&gt;policy FORWARD DROP

$IPT &lt;/span&gt;-&lt;span&gt;P INPUT DROP

 

#setting &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; loopback &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;

$IPT &lt;/span&gt;-A INPUT -i lo -&lt;span&gt;j ACCEPT

$IPT &lt;/span&gt;-A OUTPUT -o lo -&lt;span&gt;j ACCEPT

 

#accept &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt; port only

$IPT &lt;/span&gt;-A INPUT   -p tcp --dport &lt;span&gt;80&lt;/span&gt; -&lt;span&gt;j ACCEPT

 

#save iptables

&lt;/span&gt;/etc/init.d/iptables save
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;13. &lt;/strong&gt;&lt;strong&gt;编写个shell脚本将/logs目录下3天前的文件转移到/tmp目录下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; to move file &lt;span&gt;3&lt;/span&gt; yearago &lt;span&gt;from&lt;/span&gt; /logs to /&lt;span&gt;tmp

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

 

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

FILE_FROM&lt;/span&gt;=/&lt;span&gt;logs

FILE_TO&lt;/span&gt;=/&lt;span&gt;tmp

DAY_AGO&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;

 

cd $FILE_FROM

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; `find $FILE_FROM-type f -mtime +&lt;span&gt;3&lt;/span&gt;&lt;span&gt;`

   &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;

              /bin/mv $FILE_FROM/$file $FILE_TO/&lt;span&gt;$file

   done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;14. &lt;/strong&gt;&lt;strong&gt;每天1:00备份/var/log目录下前一天的日志文件并存放到当前目录的btslog目录中，并删除15天前的log备份文件，请使用shell脚本完成。（日志格式为：btsvr.log.2016-01-01,打包备份文件格式为：btsvr.log.2016-01-01.tar.gz）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cat bak_logs.sh

#&lt;/span&gt;!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; to backup logs

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

 

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

YESTERDAY&lt;/span&gt;=`date +%F -d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1 day&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`

LOG_DIR&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;log

BAK_DIR&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;btslog

LOG_FILE&lt;/span&gt;=&lt;span&gt;btsvr.log

 

cd $LOG_DIR&lt;/span&gt;/

&lt;span&gt;if&lt;/span&gt; [ -f $LOG_DIR/&lt;span&gt;$LOG_FILE.$YESTERDAY] ;then{

tar zcf $LOG_DIR&lt;/span&gt;/$LOG_FILE.$YESTERDAY.tar.gz$LOG_DIR/&lt;span&gt;$LOG_FILE.$YESTERDAY

&lt;/span&gt;/bin/mv $LOG_DIR/$LOG_FILE.$YESTERDAY.tar.gz/BAK_DIR/&lt;span&gt;

}

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

       echo “the file &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; not exist.”

fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用定时任务每天1点执行该脚本：0001 * * * /bin/bash bak_logs.sh&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;15. &lt;/strong&gt;&lt;strong&gt;写一个脚本进行nginx日志统计，得到访问ip最多的前10个（nginx日志路径：/nginx/default/access.log）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cat bak_logs.sh

#&lt;/span&gt;!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; to backup logs

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

 

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

LOG_FILE&lt;/span&gt;=/nginx/&lt;span&gt;default&lt;/span&gt;/&lt;span&gt;access.log

awk &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;/application/nginx/logs/access.log |sort|uniq -c|sort -r|head -&lt;span&gt;10&lt;/span&gt;&amp;gt;/tmp/&lt;span&gt;ip_max.txt

echo &lt;/span&gt;/tmp/ip_max.txt
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 27 Apr 2018 15:14:00 +0000</pubDate>
<dc:creator>青竹博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hystj/p/8965106.html</dc:identifier>
</item>
</channel>
</rss>