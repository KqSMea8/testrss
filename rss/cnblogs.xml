<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>QT 子窗口退出全屏 - Mouming_Ning</title>
<link>http://www.cnblogs.com/ningmouming/p/9935537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ningmouming/p/9935537.html</guid>
<description>&lt;p&gt;m_pWidget代表子窗口，&lt;/p&gt;
&lt;p&gt;子窗口显示全屏：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
m_pWidget-&amp;gt;setWindowFlags(Qt::Dialog);
m_pWidget-&amp;gt;showFullScreen();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子窗口退出全屏：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
m_pWidget-&amp;gt;showNormal();
m_pWidget-&amp;gt;setWindowFlags(Qt::SubWindow);
m_pWidget-&amp;gt;showMaximized();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;退出全屏时，前两句代码运行后，子窗口回到全屏前位置，&lt;/p&gt;
&lt;p&gt;但是是最小化的，需要将其显示最大化，即添加最后一句代码即可。&lt;/p&gt;
&lt;p&gt;试用其他的退出全屏方法，&lt;/p&gt;
&lt;p&gt;如调用 setWindowFlags(Qt::Dialog) 或  setWindowFlags(Qt::SubWindow) 先将子窗口设置为非顶层窗口，&lt;/p&gt;
&lt;p&gt;再将子窗口移动到全屏前的位置，以及大小设置为全屏前的大小，再调用showNormal()，&lt;/p&gt;
&lt;p&gt;此种情况确实可以退出全屏，但是子窗口并没有挂到原本的父窗口下，&lt;/p&gt;
&lt;p&gt;如果将父窗口移动，则退出全屏后的子窗口仍在退出后的位置，脱离了父窗口，&lt;/p&gt;
&lt;p&gt;很尴尬。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 07:49:00 +0000</pubDate>
<dc:creator>Mouming_Ning</dc:creator>
<og:description>m_pWidget代表子窗口， 子窗口显示全屏： 子窗口退出全屏： 退出全屏时，前两句代码运行后，子窗口回到全屏前位置， 但是是最小化的，需要将其显示最大化，即添加最后一句代码即可。 试用其他的退出全</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ningmouming/p/9935537.html</dc:identifier>
</item>
<item>
<title>Python协程中使用上下文 - 不写日记</title>
<link>http://www.cnblogs.com/mithrilon/p/9934660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mithrilon/p/9934660.html</guid>
<description>&lt;p&gt;在Python 3.7中，&lt;em&gt;asyncio&lt;/em&gt; 协程加入了对上下文的支持。使用上下文就可以在一些场景下隐式地传递变量，比如数据库连接session等，而不需要在所有方法调用显示地传递这些变量。使用得当的话，可以提高接口的可读性和扩展性。&lt;/p&gt;

&lt;p&gt;协和的上下文是通过 &lt;em&gt;contextvars&lt;/em&gt; 中的 &lt;em&gt;ContextVar&lt;/em&gt; 对象来管理的。最基本的使用方式是在某一调用层次中设置上下文，然后在后续调用中使用。如下例所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import contextvars
from random import randint
from unittest import TestCase

request_id_context = contextvars.ContextVar('request-id')


async def inner(x):
    request_id = request_id_context.get()
    if request_id != x:
        raise AssertionError('request_id %d from context does NOT equal with parameter x %d' % (request_id, x))

    print('start handling inner request-%d, with x: %d' % (request_id, x))
    await asyncio.sleep(randint(0, 3))
    print('finish handling inner request-%d, with x: %d' % (request_id, x))


async def outer(i):
    print('start handling outer request-%d' % i)
    request_id_context.set(i)
    await inner(i)
    print('finish handling outer request-%d with request_id in context %d' % (i, request_id_context.get()))


async def dispatcher():
    await asyncio.gather(*[
        outer(i) for i in range(0, 10)
    ])


class ContextTest(TestCase):

    def test(self):
        asyncio.run(dispatcher())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中，在最后定义了一个单元测试用例对象 &lt;code&gt;ContextTest&lt;/code&gt; 。它的方法 &lt;code&gt;test&lt;/code&gt; 是程序的入口，使用 &lt;code&gt;asyncio.run&lt;/code&gt; 方法来在协程中执行被测试的异步方法 &lt;code&gt;dispatcher&lt;/code&gt; 。&lt;code&gt;dispatcher&lt;/code&gt; 则并发启动10个异步方法 &lt;code&gt;outer&lt;/code&gt; 。 &lt;code&gt;outer&lt;/code&gt;方法首先将在模块层定义的上下文变量 &lt;code&gt;request_id_context&lt;/code&gt; 设置为当前调用指定的值，这个值对于每个 &lt;code&gt;outer&lt;/code&gt; 的调用都是不同的。 然后在后续被调用的 &lt;code&gt;inner&lt;/code&gt; 方法，以及 &lt;code&gt;outer&lt;/code&gt; 方法内部访问了这个上下文变更。在 &lt;code&gt;inner&lt;/code&gt; 方法内容，则比较了显示传入的 &lt;code&gt;i&lt;/code&gt; 和从上下文变量中取出的 &lt;code&gt;request_id&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;测试用例的执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start handling outer request-0
start handling inner request-0, with x: 0
start handling outer request-1
start handling inner request-1, with x: 1
start handling outer request-2
start handling inner request-2, with x: 2
start handling outer request-3
start handling inner request-3, with x: 3
start handling outer request-4
start handling inner request-4, with x: 4
start handling outer request-5
start handling inner request-5, with x: 5
start handling outer request-6
start handling inner request-6, with x: 6
start handling outer request-7
start handling inner request-7, with x: 7
start handling outer request-8
start handling inner request-8, with x: 8
start handling outer request-9
start handling inner request-9, with x: 9
finish handling inner request-3, with x: 3
finish handling outer request-3 with request_id in context 3
finish handling inner request-7, with x: 7
finish handling outer request-7 with request_id in context 7
finish handling inner request-1, with x: 1
finish handling outer request-1 with request_id in context 1
finish handling inner request-4, with x: 4
finish handling outer request-4 with request_id in context 4
finish handling inner request-5, with x: 5
finish handling outer request-5 with request_id in context 5
finish handling inner request-9, with x: 9
finish handling outer request-9 with request_id in context 9
finish handling inner request-0, with x: 0
finish handling outer request-0 with request_id in context 0
finish handling inner request-2, with x: 2
finish handling outer request-2 with request_id in context 2
finish handling inner request-6, with x: 6
finish handling outer request-6 with request_id in context 6
finish handling inner request-8, with x: 8
finish handling outer request-8 with request_id in context 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，虽然每次 &lt;code&gt;outer&lt;/code&gt; 方法对模块层同定义的同一个上下文变量 &lt;code&gt;request_id_context&lt;/code&gt; 设置了不同的值，但后续并发访问相互之间并不会混淆或冲突。&lt;/p&gt;

&lt;p&gt;前一节展示了在设置了上下文变量后，在后续使用中读取这个变量的情况。这一节，我们看一下不用调用层次间对同一个上下文变量进行修改的情况。&lt;/p&gt;
&lt;p&gt;在上一节代码上做了一些调整后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import contextvars
from random import randint
from unittest import TestCase

request_id_context = contextvars.ContextVar('request-id')

obj_context = contextvars.ContextVar('obj')


class A(object):

    def __init__(self, x):
        self.x = x

    def __repr__(self):
        return '&amp;lt;A|x: %d&amp;gt;' % self.x


async def inner(x):
    request_id = request_id_context.get()
    if request_id != x:
        raise AssertionError('request_id %d from context does NOT equal with parameter x %d' % (request_id, x))

    print('start handling inner request-%d, with x: %d' % (request_id, x))
    request_id_context.set(request_id * 10)
    await asyncio.sleep(randint(0, 3))

    obj = A(x)
    obj_context.set(obj)
    print('finish handling inner request-%d, with x: %d' % (request_id, x))


async def outer(i):
    print('start handling outer request-%d with request_id in context %d' % (i, request_id_context.get()))
    request_id_context.set(i)
    await inner(i)
    print('obj: %s in outer request-%d' % (obj_context.get(), i))
    print('finish handling outer request-%d with request_id in context %d' % (i, request_id_context.get()))


async def dispatcher():
    request_id_context.set(-1)
    await asyncio.gather(*[
        outer(i) for i in range(0, 10)
    ])
    print('finish all coroutines with request_id in context: %d' % (request_id_context.get()))


class ContextTest(TestCase):

    def test(self):
        asyncio.run(dispatcher())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体调整&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在 &lt;code&gt;dispatcher&lt;/code&gt; 中，开始启动协程前，将 &lt;code&gt;request_id_context&lt;/code&gt; 设置为 &lt;code&gt;-1&lt;/code&gt; 。 然后在所有的协程调用完毕后，再查看 &lt;code&gt;request_context_id&lt;/code&gt; 的值。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;outer&lt;/code&gt; 中，在设置 &lt;code&gt;request_id_context&lt;/code&gt; 之前，先查看它的值。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;inner&lt;/code&gt; 中，在检查和查看 &lt;code&gt;request_id_context&lt;/code&gt; 之后，将它修改为其原始值的10倍。&lt;/li&gt;
&lt;li&gt;定义了一个对象 &lt;code&gt;A&lt;/code&gt; ，以及一个用来传递 &lt;code&gt;A&lt;/code&gt; 对象实例的上下文变量 &lt;code&gt;obj_context&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;inner&lt;/code&gt; 中，创建&lt;code&gt;A&lt;/code&gt;的实例并保存到&lt;code&gt;obj_context&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;outer&lt;/code&gt;中，调用完&lt;code&gt;inner&lt;/code&gt;方法后，查看&lt;code&gt;obj_context&lt;/code&gt;上下文变量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码的执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start handling outer request-0 with request_id in context -1
start handling inner request-0, with x: 0
start handling outer request-1 with request_id in context -1
start handling inner request-1, with x: 1
start handling outer request-2 with request_id in context -1
start handling inner request-2, with x: 2
start handling outer request-3 with request_id in context -1
start handling inner request-3, with x: 3
start handling outer request-4 with request_id in context -1
start handling inner request-4, with x: 4
start handling outer request-5 with request_id in context -1
start handling inner request-5, with x: 5
start handling outer request-6 with request_id in context -1
start handling inner request-6, with x: 6
start handling outer request-7 with request_id in context -1
start handling inner request-7, with x: 7
start handling outer request-8 with request_id in context -1
start handling inner request-8, with x: 8
start handling outer request-9 with request_id in context -1
start handling inner request-9, with x: 9
finish handling inner request-6, with x: 6
obj: &amp;lt;A|x: 6&amp;gt; in outer request-6
finish handling outer request-6 with request_id in context 60
finish handling inner request-0, with x: 0
obj: &amp;lt;A|x: 0&amp;gt; in outer request-0
finish handling outer request-0 with request_id in context 0
finish handling inner request-2, with x: 2
obj: &amp;lt;A|x: 2&amp;gt; in outer request-2
finish handling outer request-2 with request_id in context 20
finish handling inner request-3, with x: 3
obj: &amp;lt;A|x: 3&amp;gt; in outer request-3
finish handling outer request-3 with request_id in context 30
finish handling inner request-5, with x: 5
obj: &amp;lt;A|x: 5&amp;gt; in outer request-5
finish handling outer request-5 with request_id in context 50
finish handling inner request-7, with x: 7
obj: &amp;lt;A|x: 7&amp;gt; in outer request-7
finish handling outer request-7 with request_id in context 70
finish handling inner request-8, with x: 8
obj: &amp;lt;A|x: 8&amp;gt; in outer request-8
finish handling outer request-8 with request_id in context 80
finish handling inner request-9, with x: 9
obj: &amp;lt;A|x: 9&amp;gt; in outer request-9
finish handling outer request-9 with request_id in context 90
finish handling inner request-1, with x: 1
obj: &amp;lt;A|x: 1&amp;gt; in outer request-1
finish handling outer request-1 with request_id in context 10
finish handling inner request-4, with x: 4
obj: &amp;lt;A|x: 4&amp;gt; in outer request-4
finish handling outer request-4 with request_id in context 40
finish all coroutines with request_id in context: -1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察执行结果，可以看到对上下文变量的修改，有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于已经设置过值的上下文变量，后续对其做的修改是单向传播的。尽管每个 &lt;code&gt;outer&lt;/code&gt; 方法都 &lt;code&gt;request_id_context&lt;/code&gt; 设置成了不同的值，但最后在 &lt;code&gt;dispatcher&lt;/code&gt; 调用完所有的 &lt;code&gt;outer&lt;/code&gt; 后，它取到的 &lt;code&gt;request_id_context&lt;/code&gt; 仍然为 &lt;code&gt;-1&lt;/code&gt;。 同样，&lt;code&gt;inner&lt;/code&gt;方法虽然修改了&lt;code&gt;request_id_context&lt;/code&gt;，但这个修改对调用它的&lt;code&gt;outer&lt;/code&gt;是不可见的。另外一个方向，&lt;code&gt;outer&lt;/code&gt;可以读取到调用它的&lt;code&gt;dispatcher&lt;/code&gt;修改的值，&lt;code&gt;inner&lt;/code&gt;也可以读取到&lt;code&gt;outer&lt;/code&gt;的修改。&lt;/li&gt;
&lt;li&gt;如果是新设置的上下文变量，它的值可以传递到其所在方法的调用者。比如在&lt;code&gt;inner&lt;/code&gt;中设置的&lt;code&gt;obj_context&lt;/code&gt;，在&lt;code&gt;outer&lt;/code&gt;中可以读取。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据Python文档， &lt;code&gt;ContextVar&lt;/code&gt;对象会持有变量值的强引用，所以如果没有适当清理，会导致内存漏泄。我们使用以下代码演示这种问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import contextvars
from unittest import TestCase
import weakref

obj_context = contextvars.ContextVar('obj')
obj_ref_dict = {}


class A(object):

    def __init__(self, x):
        self.x = x

    def __repr__(self):
        return '&amp;lt;A|x: %d&amp;gt;' % self.x


async def inner(x):
    obj = A(x)
    obj_context.set(obj)
    obj_ref_dict[x] = weakref.ref(obj)


async def outer(i):
    await inner(i)
    print('obj: %s in outer request-%d from obj_ref_dict' % (obj_ref_dict[i](), i))


async def dispatcher():
    await asyncio.gather(*[
        outer(i) for i in range(0, 10)
    ])
    for i in range(0, 10):
        print('obj-%d: %s in obj_ref_dict' % (i, obj_ref_dict[i]()))


class ContextTest(TestCase):

    def test(self):
        asyncio.run(dispatcher())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和上一节中的代码一样，&lt;code&gt;inner&lt;/code&gt;方法在调用栈的最内部设置了上下文变量&lt;code&gt;obj_context&lt;/code&gt;。不同的是，在设置上下文的同时，也将保存在上下文中的对象&lt;code&gt;A&lt;/code&gt;的实例保存到一个弱引用中，以便后续通过弱引用来检查对象实例是否被回收。&lt;/p&gt;
&lt;p&gt;代码的执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;obj: &amp;lt;A|x: 0&amp;gt; in outer request-0 from obj_ref_dict
obj: &amp;lt;A|x: 1&amp;gt; in outer request-1 from obj_ref_dict
obj: &amp;lt;A|x: 2&amp;gt; in outer request-2 from obj_ref_dict
obj: &amp;lt;A|x: 3&amp;gt; in outer request-3 from obj_ref_dict
obj: &amp;lt;A|x: 4&amp;gt; in outer request-4 from obj_ref_dict
obj: &amp;lt;A|x: 5&amp;gt; in outer request-5 from obj_ref_dict
obj: &amp;lt;A|x: 6&amp;gt; in outer request-6 from obj_ref_dict
obj: &amp;lt;A|x: 7&amp;gt; in outer request-7 from obj_ref_dict
obj: &amp;lt;A|x: 8&amp;gt; in outer request-8 from obj_ref_dict
obj: &amp;lt;A|x: 9&amp;gt; in outer request-9 from obj_ref_dict
obj-0: &amp;lt;A|x: 0&amp;gt; in obj_ref_dict
obj-1: &amp;lt;A|x: 1&amp;gt; in obj_ref_dict
obj-2: &amp;lt;A|x: 2&amp;gt; in obj_ref_dict
obj-3: &amp;lt;A|x: 3&amp;gt; in obj_ref_dict
obj-4: &amp;lt;A|x: 4&amp;gt; in obj_ref_dict
obj-5: &amp;lt;A|x: 5&amp;gt; in obj_ref_dict
obj-6: &amp;lt;A|x: 6&amp;gt; in obj_ref_dict
obj-7: &amp;lt;A|x: 7&amp;gt; in obj_ref_dict
obj-8: &amp;lt;A|x: 8&amp;gt; in obj_ref_dict
obj-9: &amp;lt;A|x: 9&amp;gt; in obj_ref_dict&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，无论是在&lt;code&gt;outer&lt;/code&gt;中，还是在&lt;code&gt;dispatcher&lt;/code&gt;中，所有&lt;code&gt;inner&lt;/code&gt;方法保存的上下文变量都被没有被回收。所以我们必需在使用完上下文变量后，显示清理上下文，否则会导致内存泄漏。&lt;/p&gt;
&lt;p&gt;这里，我们在&lt;code&gt;inner&lt;/code&gt;方法的最后，将&lt;code&gt;obj_context&lt;/code&gt;设置为&lt;code&gt;None&lt;/code&gt;，就可以保证不会因为上下文而导致内存不会被回收：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async def inner(x):
    obj = A(x)
    obj_context.set(obj)
    obj_ref_dict[x] = weakref.ref(obj)
    obj_context.set(None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后的代码执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;obj: None in outer request-0 from obj_ref_dict
obj: None in outer request-1 from obj_ref_dict
obj: None in outer request-2 from obj_ref_dict
obj: None in outer request-3 from obj_ref_dict
obj: None in outer request-4 from obj_ref_dict
obj: None in outer request-5 from obj_ref_dict
obj: None in outer request-6 from obj_ref_dict
obj: None in outer request-7 from obj_ref_dict
obj: None in outer request-8 from obj_ref_dict
obj: None in outer request-9 from obj_ref_dict
obj-0: None in obj_ref_dict
obj-1: None in obj_ref_dict
obj-2: None in obj_ref_dict
obj-3: None in obj_ref_dict
obj-4: None in obj_ref_dict
obj-5: None in obj_ref_dict
obj-6: None in obj_ref_dict
obj-7: None in obj_ref_dict
obj-8: None in obj_ref_dict
obj-9: None in obj_ref_dict&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当&lt;code&gt;outer&lt;/code&gt;和&lt;code&gt;dispatcher&lt;/code&gt;尝试通过弱引用来访问曾经保存在上下文中的对象实例时，这些对象都已经被回收了。&lt;/p&gt;

&lt;p&gt;在协程中使用 &lt;em&gt;contextvars&lt;/em&gt; 模块中的_ContextVar_对象可以让我们方便在协程间保存上下文数据。在使用时要注意以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;em&gt;contextvars&lt;/em&gt; 对协程的支持是从Python 3.7才开始的，使用时要注意Python版本。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ContextVar&lt;/em&gt; 应当在模块级别定义和创建，一定不能在闭包中定义。&lt;/li&gt;
&lt;li&gt;保存在上下文中的变量一定要在使用完成后显示清理，否则会导致内存泄漏。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Fri, 09 Nov 2018 07:46:00 +0000</pubDate>
<dc:creator>不写日记</dc:creator>
<og:description>使用 _contextvars_ 在Python协程中保存和读取上下文。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mithrilon/p/9934660.html</dc:identifier>
</item>
<item>
<title>golang channel 使用总结 - _toby</title>
<link>http://www.cnblogs.com/tobycnblogs/p/9935465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tobycnblogs/p/9935465.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://litang.me/post/golang-channel/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不同于传统的多线程并发模型使用共享内存来实现线程间通信的方式，golang 的哲学是通过 channel 进行协程(goroutine)之间的通信来实现数据共享：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Do not communicate by sharing memory; instead, share memory by communicating.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种方式的优点是通过提供原子的通信原语，避免了竞态情形(race condition)下复杂的锁机制。&lt;br/&gt;channel 可以看成一个 FIFO 队列，对 FIFO 队列的读写都是原子的操作，不需要加锁。对 channel 的操作行为结果总结如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;close&lt;/td&gt;
&lt;td&gt;panic&lt;/td&gt;
&lt;td&gt;panic&lt;/td&gt;
&lt;td&gt;成功 close&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;写 &lt;code&gt;ch &amp;lt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一直阻塞&lt;/td&gt;
&lt;td&gt;panic&lt;/td&gt;
&lt;td&gt;阻塞或成功写入数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;读 &lt;code&gt;&amp;lt;- ch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一直阻塞&lt;/td&gt;
&lt;td&gt;读取对应类型零值&lt;/td&gt;
&lt;td&gt;阻塞或成功读取数据&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;读取一个已关闭的 channel 时，总是能读取到对应类型的零值，为了和读取非空未关闭 channel 的行为区别，可以使用两个接收值：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// ok is false when ch is closed
v, ok := &amp;lt;-ch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;golang 中大部分类型都是值类型(只有 slice / channel / map 是引用类型)，读/写类型是值类型的 channel 时，如果元素 size 比较大时，应该使用指针代替，避免频繁的内存拷贝开销。&lt;/p&gt;
&lt;h3 id=&quot;内部实现&quot;&gt;内部实现&lt;/h3&gt;
&lt;p&gt;如图所示，在 channel 的内部实现中(具体定义在 &lt;code&gt;$GOROOT/src/runtime/chan.go&lt;/code&gt; 里)，维护了 3 个队列：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读等待协程队列 recvq，维护了阻塞在读此 channel 的协程列表&lt;/li&gt;
&lt;li&gt;写等待协程队列 sendq，维护了阻塞在写此 channel 的协程列表&lt;/li&gt;
&lt;li&gt;缓冲数据队列 buf，用环形队列实现，不带缓冲的 channel 此队列 size 则为 0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://litang.me/image/chan.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当协程尝试从未关闭的 channel 中读取数据时，内部的操作如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当 buf 非空时，此时 recvq 必为空，buf 弹出一个元素给读协程，读协程获得数据后继续执行，此时若 sendq 非空，则从 sendq 中弹出一个写协程转入 running 状态，待写数据入队列 buf ，此时读取操作 &lt;code&gt;&amp;lt;- ch&lt;/code&gt; 未阻塞；&lt;/li&gt;
&lt;li&gt;当 buf 为空但 sendq 非空时(不带缓冲的 channel)，则从 sendq 中弹出一个写协程转入 running 状态，待写数据直接传递给读协程，读协程继续执行，此时读取操作 &lt;code&gt;&amp;lt;- ch&lt;/code&gt; 未阻塞；&lt;/li&gt;
&lt;li&gt;当 buf 为空并且 sendq 也为空时，读协程入队列 recvq 并转入 blocking 状态，当后续有其他协程往 channel 写数据时，读协程才会重新转入 running 状态，此时读取操作 &lt;code&gt;&amp;lt;- ch&lt;/code&gt; 阻塞。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;类似的，当协程尝试往未关闭的 channel 中写入数据时，内部的操作如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当队列 recvq 非空时，此时队列 buf 必为空，从 recvq 弹出一个读协程接收待写数据，此读协程此时结束阻塞并转入 running 状态，写协程继续执行，此时写入操作 &lt;code&gt;ch &amp;lt;-&lt;/code&gt; 未阻塞；&lt;/li&gt;
&lt;li&gt;当队列 recvq 为空但 buf 未满时，此时 sendq 必为空，写协程的待写数据入 buf 然后继续执行，此时写入操作 &lt;code&gt;ch &amp;lt;-&lt;/code&gt; 未阻塞；&lt;/li&gt;
&lt;li&gt;当队列 recvq 为空并且 buf 为满时，此时写协程入队列 sendq 并转入 blokcing 状态，当后续有其他协程从 channel 中读数据时，写协程才会重新转入 running 状态，此时写入操作 &lt;code&gt;ch &amp;lt;-&lt;/code&gt; 阻塞。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当关闭 non-nil channel 时，内部的操作如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当队列 recvq 非空时，此时 buf 必为空，recvq 中的所有协程都将收到对应类型的零值然后结束阻塞状态；&lt;/li&gt;
&lt;li&gt;当队列 sendq 非空时，此时 buf 必为满，sendq 中的所有协程都会产生 panic ，在 buf 中数据仍然会保留直到被其他协程读取。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;除了常规的用来在协程之间传递数据外，本节列出了一些特殊的使用 channel 的场景。&lt;/p&gt;
&lt;h4 id=&quot;futures-promises&quot;&gt;futures / promises&lt;/h4&gt;
&lt;p&gt;golang 虽然没有直接提供 &lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises&quot;&gt;futrue / promise&lt;/a&gt; 模型的操作原语，但通过 goroutine 和 channel 可以实现类似的功能：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

// RequestFuture, http request promise.
func RequestFuture(url string) &amp;lt;-chan []byte {
    c := make(chan []byte, 1)
    go func() {
        var body []byte
        defer func() {
            c &amp;lt;- body
        }()

        res, err := http.Get(url)
        if err != nil {
            return
        }
        defer res.Body.Close()

        body, _ = ioutil.ReadAll(res.Body)
    }()

    return c
}

func main() {
    future := RequestFuture(&quot;https://api.github.com/users/octocat/orgs&quot;)
    body := &amp;lt;-future
    log.Printf(&quot;reponse length: %d&quot;, len(body))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;条件变量condition-variable&quot;&gt;条件变量(condition variable)&lt;/h4&gt;
&lt;p&gt;类型于 POSIX 接口中线程通知其他线程某个事件发生的条件变量，channel 的特性也可以用来当成协程之间同步的条件变量。因为 channel 只是用来通知，所以 channel 中具体的数据类型和值并不重要，这种场景一般用 &lt;code&gt;strct {}&lt;/code&gt; 作为 channel 的类型。&lt;/p&gt;
&lt;h5 id=&quot;一对一通知&quot;&gt;一对一通知&lt;/h5&gt;
&lt;p&gt;类似 &lt;code&gt;pthread_cond_signal()&lt;/code&gt; 的功能，用来在一个协程中通知另个某一个协程事件发生：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ch := make(chan struct{})
    nums := make([]int, 100)

    go func() {
        time.Sleep(time.Second)
        for i := 0; i &amp;lt; len(nums); i++ {
            nums[i] = i
        }
        // send a finish signal
        ch &amp;lt;- struct{}{}
    }()

    // wait for finish signal
    &amp;lt;-ch
    fmt.Println(nums)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;广播通知&quot;&gt;广播通知&lt;/h5&gt;
&lt;p&gt;类似 &lt;code&gt;pthread_cond_broadcast()&lt;/code&gt; 的功能。利用从已关闭的 channel 读取数据时总是非阻塞的特性，可以实现在一个协程中向其他多个协程广播某个事件发生的通知：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    N := 10
    exit := make(chan struct{})
    done := make(chan struct{}, N)

    // start N worker goroutines
    for i := 0; i &amp;lt; N; i++ {
        go func(n int) {
            for {
                select {
                // wait for exit signal
                case &amp;lt;-exit:
                    fmt.Printf(&quot;worker goroutine #%d exit\n&quot;, n)
                    done &amp;lt;- struct{}{}
                    return
                case &amp;lt;-time.After(time.Second):
                    fmt.Printf(&quot;worker goroutine #%d is working...\n&quot;, n)
                }
            }
        }(i)
    }

    time.Sleep(3 * time.Second)
    // broadcast exit signal
    close(exit)
    // wait for all worker goroutines exit
    for i := 0; i &amp;lt; N; i++ {
        &amp;lt;-done
    }
    fmt.Println(&quot;main goroutine exit&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;信号量&quot;&gt;信号量&lt;/h4&gt;
&lt;p&gt;channel 的读/写相当于信号量的 P / V 操作，下面的示例程序中 channel 相当于信号量：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;log&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

type Seat int
type Bar chan Seat

func (bar Bar) ServeConsumer(customerId int) {
    log.Print(&quot;-&amp;gt; consumer#&quot;, customerId, &quot; enters the bar&quot;)
    seat := &amp;lt;-bar // need a seat to drink
    log.Print(&quot;consumer#&quot;, customerId, &quot; drinks at seat#&quot;, seat)
    time.Sleep(time.Second * time.Duration(2+rand.Intn(6)))
    log.Print(&quot;&amp;lt;- consumer#&quot;, customerId, &quot; frees seat#&quot;, seat)
    bar &amp;lt;- seat // free the seat and leave the bar
}

func main() {
    rand.Seed(time.Now().UnixNano())

    bar24x7 := make(Bar, 10) // the bar has 10 seats
    // Place seats in an bar.
    for seatId := 0; seatId &amp;lt; cap(bar24x7); seatId++ {
        bar24x7 &amp;lt;- Seat(seatId) // none of the sends will block
    }

    // a new consumer try to enter the bar for each second
    for customerId := 0; ; customerId++ {
        time.Sleep(time.Second)
        go bar24x7.ServeConsumer(customerId)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;互斥量&quot;&gt;互斥量&lt;/h4&gt;
&lt;p&gt;互斥量相当于二元信号里，所以 cap 为 1 的 channel 可以当成互斥量使用：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    mutex := make(chan struct{}, 1) // the capacity must be one

    counter := 0
    increase := func() {
        mutex &amp;lt;- struct{}{} // lock
        counter++
        &amp;lt;-mutex // unlock
    }

    increase1000 := func(done chan&amp;lt;- struct{}) {
        for i := 0; i &amp;lt; 1000; i++ {
            increase()
        }
        done &amp;lt;- struct{}{}
    }

    done := make(chan struct{})
    go increase1000(done)
    go increase1000(done)
    &amp;lt;-done; &amp;lt;-done
    fmt.Println(counter) // 2000
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关闭-channel&quot;&gt;关闭 channel&lt;/h3&gt;
&lt;p&gt;关闭不再需要使用的 channel 并不是必须的。跟其他资源比如打开的文件、socket 连接不一样，这类资源使用完后不关闭后会造成句柄泄露，channel 使用完后不关闭也没有关系，channel 没有被任何协程用到后最终会被 GC 回收。关闭 channel 一般是用来通知其他协程某个任务已经完成了。golang 也没有直接提供判断 channel 是否已经关闭的接口，虽然可以用其他不太优雅的方式自己实现一个：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func isClosed(ch chan int) bool {
    select {
    case &amp;lt;-ch:
        return true
    default:
    }
    return false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过实现一个这样的接口也没什么必要。因为就算通过 &lt;code&gt;isClosed()&lt;/code&gt; 得到当前 channel 当前还未关闭，如果试图往 channel 里写数据，仍然可能会发生 panic ，因为在调用 &lt;code&gt;isClosed()&lt;/code&gt; 后，其他协程可能已经把 channel 关闭了。&lt;br/&gt;关闭 channel 时应该注意以下准则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要在读取端关闭 channel ，因为写入端无法知道 channel 是否已经关闭，往已关闭的 channel 写数据会 panic ；&lt;/li&gt;
&lt;li&gt;有多个写入端时，不要再写入端关闭 channle ，因为其他写入端无法知道 channel 是否已经关闭，关闭已经关闭的 channel 会发生 panic ；&lt;/li&gt;
&lt;li&gt;如果只有一个写入端，可以在这个写入端放心关闭 channel 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关闭 channel 粗暴一点的做法是随意关闭，如果产生了 panic 就用 recover 避免进程挂掉。稍好一点的方案是使用标准库的 &lt;code&gt;sync&lt;/code&gt; 包来做关闭 channel 时的协程同步，不过使用起来也稍微复杂些。下面介绍一种优雅些的做法。&lt;/p&gt;
&lt;h4 id=&quot;一写多读&quot;&gt;一写多读&lt;/h4&gt;
&lt;p&gt;这种场景下这个唯一的写入端可以关闭 channel 用来通知读取端所有数据都已经写入完成了。读取端只需要用 &lt;code&gt;for range&lt;/code&gt; 把 channel 中数据遍历完就可以了，当 channel 关闭时，&lt;code&gt;for range&lt;/code&gt; 仍然会将 channel 缓冲中的数据全部遍历完然后再退出循环：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    wg := &amp;amp;sync.WaitGroup{}
    ch := make(chan int, 100)

    send := func() {
        for i := 0; i &amp;lt; 100; i++ {
            ch &amp;lt;- i
        }
        // signal sending finish
        close(ch)
    }

    recv := func(id int) {
        defer wg.Done()
        for i := range ch {
            fmt.Printf(&quot;receiver #%d get %d\n&quot;, id, i)
        }
        fmt.Printf(&quot;receiver #%d exit\n&quot;, id)
    }

    wg.Add(3)
    go recv(0)
    go recv(1)
    go recv(2)
    send()

    wg.Wait()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多写一读&quot;&gt;多写一读&lt;/h4&gt;
&lt;p&gt;这种场景下虽然可以用 &lt;code&gt;sync.Once&lt;/code&gt; 来解决多个写入端重复关闭 channel 的问题，但更优雅的办法设置一个额外的 channel ，由读取端通过关闭来通知写入端任务完成不要再继续再写入数据了：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    wg := &amp;amp;sync.WaitGroup{}
    ch := make(chan int, 100)
    done := make(chan struct{})

    send := func(id int) {
        defer wg.Done()
        for i := 0; ; i++ {
            select {
            case &amp;lt;-done:
                // get exit signal
                fmt.Printf(&quot;sender #%d exit\n&quot;, id)
                return
            case ch &amp;lt;- id*1000 + i:
            }
        }
    }

    recv := func() {
        count := 0
        for i := range ch {
            fmt.Printf(&quot;receiver get %d\n&quot;, i)
            count++
            if count &amp;gt;= 1000 {
                // signal recving finish
                close(done)
                return
            }
        }
    }

    wg.Add(3)
    go send(0)
    go send(1)
    go send(2)
    recv()

    wg.Wait()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多写多读&quot;&gt;多写多读&lt;/h4&gt;
&lt;p&gt;这种场景稍微复杂，和上面的例子一样，也需要设置一个额外 channel 用来通知多个写入端和读取端。另外需要起一个额外的协程来通过关闭这个 channel 来广播通知：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    wg := &amp;amp;sync.WaitGroup{}
    ch := make(chan int, 100)
    done := make(chan struct{})

    send := func(id int) {
        defer wg.Done()
        for i := 0; ; i++ {
            select {
            case &amp;lt;-done:
                // get exit signal
                fmt.Printf(&quot;sender #%d exit\n&quot;, id)
                return
            case ch &amp;lt;- id*1000 + i:
            }
        }
    }

    recv := func(id int) {
        defer wg.Done()
        for {
            select {
            case &amp;lt;-done:
                // get exit signal
                fmt.Printf(&quot;receiver #%d exit\n&quot;, id)
                return
            case i := &amp;lt;-ch:
                fmt.Printf(&quot;receiver #%d get %d\n&quot;, id, i)
                time.Sleep(time.Millisecond)
            }
        }
    }

    wg.Add(6)
    go send(0)
    go send(1)
    go send(2)
    go recv(0)
    go recv(1)
    go recv(2)

    time.Sleep(time.Second)
    // signal finish
    close(done)
    // wait all sender and receiver exit
    wg.Wait()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;channle 作为 golang 最重要的特性，用起来还是比较爽的。传统的 C 里要实现类型的功能的话，一般需要用到 socket 或者 FIFO 来实现，另外还要考虑数据包的完整性与并发冲突的问题，channel 则屏蔽了这些底层细节，使用者只需要考虑读写就可以了。 channel 是引用类型，了解一下 channel 底层的机制对更好的使用 channel 还是很用必要的。虽然操作原语简单，但涉及到阻塞的问题，使用不当可能会造成死锁或者无限制的协程创建最终导致进程挂掉。&lt;br/&gt;channel 除在可以用来在协程之间通信外，其阻塞和唤醒协程的特性也可以用作协程之间的同步机制，文中也用示例简单介绍了这种场景下的用法。&lt;br/&gt;关闭 channel 并不是必须的，只要没有协程没用引用 channel ，最终会被 GC 清理。所以使用的时候要特别注意，不要让协程阻塞在 channel 上，这种情况很难检测到，而且会造成 channel 和阻塞在 channel 的协程占有的资源无法被 GC 清理最终导致内存泄露。&lt;br/&gt;channle 方便 golang 程序使用 CSP 的编程范形，但是 golang 是一种多范形的编程语言，golang 也支持传统的通过共享内存来通信的编程方式。终极的原则是根据场景选择合适的编程范型，不要因为 channel 好用而滥用 CSP 。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Fri, 09 Nov 2018 07:37:00 +0000</pubDate>
<dc:creator>_toby</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tobycnblogs/p/9935465.html</dc:identifier>
</item>
<item>
<title>网络编程(三) - Thales5</title>
<link>http://www.cnblogs.com/zuanzuan/p/9935351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuanzuan/p/9935351.html</guid>
<description>&lt;p&gt;在之前两篇文章我们已经大概了解了互联网的工作原理,知道了一个数据包的诞生与结束中间经历的过程,那么在这篇博客我们将了解一个稳定可靠地 TCP 连接是怎么产生的,它的数据传送有什么优点和缺点?&lt;/p&gt;
&lt;p&gt;该博客将重点介绍 传输层的 TCP 协议建立连接和断开连接的过程. UDP 因为不是可靠的连接所以就不重点介绍了.&lt;/p&gt;

&lt;p&gt;在传输层通常遵循的协议为 TCP 和 UDP协议,并且是基于端口运行的,但是两者为应用层提供不同的服务. TCP 提供的是一种稳定,可靠地字节流服务.&lt;/p&gt;
&lt;p&gt;面向连接意味着两个使用 TCP 的应用在数据传送之前需要建立 TCP 连接.这一过程可以理解为打电话,先拨号,等待接通,然后稳定的通信.&lt;/p&gt;
&lt;p&gt;那么 UDP 是无连接,不可靠的数据包服务,因为无连接,所以可能会产生丢包,但是效率却较高,因为不用对方发送确认包,所以 UDP 广泛应用与游戏,直播等软件.&lt;/p&gt;

&lt;p&gt;在网络编程(二)中已经知道 TCP是基于端口发送数据包的,所以会记录本机端口号和目的端口号,具体格式如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fx0tpgbpl9j307y04w3yr.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图有几个重要的字段需要了解:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;序 列号: seq 序号,占32位,用来标识从 TCP 源端向目的端发送的字节流,发送方的发送数据时对比进行标记;&lt;/li&gt;
&lt;li&gt;确认号: ACK 序号,占32位,只有 ACK 标志位位1时,确认号字段才有效, ack=seq+1;&lt;/li&gt;
&lt;li&gt;标志位:共6个,即 URG,ACK,PSH,RST,SYN,FIN 等,具体含义如下:
&lt;ol&gt;&lt;li&gt;URG: 紧急指针有效;&lt;/li&gt;
&lt;li&gt;ACK: 确认序号有效;&lt;/li&gt;
&lt;li&gt;PSH: 接收方应该尽快将报文交给应用层;&lt;/li&gt;
&lt;li&gt;RST: 重置连接;&lt;/li&gt;
&lt;li&gt;SYN: 发起一个新连接&lt;/li&gt;
&lt;li&gt;FIN: 释放一个连接.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;两个号码
&lt;ol&gt;&lt;li&gt;Sequene number: 顺序号码&lt;/li&gt;
&lt;li&gt;Acknowledge number: 确认号码&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要将确认序号 Ack 与标志位中的 ACK 搞混了;&lt;/li&gt;
&lt;li&gt;确认方 ack=seq+1(不论哪方发送),两端才建立连接.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所谓的三次握手( Three-Way Handshake)即建立 TCP 连接,就是指建立一个 TCP 连接时,需要客户端和服务端发送三个包用来确认连接的建立.在套接字编程中,这一过程由客户端执行 connect 来主动触发,整个流程如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fx0u5zq7v7j30ob0r40wb.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次握手: 客户端发送 SYN 包( seq=x)的数据包到服务器,并进入 SYN_SEND 状态,等待服务器确认;&lt;/li&gt;
&lt;li&gt;第二次握手: 服务器收到 SYN 包,必须确认客户端的 SYN(ACK=x+1),同时自己也发送一个 SYN 包(seq=y),即 SYN+ACK 包,此时服务器进入 SYN_RCVD 状态;&lt;/li&gt;
&lt;li&gt;第三次握手: 客户端收到服务器的 SYN+ACK 包,向服务器发送确认包 ACK(ACK=y+1),此包发送完毕,客户端和服务端都进入 ESTABLISHED 状态,完成三次握手.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;握手过程传送的包不包含任何数据,三次握手完毕后,客户端与服务器才正式开始传送数据.理想状态下, TCP 连接建立.在通信双方中的任何一方主动关闭连接之前, TCP 连接都将被一直保持下去.(双方都可以主动断开连接)&lt;/p&gt;

&lt;p&gt;在建立 TCP 连接之后,客户端和服务端开始传输数据,因为这是双向连接,所以任一方都可以主动断开连接.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四次挥手&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次挥手: 主动关闭方发送一个 FIN, 用来关闭主动方到被动方的数据传送,也就是主动关闭方告诉被动关闭方:我的数据传输已经完成了,不会再给你发送数据了(当然,在 FIN 包之前发送出去的数据,如果没有收到对应的 ACK 确认报文,主动关闭方依然会重发这些数据),但是此时主动关闭方还可以接收数据.&lt;/li&gt;
&lt;li&gt;第二次挥手: 被动关闭方收到 FIN 包后,发送一个 ACK 给对方,确认序号为收到序号+1(与 SYN 相同,一个 FIN 占用一个序号).&lt;/li&gt;
&lt;li&gt;第三次挥手: 被动关闭方发送一个 FIN, 用来关闭被动关闭方到主动关闭方的数据传送,也就是告诉主动关闭方,我的数据也发送完成,不会再给你发送数据了(但是在 FIN 发送之前发送的数据仍然需要主动关闭方发送确认包).&lt;/li&gt;
&lt;li&gt;第四次挥手: 主动关闭方收到 FIn 后,发送一个 ACK 给被动关闭方,确认序号为收到序号+1,至此,完成四次挥手.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fx0v4ebsi1j30iy0fwmza.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fx0vgkunpaj305z06j3yu.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CLOSED: 表示初始状态&lt;/p&gt;
&lt;p&gt;LISTEN(服务器): 表示服务器的某个套接字处于坚挺状态,可以接受客户端的连接&lt;/p&gt;
&lt;p&gt;YN_RCVD(服务器): 这个状态表示服务器接收到了客户端的 SYN 报文,在正常情况下,这个状态是服务端的 SOCKET 在建立 TCP 连接时的三次握手会话过程中的一个中间状态,很短暂,基本上用 netstat 是很难看到这种状态的,因此这种状态时,当收到客户端的 ACK 报文后,他会进入 ESTABLISHED 状态&lt;/p&gt;
&lt;p&gt;SYN_SENT: 这个状态与 SYN_RCVD 相对应,当客户端SOCKET 执行 CONNECT 连接时,它首先发送 SYN 报文,因此也随机会进入 SYN_SENT, 并等待服务端发送三次连接中的第二个报文. SYN_SENT 表示客户端已发送 SYN 请求连接报文.&lt;/p&gt;
&lt;p&gt;ESTABLISHED: 表示连接已经建立&lt;/p&gt;
&lt;p&gt;FIN_WAIT_1: 其实 FIN_WAIT_1和 FIN_WAIT_1状态的真正含义都是表示等待对方的 FIN 报文.而这两种状态的区别是: FIN_WAIT_1状态实际上是当SOCKET 在 ESTABLISHED 状态时,它想主动关闭连接,向对方发送了 FIN 报文,此时该 SOCKET 即进入到 FIN_WAIT_1状态.而当对方回应ACK 报文后,则进入到 FIN_WAIT_2状态,当然在实际的正常情况下,无论对方在何种情况,都应该回应 ACK 报文,所以 FIN_WAIT_1状态一般是不容易见到的,而 FIN_WAIT_2可以用 netstat 看到&lt;/p&gt;
&lt;p&gt;FIN_WAIT_2: 实际上 FIN_WAIT_2状态下的 SOCKET, 表示半连接,也即有一方要求 CLOSE 连接,但另外还告诉对方,我暂时还有点数据需要传送,等会再关闭连接&lt;/p&gt;
&lt;p&gt;TIME_WAIT: 表示收到了对方的 FIN 报文,并发送了 ACK 报文,就等2MSL 后即可回到 CLOSED 可用状态了(初始状态).如果 FIN_WAIT_1状态下,收到了对方同时带 FIN标志和 ACK 标志的报文时,可以直接进入到 TIME_WAIT 状态,而无需经过 FIN_WAIT_2状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MSL( 最大分段生存期)指明 TCP 报文在 internet 上最长生存时间,每个具体的 TCP 实现都必须选择一个确定的 MSL 值. RFC1122建议为2分钟,但 BSD 传统实现了采用30秒. TIME_WAIT 状态最大保持时间是2*MSL, 也就是1-4分钟.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 TIME_WAIT 下等待2MSL, 只是为了尽最大努力保证四次握手正常关闭.确保老的报文段在网络中消失,不会影响新建立的连接.&lt;/p&gt;
&lt;p&gt;CLOSING: 这种状态比较特殊,实际情况中很少见.正常情况下,当你发送 FIN 报文后,按理来说应该先收到(或同时受到)对方的 ACK 报文,再收到对方的 FIN 报文.但是 CLOSING 状态表示你发送 FIN 报文后,并没有收到对方的 ACK报文,反而收到了对方的 FIN 报文.那么什么情况下会出现这种情况.那就是双方几乎在同时 close 一个 SOCKET 的时候,那么久出现了双方同时发送 FIN 报文的情况,也即会出现 CLOSING 状态,表示双方都正在关闭 SOCKET 连接.&lt;/p&gt;
&lt;p&gt;CLOSE_WAIT: 这种状态的含义其实是在表示等待关闭.当对方 close 一个 SOCKET 后发送 FIN 报文给自己,系统毫无疑问会回应一个 ACK 报文给对方,此时则进入 CLOSE_WAIT 状态.接下来就需要考虑是否还有数据需要发送给对方,如果没有的话,那么就可以 close 这个 SOCKET, 发送 FIN 报文给对方,也即关闭连接.所以在 CLOSE_WAIT 状态下,需要等待你去关闭连接&lt;/p&gt;
&lt;p&gt;LAST_ACK: 它是被动关闭一方在发送 FIN 报文后,最后等待对方的 ACK 报文.当收到 ACK 报文后,也即可以进入到 CLOSED可用状态.( 初始状态)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认情况下,当调用 close 时,如果发送缓冲中还有数据, TCP 会继续把数据发送完;&lt;/li&gt;
&lt;li&gt;发送了 FIN 只是表示这端不能继续发送数据(应用层不能调用 send 发送),但是仍然可以接收数据;&lt;/li&gt;
&lt;li&gt;应用层如何知道对端关闭?通常,在最简单的阻塞模型中,当你调用 recv 时,如果返回0,则表示对端关闭.在这个时候通常的做法就是也调用close, 那么会发送 FIN, 完成四次握手.如果不调用 close, 那么对端就会处于 FIN_WAIT_2状态,而本端则会处于 CLOSE_WAIT状态.&lt;/li&gt;
&lt;li&gt;很多时候, TCP 连接的断开都是有 TCP 层自动进行,例如使用 CTRL_C 终止程序, TCP 连接依然会正常关闭.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;问题:&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;58.5&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;为什么建立连接协议是三次握手,而关闭连接是四次挥手呢?&lt;/p&gt;
&lt;p&gt;这是因为服务端的 LISTEN 状态下的 SOCKET 收到 SYN 的请求连接时,可以把 ACK和 SYN(ACK起应答作用,而 SYN 起同步作用)放在一个报文里一起发送.但是关闭连接时,当收到对方的 FIN 报文通知时,它仅仅表示对方没有数据发送了,但是另一方未必所有的数据 都全部发送完全了,所以可能不会立马关闭 SOCKET, 也即你可能还需要发送一些数据给对方之后,再发送 FIN 报文给对方表示你同意现在关闭连接了,所以这里的 ACK 报文和 FIN 报文是分开发送的.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;为什么不能用两次握手进行连接?&lt;/p&gt;
&lt;p&gt;在三次握手中,总共需要完成两个重要的功能,既要双方做好发送数据的准备工作(双方都知道彼此已经准备好),也要允许双方就初始序列号进行协商,这个序列号在握手过程中被发送和确认.&lt;/p&gt;
&lt;p&gt;现在把三次握手改成仅需要两次握手,是可能会发生死锁的.考虑计算机客户端和服务端之间的通信,假定客户端给服务端发送一个连接请求分组,服务端收到了这个分组,并发送了确认应答分组.按照两次握手的协定,服务端认为链接已经成功的建立了,可以开始发送数据分组.可是,客户端在服务端的应答分组在传输中被丢失的情况下,将不会知道服务端是否已准备好,不知道服务端建立什么样的序列号,客户端甚至会怀疑服务端是否收到自己的连接请求分组.在这种情况下,客户端认为连接还未建立成功,将忽略服务端发来的任何数据分组,只等待连接确认应答分组.而服务端在发出的数据分组超时后,重复发送同样的数据分组,就形成了死锁.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;73&quot;&gt;
&lt;p&gt;为什么 TIME_WAIT 状态需要等2MSL 后才能返回到 CLOSED 状态?&lt;/p&gt;
&lt;p&gt;什么是 MSL? MSL 即Maximum Segment Lifetime, 也就是报文最大生存时间.'MSL 是任何报文段被丢弃前在网络内的最长时间.'那么,2MSL 也就是这个时间的两倍,当 TCP 连接完成四个报文段的交换时,主动关闭的一方将继续等待一定时间(2-4)分钟,即使两端的应用程序结束.&lt;/p&gt;
&lt;p&gt;为什么需要2MSL 呢.&lt;/p&gt;
&lt;p&gt;第一,虽然双方都同意关闭连接了,而且握手的四个报文也都协调和发送完毕,按理可以直接回到 CLOSED 状态(就好比从 SYN_SEND 状态到 ESTABLISH 状态那样);但是因为对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文,而重发 FIN 报文,所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文.&lt;/p&gt;
&lt;p&gt;第二,报文可能会被混淆,意思是说其他时候的连接可能会被当做本次的连接.&lt;/p&gt;
&lt;p&gt;当某个连接的一端处于 TIME_WAIT 状态时,该连接将不能再被使用.事实上,对于我们比较有现实意义的是,这个端口将不能再被使用.某个端口处于 TIME_WAIT(其实应该是这个连接) 状态时,这意味着这个 TCP 连接并没有断开(完全断开),那么.如果你 bind 这个端口,就会失败.对于服务器而言,如果服务器突然 crash 掉了,那么他将无法在2MSL 内重新启动,因为 bind 会失败.解决这个问题的一个方法就是设置 SOCKET 的 SO_REUSEADDR 选项.这个选项意味着可以重用一个地址.&lt;/p&gt;
&lt;p&gt;当建立一个 TCP 连接时,服务端会继续用原有端口监听,同时用这个端口与客户端通信.而客户端默认情况下会使用一个随机端口与服务端的监听端口通信.有时候,为了服务端的安全性,我们需要对客户端进行验证,即限定某个 IP 的某个特定端口的客户端.客户端可以使用 bind 来使用特定的端口.对于服务端,当设置了 SO_REUSEADDR 选项时,它可以在2MSL 内启动并 listen成功.但是对于客户端,当使用 bind 并设置 SO_REUSEADDR 时,如果在2MSL 内启动,虽然 bind 会成功,但是在 windows 平台上 connect 会失败.而在 linux 是哪个不存在这个问题.&lt;/p&gt;
&lt;p&gt;要解决 windows 平台的问题,可以设置 SO_LISTEN 选项. SO_LINGER 选项决定调用 close 时 TCP 的行为. SO_LINGER 涉及到 linger 结构体,如果设置结构体中 l_onoff 为非0,l_linger 为0,那么调用 close 时 TCP 连接会立刻断开, TCP 不会将发送缓冲中未发送的数据发送,而是立即发送一个 RST 报文给对方,这个时候 TCP 连接(关闭时)就不会进入 TIME_WAIT 状态.这样做虽然解决了问题,但是并不安全.通过以上方式设置 SO_LINGER 状态,等同于设置 SO_DONTLINGER 状态.&lt;/p&gt;
&lt;p&gt;当 TCP 连接发生一些物理上的意外情况时,例如网线断开, linux 上的 TCP 实现会依然认为该连接有效,而 windows 则会在一定时间后返回错误信息.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 09 Nov 2018 07:24:00 +0000</pubDate>
<dc:creator>Thales5</dc:creator>
<og:description>在之前两篇文章我们已经大概了解了互联网的工作原理,知道了一个数据包的诞生与结束中间经历的过程,那么在这篇博客我们将了解一个稳定可靠地 TCP 连接是怎么产生的,它的数据传送有什么优点和缺点? 该博客将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuanzuan/p/9935351.html</dc:identifier>
</item>
<item>
<title>REST API设计指导——译自Microsoft REST API Guidelines（二） - 雪雁</title>
<link>http://www.cnblogs.com/codelove/p/9935291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codelove/p/9935291.html</guid>
<description>&lt;p&gt;由于文章内容较长，只能拆开发布。翻译的不对之处，请多多指教。&lt;/p&gt;
&lt;p&gt;另外：最近团队在做一些技术何架构的研究，视频教程只能争取周末多录制一点，同时预计在下周我们会展开一次直播活动，内容围绕容器技术这块。&lt;/p&gt;
&lt;p&gt;所有章节我们翻译校对完成后，将会将最终定稿签入到我们的Github开源库托管，方便大家查阅和校正。同时，我们推荐将此规范作为团队的REST API设计指导和规范。&lt;/p&gt;
&lt;p&gt;上篇内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU0Mzk1OTU2Mg==&amp;amp;mid=2247483760&amp;amp;idx=1&amp;amp;sn=c6e7c052c6da5077dcf1e067adb45ccd&amp;amp;chksm=fb023e15cc75b7038031e8b1a73f68d47fe426f0370dbced3f84a4aebad5d651eb70c9be6a10&amp;amp;token=1572464062&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;REST API设计指导——译自Microsoft REST API Guidelines（一）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;Developers access most Microsoft Cloud Platform resources via HTTP interfaces.&lt;/p&gt;
&lt;p&gt;开发者基本都通过 HTTP 接口访问微软云平台的资源。&lt;/p&gt;

&lt;p&gt;Although each service typically provides language-specific frameworks to wrap their APIs, all of their operations eventually boil down to HTTP requests.&lt;/p&gt;
&lt;p&gt;尽管每个服务通过特定语言的框架封装了它们的 API，但它们的所有操作最终都归结为 HTTP 请求。&lt;/p&gt;

&lt;p&gt;Microsoft must support a wide range of clients and services and cannot rely on rich frameworks being available for every development environment.&lt;/p&gt;
&lt;p&gt;微软必须支持多种类型的客户端和服务，且不能依赖于各个开发环境丰富的框架。&lt;/p&gt;

&lt;p&gt;Thus a goal of these guidelines is to ensure Microsoft REST APIs can be easily and consistently consumed by any client with basic HTTP support.&lt;/p&gt;
&lt;p&gt;因此，这些准则的一个目标是确保任何支持基本 HTTP 协议的客户端都可以简单且一致地使用 Microsoft REST API。&lt;/p&gt;

&lt;p&gt;To provide the smoothest possible experience for developers, it's important to have these APIs follow consistent design guidelines, thus making using them easy and intuitive.&lt;/p&gt;
&lt;p&gt;为了给开发人员提供最流畅的开发体验，让这些 API 遵循一致的设计准则非常重要，从而使它们用起来简单直观。&lt;/p&gt;

&lt;p&gt;This document establishes the guidelines to be followed by Microsoft REST API developers for developing such APIs consistently.&lt;/p&gt;
&lt;p&gt;本文档建立了 Microsoft REST API 开发人员应该遵循的指南, 以便统一一致地开发 API。&lt;/p&gt;

&lt;p&gt;The benefits of consistency accrue in aggregate as well; consistency allows teams to leverage common code, patterns, documentation and design decisions.&lt;/p&gt;
&lt;p&gt;一致性的好处在于可以不断地积累合理的规范;一致性使团队拥有统一的代码、模式、文档风格和设计策略。&lt;/p&gt;

&lt;p&gt;These guidelines aim to achieve the following:&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Define consistent practices and patterns for all API endpoints across Microsoft.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Adhere as closely as possible to accepted REST/HTTP best practices in the industry at-large.*&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Make accessing Microsoft Services via REST interfaces easy for all application developers.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Allow service developers to leverage the prior work of other services to implement, test and document REST endpoints defined consistently.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Allow for partners (e.g., non-Microsoft entities) to use these guidelines for their own REST endpoint design.&lt;/p&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些准则旨在实现以下目标:&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为 Microsoft 技术平台中的所有 API 端点定义一致的实现和体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽可能地遵循行业普遍接受的 REST/HTTP 最佳实践。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使所有程序的开发人员都可以通过 REST 接口简单地友好地访问 Microsoft 服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;允许Service服务开发人员利用其他Service服务的基础来开发一致的 REST API 节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;允许合作伙伴 (如非微软团队) 使用这些准则来设计自己的 REST API。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*Note: The guidelines are designed to align with building services which comply with the REST architectural style, though they do not address or require building services that follow the REST constraints.&lt;/p&gt;
&lt;p&gt;The term &quot;REST&quot; is used throughout this document to mean services that are in the spirit of REST rather than adhering to REST by the book.*&lt;/p&gt;

&lt;p&gt;注：本指南旨在构建符合 REST 架构风格的服务，但不涉及或要求构建遵循 REST 约束的服务。&lt;/p&gt;
&lt;p&gt;本文档中使用的“REST”术语代指具有 RESTful风格的服务，而不是仅仅遵循 REST。&lt;/p&gt;

&lt;h2&gt;3.1 Recommended reading 推荐阅读&lt;/h2&gt;
&lt;p&gt;Understanding the philosophy behind the REST Architectural Style is recommended for developing good HTTP-based services.&lt;/p&gt;
&lt;p&gt;了解 REST 架构风格背后的一些理念，更有助于开发优秀的基于 HTTP 的服务。&lt;/p&gt;

&lt;p&gt;If you are new to RESTful design, here are some good resources:&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;[REST on Wikipedia][rest-on-wikipedia] -- Overview of common definitions and core ideas behind REST.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;[REST Dissertation][fielding] -- The chapter on REST in Roy Fielding's dissertation on Network Architecture, &quot;Architectural Styles and the Design of Network-based Software Architectures&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;[RFC 7231][rfc-7231] -- Defines the specification for HTTP/1.1 semantics, and is considered the authoritative resource.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;[REST in Practice][rest-in-practice] -- Book on the fundamentals of REST.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您对 RESTful 设计不熟悉，请参阅以下优秀资源：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;概述 REST 背后的常见定义和核心思想。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在 Roy Fielding 关于网络体系结构的论文中&quot;架构风格与基于网络的软件体系结构设计&quot; 一章。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HTTP/1.1 语义规范的权威资料。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关于 REST 的入门书籍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;译者注：上一篇说了，REST 指的是一组架构约束条件和原则。那么满足这些约束条件和原则的应用程序或设计就是 RESTful。&lt;/p&gt;


&lt;h2&gt;4.1 Application of the guidelines 应用指导&lt;/h2&gt;
&lt;p&gt;These guidelines are applicable to any REST API exposed publicly by Microsoft or any partner service.&lt;/p&gt;
&lt;p&gt;这些准则适用于 Microsoft 或其合作伙伴公开发布的所有 REST API 服务。&lt;/p&gt;

&lt;p&gt;Private or internal APIs SHOULD also try to follow these guidelines because internal services tend to eventually be exposed publicly.&lt;/p&gt;
&lt;p&gt;私人或内部的 API 也大致可以遵循这些准则, 因为内部服务往往最终会公开。&lt;/p&gt;

&lt;p&gt;Consistency is valuable to not only external customers but also internal service consumers, and these guidelines offer best practices useful for any service.&lt;/p&gt;
&lt;p&gt;保证一致性不仅对外部客户有利, 而且对内部服务的使用者也很有价值, 这些准则为所有的服务提供了最佳实践。&lt;/p&gt;

&lt;p&gt;There are legitimate reasons for exemption from these guidelines.&lt;/p&gt;
&lt;p&gt;当然有许多合理理由可以不遵循这些准则。&lt;/p&gt;

&lt;p&gt;Obviously a REST service that implements or must interoperate with some externally defined REST API must be compatible with that API and not necessarily these guidelines.&lt;/p&gt;
&lt;p&gt;显然，实现或必须与某些外部定义的 REST API 互操作的 REST 服务必须与那些 API 兼容，而无法遵循这些准则。&lt;/p&gt;

&lt;p&gt;Some services MAY also have special performance needs that require a different format, such as a binary protocol.&lt;/p&gt;
&lt;p&gt;还有一些服务可能由于对性能的特殊的需求，必须使用其他格式，如采用二进制协议。&lt;/p&gt;

&lt;h2&gt;4.2 Guidelines for existing services and versioning of services &lt;/h2&gt;
&lt;p&gt;现有服务和服务版本指南&lt;/p&gt;
&lt;p&gt;We do not recommend making a breaking change to a service that pre-dates these guidelines simply for compliance sake.&lt;/p&gt;
&lt;p&gt;我们不建议为了遵循这些准则，而过早的对老服务进行重大更改。&lt;/p&gt;

&lt;p&gt;The service SHOULD try to become compliant at the next version release when compatibility is being broken anyway.&lt;/p&gt;
&lt;p&gt;无论如何，当兼容性被破坏时，该服务应该尝试在下一版本中变得合规。&lt;/p&gt;

&lt;p&gt;When a service adds a new API, that API SHOULD be consistent with the other APIs of the same version.&lt;/p&gt;
&lt;p&gt;当一个服务添加新的 API 时，该 API 应该与同一版本的其他 API 保持一致。&lt;/p&gt;

&lt;p&gt;So if a service was written against version 1.0 of the guidelines, new APIs added incrementally to the service SHOULD also follow version 1.0. The service can then upgrade to align with the latest version of the guidelines at the service's next major release.&lt;/p&gt;
&lt;p&gt;因此，如果服务是针对 1.0 版本的指南编写的，那么增量添加到服务的新 API 也应该遵循 1.0 版本指南。然后该服务在下一次主要版本更新时，再去遵循最新版指南。&lt;/p&gt;
&lt;h2&gt;4.3 Requirements language 要求的语言&lt;/h2&gt;
&lt;p&gt;The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in RFC 2119.&lt;/p&gt;
&lt;p&gt;本文档中的&quot;MUST&quot;（必须）, &quot;MUST NOT&quot;（禁止）, &quot;REQUIRED&quot;（需要）, &quot;SHALL&quot;（将要）, &quot;SHALL NOT&quot;（最好不要）, &quot;SHOULD&quot;（应该）, &quot;SHOULD NOT&quot;（不应该）, &quot;RECOMMENDED&quot;（推荐）, &quot;MAY&quot;（可能）, 和 &quot;OPTIONAL&quot;（可选） 等关键字的详细解释见 RFC 2119。&lt;/p&gt;

&lt;h2&gt;4.4 License 许可证&lt;/h2&gt;
&lt;p&gt;This work is licensed under the Creative Commons Attribution 4.0 International License. &lt;br/&gt;本文的产权使用Creative Commons Attribution 4.0 International License。 &lt;/p&gt;
&lt;p&gt;译者注：署名 4.0 国际，也就是允许在任何媒介以任何形式复制、发行本作品，允许修改、转换或以本作品为基础进行创作。允许任何用途，甚至商业目的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. &lt;/p&gt;
&lt;p&gt;要查看此许可证的副本，请访问http://creativecommons.org/licenses/by/4.0/&lt;/p&gt;
&lt;p&gt;或向Creative Commons发送一封信，PO Box 1866，Mountain View，CA 94042，USA。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 07:14:00 +0000</pubDate>
<dc:creator>雪雁</dc:creator>
<og:description>由于文章内容较长，只能拆开发布。翻译的不对之处，请多多指教。 另外：最近团队在做一些技术何架构的研究，视频教程只能争取周末多录制一点，同时预计在下周我们会展开一次直播活动，内容围绕容器技术这块。 所有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codelove/p/9935291.html</dc:identifier>
</item>
<item>
<title>从docker到docker-compose部署一个nginx+flask+mysql+redis应用 - luozx207</title>
<link>http://www.cnblogs.com/luozx207/p/9935252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozx207/p/9935252.html</guid>
<description>&lt;h3&gt;　　目的是把一个flask项目的mysql数据库、redis数据库、flask应用、nginx服务分别装到四个容器中，然后用docker-compose命令同时启动与关闭&lt;/h3&gt;
&lt;h3&gt;一、安装docker&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。通过 &lt;strong&gt;uname -r &lt;/strong&gt;命令查看当前的内核版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更新yum&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;sudo yum update&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　移除旧版本&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;sudo yum remove docker &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-client &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-client-latest &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-common &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-latest &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-latest-logrotate &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-logrotate &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-selinux &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-engine-selinux &lt;span class=&quot;Apple-converted-space&quot;&gt;                  docker-engine&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装系统工具&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;sudo yum install -y yum-utils device-mapper-persistent-data lvm2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　添加软件源&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更新yum缓存&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;sudo yum makecache fast&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装docker-ce，对所有选项选y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;sudo yum -y install docker-ce&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查看docker版本&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;docker --version&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　启动docker&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;sudo systemctl start docker&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、只用docker部署&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　注意区分：docker镜像是一个模版，docker容器是一个实例，它可以被启动与关闭。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、首先先把mysql和redis数据库跑起来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　拉镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker pull mysql
docker pull redis:&lt;/span&gt;&lt;span&gt;3.2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;运行，redis并不需要把端口暴露出来，因为只有flask应用需要访问它，直接在启动flask应用容器的时候link到redis就可以了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run --name mysql -p &lt;span&gt;3306&lt;/span&gt;:&lt;span&gt;3306&lt;/span&gt; -e MYSQL_ROOT_PASSWORD=*** -&lt;span&gt;d mysql
docker run &lt;/span&gt;--name redis -d redis:&lt;span&gt;3.2&lt;/span&gt; redis-server --appendonly yes
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　2、部署flask应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一开始我直接拉了一个centos镜像，然后再装python3、requirement.txt，但是后来发现直接用python:3.6的镜像会简单一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，把项目复制到服务器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scp&lt;/span&gt; -r 本地文件夹 root@服务器公网ip:服务器目标文件夹
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　然后，创建一个Dockerfile，用于将应用build成镜像&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目录结构如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220254/201811/1220254-20181109104138673-624498417.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;108&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;Dockerfile的内容&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; python:3.6
&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; ./my-chat-server /app
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; pip install -r requirement.txt
&lt;/span&gt;&lt;span&gt;CMD&lt;/span&gt; [&quot;python&quot;, &quot;run.py&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　RUN与CMD的区别在于，RUN是在创建镜像的时候执行的，而CMD在这个镜像创建的容器每次启动时都会执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ADD与COPY的区别在于，ADD可以写成 &lt;code&gt;ADD http://foo.com/bar.go /tmp/main.go 或 &lt;/code&gt;&lt;code&gt;ADD /foo.tar.gz /tmp/ 用于下载一个文件到容器中或者将一个压缩文件解压到容器中。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　然后，在flask目录执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker build -t flask .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这会创建一个名为flask的镜像&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　然后启动这个镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --name flask -p 5000:5000 --link mysql:mysql --link redis:redis-server -d flask
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　注意应用中mysql和redis的host都要相应改变，改成数据库容器在flask容器中的别名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--link 容器名：容器别名 可以实现容器间的通信&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如无意外现在可以从服务器的5000端口访问到flask应用了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　3、部署nginx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先拉一个镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker pull nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　然后启动&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --name nginx -p &lt;span&gt;80&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -d nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　将里面的nginx.conf文件内容拿出来&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker exec -it nginx &lt;span&gt;cat&lt;/span&gt; /etc/nginx/nginx.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　然后创建一个nginx.conf，把这些内容复制进去，在http里加上&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    server {
      listen &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;; 
      server_name 服务器公网ip;
    
      location &lt;/span&gt;/&lt;span&gt; {
         proxy_pass  http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;flask:5000;&lt;/span&gt;
&lt;span&gt;    }
       access_log &lt;/span&gt;/var/log/&lt;span&gt;access_unicom.log main;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　然后把刚创的nginx镜像删掉，注意删除容器是docker rm；删除镜像是docker rmi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创建一个以刚才创建的nginx.conf为配置的nginx容器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --name nginx -p &lt;span&gt;80&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -v /root/nginx.conf:/etc/nginx/nginx.conf --link flask -d nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　现在通过服务器的80端口就可以访问到flask应用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　只使用docker的部署完成，下面我们来用docker-compose实现更方便的部署&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;三、docker-compose部署&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　docker-compose可以很方便地通过一个文件构建多个镜像、启动多个容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装docker-compose（最新版&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; curl -L &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o /usr/local/bin/docker-&lt;span&gt;compose
&lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; +x /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;　　要使用docker-compose，首先要把每个部分的Dockerfile写好，然后在docker-compose.yml文件中统一构建和启动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　整个docker-compose项目的目录结构为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220254/201811/1220254-20181109113624747-23297949.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;52&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　三个目录下分别有它们的Dockerfile和相关的配置文件或代码&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　flask目录的目录结构和Dockerfile和之前是一样的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　mysql的Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; mysql
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt; ./init.sql /docker-entrypoint-initdb.d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　init.sql是数据库初始化文件，它会把flask应用需要用到的库和表创建出来。在mysql官方镜像中提供了容器启动时自动执行&lt;code&gt;/docker-entrypoint-initdb.d&lt;/code&gt;文件夹下的脚本的功能(包括shell脚本和sql脚本) 。因此我们只要把初始化文件在镜像启动时复制到&lt;code&gt;/docker-entrypoint-initdb.d&lt;/code&gt;文件夹就可以了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　nginx的Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; nginx
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt; ./nginx.conf /etc/nginx/nginx.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在之前，我使用挂载的方式将nginx.conf导入nginx容器，这个方法有一个问题就是如果我要把这一套生产环境打包到另一个系统，docker export并不会将挂载的内容一起打包，因此，最好还是在构建镜像的时候就把相关配置加到镜像里。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　redis没有需要导入的配置，因此没有它的Dockerfile&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　docker-compose.yml文件的内容&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: '3'&lt;span&gt;
services:
  mysql:
    build: ./mysql
    ports: 
      - &lt;/span&gt;&quot;3306:3306&quot;&lt;span&gt;
    environment:
      - MYSQL_ROOT_PASSWORD=***&lt;/span&gt;&lt;span&gt;
    restart: always
  redis:
    image: redis:&lt;/span&gt;3.2&lt;span&gt;
    restart: always
  flask:
    build: ./flask
    ports:
     - &lt;/span&gt;&quot;5000:5000&quot;&lt;span&gt;
    links: 
     - mysql:mysql  
     - redis:redis-server 
    restart: always
  nginx: 
    build: ./nginx 
    ports: 
      - &lt;/span&gt;&quot;80:80&quot;&lt;span&gt; 
    links: 
     - flask &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　docker-compose会先从每个服务的build目录下找到Dockerfile，然后依次镜像。所有镜像创建完毕后，再根据yml文件中其他配置依次启动镜像的容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当docker-compose启动一次后，只要不更改它自动生成的容器和镜像，再次启动，它就不会再创建镜像，而是启动之前生成的容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果想要更改单个服务的内容，修改Dockerfile的内容、或者删除docker-compose自动生成的容器和镜像，再次启动docker-compose的时候，它会重新构建修改后服务的容器，而其他没有做过修改的服务不变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　执行docker-compose up启动所有服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220254/201811/1220254-20181109144321796-613615854.png&quot; alt=&quot;&quot; width=&quot;1425&quot; height=&quot;129&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你的应用已经可以在80端口访问了，enjoy！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 07:10:00 +0000</pubDate>
<dc:creator>luozx207</dc:creator>
<og:description>目的是把一个flask项目的mysql数据库、redis数据库、flask应用、nginx服务分别装到四个容器中，然后用docker-compose命令同时启动与关闭 一、安装docker Docke</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luozx207/p/9935252.html</dc:identifier>
</item>
<item>
<title>Spring核心概念 - 安心。</title>
<link>http://www.cnblogs.com/anxin0/p/9935146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anxin0/p/9935146.html</guid>
<description>&lt;h4 id=&quot;初始spring&quot;&gt;初始Spring&lt;/h4&gt;
&lt;p&gt;在学习Spring之前让我们先了解一下企业级应用.企业级应用是指那些为商业组织,大型企业而创建并部署的解决方案及应用,这些大型企业级应用的结构复杂,涉及的外部资源众多,事务密集,数据规模大,用户数量多.有较强的安全性考虑和较高的性能要求,而Spring就是用来做解决这些问题的&lt;/p&gt;
&lt;p&gt;Spring是一个轻量级的框架,是当前的主流框架,它能使现有技术更加易用,推进编码最佳实践&lt;/p&gt;
&lt;p&gt;Spring坚持一个原则：不重新发名轮子 Spring由大约20个模块组成。&lt;br/&gt;分成六个部分：Core Container、DataAccess/Integration、Web、AOP、Instrumentation、Test。&lt;br/&gt;Spring Core是框架的最基础的部分，提供了IOC特性&lt;br/&gt;Spring Context为企业级开发提供了便利和集成的工具&lt;br/&gt;Spring AOP是基于Spring Core的符合规范的面向切面编程的实现。&lt;br/&gt;Spring JDBC提供了JDBC的抽象层，简化了JDBC编码&lt;br/&gt;Spring ORM对市面上流行的ORM框架提供了支持&lt;br/&gt;Spring Web 为Spring在Web应用程序中的使用提供了支持&lt;/p&gt;
&lt;h4 id=&quot;spring-ioc&quot;&gt;Spring IOC&lt;/h4&gt;
&lt;p&gt;理解控制反转&lt;br/&gt;控制反转(Inversion of Control,IoC),也称为依赖注入(Dependency Injection,DI),是面向对象编程中的一种设计理念,用来降低代码之间的耦合度&lt;br/&gt;首先考虑什么是依赖,例如:在A类方法中,实例化了B类的对象并调用其方法以完成特定的功能,我们就&lt;br/&gt;说A类依赖于B类,下面我们通过示例理解一下.&lt;/p&gt;
&lt;p&gt;定义一个接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface UserDao{
    /**
    *保存用户信息的方法
    */
    public void save(User user);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口的实现类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    pulbic class UserDaoImpl implements UserDao{
        public void save(User user){
            System.out.print(&quot;保存用户信息到数据库&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户的业务类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserServiceImpl implements UserService{
    //实例化所依赖的UserDao对象
    private UserDao dao=new UserDapImpl();
    //调用UserDao的方法保存用户信息
    dao.save(User);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码所示,UserServiceImpl对UserDaoImpl存在依赖关系,这样的代码很常见,但是存在一个严重的问题,就是这个两个类是高度耦合,如果我们有新的需求需要替换UserDao的实现类,导致UserServiceImpl里面的代码也要随之发生改变,这种代码不具有优良的可扩展性和可维护性,甚至在开发中难以测试&lt;/p&gt;
&lt;p&gt;我们可以利用简单的工厂和工厂模式的思路解决此类问题&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserDaoFactory{
    public static UserDao getInstance(){
        //具体实现过程省略
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserServiceImpl implements UserService{
    //通过工厂获取所依赖的用户DAO对象
    private UserDao dao=UserDaoFactory.getInstance();
    public void addNewUser(User user){
        //调用用户DAO的方法保存用户信息
        dao.save(user);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的用户DAO工厂类UserDaoFactory就体现了&quot;控制反转的思想&quot;:UserServiceImpl不再依赖自身的代码去获得所依赖的具体DAO对象,而是把这一工作转交给了第三方--UserDaoFactory,从而避免了和具体UserDao实现类之间的耦合&lt;/p&gt;
&lt;h5 id=&quot;下面我们用spring-ioc-来实现&quot;&gt;下面我们用Spring IOC 来实现&lt;/h5&gt;
&lt;p&gt;首先我们要下载Spring的jar包&lt;br/&gt;&lt;a href=&quot;http://maven.springframework.org/release/org/springframework/spring/&quot;&gt;jar包下载地址&lt;/a&gt; 我这边是用的版本是4.3.18&lt;br/&gt;解压后的文件几个重要文件夹的意思:&lt;br/&gt;docs:该文件夹下包含Spring的相关文档,包括API参考文档,开发手册&lt;br/&gt;libs:该文件夹下存放Spring各个模块的jar文件,每个模块均提供三项内容,开发所需的jar文件,以&quot;-javadoc&quot;后缀表示的API和以&quot;-sources&quot;后缀表示的源文件&lt;br/&gt;schema:配置Spring的某些功能时需要用到的schema文件,对于已经集成了Spring的IDE环境(如MyEclipse,IDEA),这些文件不需要专门导入&lt;/p&gt;
&lt;p&gt;我们将jar导入到项目中&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427783/201811/1427783-20181109144626330-1604682215.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为项目添加log4j.properties文件,用来控制日志输出 文件放到resources里面&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 下面的属性配置中，所有日志的输出级别是info，输出源是con 
log4j.rootLogger=info,error,con
#定义输出源的输出位置是控制台
log4j.appender.con=org.apache.log4j.ConsoleAppender
#定义输出日志的布局采用的类 
log4j.appender.con.layout=org.apache.log4j.PatternLayout
#定义日志输出布局
log4j.appender.con.layout.ConversionPattern=%d{MM-dd HH:mm:ss}{%p}%c%n -%m%n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写HelloSpring类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.springdemo;

/**
 * 第一个Spring,输出&quot;Hello,Spring!&quot;。
 * 
 * @author 安心
 */
public class HelloSpring {
    // 定义who属性，该属性的值将通过Spring框架进行设置
    private String who = null;
    /**
     * 定义打印方法，输出一句完整的问候。
     */
    public void print() {
        System.out.println(&quot;Hello,&quot; + this.getWho() + &quot;!&quot;);
    }
    /**
     * 获得 who。
     * 
     * @return who
     */
    public String getWho() {
        return who;
    }
    /**
     * 设置 who。
     * 
     * @param who
     */
    public void setWho(String who) {
        this.who = who;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在resources下面创建applicationContext.xml文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;!-- 通过bean元素声明需要Spring创建的实例。该实例的类型通过class属性指定，并通过id属性为该实例指定一个名称，以便在程序中使用 --&amp;gt;
    &amp;lt;bean id=&quot;helloSpring&quot; class=&quot;cn.springdemo.HelloSpring&quot;&amp;gt;
        &amp;lt;!-- property元素用来为实例的属性赋值,此处实际是调用setWho()方法实现赋值操作 --&amp;gt;
        &amp;lt;property name=&quot;who&quot;&amp;gt;
            &amp;lt;!-- 此处将字符串&quot;Spring&quot;赋值给who属性 --&amp;gt;
            &amp;lt;value&amp;gt;Spring&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Spring配置文件中,使用&lt;/p&gt;
&lt;p&gt;编写测试方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public void helloSpring() {
        // 通过ClassPathXmlApplicationContext实例化Spring的上下文
        ApplicationContext context = new ClassPathXmlApplicationContext(
                &quot;applicationContext.xml&quot;);
        // 通过ApplicationContext的getBean()方法，根据id来获取bean的实例
        HelloSpring helloSpring = (HelloSpring) context.getBean(&quot;helloSpring&quot;);
        // 执行print()方法
        helloSpring.print();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码中的ApplicationContext是一个接口,负责读取Spring配置文件,管理对象的加载,生成,维护Bean对象与Bean对象之间的依赖关系,负责Bean的生命周期等,ClassPathXmlApplicationContext是ApplicationContext接口的实现类,用于从classpath路径中读取Spring配置文件&lt;/p&gt;
&lt;h4 id=&quot;spring-aop&quot;&gt;Spring AOP&lt;/h4&gt;
&lt;p&gt;理解面向切面&lt;br/&gt;面向切面编程（Aspect Oriented Programmin ,AOP）是软件编程发展到一定阶段的产物，AOP一般适用于具有横切逻辑的场合，如访问控制、事务管理、性能检测等。&lt;br/&gt;面向切面编程，简单的说就是在不改变原程序设计的基础上位代码段增加新的功能，对代码段进行增强处理。设计思想来源于代理设计模式。&lt;/p&gt;
&lt;p&gt;直接调用对象的方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427783/201811/1427783-20181109144640630-507547674.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在代理模式中可以为该对象设置一个代理对象，代理对象为fun()提供一个代理方法，当通过代理对象的fun()方法调用原方法的fun()方法时，就可以在代理方法中添加新的功能，也就是所谓的增强处理。&lt;br/&gt;通过代理对象调用方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427783/201811/1427783-20181109144657436-1077875920.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AOP相关术语&lt;br/&gt;增强处理（Advice）&lt;br/&gt;前置增强&lt;br/&gt;后置增强&lt;br/&gt;环绕增强、异常抛出增强、最终增强等类型&lt;br/&gt;1、横切关注点&lt;br/&gt;对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点&lt;br/&gt;2、切面（aspect）&lt;br/&gt;类是对物体特征的抽象，切面就是对横切关注点的抽象&lt;br/&gt;3、连接点（joinpoint）&lt;br/&gt;被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器&lt;br/&gt;4、切入点（pointcut）&lt;br/&gt;对连接点进行拦截的定义&lt;br/&gt;5、通知（advice）&lt;br/&gt;所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类&lt;br/&gt;6、目标对象&lt;br/&gt;代理的目标对象&lt;br/&gt;7、织入（weave）&lt;br/&gt;将切面应用到目标对象并导致代理对象创建的过程&lt;br/&gt;8、引入（introduction）&lt;br/&gt;在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段&lt;/p&gt;
&lt;p&gt;下面我们写一个使用Spring AOP实现日志输出也就是我们的log4j&lt;br/&gt;1.我们先在项目中加入jar包&lt;br/&gt;spring-aop 这个jar包 这个jar包给我们提供了AOP的实现,同时，Spring AOP还依赖AOP Alliance(aopalliance-1.0.jar)和AspectJ(aspectjweaver-1.6.9.jar)项目中的组件&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427783/201811/1427783-20181109144706056-1940951341.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来编写业务类UserServiceImpl&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * 用户业务类，实现对User功能的业务管理
 */
public class UserServiceImpl implements UserService {

    // 声明接口类型的引用，和具体实现类解耦合
    private UserDao dao;

    // dao 属性的setter访问器，会被Spring调用，实现设值注入
    public void setDao(UserDao dao) {
        this.dao = dao;
    }

    public void addNewUser(User user) {
        // 调用用户DAO的方法保存用户信息
        dao.save(user);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该项目中有一个addNewUser()方法,实现添加用户的业务,接下来就以AOP的方式为该方法添加日志功能&lt;br/&gt;编写增强类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserServiceLogger {
    private static final Logger log = Logger.getLogger(UserServiceLogger.class);

    public void before(JoinPoint jp) {
        log.info(&quot;调用 &quot; + jp.getTarget() + &quot; 的 &quot; + jp.getSignature().getName()
                + &quot; 方法。方法入参：&quot; + Arrays.toString(jp.getArgs()));
    }
    
    public void afterReturning(JoinPoint jp, Object result) {
        log.info(&quot;调用 &quot; + jp.getTarget() + &quot; 的 &quot; + jp.getSignature().getName()
                + &quot; 方法。方法返回值：&quot; + result);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;before()方法也就是在我们代码执行之前运行,afterReturning()在我们执行代码之后运行.Join Point类型的参数,Spring会自动注入该实例,通过getTarget()方法可以得到被代理的目标对象,getSignature()方法返回被代理的目标方法,getArgs()方法返回传递给目标方法的参数数组&lt;/p&gt;
&lt;p&gt;在Spring配置文件中对相关组件进行声明&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;dao&quot; class=&quot;dao.impl.UserDaoImpl&quot;&amp;gt; &amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;service&quot; 
class=&quot;service.impl.UserServiceImpl&quot;&amp;gt;
    &amp;lt;property name=&quot;userDao&quot; ref=&quot;dao&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;theLogger&quot; class=&quot;aop.UserServiceLogger&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来在Spring配置文件中进行AOP相关的配置,首先定义切入点&lt;br/&gt;定义切入点&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dao&quot; class=&quot;com.jikedaquan.spring.dao.impl.UserDaoImpl&quot;&amp;gt; &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;service&quot; class=&quot;service.impl.UserServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;userDao&quot; ref=&quot;dao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;theLogger&quot; class=&quot;aop.UserServiceLogger&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!--定义一个切入点表达式，并命名为“pointcut”--&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; 
        expression=&quot;execution(public void addNewUser(entity.User))&quot;/&amp;gt; 
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与AOP相关的配置都放在&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public * addNewUser(entity.User)：* 表示匹配所有类型的返回值&lt;/li&gt;
&lt;li&gt;public void * (entity.User)：* 表示匹配所有方法名。&lt;/li&gt;
&lt;li&gt;public void addNewUser(..)：.. 表示匹配所有参数个数和类型&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;com.service.* .*(..)：匹配com.service包下所有类的所有方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;com.service..* .&lt;em&gt;(..)：匹配com.service包及其子包下所有类的所有方法 (前面句号就是&lt;/em&gt; 不知道为啥 *显示不出来 应该是Markdown的某个命令符号把)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家可以根据自己的需求来设置切入点的匹配规则,当然配置的关键字还有很多,我就不一一介绍了,如果有兴趣可以查看Spring的&lt;a href=&quot;http://shouce.jb51.net/spring/&quot;&gt;开发手册&lt;/a&gt;&lt;br/&gt;最后还需要在切入点处插入增强处理,这个过程的专业叫法是”织入“&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dao&quot; class=&quot;com.jikedaquan.spring.dao.impl.UserDaoImpl&quot;&amp;gt; &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;service&quot; class=&quot;service.impl.UserServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;userDao&quot; ref=&quot;dao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;theLogger&quot; class=&quot;aop.UserServiceLogger&quot;&amp;gt;&amp;lt;/bean&amp;gt; 
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!--定义一个切入点表达式，并命名为“pointcut”--&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public void addNewUser(entity.User))&quot;/&amp;gt;
        &amp;lt;!--引用包含增强方法的Bean--&amp;gt;
        &amp;lt;aop:aspect ref=&quot;theLogger&quot;&amp;gt;
            &amp;lt;!--将before()方法定义为前置增强并引用pointcut切入点--&amp;gt;
            &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut&quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
            &amp;lt;!--将afterReturning()方法定义为后置增强并引用pointcut切入点--&amp;gt;
            &amp;lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointcut&quot; returning=&quot;result&quot;&amp;gt;&amp;lt;/aop:after-returning&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;  
       &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ApplicationContext context=new 
ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserService service= (UserService) context.getBean(&quot;service&quot;);
User user =new User();
service.addNewUser(null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下一篇文章还有很详细的讲解IOC和AOP一些功能,不足的地方欢迎大家提出意见&lt;br/&gt;by安心&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 06:56:00 +0000</pubDate>
<dc:creator>安心。</dc:creator>
<og:description>初始Spring 在学习Spring之前让我们先了解一下企业级应用.企业级应用是指那些为商业组织,大型企业而创建并部署的解决方案及应用,这些大型企业级应用的结构复杂,涉及的外部资源众多,事务密集,数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anxin0/p/9935146.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第一章 功能及架构分析 - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/9934970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/9934970.html</guid>
<description>&lt;p&gt;从本文开始，我们正式进入项目研发阶段，首先我们分析下统一认证平台应该具备哪些功能性需求和非功能性需求，在梳理完这些需求后，设计好系统采用的架构来满足已有的需求和未来的扩展应用。&lt;/p&gt;

&lt;p&gt;统一认证平台应该具备以下基本功能，本文只是抛砖引玉，我只列出后续课程会讲到的相关内容的需求，不会详细的设计功能和需求，详细的功能需求可在此基础上根据项目需要自己扩充。&lt;/p&gt;
&lt;h2 id=&quot;统一授权&quot;&gt;统一授权&lt;/h2&gt;
&lt;p&gt;可以为不同的业务系统提供一套标准、安全、可靠的授权方式，减少重复编码工作，也可有效整合公司内部团队使用技术架构不统一造成后期整合困难的问题。&lt;/p&gt;
&lt;h2 id=&quot;身份认证&quot;&gt;身份认证&lt;/h2&gt;
&lt;p&gt;用户访问各业务系统时，提供用户访问的身份认证工作，校验身份的合法性。&lt;/p&gt;
&lt;h2 id=&quot;单点登录&quot;&gt;单点登录&lt;/h2&gt;
&lt;p&gt;用户在认证平台通过认证后，可直接访问已授权的所有应用系统，实现不同应用系统的身份认证共享，从而达到多应用系统的单点登录。&lt;/p&gt;
&lt;h2 id=&quot;扫码登录&quot;&gt;扫码登录&lt;/h2&gt;
&lt;p&gt;对于安全性要求较高的应用，可能对用户身份进行二次认证，其中扫码登录就是一种认证方式，后期会单独列篇章在讲解扫码登录的实现。&lt;/p&gt;

&lt;h2 id=&quot;兼容性&quot;&gt;兼容性&lt;/h2&gt;
&lt;p&gt;系统设计时需要考虑到兼容性问题，考虑到后期接入的客户端的不确定性，设计时应满足采用统一标准所有客户端均可接入。&lt;/p&gt;
&lt;h2 id=&quot;扩展性&quot;&gt;扩展性&lt;/h2&gt;
&lt;p&gt;系统设计时需要考虑到系统的可扩展性，随着接入应用的增多，系统也要支持横向扩展来满足高并发的需求。&lt;/p&gt;
&lt;h2 id=&quot;安全性&quot;&gt;安全性&lt;/h2&gt;
&lt;p&gt;系统设计时需要考虑系统应用的安全性，从数据安全到传输安全，保证认证平台安全稳定运行。&lt;/p&gt;

&lt;p&gt;根据以上需求，形成初步的系统架构，后续的课程会围绕此架构的基础上进行讲解，并一步一步来实现所有的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181109143417244-1951708912.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过此微服务架构，我们可以很好的对项目进行扩展应用，随后我们会发现有几个问题需要解决。&lt;/p&gt;
&lt;ul readability=&quot;0.95485175202156&quot;&gt;&lt;li readability=&quot;1.3817204301075&quot;&gt;
&lt;p&gt;1、网关的功能及实现？&lt;/p&gt;
&lt;blockquote readability=&quot;7.3307984790875&quot;&gt;
&lt;p&gt;网关应该具备路由、认证、鉴权、限流、熔断、缓存、监控等一系列功能，所有的请求都优先进入网关，他是整个应用程序的基石，所以网关应该满足横向扩展的需求来应对未来的请求压力。那如何实现这个网关呢？大名鼎鼎的&lt;a href=&quot;http://threemammals.com/ocelot&quot;&gt;Ocelot&lt;/a&gt;就派上用场了，开源地址(&lt;a href=&quot;https://github.com/ThreeMammals/Ocelot&quot; class=&quot;uri&quot;&gt;https://github.com/ThreeMammals/Ocelot&lt;/a&gt;)，后续的网关功能实现都是基于Ocelot的基础上进行扩展实现，如有不熟悉的，可以先自己查看Ocelot相关的文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.4342783505155&quot;&gt;
&lt;p&gt;2、授权和认证的功能及如何实现？&lt;/p&gt;
&lt;blockquote readability=&quot;7.6011730205279&quot;&gt;
&lt;p&gt;如何实现标准、安全、可扩展的认证模块，这块就靠我们另外一个开源项目在解决我们的问题，&lt;a href=&quot;https://identityserver4.readthedocs.io/en/release/&quot;&gt;Identity Server 4&lt;/a&gt;，这个组件基本能满足我们常用的应用，基本的使用方法可参考园友们的基础教程，后续的应用会就满足我们业务需求需要改造的部分进行详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;3、如何实现服务注册中心？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;应用中会结合Consul集群和.Netcore服务，实现服务的自动注册、移除、监控、通知等一系列功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.4758064516129&quot;&gt;
&lt;p&gt;4、为什么要搭载配置中心及如何实现？&lt;/p&gt;
&lt;blockquote readability=&quot;7.8495297805643&quot;&gt;
&lt;p&gt;一旦项目使用分布式架构，面临的最大的问题是每次发布都要修改项目的配置信息，想象一下如果我们有100个服务，配置信息一致，需要修改100次，天哪。漏了百八十个忘了改也正常，这次我们就需要把配置信息进行独立管理，&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/.Net%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97&quot;&gt;Apollo&lt;/a&gt;闪亮登场.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后续的文章将围绕我们提出的4个问题来一个一个实现，下一篇我们将从网关这块来讲解下如何设计出跟项目需求契合的网关，对于当前未实现的部分如何进行改造。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 06:35:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/9934970.html</dc:identifier>
</item>
<item>
<title>SpringAOP+RabbitMQ+WebSocket实战 - little-sheep</title>
<link>http://www.cnblogs.com/little-sheep/p/9934887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/little-sheep/p/9934887.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;最近公司的客户要求，分配给员工的任务除了有微信通知外，还希望PC端的网页也能实时收到通知。管理员分配任务是在我们的系统A,而员工接受任务是在系统B。两个系统都是现在已投入使用的系统。&lt;/p&gt;
&lt;h2&gt;技术选型&lt;/h2&gt;
&lt;p&gt;       根据需求我们最终选用SpringAOP+RabbitMQ+WebSocket。&lt;/p&gt;
&lt;p&gt;       SpringAOP可以让我们不修改原有代码，直接将原有service作为切点，加入切面。RabbitMQ可以让A系统和B系统解耦。WebSocket则可以达到实时通知的要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181109141149474-1966535959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;SpringAOP&lt;/h3&gt;
&lt;p&gt;AOP称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待。是Spring的核心模块，底层是通过动态代理来实现（动态代理将在之后的文章重点介绍）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Aspect(切面)：&lt;/strong&gt;通常是一个类，里面可以定义切入点和通知。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;JointPoint(连接点)：&lt;/strong&gt;程序执行过程中明确的点，一般是方法的调用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Advice(通知)：&lt;/strong&gt;AOP在特定的切入点上执行的增强处理，有before,after,afterReturning,afterThrowing,around。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Pointcut(切入点)：&lt;/strong&gt;就是带有通知的连接点，在程序中主要体现为书写切入点表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通知类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Before：&lt;/strong&gt;在目标方法被调用之前做增强处理。&lt;/p&gt;
&lt;p&gt;@Before只需要指定切入点表达式即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AfterReturning：&lt;/strong&gt;在目标方法正常完成后做增强。&lt;/p&gt;
&lt;p&gt;@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AfterThrowing：&lt;/strong&gt;主要用来处理程序中未处理的异常。&lt;/p&gt;
&lt;p&gt;@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名&lt;/p&gt;
&lt;p&gt;来访问目标方法中所抛出的异常对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After：&lt;/strong&gt;在目标方法完成之后做增强，无论目标方法时候成功完成。&lt;/p&gt;
&lt;p&gt;@After可以指定一个切入点表达式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Around：&lt;/strong&gt;环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3&gt;RabbitMQ&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181109141228742-262354675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（图摘自：&lt;a href=&quot;https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html&quot;&gt;https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html&lt;/a&gt;）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;从图中我们可以看到RabbitMQ主要的结构有：Routing、Binding、Exchange、Queue。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Queue（队列）RabbitMQ的作用是存储消息，队列的特性是先进先出。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Exchange&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，还会将不符合路由规则的消息丢弃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Routing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt; 用于标记或生产者寻找Exchange。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt; 用于Exchange和Queue做关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exchange Type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fanout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;direct&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;direct会把消息路由到那些binding key与routing key完全匹配的Queue中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;topic&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;direct规则是严格意义上的匹配，换言之Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue，那么topic这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;headers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。&lt;/p&gt;

&lt;h3&gt;WebSocket&lt;/h3&gt;
&lt;p&gt;了解websocket必须先知道几个常用的web通信技术及其区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;短轮询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　短轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。&lt;/p&gt;
&lt;p&gt;　　这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。&lt;/p&gt;
&lt;p&gt;　　因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;长轮询/&lt;/strong&gt;&lt;strong&gt;comet&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　comet指的是，当服务器收到客户端发来的请求后，不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)后关闭连接。&lt;/p&gt;
&lt;p&gt;　　长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。&lt;/p&gt;
&lt;p&gt;　　SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。并且SSE的实现非常简单，不需要依赖其他插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WebSocket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　WebSocket是Html5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。&lt;/p&gt;
&lt;p&gt;　　WebSocket的优点是实现了双向通信，缺点是服务器端的逻辑非常复杂。现在针对不同的后台语言有不同的插件可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四种Web即时通信技术比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从兼容性角度考虑，短轮询&amp;gt;长轮询&amp;gt;长连接SSE&amp;gt;WebSocket；&lt;/p&gt;
&lt;p&gt;　　从性能方面考虑，WebSocket&amp;gt;长连接SSE&amp;gt;长轮询&amp;gt;短轮询。&lt;/p&gt;
&lt;h2&gt;实战&lt;/h2&gt;
&lt;p&gt;项目使用SpringBoot搭建。RabbitMQ的安装这里不讲述。&lt;/p&gt;
&lt;h3&gt;RabbitMQ配置&lt;/h3&gt;
&lt;p&gt;两个系统A、B都需要操作RabbitMQ，其中A生产消息，B消费消息。故都需要配置。&lt;/p&gt;
&lt;p&gt;1、首先引入RabbitMQ的dependency：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-amqp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个dependency中包含了RabbitMQ相关dependency。&lt;/p&gt;
&lt;p&gt;2、在项目的配置文件里配置为使用rabbitmq及其参数。&lt;/p&gt;
&lt;p&gt;application-pro.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#消息队列
message.queue.type: rabbitmq
## rabbit mq properties
rabbitmq:
  host: localhost
  port: 5672
  username: guest
  password: guest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#将要使用的队列名
rabbitmq.websocket.msg.queue=websocket_msg_queue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、创建配置文件。队列的创建交给spring。&lt;/p&gt;
&lt;p&gt;RabbitMQConfig.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableRabbit
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitMQConfig {

    @Value(&lt;/span&gt;&quot;${rabbitmq.host}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String host;
    @Value(&lt;/span&gt;&quot;${rabbitmq.port}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String port;
    @Value(&lt;/span&gt;&quot;${rabbitmq.username}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    @Value(&lt;/span&gt;&quot;${rabbitmq.password}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    @Value(&lt;/span&gt;&quot;${rabbitmq.websocket.msg.queue}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String webSocketMsgQueue;

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConnectionFactory connectionFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        CachingConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CachingConnectionFactory();
        factory.setUsername(username);
        factory.setPassword(password);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        factory.setVirtualHost(&quot;test&quot;);&lt;/span&gt;
&lt;span&gt;        factory.setHost(host);
        factory.setPort(Integer.valueOf(port));
        factory.setPublisherConfirms(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列参数，是否持久化、队列TTL、队列消息TTL等&lt;/span&gt;
        factory.createConnection().createChannel(&lt;span&gt;false&lt;/span&gt;).queueDeclare(webSocketMsgQueue, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MessageConverter messageConverter() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Jackson2JsonMessageConverter();
    }

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须是prototype类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; RabbitTemplate rabbitTemplate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RabbitTemplate(connectionFactory());
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        SimpleRabbitListenerContainerFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setConcurrentConsumers(&lt;/span&gt;3&lt;span&gt;);
        factory.setMaxConcurrentConsumers(&lt;/span&gt;10&lt;span&gt;);
        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、系统B中创建队列监听，当队列有消息时，发送websocket通知。&lt;/p&gt;
&lt;p&gt;RabbitMQListener.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitMQListener {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RabbitMQService mqService;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * WebSocket推送监听器
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; socketEntity
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; deliveryTag
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; channel
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RabbitListener(queues &lt;/span&gt;= &quot;websocket_msg_queue&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; webSocketMsgListener(@Payload WebSocketMsgEntity socketMsgEntity, @Header(AmqpHeaders.DELIVERY_TAG) &lt;span&gt;long&lt;/span&gt; deliveryTag, Channel channel) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        mqService.handleWebSocketMsg(socketMsgEntity, deliveryTag, channel);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RabbitMQService.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitMQService {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MessageWebSocketHandler messageWebSocketHandler;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; socketMsgEntity
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; deliveryTag
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; channel
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; handleWebSocketMsg(WebSocketMsgEntity socketMsgEntity, &lt;span&gt;long&lt;/span&gt; deliveryTag, Channel channel) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            messageWebSocketHandler.sendMessageToUsers(socketMsgEntity.toJsonString(), socketMsgEntity.getToUserIds());
            channel.basicAck(deliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            channel.basicNack(deliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WebSocketMsgEntity为MQ中传送的实体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebSocketMsgEntity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; OrderType{
        repair(&lt;/span&gt;&quot;维修&quot;&lt;span&gt;),
        maintain(&lt;/span&gt;&quot;保养&quot;&lt;span&gt;),
        measure(&lt;/span&gt;&quot;计量&quot;&lt;span&gt;);

        OrderType(String value){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        }
        String value;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备名称&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String EquName;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备编号&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String EquId;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工单类型&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderType orderType;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工单单号&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String orderId;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工单状态&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String orderStatus;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date createTime;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息接收人ID&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; toUserIds;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getEquName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; EquName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setEquName(String equName) {
        EquName &lt;/span&gt;=&lt;span&gt; equName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getOrderId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrderId(String orderId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderId =&lt;span&gt; orderId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getEquId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; EquId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setEquId(String equId) {
        EquId &lt;/span&gt;=&lt;span&gt; equId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getOrderStatus() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderStatus;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrderStatus(String orderStatus) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderStatus =&lt;span&gt; orderStatus;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OrderType getOrderType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrderType(OrderType orderType) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderType =&lt;span&gt; orderType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getCreateTime() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createTime;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCreateTime(Date createTime) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.createTime =&lt;span&gt; createTime;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getToUserIds() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; toUserIds;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setToUserIds(List&amp;lt;String&amp;gt;&lt;span&gt; toUserIds) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.toUserIds =&lt;span&gt; toUserIds;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toJsonString(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JSON.toJSONString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;SpringAOP&lt;/h3&gt;
&lt;p&gt;1、系统A中创建一个切面类DataInterceptor.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataInterceptor {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MessageQueueService queueService;


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;维修工单切点&lt;/span&gt;
    @Pointcut(&quot;execution(* com.zhishang.hes.common.service.impl.RepairServiceImpl.executeFlow(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; repairMsg() {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回通知，方法执行正常返回时触发
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; joinPoint
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; result
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @AfterReturning(value &lt;/span&gt;= &quot;repairMsg()&quot;, returning = &quot;result&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturning(JoinPoint joinPoint, Object result) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处可以获得切点方法名
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String methodName = joinPoint.getSignature().getName();&lt;/span&gt;
        EquipmentRepair equipmentRepair =&lt;span&gt; (EquipmentRepair) result;
        WebSocketMsgEntity webSocketMsgEntity &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.generateRepairMsgEntity(equipmentRepair);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (webSocketMsgEntity == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        queueService.send(webSocketMsgEntity);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 生成发送到MQ的维修消息
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; equipmentRepair
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; WebSocketMsgEntity generateRepairMsgEntity(EquipmentRepair equipmentRepair) {
        WebSocketMsgEntity webSocketMsgEntity &lt;/span&gt;=&lt;span&gt; generateRepairMsgFromTasks(equipmentRepair);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; webSocketMsgEntity;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从任务中生成消息
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; equipmentRepair
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; WebSocketMsgEntity generateRepairMsgFromTasks(EquipmentRepair equipmentRepair) {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务代码略&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、发送消息到MQ。这里只贴了发送的核心代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RabbitMessageQueue &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractMessageQueue {

    @Value(&lt;/span&gt;&quot;${rabbitmq.websocket.msg.queue}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String webSocketMsgQueue;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RabbitTemplate rabbitTemplate;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send(WebSocketMsgEntity entity) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有指定exchange，则使用默认名为“”的exchange，binding名与queue名相同&lt;/span&gt;
&lt;span&gt;        rabbitTemplate.convertAndSend(webSocketMsgQueue, entity);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;WebSocket&lt;/h3&gt;
&lt;p&gt;1、 系统B中引入websocket服务端dependency&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-websocket&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.3.10.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、 配置websocket，添加处理类&lt;/p&gt;
&lt;p&gt;WebSocketConfigurer.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableWebSocket
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebSocketConfig &lt;span&gt;extends&lt;/span&gt; WebMvcConfigurerAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebSocketConfigurer {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(WebSocketConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置webSocket路径&lt;/span&gt;
        registry.addHandler(messageWebSocketHandler(),&quot;/msg-websocket&quot;).addInterceptors(&lt;span&gt;new&lt;/span&gt; MyHandshakeInterceptor()).setAllowedOrigins(&quot;*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置webSocket路径 支持前端使用socketJs&lt;/span&gt;
        registry.addHandler(messageWebSocketHandler(), &quot;/sockjs/msg-websocket&quot;).setAllowedOrigins(&quot;*&quot;).addInterceptors(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyHandshakeInterceptor()).withSockJS();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MessageWebSocketHandler messageWebSocketHandler() {
        logger.info(&lt;/span&gt;&quot;......创建MessageWebSocketHandler......&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageWebSocketHandler();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MessageWebSocketHandler.java 主要用于websocket连接及消息发送处理。配置中还使用了连接握手时的处理，主要是取用户登陆信息，这里不多讲述。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MessageWebSocketHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TextWebSocketHandler {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(SystemWebSocketHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, CopyOnWriteArraySet&amp;lt;WebSocketSession&amp;gt;&amp;gt; users = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterConnectionEstablished(WebSocketSession session) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        String userId &lt;/span&gt;= session.getAttributes().get(&quot;WEBSOCKET_USERID&quot;&lt;span&gt;).toString();
        logger.info(&lt;/span&gt;&quot;......AfterConnectionEstablished......&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;session.getId:&quot; +&lt;span&gt; session.getId());
        logger.info(&lt;/span&gt;&quot;session.getLocalAddress:&quot; +&lt;span&gt; session.getLocalAddress().toString());
        logger.info(&lt;/span&gt;&quot;userId:&quot; +&lt;span&gt; userId);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;websocket连接后记录连接信息&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (users.keySet().contains(userId)) {
            CopyOnWriteArraySet&lt;/span&gt;&amp;lt;WebSocketSession&amp;gt; webSocketSessions =&lt;span&gt; users.get(userId);
            webSocketSessions.add(session);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            CopyOnWriteArraySet&lt;/span&gt;&amp;lt;WebSocketSession&amp;gt; webSocketSessions = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArraySet&amp;lt;&amp;gt;&lt;span&gt;();
            webSocketSessions.add(session);
            users.put(userId, webSocketSessions);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleTransportError(WebSocketSession session, Throwable throwable) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        removeUserSession(session);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (session.isOpen()) {
            session.close();
        }
        logger.info(&lt;/span&gt;&quot;异常出现handleTransportError&quot; +&lt;span&gt; throwable.getMessage());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        removeUserSession(session);
        logger.info(&lt;/span&gt;&quot;关闭afterConnectionClosed&quot; +&lt;span&gt; closeStatus.getReason());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supportsPartialMessages() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 给符合要求的在线用户发送消息
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; message
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendMessageToUsers(String message, List&amp;lt;String&amp;gt; userIds) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(message) ||&lt;span&gt; CollectionUtils.isEmpty(userIds)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (users.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String userId : userIds) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;users.keySet().contains(userId)) {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            CopyOnWriteArraySet&lt;/span&gt;&amp;lt;WebSocketSession&amp;gt; webSocketSessions =&lt;span&gt; users.get(userId);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (webSocketSessions == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (WebSocketSession webSocketSession : webSocketSessions) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (webSocketSession.isOpen()) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        webSocketSession.sendMessage(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextMessage(message));
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        logger.error(&lt;/span&gt;&quot; WebSocket server send message ERROR &quot; +&lt;span&gt; e.getMessage());
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e1) {
                            e1.printStackTrace();
                        }
                    }
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * websocket清除连接信息
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; session
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeUserSession(WebSocketSession session) {
        String userId &lt;/span&gt;= session.getAttributes().get(&quot;WEBSOCKET_USERID&quot;&lt;span&gt;).toString();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (users.keySet().contains(userId)) {
            CopyOnWriteArraySet&lt;/span&gt;&amp;lt;WebSocketSession&amp;gt; webSocketSessions =&lt;span&gt; users.get(userId);
            webSocketSessions.remove(session);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (webSocketSessions.isEmpty()) {
                users.remove(userId);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个功能完成后，A系统分配任务时，系统B登陆用户收到的消息如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181109142132647-669056870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总体流程：&lt;/p&gt;
&lt;p&gt;1、对于系统B，每个登陆的用户都会和服务器建立websocket长连接。&lt;/p&gt;
&lt;p&gt;2、系统A生成任务，AOP做出响应，将封装的消息发送给MQ。&lt;/p&gt;
&lt;p&gt;3、系统B中的MQ监听发现队列有消息到达，消费消息。&lt;/p&gt;
&lt;p&gt;4、系统B通过websocket长连接将消息发给指定的登陆用户。&lt;/p&gt;



&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jingmoxukong/p/7755643.html&quot;&gt;https://www.cnblogs.com/jingmoxukong/p/7755643.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html&quot;&gt;https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Holmofy/article/details/78111715&quot;&gt;https://blog.csdn.net/Holmofy/article/details/78111715&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 09 Nov 2018 06:24:00 +0000</pubDate>
<dc:creator>little-sheep</dc:creator>
<og:description>背景 最近公司的客户要求，分配给员工的任务除了有微信通知外，还希望PC端的网页也能实时收到通知。管理员分配任务是在我们的系统A,而员工接受任务是在系统B。两个系统都是现在已投入使用的系统。 技术选型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/little-sheep/p/9934887.html</dc:identifier>
</item>
<item>
<title>学了两天 react，乱讲一下学习思路，顺便弄了一个脚手架 - 风的姿态</title>
<link>http://www.cnblogs.com/fengzheng/p/9934600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengzheng/p/9934600.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;之前一直用 vue 做一些小项目，最近接触了一个项目是用 react 做前端，虽然本身是做后端开发的，但是前端还是要了解一点的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在的项目基本上都是前后端分离的，后端就先不提了。前端的框架也是层出不穷，使用最多的就是 angular、vue、react 。angular 是前几年用的比较多，最近好像用的人没那么多了。vue 是华人开发的项目，也是这三个框架里上手最简单的。react 是 fecebook 开源的框架，市场占有率也是最高的，国外的公司和国内的一些大公司用的比较多。&lt;/p&gt;
&lt;p&gt;我也不是专业前端，学习 react 也是一时兴起，讲不了什么高深的东西，就来说说入门 react 的一个过程，仅仅是入门而已。&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;&lt;strong&gt;前期准备&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;不光学习 react 需要储备一些前端的知识，学习 vue 等前端框架同样需要。&lt;/p&gt;
&lt;p&gt;稍微了解一下 nodejs ，前端框架的原理是这样的，并不是像我们之前那样直接写操作 DOM 的 js 脚本或者使用 jquery，而是用 ES5、ES6 、TypeScript 等标准去组织项目代码，这其中需要用到 nodejs 的很多包，最后编译的时候，把用这些标准组织的代码编译成我们通常意义上的 js 代码，然后在浏览器执行。&lt;/p&gt;
&lt;p&gt;会使用 npm ，这是一个包管理工具，对比 Java 来说，它就类似于 maven，可以方便的管理项目中使用的包。&lt;/p&gt;
&lt;p&gt;webpack 了解一点，&lt;em&gt;webpack&lt;/em&gt; 是一个现代 JavaScript 应用程序的静态模块打包器，我们项目开发和编译使用的命令 dev、start、build 最后都是由 webpack 帮我们完成的。&lt;/p&gt;
&lt;h2 id=&quot;学习过程&quot;&gt;&lt;strong&gt;学习过程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我这里只是说一下我学习的过程。打开 Google，先去找 react 官网，有英文的和中文的，因为英文的看着费劲，所以就看了中文官网 &lt;a href=&quot;https://react.docschina.org/&quot; class=&quot;uri&quot;&gt;https://react.docschina.org/&lt;/a&gt;。 花大概两个小时，把每个小结都看完，也就是做个大概了解，了解 react 到底是怎么一个机制，具体到写代码的时候肯定还是要返回来查的。学任何东西其实都是一样的，不能上来就拿一个 demo 开始改，肯定要先宏观的了解一下这项技术优缺点、运转机制，然后再钻到细节里。&lt;/p&gt;
&lt;p&gt;看完官方文档后，开始创建一个小项目写写简单的代码。 react 为了方便入门，提供了一个脚手架工具，create-&lt;em&gt;react&lt;/em&gt;-app，只需要运行简单的命令就能创建一个 react 项目出来。&lt;/p&gt;
&lt;p&gt;先用 npm 全局安装 create-react-app 包。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install -g create-react-app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行命令创建项目，运行之前先 cd 到你想创建项目的目录&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;create-react-app my-app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;create-react-app 已经出到了 2.x 的版本，它帮助我们省去了一些配置上的东西，它其实是把 webpack 做了比较好的封装，大大节省了我们配置 webpack 的时间，可以另我们专注的写程序代码。如果不适用它的话，你从头到尾的配置项目结构和webpack，中间会有很多坑在等着你，恐怕还没开始写代码就已经中途放弃了。&lt;/p&gt;
&lt;p&gt;然后运行 npm start 就可以把最简单的项目跑起来。&lt;/p&gt;
&lt;p&gt;跑起来之后，可以根据官方文档来写两个简单的页面，建立一下自信。&lt;/p&gt;
&lt;p&gt;如果你之前用过 vue，会发现 react 和 vue 差别是非常大的。vue 是非常直接 MVVM 模式，通俗点来说就是数据双向绑定，改变视图也就改变了 model ，改变 model 也就改变了视图。&lt;/p&gt;
&lt;p&gt;而 react 是在每个视图中维护一个 state ，每次只能操作当前视图的 state ，每次页面加载需要初始化 state ，state 绑定到视图上，但是视图的修改，需要通知 state 。这是最基本的运行模式。如果是做一个比较小的系统，交互不是很复杂的那种，可以用这些足够了。&lt;/p&gt;
&lt;p&gt;继续说看文档这件事，只看官方文档基本上可以写一些简单的页面了，但是还不够，我们通过搜索引擎继续搜索，各种各样的技术博客、文档进去看，会陆陆续续的发现更多的信息，比如 router 、redux、mobx 等等，继续根据新的关键词还能挖掘出更多的东西。以 react 为例，除了 react 核心的功能，还有一些扩展的框架，如果我们想把这些都了解，从早到晚看一天的文档恐怕也是不够的。&lt;/p&gt;
&lt;p&gt;router 路由器，如果页面很多，项目很大的情况下，就需要路由器来管理页面路径了，访问哪个路径要加载哪个页面，这些还是统一管理起来比较好。&lt;/p&gt;
&lt;p&gt;redux 和 mobx 是数据管理的扩展包 ，我们如果只用 state 来管理和维护数据，当有不同的页面需要有数据交互或共享的时候，就很吃力了，redux 或 mobx 就提供了数据统一管理的功能，把数据独立出来，这样就可以在不同的页面、不同的组件之间来回流转了。&lt;/p&gt;
&lt;p&gt;比起 mobx 来，redux 相对来说就麻烦的多，mobx 提供了装饰器的语法功能，就像 Java 中的注解、Python中的装饰器一样。&lt;/p&gt;
&lt;p&gt;写的非常乱，但这就像开始学习 react 一样，有些东西就是在你各种翻文档的过程中才发现的，比如 redux 和 mobx ，大多数时候，开始你并不知道有这些东西。&lt;/p&gt;
&lt;p&gt;学习的过程中，我用 react + router + mobx 搭了一个脚手架项目，有想要用的可以关注公众号，回复 「&lt;strong&gt;react&lt;/strong&gt;」 。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/626258-1da3596d0c993b63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;扫码关注&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 05:35:00 +0000</pubDate>
<dc:creator>风的姿态</dc:creator>
<og:description>之前一直用 vue 做一些小项目，最近接触了一个项目是用 react 做前端，虽然本身是做后端开发的，但是前端还是要了解一点的。 现在的项目基本上都是前后端分离的，后端就先不提了。前端的框架也是层出不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengzheng/p/9934600.html</dc:identifier>
</item>
</channel>
</rss>