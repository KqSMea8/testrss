<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Paper Folding UVA - 177 模拟+思路+找规律 - FanJiaming</title>
<link>http://www.cnblogs.com/fan-jiaming/p/9899115.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fan-jiaming/p/9899115.html</guid>
<description>&lt;p&gt;题目：&lt;a href=&quot;https://cn.vjudge.net/problem/UVA-177&quot; target=&quot;_blank&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路：1到4是很容易写出来的，我们先考虑这四种情况的绘制顺序&lt;/p&gt;
&lt;p&gt;　　1：ru&lt;/p&gt;
&lt;p&gt;　　2：rulu&lt;/p&gt;
&lt;p&gt;　　3：rululdlu&lt;/p&gt;
&lt;p&gt;　　4：rululdluldrdldlu&lt;/p&gt;
&lt;p&gt;　　不难发现，相较于前一行，每一次增加一倍数量，并且增加的这部分前一半和原来正好相反，后一半相同，根据这一性质，预处理出极端情况13的解答字符串，然后绘制即可，注意控制行尾空格&lt;/p&gt;
&lt;p&gt;AC代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;cstdio&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;cstring&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;vector&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;map&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;&lt;span&gt;set&lt;/span&gt;&amp;gt;
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;queue&amp;gt;
&lt;span&gt;10&lt;/span&gt; #include &amp;lt;deque&amp;gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; FRER() freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin)
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; FREW() freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INF 0x3f3f3f3f
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; ans[&lt;span&gt;10000&lt;/span&gt;], _map[&lt;span&gt;20000&lt;/span&gt;][&lt;span&gt;20000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _max[&lt;span&gt;20000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; cal(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(ch == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(ch == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(ch == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(ch == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FRER();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FREW();&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     ios::sync_with_stdio(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     cin.tie(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     
&lt;span&gt;40&lt;/span&gt;     ans[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     ans[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; &lt;span&gt;14&lt;/span&gt;; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (i - &lt;span&gt;2&lt;/span&gt;), m = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);        
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; n; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             ans[j + m] =&lt;span&gt; cal(ans[j]);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (i - &lt;span&gt;2&lt;/span&gt;); ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             ans[j + m + n] = ans[j +&lt;span&gt; n];
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     ans[&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;13&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(cin &amp;gt;&amp;gt;&lt;span&gt; n, n) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         memset(_map, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(_map));
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         memset(_max, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(_max));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; minl = &lt;span&gt;10000&lt;/span&gt;, maxl = &lt;span&gt;10000&lt;/span&gt;, minc = &lt;span&gt;10000&lt;/span&gt;, maxc = &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;10000&lt;/span&gt;, c = &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         _max[&lt;span&gt;10000&lt;/span&gt;] = &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         _map[l][c] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; m; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(ans[i - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 --&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ans[i - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 ++&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ans[i - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 --&lt;span&gt;l;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             
&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(ans[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                 
&lt;span&gt;72&lt;/span&gt;                 _map[l][c] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ans[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;                 ++&lt;span&gt;l;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;                 _map[l][c] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ans[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                 --&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                 _map[l][c] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                 ++&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;                 _map[l][c] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;             minl =&lt;span&gt; min(minl, l);
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;             minc =&lt;span&gt; min(minc, c);
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;             maxl =&lt;span&gt; max(maxl, l);
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;             _max[l] =&lt;span&gt; max(_max[l], c);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = minl; i &amp;lt;= maxl; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = minc; j &amp;lt;= _max[i]; ++&lt;span&gt;j) 
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;                 cout &amp;lt;&amp;lt; (_map[i][j] == &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt; : _map[i][j]);
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt;             cout &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;97&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;98&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;99&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 02 Nov 2018 15:37:00 +0000</pubDate>
<dc:creator>FanJiaming</dc:creator>
<og:description>题目：题目链接 思路：1到4是很容易写出来的，我们先考虑这四种情况的绘制顺序 1：ru 2：rulu 3：rululdlu 4：rululdluldrdldlu 不难发现，相较于前一行，每一次增加一倍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fan-jiaming/p/9899115.html</dc:identifier>
</item>
<item>
<title>SpringBoot实战(十三)之缓存 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/9899053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/9899053.html</guid>
<description>&lt;p&gt;缓存就是数据交换的缓冲区(又称作Cache)，当某一硬件要读取数据时，会首先从缓存中查找需要的数据，找到了则直接执行，找不到的话则从内存中查找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。&lt;/p&gt;
&lt;p&gt;因为缓存往往使用的是RAM(断电即掉的非永久性储存)，所以在用完后还是会把文件送到&lt;a href=&quot;https://baike.so.com/doc/4952181-5173681.html&quot; target=&quot;_blank&quot;&gt;硬盘&lt;/a&gt;等&lt;a href=&quot;https://baike.so.com/doc/4224899-4426539.html&quot; target=&quot;_blank&quot;&gt;存储器&lt;/a&gt;里永久存储。电脑里最大的缓存就是&lt;a href=&quot;https://baike.so.com/doc/5379821-5616070.html&quot; target=&quot;_blank&quot;&gt;内存条&lt;/a&gt;了，最快的是CPU上镶的L1和L2缓存，&lt;a href=&quot;https://baike.so.com/doc/2864149-3022502.html&quot; target=&quot;_blank&quot;&gt;显卡&lt;/a&gt;的显存是给显卡运算芯片用的缓存，&lt;a href=&quot;https://baike.so.com/doc/4952181-5173681.html&quot; target=&quot;_blank&quot;&gt;硬盘&lt;/a&gt;上也有16M或者32M的缓存。&lt;/p&gt;

&lt;p&gt;说到这你或许很疑问为什么要用缓存？&lt;/p&gt;
&lt;p&gt;比如面对千万级数据时，对于并发量和性能是非常具有挑战性的。这时如果不采用缓存的话，你每次都要直接去数据库查，那么数据库即便是分库分表，对于性能而言也是一笔不小的开支。说到这你也许还不明白为什么用缓存。直白的讲，将你每次需要到数据库中获取的大批量数据，缓存起来，每次需要查询对应的数据时，直接去缓存里面查。当然了，这里可能还会存在一个比较大的问题，对于部分项目而言，比如广告投放项目或者是一些电商项目，数据变动相对比较大，这样会导致一个问题，就是缓存数据的实时性。这里后续会讲。今天主要讲的是SpringBoot作缓存的简单Demo，主要面向一些初学者，同时笔者也作一格小小记录。框架越往后发展，就越轻量级。想当初，搭建SSM框架，一大堆XML先不说(只要很好的管理起来，看起来也不是那么讨厌),最让人头痛的就是每次引用一些非关系型数据库或者是一些类库都要导入对应的maven依赖，这是一件很头痛的事情，因为有些时候，一些依赖之间，它们会存在一定的冲突。不过还好用maven作为依赖管理，处理冲突问题还是很不错。想到我的一位朋友，他公司用的还是动态web项目。也就是手动导入jar包，有的时候还得build path一下，想到这，我觉得还是很幸运。说的或许有些偏题了，不过最想说还是，感谢老外开发出来这个SpringBoot,因为这样让我们的开发效率更加快了。&lt;/p&gt;
&lt;p&gt;不过，就国内而言，虽然也不乏有人研究SpringBoot源码，开发出对应的开发项目，比如JFinal或者是Jeecg，但是在应用方面的广度仍不及老外，离老外还是有一定的差距，不过让我高兴的是，这个差距不再是望尘莫及，而是望其项背。话不多说，源码贴起。&lt;/p&gt;

&lt;p&gt;一、导入Maven依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.yc.springboot.cache&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SprintBoot-Cache&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.6.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.1.30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二、执行SQL脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DROP TABLE IF EXISTS `article`;

CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) DEFAULT NULL,
  `author` varchar(50) DEFAULT NULL,
  `content` text,
  `file_name` varchar(255) DEFAULT NULL,
  `state` int(2) DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

/*Data for the table `article` */

insert  into `article`(`id`,`title`,`author`,`content`,`file_name`,`state`) values (1,'三国演义','罗贯中','test1324fdsafadsfadsfa','test001',1),(2,'水浒城','施耐庵','官逼民反','test002',1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三、编写对应的类(entity,dao,service及其controller和model、启动类)&lt;/p&gt;
&lt;p&gt;SpringbootCacheApplication.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.blog.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.EnableAutoConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableAutoConfiguration
@EnableCaching
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringbootCacheApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(SpringbootCacheApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Article.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.blog.entity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Article &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String content;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String author;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String fileName;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer state;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTitle() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTitle(String title) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getContent() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; content;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setContent(String content) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.content =&lt;span&gt; content;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getFileName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fileName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setFileName(String fileName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileName =&lt;span&gt; fileName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setState(Integer state) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; state;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAuthor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; author;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAuthor(String author) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.author =&lt;span&gt; author;
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ArticleMapper.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.blog.dao;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Param;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.blog.entity.Article;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ArticleMapper {


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入一篇文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; title
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; author
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fileName
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Integer addArticle(@Param(&quot;title&quot;) String  title,@Param(&quot;author&quot;&lt;span&gt;)String author,
                              @Param(&lt;/span&gt;&quot;content&quot;)String content,@Param(&quot;fileName&quot;&lt;span&gt;)String fileName);
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据id获取文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Article getArticleById(@Param(&quot;id&quot;&lt;span&gt;) Integer id);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新content
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Integer updateContentById(@Param(&quot;content&quot;)String content,@Param(&quot;id&quot;&lt;span&gt;)Integer id);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据id删除文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Integer removeArticleById(@Param(&quot;id&quot;&lt;span&gt;)Integer id);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得上一次插入的id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getLastInertId();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ArticleService.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.blog.service;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CacheConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CacheEvict;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CachePut;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.Cacheable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.blog.dao.ArticleMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.blog.entity.Article;


@Service
@CacheConfig(cacheNames &lt;/span&gt;= &quot;articleCache&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArticleService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; AtomicInteger count =&lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ArticleMapper articleMapper;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 增加一篇文章
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @CachePut()
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer addArticle(Article article){
        Integer result &lt;/span&gt;=&lt;span&gt; articleMapper.addArticle(article.getTitle(), article.getAuthor(), article.getContent(), article.getFileName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result&amp;gt;0&lt;span&gt;) {
            Integer lastInertId &lt;/span&gt;=&lt;span&gt; articleMapper.getLastInertId();
            System.out.println(&lt;/span&gt;&quot;--执行增加操作--id:&quot; +&lt;span&gt; lastInertId);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id 文章id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Cacheable(key &lt;/span&gt;= &quot;#id&quot;,unless = &quot;#result.state==0&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Article getArticle(Integer id) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟耗时操作&lt;/span&gt;
            Thread.sleep(5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Article artcile =&lt;span&gt; articleMapper.getArticleById(id);
        System.out.println(&lt;/span&gt;&quot;--执行数据库查询操作&quot;+count.incrementAndGet()+&quot;次&quot;+&quot;id:&quot;+&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; artcile;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过id更新内容
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @CacheEvict(key &lt;/span&gt;= &quot;#id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer updateContentById(String contetnt, Integer id) {
        Integer result &lt;/span&gt;=&lt;span&gt; articleMapper.updateContentById(contetnt, id);
        System.out.println(&lt;/span&gt;&quot;--执行更新操作id:--&quot;+&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过id移除文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @CacheEvict(key &lt;/span&gt;= &quot;#id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer removeArticleById(Integer id){
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Integer result =&lt;span&gt; articleMapper.removeArticleById(id);
        System.out.println(&lt;/span&gt;&quot;执行删除操作,id:&quot;+&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ArticleController.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.blog.controller;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.spring.annotation.MapperScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PostMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestBody;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestParam;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.blog.dao.ArticleMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.blog.entity.Article;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.blog.model.ResultVo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.blog.service.ArticleService;


@RestController
@ComponentScan(basePackages &lt;/span&gt;= {&quot;com.blog.controller&quot;, &quot;com.blog.service&quot;&lt;span&gt;})
@MapperScan(basePackages &lt;/span&gt;= {&quot;com.blog.dao&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArticleController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ArticleService articleService;

    @Autowired
    ArticleMapper articleMapper;

    @PostMapping(&lt;/span&gt;&quot;/add&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultVo addArticle(@RequestBody Article article) {

        System.out.println(article.toString());
        Integer result &lt;/span&gt;=&lt;span&gt; articleService.addArticle(article);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &amp;gt;= 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(result);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
    }


    @GetMapping(&lt;/span&gt;&quot;/get&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResultVo getArticle(@RequestParam(&quot;id&quot;&lt;span&gt;) Integer id) {

        Article article &lt;/span&gt;=&lt;span&gt; articleService.getArticle(id);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; article)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(article);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新一篇文章
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; contetnt
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/resh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResultVo update(@RequestParam(&quot;content&quot;) String contetnt, @RequestParam(&quot;id&quot;&lt;span&gt;) Integer id) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Integer result =&lt;span&gt; articleService.updateContentById(contetnt, id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(result);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除一篇文章
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/rem&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResultVo remove(@RequestParam(&quot;id&quot;&lt;span&gt;) Integer id) {

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Integer result =&lt;span&gt; articleService.removeArticleById(id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(result);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ResultVo.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.blog.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ResultVo&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T data;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer code;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String msg;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String errorMsg = &quot;操作失败&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String successMsg = &quot;操作成功&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultVo(T data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultVo(T data, Integer code) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultVo(T data, Integer code, String msg) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg =&lt;span&gt; msg;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultVo(Integer code, String msg) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg =&lt;span&gt; msg;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 成功
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt; 数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; ResultVo success(T data) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResultVo&amp;lt;T&amp;gt;(data, 1&lt;span&gt;, successMsg);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 失败
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; ResultVo fail() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResultVo(0&lt;span&gt;, errorMsg);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setData(T data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; code;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCode(Integer code) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMsg() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMsg(String msg) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg =&lt;span&gt; msg;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四、编写XML及其对应配置文件&lt;/p&gt;
&lt;p&gt;ArticleMapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.blog.dao.ArticleMapper&quot;&amp;gt;

    &amp;lt;resultMap type=&quot;com.blog.entity.Article&quot; id=&quot;articleMap&quot;&amp;gt;
        &amp;lt;result column=&quot;id&quot; property=&quot;id&quot;/&amp;gt;
        &amp;lt;result column=&quot;title&quot; property=&quot;title&quot;/&amp;gt;
        &amp;lt;result column=&quot;author&quot; property=&quot;author&quot;/&amp;gt;
        &amp;lt;result column=&quot;content&quot; property=&quot;content&quot;/&amp;gt;
        &amp;lt;result column=&quot;file_name&quot; property=&quot;fileName&quot;/&amp;gt;
        &amp;lt;result column=&quot;state&quot; property=&quot;state&quot;&amp;gt;&amp;lt;/result&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;insert id=&quot;addArticle&quot;&amp;gt;&lt;span&gt;
        INSERT INTO  article (title,author,content,file_name,state) values
        (#{title}, #{author}, #{content},#{fileName},&lt;/span&gt;'1'&lt;span&gt;)
    &lt;/span&gt;&amp;lt;/insert&amp;gt;


    &amp;lt;select id=&quot;getArticleById&quot; resultMap=&quot;articleMap&quot;&amp;gt;&lt;span&gt;
        select &lt;/span&gt;* from article where id =&lt;span&gt; #{id}
    &lt;/span&gt;&amp;lt;/select&amp;gt;


    &amp;lt;update id=&quot;updateContentById&quot;&amp;gt;&lt;span&gt;
        update article set content &lt;/span&gt;= #{content} where id =&lt;span&gt; #{id}
    &lt;/span&gt;&amp;lt;/update&amp;gt;

    &amp;lt;update id=&quot;removeArticleById&quot;&amp;gt;&lt;span&gt;
        update article set state &lt;/span&gt;= '0' where id =&lt;span&gt; #{id}
    &lt;/span&gt;&amp;lt;/update&amp;gt;

    &amp;lt;select id=&quot;getLastInertId&quot; resultType=&quot;java.lang.Integer&quot;&amp;gt;&lt;span&gt;
        select LAST_INSERT_ID()
    &lt;/span&gt;&amp;lt;/select&amp;gt;


&amp;lt;/mapper&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;application.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
spring.datasource.url=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/test&lt;/span&gt;
spring.datasource.username=&lt;span&gt;root
spring.datasource.password&lt;/span&gt;=1234&lt;span&gt;
spring.datasource.driver&lt;/span&gt;-&lt;span&gt;class&lt;/span&gt;-name=&lt;span&gt;com.mysql.jdbc.Driver
mybatis.mapperLocations&lt;/span&gt;=classpath*:mapper&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.xml &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201811/1255290-20181102231300807-1708620869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201811/1255290-20181102231451362-1709190592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Nov 2018 15:16:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>什么是缓存? 引用下百度百科的解释: 缓存就是数据交换的缓冲区(又称作Cache)，当某一硬件要读取数据时，会首先从缓存中查找需要的数据，找到了则直接执行，找不到的话则从内存中查找。由于缓存的运行速度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youcong/p/9899053.html</dc:identifier>
</item>
<item>
<title>Proxy模式(代理[延迟]模式) - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9899023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9899023.html</guid>
<description>&lt;h4 id=&quot;proxy&quot;&gt;Proxy？？&lt;/h4&gt;
&lt;p&gt;Proxy是“代理人”的意思，它指的是代替别人进行工作的人。代理实际上就是使用委托的机制，在代理的过程中你可以做点其他的事情，然后再来执行被代理对象的代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知识储备&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.什么时候使用：&lt;/p&gt;
&lt;p&gt;GoF书（请参见附录E[GoF]）在讲解Proxy模式时，使用了一个可以在文本中嵌入图形对象（例如图片等）的文本编辑器作为例子。为了生成这些图形对象，需要读取图片文件，这很耗费时间。因此如果在打开文档时就生成有所的图形对象，就会导致文档打开时间过长。所以，最好是当用户浏览至文本中各个图形对象时，再去生成它们的实例。这时，Proxy模式就有了用武之地。&lt;/p&gt;
&lt;p&gt;2.有那些代理：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;Virtual Proxy（虚拟代理）Virtual Proxy就是本章中学习的Proxy模式。只有当真正需要实例时，它才生成和初始化实例。&lt;/li&gt;
&lt;li&gt;Remote Proxy（远程代理）Remote Proxy可以让我们完全不必在意RealSubject角色是否在远程网络上，可以如同它在自己身边一样（透明性地）调用它的 方法。Java的RMI（RemoteMethodInvocation：远程方法调用）就相当于Remote Proxy。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Access Proxy Access Proxy 用于在调用RealSubject角色的功能时设置访问限制。例如，这种代理可以只允许指定的用户调用方法，而当其他用户调用方法时则报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;静态代理&lt;br/&gt;1.使用委托机制代理人只代理他能解决的问题。当遇到他不能解决的问题时，还是会“转交”给本人去解决。&lt;br/&gt;这里的“转交”就是在本书中多次提到过的“委托”。从PrinterProxy类的print方法中调用real.print方法正是这种“委托”的体现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;为了实现PrinterProxy类可以从printer类中分离出来作为独立的组件使用，而且只要是实现了Printable接口的类都可以扮演Proxy的角色。需要使用反射实例&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
private synchronized void realize(String classname) {
    if(real==null){
        try {
            real = ((Printable) Class.forName(classname).newInstance());
        }catch (ClassNotFoundException e){
            System.out.println(&quot;没有发现&quot;+classname);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。首先我们先来看看java的API帮助文档是怎么样对这两个类进行描述的：&lt;br/&gt;InvocationHandler:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InvocationHandler is the interface implemented by the invocation handler of a proxy instance. 

Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看&lt;br/&gt;InvocationHandler这个接口的唯一一个方法 invoke 方法：&lt;br/&gt;&lt;code&gt;Object invoke(Object proxy, Method method, Object[] args) throws Throwable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们看到这个方法一共接受三个参数，那么这三个参数分别代表什么呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Object invoke(Object proxy, Method method, Object[] args) throws Throwable

proxy:　　指代我们所代理的那个真实对象
method:　　指代的是我们所要调用真实对象的某个方法的Method对象
args:　　指代的是调用真实对象某个方法时接受的参数

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;理清职责&quot;&gt;理清职责&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;实现一个带名字的打印机&lt;br/&gt;名字=====》》说明&lt;br/&gt;Printer || 表示带名字的打印机的类（本人）&lt;br/&gt;Printable || Printer和PrinterProxy的共同接口&lt;br/&gt;PrinterProxy || 表示带名字的打印机的类（代理人）&lt;br/&gt;Main ||测试程序行为的类&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201811/1160484-20181102230317076-976163396.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201811/1160484-20181102230321697-312367728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201811/1160484-20181102230324950-769563390.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public interface Printable {

    // 设置打印名字
    void setPrinterName(String name);

    // 获取打印名字
    String getPrinterName();

    // 显示文字
    void print(String string);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;···&lt;br/&gt;public class Printer implements Printable{&lt;br/&gt;private String name;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Printer() {
    heavyjob(&quot;正在生成Printer实例&quot;);
}

public Printer(String name) {
    this.name = name;
    heavyjob(&quot;正在生成Printer实例（&quot;+name+&quot;）&quot;);
}

/**
 * 模拟一个高负载任务
 * @param string
 */
private void heavyjob(String string) {
    System.out.println(string);
    for (int i = 0; i &amp;lt; 5; i++) {
        try {
            Thread.sleep(1000);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        System.out.print(&quot;.&quot;);
    }
}

@Override
public void setPrinterName(String name) {
    this.name=name;
}

@Override
public String getPrinterName() {
    return name;
}

@Override
public void print(String string) {
    System.out.println(&quot;===&quot;+name+&quot;===&quot;);
    System.out.println(string);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;···&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PrinterProxy&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public class PrinterProxy implements Printable{

    private String name;

    private Printer real;

    /**
     * 不论 setPrinterName 方法和getPrinterName 方法被调用多少次，
     * 都不会生成Printer类的实例。只有当真正需要本人时，
     * 才会生成printer类的实例（printerProxy类的调用者完全不知道是否生成了本人，也不用在意是否生成了本人）。
     * @param name
     */


    public PrinterProxy(String name) {
        this.name = name;
    }

    @Override
    public synchronized void setPrinterName(String name) {
        if(real!=null){
            real.setPrinterName(name);
        }
        this.name=name;
    }

    @Override
    public String getPrinterName() {
        return name;
    }

    @Override
    public void print(String string) {
            realize();
            real.print(string);
    }

    private synchronized void realize() {
        if(real==null) real=new Printer(name);
    }
}

public class MainT {
    public static void main(String[] args) {

        Printable p=new PrinterProxy(&quot;Tom&quot;);
        System.out.println(&quot;现在是&quot;+p.getPrinterName());
        p.setPrinterName(&quot;Cat&quot;);
        System.out.println(&quot;现在是&quot;+p.getPrinterName());
        p.print(&quot;我是 Tomcat&quot;);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
现在是Tom
现在是Cat
正在生成Printer实例（Cat）
.....
===Cat===
我是 Tomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;动态代理code&quot;&gt;动态代理Code&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
public class Client {

    public static void main(String[] args) {

        Printable tom = new Printer(&quot;Tom&quot;);

        DynamicProxy proxy = new DynamicProxy(tom);

        Printable o = (Printable) Proxy.newProxyInstance(proxy.getClass().getClassLoader(),
                tom.getClass().getInterfaces(), proxy);

        System.out.println(o.getClass().getName());

        System.out.println(&quot;现在是&quot;+o.getPrinterName());
        o.print(&quot;Tomcat&quot;);
    }
}




public class DynamicProxy implements InvocationHandler {

    private Object object;

    public DynamicProxy(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println(&quot;准备执行&quot;);

        System.out.println(&quot;Method:&quot; + method);

        Object o = method.invoke(object, args);

        System.out.println(&quot;执行完毕&quot;);
        return o;
    }
}




public interface Printable {

    // 设置打印名字
    void setPrinterName(String name);

    // 获取打印名字
    String getPrinterName();

    // 显示文字
    void print(String string);
}



public class Printer implements Printable{
    private String name;

    public Printer() {
        heavyjob(&quot;正在生成Printer实例&quot;);
    }

    public Printer(String name) {
        this.name = name;
        heavyjob(&quot;正在生成Printer实例（&quot;+name+&quot;）&quot;);
    }

    /**
     * 模拟一个高负载任务
     * @param string
     */
    private void heavyjob(String string) {
        System.out.println(string);
        for (int i = 0; i &amp;lt; 5; i++) {
            try {
                Thread.sleep(1000);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.print(&quot;.&quot;);
        }
    }

    @Override
    public void setPrinterName(String name) {
        this.name=name;
    }

    @Override
    public String getPrinterName() {
        return name;
    }

    @Override
    public void print(String string) {
        System.out.println(&quot;===&quot;+name+&quot;===&quot;);
        System.out.println(string);
    }
}

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 02 Nov 2018 15:04:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Proxy？？ Proxy是“代理人”的意思，它指的是代替别人进行工作的人。代理实际上就是使用委托的机制，在代理的过程中你可以做点其他的事情，然后再来执行被代理对象的代码。 知识储备 1.什么时候使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9899023.html</dc:identifier>
</item>
<item>
<title>T-SQL基础（一）之简单查询 - 雪飞鸿</title>
<link>http://www.cnblogs.com/Cwj-XFH/p/9898835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cwj-XFH/p/9898835.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;名词解释&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;SQL: Structured Query Language，结构化查询语言，是一种在关系型数据库中用于管理数据的标准语言。SQL是一种声明式编程语言，即只需表明需要什么而无需关注实现细节（C#中的LINQ也是如此）。&lt;/p&gt;
&lt;p&gt;SQL方言：在SQL基础上延伸的其它语言，如SQL Server中所使用的T-SQL。&lt;/p&gt;
&lt;p&gt;T-SQL:Transact-SQL，微软公司提供的用于SQL Server数据库的SQL方言（扩展）。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;SQL表达式运算&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;谓词&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中谓词是指运算结果为True,False或Unknown的逻辑表达式。T-SQL中的谓词有IN，BETWEEN，LIKE等。&lt;/p&gt;
&lt;p&gt;使用LIKE可以做模糊匹配，支持正则表达式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 查找以x开头的name&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; name &lt;span&gt;FROM&lt;/span&gt; Xfh.dbo.UserInfo &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 查找以两个x开头的name，_表示匹配单个字符&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; name &lt;span&gt;FROM&lt;/span&gt; Xfh.dbo.UserInfo &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_x%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，LIKE模糊匹配若以%开头，则无法使用所用。如：&lt;code&gt;LIKE '%x'&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中的运算符与高级编程语言（C#,JAVA）类似。当多个运算符出现在同一表达式中时，SQL Server会按照运算符的优先级进行计算。当搞不清楚优先级就使用括号，对比下面两句SQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; orderid &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Sales.dbo.Orderes 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;span&gt; 
    custid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; empid &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;OR&lt;/span&gt;&lt;span&gt;
    custid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; empid &lt;span&gt;IN&lt;/span&gt;  (&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; orderid &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Sales.dbo.Orderes 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;span&gt; 
    (custid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; empid &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)) 
    &lt;/span&gt;&lt;span&gt;OR&lt;/span&gt;&lt;span&gt; 
    (custid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; empid &lt;span&gt;IN&lt;/span&gt;  (&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;AND运算符的优先级高于OR，所以上述两句SQL在逻辑上等价。但，很明显第二句的WHERE条件逻辑上更清晰。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;三值逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中表达式的运算结果有三种情况：&lt;code&gt;True,False 与 Unknown&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在查询筛选中，只返回条件表达式（WHERE、HAVING、ON）运算结果为True的数据。&lt;/p&gt;
&lt;p&gt;CHECK约束，返回表达式运算结果不为False的结果。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;两值逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;与T-SQL中的大多数谓词不同，EXISTS使用两值逻辑（True/False），而不是三值逻辑；&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;EXISTS( SELECT * FROM T_A WHERE Id=12)&lt;/code&gt;中，EXISTS谓语只关心匹配行是否存在，而不管SELECT中指定的属性，就像整个SELECT子句是多余的一样。SQL Server引擎在优化查询时会忽略SELECT子句。所以，SELECT子句中的星号（*）对于性能没有任何负面影响。&lt;/p&gt;
&lt;p&gt;为节省微不足道的与星号（*）解析相关的额外成本，而牺牲代码可读性是不值得的。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;NULL &amp;amp; Unknown&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;NULL表示值是Unknown状态，SQL中不同的语言元素对于NULL有着不同的处理方式。&lt;/p&gt;
&lt;p&gt;在使用NULL值时应注意以下几点：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将NULL与其它值进行比较，不管该值是否为NULL，结果均为Unknown&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;应使用IS NULL或IS NOT NULL来判断值是否为NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;INSERT未给列指定值则插入NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;GROUP BY和ORDER BY子句会将多个NULL值视为相等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;标准SQL的UNIQUE约束将NULL是为彼此不同&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;T-SQL中的UNIQUE约束认为多个NULL是相等的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;COUNT(*)的特殊性&lt;/p&gt;
&lt;p&gt;若列名为tag的例中存在&lt;code&gt;a,NULL,c,d&lt;/code&gt;几行数据，那么COUNT(*)返回4而COUNT(tag)则返回3&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NULL参与的逻辑运算结果很可能是Unknown（三值逻辑也是引发应用错误的重要原因），除非运算结果不依赖于Unknown，示例如下。&lt;/p&gt;
&lt;p&gt;Unknown参与AND运算结果：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Expression 1&lt;/th&gt;
&lt;th&gt;Expression 2&lt;/th&gt;
&lt;th&gt;Result&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;TRUE&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FALSE&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Unknown参与OR预算结果：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Expression 1&lt;/th&gt;
&lt;th&gt;Expression 2&lt;/th&gt;
&lt;th&gt;Result&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;TRUE&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FALSE&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;查询&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;SQL中的查询是指，SELECT语句经过一些列逻辑处理而获取数据的过程。&lt;/p&gt;
&lt;p&gt;几条建议：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SQL中的关键字均使用大写字母&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SQL语句均使用分号结尾&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SQL中使用对象的完全限定名，如：DbName.dbo.TableName&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;查询语句执行顺序&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SELECT语句的执行顺序与书写顺序是有差异的。按照SELECT语法规定书写的SQL语句较为符合英语语法习惯（对人类友好），但SELECT语句的实际执行则按照如下顺序进行（对机器友好）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FROM&lt;/li&gt;
&lt;li&gt;JOIN ON&lt;/li&gt;
&lt;li&gt;WHERE&lt;/li&gt;
&lt;li&gt;GROUP BY&lt;/li&gt;
&lt;li&gt;HAVING&lt;/li&gt;
&lt;li&gt;SELECT&lt;/li&gt;
&lt;li&gt;表达式&lt;/li&gt;
&lt;li&gt;DISTINCT&lt;/li&gt;
&lt;li&gt;ORDER BY&lt;/li&gt;
&lt;li&gt;TOP/OFFSET FETCH&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OFFSET FETCH可以看作是ORDER BY子句的一部分&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;⚠️ SQL基于集合理论，查询结果集（表结果）是无顺寻的（虽然看起来结果集像按照某种顺序排列），除非显式的使用ORDER BY子句指定顺寻，但使用ORDER BY字句后结果集将被作为游标对待，而非表结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FROM子句用于指定需要查询的数据源，WHERE语句对数据源中的数据做基于行的筛选。通常WHERE子句可以决定查询是否使用索引，及使用哪些索引，对于查询优化有着重要意义。&lt;/p&gt;
&lt;p&gt;GROUP BY子句用于对查询结果集进行分组，GROUP BY之后的所有操作都是对组而非行的操作。在查询结果中，每组最终由一个单行来表示。这意味着，GROUP BY之后的所有子句中指定的表达式必须对每组返回一个标量（单个值）。&lt;/p&gt;
&lt;p&gt;HAVING用于对GROUP BY产生的组进行筛选。&lt;/p&gt;
&lt;p&gt;SELECT语句用于指定返回到查询结果集中的列，生成查询结果表。注意，在SELECT子句之前执行的子句无法使用SELECT子句中的列的别名，否则会返回&lt;code&gt;Invalid column name&lt;/code&gt;错误。&lt;/p&gt;
&lt;p&gt;TOP不是标准SQL，是T-SQL专有功能，用于限制查询返回的指定行数或百分比：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 返回Table中的10条数据&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 返回Table中10%的数据&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;PERCENT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;OFFSET-FETCH有着与TOP类似的功能，但它是标准SQL，可用于分页查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 取第51至60行的10条数据&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; Id &lt;span&gt;DESC&lt;/span&gt;&lt;span&gt;
OFFSET &lt;/span&gt;&lt;span&gt;50&lt;/span&gt; ROWS &lt;span&gt;FETCH&lt;/span&gt; &lt;span&gt;NEXT&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; ROWS &lt;span&gt;ONLY&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意SQL SERVER中，OFFSET-FETCH要与ORDER BY结合使用，否则会报错：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Invalid usage of the option NEXT in the FETCH statement.&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;同时操作&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中有all-at-once operations（同时操作）的概念，即出现在同一逻辑处理阶段的所有表达式在同一时间进行逻辑计算。&lt;/p&gt;
&lt;p&gt;因为同时操作的原因，下面示例中orderyear+1中的oderyear是无效的，SQL会报错：&lt;span&gt;&lt;code&gt;Invalid column name 'orderyear'&lt;/code&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; orderid,&lt;span&gt;YEAR&lt;/span&gt;(orderdate) &lt;span&gt;AS&lt;/span&gt; orderyear,orderyear&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; nextyear &lt;span&gt;FROM&lt;/span&gt; Sales.dbo.Orders;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同样，由于同时操作的原因，SQL Server不支持短路操作。如，WHERE子句中的多个表达式的计算并没有确定的顺序。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;CASE...WHEN...&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;CASE表达式是标量表达式，返回一个符合条件的值。注意，CASE是表达式，不是语句，与COUNT类似。&lt;/p&gt;
&lt;p&gt;CASE表达式有两种使用方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CASE后面带有列名&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; 
Name,
&lt;/span&gt;&lt;span&gt;CASE&lt;/span&gt;&lt;span&gt; Age
    &lt;/span&gt;&lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;双庆&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;50&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;知天命&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;未成年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt; WJChi.dbo.UserInfo;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;CASE后面不带列名&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; 
Name,
&lt;/span&gt;&lt;span&gt;CASE&lt;/span&gt; 
    &lt;span&gt;WHEN&lt;/span&gt; Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;雪飞鸿&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;WHEN&lt;/span&gt; Age&lt;span&gt;=&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;双庆&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;WHEN&lt;/span&gt; Age&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;你猜&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt; Xfh.dbo.UserInfo;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CASE表达式中若为指定ELSE的返回值，则默认为&lt;code&gt;ELSE NULL&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;查询分类&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;查询可分为：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单表查询&lt;/p&gt;
&lt;p&gt;查询中最简单的一种形式。高并发，分布式系统中常用。通常单表查询仅需一句SELECT语句即可，简单且数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;联接查询&lt;/p&gt;
&lt;p&gt;INNER JOIN、LEFT JOIN、RIGHT JOIN、CROSS JOIN&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;子查询&lt;/p&gt;
&lt;p&gt;SQL可以在一个查询语句中编写另外一个查询语句，即嵌套查询。最外面的查询结果集返回给调用者，称为外部查询。内部查询的结果集被用于外部查询，称为子查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;表表达式&lt;/p&gt;
&lt;p&gt;派生表、公用表表达式、视图等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;聚合函数&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;聚合函数对多行数据进行运算后返回标量（聚合），只有SELECT、HAVING、ORDER BY语句中可以使用聚合函数；&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;开窗函数&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;开窗函数是对基本查询中的每一行按组（窗口）进行运算，并得到一个标量。行的窗口使用OVER子句定义。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;锁与事务隔离级别&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL Server默认情况下，查询语句会申请共享锁。共享锁可以阻止对数据进行修改，详细信息可参阅：&lt;a href=&quot;https://www.cnblogs.com/Cwj-XFH/p/9313882.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;SQL Server中锁与事务隔离级别&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;相较于增删改而言，查询是比较复杂的，也是数据库优化的关注重点。本文主要介绍了T-SQL查询的基础知识，对于较为复杂的查询，如：关联、表表达式、集合运算等将在后续文章中介绍。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;书籍推荐&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;《SQL SERVER 2012 T-SQL 基础教程》&lt;br/&gt;《SQL SERVER 性能优化与管理的艺术》&lt;br/&gt;《SQL SERVER基础教程》&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/t-sql/language-elements/null-and-unknown-transact-sql?view=sql-server-2017&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;NULL and UNKNOWN (Transact-SQL)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/9233e5f12388&quot; target=&quot;_blank&quot;&gt;SQL Server中锁与事务隔离级别&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1170837&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;数据库两大神器【索引和锁】&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Nov 2018 14:27:00 +0000</pubDate>
<dc:creator>雪飞鸿</dc:creator>
<og:description>名词解释 SQL: Structured Query Language，结构化查询语言，是一种在关系型数据库中用于管理数据的标准语言。SQL是一种声明式编程语言，即只需表明需要什么而无需关注</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cwj-XFH/p/9898835.html</dc:identifier>
</item>
<item>
<title>js.es5 map循环一大坑：循环遍历竟然出现逗号！ - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9898762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9898762.html</guid>
<description>&lt;p&gt;
&lt;h4&gt;一、map&lt;/h4&gt;
&lt;/p&gt;
&lt;div class=&quot;marginTop twoLevelTitle&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201811/1414709-20181102214615744-419777684.png&quot;/&gt;&lt;h4&gt;map大法好&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt;作为当今程序界最好用的循环方法之一&lt;code&gt;map&lt;/code&gt;, 在我的项目里基本替代了&lt;code&gt;for&lt;/code&gt;循环&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;map循环常用的一些方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/********* ES6 **********/
//一行代码可以省略return
array.map( item =&amp;gt; console.log(item))   
=&amp;gt;
array.map( item =&amp;gt; {
    return console.log(item)
})

//多行代码需要{}
array.map( item =&amp;gt; {
    //do someting  花括号一般是处理某些逻辑
})

//返回组件
array.mao( item =&amp;gt; (
    &amp;lt;div&amp;gt;{item}&amp;lt;/div&amp;gt;   //这种比较常出现在react的jsx
))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面总结了一些我经常用的&lt;code&gt;map&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;下面我就要小小批评一下&lt;code&gt;map&lt;/code&gt;的坑爹之处...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当用map循环遍历元素的时候, 会出现多余的逗号&lt;code&gt;,&lt;/code&gt;！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然对于单页面应用开发基本遇不上. 但还是做一个记录.防止日后落坑&lt;/p&gt;
&lt;p&gt;
&lt;h4&gt;二、测试案例&lt;/h4&gt;
&lt;/p&gt;
&lt;p&gt;为了生动形象说明一下问题, 我分别循环遍历四张图片和四个文字, 且看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//js
&amp;lt;script&amp;gt;
    //歌曲url.聪明的你会发现这个路径有点奇怪...
    let imgArr = ['./yaba.jpg', './siwujidan.jpg', './motiandalou.jpg', './nashini.jpg', ]     
    
    //歌曲名字
    let titleArr = ['哑巴', '肆无忌惮', '摩天大楼', '那是你离开了北京的生活']

    let imghtml = ''    //输出img
    let titlehtml = ''  //输出title
    
    imghtml += arrobj.map(function(item){
        return '&amp;lt;img src=&quot;' + item + '&quot; style=&quot;width: 350px&quot;/&amp;gt;'
    })

    titlehtml += name.map(function(item){
        return '&amp;lt;div&amp;gt;' + item + '&amp;lt;/div&amp;gt;'
    })
    document.getElementById('output').innerHTML = imghtml
    document.getElementById('output').innerHTML += titlehtml
&amp;lt;/script&amp;gt;

//html
&amp;lt;div id=&quot;output&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看一下输出的效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201811/1414709-20181102215817569-1341127222.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嘿嘿嘿, 果然出来了。什么？你说图片没出现， 你再仔细看看...&lt;/p&gt;
&lt;p&gt;对于react里面直接&lt;code&gt;return&lt;/code&gt;这个dom也是一样会出现这种情况的.&lt;/p&gt;
&lt;p&gt;
&lt;h4&gt;三、KO Bug&lt;/h4&gt;
&lt;/p&gt;
&lt;p&gt;我们可以思考一下为什么会出现这个烦人的&lt;code&gt;,&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;原来:&lt;/p&gt;
&lt;p&gt;利用&lt;code&gt;map&lt;/code&gt;插入到DOM时 调用了&lt;code&gt;toString&lt;/code&gt;方法. 而我们再看看数组结构&lt;code&gt;[1, 2, 3]&lt;/code&gt; 好家伙， 里面居然是这个逗号&lt;code&gt;,&lt;/code&gt; 转换的时候把它带上了！&lt;/p&gt;
&lt;p&gt;我们知道了原因之后就非常方便解决了。我们可以巧妙地利用&lt;code&gt;join&lt;/code&gt;方法：&lt;code&gt;join()&lt;/code&gt;可以切开一个数组, &lt;strong&gt;指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嘻嘻。明白了！我只要改成这样！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;imghtml += arrobj.map(function(item){
    return '&amp;lt;img src=&quot;' + item + '&quot; style=&quot;width: 200px&quot;/&amp;gt;'
}).join('')

titlehtml += name.map(function(item){
    return '&amp;lt;div&amp;gt;' + item + '&amp;lt;/div&amp;gt;'
}).join('')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大功告成！但是要注意记得不要附带参数哦！不然可恶的&lt;code&gt;,&lt;/code&gt;就会变成你传入的参数啦！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;imghtml += arrobj.map(function(item){
    return '&amp;lt;img src=&quot;' + item + '&quot; style=&quot;width: 200px&quot;/&amp;gt;'
}).join('***')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201811/1414709-20181102220946638-1469942953.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Nov 2018 14:11:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、map map大法好 作为当今程序界最好用的循环方法之一 , 在我的项目里基本替代了 循环 map循环常用的一些方法 上面总结了一些我经常用的 方法 下面我就要小小批评一下 的坑爹之处... 当用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9898762.html</dc:identifier>
</item>
<item>
<title>三叔学FPGA系列之二：Cyclone V中的POR、配置、初始化，以及复位 - 最浪三叔</title>
<link>http://www.cnblogs.com/zuilangsanshu/p/9898755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuilangsanshu/p/9898755.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;对于FPGA内部的复位，之前一直比较迷，这两天仔细研究官方数据手册，解开了心中的诸多疑惑，感觉自己又进步了呢.....&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; 一、关于POR（Power-On Reset ）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;FPGA在上电工作时，会先进入复位模式，将所有RAM位清除，并通过内部弱上拉电阻将用户I/O置为三态。接着依次完成 配置、初始化工作，如果这一切都顺利，就进入用户模式，FPGA会根据用户所编写的时序逻辑开始工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;二、FPGA上电工作过程详解&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从第一条我们知道，FPGA从上电到进入用户模式，会有一个过程。就不放时序图恶心人了，直接上干货，如图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515465/201811/1515465-20181102204426454-684473059.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;601&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程详解&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上电触发一个复位事件，拉低nCONFIG、nSTATUS、CONF_DONE、INIT_DONE引脚，清除RAM位，三态用户I/O，进入复位；&lt;/li&gt;
&lt;li&gt;复位过程中，控制逻辑检测所有供电电压，当他们在规定时间达到规定值，并稳定下来，则进入配置，否则就需要用户通过重新拉低nCONFIG足够时间等待电压达标，优秀的电源设计对数字电路是很重要的；&lt;/li&gt;
&lt;li&gt;复位顺利完成，则依次释放nCONFIG、nSTATUS，让它们被上拉电阻拉高，进入配置，配置模式必须和MSEL[4:0]的设置必须匹配，编写的逻辑电路由quartus生成配置文件，在这个时候烧写到FPGA中，这过程叫做配置，常用的配置方式有JTAG在线模式，和EPCS/EPCQ配置模式；&lt;/li&gt;
&lt;li&gt;配置成功，则释放CONF_DONE，进入初始化，初始化是按照用户意图将各寄存器置位成预期值；&lt;/li&gt;
&lt;li&gt;初始化完成，则释放INIT_DONE，进入用户模式，系统按照既定时序开始运转。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;*****注意*****&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;电源不稳，后面一切免谈，电源质量好，后面一切应该也顺利；&lt;/li&gt;
&lt;li&gt;设计硬件电路时，nCONFIG、nSTATUS、CONF_DONE必须上拉，因为初始化完成就万事大吉了，所以INIT_DONE不用管，配置完成后当做普通I/O用；&lt;/li&gt;
&lt;li&gt;MSEL[4:0]设置；&lt;/li&gt;
&lt;li&gt;设计硬件电路时，要注意配置FLASH和FPGA连接，以及JTAG端口的设计，硬件错了就白瞎；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;三、关于FPGA的复位&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如前所述，我们已经知道，每次上电工作，FPGA必定进行复位、初始化等操作。所以理论上，后续工作工程中，FPGA是不需要复位的，尤其是全局复位。但是，一方面为了保险起见应该进行局部复位和寄存器初始化（在时序过程中的任意时刻赋值），保证寄存器中的值是我们期望的值，而且某些IP核在工作前也必须复位；另一方面，电路中难免出现亚稳态等，使系统工作异常，这就需要形成一种机制，触发一个复位事件，使系统进入 “复位—&amp;gt;配置—&amp;gt;初始化—&amp;gt;用户模式” 这一过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以有：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在 “三叔学FPGA系列之一：Cyclone V中的时钟资源” 一文中一提到，全局时钟布线资源通常非常有限，而全局复位用的也是全局时钟的布线资源，所以能不用全局复位尽量别用，用局部复位就行了，也就是不要在所有always中都用同一个rst_n，可以通过内部逻辑生成多个局部复位信号rstn0，rstn1，rstn2.....&lt;/li&gt;
&lt;li&gt;在硬件电路设计时，Cyclone V以前的FPGA都有RESET引脚，&lt;span&gt;但设计手册中别没有说这个引脚一定要用作复位&lt;/span&gt;，可以当做普通I/O用，在Cyclone V中RESET引脚被取消了。我的理解是：RESET引脚的作用有两点，一是为了在系统运行过程中出现异常时，可以手动按钮之类的触发一个复位事件，使系统复位；二是采用电容延时的方式，强制增加上电复位时间，确保复位成功。当上诉两方面都没有太大必要的情况下，RESET引脚就没什么用了，所以Intel牛B，在Cyclone V中直接去掉RESET引脚（&lt;span&gt;个人猜想，未到技术区求证&lt;/span&gt;）；&lt;/li&gt;
&lt;li&gt;再次说明，RESET≠全局复位，实现全局复位有一万种方法，比如通过内部逻辑，或者通过matlab控制串口等等；&lt;/li&gt;
&lt;li&gt;关于是否使用全局复位，网上众说纷纭，Intel也没有官方说法。我的理解是，看个人的系统情况。比如：全局时钟本来就紧张，那么就pass全局复位，用局部复位，反之资源充足，用全局复位。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;四、验证后再来更新&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;关于第三节的内容，很多都是我个人的猜想，但是也是参考了官方手册，以及个人项目开发中的经验，准确率十之八九，后续验证后再来更新。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Fri, 02 Nov 2018 14:09:00 +0000</pubDate>
<dc:creator>最浪三叔</dc:creator>
<og:description>对于FPGA内部的复位，之前一直比较迷，这两天仔细研究官方数据手册，解开了心中的诸多疑惑，感觉自己又进步了呢..... 一、关于POR（Power-On Reset ） FPGA在上电工作时，会先进入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuilangsanshu/p/9898755.html</dc:identifier>
</item>
<item>
<title>Hadoop大数据部署 - 流浪使者</title>
<link>http://www.cnblogs.com/dianel/p/9898693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dianel/p/9898693.html</guid>
<description>&lt;h2 id=&quot;一.-系统环境配置&quot;&gt;一. 系统环境配置：&lt;/h2&gt;
&lt;h3 id=&quot;关闭防火墙selinux&quot;&gt;1. 关闭防火墙，selinux&lt;/h3&gt;
&lt;p&gt;关闭防火墙：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;systemctl stop firewalld
systemctl disable firewalld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置selinux为disable&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cat /etc/selinux/config 
SELINUX=disabled&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置ntp时间服务器&quot;&gt;2. 配置ntp时间服务器&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# yum -y install ntpdate
# crontab -l
*/5 * * * * /usr/sbin/ntpdate 192.168.1.1 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将IP地址换成可用的时间服务器IP&lt;/p&gt;
&lt;h3 id=&quot;修改系统限制&quot;&gt;3. 修改系统限制&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# cat /etc/security/limits.conf
* soft nproc  100000
* hard nproc  100000
* soft nofile 102400
* hard nofile 102400
hadoop soft nproc  100000
hadoop hard nproc  100000
hadoop soft nofile 102400
hadoop hard nofile 102400&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建hadoop用户&quot;&gt;4. 创建hadoop用户&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;groupadd -g 1002 hadoop
useradd -u 1002 -g hadoop hadoop&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置hosts&quot;&gt;5. 配置hosts&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@hadoop2 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.24.43 hadoop1
192.168.24.216 hadoop2
192.168.24.7 hadoop3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分发公钥&quot;&gt;6. 分发公钥&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# su - hadoop
$ ssh-keygen
$ ssh-copy-id hadoop@hadoop1
$ ssh-copy-id hadoop@hadoop2
$ ssh-copy-id hadoop@hadoop3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保证某一个节点上都有所有的节点的公钥。&lt;/p&gt;
&lt;h3 id=&quot;安装jdk&quot;&gt;7. 安装jdk&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# yum -y install jdk-8u171-linux-x64.rpm
# java -version
java version &quot;1.8.0_171&quot;
Java(TM) SE Runtime Environment (build 1.8.0_171-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装scala&quot;&gt;8. 安装SCALA&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Scala 是一门多范式（multi-paradigm）的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。Scala 运行在Java虚拟机上，并兼容现有的Java程序。Scala 源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /app
tar -zxvf /home/Software/scala-2.11.12.tgz  -C .
 mv scala-2.11.12 scala&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装snappy&quot;&gt;9. 安装snappy&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Snappy是一个压缩/解压缩库。它的目标不是最大压缩，也不与任何其他压缩库兼容; 相反，它的目标是非常高的速度和合理的压缩。例如，与最快的zlib模式相比，对于大多数输入，Snappy的速度要快一个数量级，但生成的压缩文件大小要高20％到100％。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum -y install automake autoconf libtool openssl openssl-devel gcc gcc-c++
tar -zxvf  snappy-1.1.3.tar.gz
cd snappy-1.1.3
./autogen.sh
./configure
make &amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装lzo以及lzop&quot;&gt;10. 安装lzo以及lzop&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;LZO 是一个用 ANSI C 语言编写的无损压缩库。他能够提供非常快速的压缩和解压功能。解压并不需要内存的支持。即使使用非常大的压缩比例进行缓慢压缩出的数据，依然能够非常快速的解压。LZO遵循GNU 的GPL 使用许可。&lt;br/&gt;LZO 非常适合进行数据的实时压缩解压处理，这就是说他更关心操作速度，而不是压缩比例。&lt;br/&gt;LZO 使用 ANSI C 语言编写，并且压缩后的数据也被设计为可以跨平台使用的格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tar -xvf lzo-2.06.tar.gz
cd lzo-2.06
./configure --enable-shared
make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;lzop是使用lzo库写的一个程序，通过shell命令直接可以压缩、解压缩文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tar -xvf lzop-1.03.tar.gz
cd lzop-1.03
./configure
make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二.-zookeeper-集群&quot;&gt;二. Zookeeper 集群&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Zookeeper有三种安装模式，单机模式：单节点安装standalones模式；伪集群模式：在一台主机上启动多个zookeeper的实例；集群模式：需要奇数台服务器，至少3台，每台启动一个zookeeper实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解压安装zookeepr&quot;&gt;1. 解压安装Zookeepr&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;su - hadoop
mkdir /app
tar -zxvf zookeeper-3.4.10.tar.gz -C /app/
cd /app
sudo mv zookeeper-3.4.10 zookeeper
mkdir data logs&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改zoo.cfg文件&quot;&gt;2. 修改zoo.cfg文件&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[hadoop@hadoop1 ~]$ vim /app/zookeeper/conf/zoo.cfg 
tickTime=2000
initLimit=20
syncLimit=10
dataDir=/app/zookeeper/data
dataLogDir=/app/zookeeper/logs
clientPort=2181
server.1=hadoop1:2888:3888
server.2=hadoop2:2888:3888
server.3=hadoop3:2888:3888&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;initLimit：初始化链接时，follower和leader之间的最长心跳时间，20*2000即40秒&lt;br/&gt;syncLimit：leader和follower之间发送消息, 请求和应答的最大时间长度，即20秒&lt;br/&gt;server.X=A:B:C 其中X是一个数字, 表示这是第几号server. A是该server所在的IP地址. B:配置该server和集群中的leader交换消息所使用的端口. C:配置选举leader时所使用的端口&lt;/p&gt;
&lt;h3 id=&quot;修改myid&quot;&gt;3. 修改myid&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;/app/zookeeper/data/&lt;/code&gt;下增加一个myid文件，把前面配置文件里server.X中的X写入里面。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[hadoop@hadoop1 ~]$ cat /app/zookeeper/data/myid 
1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改zookeeper的日志输出路径&quot;&gt;4. 修改zookeeper的日志输出路径：&lt;/h3&gt;
&lt;p&gt;修改&lt;code&gt;/app/zookeeper/bin/zkEnv.sh&lt;/code&gt;下的&lt;code&gt;ZOO_LOG_DIR&lt;/code&gt;改为配置文件里写的路径&lt;code&gt;/app/zookeeper/logs&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;if [ &quot;x${ZOO_LOG_DIR}&quot; = &quot;x&quot; ]
then
    ZOO_LOG_DIR=&quot;/app/zookeeper/logs&quot;
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动并调试zookeeper&quot;&gt;5. 启动并调试zookeeper&lt;/h3&gt;
&lt;p&gt;启动：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ zkServer.sh start&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看状态：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ zkServer.sh status&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[hadoop@hadoop1 ~]$ zkServer.sh status
ZooKeeper JMX enabled by default
Using config: /app/zookeeper/bin/../conf/zoo.cfg
Mode: follower&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二.-hadoop-ha安装&quot;&gt;二. Hadoop HA安装&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;hadoop分为1.0和2.0两个大版本，具体的区别自行查找。本文主要使用的是hadoop2.0。hadoop2.0的生态系统主要包括以下核心项目：HDFS YARN MapReduce。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解压安装&quot;&gt;1. 解压安装&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo tar -zxvf hadoop-2.9.1.tar.gz -C /app/
$ pwd
/app/hadoop/etc/hadoop
$ ls
capacity-scheduler.xml      httpfs-env.sh            mapred-env.sh
configuration.xsl           httpfs-log4j.properties  mapred-queues.xml.template
container-executor.cfg      httpfs-signature.secret  mapred-site.xml
core-site.xml               httpfs-site.xml          mapred-site.xml.template
hadoop-env.cmd              kms-acls.xml             slaves
hadoop-env.sh               kms-env.sh               ssl-client.xml.example
hadoop-metrics2.properties  kms-log4j.properties     ssl-server.xml.example
hadoop-metrics.properties   kms-site.xml             yarn-env.cmd
hadoop-policy.xml           log4j.properties         yarn-env.sh
hdfs-site.xml               mapred-env.cmd           yarn-site.xml&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改hadoop的环境变量hadoop-env.sh&quot;&gt;2. 修改hadoop的环境变量（hadoop-env.sh）&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;export HADOOP_HEAPSIZE=16196
export JAVA_HOME=/usr/java/1.8.0_171
export JAVA_LIBRARY_PATH=/app/hadoop-2.9.1/lib/native
export HADOOP_OPTS=&quot;-Djava.library.path=/app/hadoop-2.9.0/lib/native&quot;
注意：如果在Centos 6环境中变量名后面的路径必须使用双引号，否则后面启动的时候报错找不到该变量。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改core-site.xml&quot;&gt;3. 修改core-site.xml&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hdfs://myhadoop&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
   &amp;lt;name&amp;gt;ha.zookeeper.quorum&amp;lt;/name&amp;gt;
   &amp;lt;value&amp;gt;hadoop1:2181,hadoop2:2181,hadoop3:2181&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
   &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;
   &amp;lt;value&amp;gt;/app/hadoop/tmp&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;io.file.buffer.size&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;131072&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;io.compression.codecs&amp;lt;/name&amp;gt;                             &amp;lt;value&amp;gt;org.apache.hadoop.io.compress.GzipCodec,org.apache.hadoop.io.compress.DefaultCodec,com.hadoop.compression.lzo.LzoCodec,com.hadoop.compression.lzo.LzopCodec,org.apache.hadoop.io.compress.BZip2Codec&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;io.compression.codec.lzo.class&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;com.hadoop.compression.lzo.LzoCodec&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;hadoop.proxyuser.hadoop.hosts&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;*&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;hadoop.proxyuser.hadoop.groups&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;*&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改hdfs-site.xml&quot;&gt;3. 修改hdfs-site.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;myhadoop&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.ha.namenodes.myhadoop&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;nn1,nn2&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.namenode.rpc-address.myhadoop.nn1&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop1:8020&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.namenode.rpc-address.myhadoop.nn2&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop2:8020&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.namenode.http-address.myhadoop.nn1&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop1:50070&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn2&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop2:50070&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.journalnode.edits.dir&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;/app/hadoop/qjournal&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.namenode.shared.edits.dir&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;qjournal://hadoop1:8485;hadoop2:8485;hadoop3:8485/myhadoop&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.client.failover.proxy.provider.myhadoop&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
   &amp;lt;name&amp;gt;dfs.ha.fencing.methods&amp;lt;/name&amp;gt;
   &amp;lt;value&amp;gt;sshfence&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
   &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.private-key-files&amp;lt;/name&amp;gt;
   &amp;lt;value&amp;gt;/home/hadoop/.ssh/id_rsa&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
 &amp;lt;property&amp;gt;
   &amp;lt;name&amp;gt;dfs.ha.automatic-failover.enabled&amp;lt;/name&amp;gt;
   &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
 &amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;file:/app/hadoop/dfs/name,file:/hadoop/dfs/name&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;file:/app/hadoop/dfs/data&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.datanode.handler.count&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.namenode.handler.count&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;1024&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.datanode.max.xcievers&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;8096&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改yarn-site.xml&quot;&gt;3. 修改yarn-site.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.ha.enabled&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.cluster-id&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;cluster1&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.ha.rm-ids&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;rm1,rm2&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.hostname.rm1&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop1&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.hostname.rm2&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop2&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.address.rm1&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop1:8088&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.address.rm2&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop2:8088&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;yarn.resourcemanager.zk-address&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;hadoop1:2181,hadoop2:2181,hadoop3:2181&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改mapred-site.xml&quot;&gt;5. 修改mapred-site.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.jobhistory.address&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;hadoop1:10020&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.jobhistory.webapp.address&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;hadoop1:19888&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.job.tracker&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;hdfs://hadoop1:8021&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.reduce.shuffle.parallelcopies&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;50&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.map.java.opts&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;-Xmx4096M&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.reduce.java.opts&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;-Xmx8192M&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.map.memory.mb&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;4096&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.reduce.memory.mb&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;8192&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.map.output.compress&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapred.child.env&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;JAVA_LIBRARY_PATH=/app/hadoop-2.9.1/lib/native&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.map.output.compress.codec&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;com.hadoop.compression.lzo.LzoCodec&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.task.io.sort.mb&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;512&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.task.io.sort.factor&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapred.reduce.tasks&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;4&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapred.map.tasks&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;20&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt; 
    &amp;lt;name&amp;gt;mapred.child.java.opts&amp;lt;/name&amp;gt; 
    &amp;lt;value&amp;gt;-Xmx4096m&amp;lt;/value&amp;gt; 
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
     &amp;lt;name&amp;gt;mapreduce.reduce.shuffle.memory.limit.percent&amp;lt;/name&amp;gt;
     &amp;lt;value&amp;gt;0.1&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
     &amp;lt;name&amp;gt;mapred.job.shuffle.input.buffer.percent&amp;lt;/name&amp;gt;
     &amp;lt;value&amp;gt;0.6&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改yarn-env.sh环境添加环境变量&quot;&gt;6. 修改yarn-env.sh环境，添加环境变量&lt;/h3&gt;
&lt;p&gt;在yarn-env.sh文件后面设置yarn heap大小。追加下面这句&lt;br/&gt;YARN_HEAPSIZE=4000&lt;/p&gt;
&lt;p&gt;添加环境变量：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ tail .bash_profile
export JAVA_HOME=/usr/java/jdk1.8.0_171-amd64
export HADOOP_HOME=/app/hadoop
export ZOOKPEER_HOME=/app/zookeeper
export LIBRAY_PATH=$HADOOP_HOME/lib/native
export SCALA_HOME=/app/scala
export PATH=$JAVA_HOME/bin:$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$ZOOKPEER_HOME/bin:$SCALA_HOME/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集群的启动与监控&quot;&gt;7 集群的启动与监控&lt;/h3&gt;
&lt;p&gt;安装psmisc，否则不能实现自动切换：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install psmisc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动集群：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 1. 在所有zookeeper节点上执行
zkServer.sh start
# 1.1 在leader上执行，用zookeeper进行初始化，这将会创建一个znode在zookeeper上内部实现自动备援系统。
hdfs zkfc -formatZK
# 1.2 If you are setting up a fresh HDFS cluster, you should first run the format command，on one of NameNodes.
hdfs namenode -format
# 2. 自动启动hdfs服务
start-dfs.sh
# 2.1 注意：如何你想要手动的管理你的集群服务，你必须通过zkfc deamon来启动你的namenode，命令如下：
hadoop-daemon.sh --script hdfs start zkfc
# 3. 在hadoop启动Resourcemanager
start-yarn.sh
# 4. 在另一个节点上启动standby resourcemanager
yarn-daemon.sh start resourcemanager


# 其他命令：
# 启停namenode
hadoop-daemon.sh start/stop namenode
# 启停datanode
hadoop-daemon.sh start/stop namenode&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看状态：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 查看各个节点
$ jps
2049 NameNode
2611 DFSZKFailoverController
3465 ResourceManager
1727 QuorumPeerMain
2159 DataNode
2415 JournalNode
3199 NodeManager
3695 Jps
# 查看HDFS集群namedate节点的状态
hdfs haadmin -getAllServiceState
# 查看nn1/nn2的状态
hdfs haadmin -getServiceState nn1
hdfs haadmin -getServiceState nn2
# 查看resourcemanager集群的主备状态
$ yarn rmadmin -getAllServiceState 
hadoop1:8033                                       active    
hadoop2:8033                                       standby   
# 查看resourcemanager的集群各个节点的状态
$ yarn rmadmin -getServiceState rm1
active
$ yarn rmadmin -getServiceState rm2
standby&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hadoop集群监控相关的端口：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;NameNode: http://namenode_host:50070
ResourceManager: http://resourcemanager_host:8088
MapReduce JobHistory Server: http://jobistoryserver_host:19888&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 02 Nov 2018 13:56:00 +0000</pubDate>
<dc:creator>流浪使者</dc:creator>
<og:description>Hadoop大数据部署 一. 系统环境配置： 1. 关闭防火墙，selinux 关闭防火墙： 设置selinux为disable 2. 配置ntp时间服务器 将IP地址换成可用的时间服务器IP 3.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dianel/p/9898693.html</dc:identifier>
</item>
<item>
<title>iOS 性能优化套路 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/9898683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/9898683.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;***&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; 一级套路&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;***&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt; 使用ARC管理内存&lt;/strong&gt;&lt;br/&gt;- 防止内存泄露&lt;br/&gt;- 保证释放掉不再需要的内存，提高性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在正确的地方使用 reuseIdentifier&lt;/strong&gt;&lt;br/&gt;平时接触的需要考虑重用的视图有UICollectionView,UITableView。需要考虑它们内部的cell,header,footer。&lt;br/&gt;CollectionView和TableView原理相似，内部存在着两个容器对象，分别是：&lt;br/&gt;- 当前展示视图容器，里面是当前展示的cell,footer,header&lt;br/&gt;- 可重用视图容器，里面是带有重用标识符的cell,footer,header&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量把View设置为完全不透明&lt;/strong&gt;&lt;br/&gt;需要将View属性opaque设置成YES&lt;br/&gt;当opaque设置成NO时，app在进行图片展示时，会让图片处理器（GPU）进行图像混合计算（blending操作）。&lt;br/&gt;图片处理器会将透明View的像素与它相临的像素点相加，重新计算出一个新的像素值。如果app带有动画，滚动效果，性能会受到明显的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免过于庞大的XIB&lt;/strong&gt;&lt;br/&gt;XIB是推出比较早的绘图工具，后面在iOS5的时候推出了StoryBoard来取代XIB的地位。不过到目前它们两个是共存的状态，原因是它们的适用场景不同。&lt;br/&gt;- XIB使用子View控件的定制，偏小型。但是在使用时会将整个XiB都加载到内存，如果XIB过大的话，会导致内存浪费。&lt;br/&gt;- StoryBoard是偏重宏观的，一般做控制器跳转，可以定义整个控制器视图。在使用时，StoryBoard是用到哪个控制器加载哪个，不会将所有的都加载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;严格要求对主线程的使用&lt;/strong&gt;&lt;br/&gt;主线程是用户对app的直接体验，所有的交互都是靠主线程接受和反馈的。终于程度可见一斑。所以需要把++耗时的操作都移动到子线程++去，等有了结果再切换回主线程来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免在Image Views中调整图片大小&lt;/strong&gt;&lt;br/&gt;如果给予==UIImageView==的image的尺寸不合适，那么==UIImageView==就需要对image进行自动缩放，这个缩放操作是比较耗费资源的。对于从网络加载后需要滚动的，动画的==UIImageView==影响更大。所以image和==UIImageView==的尺寸尽量匹配。匹配方式：&lt;/p&gt;
&lt;p&gt;- 要求切图尺寸符合要求&lt;br/&gt;- 将获得的图片在本地缩放规定的尺寸后，再返回给==UIImageView==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据业务场景选择合适的集合（不同的数据结构）&lt;/strong&gt;&lt;br/&gt;- 数组（增删慢；改查快）：有序集合，存储在一段连续的内存空间，可方便利用下标查看，增加删除都会让后序元素整体移动&lt;br/&gt;- Set(增删改查快) ：无序集合，添加重复的对象会自动覆盖掉前面的，做到整个集合只有一份&lt;br/&gt;- 字典（增删改查快）：健值集合，可根据key对应操作value&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合理使用gzip&lt;/strong&gt;&lt;br/&gt;在网络请求时，若数据比较大，可考虑采用压缩格式，提高用户体验&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;***&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt; 二级套路&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;***&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重用view和懒加载view&lt;/strong&gt;&lt;br/&gt;- 对于重复出现的子View，考虑模仿tableview的重用机制&lt;br/&gt;- 对于不一定使用的子view，考虑使用懒加载机制（懒加载是牺牲体验提高性能）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重视缓存&lt;/strong&gt;&lt;br/&gt;缓存的种类很多，主要按情况来进行缓存，如下所示：&lt;br/&gt;- 创建麻烦而经常使用（比如NSDateFormatter和NSCalendar），对于这样的对象缓存，可以放在单例或者类属性上。对频繁时提供性能有大的改变。&lt;br/&gt;- 请求麻烦而资源不经常改变（网络请求），&lt;br/&gt;- 频繁计算而结果不变的（tableview的行高）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图片渲染方式选择&lt;/strong&gt;&lt;br/&gt;- 使用UI给的切图，渲染快，效率高。但是bundle体积大。&lt;br/&gt;- 使用CoreGraphics,UIBezir曲线进行代码绘制，消耗性能。但是减少bundle体积&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存警告处理&lt;/strong&gt;&lt;br/&gt;系统提供了不少处理内存警告的方式，在受到内存经过时释放一些可以重建的对象，可以提供app的稳定性，它们适用多种场景：&lt;br/&gt;AppDelegate中的&lt;br/&gt;`applicationDidReceiveMemoryWarning: `&lt;br/&gt;UIViewController类中的&lt;br/&gt;`didReceiveMemoryWarning`&lt;br/&gt;系统提供的通知&lt;br/&gt;`UIApplicationDidReceiveMemoryWarningNotification`&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免在内存中频繁转换数据结构&lt;/strong&gt;&lt;br/&gt;尽量使后台返回的数据结构与app场景使用的一致，并选择合适的容器保存。&lt;br/&gt;Array,Dictory,Set，根据数据使用的特性，进行合理选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;View背景设置的方案选择&lt;/strong&gt;&lt;br/&gt;- 小图平铺&lt;br/&gt;```&lt;br/&gt;self.view.backgroundColor = [UIColorcolorWithPatternImage:[UIImageimageNamed:@&quot;background&quot;]];&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;- 全图背景&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;```&lt;br/&gt;BuilderUIImageView*backgroundView = [[UIImageViewalloc] initWithImage:[UIImageimageNamed:@&quot;background&quot;]];[self.view addSubview:backgroundView];&lt;br/&gt;```&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择适当的方式为shadowPath赋值&lt;/strong&gt;&lt;br/&gt;在开发中经常需要给View、Layer设置隐形，常见的设置方式有两种&lt;/p&gt;
&lt;p&gt;- 通过属性设置&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;// Setup the shadow ...&lt;br/&gt;UIView*view = [[UIViewalloc] init];&lt;br/&gt;view.layer.shadowOffset=CGSizeMake(-1.0f,1.0f);&lt;br/&gt;view.layer.shadowRadius =5.0f;&lt;br/&gt;view.layer.shadowOpacity =0.6;&lt;br/&gt;```&lt;br/&gt;这种方式需要Core Animation在后台提前根据图像frame计算出图像和阴影。增加了计算操作，消耗性能。&lt;/p&gt;
&lt;p&gt;- 通过贝塞尔曲线赋值&lt;br/&gt;```&lt;br/&gt;view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath];&lt;br/&gt;```&lt;br/&gt;由于路径是指定好的，无需再次计算，提高了性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TableView优化方案&lt;/strong&gt;&lt;br/&gt;1.reuseIdentifier规范使用，cell,header,footer。&lt;br/&gt;2.view的opaque为YES，避免色素计算&lt;br/&gt;3.避免cell中图片缩放&lt;br/&gt;4.耗时任务子线程处理，避免阻塞主线程（网络请求，数据处理）&lt;br/&gt;5.减少subviews的层级&lt;br/&gt;6.用贝塞尔曲线设置阴影路径&lt;br/&gt;7.尽量避免代理赋值（tableview直接设置rowHeight, sectionFooterHeight 和 sectionHeaderHeight）&lt;br/&gt;8.cell动态行高时，预先计算并存储，提高性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据持久化方案&lt;/strong&gt;&lt;br/&gt;1.NSUerDefaults：相当于电脑中的偏好设置&lt;br/&gt;2.plist：存储简单列表（城市对应的邮编列表）&lt;br/&gt;3.归档：需要实现NSCoding协议&lt;br/&gt;4.SQLite、Realm：大数据的存储方案&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;***&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;三级套路&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;***&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高App启动时间&lt;/strong&gt;&lt;br/&gt;1.异步处理耗时任务（网络加载，数据库访问，批量预处理）&lt;br/&gt;2.避免大规模内存加载（大体积xib加载）&lt;br/&gt;3.主要看门狗问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合理使用Autorelease Pool&lt;/strong&gt;&lt;br/&gt;对象过了作用域，引用计数会自动减一。如果在作用域中突然大量建对象，则内存会直线下降。这中情况下要适量加Autorelease Pool，进行及时释放&lt;br/&gt;&lt;strong&gt;合理使用图片的加载方式&lt;/strong&gt;&lt;br/&gt;1.小体积而重复使用的图片，用imageNamed，此时图片对象会保存在内存中&lt;br/&gt;2.大体积而不长用的图片，用imageWithContentsOfFile，图片每次都是从本地加载。不缓存&lt;/p&gt;

</description>
<pubDate>Fri, 02 Nov 2018 13:54:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>*** 一级套路 *** 使用ARC管理内存- 防止内存泄露- 保证释放掉不再需要的内存，提高性能 在正确的地方使用 reuseIdentifier平时接触的需要考虑重用的视图有UIColl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/9898683.html</dc:identifier>
</item>
<item>
<title>Java入门系列-23-NIO(使用缓冲区和通道对文件操作) - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/9898687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/9898687.html</guid>
<description>&lt;h2 id=&quot;nio-是什么&quot;&gt;NIO 是什么&lt;/h2&gt;
&lt;p&gt;java.nio全称java non-blocking（非阻塞） IO（实际上是 new io），是指jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。&lt;/p&gt;
&lt;h2 id=&quot;nio与io的区别&quot;&gt;NIO与IO的区别&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;面向流(Stream Oriented)&lt;/td&gt;
&lt;td&gt;面向缓冲区(Buffer Oriented)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;阻塞IO(Blocking IO)&lt;/td&gt;
&lt;td&gt;非阻塞(Non Blocking IO)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;选择器(Selectors)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;NIO系统的核心是：通道(Channel)和缓冲区(Buffer)&lt;/p&gt;
&lt;h2 id=&quot;缓冲区buffer&quot;&gt;缓冲区(Buffer)&lt;/h2&gt;
&lt;p&gt;位于 java.nio 包，所有缓冲区都是 Buffer 抽象类的子类，使用数组对数据进行缓冲。&lt;/p&gt;
&lt;p&gt;除了 boolean 类型，Buffer 对每种基本数据类型都有针对的实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建缓冲区通过 xxxBuffer.allocate(int capacity)方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ByteBuffer buf1 = ByteBuffer.allocate(512);
LongBuffer buf2 = LongBuffer.allocate(1024);
……&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;缓冲区的属性&quot;&gt;缓冲区的属性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;容量(capacity)&lt;/strong&gt;：表示缓冲区存储数据的最大容量，不能为负数，创建后不可修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限制&lt;/strong&gt;：第一个不可以读取或写入的数据的索引，即&lt;strong&gt;位于 limit 后的数据不能读写&lt;/strong&gt;。不能为负数，不能大于容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;位置(position)&lt;/strong&gt;：下一个要读取或写入的数据的索引，位置不能为负数，不能大于 limit&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记(mark)&lt;/strong&gt;：标记是一个索引，通过 Buffer 中的 mark() 方法指 Buffer 中一个特定的 position，之后可以通过 reset() 方法回到这个 postion。&lt;/p&gt;
&lt;h4 id=&quot;buffer-的常用方法&quot;&gt;Buffer 的常用方法&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Buffer clear()&lt;/td&gt;
&lt;td&gt;清空缓冲区并返回对缓冲区的引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Buffer flip()&lt;/td&gt;
&lt;td&gt;将缓冲区的 limit 设置为当前位置，并将当前位置重置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int capacity()&lt;/td&gt;
&lt;td&gt;返回 Buffer 的容量大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;boolean hasRemaining()&lt;/td&gt;
&lt;td&gt;判断缓冲区是否还有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int limit()&lt;/td&gt;
&lt;td&gt;返回 限制的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Buffer limit(int n)&lt;/td&gt;
&lt;td&gt;将设置缓冲区界限为 n，并返回一个具有新 limit 的缓冲区对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Buffer mark()&lt;/td&gt;
&lt;td&gt;对缓冲区设置标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int position()&lt;/td&gt;
&lt;td&gt;返回缓冲区的当前位置 position&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Buffer position(int n)&lt;/td&gt;
&lt;td&gt;将设置缓冲区的当前位置为 n，并返回修改后的 Buffer 对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int remaining()&lt;/td&gt;
&lt;td&gt;返回 position 和 limit 之间的元素个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Buffer reset()&lt;/td&gt;
&lt;td&gt;将位置 position 转到以前设置的 mark 所在的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Buffer rewind()&lt;/td&gt;
&lt;td&gt;将位置设置为 0，取消设置的 mark&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Buffer 所有子类提供了两个操作的数据的方法：get() 方法和 put() 方法&lt;/p&gt;
&lt;p&gt;缓冲区存取数据操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package testnio;

import java.nio.ByteBuffer;

public class TestBuffer1 {

    public static void main(String[] args) {
        testuse();
    }

    public static void testuse() {
        //1.分配一个指定大小的缓冲区
        ByteBuffer buf=ByteBuffer.allocate(1024);

        System.out.println(&quot;---------------allocate()----------------&quot;);
        System.out.println(buf.position());
        System.out.println(buf.limit());
        System.out.println(buf.capacity());

        //2.利用 put() 存入数据到缓冲区中
        String str=&quot;hello&quot;;
        //将字符串转为 byte 数组存入缓冲区
        buf.put(str.getBytes());
        System.out.println(&quot;---------------put()----------------&quot;);
        System.out.println(buf.position());
        System.out.println(buf.limit());
        System.out.println(buf.capacity());

        //3.切换读取数据模式
        buf.flip();
        System.out.println(&quot;---------------flip()----------------&quot;);
        System.out.println(buf.position());
        System.out.println(buf.limit());
        System.out.println(buf.capacity());

        //4.利用get() 读取缓冲区中的数据
        byte[] data=new byte[buf.limit()];
        System.out.println(&quot;---------------get()----------------&quot;);
        buf.get(data);
        System.out.println(new String(data,0,data.length));
        System.out.println(buf.position());
        System.out.println(buf.limit());
        System.out.println(buf.capacity());

        //5.rewind() 重复读
        buf.rewind();
        System.out.println(&quot;---------------rewind()----------------&quot;);
        System.out.println(buf.position());
        System.out.println(buf.limit());
        System.out.println(buf.capacity());

        //6.clear() 清空缓冲区，但缓冲区中的数据依然存在
        buf.clear();
        System.out.println(&quot;---------------clear()----------------&quot;);
        System.out.println(buf.position());
        System.out.println(buf.limit());
        System.out.println(buf.capacity());
        System.out.println((char)buf.get());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 mark()方法标记&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package testnio;

import java.nio.ByteBuffer;

public class TestBuffer2 {

    public static void main(String[] args) {
        testmark();
    }

    public static void testmark() {
        String str=&quot;jikedaquan.com&quot;;
        //创建缓冲区
        ByteBuffer buf=ByteBuffer.allocate(1024);
        //存入数据
        buf.put(str.getBytes());
        //切换模式
        buf.flip();
        //临时数组用于接收缓冲区获取的数据，长度与缓冲区 limit 一值
        byte[] data=new byte[buf.limit()];
        //获取缓冲区的数据从0开始获取4个，存入 data 数组中
        buf.get(data, 0, 4);
        //将数组转为字符串打印
        System.out.println(new String(data,0,4));
        //打印 position
        System.out.println(buf.position());

        //标记
        buf.mark();
        System.out.println(&quot;---------------再次获取----------------&quot;);
        //从索引4开始，获取6个字节(余下数据)
        buf.get(data, 4, 6);
        System.out.println(new String(data,4,6));
        System.out.println(buf.position());

        //恢复到标记位置
        buf.reset();
        System.out.println(&quot;---------------reset()----------------&quot;);
        System.out.println(buf.position());

        //判断缓冲区是是有还有剩余数据
        if (buf.hasRemaining()) {
            //获取缓冲区中可以操作的数量
            System.out.println(&quot;可操作数量：&quot;+buf.remaining());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mark &amp;lt;= position &amp;lt;= limit &amp;lt;= capacity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然使用了缓冲区提高了一定的IO速度，但这样的效率仍然不是最高的。非直接缓冲区在与物理磁盘操作中需要经过内核地址空间copy操作，直接缓冲区不经过copy操作，直接操作物理内存映射文件，&lt;br/&gt;使用直接缓冲区将大大提高效率。&lt;/p&gt;
&lt;p&gt;直接缓冲区进行分配和取消分配所需成本工厂高于非直接缓冲区，一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;直接缓冲区可以通过调用此类的 allocateDirect()工厂方法创建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建直接缓冲区&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package testnio;

import java.nio.ByteBuffer;

public class TestBuffer3 {

    public static void main(String[] args) {
        testAllocateDirect();
    }

    public static void testAllocateDirect() {
        //创建直接缓冲区
        ByteBuffer buf=ByteBuffer.allocateDirect(1024);
        
        //是否是直接缓冲区
        System.out.println(buf.isDirect());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通道channel&quot;&gt;通道(Channel)&lt;/h2&gt;
&lt;p&gt;缓冲区仅是运载数据的容器，需要对数据读写还需要有一条通道，这两者是密不可分的。&lt;/p&gt;
&lt;p&gt;Channel 接口的主要实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileChannel：用于读取、写入、映射和操作文件的通道&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;DatagramChannel：通过 UDP 读写网络中的数据通道&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;ScoketChannel：通过 TCP 读写网络中的数据&lt;/li&gt;
&lt;li&gt;ServerScoketChannel：可以监听新进来的 TCP 链接，对每一个新进来的连接都会创建一个 SocketChannel&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何获取通道&quot;&gt;如何获取通道？&lt;/h3&gt;
&lt;h4 id=&quot;通过支持通道的对象调用-getchannel-方法&quot;&gt;1、通过支持通道的对象调用 getChannel() 方法&lt;/h4&gt;
&lt;p&gt;支持通道的类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileInputStream&lt;/li&gt;
&lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;li&gt;RandomAccessFile&lt;/li&gt;
&lt;li&gt;DatagramScoket&lt;/li&gt;
&lt;li&gt;Socket&lt;/li&gt;
&lt;li&gt;ServerScoket&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用通道和缓冲区实现文件读和写&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package testnio;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class TestChannel {

    public static void main(String[] args) {
        FileInputStream fis=null;
        FileOutputStream fos=null;
        
        FileChannel inChannel=null;
        FileChannel outChannel=null;
        
        try {
            //创建输入流
            fis=new FileInputStream(&quot;F:/1.jpg&quot;);
            //创建输出流
            fos=new FileOutputStream(&quot;F:/2.jpg&quot;);
            //获取通道
            inChannel=fis.getChannel();
            outChannel=fos.getChannel();
            
            //分配指定大小的缓冲区
            ByteBuffer buf=ByteBuffer.allocate(1024);
            
            //将通道中的数据存入缓存区
            while(inChannel.read(buf)!=-1) {
                //切换读取数据的模式
                buf.flip();
                //将读入的缓冲区存入写数据的管道
                outChannel.write(buf);
                //清空缓存区(清空才能再次读入)
                buf.clear();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (fis!=null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (fos!=null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(inChannel!=null) {
                try {
                    inChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (outChannel!=null) {
                try {
                    outChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过通道类的静态方法-open&quot;&gt;2、通过通道类的静态方法 open()&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package testnio;

import java.io.IOException;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class TestOpenAndMapped {

    public static void main(String[] args) {
        FileChannel inChannel=null;
        FileChannel outChannel=null;
        try {
            //通过open创建通道
            inChannel = FileChannel.open(Paths.get(&quot;F:/a.jpg&quot;), StandardOpenOption.READ);
            outChannel = FileChannel.open(Paths.get(&quot;F:/b.jpg&quot;),StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE);

            //内存映射文件   直接缓冲区
            MappedByteBuffer inMappedBuf=inChannel.map(MapMode.READ_ONLY, 0, inChannel.size());
            MappedByteBuffer outMappedBuf=outChannel.map(MapMode.READ_WRITE, 0, inChannel.size());

            //直接对缓冲区进行数据的读写操作
            byte[] data=new byte[inMappedBuf.limit()];
            inMappedBuf.get(data);//读
            outMappedBuf.put(data);//写
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (inChannel!=null) {
                try {
                    inChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (outChannel!=null) {
                try {
                    outChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDK 1.7 新增的方法 open()，参数 path 通常代表一个依赖系统的文件路径，通过Paths.get()获取。&lt;/p&gt;
&lt;p&gt;参数 StandardOpenOption 是一个枚举类型，常用值如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;READ ：打开读访问&lt;/li&gt;
&lt;li&gt;WRITE：打开写访问&lt;/li&gt;
&lt;li&gt;APPEND：向后追加&lt;/li&gt;
&lt;li&gt;CREATE：创建新文件，存在则覆盖&lt;/li&gt;
&lt;li&gt;CREATE_NEW：创建新文件，存在则报错&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MappedByteBuffer：直接字节缓冲区，其内容是文件的内存映射区域。&lt;/p&gt;
&lt;h4 id=&quot;通道数据传输&quot;&gt;通道数据传输&lt;/h4&gt;
&lt;p&gt;将数据从源通道传输到其他 Channel 中，transferTo() 和 transferFrom()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package testnio;

import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class TestChannelTransfer {

    public static void main(String[] args) {
        FileChannel inChannel=null;
        FileChannel outChannel=null;
        try {
            //通过open创建管道
            inChannel = FileChannel.open(Paths.get(&quot;F:/a.jpg&quot;), StandardOpenOption.READ);
            outChannel = FileChannel.open(Paths.get(&quot;F:/b.jpg&quot;),StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE);
            //将inChannel中所有数据发送到outChannel
            //inChannel.transferTo(0, inChannel.size(), outChannel);
            outChannel.transferFrom(inChannel, 0, inChannel.size());
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (inChannel!=null) {
                try {
                    inChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (outChannel!=null) {
                try {
                    outChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Channel 负责传输，Buffer 负责存储&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 02 Nov 2018 13:54:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>NIO 是什么 java.nio全称java non blocking（非阻塞） IO（实际上是 new io），是指jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（bo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/9898687.html</dc:identifier>
</item>
<item>
<title>微信小程序初体验，入门练手项目--通讯录，后台是阿里云服务器 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9898670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9898670.html</guid>
<description>&lt;p&gt;&lt;strong&gt;内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;二、相关概念&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;三、开始工作&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;四、启动项目起来&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;五、项目结构&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;六、设计理念&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;七、路由&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;八、部署线上后端服务&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同步交流学习社区： &lt;a href=&quot;https://www.mwcxs.top/page/440&quot; target=&quot;_blank&quot;&gt;https://www.mwcxs.top/page/440&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码地址：&lt;a href=&quot;https://github.com/saucxs/wx_phoneBook&quot; target=&quot;_blank&quot;&gt;https://github.com/saucxs/wx_phoneBook&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、前言（坑爹的玩意）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        微信小程序自从2017年，被各种看好，不过一段时间过去了还是反响平平，下半年随着各项功能的开放，很多企业陆续接入了小程序，我觉得就算是坑，咱们也得踩踩。不然怎么从微信这个大流量体系中推广引流。&lt;/p&gt;
&lt;p&gt;    小程序内部可以理解成一个mvvm的框架，分为逻辑层和视图层，逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。&lt;/p&gt;
&lt;p&gt;    最近微信小程序异常火爆，很多人在学习，下面带着大家搭建下微信小程序的调试环境（client+server），并调试入门练手项目--&lt;a href=&quot;https://github.com/saucxs/wx_phoneBook&quot; target=&quot;_blank&quot;&gt;通讯录（phoneBook）&lt;/a&gt;（JavaScript和node.js基础即可,微信推荐使用的语言，去菜鸟教程简单学习下 JavaScript，node.js，mysql，nginx即可），方便大家学习。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;        官方解释：微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;        小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。可以理解成一套嵌套在微信里面的app，和原生app不同的是不需要下载，属于小而轻的应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、开始工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、本地koa后台服务部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参考&lt;a href=&quot;https://www.cnblogs.com/chengxs/p/9890735.html&quot;&gt;快速新建简单的koa2后端服务&lt;/a&gt; 这篇文章，教会你快递建立简单的koa后端服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、准备注册等工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fdebug%2Fwxadoc%2Fintroduction%2Findex.html%3Ft%3D20171117&quot; target=&quot;_blank&quot;&gt;注册账号&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;（2）&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fdebug%2Fwxadoc%2Fdev%2Fdevtools%2Fdownload.html%3Ft%3D201822&quot; target=&quot;_blank&quot;&gt;下载开发者工具&lt;/a&gt;, 下载1.02.x这个版本的，最新版的有bug，编译的时候调试器Wxml窗口会出现空的page标签，里面没有内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/2bX4DbdOKytVPJb75uPRRHkdV.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）注册好后登录下&lt;a href=&quot;https://mp.weixin.qq.com/wxopen/wacodepage?action=getcodepage&amp;amp;token=1168160377&amp;amp;lang=zh_CN&quot; target=&quot;_blank&quot;&gt;微信公众平台|小程序&lt;/a&gt;，在设置里找到开发设置，把appID保存下来，一会开发的时候需要用到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/262zFYeJ_gvWH_yo7NCKFAyAj.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、启动项目起来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、此时，工具有了，ID有了，接下来开始我们的撸码之旅。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开开发者工具，扫码登录后选择小程序项目，点击右下角的加号，创建新项目，选择项目目录，填写appID，项目名称，写好后点击确定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/2fsQI8TFT-R_X9uwTtQ4Az6HP.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、确定以后，默认打开后，发现给我们创建了一些代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/2GZIGIZnluqg6y-QV_PbQHXun.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、设置不校验合法域名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个设置是本地开发换环境下，进行开发调试的，必须勾上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/2wjnWYKLNyKlXLLPOBmtssGO3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、运行起来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/2ll6IQQmwnD5NFqlNF232mmWr.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、项目结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们主要看app.js、app.json、app.wxss三个文件和pages文件夹里面的wxml&lt;/p&gt;
&lt;p&gt;1、app.js做为小程序的入口，里面有个App实例，每个小程序只会有一个App实例，小程序启动以后触发onLaunch函数执行，获取用户信息&lt;/p&gt;
&lt;p&gt;2、app.json是小程序的所有全局配置，pages字段放置所有页面的路径，window字段定义所有页面的顶部背景颜色，文字颜色 详细配置请&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fdebug%2Fwxadoc%2Fdev%2Fframework%2Fconfig.html&quot; target=&quot;_blank&quot;&gt;戳这里👇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、app.wxss文件就是页面公用的样式，仅支持部分css选择器&lt;/p&gt;
&lt;p&gt;4、wxml就是我们的HTML文件，常用标签为 view 、text 等，没有所谓的div、span、p一类的标签了，我们习惯称它们为组件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、设计理念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、小程序可以理解成一个mvvm的框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为逻辑层和视图层，逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pages/login/login.js&lt;/span&gt;
const app =&lt;span&gt; getApp();
Page({

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 页面的初始数据
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  data: {
    phone: &lt;/span&gt;''&lt;span&gt;,
    password: &lt;/span&gt;''&lt;span&gt;,
    isError: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    errorText: &lt;/span&gt;''&lt;span&gt;
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 生命周期函数--监听页面加载
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onLoad: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (options) {

  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 输入手机号
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  bindPhoneInput: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      phone: item.detail.value
    })
  },
  
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 输入密码
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  bindPasswordInput: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      password: item.detail.value
    })
  },


  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 点击登录按钮
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  login: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.data.phone === '' || &lt;span&gt;this&lt;/span&gt;.data.password === ''&lt;span&gt;){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
        isError: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        errorText: &lt;/span&gt;&quot;手机号码或密码不能为空&quot;&lt;span&gt;
      })
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    let that &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    wx.request({
      url: `${app.globalData.apiUrl}&lt;/span&gt;/login`,
&lt;span&gt;      data: {
        phone: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.phone,
        password: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.password
      },
      method: &lt;/span&gt;&quot;POST&quot;&lt;span&gt;,
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(res.data.success){
          wx.setStorageSync(&lt;/span&gt;&quot;USERID&quot;&lt;span&gt;, res.data.userID);
          wx.switchTab({
            url: &lt;/span&gt;'/pages/department/department'&lt;span&gt;,
          });
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
          that.setData({
            isError: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            errorText: &lt;/span&gt;&quot;请输入正确的手机号码或密码&quot;&lt;span&gt;
          })
        }
      },
      fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
        console.log(item)
      },
      complete: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
        console.log(item)
      }
    })
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用Page函数来注册一个页面，接收一个Object参数。 &lt;/p&gt;
&lt;p&gt;这里我们使用了onLoad来监听页面的加载，&lt;/p&gt;
&lt;p&gt;定义了一个输入手机号bindPhoneInput函数 ，并使用setData函数将text的值进行更改，&lt;/p&gt;
&lt;p&gt;定义一个输入密码bindPasswordInput函数，并使用setData函数将text的值进行更改，&lt;/p&gt;
&lt;p&gt;定义一个登陆按钮login函数，通过wx.request方法请求后端服务接口，通过wx.setStorageSync方法将请求的结果加入到storage中，通过wx.switchTab方法跳转到相应的路由。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--pages/login/login.wxml--&amp;gt;
&amp;lt;view class=&quot;container&quot;&amp;gt;
  &amp;lt;view class=&quot;login-container&quot;&amp;gt;
    &amp;lt;text class=&quot;app-title&quot;&amp;gt;系统&amp;lt;/text&amp;gt;
    &amp;lt;form class=&quot;login-form&quot;&amp;gt;
      &amp;lt;view class=&quot;section&quot;&amp;gt;
        &amp;lt;input name=&quot;phone&quot; type=&quot;number&quot; bindinput=&quot;bindPhoneInput&quot; maxlength=&quot;11&quot; placeholder=&quot;手机号码&quot; /&amp;gt;
      &amp;lt;/view&amp;gt;
      &amp;lt;view class=&quot;section&quot;&amp;gt;
        &amp;lt;input name=&quot;password&quot; bindinput='bindPasswordInput' type=&quot;password&quot; password=&quot;true&quot; placeholder=&quot;密码&quot; /&amp;gt;
      &amp;lt;/view&amp;gt;
      &amp;lt;text class=&quot;{{ isError ? 'error' : ''}}&quot;&amp;gt;{{errorText}}&amp;lt;/text&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;view class=&quot;section&quot;&amp;gt;
      &amp;lt;button bindtap=&quot;login&quot;&amp;gt;立即登录&amp;lt;/button&amp;gt;
    &amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更改data数据的时候必须调用setData函数进行更改，我们在button组件上添加了点击事件，调用了login函数。&lt;/p&gt;
&lt;p&gt;相应的事件可以参考官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、传递参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候我们需要触发事件的时候，传递一些参数，那小程序怎么传递呢？很不幸，小程序不能类似js里面直接传递，往往我们需要将传递的数据绑定到事件元素上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.wxml&lt;/span&gt;
&amp;lt;button data-test=&quot;哈哈&quot;  bindtap=&quot;change&quot;&amp;gt;点击我&amp;lt;/button&amp;gt;
&lt;span&gt;使用e.currentTarget.dataset来获取值
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.js&lt;/span&gt;
&lt;span&gt;change(e){
  e.currentTarget.dataset.test  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈哈&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;七、路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小程序里面所有的页面路由由框架进行管理&lt;/p&gt;
&lt;p&gt;我们可以使用getCurrnetPages函数获取当前页面栈的实例，返回一个数组, 最后一个元素为当前页面&lt;/p&gt;
&lt;p&gt;小程序定义了五个用于导航跳转的API，这里列举两个常用的&lt;/p&gt;
&lt;p&gt;1、wx.navigateTo 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wx.navigateTo({url:`/pages/text/index?text=${saucxs}`})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、wx.redirectTo 关闭当前页面，跳转到应用内的某个页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wx.navigateTo({url:`/pages/text/index?text=${saucxs }`})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的API跳转带的参数，在页面上我们需要怎么获取呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; text.js&lt;/span&gt;
&lt;span&gt;Page({
  data:{
     ... &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面数据&lt;/span&gt;
&lt;span&gt;  },
  onLoad(options){
    console.log(options.text)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; saucxs 获取上个页面带过来的值&lt;/span&gt;
&lt;span&gt;  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;（一）数据过滤 过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你使用过vue、angular框架，对|管道符肯定不陌生，它用来对我们的数据进行转换，那小程序里面有没有过滤器呢，不过这个是真没有。&lt;/p&gt;
&lt;p&gt;但是目前有两种方法，可以实现过滤。&lt;/p&gt;
&lt;p&gt;1、获取数据的时候，直接改了，干脆利落、好不优雅。&lt;/p&gt;
&lt;p&gt;2、使用最后我们要介绍的wxs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（二）WXS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WXS是小程序的一套脚本语言，首先和js是不同的语言，其次运行环境和js也是隔离开的，wxs不能调用js文件中的函数，也不能调用小程序的API，它主要用来增强wxml。&lt;/p&gt;
&lt;p&gt;wxs不能使用es6语法，接下来我们来实现一个使用wxs实现一个简单的过滤器。&lt;/p&gt;
&lt;p&gt; 1、首先我们创建filter.wxs文件并写入以下内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; filter.wxs&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Filter =&lt;span&gt; {
  getSatusStr: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(num){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = ''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (num) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
        string &lt;/span&gt;= '待支付'
        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
        string &lt;/span&gt;= '已支付'
        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        string &lt;/span&gt;= '待发货'
        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str
  }
}
module.exports &lt;/span&gt;=&lt;span&gt; {
  status: Filter.getSatusStr
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同级下index.wxml使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;wxs module=&quot;filter&quot; src=&quot;./filter.wxs&quot;&amp;gt;&amp;lt;/wxs&amp;gt; 
&amp;lt;view wx:&lt;span&gt;for&lt;/span&gt;=&quot;{{list}}&quot;&amp;gt;
  &amp;lt;view&amp;gt;{{filter.status(item.status)}}&amp;lt;/view&amp;gt;  
&amp;lt;/view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结： &lt;/p&gt;
&lt;p&gt;1、每个wxs标签都有一个module 属性 &lt;/p&gt;
&lt;p&gt;2、wxs可以写在wxml里面的wxs标签里和.wxs文件里 &lt;/p&gt;
&lt;p&gt;3、wxs文件中引入其他wxs文件时候，可以使用require函数，接受相对路径 &lt;/p&gt;
&lt;p&gt;4、在wxml标签里使用外部wxs文件的时候，src属性是相对路径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;八、部署线上后端服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信小程序搭建环境必需的两点：云服务器，域名，下面给搭建演示如果在一台阿里云服务器上搭建微信小程序服务端环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（一）准备好将http转成https&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参考这篇阿里云免费购买SSL证书，nginx无缝升级https：&lt;a href=&quot;https://www.mwcxs.top/page/434.html&quot; target=&quot;_blank&quot;&gt;https://www.mwcxs.top/page/434.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考主要是申请和解析域名，以及将nginx的http跳转到https。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（二）线上部署koa后台服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、修改mysql配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const pool =&lt;span&gt; mysql.createPool({
  host: &lt;/span&gt;'xx.xx.xx.xx'&lt;span&gt;,
  port: &lt;/span&gt;'3306'&lt;span&gt;,
  user: &lt;/span&gt;'root'&lt;span&gt;,
  password: &lt;/span&gt;'xxxxxxxxx'&lt;span&gt;,
  database: &lt;/span&gt;'wx_contactsadmin'&lt;span&gt;,
  connectionLimit: &lt;/span&gt;100&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;host使用你的服务器外网IP，user数据库用户名，密码，以及数据库名称。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、修改请求后端的url&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在app.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;globalData: {
    userInfo: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; apiUrl: 'http://localhost:8000/contact'&lt;/span&gt;
    apiUrl: 'https://phonebook.mwcxs.top/contact'&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3、使用pm2管理koa的服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/2NPvVqttDk-izXuKdCaF4xPiI.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、本地修改设置不校验合法域名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;去掉不校验合法域名的勾选&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/2TTEahzLxNPeI4Qc4kqBR0VL5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 02 Nov 2018 13:50:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>内容： 一、前言 二、相关概念 三、开始工作 四、启动项目起来 五、项目结构 六、设计理念 七、路由 八、部署线上后端服务 同步交流学习社区： https://www.mwcxs.top/p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9898670.html</dc:identifier>
</item>
</channel>
</rss>