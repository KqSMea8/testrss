<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>android传值 - 黄增松</title>
<link>http://www.cnblogs.com/huangzs/p/8996758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangzs/p/8996758.html</guid>
<description>&lt;p&gt;需求&lt;/p&gt;
&lt;p&gt;OneActivity向TwoActivity传值name=hzs，然后TwoActivity向OneActivity传值sex=Y&lt;/p&gt;
&lt;p&gt;第一步：OneActivity向TwoActivity传值name=hzs&lt;/p&gt;
&lt;p&gt;OneActivity 里设置&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;9&quot;&gt;
&lt;pre&gt;
Intent intent = new Intent(OneActivity.this,TwoActivity.class);&lt;br/&gt;intent.putExtra(&quot;name&quot;,&quot;hzs&quot;);&lt;br/&gt;startActivityForResult(intent,2008); //code是请求码 int类型 
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;TwoActivity 里取值&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;pre&gt;
Intent getIntent = getIntent();&lt;br/&gt;String name = getIntent.getStringExtra(&quot;name&quot;);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第二步：TwoActivity向OneActivity传值sex=Y&lt;/p&gt;
&lt;p&gt;TwoActivity 里设置&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;pre&gt;
Intent intent = new Intent();&lt;br/&gt;intent.putExtra(&quot;sex&quot;, &quot;Y&quot;);&lt;br/&gt;setResult(1, intent);  //resultCode 为返回码 用于区分从哪里返回。&lt;br/&gt;finish();
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;OneActivity 里取值&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;@Override &lt;br/&gt;protected void onActivityResult(int requestCode, int resultCode, Intent data) {&lt;/p&gt;
&lt;p&gt;switch(requestCode){&lt;/p&gt;
&lt;p&gt;case 2000:&lt;/p&gt;
&lt;p&gt;if(resultCode==1){&lt;/p&gt;
&lt;p&gt;String sex = data.getStringExtra(&quot;sex&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;break;&lt;/p&gt;
&lt;p&gt;default:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;&lt;p&gt;super.onActivityResult(requestCode, resultCode, data); &lt;br/&gt;}&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sat, 05 May 2018 15:28:00 +0000</pubDate>
<dc:creator>黄增松</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangzs/p/8996758.html</dc:identifier>
</item>
<item>
<title>Git快速入门 - guan_yan_guan</title>
<link>http://www.cnblogs.com/guanzhyan/p/8996607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guanzhyan/p/8996607.html</guid>
<description>&lt;p&gt;前篇文章&lt;a title=&quot;玩转Git入门篇&quot; href=&quot;http://www.cnblogs.com/guanzhyan/p/8996489.html&quot; target=&quot;_blank&quot;&gt;玩转Git入门篇&lt;/a&gt;我们已经对Git有了一个大概的了解，接下来我们学习下Git的如何管理项目的。&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;Repository(仓库)包含的内容 - Git的目标是管理一个工程，或者说是一些文件的集合，以跟踪它们的变化。Git使用Repository来存储这些信息。一个仓库主要包含以下内容(也包括其他内容)：&lt;/p&gt;&lt;div readability=&quot;252.39005083515&quot;&gt;
&lt;h2&gt;创建Repository(仓库)&lt;/h2&gt;
&lt;p&gt;在使用Repository(仓库)之前，我们首先需要创建仓库，创建仓库有很多种，这里常见的有如下几种：&lt;/p&gt;
&lt;p&gt;这里使用第三方托管平台作为讲解，以 &lt;a href=&quot;http://git.oschina.net/&quot; target=&quot;_blank&quot;&gt;http://git.oschina.net&lt;/a&gt; 为例,注册过程就省略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;创建仓库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505225826329-1543167301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击红色箭头指向的”&lt;strong&gt;+&lt;/strong&gt;“号，以创建一个仓库，如下所示 –&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505225951759-622928517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，一个公开的仓库就创建完成了。要记住上面图片创建的路径：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/guanzzh/git-start.git&quot;&gt;https://gitee.com/guanzzh/git-start.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;获取 Git 仓库&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;方法一：从一个服务器克隆一个现有的 Git 仓库。&lt;/p&gt;
&lt;p&gt;方法二：在现有项目或目录下导入所有文件到 Git 中；&lt;/p&gt;
&lt;h3&gt;克隆现有的仓库&lt;/h3&gt;
&lt;p&gt;如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，想为某个开源项目贡献自己的一份力，这时就要用到 &lt;code&gt;git clone&lt;/code&gt; 命令。当你执行 &lt;code&gt;git clone&lt;/code&gt; 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。&lt;/p&gt;
&lt;p&gt;在安装了Git 的 Windows系统上，在一个目录(本示例是：&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;D:\Git_Repository&lt;/span&gt;&lt;/em&gt;)中，单击右键，在弹出的菜单中选择“Git Bash”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的上面创建的仓库 git-start.git，可以用下面的命令：&lt;/p&gt;
&lt;p&gt;$ git clone &lt;a href=&quot;https://gitee.com/guanzzh/git-start.git&quot;&gt;https://gitee.com/guanzzh/git-start.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230143640-607658470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这会在当前目录下创建一个名为 “&lt;code&gt;git-start.git&lt;/code&gt;” 的目录，并在这个目录下初始化一个 &lt;code&gt;.git&lt;/code&gt; 文件夹，从远程仓库拉取下所有数据放入 &lt;code&gt;.git&lt;/code&gt; 文件夹，然后从中读取最新版本的文件的拷贝。&lt;/p&gt;
&lt;p&gt;如果想在克隆远程仓库的时候，自定义本地仓库的名字，可以使用如下命令：&lt;/p&gt;
&lt;p&gt;$ git clone &lt;a href=&quot;https://gitee.com/guanzzh/git-start.git&quot;&gt;https://gitee.com/guanzzh/git-start.git&lt;/a&gt; mygit-start&lt;/p&gt;
&lt;p&gt;Git 支持多种数据传输协议。 上面的例子使用的是 &lt;code&gt;https://&lt;/code&gt; 协议，不过也可以使用 &lt;code&gt;git://&lt;/code&gt; 协议或者使用 SSH 传输协议，比如 &lt;code&gt;user&lt;a title=&quot;@server_ip&quot; href=&quot;https://github.com/server_ip&quot; target=&quot;_blank&quot;&gt;@server_ip&lt;/a&gt;-or-host:path/to/repo.git&lt;/code&gt; 。在服务器上搭建 Git 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。&lt;/p&gt;
&lt;h3&gt;在现有目录中初始化仓库&lt;/h3&gt;
&lt;p&gt;如果不克隆现有的仓库，而是打算使用 Git 来对现有的项目进行管理。假设有一个项目的目录是：&lt;code&gt;D:\Git_Repository\demo-sample&lt;/code&gt;，进入该目录并输入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git init&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git init&lt;/code&gt;命令创建一个空的Git仓库或重新初始化一个现有仓库。
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230350718-843377324.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;该命令将创建一个名为 &lt;code&gt;.git&lt;/code&gt; 的子目录，这个子目录含有初始化的 Git 仓库中所有的必须文件，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪。此时可通过 &lt;code&gt;git add&lt;/code&gt; 命令来实现对指定文件的跟踪，然后执行 &lt;code&gt;git commit&lt;/code&gt; 提交。&lt;/p&gt;
&lt;p&gt;假设在目录 &lt;code&gt;D:\Git_Repository\demo-sample&lt;/code&gt;中有一些代码需要跟踪(版本控制)，可通过 &lt;code&gt;git add&lt;/code&gt; 命令来实现对&lt;em&gt;HelloWorld.java&lt;/em&gt;文件的跟踪 –&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git add &lt;/code&gt;&lt;em&gt;HelloWorld.java&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;$ git commit -m 'initial project version'&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230431945-1474748337.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
&lt;h2&gt;更新提交到仓库&lt;/h2&gt;
&lt;/p&gt;
&lt;h3&gt;记录每次更新到仓库&lt;/h3&gt;
&lt;p&gt;工作目录下的每一个文件都不外乎这两种状态：&lt;span&gt;&lt;strong&gt;已跟踪或未跟踪&lt;/strong&gt;&lt;/span&gt;。 &lt;strong&gt;已跟踪&lt;/strong&gt;的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于&lt;strong&gt;未修改，已修改或已放入暂存区&lt;/strong&gt;。工作目录中除已跟踪文件以外的所有其它文件都属于&lt;strong&gt;未跟踪文件&lt;/strong&gt;，&lt;strong&gt;它们既不存在于上次快照的记录中，也没有放入暂存区。&lt;/strong&gt; 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。&lt;/p&gt;
&lt;p&gt;编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230511077-1117357199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;检查当前文件状态&lt;/h3&gt;
&lt;p&gt;要查看哪些文件处于什么状态，可以用 &lt;code&gt;git status&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git status&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在项目中新建不存在文件&lt;/code&gt;mytext.txt&lt;code&gt;，&lt;/code&gt;使用 &lt;code&gt;git status&lt;/code&gt; 命令，将看到一个新的未跟踪文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230548855-1016136906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若使用 git status -s 命令或 git status --short 命令，将得到一种更为紧凑的格式输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230619968-59985421.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;??标识未跟踪，新增A，修改M，同时出现MM，右M标识文件被修改未放入暂存区，左M标识该文件被修改并放入暂存区。&lt;/p&gt;
&lt;h4&gt;查看已暂存和未暂存的修改&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 将通过文件补丁的格式显示具体哪些行发生了改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230814145-1945520693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;&lt;strong&gt;git diff&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;本身只显示尚未暂存的改动&lt;/strong&gt;，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 &lt;code&gt;git diff&lt;/code&gt; 后却什么也没有，就是这个原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后用&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;code&gt;&lt;strong&gt;git diff --cached&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;查看已经暂存起来的变化：&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;code&gt;&lt;strong&gt;--staged&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;code&gt;&lt;strong&gt;--cached&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;是同义词&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230909783-865102684.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git difftool&lt;/code&gt; 命令来用 &lt;code&gt;Araxis&lt;/code&gt; ，&lt;code&gt;emerge&lt;/code&gt; 或 &lt;code&gt;vimdiff&lt;/code&gt; 等软件输出 &lt;code&gt;diff&lt;/code&gt; 分析结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230932355-873450465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;qa!&lt;/span&gt;&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;退出窗口&lt;br/&gt;&lt;/strong&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;跟踪新文件&lt;/h3&gt;
&lt;p&gt;使用命令 &lt;code&gt;git add&lt;/code&gt; 开始跟踪一个文件。 (&lt;span&gt;添加内容到下一次提交中&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git add mytext.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时再运行 &lt;code&gt;git status&lt;/code&gt; 命令，会看到 &lt;code&gt;mytext.txt&lt;/code&gt; 文件已被跟踪，并处于暂存状态：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231042477-1222125997.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;只要在 &lt;em&gt;Changes to be committed&lt;/em&gt; 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。&lt;span&gt;&lt;code&gt;&lt;strong&gt;git add&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;暂存已修改文件&lt;/h3&gt;
&lt;p&gt;修改一个已被跟踪的文件。然后运行 &lt;code&gt;git status&lt;/code&gt; 命令，会看到下面内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231117037-1018769853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现在 &lt;em&gt;Changes not staged for commit&lt;/em&gt; 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。&lt;strong&gt;要暂存这次更新&lt;/strong&gt;，需要运行 &lt;code&gt;git add&lt;/code&gt; 命令。 这是个多功能命令：可以用它&lt;strong&gt;开始跟踪新文件&lt;/strong&gt;，或者&lt;strong&gt;把已跟踪的文件放到暂存区&lt;/strong&gt;，还能用于&lt;strong&gt;合并时把有冲突的文件标记为已解决状态等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231134654-996434963.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先修改README.md文件，git add之后，现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，修改README.md,再运行 &lt;code&gt;git status&lt;/code&gt; &lt;code&gt;：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231148181-177289404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
现在 &lt;code&gt;README.md&lt;/code&gt; 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了运行 &lt;code&gt;git add&lt;/code&gt; 命令时的版本， 如果现在提交，&lt;code&gt;README.md&lt;/code&gt; 的版本是最后一次运行 &lt;code&gt;git add&lt;/code&gt; 命令时的那个版本，而不是运行 &lt;code&gt;git commit&lt;/code&gt; 时，在工作目录中的当前版本。运行了 &lt;code&gt;git add&lt;/code&gt; 之后又作了修订的文件，需要重新运行 &lt;code&gt;git add&lt;/code&gt; 把最新版本重新暂存起来：
&lt;h3&gt;忽略文件&lt;/h3&gt;
&lt;p&gt;一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为 &lt;code&gt;.gitignore&lt;/code&gt; 的文件，列出要忽略的文件模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ cat .gitignore&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;*.[oa]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;*~&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;忽略所有以 &lt;code&gt;.o&lt;/code&gt; 或 &lt;code&gt;.a&lt;/code&gt; 结尾的文件。&lt;/p&gt;
&lt;p&gt; 忽略所有以波浪符(&lt;code&gt;~&lt;/code&gt;)结尾的文件，&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;.gitignore&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;的格式规范如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有空行或者以 ＃ 开头的行都会被 Git 忽略。&lt;/li&gt;
&lt;li&gt;可以使用标准的 glob 模式匹配。&lt;/li&gt;
&lt;li&gt;匹配模式可以以(/)开头防止递归。&lt;/li&gt;
&lt;li&gt;匹配模式可以以(/)结尾指定目录。&lt;/li&gt;
&lt;li&gt;要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：GitHub 有一个十分详细的针对数十种项目及编程语言的 &lt;code&gt;.gitignore&lt;/code&gt; 文件列表，你可以在 &lt;a href=&quot;http://github.com/github/gitignore&quot; target=&quot;_blank&quot;&gt;http://github.com/github/gitignore&lt;/a&gt; 找到它。&lt;/p&gt;
&lt;h3&gt;提交更新&lt;/h3&gt;
&lt;p&gt;每次准备提交前，先用 &lt;code&gt;git status&lt;/code&gt; 看下，是不是都已暂存起来了，如果没有暂存起来则要先使用命令：&lt;code&gt;git add .&lt;/code&gt;将所有文件暂存起来， 然后再运行提交命令 &lt;code&gt;git commit&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git status&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git add .&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git commit&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提交后它会告诉你，当前是在哪个分支(&lt;code&gt;master&lt;/code&gt;)提交的，本次提交的完整 SHA-1 校验和是什么(&lt;code&gt;463dc4f&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请记住&lt;/strong&gt;，提交时记录的是放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳过使用暂存区域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt; 加上 &lt;code&gt;-a&lt;/code&gt; 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 &lt;code&gt;git add&lt;/code&gt; 步骤：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git commit -a -m 'added new benchmarks'&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;Git&lt;/code&gt;&lt;code&gt;隐藏(stash)操作&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在Git中，隐藏操作将使您能够修改跟踪文件，阶段更改，并将其保存在一系列未完成的更改中，并可以随时重新应用。要将一个新的存根推到堆栈上，运行&lt;code&gt;git stash&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git stash&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;Saved working directory and index state WIP on master: ef07ab5 synchronized with the remote repository&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;HEAD is now at ef07ab5 synchronized with the remote repository&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过使用&lt;/strong&gt;&lt;code&gt;&lt;strong&gt;git stash list&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt;命令来查看已存在更改的列表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git stash list&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;stash@{0}: WIP on master: ef07ab5 synchronized with the remote repository&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;想要重新开始新的功能的代码编写，查找上次没有写完成的代码，只需执行&lt;/strong&gt;&lt;code&gt;&lt;strong&gt;git stash pop&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt;命令即可从堆栈中删除更改并将其放置在当前工作目录中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231458188-943016788.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;移除文件&lt;/h3&gt;
&lt;p&gt;要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除(确切地说，是从暂存区域移除)，然后提交。 可以用 &lt;code&gt;git rm&lt;/code&gt; 命令完成此项工作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ rm mytext.txt&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已经存放到暂存区，则必须要用强制删除选项 &lt;code&gt;-f&lt;/code&gt;(注：即 &lt;code&gt;force&lt;/code&gt; 的首字母)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rm&lt;/code&gt; 命令后面可以列出文件或者目录的名字，也可以使用 &lt;code&gt;glob&lt;/code&gt; 模式。 比方说：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git rm log/\*.log&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;移动文件&lt;/h3&gt;
&lt;p&gt;Git 并不显式跟踪文件移动操作。在 Git 中对文件改名，命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git mv file_from file_to&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;相当于如下三个命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ mv README.md README&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git rm README.md&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git add README&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;查看提交历史&lt;/h3&gt;
&lt;p&gt;查看提交历史，&lt;code&gt;git log&lt;/code&gt; 命令。默认不用任何参数的话，&lt;code&gt;git log&lt;/code&gt; 会按提交时间列出所有的更新，最近的更新排在最上面。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231639764-1039136274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个常用的选项是 &lt;code&gt;-p&lt;/code&gt;，用来显示每次提交的内容差异。 你也可以加上 &lt;code&gt;-2&lt;/code&gt; 来仅显示最近两次提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231654114-1855859567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想看到每次提交的简略的统计信息，可以使用 &lt;code&gt;--stat&lt;/code&gt; 选项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231706766-126920780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外一个常用的选项是 &lt;code&gt;--pretty&lt;/code&gt;。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 &lt;code&gt;oneline&lt;/code&gt; 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 &lt;code&gt;short&lt;/code&gt;，&lt;code&gt;full&lt;/code&gt; 和 &lt;code&gt;fuller&lt;/code&gt; 可以用，展示的信息或多或少有些不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231721794-616220142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;撤消操作&lt;/h3&gt;
&lt;p&gt;有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 &lt;code&gt;--amend&lt;/code&gt; 选项的提交命令尝试重新提交：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git commit --amend&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改(例如，在上次提交后马上执行了此命令)，那么快照会保持不变，而你所修改的只是提交信息。&lt;/p&gt;
&lt;h3&gt;取消暂存的文件&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;...&lt;/code&gt; 来取消暂存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git reset HEAD mytext.txt&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reset强调，撤销&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;git reset head - - filename &lt;ul&gt;&lt;li&gt;撤销上次暂存（取消暂存区的内容，用head指向的目录（版本库）替换暂存区）&lt;/li&gt;
&lt;li&gt;如果只删除暂存，保留工作区，可以使用git rm --cached -r filename,-r表示递归删除&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;git reset - -hard head: &lt;ul&gt;&lt;li&gt;撤销本地和暂存区的所有变动（用head指向的目录（版本库）替换本地和暂存区）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;git reset – hard origin/master &lt;ul&gt;&lt;li&gt;撤销本地、暂存区、版本库(用远程服务器的origin/master替换本地、暂存区、版本库)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;用Git复位移动头指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过少量更改后，可以决定删除这些更改。 &lt;code&gt;git reset&lt;/code&gt;命令用于复位或恢复更改。 我们可以执行三种不同类型的复位操作。语法：git reset [&amp;lt;mode&amp;gt;] [&amp;lt;commit&amp;gt;]&lt;/p&gt;
&lt;p&gt;下图显示了&lt;code&gt;git reset&lt;/code&gt;命令的图示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;git reset&lt;/code&gt;命令之前 -&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231919618-780711756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;git reset&lt;/code&gt;命令之后 -&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231925329-415093366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;—soft&lt;/strong&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个分支都有一个&lt;code&gt;HEAD&lt;/code&gt;指针，它指向最新的提交。 如果用&lt;code&gt;--soft&lt;/code&gt;选项后跟提交ID的&lt;code&gt;Git reset&lt;/code&gt;命令，那么它将仅重置&lt;code&gt;HEAD&lt;/code&gt;指针而不会破坏任何东西。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.git/refs/heads/master&lt;/code&gt;文件存储&lt;code&gt;HEAD&lt;/code&gt;指针的提交ID。 使用git reset --soft [comittedID]命令。可使用&lt;code&gt;git log -1&lt;/code&gt;命令验证它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505232022249-135563953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;$ git reset --soft 931280a3ec004120c4cee372f45cf7c0b4fed1bc&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505232035156-1712108578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;--mixed&lt;/code&gt;选项的Git重置将从尚未提交的暂存区域还原这些更改。它仅从暂存区域恢复更改。对文件的工作副本进行的实际更改不受影响。 默认Git复位等效于执行&lt;code&gt;git reset -- mixed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果使用&lt;code&gt;--hard&lt;/code&gt;选项与Git重置命令，它将清除分段区域; 它会将HEAD指针重置为特定提交ID的最新提交，并删除本地文件更改。&lt;/p&gt;
&lt;h3&gt;撤消对文件的修改&lt;/h3&gt;
&lt;p&gt;用暂存区的内容替换工作区的文件。使用 &lt;code&gt;git checkout -- &amp;lt;file&amp;gt;...&lt;/code&gt; 来撤消之前所做的修改。（&lt;strong&gt;未加入暂存区&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git checkout -- mytext.txt&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505232120768-1862242757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;strong&gt;加入暂存区撤销修改&lt;/strong&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
当执行添加操作时，文件将从本地存储库移动到暂存区域。 如果用户意外修改文件并将其添加到暂存区域，则可以使用&lt;code&gt;git checkout&lt;/code&gt;命令恢复其更改。
&lt;/pre&gt;
&lt;pre&gt;
在Git中，有一个&lt;code&gt;HEAD&lt;/code&gt;指针总是指向最新的提交。 如果要从分段区域撤消更改，则可以使用&lt;code&gt;git checkout&lt;/code&gt;命令，但是使用&lt;code&gt;checkout&lt;/code&gt;命令，必须提供一个附加参数，即&lt;code&gt;HEAD&lt;/code&gt;指针。 附加的提交指针参数指示&lt;code&gt;git checkout&lt;/code&gt;命令重置工作树，并删除分段更改。
&lt;/pre&gt;
&lt;p&gt;$ git checkout &lt;strong&gt;head&lt;/strong&gt; -- &lt;code&gt;mytext.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;休息片刻，接下来我们将在&lt;a title=&quot;Git快速入门进阶篇&quot; href=&quot;http://www.cnblogs.com/guanzhyan/p/8996750.html&quot; target=&quot;_blank&quot;&gt;Git快速入门进阶篇&lt;/a&gt;中继续探讨Git是如何管理项目的。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 05 May 2018 15:27:00 +0000</pubDate>
<dc:creator>guan_yan_guan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guanzhyan/p/8996607.html</dc:identifier>
</item>
<item>
<title>[ SSH框架 ] Hibernate框架学习之四（JPA） - Kevin.ZhangCG</title>
<link>http://www.cnblogs.com/Kevin-ZhangCG/p/8996491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kevin-ZhangCG/p/8996491.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、JPA概述以及它和Hibernate之间的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1.Hibernate 概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JPA Java Persistence API，是EJB3规范中负责对象持久化的应用程序编程接口（ORM接口），它定义一系列的注释。这些注释大体可分为：类级别注释、方法级别注释、字段级别注释。给实体类添加适当的注释可以在程序运行时告诉Hibernate如何将一个实体类保存到数据库中以及如何将数据以对象的形式从数据库中读取出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目前有两种注释方案可以确定对象与表格之间的对应关系：一种是注释实体类的属性字段（字段级别注释），成为字段访问方式（field access mode）；另一种是注释实体类的属性访问方法（方法级别注释），称为属性访问方式（property access mode）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 JPA与Hibernate 的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JPA和Hibernate之间的关系，可以简单的理解为&lt;span&gt;JPA是标准接口&lt;/span&gt;，&lt;span&gt;Hibernate是实现&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;hibernate-annotation：&lt;/strong&gt;是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;hibernate-core：&lt;/strong&gt;是Hibernate的核心实现，提供了Hibernate所有的核心功能。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;hibernate-entitymanager：&lt;/strong&gt;实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、JPA的环境搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 主要配置文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用JPA可以省去配置每个实体类的.xml 文件，只需直接在实体类中用注解的方式直接说明即可。先在src目录下的META-INF文件下创建persistence.xml配置文件，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505203623881-484167877.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;persistence.xml配置内容如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://java.sun.com/xml/ns/persistence
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;&lt;/span&gt;
    version=&quot;2.0&quot;&amp;gt;

    
    &amp;lt;!--&lt;span&gt; 配置持久化单元 
        可以制定多个持久化单元，但名称不可重复，name用于指定持久化单元名称        
        transaction&lt;/span&gt;-&lt;span&gt;type：指定事务的类型
                        RESCOURCE_LOCAL:指的是本地代码事务        
    &lt;/span&gt;--&amp;gt;
    &amp;lt;persistence-unit name=&quot;myJPAUnit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&amp;gt;
    &amp;lt;!-- JPA规范的提供商  可以不写 --&amp;gt;
        &amp;lt;provider&amp;gt;org.hibernate.jpa.HibernatePersistenceProvider&amp;lt;/provider&amp;gt;
    &amp;lt;!-- 指定由JPA注解的实体类位置    可以不写--&amp;gt;    
        &amp;lt;&lt;span&gt;class&lt;/span&gt;&amp;gt;com.Kevin.domain.Customer&amp;lt;/&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;!-- 连接数据库相关的一些配置，都是Hibernate的，所以只需要把之前Hibernate配置文件中的内容拷贝过来即可 --&amp;gt;
        &amp;lt;properties&amp;gt;
            &amp;lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql:///hibernateday4&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.password&quot; value=&quot;admin&quot;/&amp;gt;
            &amp;lt;!-- Hibernate显示SQL语句 --&amp;gt;
            &amp;lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&amp;gt;
            &amp;lt;!-- Hibernate格式化SQL语句 --&amp;gt;
            &amp;lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;/&amp;gt; 
        &amp;lt;/properties&amp;gt;
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获取JPA操作数据库的对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;在src目录下com.Kevin.utils包中创建JPAUtil类用来获取数据库操作对象，文件目录如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505204217579-173059649.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.utils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManagerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Persistence;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * JPA的工具类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JPAUtil {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于SessionFactory&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManagerFactory factory;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt; tl;
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        factory&lt;/span&gt;=Persistence.createEntityManagerFactory(&quot;myJPAUnit&quot;);　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称要与persistence.xml文件中的持久化单元name一致&lt;/span&gt;
        tl=&lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取JPA操作数据库的对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static EntityManager createEntityManager(){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return factory.createEntityManager();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取EntityManager对象
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManager createEntityManager(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从当前线程上获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;tl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(em==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            em&lt;/span&gt;=&lt;span&gt;factory.createEntityManager();
            tl.set(em);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tl.get();        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[]args){
        createEntityManager();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 基本映射注释简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.1 @Entity：映射实体类（必须）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;@Entity(name=&quot;EntityName&quot;)&lt;/span&gt;  ,name 为可选 , 对应数据库中一的个表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.2 @Table：映射数据库表名（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@Table(name=&quot;&quot;,catalog=&quot;&quot;,schema=&quot;&quot;)&lt;/span&gt;  , 通常和 @Entity 配合使用 , 只能标注在实体的 class 定义处 , 表示实体对应的数据库表的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 name: 可选 , 表示表的名称 . 默认地 , 表名和实体名称一致 , 只有在不一致的情况下才需要指定表名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 catalog: 可选 , 表示 Catalog 名称 , 默认为 Catalog(&quot;&quot;). schema: 可选 , 表示 Schema 名称 , 默认为 Schema(“”)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.3 @Id：映射生成主键（必选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;@id 定义了映射到数据库表的主键的属性 , &lt;span&gt;一个实体只能有一个属性被映射为主键&lt;/span&gt; 。置于 getXxxx() 前 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@GeneratedValue(strategy=GenerationType,generator=&quot;&quot;)&lt;/span&gt; 可选 strategy: 表示主键生成策略 , 有 AUTO,INDENTITY,SEQUENCE 和 TABLE 4 种 , 分别表示让 ORM 框架自动选择。根据数据库的 Identity 字段生成 , 根据数据库表的 Sequence 字段生成 , 以有根据一个额外的表生成主键 , 默认为 AUTO 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　generator: 表示主键生成器的名称 , 这个属性通常和 ORM 框架相关 , 例如 ,Hibernate 可以指定 uuid 等主键生成方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.4 @Column：映射表格列（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Column 描述了数据库表中该字段的详细定义 , 这对于根据 JPA 注解生成数据库表结构的工具非常有作用 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　name: 表示数据库表中该字段的名称 , 默认情形属性名称一致 。nullable: 表示该字段是否允许为 null, 默认为 true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　unique: 表示该字段是否是唯一标识 , 默认为 false length: 表示该字段的大小 , 仅对 String 类型的字段有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　insertable: 表示在 ORM 框架执行插入操作时 , 该字段是否应出现 INSETRT 语句中 , 默认为 true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　updateable: 表示在 ORM 框架执行更新操作时 , 该字段是否应该出现在 UPDATE 语句中 , 默认为 true. 对于一经创建就不可以更改的字段 , 该属性非常有用 , 如对于 birthday 字段 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　columnDefinition: 表示该字段在数据库中的实际类型 . 通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型 , 但是对于 Date 类型仍无法确定数据库中字段类型究竟是 DATE,TIME 还是 TIMESTAMP. 此外 ,String 的默认映射类型为 VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB 或 TEXT 字段类型 , 该属性非常有用 .。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.5 @Transient：定义暂态属性（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Transient 表示该属性并非一个到数据库表的字段的映射 ,ORM 框架将忽略该属性。如果一个属性并非数据库表的字段映射 , 就务必将其标示为 @Transient, 否则 ,ORM 框架默认其注解为 @Basic。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 关联类映射注释简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.1 @ManyToOne（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@ManyToOne(fetch=FetchType,cascade=CascadeType ) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ManyToOne 表示一个多对一的映射 , 该注解标注的属性通常是数据库表的外键 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　optional: 是否允许该字段为 null, 该属性应该根据数据库表的外键约束来确定 , 默认为 true 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fetch: 表示抓取策略 , 默认为 FetchType.EAGER cascade: 表示默认的级联操作策略 , 可以指定为 ALL,PERSIST,MERGE,REFRESH 和 REMOVE 中的若干组合 , 默认为无级联操作 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　targetEntity: 表示该属性关联的实体类型 . 该属性通常不必指定 ,ORM 框架根据属性类型自动判断 targetEntity。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.2 @JoinColumn（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@JoinColumn 和 @Column 类似 , 介量描述的不是一个简单字段 , 而一一个关联字段 , 例如 . 描述一个 @ManyToOne 的字段 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　name: 该字段的名称 . 由于 @JoinColumn 描述的是一个关联字段 , 如 ManyToOne, 则默认的名称由其关联的实体决定。例如 , 实体 Order 有一个 user 属性来关联实体 User, 则 Order 的 user 属性为一个外键 , 其默认的名称为实体 User 的名称 + 下划线 + 实体 User 的主键名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.3 @OneToMany&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@OneToMany(fetch=FetchType,cascade=CascadeType) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@OneToMany 描述一个一对多的关联 , 该属性应该为集体类型 , 在数据库中并没有实际字段 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fetch: 表示抓取策略 , 默认为 FetchType.LAZY, 因为关联的多个对象通常不必从数据库预先读取到内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　cascade: 表示级联操作策略 , 对于 OneToMany 类型的关联非常重要 , 通常该实体更新或删除时 , 其关联的实体也应当被更新或删除 例如 : 实体 User 和 Order 是 OneToMany 的关系 , 则实体 User 被删除时 , 其关联的实体 Order 也应该被全部删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.4 @OneToOne（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@OneToOne(fetch=FetchType,cascade=CascadeType)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@OneToOne 描述一个一对一的关联 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fetch: 表示抓取策略 , 默认为 FetchType.LAZY 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　cascade: 表示级联操作策略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.5 @ ManyToMany（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ManyToMany 描述一个多对多的关联 . 多对多关联上是两个一对多关联 , 但是在 ManyToMany 描述中 , 中间表是由 ORM 框架自动处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　targetEntity: 表示多对多关联的另一个实体类的全名 , 例如 :package.Book.class。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　mappedBy: 表示多对多关联的另一个实体类的对应集合属性名称。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、JPA入门案例和CRUD操作（单表）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 创建客户实体类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的实体类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 * 使用的注解都是JPA规范，所以导包要导入javax.persistence包下
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Entity      &lt;/span&gt;&lt;span&gt;//表名&lt;/span&gt;&lt;span&gt;该类是一个实体类&lt;/span&gt;
@Table(name=&quot;cst_customer&quot;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立当前类和数据库的对应关系&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Customer{
    @Id    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    @Column(name=&quot;cust_id&quot;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表明对应数据库的主键字段是cust_id&lt;/span&gt;
    @GeneratedValue(strategy=GenerationType.IDENTITY)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定主键生成策略,strategy:使用JPA中提供的主键生成策略，此属性是用不了；generator属性可以使用hibernate主键生成策略&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_id;    
    
    @Column(name&lt;/span&gt;=&quot;cust_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_name;
    
    @Column(name&lt;/span&gt;=&quot;cust_address&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_address;
    
    @Column(name&lt;/span&gt;=&quot;cust_industry&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_industry;
    
    @Column(name&lt;/span&gt;=&quot;cust_level&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_level;
    
    
    @Column(name&lt;/span&gt;=&quot;cust_phone&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_phone;
    
    @Column(name&lt;/span&gt;=&quot;cust_mobile&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_mobile;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_id(Long cust_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_id =&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_name(String cust_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_name =&lt;span&gt; cust_name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_address() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_address(String cust_address) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_address =&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_industry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_industry(String cust_industry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_industry =&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_level() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_level(String cust_level) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_level =&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_phone(String cust_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_phone =&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_mobile(String cust_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_mobile =&lt;span&gt; cust_mobile;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Customer [cust_id=&quot; + cust_id + &quot;, cust_name=&quot; + cust_name + &quot;, cust_address=&quot; +&lt;span&gt; cust_address
                &lt;/span&gt;+ &quot;, cust_industry=&quot; + cust_industry + &quot;, cust_level=&quot; + cust_level + &quot;, cust_phone=&quot; +&lt;span&gt; cust_phone
                &lt;/span&gt;+ &quot;, cust_mobile=&quot; + cust_mobile + &quot;]&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 编写CRUD测试代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2.1 保存操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存操作&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建客户对象&lt;/span&gt;
        Customer c=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        c.setCust_name(&lt;/span&gt;&quot;Kevin&quot;&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取EntityManager&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行保存操作&lt;/span&gt;
&lt;span&gt;        em.persist(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.2 更新操作（两种方式）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：正常更新方式（update）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取EntityManager&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行更新操作（将需要更新的对象查询出来）&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新客户地址&lt;/span&gt;
        c.setCust_address(&quot;China&quot;&lt;span&gt;);&lt;br/&gt;　　　 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二种：合并方式保存（merge，将两个实体合并）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4(){    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取EntityManager&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行更新操作（将需要更新的对象查询出来）&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新客户地址&lt;/span&gt;
        c.setCust_mobile(&quot;66666666&quot;&lt;span&gt;);;
        em.merge(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.3 删除操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取操作对象&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除对象&lt;/span&gt;
&lt;span&gt;        em.remove(c);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.2.4 基本查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询所有&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 涉及的对象：
     *             JPA的Query：
     *         如何获取对象：EntityManager的createQuery（String sql）
     *         参数含义：JPAL：Java Persistence Query Language
     *                 写法与HQL很相似，也是把表名换成类名，把字段名换成属性名称
     *                 在写查询所有时，不能直接用    from 类
     *                 需要使用select关键字
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test6(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取JPA的查询对象Query&lt;/span&gt;
        Query query=em.createQuery(&quot;select c from Customer c&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c是一个别名
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法获取结果集&lt;/span&gt;
        List list=&lt;span&gt;query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object o:list)
            System.out.println(o);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.2.5 条件查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test7(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取JPA的查询对象Query&lt;/span&gt;
        Query query=em.createQuery(&quot;select c from Customer c where cust_name like ?&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给占位符赋值&lt;/span&gt;
        query.setParameter(1, &quot;%k%&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法获取结果集&lt;/span&gt;
        List list=&lt;span&gt;query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object o:list)
            System.out.println(o);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;多条件查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test8(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取JPA的查询对象Query&lt;/span&gt;
        Query query=em.createQuery(&quot;select c from Customer c where cust_name like ? and cust_level = ? &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给占位符赋值&lt;/span&gt;
        query.setParameter(1, &quot;%K%&quot;&lt;span&gt;);
        query.setParameter(&lt;/span&gt;2, &quot;5&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法获取结果集&lt;/span&gt;
        List list=&lt;span&gt;query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object o:list)
            System.out.println(o);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;TIps：&lt;/span&gt; &lt;/strong&gt; &lt;span&gt;1. persist()方法相当于是save()操作；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2. remove()对应的是delete()；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3. find()方法对应get()方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　4. getReference()是延迟加载；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　5. find()是立即加载；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　6. uniqueResult()对应getSingleResult(),返回唯一的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　7. merge()和update()相似，但是merge干的活update有些不能干；&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt; 3.2.6 区别merge和update&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　当查询了一个对象后，关闭session，再次查询了该对象，并且修改了该对象。此时如果使用update方法时会报错，因为第一次查完后关闭了session，对象的状态转变成了托管态，而此时查询该对象，修改的时候是持久态，对象的状态是不一样的，在一级缓存外边还有一个修改对象。此时更新的话，由于两个对象的OID是一样的，但是却发生了修改，使用update的话，两个对象是不能合并的，只能用merge()方法将其更新，即将两个对象合并。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test10(){
         &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 查询ID为1的客户
         * 关闭EntityManager（清空了一级缓存和快照）
         * 修改id为1的客户的地址为America
         * 在此获取EntityManager
         * 再次查询ID为1的客户
         *  更新刚才修改的客户
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        Customer c&lt;/span&gt;=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1L);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持久态&lt;/span&gt;
&lt;span&gt;        tx.commit();
        em.close();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改客户信息&lt;/span&gt;
        c.setCust_address(&quot;America&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;托管态
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em1=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx1=&lt;span&gt;em.getTransaction();
        tx1.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次查询&lt;/span&gt;
        Customer c1=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1L);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持久态
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新操作&lt;/span&gt;
        em1.persist(c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将托管态转换为持久态,update(persist)方法是不行的，必须要用到merge方法才可以的&lt;/span&gt;
&lt;span&gt;        em1.merge(c);
        tx1.commit();
        em1.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、 JPA中实体一对多映射配置及操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1 一对多实体类注解编写&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.FetchType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.OneToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的实体类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 * 使用的注解都是JPA规范，所以导包要导入javax.persistence包下
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Entity      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表情该类是一个实体类&lt;/span&gt;
@Table(name=&quot;cst_customer&quot;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立当前类和数据库的对应关系&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Customer{
    @Id    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    @Column(name=&quot;cust_id&quot;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表明对应数据库的主键字段是cust_id&lt;/span&gt;
    @GeneratedValue(strategy=GenerationType.IDENTITY)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定主键生成策略,strategy:使用JPA中提供的主键生成策略，此属性是用不了；generator属性可以使用hibernate主键生成策略&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_id;    
    
    @Column(name&lt;/span&gt;=&quot;cust_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_name;
    
    @Column(name&lt;/span&gt;=&quot;cust_address&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_address;
    
    @Column(name&lt;/span&gt;=&quot;cust_industry&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_industry;
    
    @Column(name&lt;/span&gt;=&quot;cust_level&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_level;
    
    
    @Column(name&lt;/span&gt;=&quot;cust_phone&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_phone;
    
    @Column(name&lt;/span&gt;=&quot;cust_mobile&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_mobile;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一对多关系映射：一个客户可以有多个联系人
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;targetEntity=Linkman.class  可以不写&lt;/span&gt;
    @OneToMany(targetEntity=Linkman.&lt;span&gt;class&lt;/span&gt;,mappedBy=&quot;customer&quot;,cascade=CascadeType.ALL,fetch=&lt;span&gt;FetchType.EAGER)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;Linkman&amp;gt; linkmans=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Linkman&amp;gt;(0&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_id(Long cust_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_id =&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_name(String cust_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_name =&lt;span&gt; cust_name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_address() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_address(String cust_address) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_address =&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_industry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_industry(String cust_industry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_industry =&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_level() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_level(String cust_level) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_level =&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_phone(String cust_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_phone =&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_mobile(String cust_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_mobile =&lt;span&gt; cust_mobile;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Linkman&amp;gt;&lt;span&gt; getLinkmans() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; linkmans;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setLinkmans(Set&amp;lt;Linkman&amp;gt;&lt;span&gt; linkmans) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.linkmans =&lt;span&gt; linkmans;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Customer [cust_id=&quot; + cust_id + &quot;, cust_name=&quot; + cust_name + &quot;, cust_address=&quot; +&lt;span&gt; cust_address
                &lt;/span&gt;+ &quot;, cust_industry=&quot; + cust_industry + &quot;, cust_level=&quot; + cust_level + &quot;, cust_phone=&quot; +&lt;span&gt; cust_phone
                &lt;/span&gt;+ &quot;, cust_mobile=&quot; + cust_mobile + &quot;]&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;联系人实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 创建联系人实体类
 *   `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)',
  `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名',
  `lkm_cust_id` bigint(32) NOT NULL COMMENT '客户id',
  `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别',
  `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话',
  `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机',
  `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱',
  `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq',
  `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位',
  `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注',
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToOne;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

@Entity
@Table(name&lt;/span&gt;=&quot;cst_linkman&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Linkman &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    @Id
    @Column(name&lt;/span&gt;=&quot;lkm_id&quot;&lt;span&gt;)
    @GeneratedValue(strategy&lt;/span&gt;=&lt;span&gt;GenerationType.IDENTITY)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long lkm_id;
    @Column(name&lt;/span&gt;=&quot;lkm_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_name;
    @Column(name&lt;/span&gt;=&quot;lkm_gender&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_gender;
    @Column(name&lt;/span&gt;=&quot;lkm_mobile&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_mobile;
    @Column(name&lt;/span&gt;=&quot;lkm_phone&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_phone;
    @Column(name&lt;/span&gt;=&quot;lkm_email&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_email;
    @Column(name&lt;/span&gt;=&quot;lkm_qq&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_qq;
    @Column(name&lt;/span&gt;=&quot;lkm_position&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_position;
    @Column(name&lt;/span&gt;=&quot;lkm_memo&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_memo;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一对多关系影射
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从表实体包含主表实体的对象引用&lt;/span&gt;
    @ManyToOne(targetEntity=Customer.&lt;span&gt;class&lt;/span&gt;,cascade=&lt;span&gt;CascadeType.ALL)
    @JoinColumn(name&lt;/span&gt;=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Customer customer;
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getLkm_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_id(Long lkm_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_id =&lt;span&gt; lkm_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_name(String lkm_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_name =&lt;span&gt; lkm_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_gender() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_gender;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_gender(String lkm_gender) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_gender =&lt;span&gt; lkm_gender;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_mobile(String lkm_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_mobile =&lt;span&gt; lkm_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_phone(String lkm_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_phone =&lt;span&gt; lkm_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_email() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_email;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_email(String lkm_email) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_email =&lt;span&gt; lkm_email;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_qq() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_qq;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_qq(String lkm_qq) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_qq =&lt;span&gt; lkm_qq;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_position() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_position;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_position(String lkm_position) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_position =&lt;span&gt; lkm_position;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_memo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_memo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_memo(String lkm_memo) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_memo =&lt;span&gt; lkm_memo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getCustomer() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomer(Customer customer) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customer =&lt;span&gt; customer;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Linkman [lkm_id=&quot; + lkm_id + &quot;, lkm_name=&quot; + lkm_name + &quot;, lkm_gender=&quot; + lkm_gender + &quot;, lkm_mobile=&quot;
                + lkm_mobile + &quot;, lkm_phone=&quot; + lkm_phone + &quot;, lkm_email=&quot; + lkm_email + &quot;, lkm_qq=&quot; +&lt;span&gt; lkm_qq
                &lt;/span&gt;+ &quot;, lkm_position=&quot; + lkm_position + &quot;, lkm_memo=&quot; + lkm_memo + &quot;]&quot;&lt;span&gt;;
    }
    
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2 一对多关联关系的相关操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2.1 保存操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存操作
     *         创建一个客户和一个联系人
     *         建立客户和联系人的双向关联关系
     *         先保存客户，在保存联系人
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        Customer c&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        c.setCust_name(&lt;/span&gt;&quot;Kevin_one2many&quot;&lt;span&gt;);
        Linkman lkm&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Linkman();
        lkm.setLkm_name(&lt;/span&gt;&quot;Kevin_onw2many&quot;&lt;span&gt;);
        
        c.getLinkmans().add(lkm);
        lkm.setCustomer(c);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        em.persist(c);
        em.persist(lkm);
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2.2 更新操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　此时需要配置级联操作：要级联操作哪一方就应该在那一方的上边进行注解配置cascade=CsacadeType.PERSIST属性，即保存或者更新客户的同时保存联系人,但时cascade=CsacadeType.PERSIST只是级联更新。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505221051323-627908734.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;其中mappedBy是映射来自，相当于inverse，即主表不在关心从表的信息，让联系人去维护&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新操作
     * 创建一个联系人
     * 查询id为*客户
     * 为该客户分配该联系人
     * 更新客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        Linkman lkm&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Linkman();
        lkm.setLkm_name(&lt;/span&gt;&quot;Kevin_onw2many3&quot;&lt;span&gt;);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        Customer c&lt;/span&gt;=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 7l&lt;span&gt;);
        
        c.getLinkmans().add(lkm);
        lkm.setCustomer(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;em.merge(c);        &lt;/span&gt;
&lt;span&gt;        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2.3 删除操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　删除主表：若在客户上边配置了放弃维护，即mappedBy=&quot;customer&quot;,直接删除指标会报错，若此时还想要删除的话，需要配置cascade=CascadeType.DELET或者cascade=CascadeType.ALL就可以删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505221824778-1761227308.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;需要注意的是：联系人（从表）也可以配置cascade=CascadeType.ALL来进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        Customer c&lt;/span&gt;=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 6l&lt;span&gt;);
        em.remove(c);
        
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.4 查询操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JPA中也可以使用对象导航查询，也可以设置查询的时机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;延迟加载的特点：真正用到该对象的时候才开始查询改对象的属性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是立即加载，需要在Customer的set集合的注解中加入下边的语句：fetch=FetchType.&lt;em&gt;EAGER，&lt;/em&gt;如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505221622048-1467928226.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其原理是利用了左外连接查询的方式实现了立即加载。没写是EAGER，即默认是EAGER。LinkMan中也可是设置成立即加载。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　mappedBy是映射来自，相当于inverse，即主表不在关心从表的信息，让联系人去维护。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据客户查询联系人&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询id为7的客户&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 7l&lt;span&gt;);
        System.out.println(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询当前客户下的联系人&lt;/span&gt;
        Set&amp;lt;Linkman&amp;gt; linkmans=&lt;span&gt;c.getLinkmans();
        System.out.println(linkmans);
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据联系人查询客户&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询id为7的客户&lt;/span&gt;
        Linkman lkm=em.find(Linkman.&lt;span&gt;class&lt;/span&gt;, 4l&lt;span&gt;);
        System.out.println(lkm);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询当前客户下的联系人&lt;/span&gt;
        Customer c=&lt;span&gt;lkm.getCustomer();
        System.out.println(c);
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、 JPA中实体多对多映射配置及操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.1 多对多的实体类注解编写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在角色实体对象中，如果配置了中间表的表名和在中间表中的列明，则在另外多的一方中只需要配置@ManyToMany(mappedBy=&quot;users&quot;)，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505222014808-1313269583.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哪一方写mappedBy哪一方就不在关心创建中间表了，即让另外一方不在关心创建中间表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 用户实体类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.annotations.GenericGenerator;

@Entity
@Table(name&lt;/span&gt;=&quot;sys_user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SysUser &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    @Id
    @Column(name&lt;/span&gt;=&quot;user_id&quot;&lt;span&gt;)
    @GenericGenerator(name&lt;/span&gt;=&quot;uuid&quot;,strategy=&quot;uuid&quot;&lt;span&gt;)
    @GeneratedValue(generator&lt;/span&gt;=&quot;uuid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userId;
    
    @Column(name&lt;/span&gt;=&quot;user_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
    
    @Column(name&lt;/span&gt;=&quot;user_password&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userPassword;
    
    @Column(name&lt;/span&gt;=&quot;user_state&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer userState;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多对多关系映射：&lt;/span&gt;
    @ManyToMany(mappedBy=&quot;users&quot;,cascade=&lt;span&gt;CascadeType.ALL)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;SysRole&amp;gt; roles=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;SysRole&amp;gt;(0&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;SysRole&amp;gt;&lt;span&gt; getRoles() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roles;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRoles(Set&amp;lt;SysRole&amp;gt;&lt;span&gt; roles) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roles =&lt;span&gt; roles;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserId(String userId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userId =&lt;span&gt; userId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserName(String userName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userPassword;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserPassword(String userPassword) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userPassword =&lt;span&gt; userPassword;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getUserState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userState;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserState(Integer userState) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userState =&lt;span&gt; userState;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SysUser [userId=&quot; + userId + &quot;, userName=&quot; + userName + &quot;, userPassword=&quot; +&lt;span&gt; userPassword
                &lt;/span&gt;+ &quot;, userState=&quot; + userState + &quot;]&quot;&lt;span&gt;;
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;角色实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 角色的实体类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinTable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.annotations.GenericGenerator;

@Entity
@Table(name&lt;/span&gt;=&quot;sys_role&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SysRole &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    @Id
    @Column(name&lt;/span&gt;=&quot;role_id&quot;&lt;span&gt;)
    @GenericGenerator(name&lt;/span&gt;=&quot;uuid&quot;,strategy=&quot;uuid&quot;)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个主键生成器,name：给生成器起名;strategy:指定的是hibernate中包含的生成策略&lt;/span&gt;
    @GeneratedValue(generator=&quot;uuid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleId;
    
    @Column(name&lt;/span&gt;=&quot;role_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleName;
    
    @Column(name&lt;/span&gt;=&quot;role_memo&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleMemo;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多对多关系映射：一个角色可以赋予多个用户&lt;/span&gt;
    @ManyToMany(cascade=&lt;span&gt;CascadeType.ALL)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入一张表&lt;/span&gt;
    @JoinTable(name=&quot;user_role_ref&quot;,joinColumns={@JoinColumn(name=&quot;role_id&quot;,referencedColumnName=&quot;role_id&quot;)},    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写的是当前实体在中间表的外键字段&lt;/span&gt;
                inverseJoinColumns={@JoinColumn(name=&quot;user_id&quot;,referencedColumnName=&quot;user_id&quot;)}        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写的是对方实体在中间表的外键字段&lt;/span&gt;
&lt;span&gt;                )
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;SysUser&amp;gt; users=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;SysUser&amp;gt;(0&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;SysUser&amp;gt;&lt;span&gt; getUsers() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; users;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUsers(Set&amp;lt;SysUser&amp;gt;&lt;span&gt; users) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.users =&lt;span&gt; users;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRoleId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roleId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRoleId(String roleId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roleId =&lt;span&gt; roleId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRoleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roleName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRoleName(String roleName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roleName =&lt;span&gt; roleName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRoleMemo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roleMemo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRoleMemo(String roleMemo) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roleMemo =&lt;span&gt; roleMemo;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SysRole [roleId=&quot; + roleId + &quot;, roleName=&quot; + roleName + &quot;, roleMemo=&quot; + roleMemo + &quot;]&quot;&lt;span&gt;;
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 多对多关联关系的相关操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2.1 一般保存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存操作
     *         创建2个用户，3个角色
     *         让1号用户具备1、2号角色    
     *         让2号用户具备2、3号角色
     *         保存用户和角色
     * 正常保存        
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        SysUser u1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        SysUser u2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        u1.setUserName(&lt;/span&gt;&quot;JPA u1&quot;&lt;span&gt;);
        u2.setUserName(&lt;/span&gt;&quot;JPA u2&quot;&lt;span&gt;);
        SysRole r1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r3&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        r1.setRoleName(&lt;/span&gt;&quot;JPA r1&quot;&lt;span&gt;);
        r2.setRoleName(&lt;/span&gt;&quot;JPA r2&quot;&lt;span&gt;);
        r3.setRoleName(&lt;/span&gt;&quot;JPA r3&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立用户和角色的关联关系&lt;/span&gt;
&lt;span&gt;        u1.getRoles().add(r1);
        u1.getRoles().add(r2);
        u2.getRoles().add(r2);
        u2.getRoles().add(r3);
        
        r1.getUsers().add(u1);
        r2.getUsers().add(u2);
        r2.getUsers().add(u1);
        r3.getUsers().add(u2);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        
        em.persist(u1);
        em.persist(u2);
        em.persist(r1);
        em.persist(r2);
        em.persist(r3);
        tx.commit();
        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2.2 级联保存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　级联操作是指&lt;span&gt;当主控方执行保存、更新或者删除操作时，其关联对象(被控方)也执行相同的操作&lt;/span&gt;。在映射文件中通过对 cascade属性的设置来控制是否对关联对象采用级联操作，级联操作对各种关联关系都是有效的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在JPA的多对多关联关系中中只需设置一方的级联保存属性即可，本文中以用户为例，实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505215544868-1348436485.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编写测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;级联保存&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        SysUser u1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        SysUser u2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        u1.setUserName(&lt;/span&gt;&quot;JPA u1&quot;&lt;span&gt;);
        u2.setUserName(&lt;/span&gt;&quot;JPA u2&quot;&lt;span&gt;);
        SysRole r1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r3&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        r1.setRoleName(&lt;/span&gt;&quot;JPA r1&quot;&lt;span&gt;);
        r2.setRoleName(&lt;/span&gt;&quot;JPA r2&quot;&lt;span&gt;);
        r3.setRoleName(&lt;/span&gt;&quot;JPA r3&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立用户和角色的关联关系&lt;/span&gt;
&lt;span&gt;        u1.getRoles().add(r1);
        u1.getRoles().add(r2);
        u2.getRoles().add(r2);
        u2.getRoles().add(r3);
        
        r1.getUsers().add(u1);
        r2.getUsers().add(u2);
        r2.getUsers().add(u1);
        r3.getUsers().add(u2);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        
        em.persist(u1);
        tx.commit();
        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 5.2.3 删除操作（禁用级联删除）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除操作
     *         双向级联删除：不管是在JPA还是hibernate，多对多中都禁止使用 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        SysUser user&lt;/span&gt;=em.find(SysUser.&lt;span&gt;class&lt;/span&gt;, &quot;402881ea632f00cf01632f00e6550000&quot;&lt;span&gt;);
        em.remove(user);
        tx.commit();
        em.close();    
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、JPA的c3p0连接池操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先需要导入c3p0的JAR包，而且要在配置文件里面协商c3p0的供应商，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505223411806-1763069432.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要从JPA中得到Session对象的话，需要对EntityManager进行unwrap()操作（解包装），就可以得到Session对象，而且用doWork()方法可以得到Connection对象，可以对它进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 验证c3p0是否连接成功
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取JPA中的操作对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取session&lt;/span&gt;
        Session session=em.unwrap(Session.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行session的doWork方法&lt;/span&gt;
        session.doWork(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Work() {
            
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute(Connection conn) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;                System.out.println(conn.getClass().getName());
            }
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、JPA中的单线程使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;手动编写代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.utils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManagerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Persistence;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * JPA的工具类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JPAUtil {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于SessionFactory&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManagerFactory factory;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt; tl;
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        factory&lt;/span&gt;=Persistence.createEntityManagerFactory(&quot;myJPAUnit&quot;&lt;span&gt;);
        tl&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取EntityManager对象
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManager createEntityManager(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从当前线程上获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;tl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(em==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            em&lt;/span&gt;=&lt;span&gt;factory.createEntityManager();
            tl.set(em);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tl.get();        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[]args){
        createEntityManager();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        EntityManager em1&lt;/span&gt;=&lt;span&gt;JPAUtil.createEntityManager();
        EntityManager em2&lt;/span&gt;=&lt;span&gt;JPAUtil.createEntityManager();
        System.out.println(em1&lt;/span&gt;==&lt;span&gt;em2);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;八、在JPA中用Hibernate的方式进行CRUD操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　配置文件的写法和实体类的创建和普通的JPA是一样的，可以参考第三部分的入门案例，此处演示也仅作单表演示，夺标操作类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.1 保存操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        Customer c&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        c.setCust_name(&lt;/span&gt;&quot;Kevin&quot;&lt;span&gt;);
        
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        s.save(c);
        tx.commit();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.2 查询操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询一个客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        System.out.println(c);
        tx.commit();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.3 更新操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修改一个客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        c.setCust_source(&lt;/span&gt;&quot;China&quot;&lt;span&gt;);
        s.update(c);
        tx.commit();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        c.setCust_source(&lt;/span&gt;&quot;America&quot;&lt;span&gt;);
        tx.commit();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;快照机制自动更新&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.4 删除操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除操作&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 2l&lt;span&gt;);
        s.delete(c);
        tx.commit();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;快照机制自动更新&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 05 May 2018 14:28:00 +0000</pubDate>
<dc:creator>Kevin.ZhangCG</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kevin-ZhangCG/p/8996491.html</dc:identifier>
</item>
<item>
<title>17.QT-事件处理分析、事件过滤器、拖放事件 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8996425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8996425.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Qt事件处理介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Qt平台会将系统产生的消息转换为&lt;span&gt;&lt;strong&gt;Qt事件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Qt事件是一个&lt;span&gt;&lt;strong&gt;QEvent的对象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Qt事件用来描述程序内部或外部发生的动作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任意的QObject对象都&lt;span&gt;&lt;strong&gt;具备事件处理&lt;/strong&gt;&lt;/span&gt;的能力&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Qt常见的事件继承图如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505214521401-207229066.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QInputEvent:&lt;/strong&gt;&lt;/span&gt;用户输入事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QDropEvent:&lt;/strong&gt;&lt;/span&gt;用户拖放事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QPaintEvent:&lt;/strong&gt;&lt;/span&gt;描述操作系统绘制GUI动作的事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QCloseEvent:&lt;/strong&gt;&lt;/span&gt;用户关闭窗口事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QTimerEvent:&lt;/strong&gt;&lt;/span&gt;计时器事件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;事件处理方式顺序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Qt事件产生后立即被&lt;strong&gt;&lt;span&gt;分发到QWidget对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.QWidget中的&lt;span&gt;&lt;strong&gt;event(QEvent*)&lt;/strong&gt;&lt;/span&gt;进行事件处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.event()根据事件类型&lt;span&gt;&lt;strong&gt;调用不同的事件处理函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.在事件处理函数中&lt;span&gt;&lt;strong&gt;发送&lt;/strong&gt;&lt;strong&gt;Qt&lt;/strong&gt;&lt;strong&gt;中预定义的信号&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.&lt;span&gt;&lt;strong&gt;调用信号关联的槽函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;以按钮点击为例,如下图所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505214531347-1037688900.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;QPushButton&lt;/strong&gt;&lt;strong&gt;事件处理总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.当点击按钮后,将会触发&lt;span&gt;&lt;strong&gt;鼠标事件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.调用&lt;span&gt;&lt;strong&gt;event(QEvent*)&lt;/strong&gt;&lt;/span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.调用&lt;span&gt;&lt;strong&gt;mouseReleaseEvent(QMouseEvent*)&lt;/strong&gt;&lt;/span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.调用&lt;span&gt;&lt;strong&gt;click()&lt;/strong&gt;&lt;/span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.触发信号&lt;span&gt;&lt;strong&gt;SIGNAL(clicked())&lt;/strong&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同样,当用户点击窗口的关闭按钮时,也会触发closeEvent()事件函数,该函数需要重写,才能实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考示例:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; void&lt;/span&gt; MainWindow::closeEvent(QCloseEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
{
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maybeSave())                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果还有需要保存的数据&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    {
         writeSettings();
         &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;accept();
    } &lt;br/&gt;&lt;/span&gt;&lt;span&gt;     else&lt;/span&gt;                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消关闭窗口&lt;/span&gt;
    {
         &lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;ignore();
    }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类似的还有keyEvent()获取键盘事件函数, keyReleaseEvent()键盘按下事件函数,&lt;/span&gt;&lt;span&gt;enterEvent光标进入组件事件函数, leaveEvent光标离开组件事件函数等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其中QCloseEvent继承与QEvent,在QEvent中常用成员函数有&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;  accept ();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收者处理当前事件&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt;  ignore ();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收者忽略当前事件,忽略后,事件可能传递给父组件&lt;/span&gt;

&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isAccepted();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前事件是否被处理过 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;当使用ignore()&lt;/strong&gt;&lt;strong&gt;处理事件时,&lt;/strong&gt;&lt;strong&gt;该事件可能会传递给其父组件对象继续处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;写两个类: &lt;span&gt;&lt;strong&gt;QMyWidget、QMyLineEdit&lt;/strong&gt;&lt;/span&gt;(QMyLineEdit是QMyWidget的类成员)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过QMyLineEdit来重写LineEdit的&lt;span&gt;&lt;strong&gt;keyReleaseEvent()&lt;/strong&gt;&lt;/span&gt;键盘按下事件函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过QMyWidget来重写QWidget的&lt;span&gt;&lt;strong&gt;keyReleaseEvent()&lt;/strong&gt;&lt;/span&gt;键盘按下事件函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后通过&lt;span&gt;&lt;strong&gt;ignore()&lt;/strong&gt;&lt;/span&gt;处理QMyLineEdit的keyReleaseEvent()事件函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;判断&lt;/strong&gt;&lt;/span&gt;是否会继续执行QMyWidget父组件的keyReleaseEvent()事件函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QLineEdit.h如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef QMYLINEEDIT_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; QMYLINEEDIT_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QLineEdit&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QtGui&amp;gt;

&lt;span&gt;class&lt;/span&gt; QMyLineEdit : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QLineEdit
{
    Q_OBJECT

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; QMyLineEdit(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;  keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; );
};&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; QMYLINEEDIT_H&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QLineEdit.cpp如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyLineEdit.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

QMyLineEdit::QMyLineEdit(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QLineEdit(parent)
{&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;  QMyLineEdit::keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; )
{
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyLineEdit::keyReleaseEvent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key value:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;key();      
    &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;ignore();                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略当前事件&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QMyWidget.h如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef QMYWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; QMYWIDGET_H&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyLineEdit.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;

&lt;span&gt;class&lt;/span&gt; QMyWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT
    QMyLineEdit line;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; QMyWidget(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;   keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; );

};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; QMYWIDGET_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QMyWidget.cpp如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyWidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

QMyWidget::QMyWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QWidget(parent),
    line(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
{
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;  QMyWidget::keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; )
{
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyWidget::keyReleaseEvent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key value:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;key();

    QWidget::keyPressEvent(&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;main()函数如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
        QApplication a(argc, argv);

        QMyWidget w;

        w.show();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;效果如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505215346821-1769428314.gif&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;496&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到成员调用了&lt;span&gt;&lt;strong&gt;event-&amp;gt;ignore()函数&lt;/strong&gt;&lt;/span&gt;忽略事件后,同样也会继续进入&lt;span&gt;&lt;strong&gt;QMyWidget类&lt;/strong&gt;&lt;/span&gt;处理事件 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Qt&lt;/strong&gt;&lt;strong&gt;中的事件过滤器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;事件过滤器可以对需要的组件接收到的事件进行过滤,以及监控&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任意的&lt;span&gt;&lt;strong&gt;QObject对象&lt;/strong&gt;&lt;/span&gt;都可以作为事件过滤器使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;事件过滤器的实现,需要重写&lt;span&gt;&lt;strong&gt;eventFilter()&lt;/strong&gt;&lt;/span&gt;函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组件要想被监控,则需要通过&lt;span&gt;&lt;strong&gt;installEventFilter()&lt;/strong&gt;&lt;/span&gt;安装事件过滤器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;事件过滤器能够决定是否将事件转发给组件对象,如下图所示:&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505215831990-1458432516.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;230&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;eventFilter函数体如下所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; QObject::eventFilter ( QObject * watched, QEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; );
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; watched:代表被监控的组件  event:代表要转发的事件
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回true,表示该事件也被过滤掉(处理),无需再转发了
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回false,则正常转发给watched&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考示例-&lt;/strong&gt;&lt;strong&gt;实现文本框只允许输入数字:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MainWindow : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QMainWindow
 {
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
     MainWindow();

 &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
     &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; eventFilter(QObject *obj, QEvent *&lt;span&gt;ev);

 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
     QTextEdit &lt;/span&gt;*&lt;span&gt;textEdit;
 };
&lt;br/&gt;MainWindow::MainWindow()
 {
     textEdit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTextEdit;
     setCentralWidget(textEdit);
     textEdit&lt;/span&gt;-&amp;gt;setAttribute(Qt::WA_InputMethodEnabled, &lt;span&gt;false&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁止中文输入法&lt;/span&gt;&lt;span&gt;
     textEdit&lt;/span&gt;-&amp;gt;installEventFilter(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
 }

 &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; MainWindow::eventFilter(QObject *obj, QEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
 {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj ==&lt;span&gt; textEdit)
     {
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;-&amp;gt;type() ==&lt;span&gt; QEvent::KeyPress)
         {
             QKeyEvent &lt;/span&gt;*keyEvent = static_cast&amp;lt;QKeyEvent*&amp;gt;(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
             qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ate key press&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; keyEvent-&amp;gt;&lt;span&gt;key();
             &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(keyEvent-&amp;gt;key())         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只接受0~9数字&lt;/span&gt;&lt;span&gt;
             {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_0:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_1:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_2:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_3:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_4:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_5:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_6:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_7:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_8:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_9:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
         }
         &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
         {
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
         }
     }
     &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
     {
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; QMainWindow::eventFilter(obj, &lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户拖放事件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个QWidget对象都能处理拖放事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用的拖放事件相关函数有:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;  dragEnterEvent ( QDragEnterEvent * &lt;span&gt;event&lt;/span&gt; );  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拖事件处理函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; dropEvent ( QDropEvent * &lt;span&gt;event&lt;/span&gt; ) ;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;放事件处理函数&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;拖放事件所处理的数据是QMimeData类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MIME类型常用处理函数如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505220107600-1129683195.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;拖放事件的步骤如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;在构造函数里通过&lt;span&gt;setAcceptDrops(true)&lt;/span&gt;函数,让该组件能接受拖放事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;重写&lt;span&gt;dragEnterEvent(&lt;a href=&quot;file:///G:/QT/笔记/qdragenterevent.html&quot;&gt;&lt;span&gt;QDragEnterEvent&lt;/span&gt;&lt;/a&gt;* event)&lt;/span&gt;函数并判断MIME类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  如果是期待的类型,则调用event -&amp;gt;acceptProposedAction();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  否则调用 : event -&amp;gt;ignore();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;重写&lt;span&gt;dropEvent()&lt;/span&gt;函数并判断MIME类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  如果是期待的类型,则获取MIME数据并处理.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  否则调用 : event -&amp;gt;ignore();&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; class&lt;/span&gt; MainWindow : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QMainWindow
 {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    QTextEdit &lt;/span&gt;*&lt;span&gt;textEdit;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dragEnterEvent(QDragEnterEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dropEvent(QDropEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MainWindow();
 };

 MainWindow::MainWindow()
 {
     textEdit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTextEdit;
     setCentralWidget(textEdit);
     textEdit&lt;/span&gt;-&amp;gt;setAttribute(Qt::WA_InputMethodEnabled, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) ;
     textEdit&lt;/span&gt;-&amp;gt;installEventFilter(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;setAcceptDrops(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
 }

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MainWindow::dragEnterEvent(QDragEnterEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
{
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;-&amp;gt;mimeData()-&amp;gt;hasUrls())      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断拖的类型&lt;/span&gt;&lt;span&gt;
      {
            &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;acceptProposedAction();
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
      {
            &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;ignore();
      }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MainWindow::dropEvent(QDropEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;-&amp;gt;mimeData()-&amp;gt;hasUrls())        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断放的类型&lt;/span&gt;&lt;span&gt;
    {
        textEdit&lt;/span&gt;-&amp;gt;&lt;span&gt;clear();
        QList&lt;/span&gt;&amp;lt;QUrl&amp;gt; List = &lt;span&gt;event&lt;/span&gt;-&amp;gt;mimeData()-&amp;gt;&lt;span&gt;urls();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;List.length();i++&lt;span&gt;)
        {
            textEdit&lt;/span&gt;-&amp;gt;insertPlainText(List[i].toLocalFile()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
          &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;ignore();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;效果:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505220234348-947825655.gif&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;615&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 14:12:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8996425.html</dc:identifier>
</item>
<item>
<title>线程池你真不来了解一下吗？ - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8996365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8996365.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回顾前面：&lt;/p&gt;
&lt;p&gt;本篇主要是讲解线程池，这是我在多线程的倒数第二篇了，&lt;strong&gt;后面还会有一篇死锁&lt;/strong&gt;。主要将多线程的基础&lt;strong&gt;过一遍&lt;/strong&gt;，以后&lt;strong&gt;有机会再继续深入&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;那么接下来就开始吧，如果文章有错误的地方请大家多多包涵，不吝在评论区指正哦~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;声明：本文使用JDK1.8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;线程池可以看做是&lt;strong&gt;线程的集合&lt;/strong&gt;。在没有任务时线程处于空闲状态，当请求到来：线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务&lt;strong&gt;(而不是销毁)&lt;/strong&gt;。这样就&lt;strong&gt;实现了线程的重用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们来看看&lt;strong&gt;如果没有使用线程池&lt;/strong&gt;的情况是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;为每个请求都新开一个线程&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ThreadPerTaskWebServer {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        ServerSocket socket = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ServerSocket(&lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 为每个请求都创建一个新的线程&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Socket connection = socket.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;();
            Runnable task = () -&amp;gt; &lt;span class=&quot;fu&quot;&gt;handleRequest&lt;/span&gt;(connection);
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(task).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        }
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;handleRequest&lt;/span&gt;(Socket connection) {
        &lt;span class=&quot;co&quot;&gt;// request-handling logic here&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为每个请求都开一个新的线程虽然&lt;strong&gt;理论上是可以&lt;/strong&gt;的，但是会有&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线程生命周期的开销非常高&lt;/strong&gt;。每个线程都有自己的生命周期，&lt;strong&gt;创建和销毁线程&lt;/strong&gt;所花费的时间和资源可能比处理客户端的任务花费的时间和资源更多，并且还会有某些&lt;strong&gt;空闲线程也会占用资源&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;程序的稳定性和健壮性会下降，每个请求开一个线程。如果受到了恶意攻击或者请求过多(内存不足)，程序很容易就奔溃掉了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以说：我们的&lt;strong&gt;线程最好是交由线程池来管理&lt;/strong&gt;，这样可以减少对线程生命周期的管理，一定程度上提高性能。&lt;/p&gt;

&lt;p&gt;JDK给我们提供了&lt;strong&gt;Excutor框架&lt;/strong&gt;来使用线程池，它是&lt;strong&gt;线程池的基础&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Executor提供了一种将&lt;strong&gt;“任务提交”与“任务执行”&lt;/strong&gt;分离开来的机制(解耦)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来看看JDK线程池的总体api架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330918d3dbf6ad?w=1003&amp;amp;h=708&amp;amp;f=png&amp;amp;s=18678&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们把这些API都过一遍看看：&lt;/p&gt;
&lt;p&gt;Executor接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330918d5167cf2?w=1211&amp;amp;h=475&amp;amp;f=png&amp;amp;s=18061&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ExcutorService接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330918d3fb596e?w=1680&amp;amp;h=681&amp;amp;f=png&amp;amp;s=59550&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AbstractExecutorService类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330918d52464ff?w=1799&amp;amp;h=708&amp;amp;f=png&amp;amp;s=54483&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ScheduledExecutorService接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330918dedf5285?w=1599&amp;amp;h=592&amp;amp;f=png&amp;amp;s=42304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ThreadPoolExecutor类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330918d5783349?w=1657&amp;amp;h=782&amp;amp;f=png&amp;amp;s=73397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ScheduledThreadPoolExecutor类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091998cee0e2?w=1702&amp;amp;h=730&amp;amp;f=png&amp;amp;s=63207&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;forkjoinpool线程池&quot;&gt;2.1ForkJoinPool线程池&lt;/h2&gt;
&lt;p&gt;除了ScheduledThreadPoolExecutor和ThreadPoolExecutor类线程池以外，还有一个是&lt;strong&gt;JDK1.7新增&lt;/strong&gt;的线程池：ForkJoinPool线程池&lt;/p&gt;
&lt;p&gt;于是我们的类图就可以变得完整一些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091998bf88ce?w=800&amp;amp;h=596&amp;amp;f=png&amp;amp;s=14246&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;JDK1.7中新增的一个线程池，与ThreadPoolExecutor一样，同样继承了AbstractExecutorService。ForkJoinPool是Fork/Join框架的两大核心类之一。与其它类型的ExecutorService相比，&lt;strong&gt;其主要的不同在于采用了工作窃取算法(work-stealing)&lt;/strong&gt;：所有池中线程会尝试找到并执行已被提交到池中的或由其他线程创建的任务。这样很少有线程会处于空闲状态，非常高效。这使得能够有效地处理以下情景：&lt;strong&gt;大多数由任务产生大量子任务的情况&lt;/strong&gt;；从外部客户端大量提交小任务到池中的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来源：&lt;/p&gt;
&lt;h2 id=&quot;补充callable和future&quot;&gt;2.2补充：Callable和Future&lt;/h2&gt;
&lt;p&gt;学到了线程池，我们可以很容易地发现：很多的API都有Callable和Future这么两个东西。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    Future&amp;lt;?&amp;gt; &lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(Runnable task)
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实它们也不是什么高深的东西~~~&lt;/p&gt;
&lt;p&gt;我们可以简单认为：&lt;strong&gt;Callable就是Runnable的扩展&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Runnable没有返回值，不能抛出受检查的异常，而Callable可以&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330919e74eb356?w=975&amp;amp;h=331&amp;amp;f=png&amp;amp;s=8889&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说：当我们的&lt;strong&gt;任务需要返回值&lt;/strong&gt;的时，我们就可以使用Callable！&lt;/p&gt;
&lt;p&gt;Future一般我们认为是Callable的返回值，但他其实代表的是&lt;strong&gt;任务的生命周期&lt;/strong&gt;(当然了，它是能获取得到Callable的返回值的)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330919a84c2a25?w=1189&amp;amp;h=353&amp;amp;f=png&amp;amp;s=24749&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来看一下他们的用法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CallableDemo {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException {
        &lt;span class=&quot;co&quot;&gt;// 创建线程池对象&lt;/span&gt;
        ExecutorService pool = Executors.&lt;span class=&quot;fu&quot;&gt;newFixedThreadPool&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;// 可以执行Runnable对象或者Callable对象代表的线程&lt;/span&gt;
        Future&amp;lt;Integer&amp;gt; f1 = pool.&lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyCallable&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;));
        Future&amp;lt;Integer&amp;gt; f2 = pool.&lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyCallable&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;));

        &lt;span class=&quot;co&quot;&gt;// V get()&lt;/span&gt;
        Integer i1 = f1.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
        Integer i2 = f2.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();

        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(i1);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(i2);

        &lt;span class=&quot;co&quot;&gt;// 结束&lt;/span&gt;
        pool.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Callable任务：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyCallable &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Callable&amp;lt;Integer&amp;gt; {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; number;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyCallable&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; number) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;number&lt;/span&gt; = number;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;fu&quot;&gt;call&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sum = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; x &amp;lt;= number; x++) {
            sum += x;
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sum;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完任务之后可以&lt;strong&gt;获取得到任务返回的数据&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330919b373dd8a?w=732&amp;amp;h=215&amp;amp;f=png&amp;amp;s=4870&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是用得最多的线程池，所以本文会重点讲解它。&lt;/p&gt;
&lt;p&gt;我们来看看顶部注释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/16330919d52fa1f8?w=1533&amp;amp;h=4685&amp;amp;f=jpeg&amp;amp;s=927724&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;内部状态&quot;&gt;3.1内部状态&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091a7df162af?w=1119&amp;amp;h=191&amp;amp;f=png&amp;amp;s=8360&quot;/&gt;&lt;/p&gt;
&lt;p&gt;变量ctl定义为AtomicInteger，&lt;strong&gt;记录了“线程池中的任务数量”和“线程池的状态”两个信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091a51628023?w=1097&amp;amp;h=724&amp;amp;f=png&amp;amp;s=29373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程的状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RUNNING：线程池&lt;strong&gt;能够接受新任务&lt;/strong&gt;，以及对新添加的任务进行处理。&lt;/li&gt;
&lt;li&gt;SHUTDOWN：线程池&lt;strong&gt;不可以接受新任务&lt;/strong&gt;，但是可以对已添加的任务进行处理。&lt;/li&gt;
&lt;li&gt;STOP：线程池&lt;strong&gt;不接收新任务，不处理已添加的任务，并且会中断正在处理的任务&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;TIDYING：当&lt;strong&gt;所有的任务已终止&lt;/strong&gt;，ctl记录的&quot;任务数量&quot;为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。&lt;/li&gt;
&lt;li&gt;TERMINATED：线程池&lt;strong&gt;彻底终止的状态&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091a841450d9?w=1064&amp;amp;h=372&amp;amp;f=png&amp;amp;s=17003&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各个状态之间转换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091adfc9d89e?w=922&amp;amp;h=348&amp;amp;f=png&amp;amp;s=37225&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;已默认实现的池&quot;&gt;3.2已默认实现的池&lt;/h2&gt;
&lt;p&gt;下面我就列举三个比较&lt;strong&gt;常见&lt;/strong&gt;的实现池：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;newFixedThreadPool&lt;/li&gt;
&lt;li&gt;newCachedThreadPool&lt;/li&gt;
&lt;li&gt;SingleThreadExecutor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果读懂了上面对应的策略呀，线程数量这些，应该就不会太难看懂了。&lt;/p&gt;
&lt;h3 id=&quot;newfixedthreadpool&quot;&gt;3.2.1newFixedThreadPool&lt;/h3&gt;
&lt;p&gt;一个固定线程数的线程池，它将返回一个&lt;strong&gt;corePoolSize和maximumPoolSize相等的线程池&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
   &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ExecutorService &lt;span class=&quot;fu&quot;&gt;newFixedThreadPool&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nThreads) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MILLISECONDS&lt;/span&gt;,
                                      &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;newcachedthreadpool&quot;&gt;3.2.2newCachedThreadPool&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;非常有弹性的线程池&lt;/strong&gt;，对于新的任务，如果此时线程池里没有空闲线程，&lt;strong&gt;线程池会毫不犹豫的创建一条新的线程去处理这个任务&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ExecutorService &lt;span class=&quot;fu&quot;&gt;newCachedThreadPool&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;,
                                      60L, TimeUnit.&lt;span class=&quot;fu&quot;&gt;SECONDS&lt;/span&gt;,
                                      &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;singlethreadexecutor&quot;&gt;3.2.3SingleThreadExecutor&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用单个worker线程的Executor&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ExecutorService &lt;span class=&quot;fu&quot;&gt;newSingleThreadExecutor&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FinalizableDelegatedExecutorService
            (&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,
                                    0L, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MILLISECONDS&lt;/span&gt;,
                                    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;构造方法&quot;&gt;3.3构造方法&lt;/h2&gt;
&lt;p&gt;我们读完上面的默认实现池还有对应的属性，再回到构造方法看看&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造方法可以让我们&lt;strong&gt;自定义(扩展)线程池&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; corePoolSize,
                              &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; maximumPoolSize,
                              &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (corePoolSize &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ||
            maximumPoolSize &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ||
            maximumPoolSize &amp;lt; corePoolSize ||
            keepAliveTime &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (workQueue == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || threadFactory == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || handler == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException();
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;corePoolSize&lt;/span&gt; = corePoolSize;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;maximumPoolSize&lt;/span&gt; = maximumPoolSize;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;workQueue&lt;/span&gt; = workQueue;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;keepAliveTime&lt;/span&gt; = unit.&lt;span class=&quot;fu&quot;&gt;toNanos&lt;/span&gt;(keepAliveTime);
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;threadFactory&lt;/span&gt; = threadFactory;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt; = handler;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;指定核心线程数量&lt;/li&gt;
&lt;li&gt;指定最大线程数量&lt;/li&gt;
&lt;li&gt;允许线程空闲时间&lt;/li&gt;
&lt;li&gt;时间对象&lt;/li&gt;
&lt;li&gt;阻塞队列&lt;/li&gt;
&lt;li&gt;线程工厂&lt;/li&gt;
&lt;li&gt;任务拒绝策略&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再总结一遍这些参数的要点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程数量要点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果运行线程的数量&lt;strong&gt;少于&lt;/strong&gt;核心线程数量，则&lt;strong&gt;创建新&lt;/strong&gt;的线程处理请求&lt;/li&gt;
&lt;li&gt;如果运行线程的数量&lt;strong&gt;大于&lt;/strong&gt;核心线程数量，&lt;strong&gt;小于&lt;/strong&gt;最大线程数量，则当&lt;strong&gt;队列满的时候才创建新&lt;/strong&gt;的线程&lt;/li&gt;
&lt;li&gt;如果核心线程数量&lt;strong&gt;等于&lt;/strong&gt;最大线程数量，那么将&lt;strong&gt;创建固定大小&lt;/strong&gt;的连接池&lt;/li&gt;
&lt;li&gt;如果设置了最大线程数量为&lt;strong&gt;无穷&lt;/strong&gt;，那么允许线程池适合&lt;strong&gt;任意&lt;/strong&gt;的并发数量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;线程空闲时间要点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前线程数&lt;strong&gt;大于&lt;/strong&gt;核心线程数，如果空闲时间已经超过了，那该线程会&lt;strong&gt;销毁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;排队策略要点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步移交：&lt;strong&gt;不会放到队列中，而是等待线程执行它&lt;/strong&gt;。如果当前线程没有执行，很可能会&lt;strong&gt;新开&lt;/strong&gt;一个线程执行。&lt;/li&gt;
&lt;li&gt;无界限策略：&lt;strong&gt;如果核心线程都在工作，该线程会放到队列中&lt;/strong&gt;。所以线程数不会超过核心线程数&lt;/li&gt;
&lt;li&gt;有界限策略：&lt;strong&gt;可以避免资源耗尽&lt;/strong&gt;，但是一定程度上减低了吞吐量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当线程关闭或者线程数量满了和队列饱和了，就有拒绝任务的情况了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拒绝任务策略：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接抛出异常&lt;/li&gt;
&lt;li&gt;使用调用者的线程来处理&lt;/li&gt;
&lt;li&gt;直接丢掉这个任务&lt;/li&gt;
&lt;li&gt;丢掉最老的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;execute执行方法分了三步，以注释的方式写在代码上了~&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(Runnable command) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (command == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException();
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//如果线程池中运行的线程数量&amp;lt;corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(c) &amp;lt; corePoolSize) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(command, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;))
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
            c = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
        }

        &lt;span class=&quot;co&quot;&gt;//如果线程池中运行的线程数量&amp;gt;=corePoolSize，且线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中，就再次检查线程池的状态，&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 1.如果线程池不是RUNNING状态，且成功从阻塞队列中删除任务，则该任务由当前 RejectedExecutionHandler 处理。&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 2.否则如果线程池中运行的线程数量为0，则通过addWorker(null, false)尝试新建一个线程，新建线程对应的任务为null。&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRunning&lt;/span&gt;(c) &amp;amp;&amp;amp; workQueue.&lt;span class=&quot;fu&quot;&gt;offer&lt;/span&gt;(command)) {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; recheck = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (! &lt;span class=&quot;fu&quot;&gt;isRunning&lt;/span&gt;(recheck) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(command))
                &lt;span class=&quot;fu&quot;&gt;reject&lt;/span&gt;(command);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(recheck) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
        }
        &lt;span class=&quot;co&quot;&gt;// 如果以上两种case不成立，即没能将任务成功放入阻塞队列中，且addWoker新建线程失败，则该任务由当前 RejectedExecutionHandler 处理。&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(command, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;))
            &lt;span class=&quot;fu&quot;&gt;reject&lt;/span&gt;(command);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ThreadPoolExecutor提供了&lt;code&gt;shutdown()&lt;/code&gt;和&lt;code&gt;shutdownNow()&lt;/code&gt;两个方法来关闭线程池&lt;/p&gt;
&lt;p&gt;shutdown() ：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091b0763388d?w=1186&amp;amp;h=683&amp;amp;f=png&amp;amp;s=36457&quot;/&gt;&lt;/p&gt;
&lt;p&gt;shutdownNow():&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/5/1633091b0a764a07?w=1382&amp;amp;h=849&amp;amp;f=png&amp;amp;s=55052&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用shutdown()后，线程池状态立刻&lt;strong&gt;变为SHUTDOWN&lt;/strong&gt;，而调用shutdownNow()，线程池状态&lt;strong&gt;立刻变为STOP&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;shutdown()&lt;strong&gt;等待任务执行完&lt;/strong&gt;才中断线程，而shutdownNow()&lt;strong&gt;不等任务执行完&lt;/strong&gt;就中断了线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇博文主要简单地将多线程的结构体系过了一篇，讲了最常用的ThreadPoolExecutor线程池是怎么使用的~~~&lt;/p&gt;
&lt;p&gt;明天希望可以把死锁写出来，敬请期待~~~&lt;/p&gt;
&lt;p&gt;还有剩下的几个线程池(给出了参考资料)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ScheduledThreadPoolExecutor
&lt;/li&gt;
&lt;li&gt;ForkJoinPool
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;。为了大家方便，刚新建了一下&lt;strong&gt;qq群：742919422&lt;/strong&gt;，大家也可以去交流交流。谢谢支持了！希望能多介绍给其他有需要的朋友&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章的目录导航&lt;/strong&gt;：&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 13:58:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8996365.html</dc:identifier>
</item>
<item>
<title>Layx——网页弹窗最佳选择. - 百小僧</title>
<link>http://www.cnblogs.com/baisoft/p/8996356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baisoft/p/8996356.html</guid>
<description>
&lt;p&gt;开源地址：&lt;a href=&quot;https://gitee.com/monksoul/LayX&quot; target=&quot;_blank&quot;&gt;https://gitee.com/monksoul/LayX&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文档地址：&lt;a href=&quot;http://baisoft.gotoip11.com/layx/doc/&quot; target=&quot;_blank&quot;&gt;http://baisoft.gotoip11.com/layx/doc/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1006466/201805/1006466-20180505215331601-1239805278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;大家好，我叫百小僧，是一名C#开发工程师，同时也擅长多种程序语言。平时的工作都是开发企业管理系统（ERP、CRM）。目前企业管理系统更多都是C/S架构的，而且C/S架构多窗口处理数据更加灵活。刚好公司为了顺应潮流将现有的企业管理系统采用全新B/S架构全新开发，我们最初的想法是在B/S结构界面中采用类似浏览器多标签页模式进行设计，但是交给客户试用时大部分都否决了，这些客户一致认为客户端多窗口操作模式比较好。所以还得按照传统C/S模式进行开发。&lt;/p&gt;
&lt;p&gt;然而，目前网页弹窗使用最多的 layer插件没能满足我们的期望或者说没有达到C/S架构多窗口应有的水平。所以，本人利用五一放假期间亲自操刀。&lt;/p&gt;
&lt;p&gt;两天后，Layx诞生了...&lt;/p&gt;
&lt;p&gt;为什么起名叫 Layx 呢？其实很简单，层的英文是layer，但是目前已经有一个非常成熟的layer插件了，那我得起个牛逼的名字：LayerX——也就是比 layer 更加牛X的意思* ^ *。最后琢磨琢磨着发现名字还是有点长，也有点趁layer热度的赶脚，所以干脆去掉了er，直接叫 LayX.&lt;/p&gt;



&lt;p&gt;Layx 是一款纯原生Javascript编写的网页弹窗插件，完全模仿Windows 10操作系统窗口进行设计开发。&lt;/p&gt;
&lt;p&gt;目前Layx具备以下功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持文本窗口、页面窗口（iframe）&lt;/li&gt;
&lt;li&gt;支持最大化、最小化、恢复、关闭、置顶功能&lt;/li&gt;
&lt;li&gt;支持窗口拖动及四个方向拖动控制&lt;/li&gt;
&lt;li&gt;支持8个方向的窗口拖曳改变大小（上，右，下，左，左上，左下，右上，右下）&lt;/li&gt;
&lt;li&gt;窗口最小宽度、最大宽度控制&lt;/li&gt;
&lt;li&gt;窗口焦点激活控制&lt;/li&gt;
&lt;li&gt;支持窗口阴影控制&lt;/li&gt;
&lt;li&gt;窗口自动记录上次位置&lt;/li&gt;
&lt;li&gt;支持双击标题切换窗口&lt;/li&gt;
&lt;li&gt;支持拖曳窗口到顶部自动最大化、最大化拖曳自动恢复正常窗口&lt;/li&gt;
&lt;li&gt;支持MDI多级嵌套窗口&lt;/li&gt;
&lt;li&gt;支持窗口外观控制（背景颜色、透明度、边框颜色、状态栏等）&lt;/li&gt;
&lt;li&gt;支持窗口图标自定义、操作按钮自定义&lt;/li&gt;
&lt;li&gt;支持窗口之间相互通讯&lt;/li&gt;
&lt;li&gt;支持窗口操作监听（最小化监听、最大化监听、恢复监听、置顶监听、拖动监听、改变大小监听、加载监听等）&lt;/li&gt;
&lt;li&gt;支持窗口打开初始化位置控制（中间，左上、右上、左下、右下、自定义上边和左边）&lt;/li&gt;
&lt;li&gt;支持窗口阻隔、遮罩&lt;/li&gt;
&lt;li&gt;支持自动获取iframe页面标题填充窗口标题&lt;/li&gt;
&lt;li&gt;支持窗口状态拦截器，可以拦截窗口所有操作功能&lt;/li&gt;
&lt;li&gt;支持窗口加载提示控制&lt;/li&gt;
&lt;li&gt;兼容IE9+、Chrome、Edge、FF、Opera等现代主流浏览器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;未来拥有的功能远不止这些...&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;127&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// layx 默认配置参数

    var defaults = {
        id: 'layx', // 唯一id
        icon: '', // 图标，设置false不启用，这里支持html代码
        title: '', // 窗口标题
        bgColor: '#fff', // 背景颜色，iframe页面背景为透明有效
        borderColor: '#3baced', // 边框颜色
        opacity: 1, // 透明度
        type: 'iframe', // 窗口类型：支持iframe,alert,confirm,error,load,prompt
        url: '', // iframe类型地址，type=iframe 时有效
        content: '', // 非iframe类型内容，支持text,html
        width: 800, // 初始化宽度
        height: 600, // 初始化高度
        loaddingText: '内容加载中...', // 内容加载文本内容，支持html
        position: 'center', // 初始化位置，支持'center', 'lt', 'rt', 'lb', 'rb'以及 [top,left]数组
        useFrameTitle: false, // 是否自动获取iframe页面标题填充窗口标题
        minWidth: 150, // 拖曳大小最小宽度
        minHeight: 150, // 拖曳大小最大宽度
        shadable: false, // 是否启用窗口阻隔
        alwaysOnTop: false, // 是否总是置顶
        pinable: false, // 是否显示图钉按钮，当 alwaysOnTop为true的时候，pinable自动显示
        minimizable: true, // 是否允许最小化
        maximizable: true, // 是否允许最大化
        closable: true, // 是否允许关闭
        resizable: true, // 是否允许拖曳大小
        // 拖曳方向控制
        resizeLimit: {
            t: true, // 是否允许上边拖曳大小，true允许
            r: true, // 是否允许右边拖曳大小，true允许
            b: true, // 是否允许下边拖曳大小，true允许
            l: true, // 是否允许左边拖曳大小，true允许
            lt: true, // 是否允许左上边拖曳大小，true允许
            rt: true, // 是否允许右上边拖曳大小，true允许
            lb: true, // 是否允许左下边拖曳大小，true允许
            rb: true // 是否允许右下边拖曳大小，true允许
        },
        movable: true, // 是否允许拖动窗口
        // 拖动窗口显示，vertical为true表示禁止水平拖动，horizontal为true表示禁止垂直拖动
        moveLimit: {
            vertical: false, // 是否禁止垂直拖动，false不禁止
            horizontal: false, // 是否禁止水平拖动，false不禁止
            leftOut: true, // 是否允许左边拖出，true允许
            rightOut: true, // 是否允许右边拖出，true允许
            topOut: true, // 是否允许上边拖出，true允许，此设置不管是false还是true，窗口都不能拖出窗体
            bottomOut: true, // 是否允许下边拖出，true允许
        },
        statusBar: false, // 是否显示状态栏
        focusable: true, // 是否启用iframe页面点击置顶
        // scaleAnimatable: false, // 是否启用窗口缩放动画，开发中....
        allowTitleDblclickToRestore: true, // 是否允许标题双击恢复窗体
        // parent: null, // 父窗体id，设置此选项时，窗体将在窗体内部页面打开（MDI模式）并和父窗口共用同一个生命周期；注意：只支持非跨域页面。开发中...
        // menuItems: [], // 自定义顶部下拉菜单，支持无限极，开发中....
        // 拦截器，可以监听窗口各个状态
        intercept: {
            // iframe页面加载监听
            load: {
                // 加载之前，return false；禁止加载
                before: function(windowDom, winform) {},
                // 加载之后
                after: function(windowDom, winform, iframe) {}
            },
            // 最小化监听
            min: {
                // 最小化之前，return false；禁止最小化
                before: function(windowDom, winform) {},
                // 最小化之后
                after: function(windowDom, winform) {}
            },
            // 最大化监听
            max: {
                // 最大化之前，return false；禁止最大化
                before: function(windowDom, winform) {},
                // 最大化之后
                after: function(windowDom, winform) {}
            },
            // 恢复监听
            restore: {
                // 恢复之前，return false；禁止恢复
                before: function(windowDom, winform) {},
                // 恢复之后
                after: function(windowDom, winform) {}
            },
            // 关闭监听
            destroy: {
                // 关闭之前，return false；禁止关闭
                before: function(windowDom, winform) {},
                // 关闭之后
                after: function(windowDom, winform) {}
            },
            // 置顶监听
            pin: {
                // 置顶之前，return false；禁止操作
                before: function(windowDom, winform) {},
                // 置顶之后
                after: function(windowDom, winform) {}
            },
            // 移动窗口监听
            move: {
                // 移动之前
                before: function(windowDom, winform) {},
                // 移动中
                moveing: function(windowDom, winform) {},
                // 移动结束
                after: function(windowDom, winform) {}
            },
            // 拖曳窗口大小监听
            resize: {
                // 移动之前
                before: function(windowDom, winform) {},
                // 移动中
                resizing: function(windowDom, winform) {},
                // 移动结束
                after: function(windowDom, winform) {}
            }
        }
    };
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Sat, 05 May 2018 13:56:00 +0000</pubDate>
<dc:creator>百小僧</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baisoft/p/8996356.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构15（图01） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8992910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8992910.html</guid>
<description>&lt;p&gt;　　其实在上一篇介绍树结构的时候，已经有了一些算法的相关内容介入。而在图这种数据结构下，会有更多有关图的算法，比如广度优先搜索，深度优先搜索最短路径算法等等。这是我们要介绍的最后一个数据结构。同时也是本系列最为复杂的一个。那么我们先来简单介绍一下，什么是图？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、图的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　简单说，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)&quot; target=&quot;_blank&quot;&gt;图&lt;/a&gt;就是网络结构的抽象模型，图是一组由&lt;strong&gt;边&lt;/strong&gt;连接的&lt;strong&gt;节点&lt;/strong&gt;（或顶点）。任何二元关系都可以用图来表示。比如我们的地图，地铁线路图等。都是图的实际应用。&lt;/p&gt;
&lt;p&gt;　　接着我们看看图的一些相关概念和术语。&lt;/p&gt;
&lt;p&gt;　　一个图G = (V,E)由以下元素组成：&lt;/p&gt;
&lt;p&gt;　　　　V：一组顶点。&lt;/p&gt;
&lt;p&gt;　　　　E：一组边，链接V中的顶点。&lt;/p&gt;
&lt;p&gt;　　在继续之前我们先来上张图，继续我们的看图说话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180505121637509-223234369.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　请看上图，我们来解释一些概念。&lt;/p&gt;
&lt;p&gt;　　　　1、由一条边连接在一起的顶点称为&lt;strong&gt;相邻顶点。&lt;/strong&gt;比如上图中的A和B，A和C，A和D都是相邻的，但是A和E不是相邻的。&lt;/p&gt;
&lt;p&gt;　　　　2、一个顶点的&lt;strong&gt;度&lt;/strong&gt;取决于其相邻顶点的数量。也就是说，有多少个顶点与其相连，那么它的度就是多少。比如A的度是3，D的度就是4。&lt;/p&gt;
&lt;p&gt;　　　　3、&lt;strong&gt;路径&lt;/strong&gt;是顶点V1,V2.....Vn的一个连续序列，其中Vi和Vi+1是相邻的。比如上图中的ACDG，ABEI都是一个路径。&lt;/p&gt;
&lt;p&gt;　　　　4、&lt;strong&gt;简单路径&lt;/strong&gt;要求不包含重复的定点。比如ADG就是一条简单路径。&lt;/p&gt;
&lt;p&gt;　　　　5、除去最后一个顶点（因为它和第一个顶点时相同的），&lt;strong&gt;环&lt;/strong&gt;也是一个简单路径，比如ADCA。&lt;/p&gt;
&lt;p&gt;　　　　6、如果图中不存在环。则该图是&lt;strong&gt;无环&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;　　　　7、如果图中每两个顶点间都存在路径，则该图是&lt;strong&gt;连通&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;　　为了便于对比，我又花了一张图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180505183017819-1418118190.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;238&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　跟第一幅图几乎是一样的，只不过我们在路径上加了点东西。&lt;/p&gt;
&lt;p&gt;　　　　8、图可以是&lt;strong&gt;有向&lt;/strong&gt;的（边有方向）或者是&lt;strong&gt;无向&lt;/strong&gt;的（边没有方向）。比如上图我们在边上加了方向就变成了有向图。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　9、如果在图中的&lt;strong&gt;每&lt;/strong&gt;两个顶点间在双向上都存在路径，则该图是&lt;strong&gt;强连通的。&lt;/strong&gt;比如上图中我们可以说C和D是强连通的。A和B不是强连通的。但是上图并不是一个强连通图。因为上图并不是&lt;strong&gt;每&lt;/strong&gt;两个点都有双向的路径。&lt;/p&gt;
&lt;p&gt;　　　　10、图还可以是&lt;strong&gt;未加权的&lt;/strong&gt;或是&lt;strong&gt;加权的&lt;/strong&gt;。上图边上加的数字就是加权值。（加权的意思可以简单理解为CSS选择器中的那种权重。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、图的表示方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以表示图的方法有很多。根据我们要解决问题的类型和图的类型。我们可以选择不同的方法来表示图。下面我们会简单介绍两种表示图的方法。&lt;/p&gt;
&lt;p&gt;　　1、&lt;strong&gt;邻接矩阵。&lt;/strong&gt;每一个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示各个顶点之间的连接情况。比如索引为i的节点和索引为j的节点相邻，则表示为arrya[i][j]=1。否则arrya[i][j]=0。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180505202805333-886755040.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　邻接矩阵看起来就是这样子的。要注意我们上面的邻接矩阵只是表示两个顶点是否相邻。我们还需要一个数组来存储所有的顶点。&lt;/p&gt;
&lt;p&gt;　　但是邻接矩阵会有一些性能问题。比如我们会用很多的空间来表示一些根本就不存在的边。比如上图所有的0。再比如我们想要找到A顶点的相邻顶点，即使A顶点只有一个相邻顶点。我们也必须遍历整个数组才能找到。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、邻接表，&lt;/strong&gt;鉴于以上的问题。我们在本篇中所使用的图的表示方法就是邻接表。邻接表由图中每个顶点的相邻顶点列表所组成。我们可以用数组，链表，map或者hashMap来实现邻接表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180505203901430-2098520797.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　邻接表看起来就像是上图这样。&lt;/p&gt;
&lt;p&gt;　　那么我们知道了图的一些基本概念和我们要使用的图的表示方法。下面我们先来完成我们Graph类的架子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Map () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;......其他各种方法，详见前面的字典部分&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代码很简单，但是还是要解释一下。&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Graph() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vertices数组存放我们图中所有的顶点&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; vertices =&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;adjList存放我们的邻接表。adjList会使用顶点来作为键，邻接顶点列表作为值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; adjList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加顶点的方法。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.addVertices = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (v) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放到顶点数组中&lt;/span&gt;
&lt;span&gt;        vertices.push(v);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个还没有邻接顶点列表的Map，因为这时我们已经有顶点了，所以要生成以待使用&lt;/span&gt;
&lt;span&gt;        adjList.set(v,[]);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里有个小细节我们需要注意，哦对，这是为图添加边的方法。要注意的是，实际上，在代码中，我们是没有一个东西（变量或者其他什么）来代表边的。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们为两个顶点之间添加一个边实际上只是为两个顶点的邻接表中加入彼此。这样就代表了这两个顶点是相邻的。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.addEdge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (v,w) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;而这里我们所实现的图是无向图，所以需要给两个顶点所对应的邻接表加入彼此。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;而如果是有向图的话，只需要根据方向添加一个就可以了。&lt;/span&gt;
&lt;span&gt;        adjList.get(v).push(w);
        adjList.get(w).push(v);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了方便观察，我们再实现一个toString方法&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没啥好说的，双重循环遍历两个数组。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.toString = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = &quot;&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0;i &amp;lt; vertices.length;i++&lt;span&gt;) {
            s &lt;/span&gt;+= vertices[i] + &quot;-&amp;gt;&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; neighbors =&lt;span&gt; adjList.get(vertices[i]);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; neighbors.length; j++&lt;span&gt;) {
                s &lt;/span&gt;+= neighbors[j] + '  '&lt;span&gt;;
            }
            s &lt;/span&gt;+= '\n'&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们来试一下&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; graph = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Graph();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; verticesArray = ['A','B','C','D','E','F','G','H','I'&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; verticesArray.length; i++&lt;span&gt;) {
    graph.addVertices(verticesArray[i]);
}

graph.addEdge(&lt;/span&gt;'A','B'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'A','C'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'A','D'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'C','D'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'C','G'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'D','G'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'D','H'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'B','E'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'B','F'&lt;span&gt;);
graph.addEdge(&lt;/span&gt;'E','I'&lt;span&gt;);


console.log(graph.toString());
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
A-&amp;gt;B  C  D  
B-&amp;gt;A  E  F  
C-&amp;gt;A  D  G  
D-&amp;gt;A  C  G  H  
E-&amp;gt;B  I  
F-&amp;gt;B  
G-&amp;gt;C  D  
H-&amp;gt;D  
I-&amp;gt;E  
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么我们就实现了Graph类中最简单的部分——如何添加顶点和边。大家会不会觉得有点简单了。嘿嘿.....有趣的还在后面，别急......&lt;/p&gt;
&lt;p&gt;　　好了，那么到这里这篇文章就结束了。下一篇文章我们再继续学习图的遍历。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;　　&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 13:23:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8992910.html</dc:identifier>
</item>
<item>
<title>前端技术之_CSS详解第五天 - 我举个栗子</title>
<link>http://www.cnblogs.com/wanghui1234/p/8996047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghui1234/p/8996047.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.1 行高&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;CSS中，所有的行，都有行高。盒模型的padding，绝对不是直接作用在文字上的，而是作用在“行”上的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bc5c0585-fe24-438c-afcf-c58336d62990')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_bc5c0585-fe24-438c-afcf-c58336d62990&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bc5c0585-fe24-438c-afcf-c58336d62990&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bc5c0585-fe24-438c-afcf-c58336d62990',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bc5c0585-fe24-438c-afcf-c58336d62990&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt; xml:lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        *&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        p&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid black&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt; line-height: 40px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505204935890-76585500.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('763cd2ef-fd16-4b5f-bd49-a83763b6a3d2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_763cd2ef-fd16-4b5f-bd49-a83763b6a3d2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_763cd2ef-fd16-4b5f-bd49-a83763b6a3d2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('763cd2ef-fd16-4b5f-bd49-a83763b6a3d2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_763cd2ef-fd16-4b5f-bd49-a83763b6a3d2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        *&lt;/span&gt;{&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
        }&lt;span&gt;
        p&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid black&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
            line-height&lt;/span&gt;:&lt;span&gt; 25px&lt;/span&gt;;&lt;span&gt;
            font-size&lt;/span&gt;:&lt;span&gt; 14px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;国国国国国国国国国国国国国国国国国国国国国国国&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;文字，是在自己的行里面居中的。比如，现在文字字号14px，行高是24px。那么：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505205052268-780871335.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为了严格保证字在行里面居中，我们的工程师有一个约定：&lt;strong&gt; &lt;span&gt;行高、字号，一般都是偶数&lt;/span&gt;。&lt;/strong&gt;这样，它们的差，就是偶数，就能够被2整除。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.2 单行文本垂直居中&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        *&lt;/span&gt;{&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
        }&lt;span&gt;
        p&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 600px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
            font-size&lt;/span&gt;:&lt;span&gt; 16px&lt;/span&gt;;&lt;span&gt;
            line-height&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;文字文字文字文字文字文字文字文字文字&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文本在行里面居中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505205110206-743327101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;公式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 行高:盒子高;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，这个小技巧，行高=盒子高。  &lt;strong&gt;只适用于单行文本垂直居中！！不适用于多行&lt;/strong&gt;。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果想让多行文本垂直居中，需要设置盒子的&lt;/span&gt;padding&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505205123988-111790315.png&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;295&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.3 font属性&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;●&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;strong&gt;font属性，能够将&lt;/strong&gt;&lt;strong&gt;字号、行高、字体，能够一起设置&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('81ce27d6-a6ef-47e4-aadc-7504e033bb9d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_81ce27d6-a6ef-47e4-aadc-7504e033bb9d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_81ce27d6-a6ef-47e4-aadc-7504e033bb9d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('81ce27d6-a6ef-47e4-aadc-7504e033bb9d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_81ce27d6-a6ef-47e4-aadc-7504e033bb9d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        *&lt;/span&gt;{&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
        }&lt;span&gt;
        p&lt;/span&gt;{&lt;span&gt;
            font&lt;/span&gt;:&lt;span&gt;14px/24px &quot;宋体&quot;&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 font: 14px/24px “宋体”;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 font-size:14px;

2 line-height:24px;

3 font-family:&quot;宋体&quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 等价于三行语句：&lt;/p&gt;
&lt;p&gt;font-family就是“字体”。family是“家庭”、“伐木累”的意思。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6f64f996-eba4-4d0d-b8de-9a4d0f42ce2a')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_6f64f996-eba4-4d0d-b8de-9a4d0f42ce2a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6f64f996-eba4-4d0d-b8de-9a4d0f42ce2a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6f64f996-eba4-4d0d-b8de-9a4d0f42ce2a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6f64f996-eba4-4d0d-b8de-9a4d0f42ce2a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body&lt;/span&gt;{&lt;span&gt;
            font&lt;/span&gt;:&lt;span&gt; 24px/48px &quot;Arial&quot;,&quot;Microsoft YaHei&quot;,&quot;SimSun&quot;&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    哈abcdefghijklmn哈
    &amp;lt;span&amp;gt;我是span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;● 网页中不是所有字体都能用哦，因为这个字体要看用户的电脑里面装没装&lt;/strong&gt;，比如你设置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 font-family: &quot;华文彩云&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果用户电脑里面没有这个字体，那么就会变成宋体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;页面中，中文我们只使用：&lt;/span&gt; &lt;span&gt;微软雅黑、宋体、黑体。&lt;/span&gt; &lt;span&gt;如果页面中，需要其他的字体，那么需要切图。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;英语：&lt;/span&gt;Arial 、 Times New Roman&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;span&gt;&lt;strong&gt;● 为了防止用户电脑里面，没有微软雅黑这个字体。就要用英语的逗号，隔开备选字体&lt;/strong&gt;，就是说如果用户电脑里面，没有安装微软雅黑字体，那么就是宋体：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 font-family: &quot;微软雅黑&quot;,&quot;宋体&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 备选字体可以有无数个，用逗号隔开。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;● 我们要将英语字体，放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1 font-family: &quot;Times New Roman&quot;,&quot;微软雅黑&quot;,&quot;宋体&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;● 所有的中文字体，都有英语别名，我们也要知道&lt;/strong&gt;： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;微软雅黑的英语别名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 font-family: &quot;Microsoft YaHei&quot;;   
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
1 font-family: &quot;SimSun&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 宋体的英语别名：&lt;/p&gt;
&lt;p&gt;font属性能够将font-size、line-height、font-family合三为一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1 font:12px/30px  &quot;Times New Roman&quot;,&quot;Microsoft YaHei&quot;,&quot;SimSun&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;● 行高可以用百分比，表示&lt;/strong&gt;&lt;strong&gt;字号&lt;/strong&gt;&lt;strong&gt;的百分之多少&lt;/strong&gt;&lt;span&gt;。一般来说，都是大于&lt;/span&gt;100%的，因为行高一定要大于字号。 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 font:12px/200% “宋体”
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 font:12px/24px “宋体”;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 等价于&lt;/p&gt;
&lt;p&gt;反过来，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 font:16px/48px “宋体”;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 font:16px/300% “宋体”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于&lt;/p&gt;

&lt;p&gt;&lt;span&gt;超级链接就是&lt;/span&gt;a标签。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.1 伪类&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        a:link&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
        }&lt;span&gt;
        a:visited&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;orange&lt;/span&gt;;
        }&lt;span&gt;
        a:hover&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;green&lt;/span&gt;;
        }&lt;span&gt;
        a:active&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;black&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;http://www.563.com/&quot; target=&quot;_blank&quot;&amp;gt;点击我去363&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;http://www.163.com/&quot; target=&quot;_blank&quot;&amp;gt;点击我去网易&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;也就是说，同一个标签，根据用户的某种状态不同，有不同的样式。这就叫做&lt;/span&gt;“伪类”。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类就是工程师加的，比如&lt;/span&gt;div属于box类，很明确，就是属于box类。但是a属于什么类？不明确。因为要看用户有没有点击、有没有触碰。所以，就叫做“伪类”。&lt;/p&gt;
&lt;p&gt;伪类用冒号来表示。&lt;/p&gt;
&lt;p&gt;a标签有4种伪类，要求背诵：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  a:link&lt;/span&gt;{&lt;span&gt;
2  color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
3  &lt;/span&gt;}&lt;span&gt;
4  a:visited&lt;/span&gt;{&lt;span&gt;
5  color&lt;/span&gt;:&lt;span&gt;orange&lt;/span&gt;;&lt;span&gt;
6  &lt;/span&gt;}&lt;span&gt;
7  a:hover&lt;/span&gt;{&lt;span&gt;
8  color&lt;/span&gt;:&lt;span&gt;green&lt;/span&gt;;&lt;span&gt;
9  &lt;/span&gt;}&lt;span&gt;
10  a:active&lt;/span&gt;{&lt;span&gt;
11  color&lt;/span&gt;:&lt;span&gt;black&lt;/span&gt;;&lt;span&gt;
12  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;:visited &lt;span&gt;表示，&lt;/span&gt; &lt;span&gt;用户访问过了这个链接的样式。&lt;/span&gt; &lt;span&gt;是英语&lt;/span&gt;“访问过的”的意思。:link   &lt;span&gt;表示，&lt;/span&gt; &lt;span&gt;用户没有点击过这个链接的样式。&lt;/span&gt; &lt;span&gt;是英语&lt;/span&gt;“链接”的意思。&lt;/p&gt;
&lt;p&gt;:hover &lt;span&gt;表示，&lt;/span&gt; &lt;span&gt;用户鼠标悬停的时候链接的样式。&lt;/span&gt; &lt;span&gt;是英语&lt;/span&gt;“悬停”的意思。&lt;/p&gt;
&lt;p&gt;:active &lt;span&gt;表示，&lt;/span&gt; &lt;span&gt;用户用鼠标点击这个链接，但是不松手，此刻的样式。&lt;/span&gt; &lt;span&gt;是英语&lt;/span&gt;“激活”的意思。&lt;/p&gt;

&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;217&quot;&gt;
&lt;p&gt;a:link&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505205440365-1118079400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;217&quot;&gt;
&lt;p&gt;a:visited&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505205447486-485341094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;217&quot;&gt;
&lt;p&gt;a:hover&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505205453790-1110333871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;217&quot;&gt;
&lt;p&gt;a:active&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505205459835-1248659036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;记住，这四种状态，在&lt;/span&gt;css中，必须按照固定的顺序写：&lt;/p&gt;
&lt;p&gt;a:&lt;strong&gt;l&lt;/strong&gt;ink 、a:&lt;strong&gt;v&lt;/strong&gt;isited 、a:&lt;strong&gt;h&lt;/strong&gt;over 、a:&lt;strong&gt;a&lt;/strong&gt;ctive&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不按照顺序，那么将失效。&lt;/span&gt;“爱恨准则”&lt;strong&gt;l&lt;/strong&gt;o&lt;strong&gt;v&lt;/strong&gt;e &lt;strong&gt;ha&lt;/strong&gt;te。必须先爱，后恨。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.2 超级链接的美化&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;a标签在使用的时候，非常的难。因为不仅仅要控制a这个盒子，也要控制它的伪类。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们一定要将&lt;/span&gt;a标签写在前面，:link、:visited、:hover、:active这些伪类写在后面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('00105712-2d9c-41b0-8c10-3591427e56b7')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_00105712-2d9c-41b0-8c10-3591427e56b7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_00105712-2d9c-41b0-8c10-3591427e56b7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('00105712-2d9c-41b0-8c10-3591427e56b7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_00105712-2d9c-41b0-8c10-3591427e56b7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        *&lt;/span&gt;{&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
        }&lt;span&gt;
        .nav&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 960px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid red&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul&lt;/span&gt;{
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;去掉小圆点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            list-style&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li&lt;/span&gt;{&lt;span&gt;
            float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
            line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li a&lt;/span&gt;{&lt;span&gt;
            display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li a:link , .nav ul li a:visited&lt;/span&gt;{&lt;span&gt;
            text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; purple&lt;/span&gt;;&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;white&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li a:hover&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; orange&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;nav&quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;a标签中，描述盒子； 伪类中描述文字的样式、背景。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     .nav ul li a&lt;/span&gt;{&lt;span&gt;
2     display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
3     width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
4     height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
5     &lt;/span&gt;}&lt;span&gt;
6    .nav ul li a:link ,.nav ul li a:visited&lt;/span&gt;{&lt;span&gt;
7     text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
8 
9     color&lt;/span&gt;:&lt;span&gt;white&lt;/span&gt;;&lt;span&gt;
10     &lt;/span&gt;}&lt;span&gt;
11     .nav ul li a:hover&lt;/span&gt;{&lt;span&gt;
12 
13     font-weight&lt;/span&gt;:&lt;span&gt; bold&lt;/span&gt;;&lt;span&gt;
14     color&lt;/span&gt;:&lt;span&gt;yellow&lt;/span&gt;;&lt;span&gt;
15     &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;记住，所有的&lt;/span&gt;a不继承text、font这些东西。因为a自己有一个伪类的权重。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;最标准的，就是把&lt;/span&gt;link、visited、hover都要写。但是前端开发工程师在大量的实践中，发现不写link、visited浏览器也挺兼容。所以这些“老油条”们，就把a标签简化了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('582cfc97-4552-4748-a1b7-5fcf199b0ac0')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_582cfc97-4552-4748-a1b7-5fcf199b0ac0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_582cfc97-4552-4748-a1b7-5fcf199b0ac0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('582cfc97-4552-4748-a1b7-5fcf199b0ac0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_582cfc97-4552-4748-a1b7-5fcf199b0ac0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        *&lt;/span&gt;{&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
        }&lt;span&gt;
        .nav&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 960px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid red&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul&lt;/span&gt;{
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;去掉小圆点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            list-style&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li&lt;/span&gt;{&lt;span&gt;
            float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
            line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li a&lt;/span&gt;{&lt;span&gt;
            display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; purple&lt;/span&gt;;&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;white&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li a:hover&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; orange&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;nav&quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网站栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;a:link、a:visited都是可以省略的，简写在a标签里面。也就是说，a标签涵盖了link、visited的状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     .nav ul li a&lt;/span&gt;{&lt;span&gt;
2     display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
3     width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
4     height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
5     text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt; 
7     color&lt;/span&gt;:&lt;span&gt;white&lt;/span&gt;;&lt;span&gt;
8     &lt;/span&gt;}&lt;span&gt;
9     .nav ul li a:hover&lt;/span&gt;{&lt;span&gt;
11     &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.1 background-color属性&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;背景颜色属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 180px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;&lt;span&gt;
            margin-bottom&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
        }&lt;span&gt;
        .box1&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
        }&lt;span&gt;
        .box2&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(255,0,0)&lt;/span&gt;;
        }&lt;span&gt;
        .box3&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #ff0000&lt;/span&gt;;
        }&lt;span&gt;

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box1&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box2&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box3&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;css2.1中，颜色的表示方法有哪些？一共有三种：单词、rgb表示法、十六进制表示法&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.1.1 用英语单词来表示&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;能够用英语单词来表述的颜色，都是简单颜色。&lt;/p&gt;
&lt;p&gt;红色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
background-color: red;   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.1.2 用rgb方法来表示&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;红色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 180px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;&lt;span&gt;
            margin-bottom&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
        }&lt;span&gt;
        .box1&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(255,0,0)&lt;/span&gt;;
        }&lt;span&gt;
        .box2&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(0,255,0)&lt;/span&gt;;
        }&lt;span&gt;
        .box3&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(0,0,0)&lt;/span&gt;;
        }&lt;span&gt;
        .box4&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(255,255,255)&lt;/span&gt;;
        }&lt;span&gt;
        .box5&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(255,255,0)&lt;/span&gt;;
        }&lt;span&gt;
        .box6&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(255,0,255)&lt;/span&gt;;
        }&lt;span&gt;
        .box7&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(111,222,123)&lt;/span&gt;;
        }&lt;span&gt;
        .box8&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(111,222,153)&lt;/span&gt;;
        }&lt;span&gt;
        .box9&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; rgb(55,55,55)&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box1&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box2&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box3&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box4&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box5&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box6&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box7&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box8&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box9&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
background-color: rgb(255,0,0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;用逗号隔开，&lt;/span&gt;r、g、b的值，每个值的取值范围0~255，一共256个值&lt;/span&gt;。&lt;/strong&gt;rgb表示三原色“红”red、“绿”green、“蓝”blue。光学显示器，每个像素都是由三原色的发光原件组成的，靠明亮度不同调成不同的颜色的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果此项的值，是&lt;/span&gt;255，那么就说明是纯色：&lt;/p&gt;
&lt;p&gt;绿色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: rgb(0,255,0);  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;蓝色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: rgb(0,0,255);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;黑色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: rgb(0,0,0);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;白色：光学显示器，每个元件都不发光，黑色的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: rgb(255,255,255);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;颜色可以叠加，比如黄色就是红色和绿色的叠加： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: rgb(255,255,0);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再比如： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: rgb(111,222,123);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是红、绿、蓝三种颜色的不同比例叠加。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.1.3 十六进制表示法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0fbefeff-3ac4-46a2-a04e-99dccb6ed33d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0fbefeff-3ac4-46a2-a04e-99dccb6ed33d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0fbefeff-3ac4-46a2-a04e-99dccb6ed33d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0fbefeff-3ac4-46a2-a04e-99dccb6ed33d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0fbefeff-3ac4-46a2-a04e-99dccb6ed33d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 180px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;&lt;span&gt;
            margin-bottom&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
        }&lt;span&gt;
        .box1&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #ff0000&lt;/span&gt;;
        }&lt;span&gt;
        .box2&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #00ff00&lt;/span&gt;;
        }&lt;span&gt;
        .box3&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #00f&lt;/span&gt;;
        }&lt;span&gt;
        .box4&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #111&lt;/span&gt;;
        }&lt;span&gt;
        .box5&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #222&lt;/span&gt;;
        }&lt;span&gt;
        .box6&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #333&lt;/span&gt;;
        }&lt;span&gt;
        .box7&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #444&lt;/span&gt;;
        }&lt;span&gt;
        .box8&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #555&lt;/span&gt;;
        }&lt;span&gt;
        .box9&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; #666&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box1&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box2&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box3&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box4&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box5&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box6&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box7&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box8&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box9&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;红色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: #ff0000;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;#ff0000&lt;/span&gt;所有用&lt;/span&gt;#开头的值，都是16进制的。&lt;/p&gt;
&lt;p&gt;16进制表示法，也是两位两位看，看r、g、b，但是没有逗号隔开。&lt;/p&gt;
&lt;p&gt;ff就是10进制的255 ，00 就是10进制的0，00就是10进制的0。所以等价于rgb(255,0,0);&lt;/p&gt;
&lt;p&gt;怎么换算的？我们介绍一下&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们现在看一下&lt;/span&gt;10进制中的基本数字（一共10个）:&lt;/p&gt;
&lt;p&gt;0、1、2、3、4、5、6、7、8、9&lt;/p&gt;
&lt;p&gt;16进制中的基本数字（一共16个）:&lt;/p&gt;
&lt;p&gt;0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f&lt;/p&gt;
&lt;p&gt;16进制对应表：&lt;/p&gt;
&lt;p&gt;十进制数 十六进制数&lt;/p&gt;
&lt;p&gt;0 　　 0&lt;/p&gt;
&lt;p&gt;1 　　 1&lt;/p&gt;
&lt;p&gt;2　　 2　　&lt;/p&gt;
&lt;p&gt;3 3　　　　&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;10　　 a&lt;/p&gt;
&lt;p&gt;11 　　 b&lt;/p&gt;
&lt;p&gt;12 　　 c&lt;/p&gt;
&lt;p&gt;13　　 d&lt;/p&gt;
&lt;p&gt;14 　　 e&lt;/p&gt;
&lt;p&gt;15　　 f&lt;/p&gt;
&lt;p&gt;16　　 10&lt;/p&gt;
&lt;p&gt;17　　 11&lt;/p&gt;
&lt;p&gt;18 　　 12&lt;/p&gt;
&lt;p&gt;19 　　 13&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;43 　　 2b&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;255　　 ff&lt;/p&gt;
&lt;p&gt;&lt;span&gt;十六进制中，&lt;/span&gt;13 这个数字表示什么？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;表示&lt;/span&gt;1个16和3个1。 那就是19&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;span&gt;这就是&lt;/span&gt;&lt;strong&gt;位权&lt;/strong&gt;&lt;span&gt;的概念，开头这位表示多少个&lt;/span&gt;16，末尾这位表示多少个1。&lt;/p&gt;
&lt;p&gt;小练习：&lt;/p&gt;
&lt;p&gt;16进制中28等于10进制多少？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：&lt;/span&gt;2*16+8 = 40。&lt;/p&gt;
&lt;p&gt;16进制中的2b等于10进制多少？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：&lt;/span&gt;2*16+11 = 43。&lt;/p&gt;
&lt;p&gt;16进制中的af等于10进制多少？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：&lt;/span&gt;10 * 16 + 15 = 175&lt;/p&gt;
&lt;p&gt;16进制中的ff等于10进制多少？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：&lt;/span&gt;15*16 + 15 = 255&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;/span&gt;#ff0000就等于rgb(255,0,0)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: #123456;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 等价于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color: rgb(18,52,86);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，&lt;span&gt;&lt;strong&gt;&lt;span&gt;任何一种十六进制表示法，都能够换算成为&lt;/span&gt;rgb表示法。也就是说，两个表示法的颜色数量，一样&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十六进制可以简化为&lt;/span&gt;3位，所有#aabbcc的形式，能够简化为#abc;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color:#ff0000;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color:#f00;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color:#112233;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color:#123;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只能上面的方法简化，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;background-color:#222333;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要记住：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 #000   黑
2 #fff    白
3 #f00   红
4 #333   灰
5 #222   深灰
6 #ccc   浅灰&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.2 background-image&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;用于给盒子加上背景图片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('eba0c699-1ede-458b-9cdb-66e299d8bb71')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_eba0c699-1ede-458b-9cdb-66e299d8bb71&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eba0c699-1ede-458b-9cdb-66e299d8bb71&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('eba0c699-1ede-458b-9cdb-66e299d8bb71',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eba0c699-1ede-458b-9cdb-66e299d8bb71&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt;url(images/wuyifan.jpg)&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;文字文字文字文字文字文字文字文字文字文字&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background-image:url(images/wuyifan.jpg);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210508450-1025116357.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;

&lt;p&gt;images/wuyifan.jpg 就是相对路径。url()表示网址，uniform resouces locator 同意资源定位符&lt;/p&gt;
&lt;p&gt;背景天生是会被平铺满的。&lt;/p&gt;
&lt;p&gt;padding的区域有背景图。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.3 background-repeat属性&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;设置背景图是否重复的，重复方式的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/wuyifan.jpg)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt;repeat-x&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;文字文字文字文字文字文字文字文字文字文字&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;repeat表示“重复”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210622453-745595215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background-repeat:no-repeat;   不重复

2 background-repeat:repeat-x;    横向重复

3 background-repeat:repeat-y;    纵向重复&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;也就是说，&lt;/span&gt;background-repeat属性，有三种值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('579c49b3-b3d7-4267-b73b-689ba91e962c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_579c49b3-b3d7-4267-b73b-689ba91e962c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_579c49b3-b3d7-4267-b73b-689ba91e962c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('579c49b3-b3d7-4267-b73b-689ba91e962c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_579c49b3-b3d7-4267-b73b-689ba91e962c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        *&lt;/span&gt;{&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
        }&lt;span&gt;
        body&lt;/span&gt;{&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/dibanzhuan.jpg)&lt;/span&gt;;
        }&lt;span&gt;
        .nav&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 960px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul&lt;/span&gt;{&lt;span&gt;
            list-style&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li&lt;/span&gt;{&lt;span&gt;
            float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
            text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
            line-height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li a&lt;/span&gt;{&lt;span&gt;
            display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/bg2.png)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt; repeat-x&lt;/span&gt;;&lt;span&gt;
            text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;white&lt;/span&gt;;
        }&lt;span&gt;
        .nav ul li a:hover&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;black&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/bg3.png)&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;nav&quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;网页栏目&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.4 background-position属性&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.4.1 属性的意思&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/wuyifan.jpg)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt;-50px -120px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;背景定位属性，是最难的属性。一定要好好学。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210702767-773356046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;position就是“位置”的意思。background-position就是背景定位属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background-position:向右移动量 向下移动量;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定位属性可以是负数： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210717536-489846062.png&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.4.2 css精灵&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a6572a24-705c-48e0-a253-8d125c481959')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a6572a24-705c-48e0-a253-8d125c481959&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a6572a24-705c-48e0-a253-8d125c481959&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a6572a24-705c-48e0-a253-8d125c481959',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a6572a24-705c-48e0-a253-8d125c481959&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 150px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/1.jpg)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt; -100px -220px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210730634-1179651892.png&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“css精灵”，英语css sprite，所以也叫做“css雪碧”技术。是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。&lt;/p&gt;
&lt;p&gt;css精灵有什么优点，就是减少了http请求。比如4张小图片，原本需要4个http请求。但是用了css精灵，小图片变为了一张图，http请求只有1个了。&lt;/p&gt;
&lt;p&gt;淘宝网的精灵图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        span&lt;/span&gt;{&lt;span&gt;
            display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/taobao.png)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;
        }&lt;span&gt;
        .kuang&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 19px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt; -110px -98px&lt;/span&gt;;
        }&lt;span&gt;
        .tbzc&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 78px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 15px&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt; -146px -68px&lt;/span&gt;;
        }&lt;span&gt;
        .mao&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 32px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 11px&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt; -146px -119px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;span class=&quot;kuang&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;tbzc&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;mao&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210744080-77720250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用&lt;/span&gt;fireworks精确控制精灵：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ecd2bb3d-0dd6-4ddd-8830-e9bea8d777fa')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ecd2bb3d-0dd6-4ddd-8830-e9bea8d777fa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ecd2bb3d-0dd6-4ddd-8830-e9bea8d777fa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ecd2bb3d-0dd6-4ddd-8830-e9bea8d777fa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ecd2bb3d-0dd6-4ddd-8830-e9bea8d777fa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 110px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 140px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid #000&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/3.jpg)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt; -161px -45px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210755248-293211452.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.4.3 用单词描述&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background-position: 描述左右的词儿  描述上下的词儿;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;描述上下的词儿：&lt;/span&gt; &lt;span&gt;top 、center、bottom&lt;/span&gt;描述左右的词儿：&lt;/span&gt; left、 center、right&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background-position: right bottom;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 右下角：&lt;/p&gt;
&lt;p&gt;左下角：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background-position: left bottom;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210844954-1136625055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用图： &lt;/p&gt;
&lt;p&gt;1） 大背景图居中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body&lt;/span&gt;{&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt;url(images/anhei.jpg)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt; center top&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210856929-869348933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2） 通栏banner&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3510a191-8c8a-4acc-86d8-82b0424ee4f0')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3510a191-8c8a-4acc-86d8-82b0424ee4f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3510a191-8c8a-4acc-86d8-82b0424ee4f0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3510a191-8c8a-4acc-86d8-82b0424ee4f0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3510a191-8c8a-4acc-86d8-82b0424ee4f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        *&lt;/span&gt;{&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
        }&lt;span&gt;
        div&lt;/span&gt;{&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 465px&lt;/span&gt;;&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/banner.jpg)&lt;/span&gt;;&lt;span&gt;
            background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;&lt;span&gt;
            background-position&lt;/span&gt;:&lt;span&gt; center top&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505210906701-303262919.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.5 background-attachment&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;背景是否固定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b476a49c-ca26-44c8-8244-59ea75a27e0b')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b476a49c-ca26-44c8-8244-59ea75a27e0b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b476a49c-ca26-44c8-8244-59ea75a27e0b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b476a49c-ca26-44c8-8244-59ea75a27e0b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b476a49c-ca26-44c8-8244-59ea75a27e0b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body&lt;/span&gt;{&lt;span&gt;
            background-image&lt;/span&gt;:&lt;span&gt; url(images/1.jpg)&lt;/span&gt;;&lt;span&gt;
            background-attachment&lt;/span&gt;:&lt;span&gt; fixed&lt;/span&gt;;
        }&lt;span&gt;
        .header&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 980px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;header&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfssdfasdfdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdasdfadsff&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;sdfsdf&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background-attachment:fixed;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 背景就会被固定住，不会被滚动条滚走。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.6 background综合属性&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;background属性和border一样，是一个综合属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c2dd5df8-7ce9-4b16-bc47-318361eae552')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c2dd5df8-7ce9-4b16-bc47-318361eae552&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c2dd5df8-7ce9-4b16-bc47-318361eae552&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c2dd5df8-7ce9-4b16-bc47-318361eae552',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c2dd5df8-7ce9-4b16-bc47-318361eae552&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
            background&lt;/span&gt;:&lt;span&gt; blue url(images/wuyifan.jpg) no-repeat 100px 100px&lt;/span&gt;;
        }&lt;span&gt;
        span&lt;/span&gt;{&lt;span&gt;
            display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 59px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
            background&lt;/span&gt;:&lt;span&gt; url(images/taobao.png) no-repeat 0 -133px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background:red url(1.jpg) no-repeat 100px 100px fixed;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2 background-image:url(1.jpg);
3 background-repeat:no-repeat;
4 background-position:100px 100px;
5 background-attachment:fixed;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 等价于：&lt;/p&gt;
&lt;p&gt;可以任意省略部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background: red;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background: blue url(images/wuyifan.jpg) no-repeat 100px 100px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180505211020182-180268903.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;

&lt;p&gt;精灵的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 background: url(images/taobao.png) no-repeat 0 -133px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;预告一下，&lt;/span&gt;CSS3课程中，将学习更多background属性： &lt;/p&gt;
&lt;p&gt;background-origin、background-clip、background-size（在CSS2.1背景图片是不能调整尺寸，IE9开始兼容）、&lt;/p&gt;
&lt;p&gt;多背景。&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 13:22:00 +0000</pubDate>
<dc:creator>我举个栗子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanghui1234/p/8996047.html</dc:identifier>
</item>
<item>
<title>常量，字段，构造方法 - franhome</title>
<link>http://www.cnblogs.com/franhome/p/8996003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/franhome/p/8996003.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;常量&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.什么是常量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 常量是值从不变化的符号，在编译之前值就必须确定。编译后，常量值会保存到程序集元数据中。所以，常量必须是编译器识别的基元类型的常量，如：Boolean,Char,Byte,SByte,...,...,...,UInt64,Single,Double,Decimal,String。另外，C#是可以定义非基元类型的常量的，前提是值必须为null。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomeType
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; SomeType Empty=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.常量的特性&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;常量成员将创建元数据，它是直接嵌入在代码内部，运行时不需要额外分配内存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;常量被视为静态成员，而不是实例成员。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;不能获取常量的地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;不能以引用的方式传递常量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;参考上面的特性，如果跨程序引用，尝试改变常量初始值，不仅dll需要重新编译，引用者也需要编译&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;字段&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.什么是字段&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;字段是一种数据成员，它可以是值类型的实例也可以是引用类型的引用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;CLR支持类型字段和实例字段，什么是类型字段？它其实就是我们熟悉的静态字段，实例字段就是非静态字段。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.1类型字段（静态字段）的内存分配过程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;类型对象（静态对象）是在类型加载到一个AppDomain时创建的，而所需内存也是在内型对象中分配的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接着上面的问题，那么，什么时候将类型加载到AppDomain中内？当第一次对引用到该类型的方法进行JIT编译时，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.2实例字段的内存分配过程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;实例字段的内存，是在构造容纳字段的类型进行实例构造时分配的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.字段特性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;字段存储在动态内存中，它不像常量，所以只能在程序运行时，才能够获取到它的值。字段可以是任何类型，不像常量有类型上的限制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.1字段修饰符&lt;/span&gt;&lt;/h4&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;Static&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;static&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;指定字段为类型的一部分，而不是对象的一部分&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;&lt;strong&gt;Instance&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;默认&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;指定字段与实例关联，而不是和类本身关联&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;&lt;strong&gt;InitOly&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;只能在构造器方法中进行值的写入，否则只读&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;&lt;strong&gt;Volatile&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;表示，编译器和CLR以及硬件，不会对这种字段标识的代码执行“线程不安全的措施”，只有CLR中的基元类型能使用这个修饰符。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.2 readonly和read/write&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;通常，字段都是read/write，即可读可写的，这也意味着，字段的值会随着运行可能发生值得变化。而当你把字段标记为readonly，那么你就只能在构造函数中，对它进行赋值，编译器是不会允许你在构造器（构造函数）以为的任何方法写入值，或变更值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当然，C#提供了一种内联初始化的语法糖来进行readonly值的初始化，这种语法也可以对常量和其他形式的字段进行赋值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;readonly &lt;span class=&quot;cm-variable-3&quot;&gt;int &lt;span class=&quot;cm-operator&quot;&gt;=&lt;span class=&quot;cm-number&quot;&gt;250;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当然，使用内联语法，而不是在构造器中构造，滥用的话可能会有一些性能问题（代码膨胀等）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;构造方法&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;实例构造器（引用类型）&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;什么是构造器？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;构造器是将类型的实例初始化到良好状态的特殊方法。在“方法定义元数据表”中始终叫.ctor(constructor的简称)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;引用类型在内存中如何实例化？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;首先为实例的数据字段分配内存空间，然后是为初始化对象的附加字段（没错，就是我们经常会提到的同步块索引和类型对象指针）分配内存，然后最后开辟一个空间来调用实例构造函数进行对象的初始化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在调用构造器之前，为对象分配的内存总是先被归零，为了保证那些被构造器显示重写的字段都获得0或者null的值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;G:/Users/Fran/Desktop/blog_image/blog/clrviac%23/%E5%B8%B8%E9%87%8F%E5%AD%97%E6%AE%B5%E6%96%B9%E6%B3%95/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653549/201805/653549-20180505203738025-1251962561.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;实例构造器的特性：&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;11&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;实例构造器永远不能被继承，类必须执行自己的构造函数。如果没有，系统默认会构造一个无参的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以，实例构造器不能用new ,override,sealed和abstract修饰&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果类的修饰符为abstract，那么构造器可访问性默认为protected,否则默认为public。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果基类没有提供无参构造函数（意味着显示的实现了有参的构造函数），那么派生类必须显示调用一个基类的构造器（及为了保证参数一致），否则编译报错。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;static（sealed和abstract）修饰的类，编译器不会为它生成默认的构造函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;通常情况下，无论如何实例化派生类，基类的构造函数一定会被调用，所以object的构造函数一定会被先调用，但是实时上它什么也不会干。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;极少数情况下，对象实例不会调用构造函数。如，Object的MemberwiseClone方法，它是用来分配内存，初始化对象的附加字段的，然后将源对象的字节数据复制到新对象中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Notice:不要在构造器中调用虚方法。因为，假如被实例化的类型重写了虚方法，就会执行派生类型中的实现，但这个时候，却是没有初始化的，所以，容易导致无法预测的行为。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;内联语法（在字段一节提到过）方式实现初始化实例字段，其实也是转换成构造器方法中的代码来实现。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;实例构造器（值类型）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;CLR是允许值类型创建实例，但是c#编译器是不会默认为值类型构建构造函数的，并且值类型构造器必须显示调用才执行。如上面所说，即使你自己定义了一个构造函数，不管它是有参还是无参，编译器都不会去自动调用它，如果你想执行，必须自己显示进行调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;然而，上面说那么多，在C#中，编译器根本不允许你定义值类型的无参构造函数，它会报：error CS0568:结构不能包含显示的无参构造函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;同理，你不能对值类型的字段成员进行内联赋值，因为内联语句实际上是通过构造器进行赋值，如下面的代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; SomeValType
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; m=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;上面的代码，会报：结构中不能有实例字段初始值设定项。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以，值类型的字段总是被初始化为0或null,因为没有真正意义上的构造函数为它初始化其他值，只有你手动去调用构造函数（所以这里我们不理解为初始化）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当你提供一个有参构造函数时，你需要为所有的字段进行赋值，否则会报：error CS0171:在控制返回到调用方法之前，字段XXX必须完全赋值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;类型构造器（静态构造器）&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;什么是类型构造器？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;实例构造器是为了让类的实例有一个良好的可验证的初始值。而类型构造器是为静态类型服务，顾名思义，类型构造器则是为了让类型有良好的初始状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;类型构造器特征&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2.5&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;默认没有构造函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;（类型）静态构造器永远不能有参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;必须标记为static,因为静态类型的成员必须为静态成员&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;不能赋予任何访问修饰符，默认为隐式类型,C#默认为private&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;类型构造器中的代码只能访问类型的静态字段（常规用途就是初始化这些字段）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;类型构造器的调用过程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;类型构造器调用过程大致如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;JIT编译器在编译到一个静态方法时，会查看引用了哪些静态类型。如果这个静态类型定义了一个构造函数，JIT编译器会检查当前AppDomain,是否已经执行过了这个类型构造器。如果已经执行过，就不添加对它的调用。如果从未执行过，JIT编译器会在它的本机代码中添加对类型构造器的调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;重要的是：为什么静态类型的特性是十分适合做单例呢？因为CLR常常是确保每一个AppDomain中，一个类型构造器都只执行一次，那么上述的机制不足以很好的支撑这个特性，因为，多个线程下如何保证呢？为了保证这一点，调用类型构造器时，每一个调用线程都会获取一个互斥线程同步锁，在这样的机制下，如果多个线程试图同时调用某个类型的静态构造器，只有一个线程可以获得锁，其他的线程会被阻塞。只有第一个线程会执行静态构造器的代码。当一个线程离开构造器后，正在等待的线程才会被唤醒，后面的线程会发现，类型构造器已经被执行过了，将直接从构造方法返回。这样就能确保不会被再次调用。并且以上是线程安全的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以，单例模式就是借助上面的特性，你想构建的单例对象，则也应该放到类型构造器中进行初始化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：值类型中也可以定义类型（静态）构造器，但是是不推荐这么做的，因为有时候CLR有时不会调用值类型的静态类型构造器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; StructValType
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虽然值类型的构造函数必须有参数，但是这个是静态构造函数，所以它是一定没有参数的，也不用遵守，必须初始化所有成员的值&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; StructValType()
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我会出现吗？&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)；
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
}
​
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseClass
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ClassName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
​
         &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; BaseClass()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm BaseClass static Constructor without param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
​
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseClass()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm BaseClass Constructor without param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;上述代码，BaseClass中和StructValType中都有static构造函数，再对两个类进行实例时，你可以发现值类型的静态函数是没有被调用的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：单个线程中，两个类型构造器包含互相引用的代码可能出问题，因为你无法把握两者的实现顺序，也就无法保证能正确的引用。因为是CLR负责类型构造器的调用，所以不能要求以特定的顺序调用类型构造器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果，类型构造器抛出未处理的异常，CLR会认为类型不可用。试图访问该类型的任何字段和方法都会抛出System.TypeInitializationException异常。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 12:33:00 +0000</pubDate>
<dc:creator>franhome</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/franhome/p/8996003.html</dc:identifier>
</item>
<item>
<title>ScrollView的顶部下拉和底部上拉回弹效果 - Denluoyia</title>
<link>http://www.cnblogs.com/denluoyia/p/8995589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/denluoyia/p/8995589.html</guid>
<description>&lt;p&gt;要实现ScrollView的回弹效果，需要对其进行触摸事件处理。先来看一下简单的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1045731/201805/1045731-20180505200820796-780864703.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据Android的View事件分发处理机制，下面对dispatchTouchEvent进行详细分析：&lt;/p&gt;
&lt;p&gt;在加载布局完成之后，获取ScrollView的第一个子元素，保存它的参数，left top right bottom参数，根据顶部下拉操作和底部上拉操作进行子View的布局参数根据滑动距离改变，ACTION_UP的时候判断是否存在回弹，如果需要则进行动画回弹到原来的位置，可以添加一个回弹结束监听，比如监听回弹处理跳转到其他的页面的操作等。&lt;/p&gt;
&lt;p&gt;具体的实现如下，添加了是否禁用顶部和底部回弹的参数设置，以及回弹效果结束监听。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * A Simple Rebound ScrollView
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Denluoyia
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ReboundScrollView &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ScrollView{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; mEnableTopRebound = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; mEnableBottomRebound = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OnReboundEndListener mOnReboundEndListener;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; View mContentView;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Rect mRect = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Rect();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReboundScrollView(Context context) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReboundScrollView(Context context, AttributeSet attrs) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ReboundScrollView(Context context, AttributeSet attrs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyleAttr) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs, defStyleAttr);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; after inflating view, we can get the width and height of view &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onFinishInflate() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onFinishInflate();
        mContentView &lt;/span&gt;= getChildAt(0&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onLayout(&lt;span&gt;boolean&lt;/span&gt; changed, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onLayout(changed, l, t, r, b);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mContentView == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to remember the location of mContentView&lt;/span&gt;
&lt;span&gt;        mRect.set(mContentView.getLeft(), mContentView.getTop(), mContentView.getRight(), mContentView.getBottom());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReboundScrollView setOnReboundEndListener(OnReboundEndListener onReboundEndListener){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mOnReboundEndListener =&lt;span&gt; onReboundEndListener;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ReboundScrollView setEnableTopRebound(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enableTopRebound){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mEnableTopRebound =&lt;span&gt; enableTopRebound;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ReboundScrollView setEnableBottomRebound(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; mEnableBottomRebound){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mEnableBottomRebound =&lt;span&gt; mEnableBottomRebound;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastY;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; rebound = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; reboundDirection = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;0 表示下部回弹  &amp;gt;0 表示上部回弹 0表示不回弹&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mContentView == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(ev);
        }
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ev.getAction()){
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_DOWN:
                lastY &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) ev.getY();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_MOVE:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isScrollToTop() &amp;amp;&amp;amp; !&lt;span&gt;isScrollToBottom()){
                    lastY &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) ev.getY();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处于顶部或者底部&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; deltaY = (&lt;span&gt;int&lt;/span&gt;) (ev.getY() -&lt;span&gt; lastY);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;deltaY &amp;gt; 0 下拉  deltaY &amp;lt; 0 上拉


                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;disable top or bottom rebound&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((!mEnableTopRebound &amp;amp;&amp;amp; deltaY &amp;gt; 0) || (!mEnableBottomRebound &amp;amp;&amp;amp; deltaY &amp;lt; 0&lt;span&gt;)){
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; offset = (&lt;span&gt;int&lt;/span&gt;) (deltaY * 0.48&lt;span&gt;);
                mContentView.layout(mRect.left, mRect.top &lt;/span&gt;+ offset, mRect.right, mRect.bottom +&lt;span&gt; offset);
                rebound &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_UP:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!rebound) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                reboundDirection &lt;/span&gt;= mContentView.getTop() -&lt;span&gt; mRect.top;
                TranslateAnimation animation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TranslateAnimation(0, 0&lt;span&gt;, mContentView.getTop(), mRect.top);
                animation.setDuration(&lt;/span&gt;300&lt;span&gt;);
                animation.setAnimationListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animation.AnimationListener() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAnimationStart(Animation animation) {

                    }

                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAnimationEnd(Animation animation) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mOnReboundEndListener != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (reboundDirection &amp;gt; 0&lt;span&gt;){
                               mOnReboundEndListener.onReboundTopComplete();
                           }
                           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (reboundDirection &amp;lt; 0&lt;span&gt;){
                               mOnReboundEndListener.onReboundBottomComplete();
                           }
                           reboundDirection &lt;/span&gt;= 0&lt;span&gt;;
                        }
                    }

                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAnimationRepeat(Animation animation) {

                    }
                });
                mContentView.startAnimation(animation);
                mContentView.layout(mRect.left, mRect.top, mRect.right, mRect.bottom);
                rebound &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(ev);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setFillViewport(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; fillViewport) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.setFillViewport(&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认是填充ScrollView 或者再XML布局文件中设置fillViewport属性&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断当前ScrollView是否处于顶部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isScrollToTop(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getScrollY() == 0&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断当前ScrollView是否已滑到底部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isScrollToBottom(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; mContentView.getHeight() &amp;lt;= getHeight() +&lt;span&gt; getScrollY();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * listener for top and bottom rebound
     * do your implement in the following methods
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; OnReboundEndListener{

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; onReboundTopComplete();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; onReboundBottomComplete();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 使用：&lt;/p&gt;
&lt;p&gt;直接在XML布局文件中把ScrollView替换成ReboundScrollView就可以了。还可以拓展把回弹顶部和底部添加其他的动画效果（之后再拓展试下）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.TestActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.denluoyia.dtils.widget.ReboundScrollView
        android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/reboundScrollView&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout
            &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;#eefade&quot;&lt;/span&gt;&lt;span&gt;
            android:padding&lt;/span&gt;&lt;span&gt;=&quot;16dp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
                &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
                android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
                android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15sp&quot;&lt;/span&gt;&lt;span&gt;
                android:lineSpacingExtra&lt;/span&gt;&lt;span&gt;=&quot;5dp&quot;&lt;/span&gt;&lt;span&gt;
                android:text&lt;/span&gt;&lt;span&gt;=&quot;@string/content&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;com.denluoyia.dtils.widget.ReboundScrollView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果需要禁用回弹，可以直接设置enableTopRebound和enableBottomRebound参数，同样设置回弹结束（或开始）监听。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ReboundScrollView reboundScrollView;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);

        reboundScrollView &lt;/span&gt;=&lt;span&gt; findViewById(R.id.reboundScrollView);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reboundScrollView.setEnableTopRebound(false);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reboundScrollView.setEnableBottomRebound(false);&lt;/span&gt;
        reboundScrollView.setOnReboundEndListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReboundScrollView.OnReboundEndListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onReboundTopComplete() {
                Toast.makeText(TestActivity.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;顶部回弹&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onReboundBottomComplete() {
                Toast.makeText(TestActivity.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;底部回弹&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
            }
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 05 May 2018 12:22:00 +0000</pubDate>
<dc:creator>Denluoyia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/denluoyia/p/8995589.html</dc:identifier>
</item>
</channel>
</rss>