<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>聊聊如何设计千万级吞吐量的.Net Core网络通信！ - 笑笑🤞</title>
<link>http://www.cnblogs.com/xxred/p/9859893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxred/p/9859893.html</guid>
<description>[unable to retrieve full-text content]聊聊如何设计千万级吞吐量的.Net Core网络通信！ 作者： &quot;大石头&quot; 时间：2018 10 26 晚上 20:00 地点：QQ群 1600800 内容：网络通信， 1. 网络库使用方式 2. 网络库设计理念，高性能要点 介绍 首先看下面这张很具有代表性的图，2018年5月份做的测试。当时单服务</description>
<pubDate>Fri, 26 Oct 2018 18:52:00 +0000</pubDate>
<dc:creator>笑笑&amp;#129310;</dc:creator>
<og:description>聊聊如何设计千万级吞吐量的.Net Core网络通信！ 作者： </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxred/p/9859893.html</dc:identifier>
</item>
<item>
<title>Reinforce Learning 的那点事——强化学习（一） - iTryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/9856626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/9856626.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;最近实验室的项目需要用到强化学习的有关内容，就开始学习起强化学习了，这里准备将学习的一些内容记录下来，作为笔记，方便日后忘记了好再方便熟悉，也可供大家参考。该篇为强化学习开篇文章，主要概括一些有关强化学习的内容，以帮助了解什么是强化学习，以及学习方向，部分涉及到的内容将会在后面的篇章中展开详细的叙述。&lt;span&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLzuuYNsE1EZAXYR4FJ75jcJseBmo4KQ9-&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;推荐课程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（Utubu上的，需FQ），&lt;span&gt;&lt;a href=&quot;https://www.bilibili.com/video/av32149008&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;B站上也有。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;　定义&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先先看一段定义：Reinforcement learning is learning what to do—how to map situations to actions—so as to maximize a numerical reward signal。感觉看英文的定义很容易可以了解什么叫强化学习。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　&lt;span&gt;应用领域&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　再来看看强化学习在整个科学领域的应用范围。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201810/1413964-20181026102526031-419999450.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;从图中可以看出，众多学科都与强化学习有关，增强学习本质上是一门决策学科，通过理解最佳的方式来制定决策。决策科学在计算机科学领域，体现为机器学习，尤其是强化学习；在工程领域，最优控制的实现与强化学习有关联；神经科学领域最主要的是研究人类大脑如何做出决策，提出多巴胺系统（前段时间谷歌开源了一个强化学习的框架就叫多巴胺），在强化学习中的运用体现为奖励系统；在心理学领域，也存在类似于神经科学领域的东西，传统的条件作用以及条件反射实验探究动物面对事物是如何做出反应，以及为什么会做出这种反应；在数学方面，可以用一个等价的公式来表示强化学习，可用于研究最优控制，也被称为运筹学；在经济学中，博弈论，效用理论以及有限性理的运用，也都是研究人类如何以及为什么做出决定，并使这些决定的效用最大化。这些都涉及到上述的强化学习的本质。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　&lt;span&gt;强化学习、监督学习、无监督学习&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;What makes reinforcement learning diﬀerent from other machine learning paradigms?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　1、&lt;span&gt;There is no supervisor, only a reward signal.&lt;/span&gt;&lt;/span&gt; &lt;span&gt;一个显而易见的地方是进行强化学习训练的时候并不存在监督者，没有人会告诉你，什么行为是正确的。那么强化学习的训练是通过什么方式进行的呢？强化学习的训练类似于小孩不断试错的过程，会创建一个agent，没有监督者，但是有奖励信号，根据奖励信号就可以知道什么是对什么是错，但并不知道采取什么措施才是最好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　2、&lt;span&gt;Feedback is delayed, not instantaneous.&lt;/span&gt; 第二个区别是强化学习的反馈并不是立刻得到的，可能会有很大的延迟，因此，在强化学习中，做出的一步决策可能需要在经历很多步之后才能知道这个决策是正确的还是错误的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　3、&lt;span&gt;Time really matters.&lt;/span&gt; 另外，在强化学习的过程中，时间很重要，我们是一步一步的进行的，即agent通过采取相应的措施来制定决策，并计算采取措施后会得到多少奖励，然后agent会尝试修改决策，使得最终的结果尽可能的好。而这一过程，我们不是在讨论独立分布的数据，不像传统的监督学习或非监督学习环境那样，只需将独立分布的数据丢给机器，让机器自己学习就行了。在这里，我们面对的是一个动态的系统，agent要和外部环境进行交互，它的每步举措都会影响下一步的行动，agent会根据环境的影响来采取措施，应对环境的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　4、&lt;span&gt;Agent’s actions aﬀect the subsequent data it receives.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　举几个栗子&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　光说概念肯定会觉得没意思，下面将通过几个已经实现的例子来让你对强化学习有更好的理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　一、直升机的飞行特技表演：通过奖励函数，来告知直升飞机什么是好什么是坏，然后直升飞机去执行那些特技。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　二、backgammon游戏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　三、处理投资组合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　四、控制发电站&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　五、人形机器人行走&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不知道你会不会有个疑问，我之前就存在这个疑问，&lt;span&gt;agent的每次测试是会记住之前的路线，还是重新开始？&lt;/span&gt;事实上每次都是重新开始。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;上述的几个例子在训练过程中都离不开一个东西——Rewards（奖励）。那么，什么是奖励呢?如何定义奖励？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;所谓奖励，它仅仅是一个数字，一个标量的反馈信号，我们用随机变量R&lt;sub&gt;t&lt;/sub&gt;表示，即每一步T对应一个反馈信号R&lt;sub&gt;t&lt;/sub&gt;，表明agent每一步做的怎么样，然后将每一步获得的Rewards加起来，最终获得一个结果。agent的目标就是使这一结果达到最大。当然，我们可能不仅仅只有这一种方法来训练agent，但是，这个方法无疑是适用于解决各种各样问题的。强化学习都遵循这么一种假设的模型 All goals can be described by the maximisation of expected cumulative reward. 因此可以笼统的将强化学习概括为累计求最大化的问题，我们可以通过标量反馈信号来求出最大值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于奖励的定义，比如上面说的直升飞机的特技表演，每当飞机飞行轨迹或者转圈半径符合我们的期望时，就会得到一个正向的奖励，当飞机坠毁时就会得到一个巨大的惩罚。当玩backgammon的时候，胜利了就获得正向奖励，这样agent就会自己寻找获取最大化奖励的方式，让agent尝试不同的决策，以期望在最后获取最大的奖励。对于投资组合问题，奖励信号就是钱，最终利润越大自然越好。对于发电站调控问题，每当产生一单元的电力的时候就获得正向奖励，发电量超过安全上限或是调控不符合预期就获得负向奖励。对于机器人行走，每向前移动一步，就可以获取一个正向的奖励单位，摔倒的时候就获得负向的奖励。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;上述的问题都是不同的，乍一看并不存在一个框架适用于所有的这些问题，但我们的目标就是建立统一的框架，使用机器学习的方法，或是用相同的形式应对各种各样不同的问题，因此，解决这些问题只需要使用相同的agents，相同的想法。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;需要指出的是&lt;/span&gt;，&lt;span&gt;我们需要提前计划，考虑未来&lt;/span&gt;。因为此时的行动的影响可能是长期的，可能现在不是我们想要的结果，但经过了几步之后就变成了想要的结果了。这也就意味着现在需要放弃一些好的奖励，而在不久的未来则会得到更高的奖励（更经典算法里的贪心有些相反）。例如金融投资问题，直升机表演时加油的问题等&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大致的训练过程如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201810/1413964-20181026150720890-1028263745.png&quot; alt=&quot;&quot; width=&quot;818&quot; height=&quot;450&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;span&gt;我们在大脑中创建一个算法即agent，然后再根据周围的环境的影响以及agent的决策，不断进行调整，最终达到目的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　&lt;span&gt;再来几个概念&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;History&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　agent在训练时，一系列的选项序列，观察，行动，奖励，称为history，即agent目前所知道的东西。每一步agent都会采取行动，进行观察，获取奖励一直到第T步，所有的这些过程组成了history，即H&lt;sub&gt;t&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　H&lt;sub&gt;t&lt;/sub&gt; = O&lt;sub&gt;1&lt;/sub&gt;,R&lt;sub&gt;1&lt;/sub&gt;,A&lt;sub&gt;1&lt;/sub&gt;,...,A&lt;sub&gt;t−1&lt;/sub&gt;,O&lt;sub&gt;t&lt;/sub&gt;,R&lt;sub&gt;t&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　后面会发生什么，实际上都取决于history，agent实际上事从history到action的映射，因此，我们的目标就是创建一个映射，算法就是从一个history到下一个action的映射，所以agent接下来的action完全依赖于history。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　　  State&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　然而，history并不是很有用，因为它通常会很巨大，而我们希望agents可以活的更久，可以在很短时间内进行交互，因此，我们要研究的是state，state是对信息的总结，state决定下一步的action，即state包含了我们需要的所有信息，通过这些信息，我们就可以采取下一步的action。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　那么，什么是state呢？每经历一个时间步长T，我们就构建一个状态，它是关于history的函数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　表示为　　&lt;/span&gt;&lt;span&gt;S&lt;sub&gt;t&lt;/sub&gt;=f（H&lt;sub&gt;t&lt;/sub&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;因为state只是关于history的函数，所以state只有经过最后一次观测才能使合理有效的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;再来讲讲state的种类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　1.Environment State：agent所处环境中的信息决定接下来会发生什么，&lt;/span&gt;&lt;span&gt;例如，机器人在和真实的环境进行交互，真实的环境可以抽象为某些数字的集合，这些数字决定了接下来会发生什么；或者说一个Atria模拟器，模拟器内有一些内置的状态，这些状态决定了模拟器下一步的行动。也就是基于目前所知道的东西，由某种数字集合决定了接下来会发生什么事情会存在某种状态来代表此时的所有已知东西，该状态在下一次观测与奖励的时候，又会被重新拆分。但是关于环境，我们需要特别注意的是，环境的状态对于agents并非总是可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201810/1413964-20181026233521287-1200309654.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;506&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　2.agent state：agent state也是数字的集合，这个集合存在于我们的算法当中，通过算法，我们可以使用某个数字的集合，来表示agent目前得到了什么，接下来该采取的action。无论储存什么信息，捕获什么信息，我们都能用agent状态来决定下一步的action。要做的action就是如何处理这些观测信息，应该记住什么，抛弃什么。在创建算法时，我们经常要讨论agent的状态，通过agent的状态来挑选下一步的行动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201810/1413964-20181026235818517-895416472.png&quot; alt=&quot;&quot; width=&quot;779&quot; height=&quot;507&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;3、信息状态：我们有时候将信息状态称之为Markov状态，在我们使用状态表示法的时候，这些state包含history的全部有用信息，我们需要做的就是定义某个具有Markov性质的东西。Markov的定义：A state S&lt;sub&gt;t&lt;/sub&gt; is Markov if and only if P[S&lt;sub&gt;t+1&lt;/sub&gt; | S&lt;sub&gt;t&lt;/sub&gt;] = P[S&lt;sub&gt;t+1&lt;/sub&gt; | S&lt;sub&gt;1&lt;/sub&gt;,...,S&lt;sub&gt;t&lt;/sub&gt;]，即下一时刻的状态仅由当前状态决定，与过去的状态并没有太大的关系，换句话说我们只需保留当前状态。例如之前说过的直升飞机表演的例子，我们会有一个标记，表示直升机当前的位置、速度、角速度、角位置等，而10分钟前的标记对于下一刻的action肯定是没有任何影响的，我们只需要关注当前直升飞机的状态即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201810/1413964-20181027003055356-1522976948.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;511&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　&lt;span&gt;agent　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;　上面讲了那么多，但都只是讲了强化学习中的问题，并没有涉及解决这些问题的方法。现在将谈谈强化学习中的agent。agent大概包含三个函数（当然，并不是所有的agent都要用到）：Policy、Value、Model。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Policy：表明agent能够采取的行动，是一个行为函数，以状态作为输入，下一步的决策作为输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  Value：该函数用来评价agent大某种特殊状态下的好坏，采取某种行动之后的好坏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  Model：用来感知环境如何变化，这里环境指的是agent眼里的环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　在强化学习中，agent间最主要的不同之处就是有无Model，没有Model，就意味着我们不会尝试去理解环境。相反的是，使用policy和value，根据经验找到最优策略。而对于有Model的强化学习模型，第一步是建立一个model来表示环境的工作原理，通过这个model知道接下来会发生什么，并找到最优策略。&lt;/span&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;一、之前说过奖励是有延时的，那么该怎么使用增强学习的方法呢？&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;我们会定义一个目标事件，确定一个阶段的开始与结束，然后为这个阶段定义奖励，事实上奖励只会在每个阶段结束的时候出现，agent的目标就是在一个阶段中采取措施，在阶段结束的时刻得到最大化的奖励。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&lt;strong&gt;二、如果我们的目标是基于时间的，即我们的目标是最短的时间来做某件事，我们该怎么做？&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;一般做法是每经历一个时间步长，都会有一个值为-1的奖励信号，完成目标后就会停下来，总奖励就是耗费的时间，此时我们就有两个目标，一是最大化积累的奖励，二是最短时间达到目标。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;strong&gt;&lt;span&gt;三、有时候会有不同的目标，且目标相互冲突，对于冲突情况该怎么考虑，比如你该去见你的老板（老师）还是女朋友（当然对我来说是不存在的，没有女朋友....）？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;这时候标量的反馈信号足以处理所有的目标了，我们需要给不同的目标赋予不同的权重值，这样我们的agent才能挑选措施采取行动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 17:42:00 +0000</pubDate>
<dc:creator>iTryagain</dc:creator>
<og:description>引言 最近实验室的项目需要用到强化学习的有关内容，就开始学习起强化学习了，这里准备将学习的一些内容记录下来，作为笔记，方便日后忘记了好再方便熟悉，也可供大家参考。该篇为强化学习开篇文章，主要概括一些有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csu-lmw/p/9856626.html</dc:identifier>
</item>
<item>
<title>使用Visual Studio Installer 2015打包WPF程序 - 流浪阿丁</title>
<link>http://www.cnblogs.com/adingfirstlove/p/9859859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adingfirstlove/p/9859859.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做过WPF项目，就少不了要将程序打包部署到客户现场，因为一般长时间不会更新打包程序，每次变动较大需要重新配置打包程序时，就会有些生疏，不那么得心应手。为了方便记忆，记录到博客中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为做过的项目都是用VS2015编写的，所以选择网上使用较多的Visual Studio Installer2015工具。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下载地址：&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=visualstudioclient.MicrosoftVisualStudio2015InstallerProjects&quot; target=&quot;_blank&quot;&gt;Microsoft Visual Studio 2015 Installer Projects extension&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下载完成后，直接运行安装即可。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;打包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.创建打包项目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;右键——&amp;gt;新建项目——&amp;gt;选择其他项目类型——&amp;gt;选择Visual Studio Installer -  Setup Project&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027002720241-703296628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 弹出如下窗体：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027002904507-867346789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 稍微解释一下：&lt;/p&gt;
&lt;p&gt;第一个文件夹包含打包程序的所有文件(dll,ico等）内容，相当于普通项目中的Debug文件夹。&lt;/p&gt;
&lt;p&gt;第二个文件夹包含将要安装者桌面显示的内容，一般以ico图标作为显示。&lt;/p&gt;
&lt;p&gt;第三个文件夹显示在安装者电脑的开始菜单中，一般包含删除卸载程序的文件。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.配置程序信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 选中新建的Setup程序，按F4打开属性窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027003738634-1205429587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般情况，修改Author、Description、Mnufcture、ProductName、Title属性即可，分别代表作者、程序安装时的描述、公司名、产品名、安装引导的标题。Mnufcture和Author将会显示控制面板查看程序时看到。&lt;/p&gt;
&lt;p&gt;注意ProductCode属性，其值关系到卸载。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.程序封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;右键DemoSetup项目，选择View——&amp;gt;文件系统&lt;/p&gt;
&lt;p&gt;选择第一个文件夹，右键Add——&amp;gt;项目输出&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027004722332-1745576231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择你要打包的主程序项目，点击确定。注意这里添加后的文件并不全，可打开项目的Debug文件，对比一下，将缺少的其他文件或文件夹，图片等添加进来。当程序架构分层比较多时，比如界面模块和打包程序不一个项目，可以通过添加内容文件的方式添加进来。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4.联动用户桌面与开始菜单&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;找到主输出 Output(Active)，右键创建快捷方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027005806171-2081934670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 找到刚创建的快捷文件，右键重命名为程序名称，安装完成后，它将显示到你桌面上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027010003490-1436130106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;剪切此文件到文件系统第二个文件夹下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027010101822-1712328445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择快捷方式，打开属性窗口，可添加秒速和等，修改Icon，选择一个ico图标，这个图标可以直接来自文件系统第一个文件夹下。&lt;/p&gt;
&lt;p&gt;选择文件系统第三个文件夹，创建一个文件夹，名字为你的程序名就行。&lt;/p&gt;
&lt;p&gt; 并重复创建一个主输出的快捷方式，粘贴到文件夹下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027010632436-381692605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，比较重要的一步来了，添加删除文件。提供系统卸载程序的功能。&lt;/p&gt;
&lt;p&gt;找到C：Windows\System32\Msiexec.exe这个文件，把他复制到第一个文件夹（应用程序文件夹）下，并修改名字为卸载程序.exe，&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027011137785-37192155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建它的快捷方式，打开快捷方式的属性窗口，填加Arguments值&lt;/p&gt;
&lt;p&gt;一定要按照这个格式来 ,先填入 /x，然后加一个空格，复制上文中要你留意的Setup项目的属性ProductCode参数值，填入空格后面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027011644392-1203310703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;剪切此快捷方式粘贴到文件系统的第三个文件夹（用户开始菜单文件夹），放入你创建的文件夹中。&lt;/p&gt;
&lt;p&gt;此后在创建一份卸载程序的快捷方式，同样添加Arguments值，选择真正的卸载程序文件，打开属性窗口，修改Hidden值为True，让其隐藏。这样用户在打开程序文件夹时，才能真正卸载程序。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 5.最后的配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实还可以修改很多东西，比如自定义用户引导界面了，只是感觉每太有必要，我一般不会去特别设置。&lt;/p&gt;
&lt;p&gt;选择Setup项目右键——&amp;gt;View下的内容，都可以试着改一改，就不一一介绍了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027012652738-1958110245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后，右键Setup项目，选择属性，点击Prerequisites...，设置一个程序必备条件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027012927358-586151231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027012939694-27478288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 确定完成后，整个打包程序的配置就完成了，右键Setup项目，选择重新生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1038506/201810/1038506-20181027013214191-71476795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;等待生成成功后，打开文件所在路径，找到Debug，生成两个文件，一个msi后缀，一个exe后缀，两者的区别就是msi文件安装后自动安装程序必备的.net框架。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;尾声&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;网上也能找到一大堆教程，但总感觉说的不是很明白，虽然我介绍的啰里啰唆，但比较详细。方便我遗忘时回顾。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 17:39:00 +0000</pubDate>
<dc:creator>流浪阿丁</dc:creator>
<og:description>使用Visual Studio Installer2015打包WPF程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adingfirstlove/p/9859859.html</dc:identifier>
</item>
<item>
<title>第一章 第四节 Hello World程序 - 38度6鍀温度</title>
<link>http://www.cnblogs.com/zhiweijq/p/9859163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhiweijq/p/9859163.html</guid>
<description>&lt;h4&gt;1、第一个HelloWorld程序&lt;/h4&gt;
&lt;p&gt;　　上节完成Java环境变量配置之后，我们就可以写第一个程序了。&lt;/p&gt;
&lt;p&gt;　　首先，我们在硬盘上创建一个test.txt文件，并把test.txt文件改成后缀为.java的test.java文件，并用记事本打开，写下如下代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloWorld{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码写完记得保存哦。然后在命令行模式下进入这个.java文件所在的目录，使用javac test.java命令进行编译：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516670/201810/1516670-20181026225332087-827710195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在编译完成之后，会在目录下生成一个相应的HelloWorld.class文件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516670/201810/1516670-20181026225554761-39933843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后，在命令行上，用下面命令来执行：&lt;/p&gt;
&lt;p&gt;java HelloWorkd&lt;/p&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516670/201810/1516670-20181026225826496-1665048426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是，会在屏幕上打印出一个&quot;Hello World&quot;的字符串。如果你是一个初学者，从本微博第一章第一节开始学习，请务必看到Hello World 字符串在继续学习。&lt;/p&gt;
&lt;h5&gt;  1.1、深入了解Hello World程序&lt;/h5&gt;
&lt;p&gt;　　我们首先来研究和分析一下test.java这个程序中的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloWorld{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先，第一行：class HelloWorld，这句话定义了一个名字叫做HelloWorld的类。其中，class是Java语言的关键字，而HelloWorld则是定义这个类的名字。&lt;/p&gt;
&lt;p&gt;　　至于什么是类，这个概念在此不做多于的介绍，会在后面的文章中做出解释，如果你是一个初学者，那么，你可以理解为：类是代码的容器。也就是说，在Java中绝大部分代码都要写在类的范围内，要写代码就必须先定义一个类。&lt;/p&gt;
&lt;p&gt;　　在定义完HelloWorld之后，后面有一对花括号，花括号中内容表示的是这个类中的内容。&lt;/p&gt;
&lt;p&gt;　　在这个花括号中，下面的就是这行：&lt;/p&gt;
&lt;p&gt;　　public static void main(String[] args)&lt;/p&gt;
&lt;p&gt;　　这一行定义了一个主方法（也叫主函数）。主方法的定义比较长，但是非常有用，如果你是一个初学者，这行代码必须记住，也许你现在无法理解这些内容，但是我会在之后的文章中会解释。那么主方法有什么作用呢？我们通常把主方法称之为：程序执行的入口。也就是说，java程序在执行的时候，会执行类中的主方法，当主方法执行完毕之后，程序也就退出了。&lt;/p&gt;
&lt;p&gt;　　在主方法内部，就是下面这句代码：&lt;/p&gt;
&lt;p&gt;　　System.out.println(&quot; Hello world&quot;)；&lt;/p&gt;
&lt;p&gt;　　这是Java的一个语句。注意，每一个Java语句都应当以分号结尾。这个语句含义是在屏幕上打印出一个字符串。这个字符串的内容就是括号中的&quot;Hello World&quot;。并且，这个语句打印完字符串之后，还会进行自动换行，如果不换行，则是 System.out.print(&quot;Hello World&quot;);代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloWorld{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;learn java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516670/201810/1516670-20181026232556187-17112743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出完learn java之后并没有换行。&lt;/p&gt;
&lt;h5&gt;1.2、类与.class文件&lt;/h5&gt;
&lt;p&gt;　　我们注意到，在编译test.java之后，会产生一个名为HelloWorld的.class文件，这个.class文件的文件名与我们在test.java中定义的类名一模一样。换句话说，一个.java文件中定义的每一个类，在编译之后，都会生成一个和类名完全一样的.class文件。这个.class文件不是可执行文件，是&quot;二进制字节码文件&quot;。用文本编辑器是无法正常打开的。&lt;/p&gt;
&lt;p&gt;　　我们在test.java文件中定义两个类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class HelloWorld{
        public static void main(String[] args){
                System.out.print(&quot;learn java&quot;);
                System.out.print(&quot;Hello World&quot;);
        }
}
class Welcome{
        public static void main(String[] args){
                System.out.println(&quot;Welcom to learn java&quot;);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们在命令行中进行编译test.java文件。编译之后，会生成两个.class文件，一个是HelloWorld.class文件和Welcome.class文件。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516670/201810/1516670-20181026234054642-401471281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译之后，运行时，运行的是.class文件，但是需要注意的是，使用的是java + 类名运行，而不能有.class这个后缀。比如，我们要运行Welcome类，则使用的命令是java Welcome而不是java Welcome.class命令，这是很多初学者经常犯的错误。还有要注意的是：我们使用java Welcome运行Welcome类时，JVM需要在硬盘上找到相应的Welcome.class文件。此时，JVM会通过CLASSPATH变量的指示，来寻找.class文件。由于我们把CLASSPATH配置成了一个&quot;.&quot;,这表示当前目录，因此，JVM就会在当前目录下寻找Welcome.class文件。&lt;/p&gt;
&lt;h5&gt; 1.3、类与公开类&lt;/h5&gt;
&lt;p&gt; 　　如果我们给HelloWorld类增加一个前缀：public，则此时，HelloWorld就不是一个普通模的类了，而变成一个公开类。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloWorld{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;learn java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　公开类有自己的特殊性，此时在编译test.java时，则会产生一个编译时的错误，错误如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516670/201810/1516670-20181026235450624-1715093326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个错误说明，如果要使用一个公开类，则公开类的类名必须和源文件名相同（包括大小写）。为了修正这个错误，我们必须把源文件的名字test.java改成HelloWord.java，再次编译才能通过。由于一个.java文件只能有一个文件名，因此一个.java文件中最多只能有一个公开类，当然，如果不是公开类的话，一个.java文件中可以有多个类。&lt;/p&gt;
&lt;p&gt;　　对于从本微博学习的初学者，建议一些忠告：动手敲代码，前期不要使用IDE等强大的编译器，建议使用notepad++等文本编译器。这对你对java初级语法理解十分重要，打下扎实的基础。对你的成长十分重要。。。&lt;/p&gt;



</description>
<pubDate>Fri, 26 Oct 2018 16:13:00 +0000</pubDate>
<dc:creator>38度6鍀温度</dc:creator>
<og:description>1、第一个HelloWorld程序 上节完成Java环境变量配置之后，我们就可以写第一个程序了。 首先，我们在硬盘上创建一个test.txt文件，并把test.txt文件改成后缀为.java的test</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhiweijq/p/9859163.html</dc:identifier>
</item>
<item>
<title>python进阶之内置函数和语法糖触发魔法方法 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/9856309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/9856309.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面已经总结了关键字、运算符与魔法方法的对应关系，下面总结python内置函数对应的魔法方法。&lt;/p&gt;
&lt;h2 id=&quot;魔法方法&quot;&gt;魔法方法&lt;/h2&gt;
&lt;h3 id=&quot;数学计算&quot;&gt;数学计算&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;abs(args):返回绝对值，调用__abs__;
round(args):返回四舍五入的值，调用__round__;
math.floor():向下取整，调用__floor__;
math.ceil():向上取整，调用__ceil__;
math.trunc()：求一个值距离0最近的整数，调用__trunc__;
divmod(a,b):返回商和余，调用__divmod__;
pow(a,b):返回幂，调用__pow__;
sum():返回和，调用__sum__;
float():转换小数，调用__float__;
int():转换整数，调用__int__;
str():转换字符串，调用__str__;
sys.getsizeof():对象占内存的大小，调用__sizeof__;
bin(*args, **kwargs):调用参数的__bin__方法，返回整数的二进制表示形式，只支持一个参数，只支持int类型
hash():调用__hash__方法，获取一个对象的散列值，相等的两个数哈希值相等，反过来不一定成立
hex(*args, **kwargs)：调用__hex__方法，求整数的十六进制表示形式，只支持Int类型
oct(*args, **kwargs)：调用__oct__方法，求整数的八进制表示形式，只支持Int类型&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问控制&quot;&gt;访问控制&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;__getattr__(self, name):getattr方法触发，仅对对象未定义的属性有效，即如果视图获取一个没有的属性时会调用该方法，前提是该对象未定义__getattribute__(self, name)方法；
__getattribute__(self, name)：getattr方法触发，如果对象定义了该方法，一定触发，__getattr__方法将不会被调用；它也可以被self.name语法糖触发；
__setattr__(self, name, value)：setattr方法触发,设置一个对象的属性；也可以被self.name = ''语法糖触发。
__delattr__(self, name)：delattr方法触发,删除一个对象的属性，或由del self.name 形式触发；&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;容器类型&quot;&gt;容器类型&lt;/h3&gt;
&lt;p&gt;在Python中实现自定义容器类型需要用到一些协议。不可变容器类型有如下协议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不可变容器，需要定义 _&lt;em&gt;len_&lt;/em&gt; 和 _&lt;em&gt;getitem_&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;可变容器,需要定义 _&lt;em&gt;len_&lt;/em&gt; 、_&lt;em&gt;getitem_&lt;/em&gt;、_&lt;em&gt;setitem_&lt;/em&gt;、_&lt;em&gt;delitem_&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;容器可迭代，需要定义 _&lt;em&gt;iter_&lt;/em&gt; ；&lt;/li&gt;
&lt;li&gt;迭代器，必须遵守迭代器协议，需要定义 _&lt;em&gt;iter_&lt;/em&gt; 和 _&lt;em&gt;next_&lt;/em&gt; 方法。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;索引语法糖与魔法方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;__len__(self):返回容器的长度；
__getitem__(self, key):使用self[key]形式语法糖获取元素会触发；
__setitem__(self, key):使用self[key] = 'xxx'形式复制会触发；
__delitem__(self, key):使用del self[key]语法糖触发
__reversed__(self):reversed(self)触发，反转容器；
__missing__(self, key)：字典结构使用self[key]形式获取元素，如果元素不存在触发；&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;分片语法糖与魔法方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;切片在底层的原理，py2和py3有很大的不同，py2中使用_&lt;em&gt;getslice_&lt;/em&gt;、_&lt;em&gt;setslice_&lt;/em&gt;、__delslice__三个魔法方法控制，py3中将索引和切片统一由_&lt;em&gt;getitem_&lt;/em&gt;、_&lt;em&gt;setitem_&lt;/em&gt;、__delitem__控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# py2中
ls = [1,2,3,4]
print(ls[1:3]) # py2中该语法糖调用__getslice__方法，py3中废弃
del ls[1:3] # py2中该语法糖调用__delslice__方法，py3中废弃
ls[1:3] = [1,2,2] # py2中该语法糖调用__setslice__方法，py3中废弃&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# py3中
class Person(object):
    def __getitem__(self, item):
        print(item)
        return 'getitem'

    def __setitem__(self, key, value):
        print(key, value)
        return 'setitem'

    def __delitem__(self, key):
        print(key)
        return 'delitem'

if __name__ == &quot;__main__&quot;:
    person = Person()
    print(person[0]) # person[0] ==&amp;gt; person.__getitem__(0)
    print(person[0:2]) # person[0:2] ==&amp;gt; person.__getitem__(slice(0,2,None))
    person[0:2] = 'test' # ==&amp;gt; person.__setitem__(slice(0,2,None), 'test')
    del person[0:2] # ==&amp;gt; person.__delitem__(slice(0,2,None))

# 结果
0
getitem
slice(0, 2, None)
getitem
slice(0, 2, None) test
slice(0, 2, None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;python在处理索引语法糖的时候，将索引当做参数传入相关getitem、setitem、delitem的魔法方法；在处理切片语法糖的时候先调用slice方法得到slice实例对象，将其作为参数调用相关的魔法方法。&lt;/p&gt;
&lt;h3 id=&quot;拷贝&quot;&gt;拷贝&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;__copy__(self):如果对象定义了该方法，copy.copy()就会调用该方法返回拷贝对象；
__deepcopy__(self, x):如果对象定义了该方法，copy.deepcopy()就会调用该方法返回拷贝对象；&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;序列化&quot;&gt;序列化&lt;/h3&gt;
&lt;p&gt;序列化我们可以简单理解成对任何数据的一种描述方法，如果多种平台遵循了相同的序列化协议，数据之间的传递就会变得方便。python默认的序列化模块为pickle。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;序列化的简单例子&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Person(object):
    def __init__(self):
        self.name = 'cai'

if __name__ == &quot;__main__&quot;:
    import pickle
    person = Person()
    with open('./person.txt', 'wb') as f:
        # 序列化后存储
        pickle.dump(person,f)

    with open('./person.txt', 'rb') as f:
        # 反序列化
        per = pickle.load(f)
        print(per.name)

# 我们可以把一个类保存起来，后续读取它直接使用。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;相关的魔法方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;__getinitargs__(self):该魔法方法在py3中似乎被废弃，原本的功能是在序列化时获取实例化参数，应该返回一个元组；
__getnewargs__(self)：对新式类，通过这个方法改变类在反pickle时传递给__new__ 的参数；应该返回一个参数元组。
__getstate__(self):定义对象被序列化时的状态，而不使用对象的 __dict__ 属性，必须返回一个字典，他会去替代 __dict__ 属性，在序列化时被调用；
__setstate__(self,state)：当一个对象被反pickle时，如果定义了 __setstate__ ，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 __dict__ 属性， state参数是序列化前的__dict__属性。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Person(object):
    def __init__(self,name):
        print('init')
        self.name = name

    def __getinitargs__(self):
        print('initargs')
        return 'zhao',

    def __getnewargs__(self):
        print('newargs')
        return 'wang',

    def __getstate__(self):
        print('getstate')
        return {'name':'xiao'}

    def __setstate__(self, state):
        print('setstate')
        print(state)
        self.__dict__ = state

if __name__ == &quot;__main__&quot;:
    import pickle
    person = Person('cai')
    with open('./person.txt', 'wb') as f:
        # 序列化后存储
        pickle.dump(person,f)

    with open('./person.txt', 'rb') as f:
        # 反序列化
        per = pickle.load(f)
        print(per.name)

# 结果
__new__
init
newargs
getstate
__new__
setstate
{'name': 'xiao'}
xiao&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;pickle序列化对象之前，先执行__getnewargs__或__new__方法的参数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后执行__getstate__方法，返回的值替代对象的__dict__属性值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;反序列化时调用new方法，以getnewargs返回的值作为参数创建实例；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后调用__setstate__方法，将getstate方法的返回值作为state参数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所以由于反序列化时不会调用init方法初始化，getinitargs和getnewargs方法的作用都变得不大；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;__instancecheck__(self, instance):instance触发,判断对象的类型
__subclasscheck__(self, subclass):issubclass触发，判断一个对象是另一个对象的子类；
__call__:callable触发，判断一个对象是否可调用；
__dir__(self):dir()触发，获取对象的所有属性、方法的名字组成的列表；&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;__str__和__repr__&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用str触发_&lt;em&gt;str_&lt;/em&gt;，调用repr()触发_&lt;em&gt;repr_&lt;/em&gt;,但是print()也可以触发__str__和__repr__，如果对象定义了_&lt;em&gt;str_&lt;/em&gt;，则print()一般触发_&lt;em&gt;str_&lt;/em&gt;，否则触发_&lt;em&gt;repr_&lt;/em&gt;；但列表以及字典等容器总是会使用_&lt;em&gt;repr_&lt;/em&gt; 方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__str__和__repr__的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一般来说，_&lt;em&gt;str_&lt;/em&gt; 的返回结果在于强可读性，而 _&lt;em&gt;repr_&lt;/em&gt; 的返回结果在于准确性;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;默认情况下，在需要却找不到 __str__方法的时候，会自动调用 _&lt;em&gt;repr_&lt;/em&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;熟悉了python语法糖、内置函数与魔法方法之间的关系后，显然对于如何写好一个优雅易用的类有很大的帮助。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Fri, 26 Oct 2018 15:56:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<og:description>前言 前面已经总结了关键字、运算符与魔法方法的对应关系，下面总结python内置函数对应的魔法方法。 魔法方法 数学计算 访问控制 容器类型 在Python中实现自定义容器类型需要用到一些协议。不可变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/9856309.html</dc:identifier>
</item>
<item>
<title>你知道吗， CoreGraphics绘图系统和Bezier贝塞尔曲线坐标系的顺时针方向是相反的！ - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/9859244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/9859244.html</guid>
<description>&lt;p&gt;UIBezierPath是对Core Graphics框架的一种上层封装，目的是让绘图需求可以被更方便的使用。&lt;/p&gt;
&lt;p&gt;那你有没有发现被UIBezierPath封装后与之前有什么改变？&lt;/p&gt;
&lt;p&gt;答：有三个变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.屏蔽繁杂重复的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.功能阉割&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.坐标系顺时针方向反转&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;证明1:屏蔽繁杂重复的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比Core Graphics框架，UIBezierPath帮我们做了一些繁琐的事件。比如有这样一个场景：需要画一个圆，但是它的每个1/4弧线的strokpath颜色是不同的。对于这样的需求。&lt;/p&gt;
&lt;p&gt;有个错误的做法是：&lt;/p&gt;
&lt;p&gt;1.拿到上下文&lt;/p&gt;
&lt;p&gt;2.设置第一个1/4户的strokpath颜色，用上下文绘制第一个1/4弧&lt;/p&gt;
&lt;p&gt;3.设置第一个2/4户的strokpath颜色，用上下文绘制第一个2/4弧&lt;/p&gt;
&lt;p&gt;4.设置第一个3/4户的strokpath颜色，用上下文绘制第一个3/4弧&lt;/p&gt;
&lt;p&gt;5.设置第一个4/4户的strokpath颜色，用上下文绘制第一个4/4弧&lt;/p&gt;
&lt;p&gt;最后的结果会发现，这四段弧的颜色是最后一个4/4弧的strokpath的颜色&lt;/p&gt;
&lt;p&gt;原因是：对于一个上下文来说，strokPathColor属性只有一个，虽然设置了4次，但总是后面的覆盖前面的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一种解决方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在第2步之前，先循环4次操作&lt;/p&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let content =&lt;span&gt; UIGraphicsGetCurrentContext()
content&lt;/span&gt;?&lt;span&gt;.setStrokeColor(UIColor.blue.cgColor)
content&lt;/span&gt;?.saveGState()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在每一步绘制前，恢复上下文栈中的存储到当前上下文&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
content?.restoreGState()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;另一种解决方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接创建4个UIBezierPath，用贝塞尔曲线绘制着4段弧。&lt;/p&gt;
&lt;p&gt;这样就很直观的看出，每个UIBezierPath的上下文都是独立的。内部帮我们自己做了上下文的存栈和出栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;证明2:功能阉割&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然有了UIBezierPath的封装我们用起来方便了，但是相应的代价是所提供的功能被阉割了。有些强大的功能UIBezierPath没有提供实现，比如：现在要画一个圆形的渐变球，就只能使用Core Graphics框架。&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;25.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用上下文绘制渐变色（圆形）&lt;/span&gt;
let context =&lt;span&gt; UIGraphicsGetCurrentContext()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色空间&lt;/span&gt;
let colorSpace =&lt;span&gt; CGColorSpaceCreateDeviceRGB()
let startColor &lt;/span&gt;=&lt;span&gt; UIColor.black
let endColor &lt;/span&gt;=&lt;span&gt; UIColor.red
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色数组&lt;/span&gt;
let colors =&lt;span&gt; [startColor.cgColor,endColor.cgColor]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色所处位置&lt;/span&gt;
let locations:[CGFloat] = [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
let gradient &lt;/span&gt;= CGGradient(colorsSpace: colorSpace, colors: colors &lt;span&gt;as&lt;/span&gt;!&lt;span&gt; CFArray, locations: locations)
let center &lt;/span&gt;= CGPoint(x: rect.size.width*&lt;span&gt;0.5&lt;/span&gt;, y: rect.size.height*&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)
let radius &lt;/span&gt;= rect.size.height*&lt;span&gt;0.3&lt;/span&gt;&lt;span&gt;
context&lt;/span&gt;?.drawRadialGradient(gradient!, startCenter: center, startRadius: radius*&lt;span&gt;0.2&lt;/span&gt;, endCenter: center, endRadius: radius, options: CGGradientDrawingOptions.drawsBeforeStartLocation)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;证明3:坐标系顺时针方向反转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你知道吗， CoreGraphics绘图系统和Bezier贝塞尔曲线坐标系的顺时针方向是相反的！&lt;/p&gt;

&lt;p&gt;我记得上学时老师讲的坐标系是这样的： &lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026225558664-533989020.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;X轴指向右侧，Y轴指向上面。对应的弧度如图上标的那样。顺时针也是钟表表针转动的方向。这就是最早接触的坐标系，熟悉的单纯模样。&lt;/p&gt;

&lt;p&gt;在工作时，当我们往屏幕上布局UI时，用到的坐标系是下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026225647819-342921351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于UI控件来讲的坐标系模式，X轴方向向右，Y轴方向向下。&lt;/p&gt;
&lt;p&gt;请注意弧度值也相应的转了方向，它是沿着X，Y指向的方向开始逐渐增加的。&lt;/p&gt;
&lt;p&gt;顺时针还是熟悉的钟表表针转动方向。&lt;/p&gt;

&lt;p&gt;关键代码如下：&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        let content =&lt;span&gt; UIGraphicsGetCurrentContext()

        var endAngl &lt;/span&gt;= _progressValue*CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        var clockState &lt;/span&gt;= (_direction ==&lt;span&gt; .onTime)
       
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆&lt;/span&gt;
        var des: String = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        des &lt;/span&gt;= clockState ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UIGraphics上下文绘制、顺时针&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UIGraphics上下文绘制、逆时针”&lt;/span&gt;
&lt;span&gt;
        content&lt;/span&gt;?.move(to: CGPoint(x: width-arcRadius, y: height*&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;))
        let bez &lt;/span&gt;= UIBezierPath(arcCenter: arcCenter, radius: arcRadius, startAngle: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, endAngle: endAngl, clockwise: clockState)
            content&lt;/span&gt;?&lt;span&gt;.addPath(bez.cgPath)

        NSString(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;: des).draw(&lt;span&gt;in&lt;/span&gt;: CGRect(x: &lt;span&gt;2&lt;/span&gt;, y: &lt;span&gt;2&lt;/span&gt;, width: width*&lt;span&gt;0.4&lt;/span&gt;, height: height*&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;), withAttributes: atts)
        log &lt;/span&gt;= String(format: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;绘制弧度: %.4f Pi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, endAngl/&lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;)
        
        content&lt;/span&gt;?.strokePath()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026225836211-1441056445.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UIBezierPath顺时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230001324-1006814804.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;UIBezierPath逆时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;p&gt;然后突出的CoreGraphics表示不服，我就要与众不同。如下图：&lt;/p&gt;
&lt;div readability=&quot;28.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230029591-338446287.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;说出来你可能不信，你会发现顺时针方向往上了。这明明是逆时针方向啊！WTF？&lt;/p&gt;
&lt;p&gt;来看下代码和实现效果吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
       let content = UIGraphicsGetCurrentContext()

        var endAngl = _progressValue*CGFloat(M_PI*2)
        var clockState = (_direction == .onTime)
       
        //圆
        var des: String = &quot;&quot;
        des = clockState ? &quot;UIGraphics上下文绘制、顺时针&quot; : &quot;UIGraphics上下文绘制、逆时针”

        content?.move(to: CGPoint(x: width-arcRadius, y: height*0.5))
        content?.addArc(center: arcCenter, radius: arcRadius, startAngle: 0, endAngle: endAngl, clockwise: clockState)

        NSString(string: des).draw(in: CGRect(x: 2, y: 2, width: width*0.4, height: height*0.5), withAttributes: atts)
        log = String(format: &quot;绘制弧度: %.4f Pi&quot;, endAngl/3.14)
        
        content?.strokePath()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230155111-1371409861.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CoreGraphics顺时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230234697-1384836494.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CoreGraphics逆时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;p&gt;CoreGraphics和Bezier贝塞尔曲线都是平时开发中的利器，认真品味一下两者的区别，会让我们对它们有更深的认识。&lt;/p&gt;
&lt;p&gt;有讲的不对的地方欢迎指正。&lt;/p&gt;
&lt;p&gt;Demo地址：https://github.com/zhfei/CoordinateSystem&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 26 Oct 2018 15:11:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>UIBezierPath是对Core Graphics框架的一种上层封装，目的是让绘图需求可以被更方便的使用。 那你有没有发现被UIBezierPath封装后与之前有什么改变？ 答：有三个变化。 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/9859244.html</dc:identifier>
</item>
<item>
<title>Netty实现高性能IOT服务器(Groza)之精尽代码篇中 - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/9859030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/9859030.html</guid>
<description>&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded md-expand&quot; data-src=&quot;/home/james/IdeaProjects/netty-learning-example/pic/blueprint-company-concept-7366.jpg&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220623730-1639489753.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;运行环境:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;JDK 8+&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Maven 3.0+&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;技术栈:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IDE:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;IDEA或者Eclipse&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Lombok插件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;近年来，物联网高歌猛进，美国有“工业互联网”，德国有“工业4.0”，我国也有“中国制造2025”，这背后都是云计算、大数据。据波士顿咨询报告，单单中国制造业，云计算、大数据、人工智能等新技术就能为其带来高达6万亿的额外附加值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;国内外巨头纷纷驻足工业互联网，国外如亚马逊AWS、微软Azure，国内则是三大电信运营商、百度云、华为、金山云等，其中腾讯云、阿里云最甚，还拉来了传统制造大佬,国内巨头纷纷在物联网上布局。在2018云栖-深圳峰会上，阿里巴巴资深副总裁，阿里云总裁胡晓明宣布阿里巴巴将正式进军IoT。胡晓明表示，IoT是阿里巴巴集团继电商、金融、物流、云计算之后的一条新的主赛道。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;以上这些内容，作者作为一个开发人员，并不是一个投资人员和创业先锋。并不太关系这些具体细节。我所关心的是如何用技术去&lt;span&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;span&gt;或者&lt;span&gt;&lt;strong&gt;模拟&lt;/strong&gt;&lt;span&gt;一个支持百万链接的IOT服务器,并不严谨，仅做大家参考。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关于为什么选用下图的中间件或者对MQTT不太了解的话,可以阅读我之前的2篇文章:&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-0.010204081632653&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sanshengshui/p/9797352.html&quot;&gt;&lt;span&gt;IOT高性能服务器实现之路&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sanshengshui/p/9826009.html&quot;&gt;&lt;span&gt;Netty实现高性能IOT服务器(Groza)之手撕MQTT协议篇上&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;技术轮廓图&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/IdeaProjects/netty-learning-example/pic/netty-iot.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220601301-1163557282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;运行测试&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;md-end-block&quot;&gt;&lt;span&gt;git clone &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://github.com/sanshengshui/netty-learning-example&quot;&gt;https://github.com/sanshengshui/netty-learning-example&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;cd netty-iot&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;运行 NettyIotApplication&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;打开 &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://localhost:8080/groza/v1/123456/auth,&quot;&gt;http://localhost:8080/groza/v1/123456/auth,&lt;/a&gt;获取密码！&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/auth.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220458826-1969346935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/auth.png&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;启动Eclipse Paho,并填写用户名和密码，即可连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;另起一个Eclipse Paho,订阅随意主题,例如test。另一个Eclipse Paho发布主题test。即可收到消息。&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;取消主题订阅，再次发布消息。就收不到消息。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220537362-1139204975.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/%E7%9B%91%E6%8E%A7%E5%8F%B0.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;有了前面2篇文章的铺垫并学习了MQTT V3.1.1 协议,说了那么多，手痒痒的很。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;You build it, You run it！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;项目结构介绍&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 netty-&lt;span&gt;iot
        ├── auth &lt;/span&gt;--&lt;span&gt; 认证
          ├── service &lt;/span&gt;--&lt;span&gt; 用户名,密码认证实现类
          ├── util &lt;/span&gt;--&lt;span&gt; 认证工具类
        ├── common &lt;/span&gt;--&lt;span&gt; 公共类
          ├── auth &lt;/span&gt;--&lt;span&gt; 用户名,密码认证接口
          ├── message &lt;/span&gt;--&lt;span&gt; 协议存储实体及接口类
          ├── session &lt;/span&gt;--&lt;span&gt; session存储实体及接口类
          ├── subscribe &lt;/span&gt;--&lt;span&gt; 订阅存储实体及接口类
        ├── config &lt;/span&gt;--&lt;span&gt; Redis配置
        ├── protocol &lt;/span&gt;--&lt;span&gt; MQTT协议实现
        ├── server &lt;/span&gt;--&lt;span&gt; MQTT服务器
        ├── store &lt;/span&gt;--&lt;span&gt; Redis数据存储
          ├── cache 
          ├── message 
          ├── session
          ├── subscribe
        ├── web &lt;/span&gt;--&lt;span&gt; web服务
        ├── NettyIotApplication &lt;/span&gt;-- 服务启动类
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用 Docker 安装。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通过 Github 源码编译。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-0.8953488372093&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果读者懒于安装操作，也可以使用网页版的 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://try.redis.io/&quot;&gt;&lt;span&gt;Web Redis&lt;/span&gt;&lt;/a&gt; &lt;span&gt;直接体验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;具体操作如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Docker 方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  # 拉取 redis 镜像
  &lt;/span&gt;&amp;gt;&lt;span&gt; docker pull redis
  # 运行 redis 容器
  &lt;/span&gt;&amp;gt; docker run --name myredis -d -p6379:6379&lt;span&gt; redis
  # 执行容器中的 redis&lt;/span&gt;-&lt;span&gt;cli，可以直接使用命令行操作 redis
  &lt;/span&gt;&amp;gt; docker exec -it myredis redis-cli...
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Github 源码编译方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  # 下载源码
  &lt;/span&gt;&amp;gt; git clone --branch 2.8 --depth 1 git@github.com:antirez/&lt;span&gt;redis.git
  &lt;/span&gt;&amp;gt;&lt;span&gt; cd redis
  # 编译
  &lt;/span&gt;&amp;gt;&lt;span&gt; make
  &lt;/span&gt;&amp;gt;&lt;span&gt; cd src
  # 运行服务器，daemonize表示在后台运行
  &lt;/span&gt;&amp;gt; ./redis-server --&lt;span&gt;daemonize yes
  # 运行命令行
  &lt;/span&gt;&amp;gt; ./redis-cli...
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;直接安装方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  # mac
  &lt;/span&gt;&amp;gt;&lt;span&gt; brew install redis
  # ubuntu
  &lt;/span&gt;&amp;gt; apt-&lt;span&gt;get install redis
  # redhat
  &lt;/span&gt;&amp;gt;&lt;span&gt; yum install redis
  # 运行客户端
  &lt;/span&gt;&amp;gt; redis-cli
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Spring Boot&lt;span&gt;&lt;code&gt;除了支持常见的ORM框架外，更是对常用的中间件提供了非常好封装，随着&lt;/code&gt;&lt;span&gt;Spring Boot2.x&lt;span&gt;&lt;code&gt;的到来，支持的组件越来越丰富，也越来越成熟，其中对&lt;/code&gt;&lt;span&gt;Redis&lt;span&gt;&lt;code&gt;的支持不仅仅是丰富了它的API，更是替换掉底层&lt;/code&gt;&lt;span&gt;Jedis&lt;span&gt;&lt;code&gt;的依赖，取而代之换成了&lt;/code&gt;&lt;span&gt;Lettuce(生菜),大家可以参考这篇&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/memmsc/article/details/80523376&quot;&gt;&lt;span&gt;文章&lt;/span&gt;&lt;/a&gt;&lt;span&gt;对工程进行配置。所以我使用Lettuce作为客户端来对我的MQTT协议传输的消息进行缓存。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下列的是Redis所对应的操作方式&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForValue： 对应 String（字符串）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForZSet： 对应 ZSet（有序集合）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForHash： 对应 Hash（哈希）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForList： 对应 List（列表）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForSet： 对应 Set（集合）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForGeo： 对应 GEO（地理位置）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我主要使用&lt;span&gt;&lt;strong&gt;opsForValue&lt;/strong&gt;&lt;span&gt;,&lt;span&gt;&lt;strong&gt;opsForHash&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;opsForZSet&lt;/strong&gt;&lt;span&gt;，对于字符串。我推荐使用&lt;span&gt;&lt;strong&gt;StringRedisTemplate&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;以下对于opsForValue和opsForHash的基础操作，我在这里简短的讲解一下。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Redis的Hash数据机构&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Redis的散列可以让用户将多个键值对存储到一个Redis键里面。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;public interface HashOperations&amp;lt;H,HK,HV&amp;gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;HashOperations提供一系列方法操作hash：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
 java &amp;gt; template.opsForHash().put(&quot;books&quot;,&quot;java&quot;,&quot;think in java&quot;&lt;span&gt;);
  redis&lt;/span&gt;-cli &amp;gt; hset books java &quot;think in java&quot;&lt;span&gt;  # 命令行的字符串如果包含空格，要用引号括起来
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().put(&quot;books&quot;,&quot;golang&quot;,&quot;concurrency in go&quot;&lt;span&gt;);
  redis&lt;/span&gt;-cli &amp;gt; hset books golang &quot;concurrency in go&quot;&lt;span&gt;
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().put(&quot;books&quot;,&quot;python&quot;,&quot;python cookbook&quot;&lt;span&gt;);
  redis&lt;/span&gt;-cli &amp;gt; hset books python &quot;python cookbook&quot;&lt;span&gt;
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().entries(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; hgetall books  # entries()，key 和 value 间隔出现
  &lt;/span&gt;1) &quot;java&quot;
  2) &quot;think in java&quot;
  3) &quot;golang&quot;
  4) &quot;concurrency in go&quot;
  5) &quot;python&quot;
  6) &quot;python cookbook&quot;
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().size(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; hlen books
  (integer) &lt;/span&gt;3
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().get(&quot;redisHash&quot;,&quot;age&quot;&lt;span&gt;)
  redi&lt;/span&gt;-cli &amp;gt;&lt;span&gt; hget books java
  &lt;/span&gt;&quot;think in java&quot;
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt;&lt;span&gt; 
  Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; testMap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        testMap.put(&lt;/span&gt;&quot;java&quot;,&quot;effective java&quot;&lt;span&gt;);
        testMap.put(&lt;/span&gt;&quot;python&quot;,&quot;learning python&quot;&lt;span&gt;);
        testMap.put(&lt;/span&gt;&quot;golang&quot;,&quot;modern golang programming&quot;&lt;span&gt;);
  template.opsForHash().putAll(&lt;/span&gt;&quot;books&quot;&lt;span&gt;,testMap);
  redis&lt;/span&gt;-cli &amp;gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot;&lt;span&gt;  # 批量 set
  OK...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Redis的Set数据结构&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
java &amp;gt; template.opsForSet().add(&quot;python&quot;,&quot;java&quot;,&quot;golang&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; sadd books python java golang
  (integer) &lt;/span&gt;3
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().members(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; smembers books  # 注意顺序，和插入的并不一致，因为 set 是无序的
  &lt;/span&gt;1) &quot;java&quot;
  2) &quot;python&quot;
  3) &quot;golang&quot;
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().isMember(&quot;books&quot;,&quot;java&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; sismember books java  # 查询某个 value 是否存在，相当于 contains(o)
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().size(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; scard books  # 获取长度相当于 count()
  (integer) &lt;/span&gt;3
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().pop(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; spop books  # 弹出一个
  &lt;/span&gt;&quot;java&quot;...
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
 
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;MQTT&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;MQTT是一种轻量级的发布/订阅消息传递协议，最初由IBM和Arcom（后来成为Eurotech的一部分）于1998年左右创建。现在，&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html&quot;&gt;&lt;span&gt;MQTT 3.1.1规范&lt;/span&gt;&lt;/a&gt;&lt;span&gt;已由&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.oasis-open.org/committees/mqtt/charter.php&quot;&gt;&lt;span&gt;OASIS联盟&lt;/span&gt;&lt;/a&gt;&lt;span&gt;标准化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;客户端下载&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026221123345-1465421653.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E4%B8%8B%E8%BD%BD/paho_logo_400.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对于MQTT客户端，我选用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://www.eclipse.org/paho/&quot;&gt;&lt;span&gt;Eclipse Paho&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,Eclipse Paho项目提供针对物联网（IoT）的新的，现有的和新兴的应用程序的MQTT和MQTT-SN消息传递协议的开源客户端实现。具体&lt;span class=&quot; md-link&quot;&gt;&lt;a&gt;&lt;span&gt;下载地址&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,大家根据自己的操作系统自行下载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;MQTT控制报文&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  ├── Connect --&lt;span&gt; 连接服务端
  ├── DisConnect &lt;/span&gt;--&lt;span&gt; 断开连接
  ├── PingReq &lt;/span&gt;--&lt;span&gt; 心跳请求
  ├── PubAck &lt;/span&gt;--&lt;span&gt; 发布确认
  ├── PubComp &lt;/span&gt;--&lt;span&gt; 发布完成(QoS2,第散步)
  ├── Publish &lt;/span&gt;--&lt;span&gt; 发布消息
  ├── PubRec &lt;/span&gt;--&lt;span&gt; 发布收到(QoS2,第一步)
  ├── PubRel &lt;/span&gt;--&lt;span&gt; 发布释放(QoS2,第二步)
  ├── Subscribe &lt;/span&gt;--&lt;span&gt; 订阅主题
  ├── UnSubscribe &lt;/span&gt;-- 取消订阅
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
Connect
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;让我们对照着MQTT 3.1.1协议来实现客户端Connect协议。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;6&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当我们对消息解码时，如果协议名不正确服务端&lt;span&gt;&lt;strong&gt;可以&lt;/strong&gt;&lt;span&gt;断开客户端的连接，按照本规范，服务端&lt;span&gt;&lt;strong&gt;不能&lt;/strong&gt;&lt;span&gt;继续处理CONNECT报。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;9.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息解码器出现异常&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (msg.decoderResult().isFailure()) {
              Throwable cause &lt;/span&gt;=&lt;span&gt; msg.decoderResult().cause();
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cause &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MqttUnacceptableProtocolVersionException) {
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不支持的协议版本&lt;/span&gt;
                  MqttConnAckMessage connAckMessage =&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                  channel.writeAndFlush(connAckMessage);
                  channel.close();
                  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
              } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cause &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MqttIdentifierRejectedException) {
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不合格的clientId&lt;/span&gt;
                  MqttConnAckMessage connAckMessage =&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                  channel.writeAndFlush(connAckMessage);
                  channel.close();
                  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
              }
              channel.close();
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;clientId为空或null的情况, 这里要求客户端必须提供clientId, 不管cleanSession是否为1, 此处没有参考标准协议实现&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
  &lt;span&gt;    &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StrUtil.isBlank(msg.payload().clientIdentifier())) {
              MqttConnAckMessage connAckMessage &lt;/span&gt;=&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
              channel.writeAndFlush(connAckMessage);
              channel.close();
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;10&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;用户名和密码验证, 这里要求客户端连接时必须提供用户名和密码, 不管是否设置用户名标志和密码标志为1, 此处没有参考标准协议实现&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
  &lt;span&gt;        &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
   String username =&lt;span&gt; msg.payload().userName();
             String password &lt;/span&gt;= msg.payload().passwordInBytes() == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(msg.payload().passwordInBytes(), CharsetUtil.UTF_8);
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;grozaAuthService.checkValid(username,password)) {
                 MqttConnAckMessage connAckMessage &lt;/span&gt;=&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                 channel.writeAndFlush(connAckMessage);
                 channel.close();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
             }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ol-list&quot; start=&quot;5&quot; readability=&quot;1.9938461538462&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果会话中已存储这个新连接的clientId, 就关闭之前该clientId的连接&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (grozaSessionStoreService.containsKey(msg.payload().clientIdentifier())){
              SessionStore sessionStore &lt;/span&gt;=&lt;span&gt; grozaSessionStoreService.get(msg.payload().clientIdentifier());
              Channel previous &lt;/span&gt;=&lt;span&gt; sessionStore.getChannel();
              Boolean cleanSession &lt;/span&gt;=&lt;span&gt; sessionStore.isCleanSession();
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cleanSession){
                  grozaSessionStoreService.remove(msg.payload().clientIdentifier());
                  grozaSubscribeStoreService.removeForClient(msg.payload().clientIdentifier());
                  grozaDupPublishMessageStoreService.removeByClient(msg.payload().clientIdentifier());
                  grozaDupPubRelMessageStoreService.removeByClient(msg.payload().clientIdentifier());
              }
              previous.close();
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;处理遗嘱信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 SessionStore sessionStore = &lt;span&gt;new&lt;/span&gt; SessionStore(msg.payload().clientIdentifier(), channel, msg.variableHeader().isCleanSession(), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (msg.variableHeader().isWillFlag()){
              MqttPublishMessage willMessage &lt;/span&gt;=&lt;span&gt; (MqttPublishMessage) MqttMessageFactory.newMessage(
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.PUBLISH,&lt;span&gt;false&lt;/span&gt;, MqttQoS.valueOf(msg.variableHeader().willQos()),msg.variableHeader().isWillRetain(),0&lt;span&gt;),
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttPublishVariableHeader(msg.payload().willTopic(),0&lt;span&gt;),
                      Unpooled.buffer().writeBytes(msg.payload().willMessageInBytes())
              );
              sessionStore.setWillMessage(willMessage);
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;处理连接心跳包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;if&lt;/span&gt; (msg.variableHeader().keepAliveTimeSeconds() &amp;gt; 0&lt;span&gt;){
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channel.pipeline().names().contains(&quot;idle&quot;&lt;span&gt;)){
                  channel.pipeline().remove(&lt;/span&gt;&quot;idle&quot;&lt;span&gt;);
              }
              channel.pipeline().addFirst(&lt;/span&gt;&quot;idle&quot;,&lt;span&gt;new&lt;/span&gt; IdleStateHandler(0, 0, Math.round(msg.variableHeader().keepAliveTimeSeconds() * 1.5f&lt;span&gt;)));
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
至此存储会话消息及返回接受客户端连接 将clientId存储到channel的map中
&lt;/pre&gt;&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;3.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;grozaSessionStoreService.put(msg.payload().clientIdentifier(),sessionStore);
          channel.attr(AttributeKey.valueOf(&lt;/span&gt;&quot;clientId&quot;&lt;span&gt;)).set(msg.payload().clientIdentifier());
          Boolean sessionPresent &lt;/span&gt;= grozaSessionStoreService.containsKey(msg.payload().clientIdentifier()) &amp;amp;&amp;amp; !&lt;span&gt;msg.variableHeader().isCleanSession();
          MqttConnAckMessage okResp &lt;/span&gt;=&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK,&lt;span&gt;false&lt;/span&gt;,MqttQoS.AT_MOST_ONCE,&lt;span&gt;false&lt;/span&gt;,0&lt;span&gt;),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_ACCEPTED,sessionPresent),
                  &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
          );
          channel.writeAndFlush(okResp);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;10.905689789556&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果cleanSession为0, 需要重发同一clientId存储的未完成的QoS1和QoS2的DUP消息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;msg.variableHeader().isCleanSession()){
              List&lt;/span&gt;&amp;lt;DupPublishMessageStore&amp;gt; dupPublishMessageStoreList =&lt;span&gt; grozaDupPublishMessageStoreService.get(msg.payload().clientIdentifier());
              List&lt;/span&gt;&amp;lt;DupPubRelMessageStore&amp;gt; dupPubRelMessageStoreList =&lt;span&gt; grozaDupPubRelMessageStoreService.get(msg.payload().clientIdentifier());
              dupPublishMessageStoreList.forEach(dupPublishMessageStore &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                  MqttPublishMessage publishMessage &lt;/span&gt;=&lt;span&gt; (MqttPublishMessage)MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.PUBLISH,&lt;span&gt;true&lt;/span&gt;,MqttQoS.valueOf(dupPublishMessageStore.getMqttQoS()),&lt;span&gt;false&lt;/span&gt;,0&lt;span&gt;),
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MqttPublishVariableHeader(dupPublishMessageStore.getTopic(),dupPublishMessageStore.getMessageId()),
                          Unpooled.buffer().writeBytes(dupPublishMessageStore.getMessageBytes())
                  );
                  channel.writeAndFlush(publishMessage);
              });
              dupPubRelMessageStoreList.forEach(dupPubRelMessageStore &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                  MqttMessage pubRelMessage &lt;/span&gt;=&lt;span&gt; MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.PUBREL,&lt;span&gt;true&lt;/span&gt;,MqttQoS.AT_MOST_ONCE,&lt;span&gt;false&lt;/span&gt;,0&lt;span&gt;),
                          MqttMessageIdVariableHeader.from(dupPubRelMessageStore.getMessageId()),
                          &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                  );
                  channel.writeAndFlush(pubRelMessage);
              });
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;其他MQTT报文大家对照着工程并对照着&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://juejin.im/post/5bcc4e1ce51d457a0e17c908&quot;&gt;&lt;span&gt;MQTT v3.1.1&lt;/span&gt;&lt;/a&gt;&lt;span&gt;自行查看!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;用户名密码认证&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * 用户名和密码认证服务
   * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 穆书伟
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @Service
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AuthServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GrozaAuthService {
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RSAPrivateKey privateKey;
  ​
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkValid(String username, String password) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(username)){
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(password)){
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          }
          RSA rsa &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RSA(privateKey,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          String value &lt;/span&gt;=&lt;span&gt; rsa.encryptBcd(username, KeyType.PrivateKey);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value.equals(password) ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      }
  ​
      @PostConstruct
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
          privateKey &lt;/span&gt;= IoUtil.readObj(AuthServiceImpl.&lt;span&gt;class&lt;/span&gt;.getClassLoader().getResourceAsStream(&quot;keystore/auth-private.key&quot;&lt;span&gt;));
      }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关于Netty实现高性能IOT服务器(Groza)之精尽代码篇中详解到这里就结束了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下文会带大家推进Netty实现MQTT协议的IOT服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;版权声明:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;作者：穆书伟&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;博客园出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sanshengshui&quot;&gt;https://www.cnblogs.com/sanshengshui&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;github出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://github.com/sanshengshui&quot;&gt;https://github.com/sanshengshui&lt;/a&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;个人博客出处：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;https://sanshengshui.github.io/&quot;&gt;https://sanshengshui.github.io/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 14:13:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>运行环境: JDK 8+ Maven 3.0+ Redis JDK 8+ Maven 3.0+ Redis 技术栈: SpringBoot 2.0+ Redis (Lettuce客户端,RedisTe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshengshui/p/9859030.html</dc:identifier>
</item>
<item>
<title>Java入门系列-21-多线程 - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/9858875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/9858875.html</guid>
<description>&lt;h2 id=&quot;什么是线程&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;在操作系统中，一个应用程序的执行实例就是&lt;strong&gt;进程&lt;/strong&gt;，进程有独立的内存空间和系统资源，在任务管理器中可以看到进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;是CPU调度和分派的基本单位，也是进程中执行运算的最小单位，可完成一个独立的顺序控制流程，当然一个进程中可以有多个线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程&lt;/strong&gt;：一个进程中同时运行了多个线程，每个线程用来完成不同的工作。多个线程交替占用CPU资源，并非真正的并行执行。&lt;/p&gt;
&lt;p&gt;使用多线程能充分利用CPU的资源，简化编程模型，带来良好的用户体验。&lt;/p&gt;
&lt;p&gt;一个进程启动后拥有一个&lt;strong&gt;主线程&lt;/strong&gt;，主线程用于产生其他子线程，而且主线程必须最后完成执行，它执行各种关闭动作。&lt;/p&gt;
&lt;p&gt;在Java中main()方法为主线程入口，下面使用 Thread 类查看主线程名。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MainThread {
    public static void main(String[] args) {
        //获取当前线程
        Thread t=Thread.currentThread();
        System.out.println(&quot;当前线程名字：&quot;+t.getName());
        //自定义线程名字
        t.setName(&quot;MyThread&quot;);
        System.out.println(&quot;当前线程名字：&quot;+t.getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建线程&quot;&gt;创建线程&lt;/h2&gt;
&lt;p&gt;在Java中创建线程有两种方式&lt;br/&gt;1.继承 java.lang.Thread 类&lt;br/&gt;2.实现 java.lang.Runnable 接口&lt;/p&gt;
&lt;h4 id=&quot;继承-thread-类创建线程&quot;&gt;1.继承 Thread 类创建线程&lt;/h4&gt;
&lt;p&gt;(1)定义MyThread类继承Thread类&lt;/p&gt;
&lt;p&gt;(2)重写run()方法，编写线程执行体&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread extends Thread{

    //重写run方法
    @Override
    public void run() {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)创建线程对象，调用start()方法启动线程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestMyThread {

    public static void main(String[] args) {
        MyThread myThread=new MyThread();
        //启动线程
        myThread.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多个线程同时启动后是交替执行的，线程每次执行时长由分配的CPU时间片长度决定&lt;/p&gt;
&lt;p&gt;修改 TestMyThread.java 观察多线程交替执行&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestMyThread {

    public static void main(String[] args) {
        MyThread myThread1=new MyThread();
        MyThread myThread2=new MyThread();
        myThread1.start();
        myThread2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;多运行几次观察效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;启动线程能否直接调用 run()方法？&lt;br/&gt;不能，调用run()方法只会是主线程执行。调用start()方法后，子线程执行run()方法，主线程和子线程并行交替执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;实现-runnable-接口创建线程&quot;&gt;2.实现 Runnable 接口创建线程&lt;/h4&gt;
&lt;p&gt;(1)定义MyRunnable类实现Runnable接口&lt;/p&gt;
&lt;p&gt;(2)实现run()方法，编写线程执行体&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyRunnable implements Runnable{
    //实现 run方法
    @Override
    public void run() {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)创建线程对象，调用start()方法启动线程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestMyRunnable {

    public static void main(String[] args) {
        Runnable runnable=new MyRunnable();
        //创建线程，传入runnable
        Thread t=new Thread(runnable);
        t.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线程的生命周期&quot;&gt;线程的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784606/201810/784606-20181026214146269-1674150498.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建状态&lt;/strong&gt;：线程创建完成，比如 &lt;code&gt;MyThread thread=new MyThread&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就绪状态&lt;/strong&gt;：线程对象调用 start() 方法，线程会等待CPU分配执行时间，并没有立马执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行状态&lt;/strong&gt;：线程分配到了执行时间，进入运行状态。线程在运行中发生礼让 &lt;code&gt;(yield)&lt;/code&gt; 会回到就绪状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞状态&lt;/strong&gt;：执行过程中遇到IO操作或代码 &lt;code&gt;Thread.sleep()&lt;/code&gt;，阻塞后的线程不能直接回到运行状态，需要重新进入就绪状态等待资源的分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;死亡状态&lt;/strong&gt;：自然执行完毕或外部干涉终止线程&lt;/p&gt;
&lt;h2 id=&quot;线程调度&quot;&gt;线程调度&lt;/h2&gt;
&lt;p&gt;线程调度指按照特定机制为多个线程分配CPU的使用权&lt;/p&gt;
&lt;p&gt;线程调度常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;setPriority(int newPriority)&lt;/td&gt;
&lt;td&gt;更改线程的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;static void sleep(long millis)&lt;/td&gt;
&lt;td&gt;在指定的毫秒数内让当前正在执行的线程休眠&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;void join()&lt;/td&gt;
&lt;td&gt;等待该线程终止&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;static void yield()&lt;/td&gt;
&lt;td&gt;暂停当前正在执行的线程对象，并执行其他线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;void interrupt()&lt;/td&gt;
&lt;td&gt;中断线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;boolean isAlive()&lt;/td&gt;
&lt;td&gt;测试线程是否处于活动状态&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;线程优先级的设置&quot;&gt;线程优先级的设置&lt;/h4&gt;
&lt;p&gt;线程优先级由1~10表示，1最低，默认有限级为5。优先级高的线程获得CPU资源的概率较大。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestPriority {

    public static void main(String[] args) {
        Thread t1=new Thread(new MyRunnable(),&quot;线程A&quot;);
        Thread t2=new Thread(new MyRunnable(),&quot;线程B&quot;);
        //最大优先级
        t1.setPriority(Thread.MAX_PRIORITY);
        //最小优先级
        t2.setPriority(Thread.MIN_PRIORITY);
        t1.start();
        t2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;线程休眠&quot;&gt;线程休眠&lt;/h4&gt;
&lt;p&gt;让线程暂时睡眠指定时长，线程进入阻塞状态，睡眠时间过后线程会再进入可运行状态。&lt;/p&gt;
&lt;p&gt;休眠时长以毫秒为单位，调用sleep()方法需要处理 InterruptedException异常。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestSleep {
    
    public static void main(String[] args) {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(&quot;第 &quot;+i+&quot; 秒&quot;);
            try {
                //让当前线程休眠1秒
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;强制运行&quot;&gt;强制运行&lt;/h4&gt;
&lt;p&gt;使用 join() 方法实现，可以认为是线程的插队，会先强制执行插队的线程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JoinThread implements Runnable{

    @Override
    public void run() {
        for (int i = 1; i &amp;lt;=10; i++) {
            System.out.println(&quot;线程名：&quot;+Thread.currentThread().getName()+&quot; i:&quot;+i);
        }
        System.out.println(&quot;插队线程执行完毕！&quot;);
    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestJoin {

    public static void main(String[] args) {
        Thread joinThread=new Thread(new JoinThread(),&quot;插队的线程&quot;);
        //启动后与主线程交替执行
        joinThread.start();
        for (int i = 1; i &amp;lt;= 10; i++) {
            if (i==5) {
                try {
                    System.out.println(&quot;====开始插队强制执行====&quot;);
                    joinThread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;线程名：&quot;+Thread.currentThread().getName()+&quot; i:&quot;+i);
        }
        System.out.println(&quot;主线程执行完毕！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最一开始执行，主线程 main 和 &quot;插队的线程&quot;是交替执行。当主线程的循环到第5次的时候，调用 &quot;插队的线程&quot;的join方法，开始强制执行&quot;插队的线程&quot;，待&quot;插队的线程&quot;执行完后，才继续恢复 main 线程的循环。&lt;/p&gt;
&lt;h4 id=&quot;线程礼让&quot;&gt;线程礼让&lt;/h4&gt;
&lt;p&gt;使用 yield() 方法实现，礼让后会暂停当前线程，转为就绪状态，其他具有相同优先级的线程获得运行机会。&lt;/p&gt;
&lt;p&gt;下面我们实现Runnable接口，在run方法中实现礼让，创建两个线程，达到某种条件时礼让。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class YieldThread implements Runnable{

    @Override
    public void run() {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(&quot;线程名：&quot;+Thread.currentThread().getName()+&quot; i:&quot;+i);
            //当前线程执行到5后发生礼让
            if (i==5) {
                System.out.println(Thread.currentThread().getName()+&quot; 礼让：&quot;);
                Thread.yield();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestYield {

    public static void main(String[] args) {
        Thread t1=new Thread(new YieldThread(),&quot;A&quot;);
        Thread t2=new Thread(new YieldThread(),&quot;B&quot;);
        t1.start();
        t2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只是提供一种可能，不能保证一定会实现礼让&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程同步&quot;&gt;线程同步&lt;/h2&gt;
&lt;p&gt;首先看一个多线共享同一个资源引发的问题&lt;/p&gt;
&lt;p&gt;仓库有10个苹果，小明、小红、小亮每次可以从仓库中拿1个苹果，拿完苹果后仓库中的苹果数量-1。&lt;/p&gt;
&lt;p&gt;先编写仓库资源类，实现接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//这个实现类将被多个线程对象共享
public class ResourceThread implements Runnable{
    private int num=10;
    @Override
    public void run() {
        while(true) {
            if (num&amp;lt;=0) {
                break;
            }
            num--;
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot;拿走一个，还剩余：&quot;+num);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试类，创建两个线程对象，共享同一个资源&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestResource {

    public static void main(String[] args) {
        ResourceThread resource=new ResourceThread();
        //使用同一个Runnable实现类对象
        Thread t1=new Thread(resource,&quot;小明&quot;);
        Thread t2=new Thread(resource,&quot;小红&quot;);
        Thread t3=new Thread(resource,&quot;小亮&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后我们发现，每次拿完苹果后的剩余数量出现了问题，使用同步方法可以解决这个问题。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;访问修饰符 synchronized 返回类型 方法名(参数列表){
    ……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;synchronized 就是为当前的线程声明一个锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改 ResourceThread.java 实现同步&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//这个实现类将被多个线程对象共享
public class ResourceThread implements Runnable{
    private int num=10;
    private boolean isHave=true;
    @Override
    public void run() {
        while(isHave) {
            take();
        }
    }
    //同步方法
    public synchronized void take() {
        if (num&amp;lt;=0) {
            isHave=false;
            return;
        }
        num--;
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+&quot;拿走一个，还剩余：&quot;+num);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现同步的第二种方式同步代码块&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized(syncObject){
    //需要同步的代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;syncObject为需同步的对象，通常为this&lt;/p&gt;
&lt;p&gt;修改 ResourceThread.java 改为同步代码块&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//这个实现类将被多个线程对象共享
public class ResourceThread implements Runnable{
    private int num=10;
    private boolean isHave=true;
    @Override
    public void run() {
        while(isHave) {
            synchronized(this) {
                if (num&amp;lt;=0) {
                    isHave=false;
                    return;
                }
                num--;
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+&quot;拿走一个，还剩余：&quot;+num);               
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 26 Oct 2018 13:43:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>什么是线程 在操作系统中，一个应用程序的执行实例就是 进程 ，进程有独立的内存空间和系统资源，在任务管理器中可以看到进程。 线程 是CPU调度和分派的基本单位，也是进程中执行运算的最小单位，可完成一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/9858875.html</dc:identifier>
</item>
<item>
<title>微服务架构下静态数据通用缓存机制 - 波斯马</title>
<link>http://www.cnblogs.com/bossma/p/9858847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bossma/p/9858847.html</guid>
<description>&lt;p&gt;在分布式系统中，特别是最近很火的微服务架构下，有没有或者能不能总结出一个业务静态数据的通用缓存处理机制或方案，这篇文章将结合一些实际的研发经验，尝试理清其中存在的关键问题以及探寻通用的解决之道。&lt;/p&gt;
&lt;h3&gt;什么是静态数据&lt;/h3&gt;
&lt;p&gt;这里静态数据是指不经常发生变化或者变化频率比较低的数据，比如车型库、用户基本信息、车辆基本信息等，车型库这种可能每个月会更新一次，用户和车辆基本信息的变化来源于用户注册、修改，这个操作的频率相对也是比较低的。&lt;/p&gt;
&lt;p&gt;另外这类数据的另一个特点是要求准确率和实时性都比较高，不能出现丢失、错误，以及过长时间的陈旧读。&lt;/p&gt;
&lt;p&gt;具体是不是应该归类为静态数据要看具体的业务，以及对变化频率高低的划分标准。在这里的业务定义中，上边这几类数据都归为静态数据。&lt;/p&gt;
&lt;h3 id=&quot;为什么需要缓存&quot; class=&quot;sectionedit3&quot;&gt;为什么需要缓存&lt;/h3&gt;
&lt;p&gt;在面向用户或车联网的业务场景中，车型信息、用户基本信息和车辆基本信息有着广泛而高频的业务需求，很多数据都需要对其进行关联处理。在这里缓存的目的就是为了提高数据查询效率。静态数据通常都保存在关系型数据库中，这类数据库的IO效率普遍不高，应对高并发的查询往往捉襟见肘。使用缓存可以极大的提升读操作的吞吐量，特别是KV类的缓存，没有复杂的关系操作，时间复杂度一般都在O(1)。注意这里说的缓存指内存缓存。&lt;/p&gt;
&lt;p&gt;当然除了使用缓存，还可以通过其它手段来提高IO吞吐量，比如读写分离，分库分表，但是这类面向关系型数据库的方案更倾向于同时提高读写效率，对于单纯提升读吞吐量的需求，这类方案不够彻底，不能在有限的资源情况下发挥更好的作用。&lt;/p&gt;
&lt;h3&gt;通用缓存机制&lt;/h3&gt;
&lt;p&gt;下面将直接给出一个我认为的通用处理机制，然后会对其进行分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/73642/201810/73642-20181026212745897-1183703475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于某个具体的业务，其涉及到六个核心程序：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;业务服务：提供对某种业务数据的操作接口，比如车辆服务，提供对车辆基本信息的增删改查服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;关系数据库：使用若干表持久化业务数据，比如SQLServer、MySQL、Oracle等。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;持久化队列：可独立部署的队列程序，支持数据持久化，比如RabbitMQ、RocketMQ、Kafka等。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;缓存处理程序：从队列接收数据，然后写入缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;数据一致处理程序：负责检查缓存数据库和关系型数据库中数据是否一致，如果不一致则使用关系数据库进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;缓存数据库（Redis）：支持持久化的缓存数据库，这里直接选了Redis，这个基本是业界标准了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以及两个外部定义：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;数据生产者：业务静态数据的来源，可以理解为前端APP、Web系统的某个功能或者模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;数据消费者：需要使用这些业务静态数据的服务或者系统，比如报警系统需要获取车辆对应的用户信息以便发送报警。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;level3&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;下面以问答的形式来说明为什么是这样一种机制。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么需要业务服务&quot;&gt;为什么需要业务服务？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;61.913000494315&quot;&gt;
&lt;p&gt;既然是微服务架构，当然离不开服务了，因为这里探讨的是业务静态数据，所以是业务服务。不过为了更好的理解，这里还是简单说下服务出现的原因。&lt;/p&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;当今业务往往需要在多个终端进行使用，比如PC、手机、平板等，既有网页的形式，又有APP的形式，另外某个数据可能在多种不同的业务被需要，如果将数据操作分布在多个程序中很可能产生数据不一致的情况，另外代码不可避免的冗余，读写性能更很难控制，变更也基本上是不敢变的。通过一个业务服务可以将对业务数据的操作有序的管理起来，并通过接口的形式对外提供操作能力，代码不用冗余了，性能也好优化了，数据不一致也得到了一定的控制，编写上层应用的人也舒服了。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么不是进程内缓存&quot;&gt;为什么不是进程内缓存？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;很多开发语言都提供了进程内缓存的支持，即使没有提供直接操作缓存的包或库，也可以通过静态变量的方式来实现。对数据的查询请求直接在进程内存完成，效率可以说是杠杠滴了。但是进程内缓存存在两个问题：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;缓存数据的大小：进程可以缓存数据的大小受限于系统可用内存，同时如果机器上部署了多个服务，某个服务使用了太多的内存，则可能会影响其它服务的正常访问，因此不适合大量数据的缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;缓存雪崩：缓存同时大量过期或者进程重启的情况下，可能产生大量的缓存穿透，过多的请求打到关系数据库上，可能导致关系数据库的崩溃，引发更大的不可用问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4 id=&quot;为什么是redis&quot;&gt;为什么是Redis？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;Redis这类数据库可以解决进程内缓存的两个问题：&lt;/p&gt;
&lt;p&gt;另外Redis提供了很好的读写性能，以及方便的水平扩容能力，还支持多种常用数据结构，使用起来比较方便，可以说是通用缓存首选。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么需要队列&quot;&gt;为什么需要队列？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;队列在这里的目的是为了解耦，坦白的说这个方案中可以没有队列，业务服务在关系数据库操作完成后，直接更新到缓存也是可以的。 之所以加上这个队列是由于当前的业务开发有很明显的系统拆分的需求，特别是在微服务架构下，为了降低服务之间的耦合，使用队列是个常用选择，在某些开发模型中也是很推崇的，比如Actor模型。&lt;/p&gt;
&lt;p&gt;举个例子，比如新注册一个用户，需要赠送其300积分，同时还要给其发个注册成功的邮件，如果将注册用户、赠送积分、发成功邮件都写到一起执行，会产生两个问题：一是注册操作耗时增加，二是其中某个处理引发整体不可用的几率增大，三是程序的扩展性不好；通多引入队列，将注册信息分别发到积分队列和通知队列，然后由积分模块和通知模块分别处理，用户、积分、通知三个模块的耦合降低了，相互影响变小了，以后再增加注册后的其它处理也就是增加个队列的事，整体的扩展性得到了增强。&lt;/p&gt;
&lt;p&gt;队列作为一种常用的解耦方案，在缓存这里虽然产生的影响不大，但是除了缓存难免同时还会有其它业务处理，所以为了统一处理机制，这里保留了下来。（既然用了，就把它发扬光大。）&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么队列需要持久化&quot;&gt;为什么队列需要持久化？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;持久化是为了解决网络抖动或者崩溃导致数据丢失的问题，在数据从业务服务到队列，队列自身处理，再从队列到缓存处理程序，中间都可能丢失数据。为了解决丢失数据的问题，需要发送时确认、队列自身持久化、接收时确认；但是需要注意确认机制可能会导致重复数据的产生，因为在未收到确认时就需要重新发送或接收，而数据实际上可能被正常处理，只是确认丢失了；确认机制还会降低队列的吞吐量，但是根据我们的定义业务静态数据的变更频率应该不高，如果同时还需要较高的并发分片是个不错的选择。&lt;/p&gt;
&lt;p&gt;这里持久化队列推荐选择RabbitMQ，虽然吞吐量支持的不是很大，但是各方面综合不错，并发够用就好。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么需要数据一致检查程序&quot;&gt;为什么需要数据一致检查程序？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;在业务服务操作完关系数据库后，数据发送到队列之前（或者不用队列就是直接写入缓存之前），业务服务崩溃了，这时候数据就不能更新到缓存了。还有一种情况是Redis发生了故障转移，master中的更新没有同步到slaver。通过引入这么一个检查程序，定时的检查关系数据库数据和缓存数据的差别，如果缓存数据比较陈旧，则更新之。这样提供了一种极端情况下的挽救措施。&lt;/p&gt;
&lt;p&gt;这个检查程序的运行频率需要综合考虑数据库压力和能够承受的数据陈旧时间，不能把数据库查死了，也不能陈旧太久导致大量数据不一致。可以通过设置上次检查时间点的方式，每次只检查从上次检查时间点（或者最近几次，防止Redis故障转移数据未同步的问题）到本次检查时间点发生变更的数据，这样每次检查只对增量变更，效率更高。&lt;/p&gt;
&lt;p&gt;同时需要理解在分布式系统中，微服务架构下，数据不一致是经常出现的，必须在一致性和可用性之间做出权衡，尽力去降低影响，比如使用准实时或最终一致性。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;只要数据一致检查程序是不是就够了&quot;&gt;只要数据一致检查程序是不是就够了？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;假设没有缓存处理程序，通过定时同步关系数据库和缓存数据库是不是就够了呢？这还是取决于业务，如果是车型库这种数据，增加一个新的车型，本来之前就没有，时间上并不是很敏感，这个是可以的。但是对于新增了用户或者车辆，数据消费者还是希望能够马上使用最新的数据进行处理，越快越好，这时使用同步或者准同步更新就能更加贴近需求。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么不用缓存过期机制&quot;&gt;为什么不用缓存过期机制？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;使用缓存过期机制可以不需要缓存处理程序和数据一致检查程序，业务服务首先从Redis查询数据，如果数据存在就直接返回，如果不存在则从关系数据库查询，然后写入Redis，然后再返回，这也是一种常用的缓存处理机制，网上可以查询到很多，很多人用的也很好。&lt;/p&gt;
&lt;p&gt;但是缓存的过期时间是个问题：缓存多长时间过期，设置的短可以降低数据的陈旧，但是会增加缓存穿透的概率，即使采用随机的缓存过期时间，在Redis重启或者故障转移的情况下还是会可能导致缓存雪崩，雪崩的情况下采用数据预热机制，也可能会导致服务更长时间的不可用；设置的长可以提升缓存的使用率，但是增加了数据陈旧，在上边对静态数据的定义中对其准确率和实时性都有较高的要求，业务上能不能接受需要考虑。而且如果操作数据和查询存在波动的峰谷，是不是要引入动态TTL的机制，以达到缓存使用和直接访问数据库的一种平衡，这就需要权衡业务需求和技术方案。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;总结&quot; class=&quot;sectionedit5&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;通过上边的这些问题问答，再来看看上面提出的微服务架构下静态数据通用缓存处理机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过业务服务来包装对数据的操作，不管是操作关系数据库还是缓存数据库，数据消费者其实不需要关心，它只关心业务服务能不能提供高并发实时数据的查询能力。&lt;/li&gt;
&lt;li&gt;利用分布式系统中经常使用队列进行解耦的方式，业务服务不干写入缓存的事，增加一个队列订阅数据变更，然后从队列取数据写入缓存数据库。&lt;/li&gt;
&lt;li&gt;对于绝大部分正常的情况，通过队列更新缓存数据和业务服务中更新缓存数据，其实时性是差不多的，同时实现了业务操作和写缓存的解耦。&lt;/li&gt;
&lt;li&gt;在极端崩溃导致数据不一致的情况下，通过数据一致检查程序进行补救，尽快更新缓存数据。&lt;/li&gt;
&lt;li&gt;现在业务服务可以通过访问Redis缓存来提供对静态数据的高并发准实时查询能力，缓存中不存在的数据就是不存在，没有缓存穿透。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于微服务架构而言，这个机制借助队列这种通用的解耦方式，独立了缓存更新处理，通过准实时更新和定时检查，保证了缓存的实时性和极端情况下较短时间内达到最终一致，通过缓存的持久化机制消除了缓存穿透和雪崩，在缓存的数据较大或读取并发较高时支持水平扩容，可以认为对业务静态数据提供了一种广泛适用的缓存处理机制。&lt;/p&gt;
&lt;p&gt;这个方案在某些情况下可能是没有必要的，比如你要缓存一个全国限行的城市列表，使用一个进程内缓存就够了。&lt;/p&gt;
&lt;p&gt;最后剩下的就是工作量的问题了，这个会给开发和维护带来复杂性，队列有没有用的顺手的，人手是不是够，业务需求是什么样的，需要考虑清楚。&lt;/p&gt;
&lt;h3&gt;后记&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Redis耦合问题：&lt;/strong&gt;图中业务服务直接访问了Redis，如果要实现业务服务对Redis的完全透明，这个还比较复杂，可以考虑采用AOP的方式，对关系数据库和Redis保持相同的类型定义，分别采用ORM和反序列化的方式标准化输出，这是个想法我也没有实现；同时缓存数据是准实时的，如果要求完全一致，还是应该提供从关系数据库查询的版本。另外如果要摆脱对Redis的直接依赖，还可以通过OpenResty来实现对资源的透明访问，这个不是本文的重点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务可用性问题：&lt;/strong&gt;这篇文章没有关注服务可用性问题，为了保证服务的高可用，每个服务或者程序都应该有多份部署的，无论是负载均衡的方案，或者传统的主备方案，在部分部署不可用时仍能够继续提供服务。&lt;/p&gt;
&lt;p&gt;写的比较快，有些理解不免偏颇，欢迎指正。&lt;/p&gt;
&lt;p&gt;另外附上我的独立博客访问地址：&lt;a href=&quot;http://blog.bossma.cn/architecture/microservice-business-static-data-universal-cache-mechanism/&quot; target=&quot;_blank&quot;&gt;http://blog.bossma.cn/architecture/microservice-business-static-data-universal-cache-mechanism/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 26 Oct 2018 13:29:00 +0000</pubDate>
<dc:creator>波斯马</dc:creator>
<og:description>在分布式系统中，特别是最近很火的微服务架构下，有没有或者能不能总结出一个业务静态数据的通用缓存处理机制或方案，这篇文章将结合一些实际的研发经验，尝试理清其中存在的关键问题以及探寻通用的解决之道。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bossma/p/9858847.html</dc:identifier>
</item>
<item>
<title>ChunkDisappearImage-一个以矩形为单位的图片消失分解效果 - blueberryzzz</title>
<link>http://www.cnblogs.com/blueberryzzz/p/9858749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueberryzzz/p/9858749.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210416528-1645876247.gif&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210435112-1055274508.gif&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210448905-1309354276.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.将ChunkDisappearImage挂在一个空GameObject上。&lt;br/&gt;2.将ChunkDisappearImage的Material设为ChunkDisappearImageMaterial。&lt;br/&gt;3.设置RectTransform的宽、高、缩放、旋转等参数。设置ChunkDisappearImage的参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Speed：&lt;/strong&gt; 小方块移动的速度。&lt;br/&gt;&lt;strong&gt;TargetX,TargetY：&lt;/strong&gt; 每个小方块移动的终点坐标。&lt;br/&gt;&lt;strong&gt;SubRectX,SubRectY：&lt;/strong&gt; 每个小方块的长宽。&lt;br/&gt;&lt;strong&gt;Interval：&lt;/strong&gt; 每个小方块开始移动时间的间隔。&lt;br/&gt;&lt;strong&gt;SpeedArg：&lt;/strong&gt; 距离越远的方块是否运行越快，_SpeedArg为1时，所有方块运行速度基本相同，值越小，距离越远的方块运行的越快。&lt;br/&gt;ps：目标点的坐标，小方块的宽高都是Image对象为父节点的本地坐标。&lt;/p&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现主要分为三个步骤：&lt;/strong&gt;&lt;br/&gt;1.修改image的mesh。&lt;br/&gt;2.将与运动相关的参数传入shader中。&lt;br/&gt;3.在移动结束后将mesh恢复为普通的image的shader。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210610120-36840052.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现细节&quot;&gt;实现细节&lt;/h2&gt;
&lt;h3 id=&quot;mesh的拆分&quot;&gt;mesh的拆分&lt;/h3&gt;
&lt;h4 id=&quot;image通过onpopulatemesh函数构建对应的mesh所以我们通过重写image的onpopulatemesh来对mesh进行构建&quot;&gt;1.Image通过OnPopulateMesh函数构建对应的mesh，所以我们通过重写Image的OnPopulateMesh来对mesh进行构建。&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Image的默认mesh：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210629788-526422195.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;拆分后的mesh：&lt;/strong&gt; 以拆分为四块为例&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210651135-147888723.png&quot;/&gt;&lt;br/&gt;将mesh拆分为很多个小矩形后，还得想办法告诉shader每个顶点是属于那个矩形的，才能以此为依据进行矩形的移动。&lt;/p&gt;
&lt;h4 id=&quot;如何告诉shader每个顶点是属于哪个矩形的&quot;&gt;2.如何告诉shader每个顶点是属于哪个矩形的。&lt;/h4&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public partial struct UIVertex
{
    public Vector3 position;
    public Vector3 normal;
    public Vector4 tangent;
    public Color32 color;
    public Vector2 uv0;
    public Vector2 uv1;
    public Vector2 uv2;
    public Vector2 uv3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看下描述一个UI顶点的结构体中都包含了哪些字段，UGUI中只用到了position，color，uv0这三个字段。&lt;br/&gt;这代表我们可以使用剩余的字段传我们需要的额外信息，这里选择使用uv1字段将每个矩形的左下角的点作为矩形的位置信息传入shader，在shader中，以此为基础进行小矩形块的移动。&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;①不能用normal和tangent，因为UGUI在渲染时，传入shader中的position不是传入VertexHelper时的原始值，而是该点在根canvas上的坐标，同理，normal，tangent也做了相应的变换。不是原始值了。&lt;br/&gt;所以在传额外信息的时候要用uv1、uv2、uv3字段，这三个字段不会随点的移动、旋转、缩放而改变。&lt;br/&gt;②由于unity高版本在ugui渲染时做了优化，在默认情况下只会将position、color、uv0三个字段传入shader，所以需要手动将uv1设为生效才行。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210708398-136229368.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;image本地坐标到根canvas坐标的模型矩阵的计算&quot;&gt;image本地坐标到根canvas坐标的模型矩阵的计算&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;mLocalToCanvas = canvas.rootCanvas.transform.localToWorldMatrix.inverse * transform.localToWorldMatrix;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;image的模型矩阵：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026212307027-2092634020.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;canvas的模型矩阵：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026212323455-1010775850.png&quot;/&gt;&lt;br/&gt;由于矩阵满足结合律，所以用用canvas的模型矩阵的逆乘以image的模型矩阵会将canvas的模型矩阵消掉，也就是image坐标-&amp;gt;canvas坐标的模型矩阵：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026212339587-582141206.png&quot;/&gt;&lt;br/&gt;用这个矩阵乘上image上的本地坐标就可以算出对应的canvas上的坐标。&lt;/p&gt;
&lt;h3 id=&quot;开始时间和结束时间的计算&quot;&gt;开始时间和结束时间的计算&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;开始时间&lt;/strong&gt;&lt;br/&gt;分两种情况：&lt;br/&gt;①当目标点在图片内时，不去算准确的起始时间，直接设置为0。&lt;br/&gt;②当目标点在图片外时，最近点一定是四个顶点之一。遍历四个顶点，计算一下离目标点最近的方块开始运动时的_Delta值，即f第一次不为0的时候&lt;br/&gt;&lt;strong&gt;结束时间&lt;/strong&gt;&lt;br/&gt;计算一下最远点的f为1的情况即可，由于距离目标点最远的点一定是四个顶点之一，所以枚举四个顶点即可。&lt;/p&gt;
&lt;h3 id=&quot;shader的重写&quot;&gt;shader的重写&lt;/h3&gt;
&lt;p&gt;我们要改动Image默认的shader的顶点着色器来实现每个顶点的位移和alpha值的降低。&lt;br/&gt;我们选择5.37f1的UGUI默认shader，UI-Default.shader进行修改，这个在unity官网就可以下到。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210734053-425371512.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意&quot;&gt;注意：&lt;/h4&gt;
&lt;p&gt;在Unity高版本打开低版本的shader时，会对一些函数做替换，如在2018.2打开5.37f1的shader时，会对如下语句进行修改。&lt;/p&gt;
&lt;pre class=&quot;glsl&quot;&gt;
&lt;code&gt;// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此demo中使用的是2018.2版本的unity，所以在低版本使用时要把这句话改回去，不然会报错。&lt;/p&gt;
&lt;h4 id=&quot;顶点的移动公式&quot;&gt;顶点的移动公式：&lt;/h4&gt;
&lt;pre class=&quot;glsl&quot;&gt;
&lt;code&gt;//计算该方块到目标点的距离，以此为标准作为每个方块移动时间的延迟
float distance = length(target.xyz - leftBottom.xyz);
//距离越远的方块是否运行越快，_SpeedArg为1时，所有方块运行速度大致相同，值越小，距离越远的方块运行的越快
float tempDis = 1 + distance * _SpeedArg;
float f = clamp((_Delta - distance * _Interval) / tempDis, 0, 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据f在0-1之间的变化，来控制方块在起点到终点之间的移动和alpha值的变化。&lt;br/&gt;①distance * _Interval保证每个距终点距离不同方块之间的开始移动时间会有一个间隔。&lt;br/&gt;②tempDis可以控制不同距离方块之间的速度比。&lt;/p&gt;

&lt;p&gt;原理其实并不难，主要只有两部分：改mesh，改shader。就是一些坐标的转换、开始结束时间的控制、版本的兼容性比较麻烦。&lt;br/&gt;在把整个流程跑通一次之后，就会对流程有一个较为全面的认识，下次做2D或是3D的一些效果思路也也会更广一些。&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&quot;https://github.com/blueberryzzz/UIAndShader/tree/master/UIAndShader/Assets/ChunkDisappearImage&quot; class=&quot;uri&quot;&gt;https://github.com/blueberryzzz/UIAndShader/tree/master/UIAndShader/Assets/ChunkDisappearImage&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 13:10:00 +0000</pubDate>
<dc:creator>blueberryzzz</dc:creator>
<og:description>效果 使用 1.将ChunkDisappearImage挂在一个空GameObject上。 2.将ChunkDisappearImage的Material设为ChunkDisappearImageMa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blueberryzzz/p/9858749.html</dc:identifier>
</item>
</channel>
</rss>