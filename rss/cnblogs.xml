<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>玩转SpringCloud   一．服务的注册与发现（Eureka） - 房上的猫</title>
<link>http://www.cnblogs.com/lsy131479/p/9613755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy131479/p/9613755.html</guid>
<description>&lt;p&gt;spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等&lt;/p&gt;

&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;主项目&lt;/span&gt;:&lt;span&gt;版本控制&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;Springboot&lt;span&gt;集中声明&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.4.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Springcloud&lt;span&gt;版本&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Finchley.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;主项目管理的依赖&lt;/span&gt;Jar&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring-cloud.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Springboot&lt;span&gt;组件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;创建&lt;/span&gt;2&lt;span&gt;个&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;工程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一个&lt;/span&gt;model工程作为服务注册中心，即Eureka Server,另一个作为Eureka Client。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180909151714556-1022355080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;创建服务注册中心&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;Eureka Server&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;　　&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;引入主项目：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fsdm&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringCloud_test1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;引入&lt;/span&gt;spring-cloud-starter-netflix-eureka-server的依赖:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Application&lt;span&gt;启动类：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableEurekaServer
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1Application {

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
      SpringApplication.run(Demo1Application.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;注解解析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. &lt;span&gt;复合注解主要&lt;/span&gt;&lt;span&gt;包括&lt;/span&gt;@ComponentScan&lt;span&gt;，和&lt;/span&gt;@SpringBootConfiguration&lt;span&gt;，&lt;/span&gt;@EnableAutoConfiguration&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. @SpringBootConfiguration&lt;span&gt;标注当前类是配置类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. @EnableAutoConfiguration&lt;span&gt;启动自动的配置&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;根据你添加的&lt;/span&gt;jar包来配置你项目的默认配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. @EnableAutoConfiguration&lt;span&gt;扫描当前包及其子包下被&lt;/span&gt;@Component&lt;span&gt;，&lt;/span&gt;@Controller&lt;span&gt;，&lt;/span&gt;@Service&lt;span&gt;，&lt;/span&gt;@Repository&lt;span&gt;注解标记的类并纳入到&lt;/span&gt;spring容器中进行管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@EnableEurekaServer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. &lt;span&gt;表明这是一个&lt;/span&gt;EurekaServer&lt;span&gt;（&lt;/span&gt;&lt;span&gt;服务注册中心&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. &lt;span&gt;配合&lt;/span&gt;yml文件使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;Eureka:&lt;/span&gt;
　　&lt;span&gt;Client:&lt;/span&gt;
　　　　&lt;span&gt;registerWithEureka:&lt;/span&gt;&lt;span&gt; false
　　　　&lt;/span&gt;&lt;span&gt;fetchRegistry:&lt;/span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yml&lt;span&gt;配置：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:&lt;/span&gt;
  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8761&lt;/span&gt;

&lt;span&gt;eureka:&lt;/span&gt;
  &lt;span&gt;instance&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;hostname:&lt;/span&gt;&lt;span&gt; localhost
  &lt;/span&gt;&lt;span&gt;client:&lt;/span&gt;&lt;span&gt;
  #  表明自己是一个eureka server.
    &lt;/span&gt;&lt;span&gt;registerWithEureka:&lt;/span&gt;&lt;span&gt; false
    &lt;/span&gt;&lt;span&gt;fetchRegistry:&lt;/span&gt;&lt;span&gt; false
    &lt;/span&gt;&lt;span&gt;serviceUrl:&lt;/span&gt;
      &lt;span&gt;defaultZone:&lt;/span&gt; &lt;span&gt;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;

&lt;span&gt;spring:&lt;/span&gt;
  &lt;span&gt;application:&lt;/span&gt;
    &lt;span&gt;name:&lt;/span&gt; eurka-server
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;启动程序，访问&lt;/span&gt;http://localhost:8761/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当&lt;/span&gt;client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180909152014887-1699747582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;No application available &lt;span&gt;表示&lt;/span&gt;&lt;span&gt;没有服务被发现&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为我们还没有注册服务当然没有发现服务啦，&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;2）&lt;strong&gt;&lt;span&gt;创建一个服务提供者&lt;/span&gt; (eureka client)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;引入主项目：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fsdm&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringCloud_test1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;需要的&lt;/span&gt;jar&lt;span&gt;以及组件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Application&lt;span&gt;启动类：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableEurekaClient
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo2Application {

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
      SpringApplication.run(Demo2Application.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
   }

   @Value(&lt;/span&gt;&quot;${server.port}&quot;&lt;span&gt;)
   String port;
   @RequestMapping(&lt;/span&gt;&quot;/hi&quot;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String home(@RequestParam String name) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hi &quot;+name+&quot;,i am from port:&quot; +&lt;span&gt;port;
   }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注解解析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@EnableEurekaClient&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. &lt;span&gt;表明这是一个&lt;/span&gt;EurekaClient&lt;span&gt;（&lt;/span&gt;&lt;span&gt;服务提供者&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. &lt;span&gt;复合注解主要包括&lt;/span&gt;@Controller&lt;span&gt;和&lt;/span&gt;@ResponseBody&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. &lt;span&gt;标注&lt;/span&gt;controller&lt;span&gt;层，可供&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;访问&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. &lt;span&gt;无法返回&lt;/span&gt;jsp&lt;span&gt;页面，或者&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;，配置的视图解&lt;/span&gt;InternalResourceViewResolver&lt;span&gt;不起作用&lt;/span&gt;&lt;span&gt;，返回的内容就是&lt;/span&gt;Return &lt;span&gt;里的内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;yml&lt;span&gt;配置：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:&lt;/span&gt;
  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8762&lt;/span&gt;

&lt;span&gt;spring:&lt;/span&gt;
  &lt;span&gt;application:&lt;/span&gt;&lt;span&gt;
#工程名称
    &lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt; service-hi

&lt;/span&gt;&lt;span&gt;eureka:&lt;/span&gt;
  &lt;span&gt;client:&lt;/span&gt;
    &lt;span&gt;serviceUrl:&lt;/span&gt;
      &lt;span&gt;defaultZone:&lt;/span&gt; &lt;span&gt;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8761/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;需要指明&lt;/span&gt;spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;启动这个项目，刷新&lt;/span&gt;http://localhost:8761/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现一个服务已经注册在服务中了，服务名为&lt;/span&gt;SERVICE-HI ,端口为8762&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180909152324074-736433188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于红色字体的警告解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/breath-taking/articles/7940364.html&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;访问&lt;/span&gt;http://localhost:8762/hi?name=fsdm&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180909152407475-553321221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 07:30:00 +0000</pubDate>
<dc:creator>房上的猫</dc:creator>
<og:description>一．服务的注册与发现（Eureka） spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy131479/p/9613755.html</dc:identifier>
</item>
<item>
<title>传统项目利用Hystrix实现热点接口的服务隔离 - 小卖铺的老爷爷</title>
<link>http://www.cnblogs.com/laoyeye/p/9581493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoyeye/p/9581493.html</guid>
<description>&lt;p&gt; 这段时间接了个需求，需要在我目前负责的数据系统上加个接口，主要是实现用户行为的记录。前端对接的项目主要有公司的PC，WAP，WEIXIN，APP等，每个端大概有两台左右的负载。因为目前我的这个项目主要是面向内部，负责数据运营相关的内容，是个单体项目。如果线上各个接入点不做限制，瞬间大量的并发进入必然会导致目前项目的崩溃，其他的功能也无法正常使用。&lt;/p&gt;

&lt;p&gt;通过前期的需求分析，目前线上系统无法进行限流处理，所以最终解决问题还是要从接口入手。&lt;/p&gt;
&lt;p&gt;目前我对接口的处理有两种实现方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以利用MQ实现消息的错峰，将消息发送到MQ服务器。&lt;/li&gt;
&lt;li&gt;实现对接口的隔离限流，避免当前接口对其他功能的影响。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实我认为最好的实现方案就是第一种了，可以保证消息的准确送达，避免并发资源的占用。不过，因为公司条件的限制暂时不能新增中间件，所以只能在现有系统上进行改造，最后只能采用第二种方法了。&lt;/p&gt;

&lt;p&gt;官方的定义就不说了，这里简单说下我的理解。Hystrix作为断路器主要是实现对服务的容错保护，简单来说就是服务隔离、服务降级、服务熔断，服务限流这几项。&lt;/p&gt;
&lt;p&gt;举个常见的例子，当你某宝【抢购】一个产品时，经常会弹出[网络错误，请重试。]的提示，这种时候是真的网络问题吗？显示不是。这种情况下其实是对调用的接口进行了降级处理，当降级的次数或比例达到一定的条件后，断路器就会直接打开，之后的访问就会直接降级，而不会判断是否降级了。达到对服务的容错保护以及给用户友好提示的目的。详细的流程可以看下图。&lt;/p&gt;
&lt;p&gt;一般Hystrix的容错保护在微服务中是用在客户端，也就是调用方。而我这次实际上是用在了提供方，主要是前台的项目我无法控制，只能在接口上想方法了。目前我使用Hystrix的主要目的就是实现对服务的隔离和限流，而对降级和熔断反而不是特别的关心，当然实际的使用要结合场景。&lt;/p&gt;
&lt;p&gt;因为一般Tomcat默认是一个线程池150个线程，如果单个热点接口的请求过多，就会造成其他功能没有线程可用甚至直接程序崩溃的问题。Hystrix的服务隔离主要有两种，常用的就是线程池隔离的方式，对热点接口建立单独的线程池避免对主程序的影响。另一种是信号量的方式，用的场景不是太多。两者的区别其实就是一个增大系统的开销，一个则直接限制了线程总的并发数，开销更小一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180908163721833-927429817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hystrix服务调用逻辑图&lt;/p&gt;

&lt;p&gt; 本文是在传统Spring项目中的应用，Springboot中的相关配置和依赖有稍许的不同。&lt;/p&gt;
&lt;p&gt;maven依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; hystrix &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.hystrix&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hystrix-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.9&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.hystrix&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hystrix-metrics-event-stream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.9&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.hystrix&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hystrix-javanica&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.9&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在Spring的配置文件中配置Hystrix的切面信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;hystrixAspect&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要是开启注解的AOP扫描，这里我们可以在这个类的源码中看到实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180908161105316-1681818891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看到我们主要是通过这个类切面扫描Hystrix的相关注解，以达到接口处理前，提前执行Hystrix相关逻辑的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 提供客户行为接口
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Controller
@RequestMapping(value &lt;/span&gt;= &quot;/test&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BehaviorController {
    Logger                                logger    &lt;/span&gt;= Logger.getLogger(BehaviorController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BehaviorService behaviorService;

    @RequestMapping(value&lt;/span&gt;=&quot;/addBehavior&quot;,method = RequestMethod.POST,produces = &quot;application/json;charset=UTF-8&quot;&lt;span&gt;)
    @ResponseBody
    @HystrixCommand(fallbackMethod &lt;/span&gt;= &quot;fallback&quot;, threadPoolProperties =&lt;span&gt; {  
            @HystrixProperty(name &lt;/span&gt;= &quot;coreSize&quot;, value = &quot;20&quot;), @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;100&quot;&lt;span&gt;),
            @HystrixProperty(name &lt;/span&gt;= &quot;queueSizeRejectionThreshold&quot;, value = &quot;20&quot;&lt;span&gt;)},
            commandProperties &lt;/span&gt;=&lt;span&gt; {  
                    @HystrixProperty(name &lt;/span&gt;= &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;30000&quot;&lt;span&gt;),  
                    @HystrixProperty(name &lt;/span&gt;= &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;&lt;span&gt;)
  
    })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String addBehavior(@RequestBody String parms) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务逻辑实现&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String fallback(@RequestBody String parms){
        logger.info(&lt;/span&gt;&quot;fallback&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;失败的实现&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;br data-filtered=&quot;filtered&quot;/&gt;
请求的接口必须为public，fallback为降级的接口逻辑，可以为private，也可以为public。&lt;/p&gt;
&lt;p&gt;但是要&lt;span&gt;&lt;strong&gt;特别注意fallback方法的返回值和参数必须和请求方法相同&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;另外需要说的是，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;当请求失败、被拒绝、超时或者断路器打开时，都会进入回退方法，但是进入回退方法并不意味着断路器已经被打开。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;&lt;tbody readability=&quot;22&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;默认值&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;execution.isolation.strategy&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;隔离策略，有THREAD和SEMAPHORE&lt;/p&gt;
&lt;p&gt;THREAD - 它在单独的线程上执行，并发请求受线程池中的线程数量的限制&lt;br/&gt;SEMAPHORE - 它在调用线程上执行，并发请求受到信号量计数的限制&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;默认使用THREAD模式，以下几种场景可以使用SEMAPHORE模式：&lt;/p&gt;
&lt;p&gt;只想控制并发度&lt;/p&gt;
&lt;p&gt;外部的方法已经做了线程隔离&lt;/p&gt;
&lt;p&gt;调用的是本地方法或者可靠度非常高、耗时特别小的方法（如medis）&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;execution.isolation.thread.timeoutInMilliseconds&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;超时时间&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;默认值：1000&lt;/p&gt;
&lt;p&gt;在THREAD模式下，达到超时时间，可以中断&lt;/p&gt;
&lt;p&gt;在SEMAPHORE模式下，会等待执行完成后，再去判断是否超时&lt;/p&gt;
&lt;p&gt;设置标准：&lt;/p&gt;
&lt;p&gt;有retry，99meantime+avg meantime&lt;/p&gt;
&lt;p&gt;没有retry，99.5meantime&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;execution.timeout.enabled&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;HystrixCommand.run（）执行是否应该有超时。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;默认值：true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;fallback.isolation.semaphore.maxConcurrentRequests&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;设置在使用时允许执行fallback方法的最大并发请求数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;默认值：10&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;circuitBreaker.requestVolumeThreshold&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置滚动时间窗中，断路器熔断的最小请求数&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt; 默认值：20&lt;/p&gt;
&lt;p&gt;滚动窗口默认10s，即10s内失败请求达到20个，熔断器即打开&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt; coreSize&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置执行命令线程池的核心线程数。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt; 默认值：10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;maxQueueSize&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置执行命令线程池的核心线程数。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;  默认值：-1&lt;/p&gt;
&lt;p&gt;当设置为-1时，线程池使用SynchronousQueue实现的队列，否则将使用LinkedBlockingQueue实现的队列&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;queueSizeRejectionThreshold&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;为队列设置拒绝阈值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;默认值：5&lt;/p&gt;
&lt;p&gt;当设置该参数后，即使队列没有达到最大值也能拒绝请求。&lt;/p&gt;
&lt;p&gt;注意：当maxQueueSize属性为-1的时候，该属性不会生效&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;另外需要特别注意的是：&lt;span&gt;&lt;strong&gt;&lt;span&gt;fallback的属性maxConcurrentRequests，当请求达到了最大并发数时，后续的请求将会被拒绝并抛出异常（因为它已经没有后续的fallback可以被调用了），异常信息一般为&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;com.netflix.hystrix.exception.HystrixRuntimeException: xxxxxxx fallback execution rejected.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;更多参数见官方文档：&lt;a href=&quot;https://github.com/Netflix/Hystrix/wiki/Configuration&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/Netflix/Hystrix/wiki/Configuration&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外附一个网友翻译的文档：&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/tongtong_use/article/details/78611225&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/tongtong_use/article/details/78611225&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;并发接口测试的方法很多，可以写代码，也可以用apache batch以及jmeter等工具。以常用的jmeter为例，测试本接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;设置环境变量：
JMETER_HOME   D:\apache-jmeter-3.0
CLASSPATH     %JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib/logkit-2.0.jar;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建线程组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180909142243583-1619056926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置并发参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180909142317881-1226647517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个参数为线程数，第二个参数为启动时间，第三个参数为请求次数。以上述配置为例即为1秒内启动50个线程，每个线程请求一次。&lt;/p&gt;
&lt;p&gt;添加HTTP请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180909142525897-703021278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里设置请求的路径，参数等等。&lt;/p&gt;
&lt;p&gt;设置请求头信息，因人而异&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180909143536844-747620279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的设置：Content-Type：application/json&lt;/p&gt;
&lt;p&gt;表格查看结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180909142703020-438322857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 查看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201809/1075594-20180909142731917-897868804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个可以根据机器的性能进行测试，以我的接口为例，当设置并发数为100以内时，基本上不会有降级处理，当并发数大于100时，就会有部分请求进入降级接口了。&lt;/p&gt;
&lt;p&gt;最后，基本上处理逻辑就这些了，实现了对接口的服务隔离和服务限流，避免了当前接口对主程序的影响。当然这个接口还有个很大的缺陷，Hystrix有个监控的组件，而我却没有实现。简单说也是一个配置的问题，后续实现验证后会在本文更新。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 06:46:00 +0000</pubDate>
<dc:creator>小卖铺的老爷爷</dc:creator>
<og:description>这段时间接了个需求，需要在我目前负责的数据系统上加个接口，主要是实现用户行为的记录。前端对接的项目主要有公司的PC，WAP，WEIXIN，APP等，每个端大概有两台左右的负载。因为目前我的这个项目主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoyeye/p/9581493.html</dc:identifier>
</item>
<item>
<title>oracle数据库应用性能优化经验（培训讲义） - 皇家救星</title>
<link>http://www.cnblogs.com/kingstarer/p/9613626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingstarer/p/9613626.html</guid>
<description>&lt;p&gt;这是我给公司同事做的内部培训ppt的讲义，给大家分享一下。这是培训大纲，ppt在找地方上传，等找到了会把链接发在这里 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/781609/201809/781609-20180909143201516-1989308650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;大家好，欢迎大家来参加今天的技术交流，而今天打算跟大家分享的是oracle数据库应用优化相关的一些经验。这是大纲。&lt;/p&gt;

&lt;p&gt;我们今天要讲的内容分五部分。其中1到3是我们今天重点交流的内容，然后四和五的话就可能，稍微快一点就带过。&lt;/p&gt;

&lt;p&gt;我先给大家简单介绍一下每个部分的内容。&lt;/p&gt;

&lt;p&gt;首先第一部分会给大家介绍一下oracle数据库的架构及一些内部实现细节。这是为了给后面介绍数据库优化知识做一些铺垫。&lt;/p&gt;

&lt;p&gt;接着，我想给大家介绍一些编写高性能sql的经验。&lt;/p&gt;

&lt;p&gt;然后在第三部分，我们会分享一下数据库的执行计划相关知识。我们平时发现sql跑得比较慢时，就可以查看执行计划，找出里面不合理的环节进行优化。&lt;/p&gt;

&lt;p&gt;第四部分内容是关于数据库等待事件及awr报告的一些优化的内介绍。awr报告相当于数据库的体检报告，等待事件就是一些体检指标。我们做整个数据库应用优化经常用到它。&lt;/p&gt;

&lt;p&gt;第五部分的话是一些学习资料推荐。&lt;/p&gt;

&lt;p&gt;下面我们开始进入第一部分内容的介绍。这是，一个oracle数据库的架构图。&lt;/p&gt;

&lt;p&gt;这里user process是客户端进程的意思，也就是我们平时自己写的程序，或者sqlplus sqldevelor这些工具。&lt;/p&gt;

&lt;p&gt;我们平时说的数据库是一个比较模糊的概念，其实它是包含两部分组成。一部分是数据库文件，包括数据文件，日志文件等。也就是这一部分，这个才是专业术语的数据库database。 另一部分是数据库实例，一套围绕真数据库运行的进程集合。&lt;/p&gt;

&lt;p&gt;这里要说明一下的是，不是比较旧的，我从网上抄下来的11g架构图。现在数据库都已经出到18c了，可能会有一些变化。另外，这图里面有一些不是太重要的数据库进程，这里是没有发出来的。嗯，我们还是看这张图吧，这图估计是oracle8i时出的图，虽然比刚才的图缺少了一些内容，但我觉得画的更好一些，所以后面会围绕这张图来介绍。&lt;/p&gt;
&lt;p&gt;从这图可以看出来，oracle数据库主要分两部分，一部分是数据库实例，由数据库后台进程和相关的共享内存组成。另一部分，就是DataBase这一块，主要是数据库文件。我们常说的数据库是对这两块内容的统称。&lt;/p&gt;
&lt;p&gt;这图还是挺重要的，大家多看几眼。接下来我们会对这图里面出现的名词做一些详细介绍。&lt;/p&gt;
&lt;p&gt;接下来，我们对数据库的一些重要组件，逐个介绍吧。&lt;/p&gt;
&lt;p&gt;‍‍&lt;/p&gt;
&lt;p&gt;首先要介绍的是‍‍数据库实例这块。这一块由两大部分组成，一个是这个，巨大的共享内存块，我们称之为SGA。另一块是oracle后台进程。&lt;/p&gt;
&lt;p&gt;SGA是非常重要的概念。它主要是做为oracle库表数据和重做日志的缓存和缓冲。下一页我们会详细讲里面具体细节。&lt;/p&gt;
&lt;p&gt;这一页我们重点要介绍的是oracle数据库后台进程。这些后台进程主要负责数据库监控，数据与日志读写，故障恢复等功能。&lt;/p&gt;
&lt;p&gt;这里我们列出几个比较常见的进程介绍。 Pmon和smon，这两个进程分别用与用户进程故障和系统故障恢复的。我们开发一般不需要关心它的工作原理，dba才需要关注。&lt;/p&gt;
&lt;p&gt;DBWN这个进程负责把SGA里面的数据写回磁盘。我们刚才说过SGA缓存了oracle数据库表数据。里面有部分数据是用户用sql修改过的，需要写回磁盘。因为数据库写磁盘比较耗时，所以数据修改总是先在SGA中修改，达到一定量或者数据库空闲时才由DBWN统一写回磁盘。&lt;/p&gt;
&lt;p&gt;LGWR也是一个比较重要的进程。它负责把Redo日志从内存中写到磁盘，用于数据库恢复。一个事务只有将Redo日志写到磁盘才能算完成。LGWR主要工作时间点是用户发起commit命令时，或者日志缓冲区超过1M时工作。&lt;/p&gt;
&lt;p&gt;Redo日志大小有限制，写满后会通过归档日志进程转移到归档日志里面。&lt;/p&gt;
&lt;p&gt;CHKP是协调LGWR和DBWN的进程。详细协调原理大家有兴趣可以上网找找，我这里主要想介绍它们之间协调需要用到的一个概念，叫系统变更号，也就是这个SCN。这个系统变更号我们可以简单理解为是oracle事务的编号，它是随着事务提交与时间变化而增长的。Oracle每个数据块都会记录修改该数据块的系统变更号。数据库做查询时，可以根据这个系统变更号判断记录是否已经最近被修改过。&lt;/p&gt;
&lt;p&gt;下面详细介绍一下SGA的组成。&lt;/p&gt;
&lt;p&gt;数据库块缓冲缓存区，这个主要是缓存数据库的数据的。包括读写数据，都会先放到这个缓冲区，有空再写回磁盘。一般交易系统这个缓冲区的命中率是很高的，超过90%。&lt;/p&gt;
&lt;p&gt;Library Cache是一个缓存，但它缓存的不是数据，而是sql以及执行计划。Oracle数据库在执行sql前，先要生成sql的执行计划，也就是sql的详细执行步骤。这个步骤生成是相对比较消耗数据库资源的。所以oracle会把生成的执行计划暂存起来，后面如果碰上一模一样的sql，就直接用现成的执行计划，不用再重新生成。所以我们平时写sql经常说要用绑定变量，一个主要原因就是减少数据库执行计划生成的时间。&lt;/p&gt;
&lt;p&gt;重做日志刚才有稍微提到，它是数据库变更的记录。例如我们发出一个update语句，把一个字段从0变成1，redo日志就会记录这个字段变成1之后的数据。数据库修改一条记录后不会立即写回磁盘的，而是先写到缓存同时登记重做日志。在事务提交时，只要把重做日志输出到磁盘，这条记录就不会因为断电丢失。因为一般来说，写数据时随机IO，写日志是顺序IO，顺序IO速度比随机IO快很多。&lt;/p&gt;
&lt;p&gt;与Redo日志对应的是Undo数据。它是存放个Undo表空间。Undo就是撤销，与重做是相反的过程。所以我们把字段从0变成1时，这里会记录的是字段在改变前，仍然是0的数据。&lt;/p&gt;
&lt;p&gt;注意Undo表空间的数据是存放在数据库文件的，所以数据库在操作回滚段时也会在Database Buffer Cache进行缓存。&lt;/p&gt;
&lt;p&gt;Undo数据有一个非常有用的作用，就是一致性读。Oracle执行select语句时一般是不锁表的，但是它还是会保证返回的数据肯定是查询开始时间点的数据，即使查询过程中，数据被修改过。这功能实现就是需要通过查询回滚数据，获得数据在修改前的状态。&lt;/p&gt;
&lt;p&gt;这是检查点的原理，检查点是用于数据库断电恢复的。大家有兴趣自己细看。&lt;/p&gt;
&lt;p&gt;数据库实例介绍完，下面我们开始介绍Database这块。Database是数据库文件集合的统称，一个Database可以对应多个数据库实例。我们常说的rac就是这样，多个数据库服务器，操作同一个数据库文件。&lt;/p&gt;
&lt;p&gt;数据库里面最重要的文件就是数据文件和联机日志文件。刚才我们有介绍过Redo日志缓存，它在用户提交事务时就会写到磁盘，就是这个联机日志。&lt;/p&gt;
&lt;p&gt;这一页介绍的是oracle数据库服务进程的知识。也就是处理我们平时写的客户端程发出的sql请求的进程。&lt;/p&gt;
&lt;p&gt;一个数据库会有很多个服务进程，这些进程共同享一个SGA。但每个进程都有自己的一块私有内存空间，我们称之为PGA。PGA默认是比较小的，如果我们需要进行大表连接，可能会嫌内存不够用，这时我们可以申请把PGA加大。做批量任务的同学可以注意一下。&lt;/p&gt;

&lt;p&gt;‍‍但是有两部分‍‍SB哎，‍‍就是这一块的内存，‍‍然后呢？他还有另外一部分就是这个‍‍这些相关的一些后台进程‍‍是比较重要的，‍‍这是一块巨大的共享内存，‍‍然后呢？它主要的功能的话就是‍‍做一个化充实‍‍这样‍‍这些数据‍‍快‍‍让我们愉快‍‍这些‍‍都会在里面存，‍‍然后‍‍这个数据是这些后台进程，‍‍后来进程，包括上面这几个，‍‍这个是每一个进程具体布置的东西‍‍监控的‍‍这个不是太重要，‍‍然后这个‍‍这个屁吗？‍‍这个是用户进程‍‍监控‍‍这个主要用于‍‍挂了的话‍‍就没有正常断开的情况下，‍‍他会帮你‍‍把这些‍‍原来‍‍重要，‍‍然后这个这个事，‍‍let‍‍这个这个这个作用的话是吧，‍‍就我们曾说过，‍‍里面有‍‍几块‍‍就是把‍‍数据库缓存的一些‍‍数据写回，‍‍然后呢。‍‍这个‍‍night。‍‍我只要。‍‍驶入池塘。‍‍日志写入进程就是‍‍跟我们数据库在‍‍定期。‍‍写到日志文件。‍‍这个是匡威。‍‍归档归档进程，‍‍这个呢是‍‍这个适用于‍‍这里面其实‍‍比较重要的话，就是需要关心的是这两个进程，‍‍不要进程的‍‍相关知识。‍‍这里。‍‍这里是oracle数据库的一些原理。‍‍这是系统改编号，‍‍就这个事，日志进程他。‍‍他有时候。‍‍接下来我们介绍这一块‍‍数据库相关的知识。‍&lt;/p&gt;
&lt;p&gt;下面让我们通过一个update语句的执行过程介绍来串讲刚才介绍过的知识吧。首先，客户端会发起sql执行请求，数据库会到缓冲池里面查找该sql执行计划是否存在。如果存在则使用现成的执行计划，这个过程称为软解析。如果执行计划不存在则需要重新生成，这个过程叫硬解析。接着数据库会分析sql需要访问的数据，看是否在数据块缓存里面。如果是则直接使用缓存数据，如果不是则需要从数据库文件读出来放到内存。&lt;/p&gt;
&lt;p&gt;接着数据库会在内存中修改数据块，并且同时登记redo日志到日志缓冲区。&lt;/p&gt;
&lt;p&gt;等到数据库提交时，redo日志的内容就会被刷进磁盘。数据缓冲区的内容则过一段时间由dbwn写进磁盘。&lt;/p&gt;
&lt;p&gt;关于数据库的主要架构介绍到这里。 这几页是数据库块的细节知识介绍，由于时间关系就不讲了。大家主要需要知道，oracle一次硬盘操作都是以数据库块为单位的，而不是以一行记录或者一个字段为单位的。一个数据库块会有n行记录。&lt;/p&gt;
&lt;p&gt;下面进入重点交流的内容，关于数据库应用优化的知识。&lt;/p&gt;
&lt;p&gt;首先，我们在数据库优化时要注意系统的类型，不同系统的优化目标是不一样的。一般来说，我们把系统分为两大类：OLTP和OLAP，也称DSS。&lt;/p&gt;
&lt;p&gt;OLTP全称是在线交易系统，像我们的收单联机系统就属这类。这类系统的特点是：交易非常频繁，但每次交易涉及的数据量很少。对数据库响应时间要求比较高，一般要求几秒甚至几毫秒内返回。&lt;/p&gt;
&lt;p&gt;OLAP全称是联机分析系统，我们平时做的批量系统就属这类。这类系统特点时：交易比较少，但每次交易涉及数据量比较多。数据库访问时间要求相对宽松点。&lt;/p&gt;
&lt;p&gt;Oltp系统常见资源瓶颈是在cpu和内存上，而oltp系统常见问题是出在io上面。&lt;/p&gt;
&lt;p&gt;这个表格介绍了两类系统开发的一些经验。&lt;/p&gt;
&lt;p&gt;OLTP由于sql运行频次较高，一般要求使用绑定变量，减少数据库生成执行计划的消耗。另外，OLTP一般要尽量减少访问数据库磁盘的次数，尽量提高内存命中率。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;在线分析系统一般是读写比比较大的系统，为了数据访问方便会做很多冗余。并且，为了数据库能得出最优的执行计划，使用绑定变量会少一些。&lt;/p&gt;
&lt;p&gt;这是一般两类系统在装数据库时的参数配置差异，也是遵循系统业务特点而配置的。&lt;/p&gt;
&lt;p&gt;前面一节介绍了系统优化的总体原则，这里会介绍一些优化细则。&lt;/p&gt;
&lt;p&gt;首先是关于索引的。&lt;/p&gt;
&lt;p&gt;索引告诉数据库有什么，而不是没有什么。所以我们平时用的不等于查询条件是用不上索引的。&lt;/p&gt;
&lt;p&gt;另外，索引列的数据类型我们也要注意。像这种情况tel电话号码列用的是字符串类型，但查询时却是用tel=数字这样的。会导致数据库索引无效。还有，像这种，我们看起来是数学等价的操作，但却会因为索引的问题导致效率相差很多。&lt;/p&gt;
&lt;p&gt;还有这个也是常见误区。不是使用索引不一定比不使用索引快。按我们平时经验，数据库里面少于100条记录，或者索引列选择比不高，例如性别字段只有男或者女，使用索引反而慢一些。因为数据库使用索引查询时需要先在索引里面做几次磁盘操作，然后找到记录位置后还要再回表数据访问记录内容。&lt;/p&gt;
&lt;p&gt;这条经验也比较重要，如果我们数据库里面有使用外键保证数据一致性，那要注意在建了外键的列上建索引。因为oracle修改父表记录时需要到子表检查修改后记录是否会违反外键约束，不建索引会很耗时。&lt;/p&gt;
&lt;p&gt;这一页想介绍的是oracle一些特性，这是oracle独有功能。用好这些特性可以在某些特定场景大大优化我们程序。&lt;/p&gt;
&lt;p&gt;这一条，讲的是oracle的rownum和rowid用法。我们平时写脚本经常会出现这样的场景：如果库表有记录，则执行a操作，否则执行b操作。有些同学会很自然地用select count(*)来判断库表是否有记录。其实我们可以在后面加上where rownum &amp;lt; 2这样的限制，这样做是告诉数据库只要找到符合条件的记录就可以结束查询，不需要统计完所有数据。&lt;/p&gt;
&lt;p&gt;Rowid概念前面的ppt页有，使用rowid访问记录是oracle访问数据最快的方法，因为rowid明确表达了数据在磁盘哪个文件，哪个数据块，哪行记录。比索引访问要快，用索引访问时需要先查出rowid再根据rowid查对应的数据。&lt;/p&gt;
&lt;p&gt;还有这个技巧，相信做批量的同学也经常用到。就是使用一些特殊方法让数据库不要记录redo日志。前面我们介绍过，对数据库操作都需要记录redo日志用于数据库出现异常时恢复数据，但如果我们确定数据不是太重要，数据库异常挂掉后不需要恢复，则可以使用这些小技巧减少redo日志以加快速度。&lt;/p&gt;
&lt;p&gt;还有一些其它不成体系的技巧，这里也介绍一下。&lt;/p&gt;
&lt;p&gt;这个是大家比较熟知的，使用绑定变量，可以复用sql执行计划，减少数据库cpu消耗。&lt;/p&gt;
&lt;p&gt;这个技巧大家应该也知道，就是删除整个表数据时，尽量考虑使用truncate。因为truncate是直接修改数据库字典，把库表占用数据空间状态改为未使用。这样操作是很快的。不过要注意的是truncate不像delete，误删后可以回滚。Truncate一执行后就会自动提交事务，并且无法闪回查询。&lt;/p&gt;
&lt;p&gt;接下来这一大章想要给大家交流的是关于数据库执行计划的一些知识。前面一章介绍的一些优化经验，这一章说的是一个优化的通用方法：通过调整执行计划改善sql运行效率。&lt;/p&gt;
&lt;p&gt;首先介绍一下执行计划的定义。执行计划就是数据库执行sql语句的步骤计划，oracle在执行sql之前会先将复杂sql拆解成一些简单步骤并依次执行。&lt;/p&gt;
&lt;p&gt;同一个sql可以有很多个不同的执行计划，这些执行计划效率差别可能很大。&lt;/p&gt;
&lt;p&gt;我们怎么看sql的执行计划呢，这里介绍几个方法：&lt;/p&gt;
&lt;p&gt;一个方法是在sqlplus里面执行set autotrace on，然后再执行sql，执行完毕后sqlplus就会打印sql执行计划及一些统计信息。&lt;/p&gt;
&lt;p&gt;还有一种，不需要执行sql，只需要执行explain命令，接着就能用sql语句查出它的执行计划。&lt;/p&gt;
&lt;p&gt;还有一种，我比较常用的方法。在plsql develor的执行计划窗口中运行sql，也可以显示执行计划。就像这边这个图片一样。&lt;/p&gt;
&lt;p&gt;知道怎么看执行计划后，我们还要懂得怎么分析。&lt;/p&gt;
&lt;p&gt;我们看这个简单的sql的执行计划，可以看出来，执行计划是树型结构，有很多个步骤组成，每个步骤都可能有子结点或者兄弟结点。&lt;/p&gt;
&lt;p&gt;我们看执行计划时需要从上往下看，碰到有子结点先后子结点，如果没有子结点，则同一层级的兄弟结点中比较靠上的一个，看完再看另一个。&lt;/p&gt;
&lt;p&gt;或者我们可以借助工具来帮我们确定执行计划执行顺序。这个就是plsql里面看执行计划的窗口，这里有一组箭头，点击它会依照执行顺序选中执行步骤。&lt;/p&gt;
&lt;p&gt;我们拿一个具体案例做一下讲解：&lt;/p&gt;
&lt;p&gt;这个sql作用是从雇员表里面找出工号小于103的数据，关联职位表取出职位信息，关联部门表取出部门信息。&lt;/p&gt;
&lt;p&gt;它对应的执行计划是这样的&lt;/p&gt;
&lt;p&gt;我们从上往下看，0 1 2都有子结点，所以先看它们的子结点。一直看到3，3没有子结点，所以先执行3。从雇员表里面取出数据。&lt;/p&gt;
&lt;p&gt;3执行完后需要执行它的兄弟结点4，4有子结点，所以先执行它的子结点5，用job_id到索引job_id_pk里面找数据的rowid。5执行完后会根据找到的数据rowid回到职位表里面找出职位信息，也就是4这个子节点的操作。&lt;/p&gt;
&lt;p&gt;3和4执行完后就要回到2，把数据连接到一起。然后再执行6和7，从部门表里面取出数据，接着执行1再把部门数据跟前面的雇员与职位表连接结果再合并，最后回到0，返回客户端。&lt;/p&gt;
&lt;p&gt;所以这个执行计划的执行顺序就是3 5 4 2 7 6 1 0&lt;/p&gt;
&lt;p&gt;像这个是比较复杂一点的执行计划，大家有兴趣可以自己回去看它的执行顺序。答案在这一列。&lt;/p&gt;
&lt;p&gt;前面我们说过，同一个sql会有很多不同执行计划。那数据库怎么确定使用哪个执行计划呢。这就涉及这章要介绍的，优化器的概念。&lt;/p&gt;
&lt;p&gt;优化器是数据库的一个核心组件，负责将sql根据各种判断标准转换成最优的执行计划。&lt;/p&gt;
&lt;p&gt;现在我们用的优化器都是cbo，基于成本计算的优化器。它会计算每个sql执行步骤的成本，挑选总成本最低的执行计划。&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 06:34:00 +0000</pubDate>
<dc:creator>皇家救星</dc:creator>
<og:description>oracle,awr,sql优化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingstarer/p/9613626.html</dc:identifier>
</item>
<item>
<title>从你的全世界路过—一群程序员的稻城亚丁游记 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/travel_daocheng_yading_introduction.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/travel_daocheng_yading_introduction.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;温馨提示：&lt;/strong&gt;&lt;/em&gt;本文图片较多，考虑到上传速度与页面加载，大部分图片都经过压缩不足1M，如想看高清照片，请私信我。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180908231856368-168024162.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　稻城亚丁，一个看似熟悉而又不熟悉的名字。说它熟悉是因为在电影《&lt;strong&gt;从你的全世界路过&lt;/strong&gt;》中它作为茅十八求婚以及陈末幺鸡最终再次见面的地方，充满了浪漫的气息。说它不熟悉是因为我们对其的了解仅仅停留于电影中那优美的景色和雪山风貌，却对它的历史和文化不甚了解。对我来说，稻城亚丁不是陌生的，因为在5年前（2013年国庆期间）我和表妹便一起去过稻城亚丁一次，当时由于是国庆节期间临时决定去的，所以当时给我的体验并不算好，人多车多加高反，还被当时的藏族兄dei坑了，最后辗转到云南香格里拉去坐了飞机回成都，七天有四天时间花在了坐车上面。2013年当时我们去的大致路线是：成都-康定-理塘-稻城-亚丁-稻城-香格里拉（云南）-成都，你可以通过这个&lt;span&gt;&lt;a href=&quot;https://user.qzone.qq.com/516365667/photo/V12oMbez4aBtyC/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;链接&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;查看我当时拍的照片相册。&lt;/p&gt;
&lt;p&gt;　　转眼之间5年过去了，在我们以前团队的聚餐上，有同事提议来一次川西之旅，于是大家纷纷响应，依次请好年假（我司每年有10天年假，&lt;span&gt;&lt;a href=&quot;https://search.51job.com/list/090200,000000,0000,00,9,99,%25E5%25AE%258F%25E5%2588%25A9%25E9%2587%2591%25E8%259E%258D%25E5%2585%25A8%25E7%2590%2583%25E6%259C%258D%25E5%258A%25A1%25E4%25B8%25AD%25E5%25BF%2583,2,1.html?lang=c&amp;amp;stype=&amp;amp;postchannel=0000&amp;amp;workyear=99&amp;amp;cotype=99&amp;amp;degreefrom=99&amp;amp;jobterm=99&amp;amp;companysize=99&amp;amp;providesalary=99&amp;amp;lonlat=0%2C0&amp;amp;radius=-1&amp;amp;ord_field=0&amp;amp;confirmdate=9&amp;amp;fromType=&amp;amp;dibiaoid=0&amp;amp;address=&amp;amp;line=&amp;amp;specialarea=00&amp;amp;from=&amp;amp;welfare=&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;em&gt;欢迎加入Manulife成都IT技术服务部&lt;/em&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;em&gt;！&lt;/em&gt;），6人（3男3女合理搭配）小队组团成功，我们决定驾驶两部小车来自驾游（你也可以选择从成都直飞稻城亚丁机场，不过这个机场离亚丁景区还有2小时路程，强烈建议自驾，因为从康定到稻城这一段国道一路都是风景）。此外，我个人也想借着这个第二次的川西之旅来散散心，虽然自己又成为了单身狗，但是我还是我，旅途中可以梳理一下心情回来再次出发！出发之前，我们先了解了解稻城亚丁的基本情况吧。&lt;/p&gt;
&lt;p&gt;　　稻城亚丁风景区位于四川省甘孜藏族自治州稻城县香格里拉镇（香格里拉镇原名是日瓦乡，不要跟云南的香格里拉市弄混淆了）亚丁村境内，主要由“&lt;strong&gt;仙乃日&lt;/strong&gt;、&lt;strong&gt;央迈勇&lt;/strong&gt;、&lt;strong&gt;夏诺多吉&lt;/strong&gt;”三座神山和周围的河流、湖泊和高山草甸组成，它的景致保持着在地球上近绝迹的纯粹，因其独特的地貌和原生态的自然风光，被誉为“香格里拉之魂”和“&lt;span&gt;&lt;strong&gt;最后的香格里拉&lt;/strong&gt;&lt;/span&gt;”，被国际友人誉为“&lt;span&gt;&lt;strong&gt;水蓝色星球上的最后一片净土&lt;/strong&gt;&lt;/span&gt;”，是摄影爱好者的天堂。&lt;/p&gt;
&lt;p&gt;　　景区内不仅有壮丽神圣的雪山，还有辽阔的草甸、五彩斑斓的森林和碧蓝通透的海子，&lt;span&gt;&lt;strong&gt;雪域高原最美的一切几乎都汇聚于此&lt;/strong&gt;&lt;/span&gt;，这一切的一切都让人流连忘返。如当地虔诚的藏民一样，徒步转山是感受亚丁风光的最好方式。不过由于亚丁保护区海拔较高，全程徒步还是需要相当的体力（并且带着高反爬山更耗费体力）。&lt;/p&gt;
&lt;p&gt;　　亚丁在藏语意为“&lt;strong&gt;向阳之地&lt;/strong&gt;”。保护区内的三座雪山：仙乃日、央迈勇、夏诺多吉，南北向分布，呈品字形排列，统称“念青贡嘎日松贡布”，意为：终年积雪不化的三座护法神山圣地。藏传佛教中称其为“三怙主雪山”，是藏民心中的神圣之地。&lt;/p&gt;
&lt;p&gt;　　1928年，美国植物学家、探险家&lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%C2%B7%E6%B4%9B%E5%85%8B&quot; target=&quot;_blank&quot;&gt;约瑟夫·洛克&lt;/a&gt;到达此地，回国后在美国《国家地理杂志》上撰文并刊登所摄照片，将亚丁介绍给了全世界。=&amp;gt; &lt;em&gt;我真的是佩服这个约瑟夫洛克，在那么多年前跑到了这个世外仙境拍照，我很好奇他是怎么找到这里的？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　稻城亚丁作为国家5A级景区，海拔2900米（贡嘎河口）至6032米（仙乃日峰），高原山地气候，最佳观赏季节为4-5月与9-10月。=&amp;gt; &lt;em&gt;体质不好的慎去，去的话记得提前吃红景天与备好氧气瓶，前面说到了，如果全程徒步需要相当的体力，更何况还是在海拔3000-4500的高原上。&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;2.1 Day 1：CSM培训 + 快马加鞭直奔康定&lt;/h2&gt;
&lt;p&gt;　　虽说我的标题是六日五晚，但其实严格算来只有5.3日，因为第一天的大部分时间我都在公司参加Scrum的认证培训课程。CSM全名Certified Scrum Master，Scrum是Agile敏捷开发中的默认标准，我司从2015年开始敏捷转型至今已3年，不过始终感觉抓住了形而不见其神，因此公司花了大价钱请了优普丰敏捷学院的CST（Certified Scrum Trainer）申导（Jacky Shen）来给我们做CSM的培训，后续还有CSPO（Certified Scrum Product Owner）的培训，不过给我的定位是SM层次，所以后面我就不会再参加了。下面来一张当时CSM培训的照片：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909000004559-1745179877.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是CSM培训之后，参加认证考试通过后的认证照片：（不得不说，Scrum的这个考试挺简单的，熟读Scrum Guide就可以，不过要参加这个认证考试需要16个Scrum联盟认可的PDU（你可以理解为学分），这个PDU可以通过参加培训来获取）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909000107867-542179439.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有了认证之后，你就可以在Scrum联盟的网站中输入你的信息了，你可以通过这个Scrum联盟的这个&lt;span&gt;&lt;a href=&quot;https://www.scrumalliance.org/community/profile/ezhou10&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;链接&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中找到我。&lt;/p&gt;
&lt;p&gt;　　下午4点50，CSM培训完整结束（一共两天，这是第二天），于是我们立即快马加鞭一路从成雅高速一直奔到了泸定，不得不说自从高速公路通往泸定之后，成都去康定的时间大大缩短。不过，泸定到康定这一段318国道的路况不是太好，有点美中不足！（因为从康定到稻城这一段国道的路况不错）最终，我们总共花了4小时左右（加上中途服务站休息的时间）便从成都飞奔到了康定，这时已是晚上九十点了。&lt;/p&gt;
&lt;p&gt;　　康定是四川省甘孜藏族自治州的首府，康巴藏区政治、经济、文化、商贸、信息中心和交通枢纽，相信你也许听过《康定情歌》：“跑马溜溜的山上，一朵溜溜的云哟，端端溜溜的照在康定溜溜的城哟...”&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909001421140-1991264092.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[康定的折多河，河水是从折多山上流下来的，河水很湍急，在河边看着很震撼！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909001626776-139275838.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[康定情歌广场附近的楼房，这个角度看上去山上的灯光就像是一颗又一颗的星星]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909002711768-2139648382.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[折多河旁的神佛像，23点后熄灯就看不到了]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909111239077-1294110941.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这一晚我们入住的是一家小旅馆叫做酒都客栈，居然要是从负一楼往上走，也是醉了，感觉像是进了，住宿条件较差，不过老板服务态度还行，100多一晚的小标间，临路较吵，加上失眠，我和同事这一晚没有睡好。&lt;/p&gt;
&lt;h2&gt;2.2 Day 2：康定→新都桥→雅江→理塘→稻城→香格里拉镇&lt;/h2&gt;
&lt;p&gt;　　第二天一早我们便在康定吃了早饭，开始了紧凑的一B的路程。一路翻过了折多山，路过了新都桥（被称为“摄影家的天堂”），天路十八弯考验驾驶技术，雅江县吃午饭，理塘县压马路，路上被五菱宏光超车后一直没有追上（我们是不是地把马自达的车标给五菱宏光？），稻城到香格里拉开夜车，晚上20:30终于到了香格里拉镇。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909003705623-1416592422.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[折多山顶，4298米纪念碑的合照]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909003931135-1345917183.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[天路十八弯，感受头文字D中的五连发夹弯！可惜我不敢排水渠过弯！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909004205084-45339746.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[一路都是观景台，找个观景台来拍照吧！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909004431990-950910216.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[和智美伙伴马三拉蒂来一张吧，86上山了，86上山了！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909133613761-147913352.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[这一路上都是类似于Windows XP的风景！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909004703932-1284744289.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[一路都是草甸，新都桥附近找个草甸来个深沉一点的]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909005024922-490863008.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[同事在理塘县的国道上专程给我拍的公路照，是不是挺有feeling？值得一提的是，理塘县是中国海拔（4014米）最高的&lt;strong&gt;县&lt;/strong&gt;（注意是&lt;strong&gt;县&lt;/strong&gt;！）]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;理塘，系藏语，藏语拼音：Litang Zong。“理”意为“铜”，“塘”为“坝子”，即&lt;strong&gt;广阔坝子&lt;/strong&gt;有如铜镜。故为里塘土司地。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909005215756-535730888.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[海子山上的美景，不得不让我好好思考下人生！]&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;海子山平均海拔4500米，最高峰果银日则海拔为5020米，共有1145个大小海子。其规模密度在我国是独一无二的，故名海子山。海子山&lt;strong&gt;位于理塘与稻城两县之间&lt;/strong&gt;。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909005514401-1909244330.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[快到稻城县时碰到一群牦牛群压马路，停下来等这群大爷安全走过]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909005628275-166513632.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[在香格里拉镇吃一顿正宗的藏餐，给这家店“仓央嘉措藏餐厅”点个赞，大爱手撕牦牛肉，这一餐人均消费大约50元]&lt;/p&gt;
&lt;p&gt;　　这一晚在图腾客栈入住，房间质量比康定的旅馆好一些，价格大约在150多左右一晚，客栈内有一只大金毛，还有许多来自天南海北的同去亚丁景区的游客，并且离各个餐馆和酒吧的地方很近，因此总体来说，值得推荐。不过，看携程评论上说老板娘很好，只是一直没有体会到。&lt;/p&gt;
&lt;h2&gt;2.3 Day 3：香格里拉镇→亚丁风景区→四号营地→亚丁徒步小环线&lt;/h2&gt;
&lt;p&gt;　　这一天一早便离开客栈，开车到了亚丁景区游客中心，现在门票是270元（包括门票+观光车，不买观光车你是上不去的），温馨提示，买票后可以去9号窗口或者小办公室兑换发票，稻城亚丁是被报道过不粗发票的。此外，亚丁游客中心有一个三层楼的停车场，单次停车20元，过夜的话40元。我很难想象国庆节的时候，这个停车场会有多少空位，不敢想象。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909113031933-1682678723.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[亚丁景区游客中心]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909114018043-1024742928.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[亚丁门票]&lt;/p&gt;
&lt;p&gt;　　乘着观光车一路上山，大约坐了30分钟终于到了我们要住宿的四号营地。这里说下，在亚丁景区内的几个营地，分为一号，二号，三号，四号。我们选择的是四号营地，因为这里可以直接看到仙乃日神山的风貌，并且有机会看到日照金山（日出），最大的便利之处就是你可以不用出景区，且要徒步游览完亚丁得需要2天时间。当然，费用也会贵一些，无论是住宿还是用餐。亚丁的用餐不用担心吃不惯，都是我们平常吃的家常菜，不过由于稻城没有自己种的菜，很多都需要从云南“进口”（毕竟人家是藏族一般吃藏餐），所以价格会贵一些。四号营地的住宿条件虽然也一般，不过也不敢奢求太多，至少整体环境不错，因为它有一个很大的露天阳台，可以容纳很多人看星星看月亮看神山。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909114202065-1774791238.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[在四号营地的大阳台坐着晒太阳，仰望仙乃日神山]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909114930467-1035142597.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[四号营地院子里的格桑花]&lt;/p&gt;
&lt;p&gt;　　在四号营地安顿好之后，我们便继续坐观光车前往亚丁景区。这一天我们的计划是走小环线，即冲古寺和仙乃日两个刷卡点。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909114432485-1312206132.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[刚刚下观光车看到的亚丁景区门口的风光]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909114638356-1122924568.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[在冲古寺前仰望神山，陷入沉思？]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909114811271-113252925.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[冲古寺门前打卡]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909115108620-1519258982.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[刻有藏文的石头山]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909115306872-34830582.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[去往卓玛拉措的路上的一个海子，不知道叫啥？]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909115448042-625327822.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[仙乃日的最佳观（拍）景（照）点：卓玛拉措，据说每个来的人都会在这里拍一张]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909115615303-1424776093.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[爬山途中偶遇一只小松鼠，于是给了它一点肉松饼]&lt;/p&gt;
&lt;p&gt;　　仙乃日这条线，是需要爬山的，不过相比后面的大环线，爬山路程还是较短，不过有高反也是正常的。这条线的必打卡观景点是卓玛拉措，虽然我也去了仙乃日观景点，单个人觉得没有卓玛拉措景色好。此外，个人建议如果你有两天的亚丁景区游计划的话，最好第一天走长线，这样第二天走短线时间上比较充足，方便你下山（因为一般第二天你都会早点离开亚丁，如果你要去远点的地方的话不至于开很久的夜车）。如果你看过《从你的全世界路过》，茅十八求婚的地方就在冲古寺附近，那里是冲古草甸。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909121621675-1436950888.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[冲古草甸，我的幺鸡在哪里？]&lt;/p&gt;
&lt;p&gt;　　下午回到四号营地之后，休息了一会便开始吃饭。之前说到，营地内的饭菜价格很贵，而且整个营地厨师就只有一个，因此游客很多的话，经常会出现这一桌子的人等着和看着另一桌子的人吃饭的场景，简直是望眼欲穿。幸运地是，我们是那桌被围观的人，第一个点餐的，人均消耗也是50左右（一共6人）。吃完后，旁边散了散步便在院子里坐着等着看星空了，不过温馨提示，建议去房间里把毛毯拿出来披着，不然会很冷的，感冒了可不好！这一晚，幸运的我们看到了银河和流星，而且经过我同事的不懈努力和客栈游客朋友的镜头，终于拍下了这个灿烂的银河照片，与各位园友分享一下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909120445023-108587633.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[亚丁的夜空银河]&lt;/p&gt;
&lt;h2&gt;2.4 Day 4：四号营地→亚丁徒步大环线→稻城&lt;/h2&gt;
&lt;p&gt;　　这一天6点多就起来了，为了看日出，感受日照金山，大家也是忍住了不睡久一点。功夫不负有心人，总算看到了，也拍了下来。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909120735514-81203004.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[日照仙乃日神峰]&lt;/p&gt;
&lt;p&gt;　　随后我们便再次进入亚丁景区，今天的计划是走大环线，即电瓶车到洛绒牛场，然后徒步来回近11公里观望牛奶海和五色海（这两个海子在山顶，也就是说你需要爬山，对，在高原爬山！）Of course，这条线的必打卡点就是洛绒牛场，牛奶海和五色海。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909121128420-1683531998.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[洛绒牛场]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909122138055-1244310872.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[洛绒牛场]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909123828106-1727931208.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[洛绒牛场合照]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909121757486-1118827494.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[随处可见的石头山，触手可及的藏文化]&lt;/p&gt;
&lt;p&gt;　　对于体质不好的人或者高反严重的人，可以选择骑马爬山，不过价格也是很贵，300元一人次。所以，建议还是带点氧气瓶爬山吧，如果你高反的话。一般走走停停加拍照的话，来回得近5~6个小时，对于长期在成都平原居住的我们这群程序员的体力真的是个考验。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909122436391-2023370394.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[爬山途中经过的一个海子，我们一度以为这是牛奶海，导致我们过于乐观，哪知道牛奶海还有很远！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909122656857-608668408.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[爬山途中经过的一个小山峰，观望夏洛多吉神峰]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大家可以看到我带了口罩，太阳镜和帽子，&lt;span&gt;&lt;strong&gt;这都是必须的&lt;/strong&gt;&lt;/span&gt;！不然，你会晒脱皮的！我这次耳朵没有做防护工作，已经晒脱了一层皮了。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909121855740-1999869704.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[爬山，爬山，爬山，好累！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909122903177-464223339.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[爬山爬的腿感觉不是自己的了，发现牛奶海还在上边！！！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909123012595-1036814963.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[五色海，位于仙乃日与央迈勇之间，海拔4600米，湖面呈圆形。现代冰谷下伸至湖畔，雪山倒影湖面，呈现奇幻的色彩。是藏区著名的圣湖，据传能“返演历史，预测未来”，有很多宗教上的传说。]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909123152535-402690816.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[我们是从五色海走到牛奶海的，建议你可以选择先走牛奶海再到五色海，这一条路线坡度没有直接从五色海到牛奶海的坡度大，上图是从五色海走到牛奶海途中拍的，可以看到牛奶海的湖面]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909130107378-915141710.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[牛奶海又叫俄绒措：古冰川湖，状如水滴，四周雪山环绕，湖水清莹碧蓝，山止成瀑，以其玲珑秀雅水色翠蓝而著名，俄绒措上方有大片的冰川。传说是能治聋哑怪病的圣湖]&lt;/p&gt;
&lt;p&gt;　　逛完牛奶海和五色海之后，便马不停蹄的下山，也是累的不行，加上有点高反，也没有用氧气瓶，感觉脚真的不属于自己了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;感悟：&lt;/strong&gt;&lt;/em&gt;如果你爱一个人，请带Ta爬一次牛奶海和五色海！如果你恨一个人，&lt;span&gt;&lt;strong&gt;也&lt;/strong&gt;&lt;/span&gt;请带Ta爬一次牛奶海和五色海！　　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　由于这一晚预定的是稻城县城的三姐妹温泉客栈，所以快马加鞭的下山和开车（毫无疑问，又开了夜车），匆匆地离开亚丁村和香格里拉镇。因此，刚刚提到建议第一天走大环线住景区内的营地，第二天走小环线便可以比较从容地下山了，无论是在香格里拉镇住还是去稻城县时间上比较宽容，不至于开夜车。现在说说这个三姐妹温泉客栈，我们一度以为应该是在县城内，结果是在县城外，这一路没有光的路差点让我怀疑人生。导航给的地址是对的，不过蛮好找的，得下车问问当地的村民。这个村的人们几乎都开了温泉客栈，而且这里的温泉都是天然的，他们就靠着这个谋生了。当然入住，发现住宿条件跟康定那晚差不多，不过失之东隅收之桑榆，提供的温泉倒是蛮不错的，而且还是小房间式的，供2~3人的小温泉，洗去了当天爬山的疲惫。重要的是，这个老板很淳朴，和我5年之前遇到的藏族人不同，感觉她没有“学坏”，仍然保留着一颗真诚的佛教信仰，也算是想给她一个好评。她们家会在客栈附近修建一个露天的温泉，估计10月份就会开始提供服务，所以后面去的朋友们，可以考虑一下三姐妹温泉客栈哟！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909125455053-1778104644.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[正在修建中的露天温泉]&lt;/p&gt;
&lt;h2&gt;2.5 Day 5：稻城→理塘→雅江→塔公草原→丹巴县→甲居藏寨&lt;/h2&gt;
&lt;p&gt;　　从Day 5开始就算是回程之旅了，早晨从稻城离开，首先经过的就是之前我们流连忘返的海子山，可以看到石海（全是石头）！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909125849971-1733529908.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[海子山观石海]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909130347565-1173988966.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[国道旁观格桑花田]&lt;/p&gt;
&lt;p&gt;　　在回程途中，我们没有选择原路返回，而是选择了塔公草原到丹巴县的这条路。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909130543773-1380435184.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[前往塔公草原的路上]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909130700549-903091409.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[国道旁随处找一处草甸来一个跳拍吧！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909130824510-1828181767.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[去丹巴途中偶遇彩虹，真的是不虚此行！]&lt;/p&gt;
&lt;p&gt;　　塔公草原是甘孜州最著名的一个草原，位于塔公镇内，也是一个打卡的景点，虽然我觉得好像也没什么好看的地方？可能是看过了亚丁这种更优美的地方了吧。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909131759766-363237628.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909131120989-416109938.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[在塔公草原上虔诚一点！]&lt;/p&gt;
&lt;p&gt;　　此外，在塔公草原上我们还进行了一次cosplay，头文字D海报的买家秀与卖家秀，简直是不忍直视！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909131244113-1373550250.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[头文字D]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909132613857-1742431563.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[辣眼睛的在下面！！！]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909131335214-1231159836.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[油文字D]&lt;/p&gt;
&lt;p&gt;　　塔公草原之后，我们便马不停蹄地开往了丹巴县甲居藏寨，我们选择的仍然是三姐妹精品客栈。不过这三姐妹来头就大了，大姐桂花可是去过人民大会堂见过七常委的风云人物。想要了解她们的故事，可以点击这个&lt;a href=&quot;http://epaper.scdaily.cn/shtml/scrb/20141022/81635.shtml&quot; target=&quot;_blank&quot;&gt;四川日报的链接&lt;/a&gt;查看。由于三姐妹精品客栈不太好找，当时电话又联系不上老板，导致一度我们的印象不是很好，想给她一个差评，不过后来停了桂花大姐的故事之后，改变了看法，也还是打算给她一个好评，因为将心比心，桂花的励志故事远比这个酒店精彩。有兴趣去丹巴旅游的朋友，可以去听听桂花三姐妹的故事。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/em&gt;：甲居藏寨三姐妹的客栈有好几个，但都算是她们家的，不过是分为几个等级，不同等级的价格不同。比如精品客栈，打造的是类似于酒店的方式，所以价格也会更贵一些，比如这一晚我们预定的标间290一晚，但配置也会更好一些。再比如精品民宿，打造的是类似于民宿的方式，配置低一些，但是民居体验更强烈一些。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这一晚我睡得很好，不知道是不是酒店配置不错的原因还是我真的太累了...&lt;/p&gt;
&lt;h2&gt;2.6 Day 6：甲居藏寨→四姑娘山→巴朗山→熊猫沟→映秀→都江堰→成都&lt;/h2&gt;
&lt;p&gt;　　这一天上午9点才起来，也算是补了下瞌睡，然后我们就在甲居藏寨的观景点逛了逛，分享一些甲居藏寨的风景。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909132455619-421620175.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[从三姐妹餐厅楼顶望去]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909132923489-1440618324.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[三姐妹餐厅内看到三姐妹的照片，美人谷出美人啊！下面照片中最右边这个是桂花大姐]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909133106206-1464867833.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[三姐妹餐厅内的两只猫咪，静静地睡着不忍打扰]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909132752854-1178230910.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[走在甲居藏寨的乡道上，处处都是风景]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909133205247-482783199.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[在三姐妹民宿楼顶观望甲居藏寨风光]&lt;/p&gt;
&lt;p&gt;　　此外，桂花大姐还邀请我们去摘她家的梨子，我们也是弄了很多梨子吃。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909133724086-1821220919.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[一起瓜分梨子]&lt;/p&gt;
&lt;p&gt;　　吃完梨子作为午饭（已经是中午12:00多了），我们又开始了长达8~9小时的回成都之旅。回程途中，经过一个镇，镇名叫做：沃日镇，莫名一股喜感。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909134055661-1187000311.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[沃日镇]&lt;/p&gt;
&lt;p&gt;　　随后一路经过了四姑娘山，熊猫沟，映秀和都江堰，最终回到绕城高速。途中经过巴朗山隧道时，遇到了大雾，能见度不足3米，醉了，于是龟速前行。在此也温馨提示一下，如果旅程图中遇到这种大雾，一定记得慢慢行驶，并且确保雾灯和应急灯全程开启。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909134216454-1569853763.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最终见到了熟悉的环球中心，AE86终于下山回家了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909133913708-412553936.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[绕城高速上观望成都环球中心，抱歉，照片质量拍的有点差]&lt;/p&gt;
&lt;p&gt;　　回到家之后，收到了腾讯云+社区送来的周边礼物，谢谢腾讯云+社区的小姐姐们。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909134402756-1443592190.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这是我的第二次川西之旅，距离上一次已经五年了。五年弹指一挥间，我从在校的研究生到现在工作三年的中年码农，表面上看上去是个白领，本质上仍然是踩着柔弱的细线过河的屌丝。不管怎样，读万卷书，行万里路，要有诗，也要有远方，这是我一直以来的目标和向往，我也会一直为止努力，寻求工作与生活的balance，努力工作，热爱生活。当你感到疲惫感到迷茫的时候，当你急着在大城市中达成自己的物质目标却又不成的时候，不妨去川西游游，寻求一下内心的平静。同样，我也把我们在途中遇到的坑和建议分享了出来，也希望对各位想要去川西特别是稻城亚丁旅游的朋友们有帮助。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180909134827041-1214732983.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 09 Sep 2018 05:52:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>温馨提示：本文图片较多，考虑到上传速度与页面加载，大部分图片都经过压缩不足1M，如想看高清照片，请私信我。 一、关于稻城亚丁 稻城亚丁，一个看似熟悉而又不熟悉的名字。说它熟悉是因为在电影《从你的全世界</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/travel_daocheng_yading_introduction.html</dc:identifier>
</item>
<item>
<title>【Spring】BeanFactory解析bean详解 - weknow619</title>
<link>http://www.cnblogs.com/weknow619/p/9612710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weknow619/p/9612710.html</guid>
<description>&lt;div readability=&quot;7.7512953367876&quot;&gt;本文是Spring源码分析中的一篇，来讲讲Spring框架中BeanFactory解析bean的过程，先来看一个在Spring中一个基本的bean定义与使用。（也可以来&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4ODEyMTgwMA==&amp;amp;mid=2650163485&amp;amp;idx=1&amp;amp;sn=844d687297731ab2c679b3c37789f23a&amp;amp;chksm=f3c1dfbac4b656ac7776a808b179b7d69cc0267c8de4686aed1e604faaca4cabed4c188d0fa1&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0909VDclNnzDZ03doydbUEls&amp;amp;pass_ticket=1fSFD5nC9Rbw7NC4YMwFPr0tmWOBaLQEFOy%2FA5EkBVD1gtAkGj7ovtwgv%2Byg9Xc5#rd&quot; target=&quot;_blank&quot;&gt;公号&lt;/a&gt;查看）&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestBean {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String beanName = &quot;beanName&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getBeanName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String beanName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.beanName =&lt;span&gt; beanName;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.9960713701097&quot;&gt;
&lt;p&gt;Spring配置文件root.xml定义如下：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; 
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans 
      http://www.springframework.org/schema/beans/spring-beans-4.1.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;testBean&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;bean.TestBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;24.987332151001&quot;&gt;
&lt;p&gt;下面使用XmlBeanFactory来获取该bean：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BeanTest {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; java.util.logging.Logger logger = LoggerFactory.getLogger(BeanTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getBeanTest() {
        BeanFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; XmlBeanFactory(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;root.xml&quot;&lt;span&gt;));
        TestBean bean &lt;/span&gt;= factory.getBean(&quot;testBean&quot;&lt;span&gt;);
        logger.info(bean.getBeanName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;p&gt;这个单元测试运行结果就是输出beanName，上面就是Spring最基本的bean的获取操作，这里我用BeanFactory作为容器来获取bean的操作并不多见，在企业开发中一般是使用功能更完善的ApplicationContext，这里先不讨论这个，下面重点讲解使用BeanFactory获取bean的过程。&lt;/p&gt;

&lt;p&gt;现在就来分析下上面的测试代码，看看Spring到底为我们做了什么工作，上面代码完成功能的流程不外乎如此：&lt;/p&gt;
&lt;p&gt;1. 读取Spring配置文件root.xml；&lt;/p&gt;
&lt;p&gt;2. 根据root.xml中的bean配置找到对应的类的配置，并实例化；&lt;/p&gt;
&lt;p&gt;3. 调用实例化后的对象输出结果。&lt;/p&gt;

&lt;p&gt;先来看看XmlBeanFactory源码：&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XmlBeanFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DefaultListableBeanFactory {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; XmlBeanDefinitionReader reader = &lt;span&gt;new&lt;/span&gt; XmlBeanDefinitionReader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(resource, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
   }

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
       &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parentBeanFactory);
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reader.loadBeanDefinitions(resource);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;14.5&quot;&gt;
&lt;p&gt;从上面可以看出XmlBeanFactory继承了DefaultListableBeanFactory，DefaultListableBeanFactory是Spring注册加载bean的默认实现，它是整个bean加载的核心部分，XmlBeanFactory与它的不同点就是XmlBeanFactory使用了自定义的XML读取器XmlBeanDefinitionReader，实现了自己的BeanDefinitionReader读取。&lt;/p&gt;
&lt;p&gt;XmlBeanFactory加载bean的关键就在于XmlBeanDefinitionReader，下面看看XmlBeanDefinitionReader的源码（只列出部分）：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XmlBeanDefinitionReader &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractBeanDefinitionReader {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Class&amp;lt;?&amp;gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ProblemReporter problemReporter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FailFastProblemReporter();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ReaderEventListener eventListener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyReaderEventListener();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SourceExtractor sourceExtractor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullSourceExtractor();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; NamespaceHandlerResolver namespaceHandlerResolver;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DocumentLoader documentLoader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultDocumentLoader();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EntityResolver entityResolver;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ErrorHandler errorHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleSaxErrorHandler(logger);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;XmlBeanDefinitionReader继承自AbstractBeanDefinitionReader，下面是AbstractBeanDefinitionReader的源码（只列出部分）：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractBeanDefinitionReader &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; EnvironmentCapable, BeanDefinitionReader {

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Log logger =&lt;span&gt; LogFactory.getLog(getClass());

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; BeanDefinitionRegistry registry;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ResourceLoader resourceLoader;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ClassLoader beanClassLoader;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Environment environment;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; BeanNameGenerator beanNameGenerator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultBeanNameGenerator();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;19.98630449669&quot;&gt;
&lt;p&gt;XmlBeanDefinitionReader主要通过以下三步来加载Spring配置文件中的bean：&lt;/p&gt;
&lt;p&gt;1. 通过继承自AbstractBeanDefinitionReader中的方法，使用ResourLoader将资源文件（root.xml）路径转换为对应的Resource文件；&lt;/p&gt;
&lt;p&gt;2. 通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Ducument文件；&lt;/p&gt;
&lt;p&gt;3. 通过DefaultBeanDefinitionDocumentReader类对Document进行解析，最后再对解析后的Element进行解析。&lt;/p&gt;

&lt;p&gt;了解以上基础后，接下来详细分析下一开始例子中的代码：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BeanFactory factory = &lt;span&gt;new&lt;/span&gt; XmlBeanFactory(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;root.xml&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;先看看下面XmlBeanFactory初始化的时序图来进一步了解这段代码的执行，&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1044046/201704/1044046-20170405092455394-263253766.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;在这里可以看出BeanTest测试类通过向ClassPathResource的构造方法传入spring的配置文件构造一个Resource资源文件的实例对象，再通过这个Resource资源文件来构造我们想要的XmlBeanFactory实例。在前面XmlBeanFactory源码中的构造方法可以看出，&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(resource, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
     &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parentBeanFactory);
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reader.loadBeanDefinitions(resource);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;this.reader.loadBeanDefinition(resource)就是资源加载真正的实现，时序图中XmlBeanDefinitionReader加载数据就是在这里完成的。&lt;/p&gt;

&lt;p&gt;接下来跟进this.reader.loadBeanDefinition(resource)方法里面，&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XmlBeanDefinitionReader &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractBeanDefinitionReader {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; loadBeanDefinitions(Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; loadBeanDefinitions(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EncodedResource(resource));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;15.986352004549&quot;&gt;
&lt;p&gt;在loadBeanDefinition(resource)方法里对资源文件resource使用EncodedResource进行编码处理后继续传入loadBeanDefinitions方法，继续跟进loadBeanDefinitions(new EncodedResource(resource))方法源码：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; loadBeanDefinitions(EncodedResource encodedResource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
    Assert.notNull(encodedResource, &lt;/span&gt;&quot;EncodedResource must not be null&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
        logger.info(&lt;/span&gt;&quot;Loading XML bean definitions from &quot; +&lt;span&gt; encodedResource.getResource());
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过属性记录已加载的资源&lt;/span&gt;
    Set&amp;lt;EncodedResource&amp;gt; currentResources = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourcesCurrentlyBeingLoaded.get();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentResources == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        currentResources &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;EncodedResource&amp;gt;(4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourcesCurrentlyBeingLoaded.set(currentResources);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;currentResources.add(encodedResource)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(
                &lt;/span&gt;&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从resource中获取对应的InputStream，用于下面构造InputSource&lt;/span&gt;
        InputStream inputStream =&lt;span&gt; encodedResource.getResource().getInputStream();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            InputSource inputSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputSource(inputStream);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (encodedResource.getEncoding() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用doLoadBeanDefinitions方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            inputStream.close();
        }
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException(
                &lt;/span&gt;&quot;IOException parsing XML document from &quot; +&lt;span&gt; encodedResource.getResource(), ex);
    }
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        currentResources.remove(encodedResource);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (currentResources.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourcesCurrentlyBeingLoaded.remove();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;p&gt;继续跟进doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法，这是整个bean加载过程的核心方法，在这个方法执行bean的加载。&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        Document doc &lt;/span&gt;=&lt;span&gt; doLoadDocument(inputSource, resource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(doc, resource);
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 省略一堆catch &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;跟进doLoadDocument(inputSource, resource)源码：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; Document doLoadDocument(InputSource inputSource, Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.documentLoader.loadDocument(inputSource, getEntityResolver(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.errorHandler,
            getValidationModeForResource(resource), isNamespaceAware());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;14.5&quot;&gt;
&lt;p&gt;在doLoadDocument(inputSource, resource)方法里就使用到了前面讲的documentLoader加载Document，这里DocumentLoader是个接口，真正调用的是其实现类DefaultDocumentLoader的loadDocument方法，跟进源码：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultDocumentLoader &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DocumentLoader {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
            ErrorHandler errorHandler, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; validationMode, &lt;span&gt;boolean&lt;/span&gt; namespaceAware) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        DocumentBuilderFactory factory &lt;/span&gt;=&lt;span&gt; createDocumentBuilderFactory(validationMode, namespaceAware);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;&lt;span&gt;);
        }
        DocumentBuilder builder &lt;/span&gt;=&lt;span&gt; createDocumentBuilder(factory, entityResolver, errorHandler);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.parse(inputSource);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;p&gt;从源码可以看出这里先创建DocumentBuilderFactory，再用它创建DocumentBuilder，进而解析inputSource来返回Document对象。得到Document对象后就可以准备注册我们的Bean信息了。&lt;/p&gt;

&lt;p&gt;在上面的doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法中拿到Document对象后下面就是执行registerBeanDefinitions(doc, resource)方法了，看源码：&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; registerBeanDefinitions(Document doc, Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
    BeanDefinitionDocumentReader documentReader &lt;/span&gt;=&lt;span&gt; createBeanDefinitionDocumentReader();
    documentReader.setEnvironment(getEnvironment());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还没注册bean前的BeanDefinition加载个数&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; countBefore =&lt;span&gt; getRegistry().getBeanDefinitionCount();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载注册bean&lt;/span&gt;
&lt;span&gt;    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本次加载注册的BeanDefinition个数&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; getRegistry().getBeanDefinitionCount() -&lt;span&gt; countBefore;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;p&gt;这里的doc就是上面的loadDocument方法加载转换来的，从上面可以看出主要工作是交给BeanDefinitionDocumentReader的registerBeanDefinitions()方法实现的，这里BeanDefinitionDocumentReader是个接口，注册bean功能在默认实现类DefaultBeanDefinitionDocumentReader的该方法实现，跟进它的源码：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.readerContext =&lt;span&gt; readerContext;
    logger.debug(&lt;/span&gt;&quot;Loading bean definitions&quot;&lt;span&gt;);
    Element root &lt;/span&gt;=&lt;span&gt; doc.getDocumentElement();
    doRegisterBeanDefinitions(root);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;p&gt;到这里通过doc.getDocumentElement()获得Element对象后，交给doRegisterBeanDefinitions()方法后就是真正执行XML文档的解析了，跟进doRegisterBeanDefinitions()方法源码：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doRegisterBeanDefinitions(Element root) {
    BeanDefinitionParserDelegate parent &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.delegate =&lt;span&gt; createDelegate(getReaderContext(), root, parent);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate.isDefaultNamespace(root)) {
        String profileSpec &lt;/span&gt;=&lt;span&gt; root.getAttribute(PROFILE_ATTRIBUTE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles &lt;/span&gt;=&lt;span&gt; StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    preProcessXml(root);
    parseBeanDefinitions(root, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate);
    postProcessXml(root);

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.delegate =&lt;span&gt; parent;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;p&gt;到这里处理流程就很清晰了，先是对profile进行处理，之后就通过parseBeanDefinitions()方法进行文档的解析操作，跟进parseBeanDefinitions()方法源码：&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(root)) {
        NodeList nl &lt;/span&gt;=&lt;span&gt; root.getChildNodes();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
            Node node &lt;/span&gt;=&lt;span&gt; nl.item(i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
                Element ele &lt;/span&gt;=&lt;span&gt; (Element) node;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面对bean进行处理&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        delegate.parseCustomElement(root);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;上面if-else语句块中的parseDefaultElement(ele, delegate)和delegate.parseCustomElement(ele)就是对Spring配置文件中的默认命名空间和自定义命名空间进行解析用的。在Spring的XML配置中，默认Bean声明就如前面定义的：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;testBean&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;bean.TestBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;自定义的Bean声明如：&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:annotation-driven &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;XmlBeanFactory加载bean的整个过程基本就讲解到这里了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;7.8153846153846&quot;&gt;&lt;strong&gt;作者注：原文发表在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4ODEyMTgwMA==&amp;amp;mid=2650163485&amp;amp;idx=1&amp;amp;sn=844d687297731ab2c679b3c37789f23a&amp;amp;chksm=f3c1dfbac4b656ac7776a808b179b7d69cc0267c8de4686aed1e604faaca4cabed4c188d0fa1&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0909VDclNnzDZ03doydbUEls&amp;amp;pass_ticket=1fSFD5nC9Rbw7NC4YMwFPr0tmWOBaLQEFOy%2FA5EkBVD1gtAkGj7ovtwgv%2Byg9Xc5#rd&quot; target=&quot;_blank&quot;&gt;公号&lt;/a&gt;（点击查看），定期分享IT互联网、金融等工作经验心得、人生感悟，欢迎订阅交流&lt;/strong&gt;，目前就职阿里-移动事业部，需要大厂内推的也可到公号砸简历。（公众号ID：weknow619）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1044046/201809/1044046-20180909100941765-920955426.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 09 Sep 2018 05:45:00 +0000</pubDate>
<dc:creator>weknow619</dc:creator>
<og:description>本文是Spring源码分析中的一篇，来讲讲Spring框架中BeanFactory解析bean的过程，先来看一个在Spring中一个基本的bean定义与使用。（也可以来公号查看） package be</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weknow619/p/9612710.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——45. 明智审慎地使用Stream - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/9613473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/9613473.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Java 8中添加了Stream API，以简化顺序或并行执行批量操作的任务。 该API提供了两个关键的抽象：流(Stream)，表示有限或无限的数据元素序列，以及流管道(stream pipeline)，表示对这些元素的多级计算。 Stream中的元素可以来自任何地方。 常见的源包括集合，数组，文件，正则表达式模式匹配器，伪随机数生成器和其他流。 流中的数据元素可以是对象引用或基本类型。 支持三种基本类型：int，long和double。&lt;/p&gt;
&lt;p&gt;流管道由源流（source stream）的零或多个中间操作和一个终结操作组成。每个中间操作都以某种方式转换流，例如将每个元素映射到该元素的函数或过滤掉所有不满足某些条件的元素。中间操作都将一个流转换为另一个流，其元素类型可能与输入流相同或不同。终结操作对流执行最后一次中间操作产生的最终计算，例如将其元素存储到集合中、返回某个元素或打印其所有元素。&lt;/p&gt;
&lt;p&gt;管道延迟（lazily）计算求值：计算直到终结操作被调用后才开始，而为了完成终结操作而不需要的数据元素永远不会被计算出来。 这种延迟计算求值的方式使得可以使用无限流。 请注意，没有终结操作的流管道是静默无操作的，所以不要忘记包含一个。&lt;/p&gt;
&lt;p&gt;Stream API流式的（fluent）：:它设计允许所有组成管道的调用被链接到一个表达式中。事实上，多个管道可以链接在一起形成一个表达式。&lt;/p&gt;
&lt;p&gt;默认情况下，流管道按顺序(sequentially)运行。 使管道并行执行就像在管道中的任何流上调用并行方法一样简单，但很少这样做（第48个条目）。&lt;/p&gt;
&lt;p&gt;Stream API具有足够的通用性，实际上任何计算都可以使用Stream执行，但仅仅因为可以，并不意味着应该这样做。如果使用得当，流可以使程序更短更清晰；如果使用不当，它们会使程序难以阅读和维护。对于何时使用流没有硬性的规则，但是有一些启发。&lt;/p&gt;
&lt;p&gt;考虑以下程序，该程序从字典文件中读取单词并打印其大小符合用户指定的最小值的所有变位词（anagram）组。如果两个单词由长度相通，不同顺序的相同字母组成，则它们是变位词。程序从用户指定的字典文件中读取每个单词并将单词放入map对象中。map对象的键是按照字母排序的单词，因此『staple』的键是『aelpst』，『petals』的键也是『aelpst』：这两个单词就是同位词，所有的同位词共享相同的依字母顺序排列的形式（或称之为alphagram）。map对象的值是包含共享字母顺序形式的所有单词的列表。 处理完字典文件后，每个列表都是一个完整的同位词组。然后程序遍历map对象的&lt;code&gt;values()&lt;/code&gt;的视图并打印每个大小符合阈值的列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Prints all large anagram groups in a dictionary iteratively

public class Anagrams {

    public static void main(String[] args) throws IOException {

        File dictionary = new File(args[0]);

        int minGroupSize = Integer.parseInt(args[1]);

        Map&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; groups = new HashMap&amp;lt;&amp;gt;();

        try (Scanner s = new Scanner(dictionary)) {

            while (s.hasNext()) {

                String word = s.next();

                [groups.computeIfAbsent(alphabetize(word](http://groups.computeIfAbsent(alphabetize(word)),

                    (unused) -&amp;gt; new TreeSet&amp;lt;&amp;gt;()).add(word);

            }

        }

        for (Set&amp;lt;String&amp;gt; group : groups.values())

            if (group.size() &amp;gt;= minGroupSize)

                System.out.println(group.size() + &quot;: &quot; + group);

    }

    private static String alphabetize(String s) {

        char[] a = s.toCharArray();

        Arrays.sort(a);

        return new String(a);

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序中的一个步骤值得注意。将每个单词插入到map中(以粗体显示)中使用了&lt;code&gt;computeIfAbsent&lt;/code&gt;方法，该方法是在Java 8中添加的。这个方法在map中查找一个键：如果键存在，该方法只返回与其关联的值。如果没有，该方法通过将给定的函数对象应用于键来计算值，将该值与键关联，并返回计算值。&lt;code&gt;computeIfAbsent&lt;/code&gt;方法简化了将多个值与每个键关联的map的实现。&lt;/p&gt;
&lt;p&gt;现在考虑以下程序，它解决了同样的问题，但大量过度使用了流。 请注意，整个程序（打开字典文件的代码除外）包含在单个表达式中。 在单独的表达式中打开字典文件的唯一原因是允许使用try-with-resources语句，该语句确保关闭字典文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Overuse of streams - don't do this!

public class Anagrams {

  public static void main(String[] args) throws IOException {

    Path dictionary = Paths.get(args[0]);

    int minGroupSize = Integer.parseInt(args[1]);

      try (Stream&amp;lt;String&amp;gt; words = Files.lines(dictionary)) {

        words.collect(

          groupingBy(word -&amp;gt; word.chars().sorted()

                      .collect(StringBuilder::new,

                        (sb, c) -&amp;gt; sb.append((char) c),

                        StringBuilder::append).toString()))

          .values().stream()

            .filter(group -&amp;gt; group.size() &amp;gt;= minGroupSize)

            .map(group -&amp;gt; group.size() + &quot;: &quot; + group)

            .forEach(System.out::println);

        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你发现这段代码难以阅读，不要担心；你不是一个人。它更短，但是可读性也更差，尤其是对于那些不擅长使用流的程序员来说。&lt;strong&gt;过度使用流使程序难于阅读和维护&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;幸运的是，有一个折中的办法。下面的程序解决了同样的问题，使用流而不过度使用它们。其结果是一个比原来更短更清晰的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Tasteful use of streams enhances clarity and conciseness

public class Anagrams {

   public static void main(String[] args) throws IOException {

      Path dictionary = Paths.get(args[0]);

      int minGroupSize = Integer.parseInt(args[1]);

      try (Stream&amp;lt;String&amp;gt; words = Files.lines(dictionary)) {

         words.collect(groupingBy(word -&amp;gt; alphabetize(word)))

           .values().stream()

           .filter(group -&amp;gt; group.size() &amp;gt;= minGroupSize)

           .forEach(g -&amp;gt; System.out.println(g.size() + &quot;: &quot; + g));

      }

   }

   // alphabetize method is the same as in original version

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使以前很少接触流，这个程序也不难理解。它在一个try-with-resources块中打开字典文件，获得一个由文件中的所有行组成的流。流变量命名为&lt;code&gt;words&lt;/code&gt;，表示流中的每个元素都是一个单词。此流上的管道没有中间操作；它的终结操作将所有单词收集到个map对象中，按照字母排列的形式对单词进行分组(第46项)。这与之前两个版本的程序构造的map完全相同。然后在map的values()视图上打开一个新的流&lt;code&gt;&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt;。当然，这个流中的元素是同位词组。对流进行过滤，以便忽略大小小于&lt;code&gt;minGroupSize&lt;/code&gt;的所有组，最后由终结操作forEach打印剩下的同位词组。&lt;/p&gt;
&lt;p&gt;请注意，仔细选择lambda参数名称。 上面程序中参数&lt;code&gt;g&lt;/code&gt;应该真正命名为&lt;code&gt;group&lt;/code&gt;，但是生成的代码行对于本书来说太宽了。 &lt;strong&gt;在没有显式类型的情况下，仔细命名lambda参数对于流管道的可读性至关重要&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另请注意，单词字母化是在单独的&lt;code&gt;alphabetize&lt;/code&gt;方法中完成的。 这通过提供操作名称并将实现细节保留在主程序之外来增强可读性。 &lt;strong&gt;使用辅助方法对于流管道中的可读性比在迭代代码中更为重要&lt;/strong&gt;，因为管道缺少显式类型信息和命名临时变量。&lt;/p&gt;
&lt;p&gt;字母顺序方法可以使用流重新实现，但基于流的字母顺序方法本来不太清楚，更难以正确编写，并且可能更慢。 这些缺陷是由于Java缺乏对原始字符流的支持（这并不意味着Java应该支持char流；这样做是不可行的）。 要演示使用流处理char值的危害，请考虑以下代码：&lt;/p&gt;
&lt;p&gt;&quot;Hello world!&quot;.chars().forEach(System.out::print);&lt;/p&gt;
&lt;p&gt;你可能希望它打印&lt;code&gt;Hello world!&lt;/code&gt;，但如果运行它，发现它打印&lt;code&gt;721011081081113211911111410810033&lt;/code&gt;。这是因为&lt;code&gt;“Hello world!”.chars()&lt;/code&gt;返回的流的元素不是char值，而是int值，因此调用了&lt;code&gt;print&lt;/code&gt;的int重载。无可否认，一个名为chars的方法返回一个int值流是令人困惑的。可以通过强制调用正确的重载来修复该程序:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Hello world!&quot;.chars().forEach(x -&amp;gt; System.out.print((char) x));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但理想情况下，&lt;strong&gt;应该避免使用流来处理char值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当开始使用流时，你可能会感到想要将所有循环语句转换为流方式的冲动，但请抵制这种冲动。尽管这是可能的，但可能会损害代码库的可读性和可维护性。 通常，使用流和迭代的某种组合可以最好地完成中等复杂的任务，如上面的&lt;code&gt;Anagrams&lt;/code&gt;程序所示。 因此，&lt;strong&gt;重构现有代码以使用流，并仅在有意义的情况下在新代码中使用它们&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如本项目中的程序所示，流管道使用函数对象(通常为lambdas或方法引用)表示重复计算，而迭代代码使用代码块表示重复计算。从代码块中可以做一些从函数对象中不能做的事情:&lt;/p&gt;
&lt;p&gt;•从代码块中，可以读取或修改范围内的任何局部变量; 从lambda中，只能读取最终或有效的最终变量[JLS 4.12.4]，并且无法修改任何局部变量。&lt;br/&gt;•从代码块中，可以从封闭方法返回，中断或继续封闭循环，或抛出声明此方法的任何已检查异常; 从一个lambda你不能做这些事情。&lt;/p&gt;
&lt;p&gt;如果使用这些技术最好地表达计算，那么它可能不是流的良好匹配。 相反，流可以很容易地做一些事情：&lt;br/&gt;•统一转换元素序列&lt;br/&gt;•过滤元素序列&lt;br/&gt;•使用单个操作组合元素序列(例如添加、连接或计算最小值)&lt;br/&gt;•将元素序列累积到一个集合中，可能通过一些公共属性将它们分组&lt;br/&gt;•在元素序列中搜索满足某些条件的元素&lt;/p&gt;
&lt;p&gt;如果使用这些技术最好地表达计算，那么使用流是这些场景很好的候选者。&lt;/p&gt;
&lt;p&gt;对于流来说，很难做到的一件事是同时访问管道的多个阶段中的相应元素:一旦将值映射到其他值，原始值就会丢失。一种解决方案是将每个值映射到一个包含原始值和新值的pair对象，但这不是一个令人满意的解决方案，尤其是在管道的多个阶段需要一对对象时更是如此。生成的代码既混乱又冗长，破坏了流的主要用途。当它适用时，一个更好的解决方案是在需要访问早期阶段值时转换映射。&lt;/p&gt;
&lt;p&gt;例如，让我们编写一个程序来打印前20个梅森素数(Mersenne primes)。 梅森素数是一个2&lt;sup&gt;p&lt;/sup&gt; − 1形式的数字。如果p是素数，相应的梅森数可能是素数; 如果是这样的话，那就是梅森素数。 作为我们管道中的初始流，我们需要所有素数。 这里有一个返回该（无限）流的方法。 我们假设使用静态导入来轻松访问BigInteger的静态成员：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static Stream&amp;lt;BigInteger&amp;gt; primes() {

    return Stream.iterate(TWO, BigInteger::nextProbablePrime);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法的名称（primes）是一个复数名词，描述了流的元素。 强烈建议所有返回流的方法使用此命名约定，因为它增强了流管道的可读性。 该方法使用静态工厂&lt;code&gt;Stream.iterate&lt;/code&gt;，它接受两个参数：流中的第一个元素，以及从前一个元素生成流中的下一个元素的函数。 这是打印前20个梅森素数的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {

    primes().map(p -&amp;gt; TWO.pow(p.intValueExact()).subtract(ONE))

        .filter(mersenne -&amp;gt; mersenne.isProbablePrime(50))

        .limit(20)

        .forEach(System.out::println);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序是上面的梅森描述的直接编码：它从素数开始，计算相应的梅森数，过滤掉除素数之外的所有数字（幻数50控制概率素性测试the magic number 50 controls the probabilistic primality test），将得到的流限制为20个元素， 并打印出来。&lt;/p&gt;
&lt;p&gt;现在假设我们想在每个梅森素数前面加上它的指数(p)，这个值只出现在初始流中，因此在终结操作中不可访问，而终结操作将输出结果。幸运的是通过反转第一个中间操作中发生的映射，可以很容易地计算出Mersenne数的指数。 指数是二进制表示中的位数，因此该终结操作会生成所需的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.forEach(mp -&amp;gt; System.out.println(mp.bitLength() + &quot;: &quot; + mp));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有很多任务不清楚是使用流还是迭代。例如，考虑初始化一副新牌的任务。假设&lt;code&gt;Card&lt;/code&gt;是一个不可变的值类，它封装了&lt;code&gt;Rank&lt;/code&gt;和&lt;code&gt;Suit&lt;/code&gt;，它们都是枚举类型。这个任务代表任何需要计算可以从两个集合中选择的所有元素对。数学家们称它为两个集合的笛卡尔积。下面是一个迭代实现，它有一个嵌套的for-each循环，你应该非常熟悉:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Iterative Cartesian product computation

private static List&amp;lt;Card&amp;gt; newDeck() {

    List&amp;lt;Card&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();

    for (Suit suit : Suit.values())

        for (Rank rank : Rank.values())

            result.add(new Card(suit, rank));

    return result;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个基于流的实现，它使用了中间操作&lt;code&gt;flatMap&lt;/code&gt;方法。这个操作将一个流中的每个元素映射到一个流，然后将所有这些新流连接到一个流(或展平它们)。注意，这个实现包含一个嵌套的lambda表达式（&lt;code&gt;rank -&amp;gt; new Card(suit, rank))&lt;/code&gt;）:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Stream-based Cartesian product computation

private static List&amp;lt;Card&amp;gt; newDeck() {

    return Stream.of(Suit.values())

        .flatMap(suit -&amp;gt;

            Stream.of(Rank.values())

                .map(rank -&amp;gt; new Card(suit, rank)))

        .collect(toList());

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;newDeck&lt;/code&gt;的两个版本中哪一个更好？ 它归结为个人偏好和你的编程的环境。 第一个版本更简单，也许感觉更自然。 大部分Java程序员将能够理解和维护它，但是一些程序员会对第二个（基于流的）版本感觉更舒服。 如果对流和函数式编程有相当的精通，那么它会更简洁，也不会太难理解。 如果不确定自己喜欢哪个版本，则迭代版本可能是更安全的选择。 如果你更喜欢流的版本，并且相信其他使用该代码的程序员会与你共享你的偏好，那么应该使用它。&lt;/p&gt;
&lt;p&gt;总之，有些任务最好使用流来完成，有些任务最好使用迭代来完成。将这两种方法结合起来，可以最好地完成许多任务。对于选择使用哪种方法进行任务，没有硬性规定，但是有一些有用的启发式方法。在许多情况下，使用哪种方法将是清楚的；在某些情况下，则不会很清楚。&lt;strong&gt;如果不确定一个任务是通过流还是迭代更好地完成，那么尝试这两种方法，看看哪一种效果更好。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 05:42:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/9613473.html</dc:identifier>
</item>
<item>
<title>堆排序 - VisualGMQ</title>
<link>http://www.cnblogs.com/learn-program/p/9613042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learn-program/p/9613042.html</guid>
<description>&lt;p&gt;堆排序是非常快的一种排序方法。其时间复杂度为O(nlogn)，和快速排序不相上下。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;什么是堆&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们在介绍堆排序之前，当然需要知道什么是堆。堆是一种数据结构，相当于二叉树一样。但是它是使用数组存放的。存放的方法是：从左到右，从上到下地将节点依此放入数组中：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909120324984-1159543918.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 像图中的二叉树，首先从顶端开始将34放入数组中。然后来到第二层，将28，16放入数组中。然后来到第三层，将15，14，9，1放入数组中...以此类推。如果你是将数组变为二叉树的话就是一个相反的过程：先将34置为树根，然后从左到右，从上到下的依次添加节点。注意这里我说的是变成二叉树而不是变成堆，因为很有可能这个数组对应的二叉树不满足堆的性质。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;堆的性质：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;堆不仅仅是二叉树，它还有自己的性质：&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;ul&gt;&lt;li&gt;任何一个节点的数值一定比两个子节点都大&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有这个性质的堆称为最大堆，如果反过来：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任何一个节点的数值一定比其子节点都小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么就是最小堆。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最大堆最后排序出来的元素是升序的。最小堆对应降序排列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;堆还有一个隐含的性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个堆都是完全二叉树&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个性质很容易被发现：由于我们从数组生成二叉树时总是自左向右，自上而下的，所以最后的结果一定是最下层的最右边空缺，所以一定会生成完全二叉树。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 堆的拓展性质：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来通过性质我们还可以推导出一些十分有用的拓展性质，我们需要使用这些性质来进行堆排序：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;对于有n个元素的堆来说，其二叉树高度为floor(logn)。（其中floor为向下取整）
&lt;p&gt;这个性质的证明还是比较简单的。可以看出层数h和当前层的节点数n的关系是n=2^(h-1)。这样使用求和公式，最后考虑最下一层不全部排满的情况就可以推导出这个公式了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;对于一个有n个元素的堆来说，第floor(n/2)+1个元素为第一个叶子节点，floor(n/2)+2为第二个叶子结点...依此类推。&lt;/li&gt;
&lt;li&gt;对于第n个父节点来说，其左节点是第2*n个节点，右节点是第2*n+1个节点&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;维护堆的性质&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个数据结构，我们需要做到在插入，删除元素的时候不改变数据结构的性质。这里我们以最大堆为例来说明如何维护堆的性质：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最大堆的性质是：&lt;/p&gt;
&lt;p&gt;　　任何一个父节点都比两个子节点的数值要大。&lt;/p&gt;
&lt;p&gt;我们需要在更改堆的时候让堆不违反这个性质。我们这里使用一个函数来维护堆的性质。这个函数将在每次打乱堆的时候使堆自动变成符合性质的结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;LEFT(n)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     return n*&lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;RIGHT(n)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     return n*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; MAX_HEAP(heap,&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     left=&lt;span&gt;LEFT(i)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     right=&lt;span&gt;RIGHT(i)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(left&amp;lt;=length &amp;amp;&amp;amp; heap[left]&amp;gt;&lt;span&gt;heap[I])
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         max=&lt;span&gt;left
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    Else 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         max=&lt;span&gt;I
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     If(right&amp;lt;=length &amp;amp;&amp;amp; heap[right]&amp;gt;&lt;span&gt;heap[max])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         max =&lt;span&gt;right
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(max!=&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        Exchange heap[I] and heap[max]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         MAX_HEAP(heap,max)   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先根据拓展性质3，LEFT()和RIGHT()函数用于获得节点n的左右节点的下标。&lt;/p&gt;
&lt;p&gt;接下来MAX_HEAP用于维护堆的性质： &lt;/p&gt;
&lt;p&gt;　　第8，9行获得节点i的左右子节点。&lt;/p&gt;
&lt;p&gt;　　第10，14行比较这个节点和其子节点的大小，并且将三者中最大的节点下标记录在max中。&lt;/p&gt;
&lt;p&gt;　　第16行判断最大的节点是不是原本的父节点i。如果是的话就停止维护堆的性质。否则再次递归调用MAX_HEAP()函数向下维护堆的性质。&lt;/p&gt;
&lt;p&gt;对于递归，我们知道总是有一个基础步骤和一个递归步骤：&lt;/p&gt;
&lt;p&gt;基础步骤：对于节点i，找出i，i的子节点中最大的节点下标，放入max中。&lt;/p&gt;
&lt;p&gt;递归步骤：如果max!=i，则交换heap[max]和heap[i]的值，并且调用MAX_HEAP(heap,max)&lt;/p&gt;
&lt;p&gt;这就是MAX_HEAP函数的递归描述。&lt;/p&gt;

&lt;p&gt;具体的C++代码如下：&lt;/p&gt;
&lt;p&gt;堆的类结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_71af35c7-7031-4a79-b200-7a8b5cebc499&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_71af35c7-7031-4a79-b200-7a8b5cebc499&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_71af35c7-7031-4a79-b200-7a8b5cebc499&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
template &amp;lt;typename T&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Heap{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Heap():heap(nullptr),len(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){}
    Heap(T&lt;/span&gt;* arr,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; l);
    vector&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; GetSortedVector();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OutPut();
    &lt;/span&gt;~&lt;span&gt;Heap();
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    T GetLeft(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
    T GetRight(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Max_Heap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Max_Heap_for_Sort(T* arr,&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateHeap();
    T&lt;/span&gt;*&lt;span&gt; heap;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; len;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;类结构&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;维护堆性质的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6c3a574e-4ece-45d8-adde-638f7797f757&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c3a574e-4ece-45d8-adde-638f7797f757&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c3a574e-4ece-45d8-adde-638f7797f757&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
template &amp;lt;typename T&amp;gt;&lt;span&gt;
T Heap&lt;/span&gt;&amp;lt;T&amp;gt;::GetLeft(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; heap[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
T Heap&lt;/span&gt;&amp;lt;T&amp;gt;::GetRight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt; &amp;gt;&lt;span&gt; len)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INT_MIN;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; heap[(i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; Heap&amp;lt;T&amp;gt;::Max_Heap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; max;
    T l&lt;/span&gt;=GetLeft(i),r=&lt;span&gt;GetRight(i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)&amp;lt;=len &amp;amp;&amp;amp; l&amp;gt;&lt;span&gt;heap[i])
        max&lt;/span&gt;=i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        max&lt;/span&gt;=&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&amp;lt;=len &amp;amp;&amp;amp; r&amp;gt;&lt;span&gt;heap[max])
        max&lt;/span&gt;=(i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(max!=&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;heap[max];
        heap[max]&lt;/span&gt;=&lt;span&gt;heap[i];
        heap[i]&lt;/span&gt;=&lt;span&gt;temp;
        Max_Heap(max);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;维护性质 &lt;/span&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;构建堆&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;由于是排序算法，所以首先一定会给出一些数，这些数常常放在数组中，像是这样： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909123521468-642176255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们就将这个数组当作一个二叉树，那么根据上面说的规则，采用自左向右，自上而下的方式构建二叉树： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909123851331-1595684903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在这个还只是二叉树。要将这棵树变成堆，需要满足堆的性质。这样的话维护堆性质的函数就派上用场了。我们自底向上的对，每个父节点使用MAX_HEAP函数来将二叉树变成堆（也就是说最下一层不使用）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CEATE_HEAP(heap)
    For i&lt;/span&gt;=floor(length/&lt;span&gt;2&lt;/span&gt;) downto &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        MAX_HEAP(heap,i)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中第二行的for循环用于从下到上的使用MAX_HEAP函数。这里floor(lengtth/2)的条件是根据拓展性质3得出的。&lt;/p&gt;

&lt;p&gt;对应的C++代码如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_abeb3280-8bbd-4308-8057-bd2e694e669f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_abeb3280-8bbd-4308-8057-bd2e694e669f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_abeb3280-8bbd-4308-8057-bd2e694e669f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
template &amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; Heap&amp;lt;T&amp;gt;&lt;span&gt;::CreateHeap(){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=floor(len/&lt;span&gt;2&lt;/span&gt;);i&amp;gt;=&lt;span&gt;1&lt;/span&gt;;i--&lt;span&gt;)
        Max_Heap(i);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;构建堆&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 对于上面的树，变成堆堆过程如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909125612760-193696217.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;674&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中蓝色是for循环里MAX_HEAP()执行到的节点。橙色的是MAX_HEAP()递归递归到的节点。&lt;/p&gt;
&lt;p&gt;可能会有些人说，为什么要自底向上创建，我自顶向下创建不行吗？下面我们来看看自顶向下的创建过程（只需要将for循环里改成i=1 to floor(length/2)即可）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909130516252-1123692813.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;479&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出最后的结果并不正确。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;堆排序&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;终于到了我们最后这一章的核心，堆排序了。其实前面说的都是如何创建堆这个数据结构。接下来通过这个数据结构来进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;堆排序的思想如下：&lt;/p&gt;
&lt;p&gt;根据最大堆的性质（你要是使用的最小堆就看最小堆的性质），父节点总是比子节点大。这样的话堆的根节点一定是整个堆里面最大的节点。我们可以把这个节点和最右下角的节点互换：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909132625051-316518341.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;305&quot;/&gt; &lt;/p&gt;
&lt;p&gt;为什么要和最右下角的节点互换呢？不要忘记这颗树是通过数组存储的哦。我们把最大元素和最右下角的元素互换，其实就是将最大元素和数组最后一个元素互换哦： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909132121618-1008501050.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;136&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候右下角的节点就已经不属于堆了。&lt;/p&gt;
&lt;p&gt;但是这样做的话又破坏了堆的性质（这里7小于8了），所以我们需要再次维护堆的性质，对根节点调用MAX_HEAP即可：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180909132829148-1249534640.png&quot; alt=&quot;&quot; width=&quot;330&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于原本最大的节点已经放到数组的最后一位了，现在堆里面的节点全部都小于数组最右边的节点。通过维护堆的性质再将堆中最大节点放到根节点处。这个时候根节点是整个排序数组中第二大节点。然后将根节点放到倒数第二个节点处就完成了一次排序。&lt;/p&gt;
&lt;p&gt;然后重复地将根节点和右下方的节点互换，再对根节点使用MAX_HEAP。直到堆里面没有节点了，排序就完成了。&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HEAPSORT(heap)
    For i&lt;/span&gt;=length downto &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        Exchange heap[i] and heap[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
        Length&lt;/span&gt;--&lt;span&gt;
        MAX_HEAP(heap,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C++代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_15c8c37a-87ef-4016-831d-1fef663916b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_15c8c37a-87ef-4016-831d-1fef663916b2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_15c8c37a-87ef-4016-831d-1fef663916b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
template &amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; Heap&amp;lt;T&amp;gt;::Max_Heap_for_Sort(T* arr,&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; max,r,l;
    l&lt;/span&gt;=i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    r&lt;/span&gt;=(i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l&amp;lt;=length &amp;amp;&amp;amp; arr[l]&amp;gt;&lt;span&gt;arr[i])
        max&lt;/span&gt;=&lt;span&gt;l;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        max&lt;/span&gt;=&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(r&amp;lt;=length &amp;amp;&amp;amp; arr[r]&amp;gt;&lt;span&gt;arr[max])
        max&lt;/span&gt;=&lt;span&gt;r;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(max!=&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;arr[i];
        arr[i]&lt;/span&gt;=&lt;span&gt;arr[max];
        arr[max]&lt;/span&gt;=&lt;span&gt;temp;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;length--;&lt;/span&gt;
&lt;span&gt;        Max_Heap_for_Sort(arr, max, length);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=len;i++&lt;span&gt;)
        cout&lt;/span&gt;&amp;lt;&amp;lt;arr[i]&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;堆排序&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;最后数组就被排序成功了。&lt;/p&gt;

&lt;p&gt;下面是C++的全部实现代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_eba1136c-9f3d-430b-8e1a-f94ff2ddac27&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eba1136c-9f3d-430b-8e1a-f94ff2ddac27&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eba1136c-9f3d-430b-8e1a-f94ff2ddac27&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef Heap_hpp
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; Heap_hpp&lt;span&gt;

#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cmath&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;vector&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

template &lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Heap{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Heap():heap(nullptr),len(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){}
    Heap(T&lt;/span&gt;* arr,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; l);
    vector&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; GetSortedVector();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OutPut();
    &lt;/span&gt;~&lt;span&gt;Heap();
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    T GetLeft(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
    T GetRight(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
    T GetParent(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Max_Heap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Max_Heap_for_Sort(T* arr,&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateHeap();
    T&lt;/span&gt;*&lt;span&gt; heap;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; len;
};

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
Heap&lt;/span&gt;&amp;lt;T&amp;gt;::Heap(T* arr,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; l):len(l){
    heap&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; T[l+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;l;i++&lt;span&gt;)
        heap[i&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;arr[i];
    CreateHeap();
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
T Heap&lt;/span&gt;&amp;lt;T&amp;gt;::GetLeft(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; heap[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
T Heap&lt;/span&gt;&amp;lt;T&amp;gt;::GetRight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt; &amp;gt;&lt;span&gt; len)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INT_MIN;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; heap[(i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
T Heap&lt;/span&gt;&amp;lt;T&amp;gt;::GetParent(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; heap[i&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; Heap&amp;lt;T&amp;gt;::Max_Heap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; max;
    T l&lt;/span&gt;=GetLeft(i),r=&lt;span&gt;GetRight(i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)&amp;lt;=len &amp;amp;&amp;amp; l&amp;gt;&lt;span&gt;heap[i])
        max&lt;/span&gt;=i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        max&lt;/span&gt;=&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&amp;lt;=len &amp;amp;&amp;amp; r&amp;gt;&lt;span&gt;heap[max])
        max&lt;/span&gt;=(i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(max!=&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;heap[max];
        heap[max]&lt;/span&gt;=&lt;span&gt;heap[i];
        heap[i]&lt;/span&gt;=&lt;span&gt;temp;
        Max_Heap(max);
    }
}


template &lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; Heap&amp;lt;T&amp;gt;::Max_Heap_for_Sort(T* arr,&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; max,r,l;
    l&lt;/span&gt;=i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    r&lt;/span&gt;=(i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l&amp;lt;=length &amp;amp;&amp;amp; arr[l]&amp;gt;&lt;span&gt;arr[i])
        max&lt;/span&gt;=&lt;span&gt;l;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        max&lt;/span&gt;=&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(r&amp;lt;=length &amp;amp;&amp;amp; arr[r]&amp;gt;&lt;span&gt;arr[max])
        max&lt;/span&gt;=&lt;span&gt;r;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(max!=&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;arr[i];
        arr[i]&lt;/span&gt;=&lt;span&gt;arr[max];
        arr[max]&lt;/span&gt;=&lt;span&gt;temp;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;length--;&lt;/span&gt;
&lt;span&gt;        Max_Heap_for_Sort(arr, max, length);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=len;i++&lt;span&gt;)
        cout&lt;/span&gt;&amp;lt;&amp;lt;arr[i]&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
vector&lt;/span&gt;&amp;lt;T&amp;gt; Heap&amp;lt;T&amp;gt;&lt;span&gt;::GetSortedVector(){
    vector&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; v;
    T temp[len&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length=&lt;span&gt;len;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=len;i++&lt;span&gt;)
        temp[i]&lt;/span&gt;=&lt;span&gt;heap[i];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=len;i&amp;gt;=&lt;span&gt;2&lt;/span&gt;;i--&lt;span&gt;){
        v.push_back(temp[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        temp[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;temp[i];
        Max_Heap_for_Sort(temp, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, --&lt;span&gt;length);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; Heap&amp;lt;T&amp;gt;&lt;span&gt;::OutPut(){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=len;i++&lt;span&gt;)
        cout&lt;/span&gt;&amp;lt;&amp;lt;heap[i]&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
Heap&lt;/span&gt;&amp;lt;T&amp;gt;::~&lt;span&gt;Heap(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(heap!=&lt;span&gt;nullptr)
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] heap;
}
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;全代码&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 09 Sep 2018 05:39:00 +0000</pubDate>
<dc:creator>VisualGMQ</dc:creator>
<og:description>堆排序详解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learn-program/p/9613042.html</dc:identifier>
</item>
<item>
<title>SpringCloud Feign的分析 - XuMinzhe</title>
<link>http://www.cnblogs.com/xmzJava/p/9612988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmzJava/p/9612988.html</guid>
<description>&lt;p&gt;Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它既可完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@FeignClient(value = &quot;qrcodepay-dike-service&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestRoute {
    @RequestMapping(value &lt;/span&gt;= &quot;/dike/get&quot;, method =&lt;span&gt; RequestMethod.GET)
    HdResult get();
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们只需要在相应的接口上添加@FeignClient注解即可将他声明为一个web客户端。这其中的原理我们后续分析。我们首先先关注下feign暴露的几个配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value: 目标服务名，一般都是 application.name&lt;/li&gt;
&lt;li&gt;fallback : 服务降级策略&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@FeignClient(value = &quot;qrcodepay-dike-service&quot;,fallback = TestRoute.TestRouteFaback.class)&lt;br/&gt;public interface TestRoute {&lt;br/&gt;@RequestMapping(value = &quot;/dike/get&quot;, method = RequestMethod.GET)&lt;br/&gt;HdResult get();&lt;br/&gt;}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;@Component
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; TestRouteFaback &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestRoute{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HdResult get() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HdResult.makeFail(&quot;服务降级&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt; fallbackFactory ：fallback的升级版，可以获取更加详细的异常信息&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@FeignClient(value = &quot;qrcodepay-dike-service&quot;,fallbackFactory = TestRoute.TestRouteFallbackFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestRoute {
    @RequestMapping(value &lt;/span&gt;= &quot;/dike/get&quot;, method =&lt;span&gt; RequestMethod.GET)
    HdResult get();

    @Component
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; TestRouteFallbackFactory &lt;span&gt;implements&lt;/span&gt; FallbackFactory&amp;lt;TestRoute&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(TestRouteFallbackFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestRoute create(Throwable throwable) {
            String msg &lt;/span&gt;= throwable == &lt;span&gt;null&lt;/span&gt; ? &quot;&quot;&lt;span&gt; : throwable.getMessage();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.isEmpty(msg)) {
                logger.error(&lt;/span&gt;&quot;异常信息打印:{}&quot;&lt;span&gt;,msg);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestRoute() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HdResult get() {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; HdResult.makeFail(msg);
                }
            };
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;configuration:重写feign的配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 具体哪些内容可以配置我们可以看  &lt;code&gt;FeignClientsConfiguration和feign.Feign.Builder。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面用两种方式重写feign的配置&lt;/p&gt;
&lt;p&gt;覆盖原有的配置bean达到重写目的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignBreakerConfiguration {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ErrorDecoder errorDecoder() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserErrorDecoder();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 自定义错误解码器 只有返回http status 非200才会进入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserErrorDecoder &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ErrorDecoder {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception decode(String methodKey, Response response) {
            Exception exception &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                String json &lt;/span&gt;=&lt;span&gt; Util.toString(response.body().asReader());
                System.out.println(&lt;/span&gt;&quot;自定义解码:&quot;+&lt;span&gt;json);
                exception &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(json);
                HdResult result&lt;/span&gt;=&lt;span&gt;HdResult.makeFail(json);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 业务异常包装成 HystrixBadRequestException，不进入熔断逻辑
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                if (!result.isSuccess()) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    exception = new HystrixBadRequestException(result.getMessage());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                }&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
                logger.error(ex.getMessage(), ex);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; exception;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义客户端达到重写的目的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@Import(FeignClientsConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultController {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; FeignClientService feignClientService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultController(Decoder decoder, Encoder encoder, Client client){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.feignClientService =&lt;span&gt; Feign.builder().client(client)
                .encoder(encoder)
                .decoder(decoder)
                .requestInterceptor(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BasicAuthRequestInterceptor(&quot;user&quot;,&quot;password&quot;&lt;span&gt;))
                .target(FeignClientService.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;,&quot;http://eureka-client&quot;&lt;span&gt;);
    }

    @RequestMapping(name &lt;/span&gt;= &quot;/default&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String  getInfo(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; feignClientService.getValue(&quot;hello world!&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; feignclient最常用的配置大致如上，接下来介绍下feign实现的原理。&lt;/p&gt;

&lt;p&gt;先说结论，feign是通过动态代理的技术将一个interface变为Web Service客户端。那我们应该从哪里入手呢。在使用feign的时候，我们应该关注两个注解，一个就是我们上文所说的feignClient，但是仅仅只用这个注解feign是不会生效的，必须要在启动类上加上EnableFeignClients，feign才会自动扫描feignClient。所以我们的入口应该是 EnableFeignClients&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201809/1138295-20180909121211202-531963072.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;
&lt;p&gt;EnableFeignClients 导入了FeignClientsRegistrar，这个注解真正的逻辑就在FeignClientsRegistrar中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201809/1138295-20180909121637602-634649803.png&quot; alt=&quot;&quot; width=&quot;703&quot; height=&quot;54&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个类实现了三个接口，我们先关注 ImportBeanDefinitionRegistrar，这是spring动态注册bean的接口。所以spring在启动的时候会调用以下方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(AnnotationMetadata metadata,
            BeanDefinitionRegistry registry) {
        registerDefaultConfiguration(metadata, registry);
        registerFeignClients(metadata, registry);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将配置类纳入beandefinationMap管理 ,这一块更为详细的内容可以看  &lt;a href=&quot;https://www.cnblogs.com/xmzJava/p/9140900.html&quot; target=&quot;_blank&quot;&gt;SpringIoc分析&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerDefaultConfiguration(AnnotationMetadata metadata,
            BeanDefinitionRegistry registry) {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; defaultAttrs =&lt;span&gt; metadata
                .getAnnotationAttributes(EnableFeignClients.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getName(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultAttrs != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; defaultAttrs.containsKey(&quot;defaultConfiguration&quot;&lt;span&gt;)) {
            String name;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (metadata.hasEnclosingClass()) {
                name &lt;/span&gt;= &quot;default.&quot; +&lt;span&gt; metadata.getEnclosingClassName();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                name &lt;/span&gt;= &quot;default.&quot; +&lt;span&gt; metadata.getClassName();
            }
            registerClientConfiguration(registry, name,
                    defaultAttrs.get(&lt;/span&gt;&quot;defaultConfiguration&quot;&lt;span&gt;));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;扫描FeignClient注解，将interface纳入beanDefination&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerFeignClients(AnnotationMetadata metadata,
            BeanDefinitionRegistry registry) {
        ClassPathScanningCandidateComponentProvider scanner &lt;/span&gt;=&lt;span&gt; getScanner();
        scanner.setResourceLoader(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceLoader);

        Set&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; basePackages;

        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; attrs =&lt;span&gt; metadata
                .getAnnotationAttributes(EnableFeignClients.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
        AnnotationTypeFilter annotationTypeFilter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AnnotationTypeFilter(
                FeignClient.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] clients = attrs == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                : (Class&lt;/span&gt;&amp;lt;?&amp;gt;[]) attrs.get(&quot;clients&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clients == &lt;span&gt;null&lt;/span&gt; || clients.length == 0&lt;span&gt;) {
            scanner.addIncludeFilter(annotationTypeFilter);
            basePackages &lt;/span&gt;=&lt;span&gt; getBasePackages(metadata);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Set&amp;lt;String&amp;gt; clientClasses = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
            basePackages &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; clazz : clients) {
                basePackages.add(ClassUtils.getPackageName(clazz));
                clientClasses.add(clazz.getCanonicalName());
            }
            AbstractClassTestingTypeFilter filter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbstractClassTestingTypeFilter() {
                @Override
                &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; match(ClassMetadata metadata) {
                    String cleaned &lt;/span&gt;= metadata.getClassName().replaceAll(&quot;\\$&quot;, &quot;.&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clientClasses.contains(cleaned);
                }
            };
            scanner.addIncludeFilter(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));
        }

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String basePackage : basePackages) {
            Set&lt;/span&gt;&amp;lt;BeanDefinition&amp;gt; candidateComponents =&lt;span&gt; scanner
                    .findCandidateComponents(basePackage);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (BeanDefinition candidateComponent : candidateComponents) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (candidateComponent &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AnnotatedBeanDefinition) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; verify annotated class is an interface&lt;/span&gt;
                    AnnotatedBeanDefinition beanDefinition =&lt;span&gt; (AnnotatedBeanDefinition) candidateComponent;
                    AnnotationMetadata annotationMetadata &lt;/span&gt;=&lt;span&gt; beanDefinition.getMetadata();
                    Assert.isTrue(annotationMetadata.isInterface(),
                            &lt;/span&gt;&quot;@FeignClient can only be specified on an interface&quot;&lt;span&gt;);

                    Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; attributes =&lt;span&gt; annotationMetadata
                            .getAnnotationAttributes(
                                    FeignClient.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getCanonicalName());

                    String name &lt;/span&gt;=&lt;span&gt; getClientName(attributes);
                    registerClientConfiguration(registry, name,
                            attributes.get(&lt;/span&gt;&quot;configuration&quot;&lt;span&gt;));

                    registerFeignClient(registry, annotationMetadata, attributes);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接下来，我们需要找到jdk代理的地方&lt;/p&gt;
&lt;p&gt;我们在构建feign的地方发现如下方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Feign build() {
      SynchronousMethodHandler.Factory synchronousMethodHandlerFactory &lt;/span&gt;=
          &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,
                                               logLevel, decode404);
      ParseHandlersByName handlersByName &lt;/span&gt;=
          &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParseHandlersByName(contract, options, encoder, decoder,
                                  errorDecoder, synchronousMethodHandlerFactory);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReflectiveFeign(handlersByName, invocationHandlerFactory);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 最终我们在SynchronousMethodHandler类中发现了真正拦截的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Object invoke(Object[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
    RequestTemplate template &lt;/span&gt;=&lt;span&gt; buildTemplateFromArgs.create(argv);
    Retryer retryer &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.retryer.clone();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; executeAndDecode(template);
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RetryableException e) {
        retryer.continueOrPropagate(e);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (logLevel !=&lt;span&gt; Logger.Level.NONE) {
          logger.logRetry(metadata.configKey(), logLevel);
        }
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;真正执行的逻辑如下，这里也是feign最为关键的地方。这里我们主要关注下真正请求的那一行。如果想对feign做debug或者重写一些配置，参考这里会是一个很好的入口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
Object executeAndDecode(RequestTemplate template) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
    Request request &lt;/span&gt;=&lt;span&gt; targetRequest(template);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (logLevel !=&lt;span&gt; Logger.Level.NONE) {
      logger.logRequest(metadata.configKey(), logLevel, request);
    }

    Response response;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.nanoTime();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;strong&gt;response &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;span&gt; client.execute(request, options);
      &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ensure the request is set. TODO: remove in Feign 10&lt;/span&gt;
&lt;span&gt;      response.toBuilder().request(request).build();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (logLevel !=&lt;span&gt; Logger.Level.NONE) {
        logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));
      }
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; errorExecuting(request, e);
    }
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() -&lt;span&gt; start);

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; shouldClose = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (logLevel !=&lt;span&gt; Logger.Level.NONE) {
        response &lt;/span&gt;=&lt;span&gt;
            logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ensure the request is set. TODO: remove in Feign 10&lt;/span&gt;
&lt;span&gt;        response.toBuilder().request(request).build();
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Response.&lt;span&gt;class&lt;/span&gt; ==&lt;span&gt; metadata.returnType()) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response.body() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response.body().length() == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                response.body().length() &lt;/span&gt;&amp;gt;&lt;span&gt; MAX_RESPONSE_BUFFER_SIZE) {
          shouldClose &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure the response body is disconnected&lt;/span&gt;
        &lt;span&gt;byte&lt;/span&gt;[] bodyData =&lt;span&gt; Util.toByteArray(response.body().asInputStream());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.toBuilder().body(bodyData).build();
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response.status() &amp;gt;= 200 &amp;amp;&amp;amp; response.status() &amp;lt; 300&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; ==&lt;span&gt; metadata.returnType()) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decode(response);
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (decode404 &amp;amp;&amp;amp; response.status() == 404&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decoder.decode(response, metadata.returnType());
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; errorDecoder.decode(metadata.configKey(), response);
      }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (logLevel !=&lt;span&gt; Logger.Level.NONE) {
        logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);
      }
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; errorReading(request, response, e);
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldClose) {
        ensureClosed(response.body());
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里的client是请求客户端，feign统一封装为LoadBalancerFeignClient&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@ConditionalOnClass({ ILoadBalancer.&lt;span&gt;class&lt;/span&gt;, Feign.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
@Configuration
@AutoConfigureBefore(FeignAutoConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignRibbonClientAutoConfiguration {

@Bean
    @ConditionalOnMissingBean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,
            SpringClientFactory clientFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LoadBalancerFeignClient(&lt;span&gt;new&lt;/span&gt; Client.Default(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;),
                cachingFactory, clientFactory);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认的Client 是HttpURLConnection，同时 feign也支持httpclient和okhhtp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
    @&lt;strong&gt;ConditionalOnClass(ApacheHttpClient.&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ConditionalOnMissingClass(&lt;/span&gt;&quot;com.netflix.loadbalancer.ILoadBalancer&quot;&lt;span&gt;)
    @ConditionalOnProperty(value &lt;/span&gt;= &quot;feign.httpclient.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpClientFeignConfiguration {

        @Autowired(required &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpClient httpClient;

        @Bean
        @ConditionalOnMissingBean(Client.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client feignClient() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.httpClient != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApacheHttpClient(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.httpClient);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApacheHttpClient();
        }
    }

    @Configuration
    &lt;strong&gt;@ConditionalOnClass(OkHttpClient.&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ConditionalOnMissingClass(&lt;/span&gt;&quot;com.netflix.loadbalancer.ILoadBalancer&quot;&lt;span&gt;)
    @ConditionalOnProperty(value &lt;/span&gt;= &quot;feign.okhttp.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OkHttpFeignConfiguration {

        @Autowired(required &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; okhttp3.OkHttpClient okHttpClient;

        @Bean
        @ConditionalOnMissingBean(Client.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client feignClient() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.okHttpClient != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OkHttpClient(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.okHttpClient);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OkHttpClient();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 只要满足 配置条件，就可以将httpclient或okhhtp引入，这里举例说明怎么使用httpclient&lt;/p&gt;
&lt;p&gt;在pom文件加上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.netflix.feign&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;feign-httpclient&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在配置文件上加上feign.httpclient.enabled为true(默认为true，可不写)&lt;/p&gt;

&lt;p&gt;最后，我们再看看feign是怎么使用ribbon的，上文我们说过feign统一将client封装为LoadBalancerFeignClient，fein的请求最终都会到以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Response execute(Request request, Request.Options options) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            URI asUri &lt;/span&gt;=&lt;span&gt; URI.create(request.url());
            String clientName &lt;/span&gt;=&lt;span&gt; asUri.getHost();
            URI uriWithoutHost &lt;/span&gt;=&lt;span&gt; cleanUrl(request.url(), clientName);
            FeignLoadBalancer.RibbonRequest ribbonRequest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeignLoadBalancer.RibbonRequest(
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate, request, uriWithoutHost);

            IClientConfig requestConfig &lt;/span&gt;=&lt;span&gt; getClientConfig(options, clientName);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;strong&gt;&lt;span&gt; lbClient(clientName).executeWithLoadBalancer(ribbonRequest,
                    requestConfig).toResponse();
        }
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClientException e) {
            IOException io &lt;/span&gt;=&lt;span&gt; findIOException(e);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (io != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; io;
            }
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;具体我们可以看下&lt;strong&gt; executeWithLoadBalancer &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; T executeWithLoadBalancer(&lt;span&gt;final&lt;/span&gt; S request, &lt;span&gt;final&lt;/span&gt; IClientConfig requestConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClientException {
        RequestSpecificRetryHandler handler &lt;/span&gt;=&lt;span&gt; getRequestSpecificRetryHandler(request, requestConfig);
        LoadBalancerCommand&lt;/span&gt;&amp;lt;T&amp;gt; command = LoadBalancerCommand.&amp;lt;T&amp;gt;&lt;span&gt;builder()
                .withLoadBalancerContext(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                .withRetryHandler(handler)
                .withLoadBalancerURI(request.getUri())
                .build();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; command.&lt;strong&gt;submit&lt;/strong&gt;(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ServerOperation&amp;lt;T&amp;gt;&lt;span&gt;() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt;&lt;span&gt; call(Server server) {
                        URI finalUri &lt;/span&gt;=&lt;span&gt; reconstructURIWithServer(server, request.getUri());
                        S requestForServer &lt;/span&gt;=&lt;span&gt; (S) request.replaceUri(finalUri);
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.just(AbstractLoadBalancerAwareClient.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.execute(requestForServer, requestConfig));
                        } 
                        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(e);
                        }
                    }
                })
                .toBlocking()
                .single();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            Throwable t &lt;/span&gt;=&lt;span&gt; e.getCause();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ClientException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (ClientException) t;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientException(e);
            }
        }
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在submit方法里,发现了如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use the load balancer&lt;/span&gt;
        Observable&amp;lt;T&amp;gt; o =&lt;span&gt; 
                (server &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt;&lt;strong&gt; selectServer&lt;/strong&gt;() : Observable.just(server))
                .concatMap(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Func1&amp;lt;Server, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的&lt;strong&gt;selectServer &lt;/strong&gt;最终会调用 ILoadBalancer 选择一个server&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ILoadBalancer lb =&lt;span&gt; getLoadBalancer();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (host == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Partial URI or no URI Case
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; well we have to just get the right instances from lb - or we fall back&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (lb != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                Server svc &lt;/span&gt;= lb.chooseServer(loadBalancerKey);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 关于这方面的具体内容，请参考 &lt;a href=&quot;https://www.cnblogs.com/xmzJava/p/9583991.html&quot; target=&quot;_blank&quot;&gt;SpringCloud Ribbon的分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上，就是对feign的具体分析&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 05:18:00 +0000</pubDate>
<dc:creator>XuMinzhe</dc:creator>
<og:description>Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它既可完成。 我们只需要在相应的接口上添加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xmzJava/p/9612988.html</dc:identifier>
</item>
<item>
<title>Spring系列(三) Bean装配的高级技术 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9613360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9613360.html</guid>
<description>&lt;h2 id=&quot;profile&quot;&gt;profile&lt;/h2&gt;
&lt;p&gt;不同于maven的profile, spring的profile不需要重新打包, 同一个版本的包文件可以部署在不同环境的服务器上, 只需要激活对应的profile就可以切换到对应的环境.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Profile({&quot;test&quot;,&quot;dev&quot;})&lt;/code&gt; Java Config 通过这个注解指定bean属于哪个或哪些profile. 参数value是一个profile的字符串数组. 此注解可以添加到类或方法上. XML Config 对应的节点是beans的属性&lt;code&gt;profile=&quot;dev&quot;&lt;/code&gt;, 可以在根&lt;code&gt;&amp;lt;beans&amp;gt;&lt;/code&gt;节点下嵌套定义分属不同profile的节点, 形成如下结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;beans ...&amp;gt;
    &amp;lt;beans profile=&quot;dev&quot;&amp;gt;
        &amp;lt;bean ...&amp;gt;
        &amp;lt;bean ...&amp;gt;
    &amp;lt;/beans&amp;gt;
    &amp;lt;beans profile=&quot;prod&quot;&amp;gt;
        &amp;lt;bean ...&amp;gt;
    &amp;lt;/beans&amp;gt;
    ...
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;spring.profiles.active&lt;/code&gt;和&lt;code&gt;spring.profiles.default&lt;/code&gt;可以设置激活哪个profile,如果是多个就用&quot;,&quot;分开, spring优先使用&lt;code&gt;spring.profiles.active&lt;/code&gt;的设置, 如果找不到, 就使用&lt;code&gt;spring.profiles.default&lt;/code&gt;设置的值, 如果二者都没设置, spring会认为没有要激活的profile, 它只会创建不加&lt;code&gt;@Profile&lt;/code&gt;的那些bean.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以通过多种方式设置这两个属性:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DispacherServlet的初始化参数&lt;/li&gt;
&lt;li&gt;Web应用的上下文参数&lt;/li&gt;
&lt;li&gt;JNDI&lt;/li&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;li&gt;JVM系统属性&lt;/li&gt;
&lt;li&gt;测试类上使用&lt;code&gt;@ActiveProfiles&lt;/code&gt;注解&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是web.xml中在上下文以及在servlet中设置&lt;code&gt;spring.profiles.default&lt;/code&gt;的代码&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;web-app&amp;gt;
    &amp;lt;!--上下文设置default profile--&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;spring.profiles.default&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;dev&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;servlet&amp;gt;
        ...
        &amp;lt;!--设置default profile--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;spring.profiles.default&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;dev&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/servlet&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;条件化的-bean&quot;&gt;条件化的 bean&lt;/h2&gt;
&lt;p&gt;Spring4.0 引入了条件化bean, 这些bean只有在满足一定条件下才会创建. profile就是条件化的一种使用方式, 事实上4.0版本后的profile实现机制与其他条件化bean完全一样, 我们可以通过profile的源码一窥条件化bean的机制.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(ProfileCondition.class) //注意这里, 条件化bean的注解
public @interface Profile {
    String[] value();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Conditional(ConditionClass.class)&lt;/code&gt; Java Config 可以将这个注解添加到&lt;code&gt;@Bean&lt;/code&gt;注解的方法上, 参数value是一个Class类型的变量, 这个类必须实现&lt;code&gt;Condition&lt;/code&gt;接口, 方法&lt;code&gt;matchs()&lt;/code&gt;返回true则加载bean, 否则忽略.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt; 接口定义如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Condition {
    boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ProfileCondition&lt;/code&gt;的定义&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class ProfileCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 获取profile注解的属性
        MultiValueMap&amp;lt;String, Object&amp;gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
        if (attrs != null) {
            // 获取value属性的值
            for (Object value : attrs.get(&quot;value&quot;)) {
                // 测试profile是否激活
                if (context.getEnvironment().acceptsProfiles((String[]) value)) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;matchs()&lt;/code&gt;方法的两个参数我们可以做到 (1)通过ConditionContext获取到上下文所需信息;(2)通过AnnotatedTypeMetadata获取到bean的注解&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ConditionContext {
    // 获取bean的注册信息, 从而可以检查bean定义
    BeanDefinitionRegistry getRegistry();
    // 获取bean工厂,从而可以判断bean是否存在,获取其他bean,获取bean的状态信息
    @Nullable
    ConfigurableListableBeanFactory getBeanFactory();
    // 获取环境变量,profile中正是使用此对象的方法acceptsProfiles()检查profile是否激活
    Environment getEnvironment();
    // 获取加载的资源
    ResourceLoader getResourceLoader();
    // 获取classLoader
    @Nullable
    ClassLoader getClassLoader();
}

public interface AnnotatedTypeMetadata {
    // 检查是否由某注解
    boolean isAnnotated(String annotationName);
    // 下面几个方法可以获取bean的注解,包括其属性
    @Nullable
    Map&amp;lt;String, Object&amp;gt; getAnnotationAttributes(String annotationName);
    @Nullable
    Map&amp;lt;String, Object&amp;gt; getAnnotationAttributes(String annotationName, boolean classValuesAsString);
    @Nullable
    MultiValueMap&amp;lt;String, Object&amp;gt; getAllAnnotationAttributes(String annotationName);
    @Nullable
    MultiValueMap&amp;lt;String, Object&amp;gt; getAllAnnotationAttributes(String annotationName, boolean classValuesAsString);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自动装配的歧义&quot;&gt;自动装配的歧义&lt;/h2&gt;
&lt;p&gt;自动装配大大简化了spring的配置, 对于大多数应用对象的依赖bean, 程序实现的时候一般只有一个匹配, 但也存在匹配到多个bean的情况, Spring处理不了这种情况, 这时候就需要由开发人员为其消除装配的歧义.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Primary&lt;/code&gt; 注解用来指定被注解的bean为首选bean. 但如果多个匹配的bean都添加了该注解依然无法消除歧义.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Qualifier&lt;/code&gt; 注解用来限定bean的范围. 与&lt;code&gt;@AutoWired&lt;/code&gt;和&lt;code&gt;@Inject&lt;/code&gt;共同使用时,参数value用来指定beanid, 但使用默认的beanid对重构不友好. 与&lt;code&gt;@Component&lt;/code&gt;或&lt;code&gt;@Bean&lt;/code&gt;一起使用时,参数value为bean指定别名, 别名一般是带有描述bean特征的词描述, 然后在注入时就可以使用别名. 但别名可能需要定义多个, Qualifier不支持数组, 也不允许定义多个(原因见下面).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Qualifier&lt;/code&gt; 不允许对同一bean重复标记, 这是因为Qualifier注解定义没有添加&lt;code&gt;@Repeatable&lt;/code&gt;注解.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用自定义限定注解的方式达到缩小bean范围的目的.&lt;/p&gt;
&lt;p&gt;下面代码使用Qualifier的方式定义bean&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Qualifier(&quot;cheap&quot;)
public class QQCar implements Car{

}
@Component
@Qualifier(&quot;fast&quot;)
public class BenzCar implements Car{
    
}
@Component
@Qualifier(&quot;safe&quot;)
//@Qualifier(&quot;comfortable&quot;) //行不通,不能加两个Qualifier
public class BMWCar implements Car{
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再使用自定义限定注解的方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 定义
...
@Qualifier
public @interface Cheap{}

...
@Qualifier
public @interface Fast{}

...
@Qualifier
public @interface Safe{}

...
@Qualifier
public @interface Comfortable{}

// 使用
@Component
@Safe
@Comfortable
public class BMWCar implements Car{
    
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用自定义限定的方式可以随意组合来限定bean的范围, 因为没有任何使用string类型, 所以也是类型安全的.&lt;/p&gt;
&lt;h2 id=&quot;bean-作用域&quot;&gt;bean 作用域&lt;/h2&gt;
&lt;p&gt;bean的四种作用域:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单例(Singleton) 默认为此作用域, 全局唯一&lt;/li&gt;
&lt;li&gt;原型(Prototype) 注入或从上下文获取时均会创建&lt;/li&gt;
&lt;li&gt;会话(Session) Web程序使用, 同一会话保持唯一&lt;/li&gt;
&lt;li&gt;请求(Request) Web程序使用,每次请求唯一&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Scope&lt;/code&gt; Java Config 用此注解指定bean的作用域, 参数value用来指定作用域, 如&lt;code&gt;value=ConfigurableBeanFactory.SCOPE_PROTOTYPE&lt;/code&gt;, 原型和单例的常数定义在&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;中, 会话和请求的常数定义在&lt;code&gt;WebApplicationContext&lt;/code&gt;中 ; 另一个参数&lt;code&gt;proxyMode=ScopedProxyMode.INTERFACES&lt;/code&gt;用来指定创建代理的方式, 示例中指定了使用基于接口的代理方法; 如果使用&lt;code&gt;proxyMode=ScopedProxyMode.TARGET_CLASS&lt;/code&gt;则会使用CGLib来生成基于类的代理.&lt;br/&gt;XML Config对应的时bean的&lt;code&gt;scope=&quot;prototype&quot;&lt;/code&gt;属性, 针对web作用域,还需要指定使用代理,示例代码如下.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;beanid&quot; class=&quot;...&quot; scope=&quot;session&quot;&amp;gt;
    &amp;lt;!--需要引用aop命名空间的.  proxy-target-class 默认为true, 使用CGLib创建代理, 指定为false则使用接口方式创建代理--&amp;gt;
    &amp;lt;aop:scoped-proxy proxy-target-class=&quot;false&quot;&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;作用域为什么使用代理模式? 如果bean不是单例的, spring会为其创建一个代理对象, 再将这个代理对象注入进去, 实际运行过程中由代理对象委托调用实际的bean. 这样有两点好处:(1)懒加载, bean可以在需要时才创建;(2)便于作用域扩展&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;属性占位符和spel&quot;&gt;属性占位符和SpEL&lt;/h2&gt;
&lt;p&gt;spring提供了两种运行时注入值的方式, 这样就避免了将字面量硬编码到程序或配置文件里面.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;属性占位符&lt;/li&gt;
&lt;li&gt;SpEL&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一. 属性占位符&lt;/p&gt;
&lt;p&gt;先看下面的例子:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@PropertySource(&quot;classpath:/path/app.property&quot;)
public class MyConfig{

    @AutoWired
    Environment env;

    @Bean
    public Car getCar(){
        return new QQCar(env.getProperty(&quot;qqcar.price&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@PropertySource(&quot;classpath:/path/app.property&quot;)&lt;/code&gt; 可以指定加载资源文件的位置, 结合使用Environment类的实例env,可以获取到资源文件中配置的节点.&lt;code&gt;Environment&lt;/code&gt;不仅可以获取到配置的字面量, 它也可以获取复杂类型, 将其转化为对应Class的实例.&lt;code&gt;&amp;lt;T&amp;gt; T getProperty(String key, Class&amp;lt;T&amp;gt; targetType);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;XML Congif 可以使用占位符, 形如&lt;code&gt;${qqcar.price}&lt;/code&gt;, 前提是配置了context命名空间下的&lt;code&gt;&amp;lt;context:property-placeholder /&amp;gt;&lt;/code&gt; 它会生成类型为&lt;code&gt;PropertySourcesPlaceholderConfigurer&lt;/code&gt;的bean, 该bean用来解析占位符&lt;/li&gt;
&lt;li&gt;如果开启组件扫描和自动装配的话, 就没有必要指定资源文件或类了, 可以使用&lt;code&gt;@Value(qqcar.price)&lt;/code&gt;. 同样, 需要一个类型为&lt;code&gt;PropertySourcesPlaceholderConfigurer&lt;/code&gt;的bean.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer(){
    return new PropertySourcesPlaceholderConfigurer();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二. 功能更强大的SpEL&lt;/p&gt;
&lt;p&gt;SpEL的特性如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用bean的Id来引用bean&lt;/li&gt;
&lt;li&gt;调用方法和属性: 可以通过beanid来调用bean的方法和属性, 就像在代码中一样.&lt;/li&gt;
&lt;li&gt;对值进行算术,逻辑,关系运算: 特别注意: &lt;code&gt;^&lt;/code&gt;乘方运算符; &lt;code&gt;?:&lt;/code&gt;为空运算符&lt;/li&gt;
&lt;li&gt;正则表达式匹配: 形如#{beanid.mobile matches '1(?:3\d|4[4-9]|5[0-35-9]|6[67]|7[013-8]|8\d|9\d)\d{8}'}&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;集合操作: &lt;code&gt;.?[]&lt;/code&gt;查找运算符; &lt;code&gt;.^[]&lt;/code&gt;查找匹配的第一项;&lt;code&gt;.$[]&lt;/code&gt;查找匹配的最后一项;&lt;code&gt;.![]&lt;/code&gt;投影运算符(比如获取集合中符合条件的对象, 并取其中某个属性映射到结果集合中);&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SpEL的示例 #{1},#{T(System).out.print(&quot;test&quot;)},#{beanId.name},#{systemProperies[&quot;path&quot;]}&lt;/p&gt;
&lt;p&gt;虽然SpEL功能强大, 我们可以通过SpEL编写复杂的表达式, 但过分复杂的表达式不适合理解和阅读, 同时也会增大测试的难度. 因此建议尽量编写简洁的表达式.&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 04:58:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>profile 不同于maven的profile, spring的profile不需要重新打包, 同一个版本的包文件可以部署在不同环境的服务器上, 只需要激活对应的profile就可以切换到对应的环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9613360.html</dc:identifier>
</item>
<item>
<title>Spring基础系列-AOP源码分析 - 唯一浩哥</title>
<link>http://www.cnblogs.com/V1haoge/p/9560803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V1haoge/p/9560803.html</guid>
<description>&lt;p&gt;原创作品，可以转载，但是请标注出处地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Spring基础系列-AOP源码分析&quot; href=&quot;https://www.cnblogs.com/V1haoge/p/9560803.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/V1haoge/p/9560803.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Spring的两大特性：IOC和AOP。&lt;/p&gt;
&lt;p&gt;　　AOP是面向切面编程，Spring内置了自己实现的基于动态代理技术的AOP，同时还支持成熟的AspectJ框架，我们这里主要讲述的还是内置的基于动态代理的AOP实现。因为面对一些普通的需求，Spring内置的AOP已经绰绰有余。&lt;/p&gt;
&lt;p&gt;　　AOP一般用于增强原来的代码的功能，这种增强体现在辅助方面，比如安全、日志、事务等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、术语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、连接点（JoinPoint）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　连接点就是具体的代码中的切入点，指的是&lt;strong&gt;具体的一处&lt;/strong&gt;代码位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、切点（PointCut）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　切点是对一系列代表同种功能（目的）的切入点（连接点）的统称，&lt;strong&gt;切点不是一个点，而是代表某一功能的一系列连接点的集合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、通知（Advice）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通知就是我们要在切点执行的操作，就是我们要实现的目的，是要实现的功能的代码实现。一般通知又称为增强，所谓增强就是对原来功能的基础上添加新功能，进行功能增强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、切面（Aspect）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;切面是通知和切点的综合体&lt;/strong&gt;，定义好了一个切面，那么我们就知道，这个AOP要实现的功能是什么，需要切入到程序中的那些地方。抽象层次中，&lt;strong&gt;切面是代码功能的横切面&lt;/strong&gt;，这个横切面的位置就是切点、这个切面的功能就是通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、织入（Weaving）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　织入就是切面作用到目标代码中的方式，Spring内置的AOP采用的是动态代理的方式来织入，还可以采用编译器织入和加载期织入，后两者分别需要特定的编译器和类加载器来完成，后两种方式是AspectJ所支持的织入方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、引介（Introduction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　引介是另一种类型的增强，它可以为类添加一些属性和方法。它和通知是并列的两种不同的增强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、目标对象（Target）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　目标对象就是我们想要织入的对象，一般不会是一个，通常是一批符合条件的对象。&lt;/p&gt;
&lt;p&gt;8、代理（Proxy）&lt;/p&gt;
&lt;p&gt;　　代理就好理解了，Spring内置的AOP就是通过动态代理的方式实现织入的，创建目标对象的代理类，在代理类中执行通知的内容，然后在合适的位置调用目标对象的方法，来达到织入的目的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、Spring AOP概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Spring AOP是基于动态代理技术实现的切面编程，代理技术包括JDK动态代理和CGLIB动态代理，前者基于接口实现，后者基于类实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、Spring中使用AOP技术的方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）定义切面类，使用@Aspect注解&lt;/p&gt;
&lt;p&gt;　　2）在切面类中定义切点方法，使用@PointCut注解&lt;/p&gt;
&lt;p&gt;　　3）在切面类中定义通知方法，使用@Before、@After、@Around等注解&lt;/p&gt;
&lt;p&gt;　　4）在通知方法的注解中使用切点方法&lt;/p&gt;
&lt;p&gt;　　5）在切面类上加设注解@Component&lt;/p&gt;
&lt;p&gt;　　6）启动AOP功能，两种方式：原始的XML配置方式和注解方式&lt;/p&gt;
&lt;p&gt;　　　　XMl方式：&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　注解方式：@EnableAspectJAutoProxy&lt;/p&gt;
&lt;p&gt;　　　　配置方式：spring.auto.proxy=true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Spring AOP支持的增强类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通知增强：Advice　　&lt;/p&gt;
&lt;p&gt;　　前置通知：MethodBeforeAdvice-在连接点之前执行&lt;/p&gt;
&lt;p&gt;　　后置通知：AfterReturningAdvice-在连接点正常执行完后执行，如果还未到连接点就异常，不会执行&lt;/p&gt;
&lt;p&gt;　　环绕通知：AroundAdvice-在连接点前后执行&lt;/p&gt;
&lt;p&gt;　　异常通知：AfterThrowingAdvice-在连接点抛出异常后执行&lt;/p&gt;
&lt;p&gt;　　finally通知：AfterAdvice-最终执行，无论是否异常，方法执行结束都会执行&lt;/p&gt;
&lt;p&gt;引介增强：IntroductionInterceptor-&amp;gt;DelegatingIntroductionInterceptor&lt;/p&gt;
&lt;p&gt;　　前五种很好理解，重点是最后一种引介增强，这种增强并不是针对方法的增强，而是针对类的增强，它会为目标添加属性和方法，比如它可以为目标类添加一个接口的实现。目标类原本没有实现某个接口，但是我们可以使用引介增强的方式为目标类创建一个实现该接口的代理，在这个代理中可以使用接口的功能来作用于目标对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、原理图：&lt;/strong&gt;（右键打开看大图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/592104/201808/592104-20180831141059061-408086898.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、源码分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.1 入口一：&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码1-来自：AopNamespaceHandler&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; In 2.0 XSD as well as in 2.1 XSD.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         registerBeanDefinitionParser(&quot;config&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigBeanDefinitionParser());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         registerBeanDefinitionParser(&quot;&lt;span&gt;&lt;strong&gt;aspectj-autoproxy&lt;/strong&gt;&lt;/span&gt;&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AspectJAutoProxyBeanDefinitionParser());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ScopedProxyBeanDefinitionDecorator());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only in 2.0 XSD: moved to context namespace as of 2.1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         registerBeanDefinitionParser(&quot;spring-configured&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringConfiguredBeanDefinitionParser());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面源码就是针对XML配置中&amp;lt;aop:XXX/&amp;gt;配置的解析，红色部分正是针对&amp;lt;aop:aspectj-autoproxy/&amp;gt;的解析，如果配置了aspectj-autoproxy，则注册Bean定义解析器：&lt;span&gt;&lt;strong&gt;AspectJAutoProxyBeanDefinitionParser&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;AspectJAutoProxyBeanDefinitionParser&lt;/span&gt;是一个实现了&lt;/span&gt;BeanDefinitionParser接口的类，专门用于解析切面自动代理的Bean定义的解析工作，重点在其parse方法。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码2-来自：AspectJAutoProxyBeanDefinitionParser&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AspectJAutoProxyBeanDefinitionParser &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanDefinitionParser {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parse(Element element, ParserContext parserContext) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-注册AnnotationAwareAspectJAutoProxyCreator&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        AopNamespaceUtils.&lt;strong&gt;registerAspectJAnnotationAutoProxyCreatorIfNecessary&lt;/strong&gt;(parserContext, element);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-扩展BeanDefinition&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&lt;strong&gt;        extendBeanDefinition&lt;/strong&gt;(element, parserContext);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; extendBeanDefinition(Element element, ParserContext parserContext) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取BeanName为internalAutoProxyCreator的BeanDefinition，其实就是之前注册的自动代理构建器&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         BeanDefinition beanDef =
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (element.hasChildNodes()) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前元素有子节点，则给上面获取的Bean定义添加子节点中明确定义的类型值（填充BeanDefinition）&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;&lt;strong&gt;            addIncludePatterns&lt;/strong&gt;(element, parserContext, beanDef);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addIncludePatterns(Element element, ParserContext parserContext, BeanDefinition beanDef) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         ManagedList&amp;lt;TypedStringValue&amp;gt; includePatterns = &lt;span&gt;new&lt;/span&gt; ManagedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         NodeList childNodes = element.getChildNodes();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取子节点&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; childNodes.getLength(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历子节点，获取子节点中name属性值，封装到TypeStringValue中
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在上下文中提取子节点includeElement的元数据保存到TypedStringValue的source属性中
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后封装好的TypeStringValue保存到includePatterns列表中&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             Node node =&lt;span&gt; childNodes.item(i);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 Element includeElement =&lt;span&gt; (Element) node;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 TypedStringValue valueHolder = &lt;span&gt;new&lt;/span&gt; TypedStringValue(includeElement.getAttribute(&quot;name&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                valueHolder.setSource(parserContext.extractSource(includeElement));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                includePatterns.add(valueHolder);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;includePatterns.isEmpty()) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从解析上下文parserContext中提取指定节点element的元数据保存到includePatterns的source属性中，
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后将includePatterns保存到BeanDefinition的propertyValues属性中&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            includePatterns.setSource(parserContext.extractSource(element));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             beanDef.getPropertyValues().add(&quot;includePatterns&quot;&lt;span&gt;, includePatterns);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码中有两个重点，首先就是&lt;span&gt;registerAspectJAnnotationAutoProxyCreatorIfNecessary方法调用，用于&lt;/span&gt;注册AnnotationAwareAspectJAutoProxyCreator构建器；另一点就是在构建器注册完成后，为其填充一些必要内容，这些内容为XML配置中子节点的配置内容，具体内容参照源码，这里重点看看第一步，注册构建器的源码：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码3-来自：AopNamespaceUtils&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerAspectJAnnotationAutoProxyCreatorIfNecessary(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            ParserContext parserContext, Element sourceElement) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-注册或升级AnnotationAwareAspectJAutoProxyCreator
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; parserContext.getRegistry()获取到的是BeanDefinitionRegistry注册器，第二个参数是提取的指定元素的元数据&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         BeanDefinition beanDefinition =&lt;span&gt; AopConfigUtils.&lt;strong&gt;registerAspectJAnnotationAutoProxyCreatorIfNecessary&lt;/strong&gt;(
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                parserContext.getRegistry(), parserContext.extractSource(sourceElement));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-校验并设置是否适用基于CGLIB的动态代理实现AOP，和是否要暴露代理类&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&lt;strong&gt;        useClassProxyingIfNecessary&lt;/strong&gt;(parserContext.getRegistry(), sourceElement);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3-注册成组件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&lt;strong&gt;        registerComponentIfNecessary&lt;/strong&gt;(beanDefinition, parserContext);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (sourceElement != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取XML中设置的proxy-target-class属性的值，解析为Boolean值&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (proxyTargetClass) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果为true，则强制自动代理构建器使用基于类的动态代理CGLIB，需要将属性设置到自动代理构建器的BeanDefinition中&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取XML中配置的expose-proxy属性的值，同样解析为Boolean值&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (exposeProxy) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果为true，强制自动代理构建器暴露代理类，需要将属性设置到自动代理构建器的BeanDefinition中&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerComponentIfNecessary(@Nullable BeanDefinition beanDefinition, ParserContext parserContext) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (beanDefinition != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将自动代理构建器包装成为一个Bean组件定义。
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bean组件定义是将一个BeanDefinition中包含的所有的属性的值（可能为一个BeanDefinition或者BeanReference）全部封装起来成为一个组件包，然后将其注册到解析上下文中&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             BeanComponentDefinition componentDefinition =
&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanComponentDefinition(beanDefinition, AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            parserContext.registerComponent(componentDefinition);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　registerAspectJAnnotationAutoProxyCreatorIfNecessary方法中主要做了三件事情：&lt;/p&gt;
&lt;p&gt;　　　　1-注册构建器&lt;/p&gt;
&lt;p&gt;　　　　2-配置属性&lt;/p&gt;
&lt;p&gt;　　　　3-组件注册&lt;/p&gt;
&lt;p&gt;　　针对第2和第3，在源码注释中解释的很清楚啦，主要看看第一步，继续进行构建器的注册：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码4-来自：AopConfigUtils&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果构建器已经加载，获取其BeanDefinition，添加属性proxyTargetClass，值为true&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             BeanDefinition definition =&lt;span&gt; registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             definition.getPropertyValues().add(&quot;proxyTargetClass&quot;&lt;span&gt;, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果构建器已经加载，获取其BeanDefinition，添加属性exposeProxy，值为true&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             BeanDefinition definition =&lt;span&gt; registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             definition.getPropertyValues().add(&quot;exposeProxy&quot;&lt;span&gt;, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BeanDefinition registerOrEscalateApcAsRequired(Class&amp;lt;?&amp;gt;&lt;span&gt; cls, BeanDefinitionRegistry registry,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            @Nullable Object source) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-如果internalAutoProxyCreator已经被注册那么比较新旧自动代理构建器类在列表中的优先级，如果已注册的构建器优先级低，则替换为给定的新构建器&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             BeanDefinition apcDefinition =&lt;span&gt; registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cls.getName().equals(apcDefinition.getBeanClassName())) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; currentPriority =&lt;span&gt; findPriorityForClass(apcDefinition.getBeanClassName());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; requiredPriority =&lt;span&gt; findPriorityForClass(cls);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (currentPriority &amp;lt;&lt;span&gt; requiredPriority) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    apcDefinition.setBeanClassName(cls.getName());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尚未注册internalAutoProxyCreator的情况下，将给定的构建器包装成RootBeanDefinition，然后注册这个BeanDefinition&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         RootBeanDefinition beanDefinition = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RootBeanDefinition(cls);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;// &lt;/span&gt;&lt;span&gt;把元数据保存到BeanDefinition中&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        beanDefinition.setSource(source);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;// &lt;/span&gt;&lt;span&gt;设置为最高优先值&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         beanDefinition.getPropertyValues().add(&quot;order&quot;&lt;span&gt;, Ordered.HIGHEST_PRECEDENCE);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;// &lt;/span&gt;&lt;span&gt;设置为基础角色&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;// 2-&lt;/span&gt;&lt;span&gt;以internalAutoProxyCreator为beanName注册当前BeanDefinition（AnnotationAwareAspectJAutoProxyCreator类）&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanDefinition;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码4中前两个方法时源码3中第二步里面配置属性时调用的方法，在此给出。&lt;/p&gt;
&lt;p&gt;　　源码4的1-中是在已存在一个自动代理构建器的情况下，将其与新的给定的AnnotationAwareAspectJAutoProxyCreator构建器的优先级进行比对，取优先极高的。&lt;/p&gt;
&lt;p&gt;　　最后的registerBeanDefinition方法用于注册BeanDefinition。至此，自动代理构建器加载完毕。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.2 入口二：@EnableAspectJAutoProxy&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　源码5-来自：EnableAspectJAutoProxy&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; @Import(&lt;strong&gt;AspectJAutoProxyRegistrar&lt;/strong&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableAspectJAutoProxy {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * to standard Java interface-based proxies. The default is {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false}.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; proxyTargetClass() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * Indicate that the proxy should be exposed by the AOP framework as a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ThreadLocal}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * for retrieval via the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.aop.framework.AopContext} class.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * Off by default, i.e. no guarantees that {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; AopContext} access will work.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 4.3.1
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; exposeProxy() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码中重点关注@Import(&lt;strong&gt;AspectJAutoProxyRegistrar&lt;/strong&gt;.&lt;span&gt;class&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;，很明显这个注解导入了一个新类：&lt;strong&gt;AspectJAutoProxyRegistrar。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　使用@Import注解导入的方式可以将一个类注册到BeanFactory中。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码6-来自AspectJAutoProxyRegistrar&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AspectJAutoProxyRegistrar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ImportBeanDefinitionRegistrar {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-注册或升级自动代理构建器&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-封装注解属性，并根据属性进行配置&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         AnnotationAttributes enableAspectJAutoProxy =
&lt;span&gt;10&lt;/span&gt;                 AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (enableAspectJAutoProxy != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以从源码5中看到注解@EnableAspectJAutoProxy内部有两个属性设置proxyTargetClass和exposeProxy，这个之前的入口一中源码3里面的2-中的设置是一样的，即我们在XML启动AOP的时候也可以设置这两个值。&lt;/p&gt;
&lt;p&gt;　　proxyTargetClass属性表示是否适用基于类的的动态代理CGLIB来创建代理类。true表示使用，false表示不使用，默认是false。&lt;/p&gt;
&lt;p&gt;　　exposeProxy属性表示是否暴露生成的代理类，暴露就是可手动调用，最常见的情况如，在一个类中使用this调用带有@Transactional注解的方法，你会发现事务是不生效的，这时候我们就可以将生成的代理暴露出来手动调用代理类来保证事务生效：&lt;/p&gt;
&lt;p&gt;　　如下例子中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestService {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMethod1();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMethod2();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestServiceImpl {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMethod1(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;some transaction operate    &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMethod2(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testMethod1();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在testMethod2中以&lt;span&gt;this&lt;span&gt;.testMethod1()方式调用带事务注解的testMethod1方法时，其事务是不生效的。修改方式就是将exposeProxy设置为true，然后修改调用方式为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     ((TestService)AopContext.currnetProxy()).testMethod1();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码6中1-调用的是AopConfigUtils中的方法：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码7-来自：AopConfigUtils&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后它再调用的就是源码4中的源码了，到这里调用的就是公共部分啦。那么这一部分也就到此为止了，其余见源码4之后的部分。&lt;/p&gt;
&lt;p&gt;　　到此两个主要的入口都分析完毕，入口的主要作用就是注册或者升级自动代理构建器，因为之后AOP的操作基本都要依靠这个构建器来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、创建AOP代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们的重点就是构建器AnnotationAwareAspectJAutoProxyCreator，分析下其继承结构，你会发现它实现了BeanPostProcessor接口。&lt;/p&gt;
&lt;p&gt;　　BeanPostProcessor接口有两个方法：&lt;/p&gt;
&lt;p&gt;　　　　postProcessBeforeInitialization：Bean实例初始化前调用&lt;/p&gt;
&lt;p&gt;　　　　postProcessAfterInitialization：Bean实例初始化之后调用&lt;/p&gt;
&lt;p&gt;　　然后我们在其继承体系中寻找实现这两个方法的类，一番寻找后发现：AbstractAutoProxyCreator&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码8-来自：AbstractAutoProxyCreator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object postProcessAfterInitialization(@Nullable Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (bean != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;// 1-&lt;/span&gt;&lt;span&gt;生成缓存key&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             Object cacheKey =&lt;span&gt;&lt;strong&gt; getCacheKey&lt;/strong&gt;(bean.getClass(), beanName);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;// &lt;/span&gt;&lt;span&gt;校验该key是否已存在于earlyProxyReferences缓存&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlyProxyReferences.contains(cacheKey)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;// 2-&lt;/span&gt;&lt;span&gt;执行创建代理对象&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;strong&gt; wrapIfNecessary&lt;/strong&gt;(bean, beanName, cacheKey);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们发现了这个方法的实现，这个方法会在构建器Bean初始化之后被调用。我们看看它做了啥？&lt;/p&gt;
&lt;p&gt;　　重点就是wrapIfNecessary方法，这个方法用于代理对象的生成。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码9-来自：AbstractAutoProxyCreator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetSourcedBeans.contains(beanName)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;// &lt;/span&gt;&lt;span&gt;已经处理过，直接返回&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Boolean.FALSE.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.get(cacheKey))) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;// &lt;/span&gt;&lt;span&gt;如果不需要增强，直接返回&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if (isInfrastructureClass(bean.getClass()) ||&lt;span&gt; shouldSkip(bean.getClass(), beanName)) {&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;　　 &lt;span&gt;// &lt;span&gt;检测目标类是否是AOP的基础设施类,基础设施类包括Advice、Pointcut、Advisor、AopInfrastructureBean，或者是否需要跳过代理，如果是则将其设置为无需增强&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create proxy if we have advice.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;// 1-获取针对当前Bean的增强&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Object[] specificInterceptors = &lt;strong&gt;getAdvicesAndAdvisorsForBean&lt;/strong&gt;(bean.getClass(), beanName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (specificInterceptors !=&lt;span&gt; DO_NOT_PROXY) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;// &lt;/span&gt;&lt;span&gt;如果获取到增强则执行下面的创建代理&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;// 2-&lt;/span&gt;&lt;span&gt;创建代理&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             Object proxy =&lt;span&gt;&lt;strong&gt; createProxy&lt;/strong&gt;(
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     bean.getClass(), beanName, specificInterceptors, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingletonTargetSource(bean));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;// &lt;/span&gt;&lt;span&gt;缓存代理类&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxyTypes.put(cacheKey, proxy.getClass());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;// &lt;/span&gt;&lt;span&gt;如果未获取到增强，则设置跳过代理&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的源码中除了进行一些必要的校验之外，主要的逻辑是获取针对当前Bean的增强和创建代理这两步。&lt;/p&gt;
&lt;p&gt;　　首先来看下如何获取增强&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码10-来自：AbstractAdvisorAutoProxyCreator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取通知（增强）&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object[] getAdvicesAndAdvisorsForBean(
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; advisors =&lt;span&gt;&lt;strong&gt; findEligibleAdvisors&lt;/strong&gt;(beanClass, beanName);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (advisors.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DO_NOT_PROXY;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors.toArray();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;源码11-来自：AbstractAdvisorAutoProxyCreator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Advisor&amp;gt; findEligibleAdvisors(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-先获取所有的增强器列表&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; candidateAdvisors =&lt;span&gt;&lt;strong&gt; findCandidateAdvisors&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-获取应用到当前目标类的增强器列表&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; eligibleAdvisors =&lt;span&gt;&lt;strong&gt; findAdvisorsThatCanApply&lt;/strong&gt;(candidateAdvisors, beanClass, beanName);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法是一个钩子方法，用于子类重写扩展&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        extendAdvisors(eligibleAdvisors);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;eligibleAdvisors.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             eligibleAdvisors = sortAdvisors(eligibleAdvisors);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; eligibleAdvisors;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的源码我们重点关注&lt;span&gt;&lt;strong&gt;findCandidateAdvisors&lt;/strong&gt;&lt;/span&gt;方法和&lt;span&gt;&lt;strong&gt;findAdvisorsThatCanApply&lt;/strong&gt;&lt;/span&gt;方法，分别用于找出BeanFactory中所有的可用的增强器，和从可用增强器中找出作用于目标类的增强器。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码12-来自：AbstractAdvisorAutoProxyCreator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; findCandidateAdvisors() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Assert.state(&lt;span&gt;this&lt;/span&gt;.advisorRetrievalHelper != &lt;span&gt;null&lt;/span&gt;, &quot;No BeanFactoryAdvisorRetrievalHelper available&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advisorRetrievalHelper.&lt;strong&gt;findAdvisorBeans&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;源码13-来自：BeanFactoryAdvisorRetrievalHelper&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; findAdvisorBeans() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine list of advisor bean names, if not cached already.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         String[] advisorNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             advisorNames = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cachedAdvisorBeanNames;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (advisorNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do not initialize FactoryBeans here: We need to leave all regular beans
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; uninitialized to let the auto-proxy creator apply to them!
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-获取当前BeanFactory及其继承体系中的容器中所有的Advisor类型的Bean的BeanName数组，排除掉FactoryBeans&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 advisorNames =&lt;span&gt; BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.beanFactory, Advisor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.cachedAdvisorBeanNames =&lt;span&gt; advisorNames;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (advisorNames.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; advisors = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name : advisorNames) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEligibleBean(name)) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-再排除创建中的Bean&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isCurrentlyInCreation(name)) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         logger.debug(&quot;Skipping currently created advisor '&quot; + name + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3-把剩下的Bean添加到通知（增强器）列表中&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                         advisors.add(&lt;span&gt;this&lt;/span&gt;.beanFactory.getBean(name, Advisor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanCreationException ex) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         Throwable rootCause =&lt;span&gt; ex.getMostSpecificCause();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (rootCause &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                             BeanCreationException bce =&lt;span&gt; (BeanCreationException) rootCause;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                             String bceBeanName =&lt;span&gt; bce.getBeanName();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (bceBeanName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.isCurrentlyInCreation(bceBeanName)) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                                     logger.debug(&quot;Skipping advisor '&quot; + name +
&lt;span&gt;41&lt;/span&gt;                                             &quot;' with dependency on currently created bean: &quot; +&lt;span&gt; ex.getMessage());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ignore: indicates a reference back to the bean we're trying to advise.
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We want to find advisors other than the currently created bean itself.&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; advisors;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这段源码看起来挺复杂，我们去掉一些不必要的内容，总结起来，总共三件事：&lt;/p&gt;
&lt;p&gt;　　　　1-获取容器中所有的Advisor，排除FactoryBeans&lt;/p&gt;
&lt;p&gt;　　　　2-再排除创建中的Bean&lt;/p&gt;
&lt;p&gt;　　　　3-将剩余的Advisor通过getBean创建Bean实例并添加到列表中返回&lt;/p&gt;
&lt;p&gt;　　至于再下一步的逻辑就不再探寻啦。&lt;/p&gt;
&lt;p&gt;　　然后是源码11中的2-&lt;span&gt;findAdvisorsThatCanApply&lt;/span&gt;方法&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码14-来自：AbstractAdvisorAutoProxyCreator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Advisor&amp;gt;&lt;span&gt; findAdvisorsThatCanApply(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;// &lt;/span&gt;&lt;span&gt;将代理的目标Bean的beanName设置到ThreadLocal中&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        ProxyCreationContext.setCurrentProxiedBeanName(beanName);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;// 1-&lt;/span&gt;&lt;span&gt;在候选增强器中找出可作用于目标Bean的增强器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             ProxyCreationContext.setCurrentProxiedBeanName(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重点操作就是&lt;span&gt;AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);用于找出能作用于目标Bean的增强器列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;源码15-来自：AopUtils&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Advisor&amp;gt; findAdvisorsThatCanApply(List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (candidateAdvisors.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; candidateAdvisors;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         List&amp;lt;Advisor&amp;gt; eligibleAdvisors = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Advisor candidate : candidateAdvisors) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt; IntroductionAdvisor &amp;amp;&amp;amp;&lt;span&gt;&lt;strong&gt; canApply&lt;/strong&gt;(candidate, clazz)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-首先添加引介增强&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                eligibleAdvisors.add(candidate);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; hasIntroductions = !&lt;span&gt;eligibleAdvisors.isEmpty();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Advisor candidate : candidateAdvisors) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAdvisor) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; already processed
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过引介增强&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验其余增强器是否能应用到目标Bean&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;strong&gt;canApply&lt;/strong&gt;(candidate, clazz, hasIntroductions)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-添加通知增强&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                eligibleAdvisors.add(candidate);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; eligibleAdvisors;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码中可以看出来，这里针对了两种类型的增强器（引介增强和通知增强）分别进行了处理，首先处理了引介增强，然后是通知增强。&lt;/p&gt;
&lt;p&gt;　　这里有两个canApply方法，第一个用于判断引介增强是否能作用到目标类，第二个用于判断通知增强是否能作用到目标类。&lt;/p&gt;
&lt;p&gt;　　其实第一个是通过调用第二个实现的。&lt;/p&gt;
&lt;p&gt;　　我觉得我们可以简单看看其实现逻辑：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码16-来源：AopUtils&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于校验引介增强&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canApply(Advisor advisor, Class&amp;lt;?&amp;gt;&lt;span&gt; targetClass) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;strong&gt;canApply&lt;/strong&gt;(advisor, targetClass, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于校验通知增强&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canApply(Advisor advisor, Class&amp;lt;?&amp;gt; targetClass, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasIntroductions) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (advisor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAdvisor) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((IntroductionAdvisor) advisor).getClassFilter().&lt;strong&gt;matches&lt;/strong&gt;(targetClass);&lt;span&gt;// 针对引介增强的类级匹配校验&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (advisor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; PointcutAdvisor) {
            PointcutAdvisor pca &lt;/span&gt;=&lt;span&gt; (PointcutAdvisor) advisor;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;strong&gt; canApply&lt;/strong&gt;(pca.getPointcut(), targetClass, hasIntroductions);&lt;span&gt;&lt;span&gt;// 针对通知增强的匹配校验&lt;/span&gt;&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It doesn't have a pointcut so we assume it applies.&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
&lt;br/&gt;&lt;span&gt;&lt;span&gt;// &lt;span&gt;&lt;span&gt;&lt;span&gt;针对通知增强的匹配校验&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canApply(Pointcut pc, Class&amp;lt;?&amp;gt; targetClass, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasIntroductions) {
        Assert.notNull(pc, &lt;/span&gt;&quot;Pointcut must not be null&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pc.getClassFilter().matches(targetClass)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 针对通知增强的类级匹配校验，如果类级校验不通过，直接驳回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
        }
　　　　 
        MethodMatcher methodMatcher &lt;/span&gt;=&lt;span&gt; pc.getMethodMatcher();&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 获取方法匹配器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodMatcher ==&lt;span&gt; MethodMatcher.TRUE) {&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 获取方法匹配器匹配的是所有方法，这里直接返回true，不必要做校验&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; No need to iterate the methods if we're matching any method anyway...&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        IntroductionAwareMethodMatcher introductionAwareMethodMatcher &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodMatcher &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IntroductionAwareMethodMatcher) {
            introductionAwareMethodMatcher &lt;/span&gt;=&lt;span&gt; (IntroductionAwareMethodMatcher) methodMatcher;
        }

        Set&lt;/span&gt;&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Proxy.isProxyClass(targetClass)) {
            classes.add(ClassUtils.getUserClass(targetClass));
        }
        classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; clazz : classes) {
            Method[] methods &lt;/span&gt;=&lt;span&gt; ReflectionUtils.getAllDeclaredMethods(clazz);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (introductionAwareMethodMatcher != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt;
                        introductionAwareMethodMatcher.&lt;strong&gt;matches&lt;/strong&gt;(method, targetClass, hasIntroductions) :
                        methodMatcher.&lt;strong&gt;matches&lt;/strong&gt;(method, targetClass)) {&lt;br/&gt;　　　　　　　　　　　　&lt;span&gt;// 方法匹配校验
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的源码中用于判断增强是否与给定的类匹配，用了多个matches方法，包括ClassFilter的matches方法，IntroductionAwareMethodMatcher的matches方法和MethodMatcher中的matches方法。&lt;/p&gt;
&lt;p&gt;　　第一个matches匹配的是类，第二、三个matches匹配的是方法。其中引介增强针对的是类，所以其校验仅仅使用类级匹配进行校验，但是通知增强针对的是类中的方法，需要进行类和方法的双重匹配校验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;然后返回到源码9中，我们开始生成代理：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码17-来自：AbstractAutoProxyCreator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Object createProxy(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, @Nullable String beanName,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            @Nullable Object[] specificInterceptors, TargetSource targetSource) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.beanFactory &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConfigurableListableBeanFactory) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;暴露目标类，将其保存到BeanDefinition中&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory, beanName, beanClass);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个新的代理工厂，并为其拷贝当前类中的相关配置属性&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         ProxyFactory proxyFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyFactory();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         proxyFactory.copyFrom(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;proxyFactory.isProxyTargetClass()) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验proxyTargetClass设置，如果设置不是直接代理目标类，则采用默认的JDK动态代理指定接口&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldProxyTargetClass(beanClass, beanName)) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验该Bean的BeanDefinition中的preserveTargetClass属性，是否被代理工厂设置为true，如果设置为true，则表示代理工厂希望代理类可以强转为目标类&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 proxyFactory.setProxyTargetClass(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则表示基于接口创建代理&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                evaluateProxyInterfaces(beanClass, proxyFactory);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将拦截器封装成通知&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         Advisor[] advisors =&lt;span&gt; buildAdvisors(beanName, specificInterceptors);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         proxyFactory.addAdvisors(advisors);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入增强器&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         proxyFactory.setTargetSource(targetSource);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要代理的类&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         customizeProxyFactory(proxyFactory);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类定制代理
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于控制代理工厂被配置之后，是否还允许修改通知，默认为false（表示不允许修改）&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         proxyFactory.setFrozen(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.freezeProxy);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (advisorsPreFiltered()) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             proxyFactory.setPreFiltered(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxyFactory.&lt;strong&gt;getProxy&lt;/strong&gt;(getProxyClassLoader());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码中执行了一大串的工作，都在为最后的创建代理做准备：&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;源码18-来自：ProxyFactory&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy(@Nullable ClassLoader classLoader) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建AOP代理，并获取代理对象&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;strong&gt; createAopProxy&lt;/strong&gt;().&lt;strong&gt;getProxy&lt;/strong&gt;(classLoader);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;源码19-来自：ProxyCreatorSupport&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; AopProxy createAopProxy() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.active) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;strong&gt;activate&lt;/strong&gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;激活开关&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取AOP代理工厂，使用AOP代理工厂创建AOP代理&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;strong&gt;getAopProxyFactory&lt;/strong&gt;().&lt;strong&gt;createAopProxy&lt;/strong&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; activate() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.active = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调监听器的activated方法&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (AdvisedSupportListener listener : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.listeners) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             listener.activated(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AopProxyFactory getAopProxyFactory() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aopProxyFactory;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重点在createAopProxy方法：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码20-来自：DefaultAopProxyFactory&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; AopProxy createAopProxy(AdvisedSupport config) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AopConfigException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (config.isOptimize() || config.isProxyTargetClass() ||&lt;span&gt; hasNoUserSuppliedProxyInterfaces(config)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果代理需要执行优化或者proxyTargetClass=true或者不存在代理接口&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             Class&amp;lt;?&amp;gt; targetClass =&lt;span&gt; config.getTargetClass();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (targetClass == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
&lt;span&gt; 8&lt;/span&gt;                         &quot;Either an interface or a target is required for proxy creation.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (targetClass.isInterface() ||&lt;span&gt; Proxy.isProxyClass(targetClass)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果目标类是接口或者是动态生成的代理类，则使用JDK动态代理&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkDynamicAopProxy(config);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建CGLIB动态AOP代理对象&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjenesisCglibAopProxy(config);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建JDK动态AOP代理对象&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkDynamicAopProxy(config);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，代理对象生成，至于是使用JDK动态代理，还是Cglib动态代理，机理如下：&lt;/p&gt;
&lt;p&gt;　　　　如果目标类实现了接口，默认使用JDK动态代理&lt;/p&gt;
&lt;p&gt;　　　　如果目标类实现了接口，可以强制使用Cglib动态代理&lt;/p&gt;
&lt;p&gt;　　　　如果目标没有实现接口，必须采用Cglib动态代理&lt;/p&gt;
&lt;p&gt;　　至于如何强制使用Cglib动态代理：&lt;/p&gt;
&lt;p&gt;　　　　首先需要添加CGLIB库，然后设置proxyTargetClass置为true，进行强制使用基于类的CGLIB动态代理。&lt;/p&gt;
&lt;p&gt;　　JDK动态代理和Cglib动态代理的区别：&lt;/p&gt;
&lt;p&gt;　　　　JDK动态代理只能基于接口生成代理，方式是通过实现JDK提供的InvocationHandler接口中的invoke方法来实现针对目标类指定方法的代理调用。&lt;/p&gt;
&lt;p&gt;　　　　CGLIB可以基于类生成代理，方式是通过对目标类生成一个子类，覆盖其中的方法。&lt;/p&gt;
&lt;p&gt; 　　返回到源码18中，创建了AOP代理之后，执行其getProxy方法：（我们看下JDK动态代理的实现）&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码21-来自：JdkDynamicAopProxy&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy(@Nullable ClassLoader classLoader) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.getTargetSource());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-获取用于代理的全部接口的集合（数组）&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         Class&amp;lt;?&amp;gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(&lt;span&gt;this&lt;/span&gt;.advised, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-查找接口集合中可能定义的equals方法获取hashCode方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3-创建指定接口的代理实例&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(classLoader, proxiedInterfaces, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代理主要做了三件事情：&lt;/p&gt;
&lt;p&gt;　　　　1-首先获取用于代理的全部接口集；&lt;/p&gt;
&lt;p&gt;　　　　2-然后查找该接口集中有无定义equals和hashCode方法；&lt;/p&gt;
&lt;p&gt;　　　　3-最后执行代理实例的创建。&lt;/p&gt;
&lt;p&gt;　　首先看下第一件事情：completeProxiedInterfaces&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码22-来自：AopProxyUtils&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取用于代理的接口的集合&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; Class&amp;lt;?&amp;gt;[] completeProxiedInterfaces(AdvisedSupport advised, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; decoratingProxy) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取配置中所有的接口&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         Class&amp;lt;?&amp;gt;[] specifiedInterfaces =&lt;span&gt; advised.getProxiedInterfaces();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (specifiedInterfaces.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No user-specified interfaces: check whether target class is an interface.&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             Class&amp;lt;?&amp;gt; targetClass =&lt;span&gt; advised.getTargetClass();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (targetClass != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (targetClass.isInterface()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    advised.setInterfaces(targetClass);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Proxy.isProxyClass(targetClass)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    advised.setInterfaces(targetClass.getInterfaces());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 specifiedInterfaces =&lt;span&gt; advised.getProxiedInterfaces();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将SpringProxy、Advised、DecoratingProxy三个接口添加到接口集中&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; addSpringProxy = !advised.isInterfaceProxied(SpringProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; addAdvised = !advised.isOpaque() &amp;amp;&amp;amp; !advised.isInterfaceProxied(Advised.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; addDecoratingProxy = (decoratingProxy &amp;amp;&amp;amp; !advised.isInterfaceProxied(DecoratingProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; nonUserIfcCount = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (addSpringProxy) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             nonUserIfcCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (addAdvised) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             nonUserIfcCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (addDecoratingProxy) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             nonUserIfcCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         Class&amp;lt;?&amp;gt;[] proxiedInterfaces = &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[specifiedInterfaces.length +&lt;span&gt; nonUserIfcCount];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0&lt;span&gt;, specifiedInterfaces.length);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; specifiedInterfaces.length;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (addSpringProxy) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             proxiedInterfaces[index] = SpringProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             index++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (addAdvised) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             proxiedInterfaces[index] = Advised.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             index++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (addDecoratingProxy) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             proxiedInterfaces[index] = DecoratingProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxiedInterfaces;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面我们再看看之前的第二步：findDefinedEqualsAndHashCodeMethods&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码23-来自：JdkDynamicAopProxy&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; findDefinedEqualsAndHashCodeMethods(Class&amp;lt;?&amp;gt;&lt;span&gt;[] proxiedInterfaces) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; proxiedInterface : proxiedInterfaces) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             Method[] methods =&lt;span&gt; proxiedInterface.getDeclaredMethods();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历每一个接口，再获取其中的方法进行遍历，逐个校验其是否是equals方法，或者hashCode方法，只有当二者都被定义之后校验才会结束，否则一直进行下去&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (AopUtils.isEqualsMethod(method)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.equalsDefined = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (AopUtils.isHashCodeMethod(method)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.hashCodeDefined = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.equalsDefined &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hashCodeDefined) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后就是我们的重点步骤：Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)，这个操作大家都不会陌生，这是JDK动态代理创建代理类的通用方式。这个方法的参数列表中最后一个是一个大家都很熟悉的家伙：InvocationHandler，我们都知道JDK动态代理的执行逻辑都是在一个实现了InvocationHandler接口中的invoke方法中，这里传入this，表示当前实例，代表当前实例所属类应该实现了InvocationHandler接口，之前已经成功创建了JDK动态代理对象，那么当我们发生对指定目标方法的调用时，就会触发JdkDynamicAopProxy中的invoke方法：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码24-来自：JdkDynamicAopProxy&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JdkDynamicAopProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AopProxy, &lt;strong&gt;&lt;span&gt;InvocationHandler&lt;/span&gt;&lt;/strong&gt;, Serializable {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这也就是说，这个类中必然实现了invoke方法：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码25-来自：JdkDynamicAopProxy&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        MethodInvocation invocation;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Object oldProxy = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; setProxyContext = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         TargetSource targetSource = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.targetSource;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Object target = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.equalsDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isEqualsMethod(method)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The target does not implement the equals(Object) method itself.
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标类体系中未实现equals方法，但是代理的目标方法却是equals方法&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; equals(args[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.hashCodeDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isHashCodeMethod(method)) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The target does not implement the hashCode() method itself.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标类体系中未实现hashCode方法，但是代理的目标方法却是hashCode方法&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashCode();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (method.getDeclaringClass() == DecoratingProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is only getDecoratedClass() declared -&amp;gt; dispatch to proxy config.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; AopProxyUtils.ultimateTargetClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; isAssignableFrom方法的意义：调用方如果是参数方的同类（接口）或者父类（接口），则返回true&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.advised.opaque &amp;amp;&amp;amp; method.getDeclaringClass().isInterface() &amp;amp;&amp;amp;
&lt;span&gt;28&lt;/span&gt;                     method.getDeclaringClass().isAssignableFrom(Advised.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Service invocations on ProxyConfig with the proxy config...
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接反射调用目标方法&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; AopUtils.invokeJoinpointUsingReflection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised, method, args);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            Object retVal;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.exposeProxy) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make invocation available if necessary.
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果设置了exposeProxy=true，那么就代理保存起来备用&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                 oldProxy =&lt;span&gt; AopContext.setCurrentProxy(proxy);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 setProxyContext = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get as late as possible to minimize the time we &quot;own&quot; the target,
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; in case it comes from a pool.&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             target =&lt;span&gt; targetSource.getTarget();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             Class&amp;lt;?&amp;gt; targetClass = (target != &lt;span&gt;null&lt;/span&gt; ? target.getClass() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the interception chain for this method.
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-获取目标方法的拦截链&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             List&amp;lt;Object&amp;gt; chain = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check whether we have any advice. If we don't, we can fallback on direct
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reflective invocation of the target, and avoid creating a MethodInvocation.&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (chain.isEmpty()) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We can skip creating a MethodInvocation: just invoke the target directly
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note that the final invoker must be an InvokerInterceptor so we know it does
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果目标类没有拦截器链，则直接反射调用目标方法&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;                 Object[] argsToUse =&lt;span&gt; AopProxyUtils.adaptArgumentsIfNecessary(method, args);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 retVal =&lt;span&gt; AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We need to create a method invocation...
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-创建一个方法调用，并执行，ReflectiveMethodInvocation是Spring封装的&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;                 invocation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Proceed to the joinpoint through the interceptor chain.
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3-执行拦截器链，在ReflectiveMethodInvocation中维护了拦截器调用的计数器，保证拦截器的逐个调用，完成所有拦截器调用之后会反射调用目标方法。&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;                 retVal =&lt;span&gt; invocation.proceed();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Massage return value if necessary.&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;             Class&amp;lt;?&amp;gt; returnType =&lt;span&gt; method.getReturnType();
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (retVal != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp;
&lt;span&gt;74&lt;/span&gt;                     returnType != Object.&lt;span&gt;class&lt;/span&gt; &amp;amp;&amp;amp; returnType.isInstance(proxy) &amp;amp;&amp;amp;
&lt;span&gt;75&lt;/span&gt;                     !RawTargetAccess.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(method.getDeclaringClass())) {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Special case: it returned &quot;this&quot; and the return type of the method
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; is type-compatible. Note that we can't help if the target sets
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a reference to itself in another returned object.&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt;                 retVal =&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (retVal == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; returnType != Void.TYPE &amp;amp;&amp;amp;&lt;span&gt; returnType.isPrimitive()) {
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AopInvocationException(
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                         &quot;Null return value from advice does not match primitive return type for: &quot; +&lt;span&gt; method);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retVal;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (target != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;targetSource.isStatic()) {
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must have come from TargetSource.&lt;/span&gt;
&lt;span&gt;90&lt;/span&gt; &lt;span&gt;                targetSource.releaseTarget(target);
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setProxyContext) {
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Restore old proxy.&lt;/span&gt;
&lt;span&gt;94&lt;/span&gt; &lt;span&gt;                AopContext.setCurrentProxy(oldProxy);
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;97&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的源码并非发现织入的痕迹，让我们接着看看ReflectiveMethodInvocation类的proceed方法：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码26-来自：ReflectiveMethodInvocation&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object proceed() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We start with an index of -1 and increment early.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完成所有增强之后执行目标切点方法&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.currentInterceptorIndex == &lt;span&gt;this&lt;/span&gt;.interceptorsAndDynamicMethodMatchers.size() - 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接调用目标方法&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invokeJoinpoint();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取下一个要执行的拦截器&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         Object interceptorOrInterceptionAdvice =
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.interceptorsAndDynamicMethodMatchers.get(++&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentInterceptorIndex);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (interceptorOrInterceptionAdvice &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; InterceptorAndDynamicMethodMatcher) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Evaluate dynamic method matcher here: static part will already have
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; been evaluated and found to match.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             InterceptorAndDynamicMethodMatcher dm =
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (dm.methodMatcher.matches(&lt;span&gt;this&lt;/span&gt;.method, &lt;span&gt;this&lt;/span&gt;.targetClass, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.arguments)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态匹配成功，则执行拦截器逻辑&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; dm.interceptor.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dynamic matching failed.
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Skip this interceptor and invoke the next in the chain.
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态匹配失败，跳过当前拦截器，递归执行下一个拦截器&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceed();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's an interceptor, so we just invoke it: The pointcut will have
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; been evaluated statically before this object was constructed.
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 普通的拦截器，直接调用即可&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　拦截器的调用执行invoke方法，并将this（当前实例）作为参数，来保证调用链的顺利执行，具体的逻辑那就在每个拦截器的invoke方法之中了，执行完拦截器的逻辑之后，就可以执行目标方法的逻辑了。&lt;/p&gt;
&lt;p&gt;　　这正是织入的实现。&lt;/p&gt;
&lt;p&gt;　　我们从织入的逻辑中并未发现有对拦截器执行顺序进行控制的逻辑，那么那些前置、后置、环绕、异常等的执行位置是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、织入实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　虽然在ReflectiveMethodInvocation的proceed方法中看到目标方法是最后才被执行，那么那些后置、环绕、异常的通知是怎么实现的呢，如果我们打开各种通知实现的invoke方法中，就会发现一些东西：&lt;/p&gt;
&lt;p&gt;　　我们查看五种通知后发现&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码27-来自：AspectJAfterReturningAdvice、AspectJAfterAdvice、AspectJAroundAdvice、AspectJMethodBeforeAdvice、AspectJAfterThrowingAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;// &lt;/span&gt;&lt;span&gt;AspectJAfterReturningAdvice：后置通知&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldInvokeOnReturnValueOf(method, returnValue)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             invokeAdviceMethod(getJoinPointMatch(), returnValue, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;// &lt;/span&gt;&lt;span&gt;AspectJAfterAdvice：后置终点通知&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(MethodInvocation mi) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mi.proceed();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             invokeAdviceMethod(getJoinPointMatch(), &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;// &lt;/span&gt;&lt;span&gt;AspectJAroundAdvice：环绕通知&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(MethodInvocation mi) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(mi &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ProxyMethodInvocation)) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot; +&lt;span&gt; mi);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         ProxyMethodInvocation pmi =&lt;span&gt; (ProxyMethodInvocation) mi;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         ProceedingJoinPoint pjp =&lt;span&gt; lazyGetProceedingJoinPoint(pmi);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         JoinPointMatch jpm =&lt;span&gt; getJoinPointMatch(pmi);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; invokeAdviceMethod(pjp, jpm, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;// &lt;/span&gt;&lt;span&gt;AspectJMethodBeforeAdvice：前置通知&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; before(Method method, Object[] args, @Nullable Object target) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         invokeAdviceMethod(getJoinPointMatch(), &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;// &lt;/span&gt;&lt;span&gt;AspectJAfterThrowingAdvice：异常通知&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(MethodInvocation mi) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mi.proceed();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldInvokeOnThrowing(ex)) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 invokeAdviceMethod(getJoinPointMatch(), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们发现这五个通知里面的invoke方法中都调用了&lt;strong&gt;invokeAdviceMethod&lt;/strong&gt;方法，这个方法是在AbstractAspectJAdvice抽象类中定义的。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码28-来自：AbstractAspectJAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object invokeAdviceMethod(
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;            @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        &lt;span&gt; // 执行参数绑定，然后使用参数调用通知方法&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;strong&gt; invokeAdviceMethodWithGivenArgs&lt;/strong&gt;(&lt;strong&gt;argBinding&lt;/strong&gt;(&lt;strong&gt;getJoinPoint&lt;/strong&gt;(), jpMatch, returnValue, ex));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此处有三个方法调用：&lt;/p&gt;
&lt;p&gt;　　　　getJoinPoint方法，用户获取当前的连接点实例&lt;/p&gt;
&lt;p&gt;　　　　argBinging方法，用于进行参数绑定操作&lt;/p&gt;
&lt;p&gt;　　　　invokeAdviceMethodWithGivenArgs方法执行通知方法&lt;/p&gt;
&lt;p&gt;　　首先看看getJointPoint方法：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码29-来自：AbstractAspectJAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; JoinPoint getJoinPoint() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前的连接点实例&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;strong&gt; currentJoinPoint&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; JoinPoint currentJoinPoint() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先尝试从ExposeInvocationInterceptor拦截器中获取当前的方法调用&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         MethodInvocation mi =&lt;span&gt; ExposeInvocationInterceptor.currentInvocation();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(mi &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ProxyMethodInvocation)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot; +&lt;span&gt; mi);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         ProxyMethodInvocation pmi =&lt;span&gt; (ProxyMethodInvocation) mi;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后从方法调用之中获取连接点实例jp&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         JoinPoint jp =&lt;span&gt; (JoinPoint) pmi.getUserAttribute(JOIN_POINT_KEY);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (jp == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果未获取到连接点实例，并设置到方法调用之中&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             jp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodInvocationProceedingJoinPoint(pmi);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            pmi.setUserAttribute(JOIN_POINT_KEY, jp);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; jp;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面逻辑很简单，就是从方法调用上下文中获取连接点，并返回，需要注意的是，此处一般情况是需要走if(jp == null)中的逻辑的，意思就是这里一般会是首次为方法调用设置连接点的地方，这也正是懒实例化的实现-在真正需要使用的时候才进行创建。&lt;/p&gt;
&lt;p&gt;　　下面看看源码28中第二个方法：参数绑定&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　源码30-来自：AbstractAspectJAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            @Nullable Object returnValue, @Nullable Throwable ex) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提前估测参数绑定
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后就是将所有通知中候选的参数的名称和类型保存到了切点对应属性之中备用&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&lt;strong&gt;        calculateArgumentBindings&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AMC start&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         Object[] adviceInvocationArgs = &lt;span&gt;new&lt;/span&gt; Object[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parameterTypes.length];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; numBound = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.joinPointArgumentIndex != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             adviceInvocationArgs[&lt;span&gt;this&lt;/span&gt;.joinPointArgumentIndex] =&lt;span&gt; jp;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             numBound++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.joinPointStaticPartArgumentIndex != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             adviceInvocationArgs[&lt;span&gt;this&lt;/span&gt;.joinPointStaticPartArgumentIndex] =&lt;span&gt; jp.getStaticPart();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             numBound++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!CollectionUtils.isEmpty(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.argumentBindings)) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; binding from pointcut match
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-通过切点匹配进行参数绑定&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (jpMatch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 PointcutParameter[] parameterBindings =&lt;span&gt; jpMatch.getParameterBindings();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (PointcutParameter parameter : parameterBindings) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     String name =&lt;span&gt; parameter.getName();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     Integer index = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.argumentBindings.get(name);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     adviceInvocationArgs[index] =&lt;span&gt; parameter.getBinding();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     numBound++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; binding from returning clause
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-通过返回名称进行参数绑定&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.returningName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 Integer index = &lt;span&gt;this&lt;/span&gt;.argumentBindings.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returningName);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 adviceInvocationArgs[index] =&lt;span&gt; returnValue;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 numBound++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; binding from thrown exception
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3-通过异常返回进行参数绑定&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.throwingName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 Integer index = &lt;span&gt;this&lt;/span&gt;.argumentBindings.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.throwingName);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 adviceInvocationArgs[index] =&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 numBound++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (numBound != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parameterTypes.length) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Required to bind &quot; + &lt;span&gt;this&lt;/span&gt;.parameterTypes.length +
&lt;span&gt;51&lt;/span&gt;                     &quot; arguments, but only bound &quot; + numBound + &quot; (JoinPointMatch &quot; +
&lt;span&gt;52&lt;/span&gt;                     (jpMatch == &lt;span&gt;null&lt;/span&gt; ? &quot;was NOT&quot; : &quot;WAS&quot;) + &quot; bound in invocation)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里会将通知方法中的所有参数进行绑定，因为他们都是候选者，除了一些特殊的不需绑定的之外（只三种切点类型）&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; adviceInvocationArgs;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数绑定的重点在于第一步，估测参数绑定，这一步会将&lt;span&gt;所有通知中候选的参数的名称和类型保存到了切点对应属性之中备用，我们来看看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;源码31-来自AbstractAspectJAdvice&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; calculateArgumentBindings() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The simple case... nothing to bind.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.argumentsIntrospected || &lt;span&gt;this&lt;/span&gt;.parameterTypes.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无参可绑的情况，直接返回&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取参数类型的数量numUnboundArgs（未绑参数数量）&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; numUnboundArgs = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parameterTypes.length;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Class&amp;lt;?&amp;gt;[] parameterTypes = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod.getParameterTypes();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 排除parameterTypes中JoinPoint类型、ProceedingJoinPoint类型、JoinPoint.StaticPart类型的参数
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JoinPoint类型的参数可作为非环绕通知的首个参数
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ProceedingJoinPoint类型的参数可作为环绕通知的首个参数
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JoinPoint.StaticPart类型的参数也可以作为某些通知的首个参数
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 谨记，以上三种类型的参数只能作为对应通知的首个参数，当然也可以和其他参数共存，但位置必须位于首个，原因也很简单，因为此处判断的时候完全就是在拿首个参数类型来完成的。
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这三个参数是可以直接使用的，无需进行参数绑定操作，所以在这里排除掉&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (maybeBindJoinPoint(parameterTypes[0]) || maybeBindProceedingJoinPoint(parameterTypes[0]) ||
&lt;span&gt;18&lt;/span&gt;                 maybeBindJoinPointStaticPart(parameterTypes[0&lt;span&gt;])) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上述三种参数不需要绑定&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             numUnboundArgs--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (numUnboundArgs &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; need to bind arguments by name as returned from the pointcut match
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 排除以上类型之后，如果还有剩余，则需要根据从切入点匹配返回的名称绑定参数
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们要明白：切点表达式完全就是用来匹配用的，哪怕其中有参数，也是为了匹配指定参数用的，他不带有任何传参功能，传参功能只有通知方法才有
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以这里的剩余参数个数，其实就是通知方法剩余参数，这里是依据参数名称来进行参数绑定&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;&lt;strong&gt;            bindArgumentsByName&lt;/strong&gt;(numUnboundArgs);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.argumentsIntrospected = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个方法中主要就是排除了三大类位于首位的切点参数类型，这三类型参数不需要进行绑定。然后对剩余的参数进行绑定操作：&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　源码32-来自AbstractAspectJAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过name来绑定参数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bindArgumentsByName(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numArgumentsExpectingToBind) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.argumentNames == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建参数名称发现器，并获取指定通知方法的参数名称&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.argumentNames = &lt;strong&gt;createParameterNameDiscoverer&lt;/strong&gt;().&lt;strong&gt;getParameterNames&lt;/strong&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.argumentNames != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We have been able to determine the arg names.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只要确认通知使用有参数的就行&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&lt;strong&gt;            bindExplicitArguments&lt;/strong&gt;(numArgumentsExpectingToBind);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Advice method [&quot; + &lt;span&gt;this&lt;/span&gt;.aspectJAdviceMethod.getName() + &quot;] &quot; +
&lt;span&gt;14&lt;/span&gt;                     &quot;requires &quot; + numArgumentsExpectingToBind + &quot; arguments to be bound by name, but &quot; +
&lt;span&gt;15&lt;/span&gt;                     &quot;the argument names were not specified and could not be discovered.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这一步，我们需要先创建参数名称发现器，然后发现器来获取当前通知方法的参数名的数组argumentNames。&lt;/p&gt;
&lt;p&gt;　　这个数组的作用仅仅是用来判空，只要其有值，即通知方法有参数，那么就需要执行绑定操作。&lt;/p&gt;
&lt;p&gt;　　首先来看看创建发现器的源码：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码33-来自AbstractAspectJAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ParameterNameDiscoverer createParameterNameDiscoverer() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We need to discover them, or if that fails, guess,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; and if we can't guess with 100% accuracy, fail.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DefaultParameterNameDiscoverer是参数名称发现器的默认实现，他其实是一个&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         DefaultParameterNameDiscoverer discoverer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultParameterNameDiscoverer();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         AspectJAdviceParameterNameDiscoverer adviceParameterNameDiscoverer =
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; AspectJAdviceParameterNameDiscoverer(&lt;span&gt;this&lt;/span&gt;.pointcut.getExpression());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 切点的表达式
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果返回通知后绑定返回值，则returningName为非null&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         adviceParameterNameDiscoverer.setReturningName(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returningName);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果在抛出通知后绑定了抛出的值，则throwingName为非null&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         adviceParameterNameDiscoverer.setThrowingName(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.throwingName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Last in chain, so if we're called and we fail, that's bad...
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置在未能推导出通知参数名称的情况下是否抛出IllegalArgumentException和AmbiguousBindingException异常&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         adviceParameterNameDiscoverer.setRaiseExceptions(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将配置好的发现器添加到DefaultParameterNameDiscoverer中并返回&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        discoverer.addDiscoverer(adviceParameterNameDiscoverer);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; discoverer;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码中AspectJAdviceParameterNameDiscoverer为真正执行发现操作的发现器。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;源码34-来自AspectJAdviceParameterNameDiscoverer&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    @Nullable
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] getParameterNames(Method method) {
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数类型&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.argumentTypes =&lt;span&gt; method.getParameterTypes();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化未绑定参数个数&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.numberOfRemainingUnboundArguments = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.argumentTypes.length;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化已绑定参数名称数组&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.parameterNameBindings = &lt;span&gt;new&lt;/span&gt; String[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.numberOfRemainingUnboundArguments];
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; minimumNumberUnboundArgs = 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化最少未绑参数个数
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对后置通知和异常通知进行特殊处理，需要将返回值进行绑定&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.returningName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果通知类型为后置通知&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;             minimumNumberUnboundArgs++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.throwingName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果通知类型为异常通知&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;             minimumNumberUnboundArgs++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.numberOfRemainingUnboundArguments &amp;lt;&lt;span&gt; minimumNumberUnboundArgs) {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                     &quot;Not enough arguments in method to satisfy binding of returning and throwing variables&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分成八步进行操作&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; algorithmicStep =&lt;span&gt; STEP_JOIN_POINT_BINDING;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((&lt;span&gt;this&lt;/span&gt;.numberOfRemainingUnboundArguments &amp;gt; 0) &amp;amp;&amp;amp; algorithmicStep &amp;lt;&lt;span&gt; STEP_FINISHED) {
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt; (algorithmicStep++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; STEP_JOIN_POINT_BINDING:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1-连接点参数绑定
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接点参数绑定格式为：thisJoinPoint -&amp;gt; 0&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;&lt;strong&gt;maybeBindThisJoinPoint&lt;/strong&gt;()) {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接点参数绑定格式为：thisJoinPointStaticPart -&amp;gt; 0&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;&lt;strong&gt;                            maybeBindThisJoinPointStaticPart&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; STEP_THROWING_BINDING:
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2-异常返回参数绑定
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常参数绑定格式为：throwingName -&amp;gt; throwableIndex
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; throwableIndex为通知参数列表中接收异常的参数的位置&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;&lt;strong&gt;                        maybeBindThrowingVariable&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; STEP_ANNOTATION_BINDING:
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3-注解参数绑定
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 格式：varName -&amp;gt; annotationIndex&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;&lt;strong&gt;                        maybeBindAnnotationsFromPointcutExpression&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; STEP_RETURNING_BINDING:
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4-返回参数绑定
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定返回值时，只有在未绑定参数只剩余1个的情况下才能绑定，否则不予绑定
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当只剩余一个未绑定的情况下，将返回值与剩余的那个位置的下标进行绑定即可&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;&lt;strong&gt;                        maybeBindReturningVariable&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; STEP_PRIMITIVE_ARGS_BINDING:
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5-原始类型参数绑定
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有在有1个原始类型参数，且只有一个候选位置时才执行绑定操作&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;&lt;strong&gt;                        maybeBindPrimitiveArgsFromPointcutExpression&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; STEP_THIS_TARGET_ARGS_BINDING:
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6-切点表达式参数绑定
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有只存在一个变量名称的时候才能执行绑定&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;&lt;strong&gt;                        maybeBindThisOrTargetOrArgsFromPointcutExpression&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; STEP_REFERENCE_PCUT_BINDING:
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7-引用切点绑定
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有只存在一个变量名称的时候才能执行绑定&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;&lt;strong&gt;                        maybeBindReferencePointcutParameter&lt;/strong&gt;();
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Unknown algorithmic step: &quot; + (algorithmicStep - 1&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AmbiguousBindingException ambigEx) {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.raiseExceptions) {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ambigEx;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException ex) {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.raiseExceptions) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.numberOfRemainingUnboundArguments == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parameterNameBindings;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.raiseExceptions) {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Failed to bind all argument names: &quot; +
&lt;span&gt; 99&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.numberOfRemainingUnboundArguments + &quot; argument(s) could not be bound&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; convention for failing is to return null, allowing participation in a chain of responsibility&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码中针对各种情况进行了参数绑定操作，采用switch...case链式结构完成功能。虽然这一步最终目的是返回&lt;span&gt;parameterNameBindings&lt;/span&gt;值，而且在源码32中看起来只是用于判空，好像用处不大，其实大错特错，这个&lt;span&gt;parameterNameBindings&lt;/span&gt;在这里绑定完成之后，在以后会有大用，判空只是它的一个小功能罢了。&lt;/p&gt;
&lt;p&gt;　　至于针对每种参数类型的绑定逻辑就不再细究了。下面看看源码32中&lt;span&gt;&lt;strong&gt;bindExplicitArguments&lt;/strong&gt;&lt;/span&gt;方法&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;源码35-来自：AbstractAspectJAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bindExplicitArguments(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numArgumentsLeftToBind) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Assert.state(&lt;span&gt;this&lt;/span&gt;.argumentNames != &lt;span&gt;null&lt;/span&gt;, &quot;No argument names available&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.argumentBindings = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取通知方法的参数个数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; numExpectedArgumentNames = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod.getParameterCount();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.argumentNames.length !=&lt;span&gt; numExpectedArgumentNames) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数个数不匹配&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Expecting to find &quot; + numExpectedArgumentNames +
&lt;span&gt;10&lt;/span&gt;                     &quot; arguments to bind by name in advice, but actually found &quot; +
&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.argumentNames.length + &quot; arguments.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; So we match in number...
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取parameterTypes中剩余的参数偏移量，将其绑定到argumentBindings中，numArgumentsLeftToBind正是之前排除三大首位切点参数之后的剩余参数量&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; argumentIndexOffset = &lt;span&gt;this&lt;/span&gt;.parameterTypes.length -&lt;span&gt; numArgumentsLeftToBind;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = argumentIndexOffset; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.argumentNames.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数绑定的格式：name-&amp;gt; index&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.argumentBindings.put(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.argumentNames[i], i);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check that returning and throwing were in the argument names list if
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; specified, and find the discovered argument types.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.returningName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.argumentBindings.containsKey(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returningName)) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Returning argument name '&quot; + &lt;span&gt;this&lt;/span&gt;.returningName +
&lt;span&gt;27&lt;/span&gt;                         &quot;' was not bound in advice arguments&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取其对应的index值，将其另外绑定到discoveredReturningType和discoveredReturningGenericType中&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                 Integer index = &lt;span&gt;this&lt;/span&gt;.argumentBindings.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returningName);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.discoveredReturningType = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod.getParameterTypes()[index];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.discoveredReturningGenericType = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod.getGenericParameterTypes()[index];
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.throwingName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.argumentBindings.containsKey(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.throwingName)) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Throwing argument name '&quot; + &lt;span&gt;this&lt;/span&gt;.throwingName +
&lt;span&gt;39&lt;/span&gt;                         &quot;' was not bound in advice arguments&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取其对应的index值，并将其另外绑定到discoveredThrowingType中&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                 Integer index = &lt;span&gt;this&lt;/span&gt;.argumentBindings.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.throwingName);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.discoveredThrowingType = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod.getParameterTypes()[index];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; configure the pointcut expression accordingly.
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 相应地配置切入点表达式。&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;strong&gt;configurePointcutParameters&lt;/strong&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.argumentNames, argumentIndexOffset);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;源码36-来自：AbstractAspectJAdvice&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configurePointcutParameters(String[] argumentNames, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; argumentIndexOffset) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; numParametersToRemove =&lt;span&gt; argumentIndexOffset;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.returningName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             numParametersToRemove++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.throwingName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             numParametersToRemove++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前将所有要移除的参数数量累加出来，需要移除首位的三种切点参数、returningName参数和throwingName参数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩余的参数就是切点表达式中可以出现的候选参数，这里初始化一个切点参数名数组pointcutParameterNames，将这些参数囊括进来
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 另外再初始化两个数组，分别用于存放这些剩余参数的参数类型（pointcutParameterTypes）和通知方法所有参数类型（methodParameterTypes）&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         String[] pointcutParameterNames = &lt;span&gt;new&lt;/span&gt; String[argumentNames.length -&lt;span&gt; numParametersToRemove];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Class&amp;lt;?&amp;gt;[] pointcutParameterTypes = &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;[pointcutParameterNames.length];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Class&amp;lt;?&amp;gt;[] methodParameterTypes = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod.getParameterTypes();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; argumentNames.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (i &amp;lt;&lt;span&gt; argumentIndexOffset) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小于偏移量的参数为移除的三大切点类型参数&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (argumentNames[i].equals(&lt;span&gt;this&lt;/span&gt;.returningName) ||
&lt;span&gt;23&lt;/span&gt;                 argumentNames[i].equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.throwingName)) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里在对returningName和throwingName参数进行排除&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩余的就是通知中的切点表达式候选参数，将这些参数的参数名逐个保存到切点参数名数组中
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将这些参数的参数类型逐个保存到切点参数类型数组中&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             pointcutParameterNames[index] =&lt;span&gt; argumentNames[i];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             pointcutParameterTypes[index] =&lt;span&gt; methodParameterTypes[i];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             index++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后，分别将两个数组设置到切点的对应属性中&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pointcut.setParameterNames(pointcutParameterNames);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 設置参数名称&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pointcut.setParameterTypes(pointcutParameterTypes);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置参数类型&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此为止我们看到了参数绑定操作的最终结果，将除了首位三大切点类型参数、returningName参数和throwingName参数之外的通知的剩余参数都作为候选参数，将其名称和类型分别放置到一个数组中，再设置到切点之中。&lt;/p&gt;
&lt;p&gt;　　逻辑到这里我们可以回到源码30中，执行剩余的逻辑，将所有参数迁移到adviceInvocationArgs中进行绑定，绑定的逻辑还是一样，都是以数组的方式保存。&lt;/p&gt;
&lt;p&gt;　　然后再回到源码28中，执行&lt;span&gt;&lt;strong&gt;invokeAdviceMethodWithGivenArgs&lt;/strong&gt;&lt;/span&gt;方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Object invokeAdviceMethodWithGivenArgs(Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Object[] actualArgs =&lt;span&gt; args;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.aspectJAdviceMethod.getParameterCount() == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             actualArgs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             ReflectionUtils.makeAccessible(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectJAdviceMethod);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO AopUtils.invokeJoinpointUsingReflection&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.aspectJAdviceMethod.&lt;strong&gt;invoke&lt;/strong&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.aspectInstanceFactory.getAspectInstance(), actualArgs);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException ex) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AopInvocationException(&quot;Mismatch on arguments to advice method [&quot; +
&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.aspectJAdviceMethod + &quot;]; pointcut expression [&quot; +
&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.pointcut.getPointcutExpression() + &quot;]&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException ex) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex.getTargetException();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　逻辑很简单，就是依据给定的参数来反射调用通知的方法逻辑。&lt;/p&gt;
&lt;p&gt;至此我们分析完JDK动态代理实现AOP切面编程的整个逻辑。&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 04:09:00 +0000</pubDate>
<dc:creator>唯一浩哥</dc:creator>
<og:description>原创作品，可以转载，但是请标注出处地址：https://www.cnblogs.com/V1haoge/p/9560803.html 一、概述 Spring的两大特性：IOC和AOP。 AOP是面向切</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/V1haoge/p/9560803.html</dc:identifier>
</item>
</channel>
</rss>