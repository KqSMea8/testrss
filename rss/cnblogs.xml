<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自动化测试  selenium中WebDriver 和WebElement的区别 - 阿杜园区</title>
<link>http://www.cnblogs.com/dwtt/p/8509381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dwtt/p/8509381.html</guid>
<description>&lt;p&gt;之前在做UI自动化测试中 经常会用到  WebDriver  和 WebElement两个类   以前对这两个类总感觉有点傻傻分不清 &lt;/p&gt;
&lt;p&gt;昨天看了下之前下的代码  结合自己的理解  对着两个类的区别和关系整理一下（欢迎拍砖指正）   希望对这两个类同样有疑惑的同学有帮助&lt;/p&gt;
&lt;p&gt;先说Webdriver   &lt;/p&gt;
&lt;p&gt;Webdriver  我理解它是一个浏览器驱动类   封装了浏览器的操作方法 比如：&lt;/p&gt;
&lt;p&gt;浏览器的打开关闭，窗口切换，查找元素，获取当前url，获取标题，前进后退等等 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236330/201803/1236330-20180305152846259-1488979292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;WebElement  我理解它是一个元素类 封装了元素的操作方法 比如：&lt;/p&gt;
&lt;p&gt;输入框的输入，清空，按钮的点击，元素属性的获取等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236330/201803/1236330-20180305153330253-1608915814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么WebDriver  和 WebElement有什么关系呢 我们来看代码 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236330/201803/1236330-20180305153611300-991871079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里用WebElement 封装了一个定位 orderid 元素 的方法。&lt;/p&gt;
&lt;p&gt;形参传的是一个driver对象，然后通过driver提供的方法去查找这个元素  &lt;/p&gt;

&lt;p&gt;所以我们可知  如果要定位一个元素并操作这个元素，首先要用Webdriver  实例化一个driver去查找这个元素  然后用WebElement提供的方法去操作这个元素 &lt;/p&gt;

&lt;p&gt;以上就是我理解的Webdriver和Webelement的区别和关系    若有不对的地方  还请拍砖指正   &lt;/p&gt;

</description>
<pubDate>Mon, 05 Mar 2018 07:49:00 +0000</pubDate>
<dc:creator>阿杜园区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dwtt/p/8509381.html</dc:identifier>
</item>
<item>
<title>JavaScript设计模式之策略模式 - 雨霖月寒</title>
<link>http://www.cnblogs.com/jofun/p/8509336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jofun/p/8509336.html</guid>
<description>&lt;p&gt;所谓“条条道路通罗马”，在现实中，为达到某种目的往往不是只有一种方法。比如挣钱养家：可以做点小生意，可以打分工，甚至还可以是偷、抢、赌等等各种手段。在程序语言设计中，也会遇到这种类似的情况，要实现某种功能可以有多种方案选择。比如，在很多地图类软件上，你想从A地点到达B地点时，为你提供几种交通工具的选择，可以查看每种交通工具的所需费用和时间。在程序语言设计中，把这种设计模式叫做策略模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;策略模式的定义：&lt;/strong&gt;策略模式是指对一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;主要解决问题：&lt;/strong&gt;&lt;/strong&gt;在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。&lt;/p&gt;

&lt;p&gt;从上面两点可以知道，策略模式是通过定义一系列的算法，并对其进行封装，使其可以相互替换使用，目的是消除多层if...else语句嵌套的问题。这里的定义一系列的算法的意思是：你可以将每一种方案封装成函数或者是类的形式。&lt;/p&gt;
&lt;p&gt;先看个输出今天是星期几的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当天是星期几函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay(day){
&lt;/span&gt;&lt;span&gt;    if&lt;/span&gt;(day === 0&lt;span&gt;){
        console.log(&lt;/span&gt;'今天是星期日'&lt;span&gt;);
    }
                
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(day === 1&lt;span&gt;){
        console.log(&lt;/span&gt;'今天是星期一'&lt;span&gt;);
    }
                
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(day === 2&lt;span&gt;){
        console.log(&lt;/span&gt;'今天是星期二'&lt;span&gt;);
    }
                
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(day === 3&lt;span&gt;){
        console.log(&lt;/span&gt;'今天是星期三'&lt;span&gt;);
    }
                
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(day === 4&lt;span&gt;){
        console.log(&lt;/span&gt;'今天是星期四'&lt;span&gt;);
    }
                
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(day === 5&lt;span&gt;){
        console.log(&lt;/span&gt;'今天是星期五'&lt;span&gt;);
    }
                
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(day === 6&lt;span&gt;){
        console.log(&lt;/span&gt;'今天是星期六'&lt;span&gt;);
    }
};
            
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; day = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getDay();
            
getDay(day);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码完全正常，使用起来一点问题都没有，但不易于维护。用策略模式重构上面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义策略类&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Strategies = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; A(){
        console.log(&lt;/span&gt;'今天是星期一'&lt;span&gt;);
    };
                
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; B(){
        console.log(&lt;/span&gt;'今天是星期二'&lt;span&gt;);
    };
                
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; C(){
        console.log(&lt;/span&gt;'今天是星期三'&lt;span&gt;);
    };
                
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; D(){
        console.log(&lt;/span&gt;'今天是星期四'&lt;span&gt;);
    };
                
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; E(){
        console.log(&lt;/span&gt;'今天是星期五'&lt;span&gt;);
    };
                
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){
        console.log(&lt;/span&gt;'今天是星期六'&lt;span&gt;);
    };
                
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; G(){
        console.log(&lt;/span&gt;'今天是星期日'&lt;span&gt;);
    };
                
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        getDay1: A,
        getDay2: B,
        getDay3: C,
        getDay4: D,
        getDay5: E,
        getDay6: F,
        getDay0: G
    }

})();
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示当天是星期几的函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; alertWeekDay(){
&lt;/span&gt;&lt;span&gt;    var&lt;/span&gt; d = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getDay();
                
&lt;/span&gt;&lt;span&gt;    //&lt;/span&gt;&lt;span&gt;根据变量d选择调用Strategies类的方法&lt;/span&gt;
    Strategies[&quot;getDay&quot; +&lt;span&gt; d]();
};&lt;p&gt;alertWeekDay();&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大伙看到这段代码的时候，是否认为上面的代码比这个用什么策略模式的简洁的多了去了？从代码量的角度看，确实是这样。但现实是，作为开发者我们有80%的时间是在维护旧的代码，剩下的20%才是写新的代码，所以写出可维护的代码同样很重要。改用策略模式后的代码虽然代码量增加了，但更易于维护了。为什么更容易维护了呢？假如某一天W3C把Date对象的getDay()函数改成为从0~6分别对应星期一到星期日（而不是现在的0表示星期日，1~6分别对象星期一到星期六），第一段用if写的代码是不是要把所用if结构的代码都要改一遍，但第二段代码只需修改Strategies类里return的对象的方法顺序即可，那个更易于维护一眼便知。&lt;/p&gt;

&lt;p&gt;当然上面是基于面向对象的方式使用的策略模式，大家都知道JavaScript没有类的概念，所以上面不是正在意义上的JavaScript语言策略模式。在JavaScript中，函数是一等对象，可以将函数当作一个变量传递到函数内部执行，所以JavaScript语言是天生自带策略模式的哦！下面看看真正的JavaScript语言策略模式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay0(e){
    console.log(&lt;/span&gt;'今天是星期日:' +&lt;span&gt; e);
};
            
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay1(e){
    console.log(&lt;/span&gt;'今天是星期一:' +&lt;span&gt; e);
};
            
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay2(e){
    console.log(&lt;/span&gt;'今天是星期二:' +&lt;span&gt; e);
};
            
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay3(e){
    console.log(&lt;/span&gt;'今天是星期三:' +&lt;span&gt; e);
};
            
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay4(e){
    console.log(&lt;/span&gt;'今天是星期四:' +&lt;span&gt; e);
};
            
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay5(e){
    console.log(&lt;/span&gt;'今天是星期五:' +&lt;span&gt; e);
};
            
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDay6(e){
    console.log(&lt;/span&gt;'今天是星期六:' +&lt;span&gt; e);
};
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示备忘事件函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; alertRemindEvents(fn, events){
     fn(events);
};
            
alertRemindEvents(getDay3, &lt;/span&gt;&quot;今天中午妈妈没时间做饭，我要自己去买菜做饭了。&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;策略模式的优缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 1、策略类会增多。 2、所有策略类都需要对外暴露。&lt;/p&gt;

</description>
<pubDate>Mon, 05 Mar 2018 07:46:00 +0000</pubDate>
<dc:creator>雨霖月寒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jofun/p/8509336.html</dc:identifier>
</item>
<item>
<title>Go基础之--操作Mysql(一) - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8509164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8509164.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;关于标准库database/sql&lt;/h2&gt;
&lt;p&gt;database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，那些特有的方法交给数据库驱动去实现。&lt;/p&gt;
&lt;p&gt;database/sql库提供了一些type。这些类型对掌握它的用法非常重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DB&lt;/strong&gt;&lt;br/&gt;数据库对象。 sql.DB类型代表了数据库。和其他语言不一样，它并是数据库连接。golang中的连接来自内部实现的连接池，连接的建立是惰性的，当你需要连接的时候，连接池会自动帮你创建。通常你不需要操作连接池。一切都有go来帮你完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Results&lt;/strong&gt;&lt;br/&gt;结果集。数据库查询的时候，都会有结果集。sql.Rows类型表示查询返回多行数据的结果集。sql.Row则表示单行查询结果的结果集。当然，对于插入更新和删除，返回的结果集类型为sql.Result。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Statements&lt;/strong&gt;&lt;br/&gt;语句。sql.Stmt类型表示sql查询语句，例如DDL，DML等类似的sql语句。可以把当成prepare语句构造查询，也可以直接使用sql.DB的函数对其操作。&lt;/p&gt;
&lt;p&gt;而通常工作中我们可能更多的是用&lt;a href=&quot;https://github.com/jmoiron/sqlx%E5%8C%85%E6%9D%A5%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93&quot;&gt;https://github.com/jmoiron/sqlx包来操作数据库&lt;/a&gt;&lt;br/&gt;sqlx是基于标准库database/sql的扩展，并且我们可以通过sqlx操作各种类型的数据如&lt;/p&gt;
&lt;p&gt;和其他语言不通的是，查询数据库的时候需要创建一个连接，对于go而言则是需要创建一个数据库对象，连接将会在查询需要的时候，由连接池创建并维护，使用sql.Open函数创建数据库对象，第一个参数是数据库驱动名，第二个参数是一个连接字符串&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;关于数据库的增删查改&lt;/h2&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;增加数据&lt;/h3&gt;
&lt;p&gt;关于增加数据几个小知识点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关于插入数据的时候占位符是通过问号：？&lt;/li&gt;
&lt;li&gt;插入数据的后可以通过LastInsertId可以获取插入数据的id&lt;/li&gt;
&lt;li&gt;通过RowsAffected可以获取受影响的行数&lt;/li&gt;
&lt;li&gt;执行sql语句是通过exec&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个简单的使用例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/jmoiron/sqlx&quot;&lt;span&gt;
    _ &lt;/span&gt;&quot;github.com/go-sql-driver/mysql&quot;
    &quot;fmt&quot;&lt;span&gt;
)

func main() {
    Db,err:&lt;/span&gt;=sqlx.Open(&quot;mysql&quot;,&quot;root:123456@tcp(192.168.14.7:3306)/godb&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;connect to mysql failed,&quot;&lt;span&gt;,err)
        return
    }
    defer Db.Close()
    fmt.Println(&lt;/span&gt;&quot;connect to mysql success&quot;&lt;span&gt;)
    &lt;/span&gt;//&lt;span&gt;执行sql语句，切记这里的占位符是？
    result,err :&lt;/span&gt;= Db.Exec(&quot;INSERT INTO user_info(username,sex,email)VALUES (?,?,?)&quot;,&quot;user01&quot;,&quot;男&quot;,&quot;8989@qq.com&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;insert failed,&quot;&lt;span&gt;,err)
    }
    &lt;/span&gt;//&lt;span&gt; 通过LastInsertId可以获取插入数据的id
    userId,err:&lt;/span&gt;=&lt;span&gt; result.LastInsertId()
    &lt;/span&gt;//&lt;span&gt; 通过RowsAffected可以获取受影响的行数
    rowCount,err:&lt;/span&gt;=&lt;span&gt;result.RowsAffected()
    fmt.Println(&lt;/span&gt;&quot;user_id:&quot;&lt;span&gt;,userId)
    fmt.Println(&lt;/span&gt;&quot;rowCount:&quot;&lt;span&gt;,rowCount)

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过Exec方法插入数据，返回的结果是一个sql.Result类型&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;查询数据&lt;/h3&gt;
&lt;p&gt;下面是一个查询的例子代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
//&lt;span&gt;执行查询操作
rows,err :&lt;/span&gt;= Db.Query(&quot;SELECT email FROM user_info WHERE user_id&amp;gt;=5&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
    fmt.Println(&lt;/span&gt;&quot;select db failed,err:&quot;&lt;span&gt;,err)
    return
}
&lt;/span&gt;// 这里获取的rows是从数据库查的满足user_id&amp;gt;=&lt;span&gt;5的所有行的email信息，rows.Next(),用于循环获取所有
for rows.Next(){
    var s string
    err &lt;/span&gt;= rows.Scan(&amp;amp;&lt;span&gt;s)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(err)
        return
    }
    fmt.Println(s)
}
rows.Close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用了Query方法执行select查询语句，返回的是一个sql.Rows类型的结果集&lt;br/&gt;迭代后者的Next方法，然后使用Scan方法给变量s赋值，以便取出结果。最后再把结果集关闭（释放连接）。&lt;br/&gt;同样的我们还可以通过Exec方式执行查询语句&lt;br/&gt;但是因为Exec返回的是一个sql.Result类型，从官网这里：&lt;br/&gt;&lt;a href=&quot;https://golang.google.cn/pkg/database/sql/#type&quot;&gt;https://golang.google.cn/pkg/database/sql/#type&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; Result&lt;br/&gt;我们可以直接这个接口里只有两个方法：LastInsertId()，RowsAffected()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们还可以通过Db.Get()方法获取查询的数据,将查询的数据保存到一个结构体中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    //&lt;span&gt;Get执行查询操作
    type user_info struct {
        Username string `db:&lt;/span&gt;&quot;username&quot;&lt;span&gt;`
        Email string `db:&lt;/span&gt;&quot;email&quot;&lt;span&gt;`
    }
    var userInfo user_info
    err &lt;/span&gt;= Db.Get(&amp;amp;userInfo,&quot;SELECT username,email FROM user_info WHERE user_id=5&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(err)
        return 
    }
    fmt.Println(userInfo)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样获取的一个数据，如果我们需要获取多行数据信息还可以通过Db.Select方法获取数据，代码例子为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
var userList []*&lt;span&gt;user_info
err &lt;/span&gt;= Db.Select(&amp;amp;userList,&quot;SELECT username,email FROM user_info WHERE user_id&amp;gt;5&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
    fmt.Println(err)
    return
}
fmt.Println(userList)
for _,v:&lt;/span&gt;=&lt;span&gt; range userList{
    fmt.Println(v)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过Db.Select方法将查询的多行数据保存在一个切片中，然后就可以通过循环的方式获取每行数据&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;更新数据&lt;/h3&gt;
&lt;p&gt;下面是一个更新的例子，这里是通过Exec的方式执行的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
//&lt;span&gt;更新数据
results,err :&lt;/span&gt;= Db.Exec(&quot;UPDATE user_info SET username=? where user_id=?&quot;,&quot;golang&quot;,5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
    fmt.Println(&lt;/span&gt;&quot;update data fail,err:&quot;&lt;span&gt;,err)
    return
}
fmt.Println(results.RowsAffected())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;删除数据&lt;/h3&gt;
&lt;p&gt;下面是一个删除的例子，同样是通过Exec的方式执行的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
//&lt;span&gt;删除数据
results,err :&lt;/span&gt;= Db.Exec(&quot;DELETE from user_info where user_id=?&quot;,5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
    fmt.Println(&lt;/span&gt;&quot;delete data fail,err:&quot;&lt;span&gt;,err)
    return
}
fmt.Println(results.RowsAffected())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的简单例子，对golang操作mysql的增删查改，有了一个基本的了解，下面整理一下重点内容&lt;/p&gt;
&lt;h2 id=&quot;toc_7&quot;&gt;sql.DB&lt;/h2&gt;
&lt;p&gt;当我们调用sqlx.Open()可以获取一个sql.DB对象，sql.DB是数据库的抽象，切记它不是数据库连接，sqlx.Open()只是验证数据库参数，并没不创建数据库连接。sql.DB提供了和数据库交互的函数，同时也管理维护一个数据库连接池，并且对于多gegoroutines也是安全的&lt;/p&gt;
&lt;p&gt;sql.DB表示是数据库抽象，因此你有几个数据库就需要为每一个数据库创建一个sql.DB对象。因为它维护了一个连接池，因此不需要频繁的创建和销毁。&lt;/p&gt;
&lt;h2 id=&quot;toc_8&quot;&gt;连接池&lt;/h2&gt;
&lt;p&gt;只用sql.Open函数创建连接池，可是此时只是初始化了连接池，并没有创建任何连接。连接创建都是惰性的，只有当真正使用到连接的时候，连接池才会创建连接。连接池很重要，它直接影响着你的程序行为。&lt;/p&gt;
&lt;p&gt;连接池的工作原来却相当简单。当你的函数(例如Exec，Query)调用需要访问底层数据库的时候，函数首先会向连接池请求一个连接。如果连接池有空闲的连接，则返回给函数。否则连接池将会创建一个新的连接给函数。一旦连接给了函数，连接则归属于函数。函数执行完毕后，要不把连接所属权归还给连接池，要么传递给下一个需要连接的（Rows）对象，最后使用完连接的对象也会把连接释放回到连接池。&lt;/p&gt;
&lt;p&gt;请求连接的函数有几个，执行完毕处理连接的方式也不同：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;db.Ping() 调用完毕后会马上把连接返回给连接池。&lt;/li&gt;
&lt;li&gt;db.Exec() 调用完毕后会马上把连接返回给连接池，但是它返回的Result对象还保留这连接的引用，当后面的代码需要处理结果集的时候连接将会被重用。&lt;/li&gt;
&lt;li&gt;db.Query() 调用完毕后会将连接传递给sql.Rows类型，当然后者迭代完毕或者显示的调用.Clonse()方法后，连接将会被释放回到连接池。&lt;/li&gt;
&lt;li&gt;db.QueryRow()调用完毕后会将连接传递给sql.Row类型，当.Scan()方法调用之后把连接释放回到连接池。&lt;/li&gt;
&lt;li&gt;db.Begin() 调用完毕后将连接传递给sql.Tx类型对象，当.Commit()或.Rollback()方法调用后释放连接。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;每个连接都是惰性的，如何验证sql.Open调用之后，sql.DB对象可用，通过db.Ping()初始化&lt;/p&gt;
&lt;p&gt;代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/jmoiron/sqlx&quot;&lt;span&gt;
    _ &lt;/span&gt;&quot;github.com/go-sql-driver/mysql&quot;
    &quot;fmt&quot;&lt;span&gt;
)

func main() {
    Db, err :&lt;/span&gt;= sqlx.Open(&quot;mysql&quot;, &quot;root:123456@tcp(192.168.50.166:3306)/godb&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;connect to mysql failed,&quot;&lt;span&gt;, err)
        return
    }

    defer Db.Close()
    fmt.Println(&lt;/span&gt;&quot;connect to mysql success&quot;&lt;span&gt;)

    err &lt;/span&gt;=&lt;span&gt; Db.Ping()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(err)
        return
    }
    fmt.Println(&lt;/span&gt;&quot;ping success&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要知道：当调用了ping之后，连接池一定会初始化一个数据连接&lt;/p&gt;
&lt;h2 id=&quot;toc_9&quot;&gt;连接失败&lt;/h2&gt;
&lt;p&gt;database/sql 其实帮我们做了很多事情，我们不用见擦汗连接失败的情况，当我们进行数据库操作的时候，如果连接失败，database/sql 会帮我们处理，它会自动连接2次，这个如果查看源码中我们可以看到如下的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
// ExecContext executes a &lt;span&gt;query&lt;/span&gt;&lt;span&gt; without returning any rows.
&lt;/span&gt;// The args are for any placeholder parameters in the &lt;span&gt;query&lt;/span&gt;&lt;span&gt;.
func (db &lt;/span&gt;*DB) ExecContext(ctx context.Context, &lt;span&gt;query&lt;/span&gt;&lt;span&gt; string, args ...interface{}) (Result, error) {
    var res Result
    var err error
    for i :&lt;/span&gt;= 0; i &amp;lt; maxBadConnRetries; i++&lt;span&gt; {
        res, err &lt;/span&gt;= db.exec(ctx, &lt;span&gt;query&lt;/span&gt;&lt;span&gt;, args, cachedOrNewConn)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; driver.ErrBadConn {
            break
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err ==&lt;span&gt; driver.ErrBadConn {
        return db.exec(ctx, &lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;, args, alwaysNewConn)
    }
    return res, err
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中变量maxBadConnRetries小时如果连接失败尝试的次数，默认是2&lt;/p&gt;
&lt;h2 id=&quot;toc_10&quot;&gt;关于连接池配置&lt;/h2&gt;
&lt;p&gt;db.SetMaxIdleConns(n int) 设置连接池中的保持连接的最大连接数。默认也是0，表示连接池不会保持释放会连接池中的连接的连接状态：即当连接释放回到连接池的时候，连接将会被关闭。这会导致连接再连接池中频繁的关闭和创建。&lt;/p&gt;
&lt;p&gt;db.SetMaxOpenConns(n int) 设置打开数据库的最大连接数。包含正在使用的连接和连接池的连接。如果你的函数调用需要申请一个连接，并且连接池已经没有了连接或者连接数达到了最大连接数。此时的函数调用将会被block，直到有可用的连接才会返回。设置这个值可以避免并发太高导致连接mysql出现too many connections的错误。该函数的默认设置是0，表示无限制。&lt;/p&gt;
&lt;p&gt;db.SetConnMaxLifetime(d time.Duration) 设置连接可以被使用的最长有效时间，如果过期，连接将被拒绝&lt;/p&gt;

</description>
<pubDate>Mon, 05 Mar 2018 07:20:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8509164.html</dc:identifier>
</item>
<item>
<title>Redis进阶实践之十四 Redis-cli命令行工具使用详解第一部分 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8508975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8508975.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       redis学了有一段时间了，以前都是看视频，看教程，很少看官方的东西。现在redis的东西要看的都差不多看完了。网上的东西也不多了。剩下来就看看官网的东西吧，一遍翻译，一遍测试。不错的使用体验，今天开始就写一下redis的客户端的使用，也就是redis-cli工具类，这个文件的内容真不少，一次写完有点吃力。分多次写吧。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、使用详解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &lt;span&gt;&lt;strong&gt; 1、redis-cli，Redis命令行界面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           redis-cli是Redis命令行界面，它是一个允许向Redis发送命令、并直接从终端读取服务器发送的回复的简单的程序。&lt;/p&gt;&lt;p&gt;           它有两种主要模式：一种交互模式，其中有一个REPL（读取评估打印循环），用户输入命令并获取回复；另一种模式是将命令作为redis-cli的参数发送，执行并打印在标准输出中。&lt;/p&gt;&lt;p&gt;           在交互模式下，redis-cli具有基本的行编辑功能，可以提供良好的打字体验。&lt;/p&gt;&lt;p&gt;           然而，redis-cli不仅仅具有以上功能，还有更高级的用法。有些选项可用来启动程序并将其置于特殊模式之下，以便redis-cli可以完成更复杂的任务，如模拟从站并打印从主站接收到的复制流，检查Redis服务器的延迟，并显示统计数据，甚至是延时采样和频率的ASCII-art频谱图，以及其他许多事情。&lt;/p&gt;&lt;p&gt;           本指南将涵盖redis-cli的不同方面，从最简单到最高级的结尾。&lt;/p&gt;&lt;p&gt;           如果您要广泛使用Redis，或者您已经这么做了，那么很可能会碰巧使用redis-cli。 花一些时间熟悉它可能是一个非常好的主意，一旦你知道了命令行界面的所有技巧，你就会更有效地使用Redis。&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;&lt;span&gt; 2、命令行的用法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;           只需运行一个命令并在标准输出上打印其答复就如同输入要作为redis-cli的分隔参数执行的命令一样简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;&lt;span&gt; incr mycounter
        (integer) &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;            该命令的结果是“7”。 由于Redis的结果是强类型的（它们可以是字符串，数组，整数，NULL，错误等等），您可以看到括号之间的就是结果的类型。 但是，当redis-cli的输出必须用作另一个命令的输入，或者我们希望将它重定向到一个文件时，这并不是一个好的做法。&lt;/p&gt;&lt;p&gt;           实际上，redis-cli当检测到标准输出是一个tty设备时就会来显示这些附加信息以帮助提高人们的可读性。 否则，它将通过 auto-enable 启用原始输出模式，如下例所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; incr mycounter &amp;gt; /tmp/&lt;span&gt;output.txt
        $ cat &lt;/span&gt;/tmp/&lt;span&gt;output.txt
        &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;           由于CLI检测到输出不再写入终端，因此这次输出中才省略了（整数）这个显示。 你甚至可以在终端上用--raw选项强制原始输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; --&lt;span&gt;raw incr mycounter
        &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;           同样，通过使用--no-raw，可以在写入文件或将管道传送到其他命令时强制读取可读的输出。&lt;/p&gt;&lt;p&gt;   &lt;span&gt;&lt;strong&gt; 3、主机，端口，密码和数据库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           默认情况下，redis-cli在127.0.0.1端口6379连接到服务器。正如您所猜测的，您可以使用命令行选项轻松更改此设置。 要指定不同的主机名或IP地址，请使用-h。 为了设置不同的端口，请使用-p。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;&lt;span&gt; ping
        PONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;           如果您的实例受密码保护，-a &amp;lt;密码&amp;gt;选项将执行身份验证，以保证明确使用AUTH命令的需要：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -&lt;span&gt;a myUnguessablePazzzzzword123 ping
        PONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;           最后，可以通过使用-n &amp;lt;dbnum&amp;gt;选项发送一个命令，该命令对除默认数字零以外的数据库号进行操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;&lt;span&gt; flushall
        OK

        $ redis&lt;/span&gt;-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -n &lt;span&gt;1&lt;/span&gt;&lt;span&gt; incr a
        (integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

        $ redis&lt;/span&gt;-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -n &lt;span&gt;1&lt;/span&gt;&lt;span&gt; incr a
        (integer) &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;

        $ redis&lt;/span&gt;-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -n &lt;span&gt;2&lt;/span&gt;&lt;span&gt; incr a
        (integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;           部分或全部信息也可以通过使用-u &amp;lt;uri&amp;gt;选项和一个有效的URI来提供：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        $ redis-cli -u redis:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p%40ssw0rd@redis-16379.hosted.com:16379/0 ping&lt;/span&gt;
        PONG
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;&lt;strong&gt;4、从其他程序获取输入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           有两种方法可以使用redis-cli来获取来自其他命令的输入（基本上来自标准输入）。 一种是使用我们从标准输入读取的有效数据作为最后一个参数。 例如，假设在我的电脑里，为了将Redis的key设置到文件/etc/services的内容里，我可以使用-x选项：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -x &lt;span&gt;set&lt;/span&gt; foo &amp;lt; /etc/&lt;span&gt;services
        OK
        $ redis&lt;/span&gt;-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; getrange foo &lt;span&gt;0&lt;/span&gt; &lt;span&gt;50&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#\n# Network services, Internet style\n#\n# Note that &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;           正如您在上述会话的第一行中看到的那样，SET命令的最后一个参数未被指定。 参数只是SET foo，并没有为我希望的key设置的实际的值。&lt;/p&gt;&lt;p&gt;           相反，指定了-x选项，并将文件重定向到CLI的标准输入。所以输入被读取，并被用作命令的最后一个参数。这对编写脚本很有用。&lt;/p&gt;&lt;p&gt;           另一种不同的方法是为redis-cli提供一个写在文本文件中的命令序列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
       $ cat /tmp/&lt;span&gt;commands.txt
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; foo &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
        incr foo
        append foo xxx
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; foo

        $ cat &lt;/span&gt;/tmp/commands.txt | redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;&lt;span&gt;
        OK
        (integer) &lt;/span&gt;&lt;span&gt;101&lt;/span&gt;&lt;span&gt;
        (integer) &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;101xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;           command.txt中的所有命令都由redis-cli一个接一个地执行，就好像它们是由用户交互式键入的一样。 如果需要，可以在文件内使用双引号来标识字符串，这样在字符串中间就可以包含空格或换行符或其他特殊字符，但是此字符串是作为一个参数使用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        $ cat /tmp/&lt;span&gt;commands.txt
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; foo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a single argument&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        strlen foo
        $ cat &lt;/span&gt;/tmp/commands.txt | redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;&lt;span&gt;
        OK
        (integer) &lt;/span&gt;&lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;&lt;strong&gt;5、连续运行相同的命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           在执行过程中，当用户选择暂停的情况下执行相同命令的指定次数是可行的。这在不同情况下很有用，例如，当我们想要持续监视一些 key 的内容或INFO字段输出时，或者当我们想模拟一些重复写入事件时（比如每5秒将一个新项目推入列表）。&lt;/p&gt;&lt;p&gt;           该功能由两个选项控制：-r &amp;lt;count&amp;gt;和-i &amp;lt;delay&amp;gt;。 第一种选项表示运行命令的次数，第二种表示不同命令调用之间的延迟，以秒为单位（能够指定十进制数字，如0.1表示100毫秒）。&lt;/p&gt;&lt;p&gt;           默认情况下，间隔（或延迟）被设置为0，所以命令只是尽快执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; -r &lt;span&gt;5&lt;/span&gt;&lt;span&gt; incr foo
        (integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        (integer) &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        (integer) &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        (integer) &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
        (integer) &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;           要长时间运行相同的命令，请使用-1作为计数。 因此，为了随时监控RSS存储器的大小，可以使用如下的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;  -r -&lt;span&gt;1&lt;/span&gt; -i &lt;span&gt;1&lt;/span&gt; INFO |&lt;span&gt; grep rss_human
        used_memory_rss_human:&lt;/span&gt;&lt;span&gt;1.38M&lt;/span&gt;&lt;span&gt;
        used_memory_rss_human:&lt;/span&gt;&lt;span&gt;1.38M&lt;/span&gt;&lt;span&gt;
        used_memory_rss_human:&lt;/span&gt;&lt;span&gt;1.38M&lt;/span&gt;&lt;span&gt;
        ... a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; line will be printed each second ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    6、使用redis-cli大量插入数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;          使用redis-cli进行大数据量插入会使用单独的章节来说，因为它本身就是一个有价值的话题。请参阅我们的《&lt;a href=&quot;https://redis.io/topics/mass-insert&quot; target=&quot;_blank&quot;&gt;批量插入指南&lt;/a&gt;》。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;    7、CSV输出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;            有时候您可能想要使用redis-cli来快速将数据从Redis导出到外部程序。 这可以使用CSV（逗号分隔值）输出功能来完成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;&lt;span&gt; lpush mylist a b c d
        (integer) &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;

        $ redis&lt;/span&gt;-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;  --csv lrange mylist &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;             目前无法像这样导出整个数据库，但只能用CSV输出运行单个命令。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;    8、运行Lua脚本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           redis-cli对使用Lua脚本编写的新Lua调试工具提供了广泛的支持，稳定版本是从Redis 3.2开始。有关此功能，请参阅《Redis Lua调试器文档》https://redis.io/topics/ldb。&lt;/p&gt;&lt;p&gt;           但是，即使不使用调试器，与以交互方式将脚本输入到shell或作为参数相比，您可以使用redis-cli从文件运行脚本，这种方式更加舒适：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        $ cat /tmp/script.lua &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,KEYS[&lt;span&gt;1&lt;/span&gt;],ARGV[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
        $ redis&lt;/span&gt;-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt; --eval /tmp/&lt;span&gt;script.lua foo , bar
        OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;            Redis EVAL命令将脚本使用的键列表和其他非键参数作为不同的数组。在调用EVAL命令时，您可以将key的数量作为一个数字提供。 但是，使用redis-cli并使用上面的--eval选项，并没有明确指定key的数量。相反，它使用用逗号分隔键和参数。这就是为什么在上面的调用中你看到foo，bar作为参数。&lt;/p&gt;&lt;p&gt;            所以foo会填充KEYS数组，bar会填充ARGV数组。&lt;/p&gt;&lt;p&gt;            编写简单脚本时，--eval选项很有用。对于更复杂的工作，使用Lua调试器肯定更适合。可以混合使用这两种方法，因为调试器也使用来自外部文件的执行脚本。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;    9、交互模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;            到目前为止，我们探讨了如何使用Redis CLI作为命令行程序。 这对于脚本和某些类型的测试非常有用，但是大多数人的大部分时间将会使用redis-cli的交互模式。&lt;/p&gt;&lt;p&gt;            在交互模式下，用户在提示符下键入Redis命令。该命令被发送到服务器，进行处理，回复被解析回来并呈现为更简单的形式来阅读。&lt;/p&gt;&lt;p&gt;           在交互模式下运行CLI不需要什么特别的东西 - 在没有任何参数的情况下运行即可，并且您处于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.139&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;
        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; ping
        PONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;            字符串192.168.127.130:6379&amp;gt;是提示符。它提醒您，您已连接到给定的Redis实例。&lt;br/&gt;        &lt;br/&gt;            当连接的服务器发生更改时，或者当您在与数据库编号0不同的数据库上运行时，提示会发生的更改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        OK
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;]&amp;gt;&lt;span&gt; dbsize
        (integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;]&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        OK
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; dbsize
        (integer) &lt;/span&gt;&lt;span&gt;503&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;   9.1、处理连接和重新连接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                在交互模式下使用connect命令可以通过指定我们要连接的主机名和端口来连接到不同的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; connect metal &lt;span&gt;6379&lt;/span&gt;&lt;span&gt;
            metal:&lt;/span&gt;&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; ping
            PONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;               正如你所看到的以下的提示也会有相应的改变。如果用户尝试连接到无法访问的实例，则redis-cli将进入断开连接模式，并且准备使用新命令尝试重新连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; connect &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; &lt;span&gt;9999&lt;/span&gt;&lt;span&gt;
            Could not connect to Redis at &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;: Connection refused

            not connected&lt;/span&gt;&amp;gt;&lt;span&gt; ping
            Could not connect to Redis at &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;: Connection refused

            not connected&lt;/span&gt;&amp;gt;&lt;span&gt; ping
            Could not connect to Redis at &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;9999&lt;/span&gt;: Connection refused
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;               通常在检测到断开连接后，CLI始终尝试以透明方式重新连接：如果尝试失败，则会显示错误并进入断开连接状态。 以下是断开和重新连接的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; debug restart
            Could not connect to Redis at &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&lt;span&gt;: Connection refused
            not connected&lt;/span&gt;&amp;gt;&lt;span&gt; ping
            PONG
            &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; (now we are connected again)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                 当执行重新连接时，redis-cli会自动重新选择所选的上一个数据库编号。然而，关于连接的所有其他状态都会丢失，例如，事务的状态信息就会丢失，当我们处于事务的执行过程中的时候：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            $ redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; multi
            OK

            &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; ping
            QUEUED

            ( here the server &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; manually restarted )

            &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; exec
            (error) ERR EXEC without MULTI&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;               在交互模式下使用CLI进行测试时，这通常不是问题，但您应该了解这一限制。&lt;/p&gt;&lt;p&gt;   &lt;span&gt;&lt;strong&gt;     9.2、编辑，历史和完成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                由于redis-cli使用《linenoise行编辑库》，因此它一直具有行编辑功能，而不依赖于libreadline或其他可选库。&lt;/p&gt;&lt;p&gt;                您可以访问已执行的命令的历史记录，以便通过按方向键（上和下）来避免重复键入它们。在用户主目录内的一个名为.rediscli_history的文件中，指定HOME环境变量，在重新启动CLI的时候保留历史记录。  可以通过设置 REDISCLI_HISTFILE 环境变量来使用不同的历史文件名，并通过将其设置为 /dev/null 来禁用它。&lt;/p&gt;&lt;p&gt;                CLI客户端还能够通过按TAB键执行命令名称的补全操作，&amp;lt;TAB&amp;gt;表示按TAB键，如下例所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; Z&amp;lt;TAB&amp;gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; ZADD&amp;lt;TAB&amp;gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; ZCARD&amp;lt;TAB&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       &lt;span&gt;&lt;strong&gt; 9.3、运行相同的命令N次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                可以通过在命令名前添加一个数字来多次运行相同的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt; incr mycounter
            (integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            (integer) &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
            (integer) &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            (integer) &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
            (integer) &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        &lt;strong&gt;&lt;span&gt;9.4、显示有关Redis命令的帮助&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                Redis有很多命令，有时候，当你测试的时候，你可能不记得参数的确切顺序。redis-cli使用help命令为大多数Redis命令提供联机帮助。 该命令可以以两种形式使用：&lt;/p&gt;&lt;p&gt;                 &lt;strong&gt;1、help @ &amp;lt;category&amp;gt;显示关于给定类别的所有命令。 类别包括：@generic，@list，@set，@sorted_set，@hash，@pubsub，@transactions，@connection，@server，@scripting，@hyperloglog。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                 &lt;strong&gt;2、help &amp;lt;commandname&amp;gt;显示作为参数给出的命令的特定帮助。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                例如，为了显示PFADD命令的帮助，使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; help PFADD

             PFADD key element [element ...]
             summary: Adds the specified elements to the specified HyperLogLog.
             since: &lt;/span&gt;&lt;span&gt;2.8&lt;/span&gt;.&lt;span&gt;9&lt;/span&gt;&lt;span&gt;
             group: hyperloglog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                  PFADD key element [element ...]&lt;br/&gt;                  摘要：将指定的元素添加到指定的HyperLogLog。&lt;br/&gt;                  从版本：2.8.9&lt;/p&gt;&lt;p&gt;                  请注意，帮助也支持TAB补全功能。&lt;/p&gt;&lt;p&gt;        &lt;strong&gt;9.5、清除终端屏幕&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;            在交互模式下使用 clear 命令将清除终端屏幕。&lt;/p&gt;&lt;p&gt;　    &lt;span&gt;&lt;strong&gt;   后面还有很多高级内容，就放在下篇文章里面了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;         好了，今天就写到这里了，剩下还有很多高级的内容需要些，慢慢来，一口不能吃一个胖子，而且翻译起来也挺耗时间的。剩下的内容就留到下一篇文章吧。继续努力，不能松懈。如果想看原文，地址如下：&lt;a href=&quot;https://redis.io/topics/rediscli&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/rediscli。&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Mar 2018 06:54:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8508975.html</dc:identifier>
</item>
<item>
<title>【开源项目】智能电视及电视盒子的控制应用TVRemoteIME的接口说明 - Kingthy</title>
<link>http://www.cnblogs.com/kingthy/p/8508933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingthy/p/8508933.html</guid>
<description>&lt;h2&gt;一、APP项目介绍：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;APP名称：&lt;/strong&gt;TVRemoteIME&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能说明：&lt;/strong&gt;安卓智能电视或者安卓盒子的控制应用，可跨屏远程输入、远程遥控（代替遥控器）盒子、盒子应用及文件管理、HTTP/RTMP/MMS网络视频直播、ED2K/种子文件的视频文件边下边播&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目地址：&lt;/strong&gt;&lt;a href=&quot;https://github.com/kingthy/TVRemoteIME&quot; target=&quot;_blank&quot;&gt;https://github.com/kingthy/TVRemoteIME&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;APK包下载：&lt;/strong&gt;&lt;a href=&quot;https://github.com/kingthy/TVRemoteIME/raw/master/released/IMEService-release.apk&quot;&gt;https://github.com/kingthy/TVRemoteIME/raw/master/released/IMEService-release.apk&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;二、APP控制端界面截图&lt;/h2&gt;
&lt;p&gt;控制端不需要安装任何APK应用，直接在同局域网的手机、电脑或者PAD的浏览器访问操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入遥控：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/25430/201803/25430-20180305143211290-1991839056.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用管理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://raw.githubusercontent.com/kingthy/TVRemoteIME/master/released/screenshot_2.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;控制界面示例截图&quot; src=&quot;https://raw.githubusercontent.com/kingthy/TVRemoteIME/master/released/screenshot_2.png&quot; alt=&quot;示例截图&quot; width=&quot;358&quot; height=&quot;393&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文件管理：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/kingthy/TVRemoteIME/master/released/screenshot_3.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;控制界面示例截图&quot; src=&quot;https://raw.githubusercontent.com/kingthy/TVRemoteIME/master/released/screenshot_3.png&quot; alt=&quot;示例截图&quot; width=&quot;365&quot; height=&quot;468&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;视频直播：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/kingthy/TVRemoteIME/master/released/screenshot_4.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;控制界面示例截图&quot; src=&quot;https://raw.githubusercontent.com/kingthy/TVRemoteIME/master/released/screenshot_4.png&quot; alt=&quot;示例截图&quot; width=&quot;366&quot; height=&quot;518&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;三、APP核心功能介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、IMEService：&lt;/strong&gt;APP的主核心入口，继承于InputMethodService，用于实现输入服务，提供简易的QWERT键盘UI，核心的遥控功能也是通过此服务来实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、RemoteServer: &lt;/strong&gt;APP的Web API服务，通过NanoHTTPD实现Web服务，控制端的所有操作都是直接调用此服务下的WebAPI接口实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、ijkplayer项目：&lt;/strong&gt; 视频播放器项目，通过封装ijkplayer播放器实现，封闭实现了视频源的解析及下载，支持HTTP/RTMP/MMS网络视频直播、ED2K/种子文件的视频文件边下边播&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、thunder项目：&lt;/strong&gt; 第三方的下载服务，实现视频源的下载服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 5、index.html与ime_core.js：&lt;/strong&gt; 实现控制端的功能页面及脚本代码，所有控制端的操作都是通过此页面和脚本实现。&lt;/p&gt;

&lt;h2&gt;四、WebAPI接口介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、“/text” &lt;/strong&gt;     ：文本输入接口，用于实现跨屏输入&lt;/p&gt;
&lt;p&gt;代码文件：InputRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;text  = 要输入的文本，可以为任意数量的字符&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /&lt;span&gt;text

text=要输入的文字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;Web服务接收到接口请求后通过DataReceiver的onTextReceived事件方法通知输入法服务IMEService，输入法服务通过commitText方法将远程输入的文本提交输入到相应的输入框。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    private boolean&lt;span&gt; commitText(String text){
        InputConnection ic =&lt;span&gt; getCurrentInputConnection();
        boolean flag = false&lt;span&gt;;
        if (ic != null&lt;span&gt;){
            Log.d(TAG, &quot;commitText:&quot; +&lt;span&gt; text);
            if(text.length() &amp;gt; 1 &amp;amp;&amp;amp;&lt;span&gt; ic.beginBatchEdit()){
                flag = ic.commitText(text, 1&lt;span&gt;);
                ic.endBatchEdit();
            }else&lt;span&gt;{
                flag = ic.commitText(text, 1&lt;span&gt;);
            }
        }
        return&lt;span&gt; flag;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、“/key&quot;，“/keydown“，”/keyup“：&lt;/strong&gt; 三个接口分别实现按键不同的输入状态：”按击“，”按下“，”弹起“。 可用于实现按键操作，如远程遥控功能。&lt;/p&gt;
&lt;p&gt;代码文件：InputRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;code = 按键码，对应于安卓KeyEvent里定义的按键码，特殊定义的按键码”cls“表示“清空文本“&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
POST /key

code=cls
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
POST /keydown

code=67
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;Web服务接收到接口请求后通过DataReceiver的onKeyEventReceived事件方法通知输入法服务IMEService，输入法服务再根据按键码及按键动作进行处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;                @Override
                public void onKeyEventReceived(String keyCode, int&lt;span&gt; keyAction) {
                    if(keyCode != null&lt;span&gt;) {
                        if(&quot;cls&quot;&lt;span&gt;.equalsIgnoreCase(keyCode)){
                            InputConnection ic =&lt;span&gt; getCurrentInputConnection();
                            if(ic != null&lt;span&gt;) {
                                ic.performContextMenuAction(android.R.id.selectAll);
                                ic.commitText(&quot;&quot;, 1&lt;span&gt;);
                            }
                        }else&lt;span&gt; {
                            final int kc =&lt;span&gt; KeyEvent.keyCodeFromString(keyCode);
                            if(kc !=&lt;span&gt; KeyEvent.KEYCODE_UNKNOWN){
                                if(mInputView != null &amp;amp;&amp;amp; KeyEventUtils.isKeyboardFocusEvent(kc) &amp;amp;&amp;amp;&lt;span&gt; mInputView.isShown()){
                                    if(keyAction == KEY_ACTION_PRESSED || keyAction ==&lt;span&gt; KEY_ACTION_DOWN) {
                                        handler.post(new&lt;span&gt; Runnable() {
                                            @Override
                                            public void&lt;span&gt; run() {
                                                if (!&lt;span&gt;handleKeyboardFocusEvent(kc)) {
                                                    sendKeyCode(kc);
                                                }
                                            }
                                        });
                                    }
                                }
                                else&lt;span&gt;{
                                    long eventTime =&lt;span&gt; SystemClock.uptimeMillis();
                                    InputConnection ic =&lt;span&gt; getCurrentInputConnection();
                                    switch&lt;span&gt; (keyAction) {
                                        case&lt;span&gt; KEY_ACTION_PRESSED:
                                            sendKeyCode(kc);
                                            break&lt;span&gt;;
                                        case&lt;span&gt; KEY_ACTION_DOWN:
                                            if(ic != null&lt;span&gt;) {
                                                ic.sendKeyEvent(new&lt;span&gt; KeyEvent(eventTime, eventTime,
                                                        KeyEvent.ACTION_DOWN, kc, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0&lt;span&gt;,
                                                        KeyEvent.FLAG_SOFT_KEYBOARD |&lt;span&gt; KeyEvent.FLAG_KEEP_TOUCH_MODE));
                                            }
                                            break&lt;span&gt;;
                                        case&lt;span&gt; KEY_ACTION_UP:
                                            if(ic != null&lt;span&gt;) {
                                                ic.sendKeyEvent(new&lt;span&gt; KeyEvent(eventTime, eventTime,
                                                    KeyEvent.ACTION_UP, kc, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0&lt;span&gt;,
                                                    KeyEvent.FLAG_SOFT_KEYBOARD |&lt;span&gt; KeyEvent.FLAG_KEEP_TOUCH_MODE));
                                            }
                                            break&lt;span&gt;;
                                    }
                                }
                            }
                        }
                    }
                }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、“/apps” ：&lt;/strong&gt; 获取盒子上安装的APP数据列表，实现盒子APP的管理&lt;/p&gt;
&lt;p&gt; 代码文件：AppRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;system= 是否包含系统应用，true或false&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
POST /apps

system=false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;通过PackageManager查询盒子上安装的APP列表，在处理列表数据的同时过滤掉系统底层的APP（非第三方）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    public static List&amp;lt;AppInfo&amp;gt; queryAppInfo(Context context, boolean&lt;span&gt; containSysApp){
        PackageManager pm =&lt;span&gt; context.getPackageManager();
        List&amp;lt;ApplicationInfo&amp;gt; listAppcations =&lt;span&gt; pm
                .getInstalledApplications(PackageManager.MATCH_UNINSTALLED_PACKAGES);
        List&amp;lt;AppInfo&amp;gt; appInfos = new ArrayList&amp;lt;AppInfo&amp;gt;&lt;span&gt;();
        for&lt;span&gt; (ApplicationInfo app : listAppcations) {
            if(containSysApp || (app.flags &amp;amp; ApplicationInfo.FLAG_SYSTEM) == 0&lt;span&gt;) {
                boolean isSysApp = (app.flags &amp;amp; ApplicationInfo.FLAG_SYSTEM) != 0&lt;span&gt;;
                //过滤掉系统底层的app
                if(isSysApp &amp;amp;&amp;amp;&lt;span&gt;
                        (app.packageName.startsWith(&quot;com.android.&quot;) || app.packageName.equals(&quot;android&quot;)))continue&lt;span&gt;;
                AppInfo appInfo = new&lt;span&gt; AppInfo();
                appInfo.setLable((String) app.loadLabel(pm));
                appInfo.setPackageName(app.packageName);
                appInfo.setApkPath(app.sourceDir);
                appInfo.setSysApp(isSysApp);
                appInfos.add(appInfo);
            }
        }
        Collections.sort(appInfos, new Comparator&amp;lt;AppInfo&amp;gt;&lt;span&gt;() {
            @Override
            public int&lt;span&gt; compare(AppInfo o1, AppInfo o2) {
                int i1 = (o1.isSysApp ? 2 : 1&lt;span&gt;);
                int i2 = (o2.isSysApp ? 2 : 1&lt;span&gt;);
                if(i1 ==&lt;span&gt; i2){
                    return&lt;span&gt; o1.getLable().compareTo(o2.getLable());
                }else&lt;span&gt;{
                    return&lt;span&gt; Integer.compare(i1, i2);
                }
            }
        });
        return&lt;span&gt;  appInfos;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、“/uninstall” ：&lt;/strong&gt; 卸载应用接口&lt;/p&gt;
&lt;p&gt; 代码文件：AppRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;packageName=卸载的应用包名&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /uninstall

packageName=com.test.app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;直接调用系统的卸载服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    public static void uninstallPackage(final String packageName, final&lt;span&gt; Context context){
        if(getApplicationInfo(packageName, context) == null)return&lt;span&gt;;;
        try&lt;span&gt; {
            Intent intent = new&lt;span&gt; Intent();
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.setAction(Intent.ACTION_DELETE);
            intent.setData(Uri.parse(&quot;package:&quot; +&lt;span&gt; packageName));
            context.startActivity(intent);
            Log.i(IMEService.TAG, String.format(&quot;已删除应用包[%s]&quot;&lt;span&gt;, packageName));
        }catch&lt;span&gt; (Exception ex){
            Log.e(IMEService.TAG, String.format(&quot;删除应用包[%s]出错&quot;&lt;span&gt;, packageName), ex);
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、“/run” ，“/runSystem”：&lt;/strong&gt; 运行应用及或调用系统应用服务，如弹出系统设置界面。&lt;/p&gt;
&lt;p&gt; 代码文件：AppRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;packageName=要运行的应用包名&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /run

packageName=com.test.app
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /runSystem

packageName=android.settings.SETTINGS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;运行第三方应用则是通过PackageManager获取包里的启动页后再运行，调用系统应用服务则是通过Intent直接启动。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    public static void runPackage(final String packageName, final&lt;span&gt; Context context){
        if(getApplicationInfo(packageName, context) == null)return&lt;span&gt;;;
        try&lt;span&gt; {
            PackageManager pm =&lt;span&gt; context.getPackageManager();
            Intent intent =&lt;span&gt; pm.getLaunchIntentForPackage(packageName);
            if(intent != null&lt;span&gt;){
                context.startActivity(intent);
            }
            Log.i(IMEService.TAG, String.format(&quot;已运行应用包[%s]&quot;&lt;span&gt;, packageName));
        }catch&lt;span&gt; (Exception ex){
            Log.e(IMEService.TAG, String.format(&quot;运行应用包[%s]出错&quot;&lt;span&gt;, packageName), ex);
        }
    }
    public static void runSystemPackage(final String packageName, final&lt;span&gt; Context context){
        try&lt;span&gt; {
            Intent intent = new&lt;span&gt; Intent(packageName);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(intent);
            Log.i(IMEService.TAG, String.format(&quot;已运行系统应用包[%s]&quot;&lt;span&gt;, packageName));
        }catch&lt;span&gt; (Exception ex){
            Log.e(IMEService.TAG, String.format(&quot;运行系统应用包[%s]出错&quot;&lt;span&gt;, packageName), ex);
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;6、“/upload” ：&lt;/strong&gt; 文件传送接口。“输入遥控”界面下的文件传送接口，如果传送的为APK包则可自动安装，如果为视频文件或者种子文件则可自动播放。&lt;/p&gt;
&lt;p&gt; 代码文件：UploadRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;file=上传的文件&lt;/p&gt;
&lt;p&gt;autoPlay = 是否自动安装APK包或者自动播放视频及种子文件，true或者false&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
POST /upload

-------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;直接通过NanoHTTPD的文件上传功能实现，为避免跨&quot;分区“移动文件，重写了NanoHTTPD的TempFileManager实现，以便文件上传时直接上传到IMEService数据目录下的files目录。&lt;/p&gt;
&lt;p&gt;代码请参考RemoteServerFileManager.java文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、“/play” ：&lt;/strong&gt; 视频播放服务接口&lt;/p&gt;
&lt;p&gt; 代码文件：PlayRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;playUrl=要播放的视频源地址&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /play

playUrl=http://www.test.com/test.avi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;直接将视频源地址传入ijkplayer项目的播放器进行播放&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
XLVideoPlayActivity.intentTo(context, url, url);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;8、“/file/dir/” ：&lt;/strong&gt; 文件管理接口服务，实现盒子的文件及目录查看功能。&lt;/p&gt;
&lt;p&gt; 代码文件：FileRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;无&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /file/dir/{查看的文件或者目录路径}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;获取目录下的子目录及文件列表，返回JSON数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
   private&lt;span&gt; NanoHTTPD.Response responseDirData(String dirName) {
        File path = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), dirName);
        String root =&lt;span&gt; Environment.getExternalStorageDirectory().getPath();
        JSONArray dirs = new&lt;span&gt; JSONArray();
        JSONArray files = new&lt;span&gt; JSONArray();
        try&lt;span&gt; {
            File[] subfiles =&lt;span&gt; path.listFiles();
            Arrays.sort(subfiles, new Comparator&amp;lt;File&amp;gt;&lt;span&gt;() {
                @Override
                public int&lt;span&gt; compare(File f1, File f2) {
                    return&lt;span&gt; f1.getName().toLowerCase().compareTo(f2.getName().toLowerCase());
                }
            });

            for&lt;span&gt; (File file : subfiles) {
                if(file.isHidden()) continue&lt;span&gt;;
                JSONObject item = new&lt;span&gt; JSONObject();
                item.put(&quot;name&quot;&lt;span&gt;, file.getName());
                item.put(&quot;path&quot;&lt;span&gt;, file.getPath().substring(root.length()));
                if&lt;span&gt; (file.isDirectory()) {
                    //item.put(&quot;total&quot;, 0);
&lt;span&gt;                    dirs.put(item);
                }else&lt;span&gt; {
                    item.put(&quot;size&quot;&lt;span&gt;, file.length());
                    files.put(item);
                }
            }

            JSONObject data = new&lt;span&gt; JSONObject();
            if(!TextUtils.isEmpty(dirName) &amp;amp;&amp;amp; dirName != &quot;/&quot;) data.put(&quot;parent&quot;&lt;span&gt;, path.getParent().substring(root.length()));
            data.put(&quot;dirs&quot;&lt;span&gt;, dirs);
            data.put(&quot;files&quot;&lt;span&gt;, files);
            return&lt;span&gt; RemoteServer.createJSONResponse(NanoHTTPD.Response.Status.OK, data.toString());
        }catch&lt;span&gt; (JSONException ex){
            return RemoteServer.createPlainTextResponse(NanoHTTPD.Response.Status.INTERNAL_ERROR,  &quot;SERVER INTERNAL ERROR: JSONException: &quot; +&lt;span&gt; ex.getMessage());
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;9、“/file/download/” ：&lt;/strong&gt; 文件下载服务，实现盒子的文件下载功能。&lt;/p&gt;
&lt;p&gt; 代码文件：FileRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;无&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /file/download/{下载的文件路径}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    private&lt;span&gt; NanoHTTPD.Response downloadFileData(String fileName){
        File file = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), fileName);
        if(!&lt;span&gt;file.exists()){
            return RemoteServer.createPlainTextResponse(NanoHTTPD.Response.Status.NOT_FOUND, &quot;Error 404, file not found.&quot;&lt;span&gt;);
        }
        try&lt;span&gt;{
            InputStream inputStream = new&lt;span&gt; FileInputStream(file);
            return&lt;span&gt; RemoteServer.newFixedLengthResponse(NanoHTTPD.Response.Status.OK,
                    NanoHTTPD.getMimeTypeForFile(file.getName()) + &quot;; charset=utf-8&quot;, inputStream, (long&lt;span&gt;)inputStream.available());
        } catch&lt;span&gt; (Exception e) {
            return RemoteServer.createPlainTextResponse(NanoHTTPD.Response.Status.NOT_FOUND, &quot;Error 404, file not found.&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;10、“/file/cut” ，“/file/copy”：&lt;/strong&gt; 文件与目录的剪切、复制服务。&lt;/p&gt;
&lt;p&gt; 代码文件：FileRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;paths = 要操作的目录或者文件列表，多个之间用“|”分隔开&lt;/p&gt;
&lt;p&gt;targetPath =  剪切或者移动的文件的新目标目录&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
POST /file/cut&lt;p&gt;paths=/Download/a.txt&amp;amp;targetPath=/Andorid/data/
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
POST /file/copy&lt;p&gt;paths=/Download/a.txt&amp;amp;targetPath=/Andorid/data/
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
   private void&lt;span&gt; batchCopyFile(String targetPath, String paths){
        File targetPathFile = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), targetPath);
        if(!targetPathFile.exists()) return&lt;span&gt;;

        String[] pathData = paths.split(&quot;\\|&quot;&lt;span&gt;);
        for&lt;span&gt;(String p : pathData){
            if(!&lt;span&gt;TextUtils.isEmpty(p)) {
                File source = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), p);
                RemoteServerFileManager.copyFile(source, targetPathFile);
            }
        }
    }
    private void&lt;span&gt; batchCutFile(String targetPath, String paths){
        File targetPathFile = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), targetPath);
        if(!targetPathFile.exists()) return&lt;span&gt;;

        String[] pathData = paths.split(&quot;\\|&quot;&lt;span&gt;);
        for&lt;span&gt;(String p : pathData){
            if(!&lt;span&gt;TextUtils.isEmpty(p)) {
                File source = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), p);
                RemoteServerFileManager.cutFile(source, targetPathFile);
            }
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;11、“/file/delete” ：&lt;/strong&gt; 文件或者目录删除服务，如果是目录删除则会一并删除目录下的所有子目录和文件。&lt;/p&gt;
&lt;p&gt; 代码文件：FileRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;paths = 要删除的文件或者目录列表&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
POST /file/delete&lt;p&gt;paths=/Download/a.txt|/Download/test
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    private void&lt;span&gt; batchDeleteFile(String paths){
        String[] pathData = paths.split(&quot;\\|&quot;&lt;span&gt;);
        for&lt;span&gt;(String p : pathData){
            if(!&lt;span&gt;TextUtils.isEmpty(p)) {
                File path = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), p);
                RemoteServerFileManager.deleteFile(path);
            }
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;12、“/file/upload” ：&lt;/strong&gt; 文件上传服务。此接口和/upload接口类似，但是此接口是将文件上传到文件管理界面下的当前目录，并且不会安装APK包和播放视频文件。&lt;/p&gt;
&lt;p&gt; 代码文件：FileRequestProcesser.java&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;file = 上传的文件数据&lt;/p&gt;
&lt;p&gt;path = 存储上传文件的目录&lt;/p&gt;
&lt;p&gt;调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /file/upload&lt;p&gt;--------
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;文件上传NanoHTTPD内部已实现好，因此只需要将上传的文件移动到对应的目录即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    private NanoHTTPD.Response uploadFile(Map&amp;lt;String, String&amp;gt; params, Map&amp;lt;String, String&amp;gt;&lt;span&gt; files){
        String uploadFileName  = params.get(&quot;file&quot;&lt;span&gt;);
        String uploadPathName  = params.get(&quot;path&quot;&lt;span&gt;);
        String localFilename = files.get(&quot;file&quot;&lt;span&gt;);
        boolean r = false&lt;span&gt;;
        if(!&lt;span&gt;TextUtils.isEmpty(uploadFileName)) {
            if (!&lt;span&gt;TextUtils.isEmpty(localFilename)) {
                File saveFilename = new&lt;span&gt; File(Environment.getExternalStorageDirectory(), uploadPathName);
                File localFile = new&lt;span&gt; File(localFilename);
                saveFilename = new&lt;span&gt; File(saveFilename,localFile.getName());
                r =&lt;span&gt; localFile.renameTo(saveFilename);
            }
        }
        return RemoteServer.createJSONResponse(NanoHTTPD.Response.Status.OK,  &quot;{\&quot;success\&quot;:&quot; + (r ? &quot;true&quot;: &quot;false&quot;) + &quot;}&quot;&lt;span&gt;);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 五：附注&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;项目地址：&lt;/strong&gt;&lt;a href=&quot;https://github.com/kingthy/TVRemoteIME&quot; target=&quot;_blank&quot;&gt;https://github.com/kingthy/TVRemoteIME&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交流QQ群：&lt;/strong&gt;7149348， 加入QQ群可以分享直播源、反馈问题及建议。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Mar 2018 06:48:00 +0000</pubDate>
<dc:creator>Kingthy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingthy/p/8508933.html</dc:identifier>
</item>
<item>
<title>我为什么突然想转管理？ - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/8508530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/8508530.html</guid>
<description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;关注我的小伙伴可能都知道，我是一个 Android 开发工程师，目前在 GitHub 有着约 7k 的 Star 量，在各大博客网站访问量也是破百万大关，而且一直以来都被不少粉丝奉为「技术大佬」。其实并不是这样，我在 Android 技术领域，其实是一个十足的菜鸡，只是花了不少的时间在写作上罢了。&lt;/p&gt;
&lt;p&gt;写作确实很重要，可以明确的说，写作成就了我的现在，虽然它还不够好，但我其实还是挺满意的。最近面试了一个 Android 开发，我似乎看到了我以前的影子，会的东西还好，但真的表达不出来，而现在的我，想必就是写作带给我的转变吧。&lt;/p&gt;
&lt;h2&gt;怎么突然有了转型管理的想法呢&lt;/h2&gt;
&lt;p&gt;我一直是深耕技术的一线 Android 开发者，自然大多数人都想着是一定会把技术进行到底，或者说至少还会做乐于做技术一段时间。其实不止你们这么认为，就连对我知根知底的公司领导，也这么认为我。因为对于一个尚且还年轻的小伙子来说，现在想转型，真的太早了。不过在这个问题上，我目前还是想的比较透彻的。&lt;/p&gt;
&lt;h2&gt;我目前渴望成为管理者的「理由」&lt;/h2&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;14&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;希望突破「个人贡献」的天花板&lt;br/&gt;对于我自己来说，我还是希望对公司释放我更大的贡献。每个公司对技术研发都有不同的岗位和职级划分，其实归根结底归为两类：「个人贡献者」和「非个人贡献者」。&lt;/p&gt;&lt;p&gt;技术开发、 UI 设计和产品经理是典型的「个人贡献者」，开发的主要工作是写代码，他的所有产出就是一行行代码所构成的最终产品。UI 设计的产出就是他的设计稿，同样产品经理的产出就是他的原型图和需求文档。这些所有的产出和对公司的贡献，都是来自个人的，很少依赖别人。&lt;/p&gt;&lt;p&gt;而作为一名管理者的话，就完全不一样了，他做的工作可能是不停地组织沟通和协调这些人。对于一个「个人贡献者」，工作时间顶天就 24 小时，他不休息地高效工作。但一个好的管理者的话，发动身边的人，朝一个目标努力，这个团队贡献是上无止境的，想想都刺激！&lt;/p&gt;&lt;p&gt;所以这是我第一个理由:&lt;strong&gt;因为我想驱动更多人朝着一个方向努力，做出一个有着更大贡献的产品。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;终究我还是会面对管理&lt;br/&gt;作为一个技术人来说，通常也就只有四条路：管理、产品、技术总监 or 转行。&lt;/p&gt;&lt;p&gt;可能有很多人说，「我不喜欢做管理，我就喜欢做技术，我就是纯技术控」。其实有很多人都这样想，包括我曾经也是如此。技术人的职业阶梯总是很美好，认为自己可以成为阿里多隆，对，就是哪个阿里仅有的 P11，我一直的偶像。&lt;/p&gt;&lt;p&gt;但不管我们的技术做的有多棒，终究还是会管理几个人的，当你达到技术的一个很高层次的时候，多多少少，我们还是得带新人，带其他技术人员，让大家一起朝一个方向冲刺。从这个角度讲，不管是不是想一直走纯技术路线，我们都需要增长自己的沟通和管理技能。&lt;/p&gt;&lt;p&gt;所以这是其二：&lt;strong&gt;我总会到管理。&lt;/strong&gt;正如今天我们 CEO 给我讲的一样，「我们技术人总会慢慢转型，只是我们可以去把控这个时间而已，早一点上去可能意味着更多的困难，但迟一点上去可能意味着损失机遇」。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;讲一讲很多人的「误区」&lt;/h2&gt;
&lt;p&gt;可能就会有不少人质疑我了，说南尘其实想做管理的原因其实不是这个，五花八门的都有。&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;18.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;只是期望拿到更多的薪水&lt;br/&gt;大多数人认为，管理人员的薪水都更高，所以难免以偏概全，认为我是为了薪水所以期望转行。&lt;/p&gt;&lt;p&gt;薪水确实很重要，但这个想法一点都不对。大多数技术足够牛逼的人，薪资都是比他的管理者高的，因为这些高级技术人员技术已经牛逼到了业界没几个能做好。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;对我的家境来说，钱确实很重要，但远远没重要到这个地步。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;期望指引别人&lt;br/&gt;其实用「指引」的时候，我好像用「指使」呀。因为肯定有很多人这样想了，管理人员可以高高在上，随意使唤别人。&lt;/p&gt;&lt;p&gt;但我觉得恰恰相反，很多时候，&lt;strong&gt;领导都是负责背锅的&lt;/strong&gt;&lt;strong&gt;，负责给大家抗压擦屁股的，领导才是那个给大家端茶倒水，服务大家的人&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这是我真实的看法。我们公司技术副总贾总，就是这样的一个人，明明技术都牛逼的要死，却因为做管理，整天接受着来自外部和内部的轮番轰炸。其实我真的超级心疼他，因为本已经是最努力的那一批人之一，却还被这样到处被数落，而且还经常遇到下属闹脾气。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;所以，放下心中的偏见吧，好好对待你们的老大。我也已经有了背黑锅，接收轰炸的觉悟。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;指望工作更加轻松&lt;br/&gt;很多人认为程序员很累，996 加班已经是很多公司的常态，有时候改需求，上线任务，还要加班到深夜。还好我们公司基本很少加班，是个标准的每周 40 小时的公司。但我们的技术领导，真的是一年 365 天，98% 的时间都在工作。所以，我会为了让工作更轻松而产生这个想法吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;更容易换工作&lt;br/&gt;&lt;strong&gt;这可能是最扯淡的一种看法了。&lt;/strong&gt;对于我们开发人员来说，只要技术实力过硬，根本就不可能愁找不到工作的，而且觉得是薪资待遇还不低。&lt;/p&gt;&lt;p&gt;但作为一个管理人员，换工作会更容易吗？完全扯淡。一个空降的管理，要融入技术团队是非常困难的，这需要非常多的时间。因为他们需要去面对这些出名的「寡言者」&lt;strong&gt;( 对，说的就是你，程序员！)&lt;/strong&gt;，需要去了解团队每一个人的擅长点和不擅长点，需要去了解团队成员是属于「自我驱动型」还是「被动接受型」人才，这是非常需要时间的。和每个人打交道，应该用怎样的方式才合适，自己公司的产品有怎样的用户场景和用户行为，为什么需要做这些功能，未来产品发展何去何从？需要思考的问题太多了，而且这大多数情况下还不是通用的。&lt;/p&gt;&lt;p&gt;说的简单点，我一个 Android 开发，假设想换工作的话，完全不可能想着从事管理行业。甚至退一步说，即使有天我离职了，我依然肯定会选择我擅长的 Android 开发岗位，而这时候，下家公司看重的却只是我的技术实力。&lt;/p&gt;&lt;p&gt;所以，我可能为了换工作而想转行管理吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;我为这次转型管理做了哪些准备？或者说我的优势&lt;/h2&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;28.5&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;高效的时间管理能力&lt;br/&gt;可能大多数程序员都是「被动接受型」，我们只需要把每天领导安排的开发任务完成就可以愉快地玩耍了。但我不是那样的人，我是典型的「主动驱动型」选手，没事的时候，强迫症的我总是喜欢去重写那些自己看不惯的代码，优化超垃圾的逻辑。所以经常可以看到我怒怼产品经理，但恰恰我和我们的公司的产品经理关系非常要好。&lt;strong&gt;我想这大概是怼多了，导致顺从我了吧。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个我其实知道，因为一个公司很重要一点是解决用户需求，所以很多时候我们的产品经理是迫不得已的，有些功能是没有按照想象的出发的。&lt;/p&gt;&lt;p&gt;我认为时间管理应该是技术转型管理的第一课，而非常 Nice 的一点是这个能力我早已具备了。我一直以来是一个喜欢规划任务的人，这从小而来的习惯，现在正促就了我现在。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;强大的总结能力&lt;br/&gt;正好今天我们 CEO 找我面谈的时候，他提到了他这个「放电影」能力：即每天晚上睡觉前会自动过一遍当天的所有事情，这正好也是我从小学习成绩优异的原因。我上学那会儿，记忆力一直不好，就连抄写在笔记本上也不行。但我后面每天晚上过一遍当天内容，我发现我很多东西自然而然就记住了，正好这个方法，也推荐大家运用，因为作为一个技术开发来说，学习能力和记忆力太重要了。&lt;/p&gt;&lt;p&gt;对于总结方面，其实和上面的时间管理有很大的挂钩。因为一个管理者的时间正常由「被动时间」和「主动时间」所构成。而所有的「主动时间」都应该花在总结上，作为一个管理人员来说，需要对各种事情做有效的排期，最重要的当然要放在最前面。&lt;/p&gt;&lt;p&gt;对于一个长期写 Blog 的我来说，总结能力方面自然是尚可的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;表达能力（沟通能力）&lt;br/&gt;对于一个管理型人才来说，这个相当重要，因为每天可能都需要大量地时间去和各种各样的人打交道。需要去说服市场部的人员了解自己手中的进度，并接受自己的排期；也需要去和本部门的员工做各种各样的交流协调，而有个很重要的一点就是，都需要用他们最喜欢的方式。&lt;/p&gt;&lt;p&gt;很多人认为指导新人是一件非常累的事情，因为要给他讲超级多的东西。在我们公司，严格说，我不算带过新人，但确实也做了不少的入职培训和后期工作安排，而这，对我的表达能力提升非常重要。每个新人的特点都不一样，你需要针对每个人的特点，来定制他的个人能力和成长计划，并且需要做刻意的沟通。说到这里，也是希望大家改变一下自己的观点，&lt;strong&gt;其实，带新人的时候，这对你的表达能力锻炼非常大。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;「刻意练习」能力&lt;br/&gt;说这个词，同样是去年我的公司 CEO 告诉我的。当时是准备去参加「Android 巴士线下交流会成都站」，而我作为一名技术演讲嘉宾。我感到非常恐惧，因为从来没上台的我，突然要面对这么多同为 Android 开发的技术大牛，这对我来说要求太突然了。&lt;/p&gt;&lt;p&gt;于是我找到了我们的 CEO 高总，他语重心长给我说了一大堆话，其中提到了一个很关键的词语就是「刻意练习」。至今深刻的是，他说他现在能做到随便脱稿演讲，就是因为他之前「刻意练习」过很多演讲活动。&lt;/p&gt;&lt;p&gt;非常庆幸，我现在已经学会了时刻「刻意练习」自己的能力，并不断提高。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;「向上管理」能力&lt;br/&gt;严格来说，这方面的能力还是我当下比较欠缺的。我目前仅仅是做好了及时回馈自己的工作进度以及公司每天要求的日报。但实际上在「向上管理」层面，我能做的还差的多。&lt;/p&gt;&lt;p&gt;但当管理一个团队的时候，向上级汇报情况就变得非常重要了，就连 CEO 不是也得向董事会汇报嘛。&lt;/p&gt;&lt;p&gt;总应该会有一个「向上管理」的过程，我们需要去和老大沟通，以便于明确整个团队在未来需要解决问题的主次方向。&lt;/p&gt;&lt;p&gt;在德鲁克的那本书里举过这样一个例子：主管写下一个目标，然后让上司写下他对主管的工作目标和期望，你会发现大部人写的都不一样，这就是缺乏沟通的一个问题。&lt;/p&gt;&lt;p&gt;如果没有这个「向上管理」的话，你可能把整个团队都给带偏了，最后老大会说我要的并不是这个，我要的是另外一个东西。所以说一定要做好向上管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;写在最后&lt;/h2&gt;
&lt;p&gt;原本这里应该是一个总结，但感觉我通篇都写的挺总结性的，这里就不多说啦。总的来说，今天和 CEO 的谈话非常舒服，不管是否能获得转型资格，这条路，南尘都将会走下去。&lt;/p&gt;

</description>
<pubDate>Mon, 05 Mar 2018 05:38:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liushilin/p/8508530.html</dc:identifier>
</item>
<item>
<title>1000多个项目中的十大JavaScript错误以及如何避免 - 葡萄城控件技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/top-10-javascript-errors.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/top-10-javascript-errors.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;通过统计数据库中的1000多个项目，我们发现在 JavaScript 中最常出现的错误有10个。下面会向大家介绍这些错误发生的原因以及如何防止。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;对于这些错误发生的次数，我们是通过收集的数据统计得出的。&lt;a href=&quot;https://rollbar.com/&quot; target=&quot;_blank&quot;&gt;Rollbar&lt;/a&gt; 会收集每个项目中的所有错误，并总结每个错误发生的次数，然后通过各个错误的特征进行分组。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;下图是发生次数最多的10大 JavaScript 错误：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305112911127-90800111.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;457&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;下面开始深入探讨每个错误发生的情况，以便确定导致错误发生的原因以及如何避免。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这是 JavaScript 开发人员最常遇到的错误。当你读取一个属性或调用一个未定义对象的方法时，Chrome 中就会报出这样的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305112936360-1519750950.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;导致这个错误发生的原因有很多，常见的一种情况是在渲染 UI 组件时，不正确地初始化状态。我们来看一个真实的应用程序中发生这种情况的例子。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Quiz extends Component {
  componentWillMount() {
    axios.get(&lt;/span&gt;'/thedata').then(res =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({items: res.data});
    });
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;ul&amp;gt;&lt;span&gt;
        {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.items.map(item =&amp;gt;
          &amp;lt;li key={item.id}&amp;gt;{item.name}&amp;lt;/li&amp;gt;
&lt;span&gt;        )}
      &lt;/span&gt;&amp;lt;/ul&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;以上代码有两个重要方面：&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;&lt;span&gt;一是组件的状态（例如 this.state），在开始生命周期之前是 undefined 状态。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;二是当通过异步的方式获取数据时，无论是在构造函数中 componentWillMount 中，还是在构造函数中提取 componentDidMount，组件在数据加载之前至少会渲染一次。当检测首次渲染时，会发现 this.state.items 是未定义的。此时就会出现一个错误 -“Uncaught TypeError: Cannot read property ‘map’ of undefined&quot; in the consol”。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决的方法很简单：在构造函数中使用合理的默认值进行状态初始化。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Quiz extends Component {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Added this:&lt;/span&gt;
&lt;span&gt;  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Assign state itself, and a default value for items&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
      items: []
    };
  }
  componentWillMount() {
    axios.get(&lt;/span&gt;'/thedata').then(res =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({items: res.data});
    });
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;ul&amp;gt;&lt;span&gt;
        {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.items.map(item =&amp;gt;
          &amp;lt;li key={item.id}&amp;gt;{item.name}&amp;lt;/li&amp;gt;
&lt;span&gt;        )}
      &lt;/span&gt;&amp;lt;/ul&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这是在 Safari 中读取属性或调用未定义对象上的方法时发生的错误，这与 Chrome 的上述错误基本相同，只是 Safari 使用不同的错误消息。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305113406063-25512495.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这是在 Safari 中读取属性或调用空对象上的方法时发生的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305113432275-2133802434.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;有趣的是，在 JavaScript 中，null 和 undefined 是两种不同的类型，这就是为什么会出现两个不同的错误消息。未定义通常是一个尚未分配的变量，而 null 则表示该值为空。要验证它们不相等，请使用严格的相等运算符：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305114800917-2042707250.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;85&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在实际情况中，导致这种错误的原因之一是：在元素加载之前，就尝试在 JavaScript 中使用 DOM 元素。这是因为 DOM API 对于空白的对象引用返回 null。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;任何执行和处理 DOM 元素的 JS 代码，都应该在创建 DOM 元素之后执行。JS 代码按照 HTML 中的规定自上而下进行解释。因此，如果在 DOM 元素之前存在标签，则脚本标签内的 JS 代码就会在浏览器分析 HTML 页面时执行。如果在加载脚本之前尚未创建 DOM 元素，就会出现这样的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在这个例子中，我们可以通过添加一个事件侦听器来解决这个问题，事件侦听器会在页面准备就绪时通知我们。一旦 addEventListener 被触发，该 init(  ) 方法就可以使用 DOM 元素。&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; init() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myButton = document.getElementById(&quot;myButton&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myTextfield = document.getElementById(&quot;myTextfield&quot;&lt;span&gt;);
    myButton.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userName =&lt;span&gt; myTextfield.value;
    }
  }
  document.addEventListener(&lt;/span&gt;'readystatechange', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (document.readyState === &quot;complete&quot;&lt;span&gt;) {
      init();
    }
  });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;form&amp;gt;
  &amp;lt;input type=&quot;text&quot; id=&quot;myTextfield&quot; placeholder=&quot;Type your name&quot; /&amp;gt;
  &amp;lt;input type=&quot;button&quot; id=&quot;myButton&quot; value=&quot;Go&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当未捕获的 JavaScript 错误违背跨边界原则时，就会发生脚本错误。例如，如果将 JavaScript 代码托管在 CDN 上，则任何未被捕获的错误（通过 window.onerror 处理程序发出的错误，而不是 try-catch 中捕获到的错误）将仅报告为“脚本错误”。这是浏览器的一种安全措施，主要用于防止跨域传递数据的情况出现。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;要获取真实的错误消息，需要执行以下操作：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;1.   &lt;/strong&gt; &lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;将 Access-Control-Allow-Origin 设置为 *， 表示可以从任何域正确访问资源。* 如有必要，也可以用自己的域名进行替换，例如：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Access-Control-Allow-Origin: www.example.com。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;以下是在各种环境中设置的一些示例：&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Apache&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在 JavaScript 文件夹中，创建一个 .htaccess 文件，并包含以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Header add Access-Control-Allow-Origin &quot;*&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;将 add_header 指令添加到提供 JavaScript 文件的 location block 中：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
location ~ ^/assets/&lt;span&gt; {
    add_header Access&lt;/span&gt;-Control-Allow-Origin *&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;HAProxy&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;将以下内容添加到提供 JavaScript 文件的静态资源配置后端：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rspadd Access-Control-Allow-Origin:\ *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.   &lt;/strong&gt; &lt;strong&gt;在脚本标签上设置crossorigin =“anonymous”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在你的 HTML 源代码中，为每一个脚本设置 Access-Control-Allow-Origin，在设置 SCRIPT 标签中，设置 crossorigin=&quot;anonymous&quot;。在将 crossorigin 属性添加到脚本标签之前，请确保正在向脚本文件发送 header。在 Firefox 中，如果 crossorigin 属性存在但 Access-Control-Allow-Origin 标题不存在，则脚本不会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当调用未定义的方法时，IE 中会发生这样的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305114934878-2140937551.png&quot; alt=&quot;&quot; width=&quot;708&quot; height=&quot;166&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这相当于 Chrome 中的 “undefined’ is not a function” 错误。对于相同的逻辑错误，不同的浏览器可能会有不同的错误消息。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这是在 IE 的 Web 应用程序中使用 JavaScript 命名空间出现的一个常见问题。出现这种情况的绝大部分原因是IE无法将当前名称空间内的方法绑定到this关键字。例如，如果你有 JS Rollbar 方法的命名空间 isAwesome。通常，如果位于 Rollbar 命名空间内，则可以使用以下语法调用该 isAwesome 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.isAwesome();
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Chrome、Firefox 和 Opera 接受这种语法，IE则不接受。因此，使用 JS 命名空间时最安全的做法是：始终以实际名称空间作为前缀。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Rollbar.isAwesome();
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当调用未定义的函数时，Chrome 中就会发生这样的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305114121019-1786879068.png&quot; alt=&quot;&quot; width=&quot;755&quot; height=&quot;153&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;随着 JavaScript 编码技术和设计模式在过去几年中变得越来越复杂，回调和闭包中的自引用范围也相应增加，这是造成这种混乱现象的主要来源。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;正如下面的示例代码片段：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunction() {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clearLocalStorage();
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.timer = setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clearBoard();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; what is &quot;this&quot;?&lt;/span&gt;
  }, 0&lt;span&gt;);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;执行上面的代码会导致以下错误：“Uncaught TypeError: undefined is not a function。” 发生以上错误的原因是，当你调用 setTimeout(  )  时，实际上是在调用 window.setTimeout(  )，传递给 setTimeout(  ) 的匿名函数是在窗口对象的上下文中定义的，而该窗口对象没有 clearBoard(  ) 方法。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;符合旧版浏览器的解决方案是以变量的方式简单地将引用保存在 this 中，然后通过闭包继承。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunction () {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clearLocalStorage();
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; save reference to 'this', while it's still this!&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.timer = setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    self.clearBoard();  
  }, &lt;/span&gt;0&lt;span&gt;);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;或者，在较新的浏览器中，使用 bind(  ) 方法传递引用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunction () {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clearLocalStorage();
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.timer = setTimeout(&lt;span&gt;this&lt;/span&gt;.reset.bind(&lt;span&gt;this&lt;/span&gt;), 0);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bind to 'this'&lt;/span&gt;
&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunction(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clearBoard();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;back in the context of the right 'this'!&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这是在很多种情况，Chrome 中发生的错误，一种情况是当你调用一个不会终止的递归函数时。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305114223474-350895701.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果将值传递给超出范围的函数，也可能会发生这种情况。许多函数只接受特定范围内的数字输入值。例如，Number.toExponential( digits ) 与 Number.toFixed( digits) 接受的参数范围为从0到20，而 Number.toPrecision( digits ) 接受的数字范围为从1至21。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; Array(4294967295);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;new&lt;/span&gt; Array(-1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;range error&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; num = 2.555555&lt;span&gt;;
document.writeln(num.toExponential(&lt;/span&gt;4));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;
document.writeln(num.toExponential(-2)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;range error!&lt;/span&gt;
num = 2.9999&lt;span&gt;;
document.writeln(num.toFixed(&lt;/span&gt;2));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;
document.writeln(num.toFixed(25));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;range error!&lt;/span&gt;
num = 2.3456&lt;span&gt;;
document.writeln(num.toPrecision(&lt;/span&gt;1));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;
document.writeln(num.toPrecision(22));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;range error!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这是 Chrome 中发生的错误，因为读取了未定义长度属性的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305114321432-957965417.png&quot; alt=&quot;&quot; width=&quot;762&quot; height=&quot;187&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;通常在数组中能够找到定义的长度，但是如果数组未初始化或变量名在另一个上下文中隐藏，则可能会出现这种错误。让我们用下面的例子来解释这种错误。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; testArray= [&quot;Test&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunction(testArray) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; testArray.length; i++&lt;span&gt;) {
      console.log(testArray[i]);
    }
}
testFunction();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当用参数声明一个函数时，这些参数会成为本地参数。这意味着即使你有名称变量 testArray，函数中具有相同名称的参数仍会被视为本地参数&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;有两种方法可以解决这个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1. 删除函数声明语句中的参数：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; testArray = [&quot;Test&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Precondition: defined testArray outside of a function &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; testFunction(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; No params &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; testArray.length; i++&lt;span&gt;) {
              console.log(testArray[i]);
        }
}
testFunction();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 调用传递给我们声明的数组函数：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; testArray = [&quot;Test&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunction(testArray) {
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; testArray.length; i++&lt;span&gt;) {
        console.log(testArray[i]);
        }
}
testFunction(testArray);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当尝试访问未定义的变量时，总会返回 undefined。我们也无法获取或设置 undefined 的任何属性。在这种情况下，应用程序将抛出“Uncaught TypeError cannot set property of undefined”。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;例如，在 Chrome 浏览器中，如果 test 对象不存在，就会出现这种错误：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305114515043-527100630.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;159&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;所以就需要在访问变量之前，对变量进行定义。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;尝试访问未定义的变量或当前范围之外的变量时会引发此错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180305114541655-638309720.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;157&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果在使用事件处理系统时遇到此错误，请确保使用传入的事件对象作为参数。IE 这样的浏览器提供了全局变量事件，Chrome 会自动将事件变量附加到处理程序中，Firefox 则不会自动添加事件变量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.addEventListener(&quot;mousemove&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
  console.log(event);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;事实证明很多这些 null 或 undefined 的错误是普遍存在的。 一个类似于 Typescript 这样的好的静态类型检查系统，当设置为严格的编译选项时，能够帮助开发者避免这些错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;最后也希望通过本文，可以帮助开发者更好避免或是应对以上的10种错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原文链接：https://dzone.com/articles/top-10-javascript-errors-from-1000-projects-and-ho-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;转载请注明出自：葡萄城控件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/state-of-javascript-frameworks-2017-part-1.html&quot; target=&quot;_blank&quot;&gt;2017年 JavaScript 框架回顾 -- 前端框架&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/state-of-javascript-frameworks-2017-part-2.html&quot; target=&quot;_blank&quot;&gt;2017年 JavaScript 框架回顾 -- React生态系统&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/the-state-of-javascript-frameworks-2017-part-3-back-end-frameworks.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;2017年 JavaScript 框架回顾 -- 后端框架&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 05 Mar 2018 05:31:00 +0000</pubDate>
<dc:creator>葡萄城控件技术团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/top-10-javascript-errors.html</dc:identifier>
</item>
<item>
<title>MySQL索引优化 - demon_gdy</title>
<link>http://www.cnblogs.com/demon89/p/8507149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demon89/p/8507149.html</guid>
<description>&lt;h2 id=&quot;mysql支持的索引类型&quot;&gt;MySQL支持的索引类型&lt;/h2&gt;
&lt;h3 id=&quot;b-tree索引的特点&quot;&gt;B-tree索引的特点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、B-tree索引以B+树的结构存储数据
2、B-tree索引能够加快数据的查询速度
3、B-tree索引更适合进行行范围查找&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;b-tree结构图&quot;&gt;B-tree结构图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/995184/201803/995184-20180305075743985-302959772.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在什么情况下可以用到b树索引&quot;&gt;在什么情况下可以用到B树索引？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、全值匹配的查询
    例如我们有个订单号，订单号为 order_sn='98764322119900'
2、匹配最左前缀的查询
3、匹配列前缀查询
    例如：order_sn like '9876%'
4、匹配范围值的查找
    例如：order_sn &amp;gt; '98764322119900' and order_sn &amp;lt; '98764322119999'
5、精确匹配左前列并范围匹配另外一列
6、只访问索引的查询&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;btree索引的使用限制&quot;&gt;Btree索引的使用限制&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、如果不是按着索引最左列开始查找，则无法使用索引
2、使用索引时不能跳过索引中的列
3、Not in 和 &amp;lt;&amp;gt; 操作无法使用索引
4、如果查询中有某个列的查询范围，则其右边所有列都无法使用索引&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hash索引的特点&quot;&gt;Hash索引的特点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、Hash索引是基于Hash表实现的，只有查询条件精确匹配Hash索引中的所有列时，才能够使用到hash索引
2、对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hash索引的限制&quot;&gt;Hash索引的限制&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、使用hash索引需要二次查找
2、Hash索引无法用于排序
3、Hash索引不支持部分索引查找也不支持范围查找&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为什么要使用索引&quot;&gt;为什么要使用索引？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、索引大大减少了存储引擎需要扫描的数据量
2、索引可以帮助我们进行排序以比喵使用临时表的IO消耗，提升MySQL的能力
3、索引可以把随机I/O变为顺序I/O&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;索引是不是越多越好&quot;&gt;索引是不是越多越好？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    场景：开发人员要求来创建更多的索引，问：“为何要添加更多的索引？”，答：”因为导入速度的时候很慢，以此来加快导入的速度！！！“，so..开发人员对索引的理解不是那么的透彻，虽然索引能够为查找带来速度上的提升，但是也会对性能有一些损失，衡量标准，当创建索引带来的好处多过于消耗的时候，才是最优的选择~

1、索引会增加写操作的成本
2、太多的索引会增加查询优化器的选择时间&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;索引的优化策略&quot;&gt;索引的优化策略&lt;/h2&gt;
&lt;h4 id=&quot;索引列上不能使用表达式或函数&quot;&gt;索引列上不能使用表达式或函数&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/995184/201803/995184-20180305083344706-656842157.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;上图中的第一个select语句中使用表达式因此不满足创建索引的要求改为第二个select语句即可&quot;&gt;上图中的第一个select语句中使用表达式，因此不满足创建索引的要求，改为第二个select语句即可&lt;/h5&gt;
&lt;h4 id=&quot;前缀索引和索引列的选择性&quot;&gt;前缀索引和索引列的选择性&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/995184/201803/995184-20180305105228378-1254214448.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;联合索引&quot;&gt;联合索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;如何选择索引列的顺序
    1、经常会被使用到的列优先
    2、选择性高的列优先

覆盖索引
    优点：
        1、可以优化缓存，减少磁盘IO操作
        2、可以减少随机IO，使随机IO操作变为顺序IO操作
        3、可以避免对Innodb主键索引的二次查询
        4、可以避免MyISAM表进行系统调用
    
    无法使用覆盖索引的情况
        1、存储引擎不支持覆盖索引
        2、查询中使用了太多的列
        3、使用了双%号的like查询&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用索引优化查询&quot;&gt;使用索引优化查询&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;使用索引扫描来优化排序
    通过排序操作
    按着索引顺序扫描数据

注意事项：
    1、索引的列顺序和order by子句的顺序完全一致
    2、索引中所有列的方向(升序，降序)和order by子句完全一样
    3、order by中的字段全部在关联表中的第一张表中
    

利用索引优化🔐
    1、索引可以减少锁定的行数
    2、索引以加快处理速度，同事也加快了锁的释放&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;索引的维护和优化&quot;&gt;索引的维护和优化&lt;/h4&gt;
&lt;h5 id=&quot;删除重复复制和容易的索引&quot;&gt;删除重复复制和容易的索引&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/995184/201803/995184-20180305123546280-1459828567.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;更新索引统计信息及减少索引碎片&quot;&gt;更新索引统计信息及减少索引碎片&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;analyze table table_name&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;未完待续mysql-sql语句的优化查询请等待下篇文章&quot;&gt;未完待续，MySQL SQL语句的优化查询请等待下篇文章&lt;/h5&gt;
&lt;h5 id=&quot;原创作品转载请注明出处httpwww.cnblogs.comdemon89p8507149.html&quot;&gt;原创作品，转载请注明出处：&lt;a href=&quot;http://www.cnblogs.com/demon89/p/8507149.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/demon89/p/8507149.html&lt;/a&gt;&lt;/h5&gt;
</description>
<pubDate>Mon, 05 Mar 2018 04:52:00 +0000</pubDate>
<dc:creator>demon_gdy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/demon89/p/8507149.html</dc:identifier>
</item>
<item>
<title>R实战 第三篇：数据处理（基础） - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/5723722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/5723722.html</guid>
<description>&lt;p&gt;在实际分析数据之前，必须对数据进行清理和转化，使数据符合相应的格式，提高数据的质量。数据处理通常包括增加新的变量、处理缺失值、类型转换、数据排序、数据集的合并和获取子集等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，增加新的变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常需要根据数据框中的现有列，按照特定的公式、业务逻辑，向数据框中新增变量，常用的操作符是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算术运算符是：+ - * /，求模（%%），整除（%/%），&lt;/li&gt;
&lt;li&gt;比较运算符是：不等是 !=，相等是 ==，&lt;/li&gt;
&lt;li&gt;逻辑运算符与（&amp;amp;）、或（|）和非（!）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，有数据框mydata&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
mydata&amp;lt;-data.frame(x1=c(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;),x2=c(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;向数据框增加新的变量，通常的做法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;attach(mydata)
mydata$sumx&lt;/span&gt;&amp;lt;-x1+&lt;span&gt;x2
mydata$meanx&lt;/span&gt;&amp;lt;-(x1+x2)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
detach(mydata)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外一个做法是使用transform()函数，该函数只用于数据框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mydata&amp;lt;-&lt;span&gt; transform(mydata
    ,sumx&lt;/span&gt;=x1+&lt;span&gt;x2
    ,meanx&lt;/span&gt;=(x1+x2)/&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二，对现有变量重新编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重新编码是根据一个变量或其他多个变量的现有值，对现有的变量重新赋值，常用于把错误的值替换为正确值。重编码语句是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
variable[condition] &amp;lt;- expression
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该语句仅在condition的值为TRUE时，执行赋值操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mydata$x1[ mydata$x1&amp;lt;&lt;span&gt;3&lt;/span&gt; ]&amp;lt;- &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用更为紧凑的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mydata&amp;lt;-within(mydata,{x1[x1&amp;lt;&lt;span&gt;3&lt;/span&gt;]&amp;lt;- &lt;span&gt;1&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三，变量的重命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看数据框的变量名，函数names(df)返回变量名的向量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
names(mydata)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重命名现有的变量名，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
names(df)[index] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
names(df)[start:end] &lt;/span&gt;&amp;lt;- c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;....)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;plyr包中有一个rename()函数，可用于修改数据框的变量名，rename()函数的使用格式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
rename(df,c(colname=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,colname=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,...))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四，数据框的变量存在缺失值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺失值是指不可用值，以符号NA表示，缺失值是不可比较的，只能使用is.na()检查是否存在缺失值，通过函数na.omit()移除所有含有缺失值的观测。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
dataset&amp;lt;-within(dataset,{var1&amp;lt;- ifelse(&lt;span&gt;is&lt;/span&gt;.na(var1),&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;var1&lt;/span&gt;&lt;span&gt;)})
dataset&lt;/span&gt;&amp;lt;-na.omit(dataset)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举个例子，创建4行3列的矩阵m，并转换为数据框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt; d &amp;lt;-data.frame(matrix(sample(c(NA, &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;), &lt;span&gt;12&lt;/span&gt;, replace = TRUE), &lt;span&gt;4&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&amp;gt;&lt;span&gt; d
  X1 X2 X3
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; NA  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;&lt;span&gt; NA
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; NA NA  &lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，把变量的缺失值替换为默认值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;替换数据框中变量X1的缺失值，使用within()函数，不会修改数据框的数据，需要把函数返回的结果重新赋值给d对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt; d &amp;lt;- within(d,{X1[&lt;span&gt;is&lt;/span&gt;.na(X1)] &amp;lt;-&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}) 
&lt;/span&gt;&amp;gt;&lt;span&gt; d
  X1 X2 X3
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;&lt;span&gt; NA
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; NA  &lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，当变量出现缺失值时，移除观测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用函数 na.omit()，用于把数据框中变量为NA的观测移除，处理的结果中不任意一个观测中都不包含NA的变量值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt; d &amp;lt;-&lt;span&gt; na.omit(d)
&lt;/span&gt;&amp;gt;&lt;span&gt; d
  X1 X2 X3
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五，数据排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数据框进行排序，常用的函数是order()，默认的排序方向是升序，在排序变量前边加一个减号，按照降序方向排序。&lt;/p&gt;
&lt;p&gt;该函数返回的结果是特定变量在数据框中的行序号序列，行序号按照升序或降序排列。&lt;/p&gt;
&lt;p&gt;举个例子，创建一个数据框d：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt; d &amp;lt;-data.frame(matrix(sample(c(&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;), &lt;span&gt;12&lt;/span&gt;, replace = TRUE), &lt;span&gt;4&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&amp;gt;&lt;span&gt; d
  X1 X2 X3
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照数据框的变量X3，获取观测的升序排列，依次为：序号为3的观测、序号为1的观测、序号为4的观测和序号为2的观测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; order(d$X3)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;3&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照观测的序号的排列，从数据框中按照行序号重新获取数据，就得到按照变量X3升序的有序结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; d[order(d$X3),,]
  X1 X2 X3
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以把排序操作写的更紧凑点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
dataset = dataset[with(dataset, order(var1, -var2)), , ...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六，数据集的合并&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把两个数据集合并为一个，这涉及到向数据框中添加列，向数据框中添加行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，向数据框中添加列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向数据框中添加列，可以使用merge()函数，也可以使用cbind()函数，这两个函数的区别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cbind()函数是根据列进行合并，合并的前提是每个对象拥有相同的行数，以相同的顺序排序。&lt;/li&gt;
&lt;li&gt;merge()函数是根据列进行合并，该函数的功能类型关系型数据库的Join命令，不同要求每个对象拥有相同的行数，使用灵活。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Merge函数的语法定义： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
merge(x, y, by =&lt;span&gt; intersect(names(x), names(y)),
      by.x &lt;/span&gt;= by, by.y = by, all = FALSE, all.x = all, all.y =&lt;span&gt; all,
      sort &lt;/span&gt;= TRUE, suffixes = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
      incomparables &lt;/span&gt;= NULL, ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x,y：是进行合并的两个数据框对象；&lt;/li&gt;
&lt;li&gt;by：按照两个对象的名称相同的列进行合并；&lt;/li&gt;
&lt;li&gt;by.x，by.y：分别指定x对象和y对象匹配的列名；&lt;/li&gt;
&lt;li&gt;all：对于不满足匹配条件时，是否保留列值；如果设置为FALSE，那么相当于INNER JOIN命令，返回的结果集只保留匹配成功的数据行；如果设置为TRUE，那么相当于FULL JOIN，保留x和y中不匹配的数据行，并把不匹配的列值设置为NA；&lt;/li&gt;
&lt;li&gt;all.x，all.y：分别设置x和y是否保留列值；如果设置all.x=TRUE,all.y=FALSE，那么相当于LEFT JOIN命令，返回的结果集只保留x对象的数据行，不匹配的y对象的数据行行的列值设置为NA；如果设置为all.x=FALSE,all.y=TRUE，那么相当于RIGHT JOIN命令，返回的结果集只保留y对象的数据行，不匹配的x对象的数据行行的列值设置为NA。&lt;/li&gt;
&lt;li&gt;sort：返回的结果集是否排序，排序列是by参数的对象&lt;/li&gt;
&lt;li&gt;suffixes：后缀名，默认值是c(&quot;.x&quot;,&quot;.y&quot;)，当合并的两个对象拥有相同的列名时，R把相同的列名后面加上该后缀名，以唯一区分结果集的列名；&lt;/li&gt;
&lt;li&gt;incomparables：不能匹配的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2，向数据框中添加行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用rbind()函数，根据行进行合并，向数据框中添加数据行，相当于关系型数据库的求求并集。要求两个数据库必须拥有相同名称的变量，而变量的顺序可以不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七，选取子集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，选择变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从一个数据框中选择有限数量的变量，数据框中的元素是通过dataframe[rows_vector , colunms_vector]，如果不设置行的下标(,)，表示选择所有行，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mydata &amp;lt;- mydata[,c(col,,...)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，剔除变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把特定的变量剔除，只选入剩余的变量。操作符 %in% 返回逻辑型向量，用法是：&lt;/p&gt;
&lt;ol class=&quot;dp-xml&quot; start=&quot;1&quot;&gt;&lt;li&gt;用法 a %in% table  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;a值是否包含于table中，为真时输出TURE，为假时输出FALSE &lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如，mydata有四个变量c1,c2,c3,c4,myvars的结果是c(TRUE,FALSE,TRUE,FALSE),对该变量求非（!myvars）之后是 c(FALSE,TRUE,FALSE,TRUE)，在根据数据框的下标来选入特定的变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
myvars &amp;lt;- names(mydata) %&lt;span&gt;in&lt;/span&gt;% c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
mydata &lt;/span&gt;&amp;lt;- mydata[!myvars]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，选入观测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选入观测，可以根据观测的序号来选择，也可以根据特定的条件来选择：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mydata &amp;lt;- mydata[&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,,...]
mydata &lt;/span&gt;&amp;lt;- mydata[mydata$c1&amp;lt;=&lt;span&gt;5&lt;/span&gt; &amp;amp; mydata$c2&amp;gt;=&lt;span&gt;20,,...&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个函数which，也能用于选入观测：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
which(x, arr.ind = FALSE, useNames = TRUE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which函数返回的是逻辑值的向量，which()函数的用法是：用法which(test)，返回test为真值的位置（指针）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，根据条件选择子集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;subset()函数是选择数据库的变量和观测最简单的方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
mydata &amp;lt;- subset(mydata, c1&amp;lt;=&lt;span&gt;5&lt;/span&gt; &amp;amp; c2&amp;gt;=&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;select&lt;/span&gt;=c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,,,))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;subset()函数的语法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
subset(x, subset, &lt;span&gt;select&lt;/span&gt;, drop = FALSE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x：数据框对象&lt;/li&gt;
&lt;li&gt;subset：该参数是逻辑表达式，对于数据框而言，该参数作用于数据行，用于选择数据行。&lt;/li&gt;
&lt;li&gt;select：要选择的变量构成的向量&lt;/li&gt;
&lt;li&gt;drop：逻辑值，要剔除的变量构成的向量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;R语言实战&lt;/p&gt;
</description>
<pubDate>Mon, 05 Mar 2018 04:04:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/5723722.html</dc:identifier>
</item>
<item>
<title>高并发场景下的httpClient优化使用 - 道德楷模周鸿祎</title>
<link>http://www.cnblogs.com/bethunebtj/p/8493379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bethunebtj/p/8493379.html</guid>
<description>&lt;h2&gt;1.背景&lt;/h2&gt;
&lt;p&gt;我们有个业务，会调用其他部门提供的一个基于http的服务，日调用量在千万级别。使用了httpclient来完成业务。之前因为qps上不去，就看了一下业务代码，并做了一些优化，记录在这里。&lt;/p&gt;
&lt;p&gt;先对比前后：优化之前，平均执行时间是250ms；优化之后，平均执行时间是80ms，降低了三分之二的消耗，容器不再动不动就报警线程耗尽了，清爽~&lt;/p&gt;
&lt;h2&gt;2.分析&lt;/h2&gt;
&lt;p&gt;项目的原实现比较粗略，就是每次请求时初始化一个httpclient，生成一个httpPost对象，执行，然后从返回结果取出entity，保存成一个字符串，最后显式关闭response和client。我们一点点分析和优化：&lt;/p&gt;
&lt;h4&gt;2.1 httpclient反复创建开销&lt;/h4&gt;
&lt;p&gt;httpclient是一个线程安全的类，没有必要由每个线程在每次使用时创建，全局保留一个即可。&lt;/p&gt;
&lt;h4&gt;2.2 反复创建tcp连接的开销&lt;/h4&gt;
&lt;p&gt;tcp的三次握手与四次挥手两大裹脚布过程，对于高频次的请求来说，消耗实在太大。试想如果每次请求我们需要花费5ms用于协商过程，那么对于qps为100的单系统，1秒钟我们就要花500ms用于握手和挥手。又不是高级领导，我们程序员就不要搞这么大做派了，改成keep alive方式以实现连接复用！&lt;/p&gt;
&lt;h4&gt;2.3 重复缓存entity的开销&lt;/h4&gt;
&lt;p&gt;原本的逻辑里，使用了如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HttpEntity entity =&lt;span&gt; httpResponse.getEntity();
String response &lt;/span&gt;= EntityUtils.toString(entity);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们相当于额外复制了一份content到一个字符串里，而原本的httpResponse仍然保留了一份content，需要被consume掉，在高并发且content非常大的情况下，会消耗大量内存。并且，我们需要显式的关闭连接，ugly。&lt;/p&gt;
&lt;h2&gt;3.实现&lt;/h2&gt;
&lt;p&gt;按上面的分析，我们主要要做三件事：一是单例的client，二是缓存的保活连接，三是更好的处理返回结果。一就不说了，来说说二。&lt;/p&gt;
&lt;p&gt;提到连接缓存，很容易联想到数据库连接池。httpclient4提供了一个PoolingHttpClientConnectionManager 作为连接池。接下来我们通过以下步骤来优化：&lt;/p&gt;
&lt;h4&gt;3.1 定义一个keep alive strategy&lt;/h4&gt;
&lt;p&gt;关于keep-alive，本文不展开说明，只提一点，是否使用keep-alive要根据业务情况来定，它并不是灵丹妙药。还有一点，keep-alive和time_wait/close_wait之间也有不少故事。&lt;/p&gt;
&lt;p&gt;在本业务场景里，我们相当于有少数固定客户端，长时间极高频次的访问服务器，启用keep-alive非常合适&lt;/p&gt;
&lt;p&gt;再多提一嘴，http的keep-alive 和tcp的KEEPALIVE不是一个东西。回到正文，定义一个strategy如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ConnectionKeepAliveStrategy myStrategy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionKeepAliveStrategy() {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getKeepAliveDuration(HttpResponse response, HttpContext context) {
        HeaderElementIterator it &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BasicHeaderElementIterator
            (response.headerIterator(HTTP.CONN_KEEP_ALIVE));
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
            HeaderElement he &lt;/span&gt;=&lt;span&gt; it.nextElement();
            String param &lt;/span&gt;=&lt;span&gt; he.getName();
            String value &lt;/span&gt;=&lt;span&gt; he.getValue();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; param.equalsIgnoreCase
               (&lt;/span&gt;&quot;timeout&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Long.parseLong(value) * 1000&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 60 * 1000&lt;span&gt;;//如果没有约定，则默认定义时长为60s
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 配置一个PoolingHttpClientConnectionManager&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
PoolingHttpClientConnectionManager connectionManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PoolingHttpClientConnectionManager();
connectionManager.setMaxTotal(5&lt;/span&gt;00&lt;span&gt;);
connectionManager.setDefaultMaxPerRoute(&lt;/span&gt;50);//例如默认每路由最高50并发，具体依据业务来定
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以针对每个路由设置并发数。&lt;/p&gt;
&lt;h4&gt;3.3 生成httpclient&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
httpClient =&lt;span&gt; HttpClients.custom()
                .setConnectionManager(connectionManager)
                .setKeepAliveStrategy(kaStrategy)
                .setDefaultRequestConfig(RequestConfig.custom().setStaleConnectionCheckEnabled(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build())
                .build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：使用setStaleConnectionCheckEnabled方法来逐出已被关闭的链接不被推荐。更好的方式是手动启用一个线程，定时运行closeExpiredConnections 和closeIdleConnections方法，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IdleConnectionMonitorThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpClientConnectionManager connMgr;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shutdown;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IdleConnectionMonitorThread(HttpClientConnectionManager connMgr) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.connMgr =&lt;span&gt; connMgr;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;shutdown) {
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
                    wait(&lt;/span&gt;5000&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Close expired connections&lt;/span&gt;
&lt;span&gt;                    connMgr.closeExpiredConnections();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optionally, close connections
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; that have been idle longer than 30 sec&lt;/span&gt;
                    connMgr.closeIdleConnections(30&lt;span&gt;, TimeUnit.SECONDS);
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; terminate&lt;/span&gt;
&lt;span&gt;        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shutdown() {
        shutdown &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            notifyAll();
        }
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.4 使用httpclient执行method时降低开销&lt;/h4&gt;
&lt;p&gt;这里要注意的是，不要关闭connection。&lt;/p&gt;
&lt;p&gt;一种可行的获取内容的方式类似于，把entity里的东西复制一份：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
res = EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;&lt;span&gt;);
EntityUtils.consume(response1.getEntity());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，更推荐的方式是定义一个ResponseHandler，方便你我他，不再自己catch异常和关闭流。在此我们可以看一下相关的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(&lt;span&gt;final&lt;/span&gt; HttpHost target, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpRequest request,
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ResponseHandler&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt; responseHandler, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpContext context)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClientProtocolException {
        Args.notNull(responseHandler, &lt;/span&gt;&quot;Response handler&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; HttpResponse response =&lt;span&gt; execute(target, request, context);

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; T result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;=&lt;span&gt; responseHandler.handleResponse(response);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Exception t) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; HttpEntity entity =&lt;span&gt; response.getEntity();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                EntityUtils.consume(entity);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Exception t2) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Log this exception. The original exception is more
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; important and will be thrown to the caller.&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.log.warn(&quot;Error consuming content after an exception.&quot;&lt;span&gt;, t2);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) t;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; IOException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (IOException) t;
            }
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(t);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Handling the response was successful. Ensure that the content has
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; been fully consumed.&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; HttpEntity entity =&lt;span&gt; response.getEntity();
        EntityUtils.consume(entity);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看这里看这里&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，如果我们使用resultHandler执行execute方法，会最终自动调用consume方法，而这个consume方法如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; consume(&lt;span&gt;final&lt;/span&gt; HttpEntity entity) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (entity == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (entity.isStreaming()) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; InputStream instream =&lt;span&gt; entity.getContent();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                instream.close();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到最终它关闭了输入流。&lt;/p&gt;
&lt;h2&gt;4.其他&lt;/h2&gt;
&lt;p&gt;通过以上步骤，基本就完成了一个支持高并发的httpclient的写法，下面是一些额外的配置和提醒：&lt;/p&gt;
&lt;h4&gt;4.1 httpclient的一些超时配置&lt;/h4&gt;
&lt;p&gt;CONNECTION_TIMEOUT是连接超时时间，SO_TIMEOUT是socket超时时间，这两者是不同的。连接超时时间是发起请求前的等待时间；socket超时时间是等待数据的超时时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
HttpParams params = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BasicHttpParams();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置连接超时时间&lt;/span&gt;
Integer CONNECTION_TIMEOUT = 2 * 1000; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置请求超时2秒钟 根据业务调整&lt;/span&gt;
Integer SO_TIMEOUT = 2 * 1000; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置等待数据超时时间2秒钟 根据业务调整

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义了当从ClientConnectionManager中检索ManagedClientConnection实例时使用的毫秒级的超时时间
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个参数期望得到一个java.lang.Long类型的值。如果这个参数没有被设置，默认等于CONNECTION_TIMEOUT，因此一定要设置。&lt;/span&gt;
Long CONN_MANAGER_TIMEOUT = 500L; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在httpclient4.2.3中我记得它被改成了一个对象导致直接用long会报错，后来又改回来了&lt;/span&gt;
&lt;span&gt; 
params.setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, CONNECTION_TIMEOUT);
params.setIntParameter(CoreConnectionPNames.SO_TIMEOUT, SO_TIMEOUT);
params.setLongParameter(ClientPNames.CONN_MANAGER_TIMEOUT, CONN_MANAGER_TIMEOUT);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在提交请求之前 测试连接是否可用&lt;/span&gt;
params.setBooleanParameter(CoreConnectionPNames.STALE_CONNECTION_CHECK, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;另外设置http client的重试次数，默认是3次；当前是禁用掉（如果项目量不到，这个默认即可）&lt;/span&gt;
httpClient.setHttpRequestRetryHandler(&lt;span&gt;new&lt;/span&gt; DefaultHttpRequestRetryHandler(0, &lt;span&gt;false&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2 如果配置了nginx的话，nginx也要设置面向两端的keep-alive&lt;/h4&gt;
&lt;p&gt;现在的业务里，没有nginx的情况反而比较稀少。nginx默认和client端打开长连接而和server端使用短链接。注意client端的keepalive_timeout和keepalive_requests参数，以及upstream端的&lt;span class=&quot;line&quot;&gt;keepalive参数设置，这三个参数的意义在此也不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;line&quot;&gt;以上就是我的全部设置。通过这些设置，成功地将原本每次请求250ms的耗时降低到了80左右，效果显著。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;完。&lt;/p&gt;

</description>
<pubDate>Mon, 05 Mar 2018 03:32:00 +0000</pubDate>
<dc:creator>道德楷模周鸿祎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bethunebtj/p/8493379.html</dc:identifier>
</item>
</channel>
</rss>