<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HDFS配额管理（实战） - 小圆圆大团团</title>
<link>http://www.cnblogs.com/staryea/p/8573812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/staryea/p/8573812.html</guid>
<description>
&lt;p&gt; &lt;strong&gt;概述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hadoop分布式文件系统(HDFS)允许管理员为使用的名称和单独目录使用的空间数量设置配额。名称配额和空间配额是独立运作的，但这两类配额的管理和实施是密切相关的。&lt;/p&gt;
&lt;h3&gt;Name Quotas：&lt;/h3&gt;
&lt;p&gt;名称配额对根目录下的树的&lt;strong&gt;文件和目录&lt;/strong&gt;的数量进行严格的限制。&lt;/p&gt;
&lt;p&gt;如果超出配额，文件和目录创建失败。配额不变&lt;/p&gt;
&lt;p&gt;对于重命名的目录;如果操作将导致配额冲突，则重命名操作失败。&lt;/p&gt;
&lt;p&gt;即使目录违反了新的配额，设置配额的操作仍然会成功。新创建的目录没有相关的配额。最大的配额是Long.Max_Value。一个命令的配额会使目录保持空。(是的，一个目录对它自己的配额有影响!)&lt;br/&gt;配额限制制与fsimage永久生效的。当开始时，如果fsimage违反了配额，就会对此类违规行为进行警告。&lt;em id=&quot;__mceDel&quot;&gt;（对于一开始设置配额的时候目录下文件个数已经超过了设置的个数，则对此类操作进行告警，操作动作不会失败）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;设置或删除一个配额都会创建日志目录&lt;/p&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;设置目录的配额空间，让目录下存储的文件不超过N 个&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;&lt;tt&gt;hdfs dfsadmin -setQuota &amp;lt;N&amp;gt; &amp;lt;directory&amp;gt;...&amp;lt;directory&amp;gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Set the name quota to be N for each directory. Best effort for each directory, with faults reported if N is not a positive long integer, the directory does not exist or it is a file, or the directory would immediately exceed the new quota.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设置每个目录的名称配额为N个。对于受影响每个目录。如果N不是一个正整数，如果目录不存在，或者是一个文件，或者目录将立即超过新的配额。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;       清除目录的配额空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Space Quotas&lt;/h3&gt;
&lt;p&gt;空间配额对于根目录下的树中的文件所使用的字节数是一个严格的限制。&lt;/p&gt;
&lt;p&gt;如果配额不允许写入一个完整的块，块分配就会失败。一个块的每个副本都与配额相对应。&lt;/p&gt;
&lt;p&gt;对于重命名的目录，配额不变&lt;/p&gt;
&lt;p&gt;如果重命名操与设置的配额冲突，则重命名操作失败。&lt;/p&gt;
&lt;p&gt;新创建的目录没有相关的配额。&lt;/p&gt;
&lt;p&gt;配额的最大值是Long.Max_Value。&lt;/p&gt;
&lt;p&gt;配额为零的情况下仍然允许创建文件，但不能往文件中写东西。&lt;/p&gt;
&lt;p&gt;创建目录不使用主机文件系统空间，也不要计算空间配额。&lt;/p&gt;
&lt;p&gt;用于保存文件元数据的主机文件系统空间不被计算在配额内。&lt;/p&gt;
&lt;p&gt;对文件的预期复制因子收取配额;更改一个文件的复制份数将会导致信用卡或借方配额。（配额考虑到了复制，当1个文件是1G，复制是3份，设置配额是2G 则上传报错）&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;配额现在制与fsimage是持久的。当开始时，如果fsimage立即违反了配额，就会对此类违规行为进行警告。设置或删除一个配额会创建一个日志条目。（对于一开始设置配额的时候目录下配额空间已经超过了设置的空间，则对此类操作进行告警，操作动作不会失败）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      设置目录的存储空间配额&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;7&quot;&gt;&lt;tt&gt;hdfs dfsadmin -setSpaceQuota &amp;lt;N&amp;gt; &amp;lt;directory&amp;gt;...&amp;lt;directory&amp;gt;&lt;/tt&gt;
&lt;p&gt;Set the space quota to be N bytes for each directory. This is a hard limit on total size of all the files under the directory tree. The space quota takes replication also into account, i.e. one GB of data with replication of 3 consumes 3GB of quota. N can also be specified with a binary prefix for convenience, for e.g. 50g for 50 gigabytes and 2t for 2 terabytes etc. Best effort for each directory, with faults reported if N is neither zero nor a positive integer, the directory does not exist or it is a file, or the directory would immediately exceed the new quota.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设置每个目录的空间配额为N个字节。这是对目录树下所有文件的总大小的严格限制。空间配额也考虑到复制，即1 GB的数据复制3消耗3GB的配额。N也可以用一个二进制前缀指定为方便起见,如50 g为50 g,2 t 2 tb等。尽最大努力为每个目录,与缺陷报告如果N是零和一个正整数,目录不存在或它是一个文件,或者目录会立即超过新配额。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;清除目录的存储空间配额命令&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;&lt;tt&gt;hdfs dfsadmin -clrSpaceQuota &amp;lt;directory&amp;gt;...&amp;lt;director&amp;gt;&lt;/tt&gt;
&lt;p&gt;Remove any space quota for each directory. Best effort for each directory, with faults reported if the directory does not exist or it is a file. It is not a fault if the directory has no quota.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;移除每个目录的空间配额。对于每个有效的目录，如果目录不存在或它是一个文件，就会报告设置错误。对应目录来说没有配额不会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试一，配额文件和目录限制：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置目录的文件+目录总数不超过3，（这里不包含3 应该是总数是２）&lt;/p&gt;
&lt;p&gt;－查看当前情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315145533481-808264285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hz目录下有1个文件 2.txt&lt;/p&gt;
&lt;p&gt;执行  hdfs dfsadmin -setQuota 3 /user/hz&lt;/p&gt;
&lt;p&gt;创建目录a --成功&lt;/p&gt;
&lt;p&gt;创建目录b--失败（报超出配额限制，可见参数是小于不包含）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315145606486-1042828845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 查询目录下文件数 是2个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315145721777-1739995419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尝试上传一个文件（继续报错，配额超出）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315145835733-314960581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 对于已经有2个文件，修改配额为1 则不报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315150049143-305080030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;清除配额，上传文件成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315150327434-1424312291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;测试二，配额空间限制：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 查看当前的空间大小&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315151017054-2016138146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明当前空间配额最小为 17*3=51字节&lt;/p&gt;
&lt;p&gt;当设置配额小于 目前已经有的大小时，则会从其他地方借用，显示为-&lt;/p&gt;
&lt;p&gt;设置配额为50，命令执行成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315151237915-1991910214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此情况下 无法在继续传文件&lt;/p&gt;
&lt;p&gt;创建一个32字节的文件 测试是否副本占用配额信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315151516052-1464761136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上传文件，32+17=49&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315151418656-1645223476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 测试结果报错，超出了配额限制&lt;/p&gt;
&lt;p&gt;重新设置配额为60&lt;/p&gt;
&lt;p&gt;查询当前配额剩余  =9 &lt;/p&gt;
&lt;p&gt;计算为 60-17*3副本=9&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315151857722-405925649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结：对于空间限制，配额空间是计算副本数的&lt;/p&gt;

&lt;p&gt; 测试 创建目录是否占用配额空间&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1342851/201803/1342851-20180315152151071-2013354793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配额空间不变化&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;http://hadoop.apache.org/docs/r2.4.1/hadoop-project-dist/hadoop-hdfs/HdfsQuotaAdminGuide.html#Space_Quotas&lt;/p&gt;
</description>
<pubDate>Thu, 15 Mar 2018 07:20:00 +0000</pubDate>
<dc:creator>小圆圆大团团</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/staryea/p/8573812.html</dc:identifier>
</item>
<item>
<title>记录一个前端bug的解决过程 - 吕大豹</title>
<link>http://www.cnblogs.com/lvdabao/p/8573778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvdabao/p/8573778.html</guid>
<description>&lt;p&gt;人在江湖飘，哪能不挨刀。&lt;/p&gt;
&lt;p&gt;我挨了重重一bug。严格来讲这可能是我职业生涯以来的首个悲惨经历，因为凭我的知识储备和经验，基本上任何可重现的bug都是可解的。然而这个bug却困扰了我三个月之久，它具有以下生理特征：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;后台日志能统计到异常，偶发、低频&lt;/li&gt;
&lt;li&gt;报异常的用户设备不具有规律性，什么手机都有&lt;/li&gt;
&lt;li&gt;我们自己无法复现，任何设备、任何环境都没复现&lt;/li&gt;
&lt;li&gt;打电话回访报异常的用户，确实存在问题&lt;/li&gt;
&lt;li&gt;客服未接到用户主动反馈这个异常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此bug并不是js报错，而是一个业务逻辑的错误。表现是，用户提交的数据莫名缺失。场景是以下这个界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/520134/201803/520134-20180315151441457-948225884.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当用户填满所有的空之后，提交按钮变为可用状态，数据放进一个数组中提交上来。后台有报错日志显示，用户提交上来的有些是空数组，有些是数组中缺了几项。&lt;/p&gt;
&lt;p&gt;问题在于，提交前是有校验的，用户不可能提交上来这种未通过校验的数据。并且还是偶发的啊，如果是逻辑写错了，那应该全部会报错，我们在测试的时候肯定会发现。&lt;/p&gt;
&lt;p&gt;最棘手的地方是，我们压根没重现过这个情况，找各种同事、各种手机、各种胡乱操作，一次都没重现出来。这就给调试带来很大的麻烦，只能是猜测哪里可能出问题，然后去验证。但是根本没法去验证啊。。。重现不了，又如何判断是成功fix了。&lt;/p&gt;
&lt;p&gt;看来能验证的手段就只剩一个：线上日志。猜问题、上线、看日志。&lt;/p&gt;
&lt;p&gt;这是一个痛苦的过程。界面虽然简单，这却是一个庞杂的项目。因为题型众多，抽离了很多组件，为了公用和灵活扩展，组件嵌套深度有五层之多。其架构复杂程度在我的职业生涯中也能排TOP3.&lt;/p&gt;
&lt;p&gt;拿题干的渲染来说，就有：公式图片转LaTeX、mathjax渲染公式、渲染公式上的空、给空编号、模拟光标、自动focus空、动态计算字体大小等诸多流程。而且下方那个键盘还是我们H5模拟的，并不是系统键盘。更别提还有校验逻辑、判分逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前n次尝试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看距离上一版有哪些改动，抹去有嫌疑的改动，看日志是否正常。尴尬的是，这是一次重大重构，改动的地方还特别多。于是一场盲人摸象式的远程debug行动开始了。&lt;/p&gt;
&lt;p&gt;一次又一次的上线、观察日志、下线。不断排除了一些相关的功能，始终未能诊断到问题所在。甚至连我很确信的地方都尝试了，还是找不到问题。前前后后尝试了二十多次吧，改到我都怀疑人生了。领导看了这些上线记录都怒了，说你这上上下下的搞鸡毛呢。我也很崩溃啊。&lt;/p&gt;
&lt;p&gt;看来用这个盲人摸象手段是搞不定了，我意识到了情况的严重性，暗暗感觉这可能不是轻易能解决的，吕某一定使出毕生所学，为民除害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第n+1次尝试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然有那么多的用户日志，我们自己为何重现不了？这是我一直纠结的。于是再次进行疯狂测试。&lt;/p&gt;
&lt;p&gt;皇天不负有心人，我竟然真的给重现出来了！操作是这样的：填好空，两个手指同时按下提交按钮和删除按钮。这样的话既通过了校验，又能在提交之前把数据给删了。&lt;/p&gt;
&lt;p&gt;发现这个骚操作的时候我是很兴奋的，但是会有那么多用户这么操作吗？显然不太可能。此时我又想到，提交按钮和删除按钮是挨着的，会不会是用户按提交的时候误触了删除键。这还算比较合理，毕竟用户是小学生嘛，操作不一定那么精准的。&lt;/p&gt;
&lt;p&gt;我兴奋不已的进行验证。在删除键和提交键之间加了“下一空”按钮（通过配置），这样用户保证不会误触了。&lt;/p&gt;
&lt;p&gt;上线，日志依旧。我摔啊，看来并不是误触的事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第n+2次尝试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着bug拖的时间越来越长，我的心态也有点焦躁。但思路还是聚焦在删除按钮上，毕竟这是好不容易发现能重现的。&lt;/p&gt;
&lt;p&gt;如何能够既点提交又点删除呢？这时候我想到了点击穿透（键盘为了响应快，使用了touchstart事件）。因为在点完提交的时候，模拟键盘会收起来，而收起的过程中删除按钮会经过提交按钮的位置。根据点击穿透的原理，如果此时派发的click事件作用到了删除按钮上，那岂不是就算点到了？&lt;/p&gt;
&lt;p&gt;我都有点佩服我的想象力了，黔驴技穷了啊，试吧。避免点击穿透有两种方式，阻止click事件的默认动作，或者是让元素收起的时间延迟。我选了后者。&lt;/p&gt;
&lt;p&gt;上线，日志依旧。我吐血。后来一想，删除按钮根本都没监听click事件啊，哪来的穿透。真是病急乱投医了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第n+3次尝试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扫代码，发现一个很重的疑点。答案是个数组，是引用类型。由于复杂的组件关系，这个引用类型的数据可以被多个组件访问到。&lt;/p&gt;
&lt;p&gt;使用可变数据的时候有个隐患，它可能在你不知道的地方被修改。代码是vue写的，有些组件中含有watch，搞不好是意外进了哪里的watch，在点完提交的时候也会把数据给更改了。&lt;/p&gt;
&lt;p&gt;这个猜测我觉得是合理的，在开发阶段我就曾因为未使用immutable数据而隐隐担心过。好了，快速验证吧。在点完提交按钮的时候，我把答案数据给克隆了一份，然后再进行判分和提交的操作。这下就不担心已经拿到的数据被篡改了。&lt;/p&gt;
&lt;p&gt;上线，日志依旧。继续吐血。&lt;/p&gt;
&lt;p&gt;不过这次也缩小了嫌疑范围，看来数据不是在点完提交的时候被篡改了，而是提交上来的就有问题。匪夷所思的是，用户是如何绕过校验把数据提交上来的呢？难不成是我的校验函数有问题，这个地方把数据给改了？扫了一遍代码，无果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第n+4次尝试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时聚焦到了用户在填写答案的时候发生了什么。我像侦探一样用放大镜一遍遍看代码，然而好多天的追踪，并没有找到什么有用线索。&lt;/p&gt;
&lt;p&gt;直到有一天，那天阳光明媚天空飘着朵朵白云，感觉有什么好事要发生。QA在反馈群里发了一张截图，说公式解析的那个点点点一直不消失（正在解析的状态），而且空里也输不进内容去。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/520134/201803/520134-20180315151533727-886428437.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我敏感的神经顿时嗅到了一丝线索。题干使用了mathjax来解析公式，而mathjax在解析的过程中会按需加载一些字体文件，而且还会扫描页面节点，并生成大量的DOM节点。这对浏览器来说是个压力不小的事情，更何况是移动端。&lt;/p&gt;
&lt;p&gt;我马上再扫描公式处理的代码，由于有些空会在公式上出现，所以代码是在等公式渲染完后统一给空编序号，然后进行自动focus，而且自动focus的时候还会首先给答案赋值。天呐，问题该不会出现在这里吧！公式的渲染过程可能有延时，用户可能在这个时间进行点什么操作！&lt;/p&gt;
&lt;p&gt;首先这符合偶发这个事实，因为公式解析中出现抖动网络延迟什么的也是偶然现象。再者公司的网络快，用户的网络可能慢，这也符合我们一直未重现的事实。感觉这次很靠谱了！很多侦探电视都是这么演的啊，主人公通过别人无意的一句话联想到了线索，然后案件破解，真相大白！对对对，就是这个感觉！&lt;/p&gt;
&lt;p&gt;赶快在代码层面做优化，尽可能早地处理没有公式的空，有公式的地方也确保执行完后用户才能输入。&lt;/p&gt;
&lt;p&gt;优化完毕，回归测试，万事俱备，只等线上验证，一锤定音！&lt;/p&gt;
&lt;p&gt;结果......日志还有啊！啊噗！，电视里都是骗人的啊！&lt;/p&gt;
&lt;p&gt;等等！日志虽然还有，但好像少了耶！难道这次的优化是有作用的？虽然从理论上能解释一些作用，但还存在的日志又表示什么呢？难道造成丢答案的原因不止一个？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第n+5次尝试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间一天天过去，我还是没找到什么有力线索。中陆续有一些猜测，打了一些日志点后还是无果。看着QA同事紧缩的眉头，领导关切的询问，我也越发焦虑了起来。因为我这是一个公共组件库，有其他项目在等着使用，如果我的bug解决不了，将影响其他项目的进度。&lt;/p&gt;
&lt;p&gt;又是阳光明媚的一天，天空飘着朵朵白云。我无意跟另一位后端同事聊到了这个话题，他随口一说：应该是超时自动提交的吧。&lt;/p&gt;
&lt;p&gt;什么？什么！自动提交？！我突然像被闪电击中。因为我写的这是个公共组件，同时也对外暴漏了一些API，比如提交答案就是其中一个。我提供的是答题界面的组件，但是别人项目中有倒计时的场景，超时后会调用我的提交API，把用户答案提交上去。&lt;/p&gt;
&lt;p&gt;如果超时的时候，用户什么也没填，那岂不是把空答案给提交上去了！！！根本没有校验函数什么事，是别人调API提交的啊。&lt;/p&gt;
&lt;p&gt;我哭了。难怪没用户反馈呢，时间到了自动提交空答案，他们没理由反馈啊。难怪我们自己没重现呢，一直沉浸在怎么乱点出来。就算QA同学看到了超时提交的时候，也无法意识此时是空答案。&lt;/p&gt;
&lt;p&gt;没错，真相就是它了，修改相关逻辑后上线，果然报错日志没了。困扰我三个月的bug终于解决了！我闭上眼睛，心里默默放了一把鞭炮。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前前后后三个月时间，总算是找到了问题所在。其实第n+4次是解决了一些问题的，最后一次是彻底解决，我用实际行动证明了，真相不止一个。而这件沸沸扬扬的丢答案bug事件，也给了我很多启示。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;做重构的时候要格外小心逻辑更改，重构后一定要跑通所有case。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;排查问题的方式，这期间我使用了各种对照试验，各种源码级别的排查&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用vue做复杂项目的时候要格外注意组件的嵌套层数，少写watch，避免程序执行顺序的混乱&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设计对外API时，要考虑健壮性，不光考虑传入参数的不稳定，还要考虑当前上下文的不稳定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 15 Mar 2018 07:18:00 +0000</pubDate>
<dc:creator>吕大豹</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvdabao/p/8573778.html</dc:identifier>
</item>
<item>
<title>[翻译]简单的实现一个Promise - 水果味的C</title>
<link>http://www.cnblogs.com/SyMind/p/8530429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SyMind/p/8530429.html</guid>
<description>&lt;p&gt;&lt;span&gt;        英文原文为：https://www.promisejs.org/implementing/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 状态机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        因为 promise 对象是一个状态机，所以我们首先应该定义将要用到的状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; PENDING = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; FULFILLED = 1&lt;span&gt;;
VAR REJECTED &lt;/span&gt;= 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Promise () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以存储这些状态，PENDING、FULFILLED 或 REJECTED&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; PENDING;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当为 FULFILLED 或 REJECTED 状态时，存储值或错误信息&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储被 .then 或 .done 方法调用的成功和失败的处理函数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; handlers =&lt;span&gt; [];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 转换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        接着，让我们来考虑一下两个可能发生的重要转换，fulfilling 和 rejecting：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; PENDING = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; FULFILLED = 1&lt;span&gt;;
var REJECTED &lt;/span&gt;= 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Promise () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以存储这些状态，PENDING、FULFILLED 或 REJECTED&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; PENDING;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当为 FULFILLED 或 REJECTED 状态时，存储值或错误信息&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储被 .then 或 .done 方法调用的成功和失败的处理函数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; handlers =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fulfill (result) {
        state &lt;/span&gt;=&lt;span&gt; FULFILLED;
        value &lt;/span&gt;=&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reject (error) {
        state &lt;/span&gt;=&lt;span&gt; REJECTED;
        value &lt;/span&gt;=&lt;span&gt; error;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这给了我们基础的低层转换，我们现在来考虑更高层的转换 resolve。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; PENDING = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; FULFILLED = 1&lt;span&gt;;
var REJECTED &lt;/span&gt;= 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Promise () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以存储这些状态，PENDING、FULFILLED 或 REJECTED&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; PENDING;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当为 FULFILLED 或 REJECTED 状态时，存储值或错误信息&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储被 .then 或 .done 方法调用的成功和失败的处理函数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; handlers =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fulfill (result) {
        state &lt;/span&gt;=&lt;span&gt; FULFILLED;
        value &lt;/span&gt;=&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reject (error) {
        state &lt;/span&gt;=&lt;span&gt; REJECTED;
        value &lt;/span&gt;=&lt;span&gt; error;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolve (result) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; then =&lt;span&gt; getThen(result);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (then) {
                doResolve(then.bind(result), resolve, reject);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            fulfill(result);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
            reject(e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        注意 resolve 如何判断接收的是一个 promise 对象还是一个基本值（plain value），如果是一个 promise 对象，如何等待他完成。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 
 * 检查值是否是一个 Promise 对象, 如果他是,
 * 返回这个 Promise 对象的‘then’方法。
 *
 * @param {Promise|Any} value
 * @return {Function|Null}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getThen (value) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &amp;amp;&amp;amp; (t === 'object' || t === 'function'&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; then =&lt;span&gt; value.then
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; then === 'function'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; then;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 潜在的解析函数，以确保 onFulfilled 和 onRejected 只执行其中的一个
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; doResolve (fn, onFulfilled, onRejected) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        fn (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (done) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
            done &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            onFulfilled(value);
        }, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (reason) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (done) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
            done &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            onRejected(reason);
        })
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ex) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (done) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        done &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        onRejected(ex);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 构造&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        我们现在有了完整的内部状态机，但我们还没有暴露出解决承诺（resolving promise）或观察它的方法。让我们从增加一个解决 promise 的方法开始。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; PENDING = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; FULFILLED = 1&lt;span&gt;;
VAR REJECTED &lt;/span&gt;= 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Promise () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以存储这些状态，PENDING、FULFILLED 或 REJECTED&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; PENDING;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当为 FULFILLED 或 REJECTED 状态时，存储值或错误信息&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储被 .then 或 .done 方法调用的成功和失败的处理函数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; handlers =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fulfill (result) {
        state &lt;/span&gt;=&lt;span&gt; FULFILLED;
        value &lt;/span&gt;=&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reject (error) {
        state &lt;/span&gt;=&lt;span&gt; REJECTED;
        value &lt;/span&gt;=&lt;span&gt; error;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolve (result) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; then =&lt;span&gt; getThen(result);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (then) {
                doResolve(then.bind(result), resolve, reject);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            fulfill(result);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
            reject(e);
        }
    }

    doResolve(fn, resolve, reject);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        你可以看到，我们复用了 doResolve，因为我们有另一个不可信的解析。fn 允许多次调用 resolve 和 reject，甚至抛出异常。我们要确保 promise 只 resolve 一次或 reject 一次，然后再也不会过渡到另一个状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 观察（使用 .done）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        我们现在拥有一个已完成的状态机，但是我们仍没有办法去观察它的变化。我们的最终目的是实现 .then，但是 .done 的语义要简单的多，所以我们首先实现它。&lt;/p&gt;
&lt;p&gt;        我们这里的目标是实现 promise.done(onFulfilled, onRejected):&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只调用 onFulfilled 或 onRejected 中的一个&lt;/li&gt;
&lt;li&gt;它是调用一次&lt;/li&gt;
&lt;li&gt;它在下一时刻被调用（例如，在 .done 方法已经返回后）&lt;/li&gt;
&lt;li&gt;不管我们在调用之前或之后是否解决了这个问题，它都被调用了。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; PENDING = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; FULFILLED = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; REJECTED = 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Promise (fn) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以存储这些状态，PENDING、FULFILLED 或 REJECTED&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; PENDING;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当为 FULFILLED 或 REJECTED 状态时，存储值或错误信息&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储被 .then 或 .done 方法调用的成功和失败的处理函数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; handlers =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fulfill(result) {
        state &lt;/span&gt;=&lt;span&gt; FULFILLED;
        value &lt;/span&gt;=&lt;span&gt; result;
        handlers.forEach(handle);
        handlers &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reject (result) {
        state &lt;/span&gt;=&lt;span&gt; REJECTED
        value &lt;/span&gt;=&lt;span&gt; result
        handlers.forEach(handle)
        handlers &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolve (result) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; then =&lt;span&gt; getThen(result)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (then) {
                doResolve(then, resolve, reject)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
            }
            fulfill(result)
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ex) {
            reject(ex)
        }
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; handle (handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state ===&lt;span&gt; PENDING) {
            handlers.push(handler);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state === FULFILLED &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; handlers.onFulfilled === 'function'&lt;span&gt;) {
                handler.onFulfilled(value);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state === REJECTED &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; handlers.onRejected === 'function'&lt;span&gt;) {
                handler.onRejected(value);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.done = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (onFulfilled, onRejected) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确保我们总是异步执行的&lt;/span&gt;
        setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            handler({
                onFulfilled: onFulfilled,
                onRejected: onRejected
            })
        }, &lt;/span&gt;0&lt;span&gt;)
    }
    
    doResolve(fn, resolve, reject);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        当 Promise 被解决或拒绝时，我们要确保去通知 handlers。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 观察（使用 .then）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        现在我们已经实现了 .done，我们可以简单的实现 .then 来实现相同的事情，但是在程序中构造一个新的 Promise 对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.then = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (onFulfilled, onRejected) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.done(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (result) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; onFulfilled === 'function'&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolve(onFulfilled(result));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ex) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; reject(ex);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolve(result);
            }
        }, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; onRejected === 'function'&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolve(onRejected(error));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ex) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; reject(ex);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; reject(error);
            }
        });
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 15 Mar 2018 06:45:00 +0000</pubDate>
<dc:creator>水果味的C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SyMind/p/8530429.html</dc:identifier>
</item>
<item>
<title>深度剖析HashMap的数据存储实现原理（看完必懂篇） - SinghamYuan</title>
<link>http://www.cnblogs.com/singhamxiao/p/8573540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/singhamxiao/p/8573540.html</guid>
<description>&lt;h4 id=&quot;深度剖析hashmap的数据存储实现原理看完必懂篇&quot;&gt;深度剖析HashMap的数据存储实现原理（看完必懂篇）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;具体的原理分析可以参考一下两篇文章，有透彻的分析！本文在此基础上加入个人理解和完善部分纰漏！！！

参考资料：

    1. https://www.jianshu.com/p/17177c12f849 [JDK8中的HashMap实现原理及源码分析]
    
    2. https://tech.meituan.com/java-hashmap.html [Java 8系列之重新认识HashMap]
    
1、关键字段：

    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // 2^4

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &amp;lt;= 1&amp;lt;&amp;lt;30.
     */
    static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 2^30

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * The bin count threshold for using a tree rather than list for a
     * bin.  Bins are converted to trees when adding an element to a
     * bin with at least this many nodes. The value must be greater
     * than 2 and should be at least 8 to mesh with assumptions in
     * tree removal about conversion back to plain bins upon
     * shrinkage.
     *
     * 一个桶的树化阈值
     * 当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点
     * 这个值必须为 8，要不然频繁转换效率也不高
     */
    static final int TREEIFY_THRESHOLD = 8;
    
    /**
     * The bin count threshold for untreeifying a (split) bin during a
     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
     * most 6 to mesh with shrinkage detection under removal.
     *
     * 一个树的链表还原阈值
     * 当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构
     * 这个值应该比上面那个小，至少为 6，避免频繁转换
     */
    static final int UNTREEIFY_THRESHOLD = 6;
    
    /**
     * The smallest table capacity for which bins may be treeified.
     * (Otherwise the table is resized if too many nodes in a bin.)
     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
     * between resizing and treeification thresholds.
     *
     * 哈希表的最小树形化容量
     * 当哈希表中的容量大于这个值时，表中的桶才能进行树形化
     * 否则桶内元素太多时会扩容，而不是树形化
     * 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
     */
    static final int MIN_TREEIFY_CAPACITY = 64;
    
    /* ---------------- Fields -------------- */

    /**
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     * 
     * 为了更好表示本文称之为桶数组
     */
    transient Node&amp;lt;K,V&amp;gt;[] table;

    /**
     * Holds cached entrySet(). Note that AbstractMap fields are used
     * for keySet() and values().
     */
    transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;

    /**
     * The number of key-value mappings contained in this map.
     */
    transient int size;

    /**
     * The number of times this HashMap has been structurally modified
     * Structural modifications are those that change the number of mappings in
     * the HashMap or otherwise modify its internal structure (e.g.,
     * rehash).  This field is used to make iterators on Collection-views of
     * the HashMap fail-fast.  (See ConcurrentModificationException).
     */
    transient int modCount;

    /**
     * The next size value at which to resize (capacity * load factor).
     *
     * @serial
     */
    // (The javadoc description is true upon serialization.
    // Additionally, if the table array has not been allocated, this
    // field holds the initial array capacity, or zero signifying
    // DEFAULT_INITIAL_CAPACITY.)
    int threshold;

    /**
     * The load factor for the hash table.
     *
     * @serial
     */
    final float loadFactor;
    
    /**
     * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

    /**
     * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }

    /**
     * Constructs a new &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the same mappings as the
     * specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;.  The &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
    public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }

2、首先针对很多文章中的纰漏语句：如果一个桶中链表内的元素个数超过 TREEIFY_THRESHOLD(默认是8)，就使用红黑树来替换链表。
 
    // 插入图片1张
    
    图片中红色标记的地方个人理解是不够严谨的！！！数据插入HashMap的时候，如果当前桶中的元素个数 &amp;gt; TREEIFY_THRESHOLD时，则会进行桶的树形化处理（见代码片段1：treeifyBin()）。
    
    注意这里只是进行桶的树形化处理，并不是把桶（如果是链表结构）直接转换为红黑树，这里面是有条件的！！！具体规则如下：
    
        条件1. 如果当前桶数组为null或者桶数组的长度 &amp;lt; MIN_TREEIFY_CAPACITY，则进行扩容处理（见代码片段2：resize()）；
        
        条件2. 当不满足条件1的时候则将桶中链表内的元素转换成红黑树！！！稍后再详细讨论红黑树。

3、再来分析下HashMap扩容机制的实现：

    概念：
    
        1. 扩容(resize)就是重新计算容量。当向HashMap对象里不停的添加元素，而HashMap对象内部的桶数组无法装载更多的元素时，HashMap对象就需要扩大桶数组的长度，以便能装入更多的元素。
        
        2. capacity 就是数组的长度/大小，loadFactor 是这个数组填满程度的最大比比例。
        
        3. size表示当前HashMap中已经储存的Node&amp;lt;key,value&amp;gt;的数量，包括桶数组和链表 / 红黑树中的的Node&amp;lt;key,value&amp;gt;。
        
        4. threshold表示扩容的临界值，如果size大于这个值，则必需调用resize()方法进行扩容。
        
        5. 在jdk1.7及以前，threshold = capacity * loadFactor，其中 capacity 为桶数组的长度。
        
            这里需要说明一点，默认负载因子0.75是是对空间和时间(纵向横向)效率的一个平衡选择，建议大家不要修改。
            
            jdk1.8对threshold值进行了改进，通过一系列位移操作算法最后得到一个power of two size的值，见代码片段4。
    
    扩容过程：
    
        1. 使用new Hashap&amp;lt;&amp;gt;()时，新桶数组初始容量设置为默认值DEFAULT_INITIAL_CAPACITY，默认容量下的阈值为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY。
        
        2. 使用new Hashap&amp;lt;&amp;gt;(int initialCapacity)或new HashMap(int initialCapacity, float loadFactor)时，newCap, newThr均重新计算。
        
        3. 如果使用过程中HashMap中的数据过多，原始容量不够使用，那么需要扩容。扩容是以2^1为单位扩容的， newCap = oldCap &amp;lt;&amp;lt; 1和newThr = oldThr &amp;lt;&amp;lt; 1。
        
        4. 如果原来的桶数组长度大于最大值MAXIMUM_CAPACITY时，扩容临界值提高到正无穷（Integer.MAX_VALUE），返回原来的数组，也就是系统已经管不了了，随便你怎么玩吧。
        
    正常扩容之后需要将老的桶数组数据重新放到新的桶数组中，同时对每个桶上的链表进行了重排，再介绍重排之前先来看看代码片段5里面的hash()计算：
    
        首先将得到key对应的哈希值：h = key.hashCode()，然后通过hashCode()的高16位异或低16位计算得到最终的key.hash值（(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)）。
        
            1. 取key的hashcode值：
        
                ① Object类的hashCode
                  
                    返回对象的经过处理后的内存地址，由于每个对象的内存地址都不一样，所以哈希码也不一样。这个是native方法，取决于JVM的内部设计，一般是某种C地址的偏移。
                
                ② String类的hashCode
                
                    根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串的内容相同，返回的哈希码也相同。
                
                ③ Integer等包装类
                
                    返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100)，i1.hashCode的值就是100。
                    
                    由此可见，2个一样大小的Integer对象，返回的哈希码也一样。
                
                ④ int，char这样的基础类
                
                    它们不需要hashCode，如果需要存储时，将进行自动装箱操作，计算方法包装类。
            
            2. hashCode()的高16位异或低16位
        
                在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：key.hash = (h = k.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)，
                
                主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。
        
            3. key.hash &amp;amp; (n - 1) 取模运算
        
                这个n我们说过是table的长度，那么n-1就是table数组元素应有的下表。这个方法非常巧妙，它通过 key.hash &amp;amp; (table.length - 1) 来得到该对象的保存位，
        
                而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，key.hash &amp;amp; (table.length - 1) 运算等价于对length取模，也就是key.hash % length，但是&amp;amp;比%具有更高的效率。
            
    链表重排：
    
        1. 如果原桶上只有一个节点，并且该节点不是红黑树节点，那么直接放到新桶原索引key.hash &amp;amp; (table.length - 1)下；
        
        2. 如果原桶上的节点是红黑树节点，那么则对该树进行分割split()；
        
        3. 如果原桶上的节点是一个链表，则进行链表重排算法:
        
            由于桶数组的容量是按2次幂的扩展(指容量扩为原来2倍)，所以，元素的位置要么是在“原索引”，要么是在“原索引 + oldCap”的位置。
            
            所以，只需要看看原来key.hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap”。
            
            // 插入图片2张

4、HashMap的数据存储实现原理
    
    流程：
    
        1. 根据key计算得到key.hash = (h = k.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)；
        
        2. 根据key.hash计算得到桶数组的索引index = key.hash &amp;amp; (table.length - 1)，这样就找到该key的存放位置了：
        
            ① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；
            
            ② 如果该位置有数据是一个红黑树，那么执行相应的插入 / 更新操作，稍后再详细讨论红黑树；
            
            ③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：
            
                如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；
                
                如果该链表已经有这个节点了，那么找到該节点并更新新数据，返回老数据。
    注意：

        HashMap的put会返回key的上一次保存的数据，比如：
        
            HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
            System.out.println(map.put(&quot;a&quot;, &quot;A&quot;));  // 打印null
            System.out.println(map.put(&quot;a&quot;, &quot;AA&quot;)); // 打印A
            System.out.println(map.put(&quot;a&quot;, &quot;AB&quot;)); // 打印AA

5、红黑树

    上面的讨论中对于红黑树并没有深入分析，HashMap的数据存储中主要有两种场景用到红黑树的操作：
    
        1. 当满足一定条件（条件2，见上文）时，单链表内的数据会转换为红黑树存储（见代码片段2：treeifyBin()）。
        
        2. 当HashMap桶结构由链表转换为红黑树后，再往里put数据将变成往红黑树插入 / 更新数据，这和链表又不太一样了。
    
    下面进行逐一详细分析：
    
    未完待续。。。。。。
        
源码片段1：
    
    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;, or
     *         &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; if there was no mapping for &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;.
     *         (A &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; return can also indicate that the map
     *         previously associated &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; with &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;.)
     */
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    /**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don't change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&amp;lt;K,V&amp;gt; e; K k;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
    
源码片段2：

    final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) {
        int n, index; Node&amp;lt;K,V&amp;gt; e;
        if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) &amp;amp; hash]) != null) {
            TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
            do {
                TreeNode&amp;lt;K,V&amp;gt; p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }

源码片段3：
    
    /**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
     * @return the table
     */
    final Node&amp;lt;K,V&amp;gt;[] resize() {
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) {
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
        }
        else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do {
                            next = e.next;
                            // 原索引
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            // 原索引 + oldCap
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        // 原索引放到桶数组里
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        // 原索引 + oldCap放到桶数组里
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }

源码片段4：

    /**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

源码片段5：

    /**
     * Computes key.hashCode() and spreads (XORs) higher bits of hash
     * to lower.  Because the table uses power-of-two masking, sets of
     * hashes that vary only in bits above the current mask will
     * always collide. (Among known examples are sets of Float keys
     * holding consecutive whole numbers in small tables.)  So we
     * apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed (so don't benefit from
     * spreading), and because we use trees to handle large sets of
     * collisions in bins, we just XOR some shifted bits in the
     * cheapest possible way to reduce systematic lossage, as well as
     * to incorporate impact of the highest bits that would otherwise
     * never be used in index calculations because of table bounds.
     */
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    }

谢谢！欢迎批评指正！！！&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 15 Mar 2018 06:41:00 +0000</pubDate>
<dc:creator>SinghamYuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/singhamxiao/p/8573540.html</dc:identifier>
</item>
<item>
<title>未来已来，腾讯AI计算网络 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8573526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8573526.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer&quot; target=&quot;_blank&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/p&gt;
&lt;blockquote readability=&quot;9.4472361809045&quot;&gt;
&lt;p&gt;作者：由&lt;a class=&quot;author-name&quot; href=&quot;https://cloud.tencent.com/developer/user/1280577&quot;&gt;鹅厂网事&lt;/a&gt;发表在&lt;a href=&quot;https://cloud.tencent.com/developer/article/1037628&quot; target=&quot;_blank&quot;&gt;云+社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;＂鹅厂网事＂由深圳市腾讯计算机系统有限公司技术工程事业群网络平台部运营，我们希望与业界各位志同道合的伙伴交流切磋最新的网络、服务器行业动态信息，同时分享腾讯在网络与服务器领域，规划、运营、研发、服务等层面的实战干货，期待与您的共同成长。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;毫无疑问，人工智能是近年IT界最火的研究方向，特别在2016年Alpha GO这一标志性事件后，国内外科技巨头持续加大对人工智能的投入。目前，人工智能的主要方向如图像识别、语音识别等等都是通过机器学习的方式，借助强大的计算平台对海量数据进行分析、计算，随着数据量的增长，单机性能已逐渐无法满足计算的需求，需要使用高性能计算(HPC, High Performance Computing)集群来进一步提升计算能力。&lt;/p&gt;
&lt;p&gt;HPC集群是将多个计算节点组织在一起协同计算的分布式系统，它一般使用iWARP/RoCE/IB等RDMA(Remote Direct Memory Access)技术来完成计算节点内存间数据的快速交换。如图1所示，RDMA网卡可以从发送节点地址空间中取出数据，直接传送到接收节点的地址空间中，整个交互过程无需内核内存参与，从而大大降低了服务器侧的处理时延。同时，网络作为HPC集群的一部分，任何传输阻滞都会造成计算资源的浪费。为了最大化集群计算能力，通常要求网络在10us内完成RDMA流量的传递。因此，对于支撑HPC的网络来说，时延是影响集群计算性能的首要指标。&lt;/p&gt;
&lt;p&gt;在实际部署中，影响网络时延的主要因素有：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-1280577/4vu9h7h3pp.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1 RDMA互联架构&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;硬件时延。网络设备转发、转发跳数以及光纤距离都会影响网络时延，优化方案是尽量使用两级”Fat-Tree”减少网络转发层级，升级网络速率以更高的波特率转发数据，以及部署低时延交换机(最低0.3us)；&lt;/li&gt;
&lt;li&gt;网络丢包。当网络由于拥塞造成缓冲区溢出丢包，服务器侧需要重传整个数据段，造成时延的严重恶化。常用解决方案有：通过增加交换机缓存、网络带宽来提高扛拥塞能力，进行应用层算法优化规避incast场景减少网络拥塞点，以及部署流控技术通知源端降速以消除拥塞等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;数据中心网络硬件环境相对固定，依靠升级硬件降低时延的效果非常有限，更多还是通过减少网络拥塞来降低时延。因此对于HPC网络，业界更多聚焦在”无损网络”的研究上，目前较成熟的解决方案有有损网络配合流控协议，和工业无损网络两个方向。&lt;/p&gt;


&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;span&gt;有损网络及流控协议&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以太网采用“尽力而为”的转发方式，每个网元尽力将数据交给下游网元，而不关心对方的转发能力，这样就可能造成下游网元的拥塞丢包，因此，以太网是一种不保证可靠传输的有损网络。数据中心中多采用可靠的TCP协议来传递数据，但以太网RDMA报文多为UDP报文，这就需要部署缓存管理、流控技术减少网络侧丢包。&lt;/p&gt;
&lt;p&gt;PFC(Priority Flow Control)是一种基于队列的反压协议，拥塞网元根据通过发送Pause帧通知上游网元降速来防止缓冲区溢出丢包，在单机场景下，PFC可以快速、有效的调节服务器速率来保证网络不丢包，但是在多级网络中，就可能出现线头阻塞(如图2)、不公平降速、PFC风暴等问题，而且当有异常服务器向网络中注入PFC报文时，还可能造成整个网络瘫痪。因此，在数据中心开启PFC，需要通过对Pause帧进行严格的监控、管理，以保证网络的可靠性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-1280577/89bby0iwij.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2 PFC的线头阻塞问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ECN(Explict Congestion Notification)是基于IP的端到端流控机制。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-1280577/u2sz0yixya.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3 ECN降速过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如图3所示，当交换机检测到有端口缓存占用，会在转发时将报文的ECN字段置位，目的端网卡根据报文特征生成通告报文，精确通知源端网卡降速。ECN避免了线头阻塞问题，能够实现流级别的精确降速，但由于其需要网卡侧生成反压报文，响应周期较长，因此通常作为PFC的辅助手段，用来减少网络中PFC的数量，如图4所示，ECN应具有更小的触发阈值，在PFC生效前完成流量的降速。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-1280577/h5xp4snltm.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4 PFC和ECN的触发时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除了主流的大缓存、PFC、ECN，业界还提出了基于RDMA字段的HASH、大象流的整形、基于队列长度的HASH算法DRILL、带宽换缓存算法HULL等解决方案，但这些方案大多需要网卡、交换芯片的支持，短期较难规模部署。&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;span&gt;工业无损网络&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-1280577/v1oxkjm4iw.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5 IB流控机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Infiniband是专为高性能计算、存储设计的互联架构，完整定义了一到七层协议栈，具有低时延、无损转发的特点。如图5，IB网络采用基于”credit”的流控机制，发送者在链路初始化时为每个队列协商初始Credit，标明了能向对端发送的报文数，接受者根据自身的转发能力，实时同时发送者刷新每个队列的Credit，当发送者Credit耗尽，则停止发包。由于网元、网卡都必须得到授权才能发包，因此IB网络不会出现长时间拥塞，是能够保证可靠传输的无损网络。IB提供了15个业务队列来区分流量，不同队列的流量不会出现线头阻塞。同时，IB交换机采用”Cut-through”转发模式，单跳转发时延约0.3us，远低于以太网交换机。&lt;/p&gt;
&lt;p&gt;因此，对于小型HPC、存储网络来说，IB是极佳的选择，但IB也存在与以太网不兼容、产品形态单一等问题，较难融入腾讯生产网中。&lt;/p&gt;


&lt;p&gt;腾讯AI计算网络属于生产网络的一部分，除了需要与其他网络模块通信，还需要对接网管、安全等后台系统，因此只能选择与现网兼容的以太网方案。计算网络的架构随着业务需求的增长经历了多次迭代，从最早支持80个40G节点的HPC v1.0，持续演进至今天支持2000个100G节点的HPC v3.0。&lt;/p&gt;
&lt;p&gt;计算网络中的计算节点作为资源池供整个公司各部门共同使用，这就使得网络面临着多业务流量并发拥塞的问题。对于承载单一业务的网络，可以通过应用层算法调度规避网络拥塞，但当多业务共享网络时，就不可避免出现多业务流量的并发拥塞，即使有队列保护、流控机制等手段减少网络丢包，也会由于服务器的降速造成集群计算能力损失。同时，PFC的缺陷也不适宜在多级网络中开启，需要限制其生效范围。因此，我们的设计思路是：&lt;/p&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;从物理上隔离业务，采用高密设备作为接入设备，尽量将一个部门的节点集中在一个接入设备下，限制跨设备集群的数量；&lt;/li&gt;
&lt;li&gt;只在接入设备开启PFC保证快速反压，在全网开启ECN保护跨设备集群；&lt;/li&gt;
&lt;li&gt;对于小量跨设备集群，围棋提供足够的网络带宽减少拥塞，并采用大缓存交换机解决ECN反压周期长的问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;综合高密接入、大缓存、端到端反压等需求，HPCv3.0架构选择了使用BCM DUNE系列芯片的框式交换机作为接入设备。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-1280577/jjgzam1uvj.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6 HPC3.0架构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如图6所示，HPC v3.0为两级CLOS架构，汇聚设备LC、接入设备LA均为BCM DUNE芯片的框式交换机，每台LA最多可接入72台40G/100G服务器，考虑到当前大部分应用的集群规模在10~20个节点，并且未来计算节点性能提升、算法的优化也会进一步限制集群规模的增大，因此72台足以满足单个业务的计算需求。DUNE线卡支持4GB的缓存，能够缓存ms级拥塞流量，同时支持基于VoQ的端到端流控方案(图7)，能够借助PFC实现同机框下服务器的精确降速。虽然框式交换机的转发时延（4us）会大于盒式交换机(1.3us)，但考虑到减少了多级转发、丢包、拥塞带来的时延恶化，并不会影响集群性能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-1280577/r33ruskmxs.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7 DUNE芯片端到端流控&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从成本上看，虽然框式交换机单端口成本高于盒式交换机，但是由于单LA的节点已可以满足大部分计算需求，跨LA集群需求有限，减少了互联模块，反而比传统盒式接入、一比一收敛比的方案成本更低。&lt;/p&gt;

&lt;p&gt;在很长一段时间，网络都不是数据中心性能的瓶颈，基于”大带宽”的网络设计可以满足业务应用需求。但近些年来，服务器技术的快速发展带动了数据中心计算、存储能力的飞速提高，而RoCE、NVME over Fabric等RDMA技术将数据中心的性能瓶颈转移到了网络侧。特别是对于HPC、分布式存储、GPU云、超融合架构这些基于RDMA的新型应用来说，网络时延已经成为制约性能的主要因素。因此，可以预见到，未来数据中心的设计目标会逐步从带宽驱动走向时延驱动，如何构建低时延、无损的大型以太网数据中心，并建立完整的缓存、时延监控机制，会是我们长期探索的目标。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;注1：凡注明来自“鹅厂网事”的文字和图片等作品，版权均属于“深圳市腾讯计算机系统有限公司”所有，未经官方授权，不得使用，如有违反，一经查实，将保留追究权利；&lt;/p&gt;
&lt;p&gt;注2：本文图片部分来至互联网，如涉及相关版权问题，请联系kevinmi@tencent.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.78142076502732&quot;&gt;
&lt;h2&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;c-hero-bar-tit&quot;&gt; &lt;/p&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/ask/27450&quot; target=&quot;_blank&quot;&gt;AI会对我们的生活带来什么影响？&lt;/a&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1058037&quot; target=&quot;_blank&quot;&gt;央视-腾讯发布报告：九成受访者认为AI 距离自己并不遥远&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1047710&quot; target=&quot;_blank&quot;&gt;AAAI 独家 | 腾讯AI Lab 现场陈述论文：使众包配对排名聚合信息最大化的 HodgeRank&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1047707&quot; target=&quot;_blank&quot;&gt;重磅独家 | 腾讯AI Lab AAAI18现场陈述论文：用随机象限性消极下降算法训练L1范数约束模型&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-sheets-value=&quot;{&amp;quot;1&amp;quot;:2,&amp;quot;2&amp;quot;:&amp;quot;Unity引擎与C#脚本简介&amp;quot;}&quot; data-sheets-userformat=&quot;{&amp;quot;2&amp;quot;:1,&amp;quot;3&amp;quot;:[null,0]}&quot;&gt;此文已由作者授权腾讯云+社区发布，转载请注明&lt;a href=&quot;https://cloud.tencent.com/developer/article/1037628&quot; target=&quot;_blank&quot;&gt;文章出处&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 原文链接：https://cloud.tencent.com/developer/article/1037628&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201803/1112679-20180309155920741-130764673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Mar 2018 06:39:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8573526.html</dc:identifier>
</item>
<item>
<title>Net 面试随想 - 郎中令</title>
<link>http://www.cnblogs.com/Sientuo/p/8573408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sientuo/p/8573408.html</guid>
<description>&lt;p&gt;      佳节已去，至今半月有余，近来园中唱衰net的声音幽幽而起，net不成熟的大环境一直被作为诟病，net core的跨平台去年抄的火热，是否为net 崛起的最后一根稻草，结合我面试的情况，作为小白，嘟囔几句。15年首次面试的时候，心里那个慌，怕出丑，不敢说，回答的时候也自带颤音特效。走上岗位也怕，怕啥也不懂，完成不了任务。而现在，技术没提升多少，脸皮却厚多了，不管啥场面，稳如泰山。&lt;br/&gt;      第一家公司，出奇的顺利，直接拿到了offer。一面技术问了下项目经验，使用的技能，算认可我，最后一句问有没有兴趣搞Java（暂时没有）。二面经理，上来就说net已死，国内政府已经明规定不在使用net做项目，我直接回复了一句，我开发的银行项目，一直都用的是net开发，他又说大趋势下淘汰net是必然的，到底不是搞技术的，两个人也谈不到一起去，结果他看我简历发现是我上上个东家的同事，顿时又口若悬河，滔滔不绝。三面总监，发现老家一个地方，两家相距不过十几分钟的路程，还客气的相约过年一起回家。开的薪资也不低，加班机制也比较合理（偷笑），如果不是我有同学已在其司，我应该被忽悠进去了。拒绝的无非是两点：&lt;br/&gt;① （实际）频繁加班，每天加班两个小时内，并且周六几乎都要加班，却只有一顿10块钱的餐补&lt;br/&gt;② 新项目全部用Java，我这net还没学到家，半吊子水平就换语言火候还不到。 &lt;/p&gt;
&lt;p&gt;      由于第一家公司比较顺利，心里还算有底，想想自己也在世界500强公司待了两年，整体也负责过一些项目（前后台+API+部署+发布），阅读书的习惯一直也没停。然而接下来却并不如此，查阅公司的时候我就发现，武汉这边net的岗位本身就不多，一部分还是搞CS（winform、WPF）的，另外一部分虽然是bs，但却是webForm开发。武汉作为二线中下等水平，大部分开的薪资也是比较气人，说是1-3年，5-9K，呵呵，实际上就是三年5K，能给高薪的公司还属外包。外包只管实际项目经验，不论是不是实习。同样（疲于奔命）累也是它的特点。而其他一些公司，一方面招实习生，用低廉的价格让他们做正式工两倍的活，一方面在面试的时候又不承认实习经验，只看毕业时间。这种公司直接PASS掉。&lt;/p&gt;
&lt;p&gt;      第二家公司，&lt;strong&gt; *普爱德&lt;/strong&gt;，也算是个小小的上市公司吧，一大早过去面试，前台打了三次电话，说吩咐了二个人去给我开门，结果毛都没有，最后终于等来人， 面试三页纸，第一页逻辑题目（看智商怎么样），其余是net后台、前端的题目，花了一个小时做完，技术面的时候只说了三句话.你这做的感觉技术不行啊，什么时候毕业的？（16年），期望薪资多少？（*K）。好，我知道了，回去等通知吧，现在想想真是后悔啊，毕竟也是花钱打印的，以后这种情况绝对当场要回简历。面试多了，其实就有这种感觉，好多公司的态度完全就不是哪种诚心招人。属于可招可不招的状态，来人了，随便应付下，然后就没下文。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;     &lt;/em&gt; 第三家公司，&lt;strong&gt;*彦科技&lt;/strong&gt;，外包明源的项目，技术面的时候，说这个题目要求用JS做，为什么你用JQ作答?(JQ灵活些，层级选择的时候不用频繁写 getElementBy...) 一定要以满足客户要求为首位。(嗯) 从现在开始说出20个JS中用到的方法？Alert就算。（抱歉我不明白这样问的意义，好久没用JS了，一时想不起来这么多）然后就是说现在要搞新的业务，怎么看待之类的。外包不靠谱，偏向于纯js的，肯定没戏，结果在20天后，电话我说，还记不记得XX科技，告知面试过了，可是我这边入职久矣。估计就是这年头搞net的本来就少，一上来对我不满意，后来挑来挑去的，实在没有好的了，又把以前pass掉的拿出来筛选下，又点上我了，哈哈，这尴尬。。。&lt;br/&gt;      第四家公司，&lt;strong&gt;** 科 技&lt;/strong&gt;，还是比较有意思的，初试当天，15个人面试Java，我一个人面试Net。复试的时候9个人面试Java，我一个Net，其他人都有自己的项目展示，而我比较懒，没在github上有项目，公司做的都是银行的门户网站和后台管理，不可能拷贝出来，于是我就说有博客园，你们要是有兴趣就点进去看看，结果一大会议室，三个考官，在大屏上查看我的博客，根据复试的问题，我估计该公司就我一个Net的，连考官都是搞Java的，问的SQL居多，事务、索引原理 和存储过程等等，MVC的就问我使用的是什么版本，可能回答的还算满意，所以给的薪资也比较高，入职后让我做的应该是产品上Net这一块。这种公司还是不敢去的，就一个人搞Net，虽然拿到了Offer，还是找了个理由推了。&lt;br/&gt;      后面连续几家就不说了，本人第一份工作是做GIS的，二次开发，离职后决定再也不会从事这个行业，作为学习面试经验，还是投递了一家大点的GIS相关公司，笔试之后，技术和人事主管轮流问问题，技术都是些刁钻的，拿他们公司用到的一些比较偏门的来考，很多我几乎都没听过，又拿公司项目中遇到的一个个问题来让我设计算法解决，并且只看毕业经验来定薪资，这次面试比较不愉快，快速面完之后赶紧溜了。&lt;br/&gt;武汉这块大公司中，能和我原东家比较的话，&lt;strong&gt;明源&lt;/strong&gt;算一个，毕竟几乎垄断了整个地产市场。Hr小姐姐也是非常亲切，前前后后给了四份面试通知（Boss上显示急聘，项目上应该相当缺人），虽然前三次都是由于个人原因没有去成，但是当天下午四点半的时候Hr都会准时来一通电话，询问缘由，第四次的时候我已离职，虽然明源加班出了名，但还是打算去见识下，签到的时候，长长的列表，我只看到一个net面试的，其余都是测试、Java。明源的环境很不错，面试题目也非常多 5页纸，一共9面。我做完了net 和Sql 部分，还有5面JS部分，最后全是算法大题，根据考察的内容，薪资应该会在10K+，奈何本人JS水平一般，Jq还算入门。就直接交卷离开了。感觉外包公司就是不一样，面试题目就是硬性条件，尤其是JS部分，一定要过硬，术业有专攻，由于我目前疏于学习，Jq前台这块还算能应付，中高级还有不少的差距。经过这些天的面试，发现武汉市场上 Net 的岗位不是很多，对于一些中小企业，像军工、政府这类的传统项目，虽然也有Net的，但是好多都选择哪种可以点击的操作，Winform、WPF。&lt;br/&gt;      诚然，最后我选择一家规模最小，薪资最低的公司入职。这家公司提供的平台不错，后期项目也要以net core来开发，我觉得自学总是赶不上跟着项目走进步大，如果能打的一波好酱油，其价值也是远远不止当前这一星半点的RMB所比。时代在进步，技术不断的在迭代，Net到底行不行？还能走多远，以前说国外的Net行业发展的比较好，现在国外环境也变了，国内就更不行了，作为学校那会就是net&lt;br/&gt;专业的人，我不是说Java不好，或者Net不好，我觉得纠结这些语言之争的大多都是些初中级的码农，语言学到一定水准，如园中张善友、蒋金楠等，已经不会在乎语言，更多的是设计、分析、优化。只要学的精绝对不会没有市场，即使转行也是得心应手。其次，身边到处都是培训Java、安卓的机构，让一些不了解的学员经过一顿诉说，纷纷选择Java，市场岗位和应聘人技能是相互影响，相辅相成。这也是导致不少公司纷纷倒向Java的原因。总之作为码农，语言之争的时候还没到，风水轮流转，只要技术到位，不管怎么转，手揣老司机卡，还怕下车吗？&lt;/p&gt;
</description>
<pubDate>Thu, 15 Mar 2018 06:23:00 +0000</pubDate>
<dc:creator>郎中令</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Sientuo/p/8573408.html</dc:identifier>
</item>
<item>
<title>初探WebSocket - 楼兰小骑士</title>
<link>http://www.cnblogs.com/xiaoloulan/p/8573344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoloulan/p/8573344.html</guid>
<description>&lt;p&gt;node websocket socket.io&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们平常开发的大部分web页面都是主动‘拉’的形式，如果需要更新页面内容，则需要“刷新”一个，但Slack工具却能主动收到信息，好像服务端能主动给客户端推送信息，请研究一下这是怎么实现的。&lt;/p&gt;
&lt;h2 id=&quot;websocket&quot;&gt;WebSocket&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif&quot; alt=&quot;OSI七层模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;websocket是HTML5中新引进的一种 &lt;code&gt;协议&lt;/code&gt; ，它是一种协议就像(HTTP,FTP在tcp/ip协议栈中属于应用层)而不是简单的一个函数。它本身及基于TCP协议的一种新的协议。&lt;/p&gt;
&lt;h3 id=&quot;websocket的产生&quot;&gt;WebSocket的产生&lt;/h3&gt;
&lt;p&gt;websocket是基于web的实时性而产生的，说到这里就不得不要追溯一下web的历史了，在2005年(也就是ajax还没诞生)以前，我们如果想要在一个页面显示显示不同的内容，或者说页面内跳转，只能是通过点击然后路由跳转，在ajax诞生之后，网页开始变得动态了。但是所有的HTTP通信还都是由客户端控制的，这就要需要长连接，定期轮询或者长轮询，来和服务器沟通来更新数据。&lt;/p&gt;
&lt;h4 id=&quot;websocket之前的服务器推的技术&quot;&gt;WebSocket之前的服务器“推”的技术&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;定期轮询(ajax轮询)：浏览器在特定的时间给服务器发送请求，查看服务器是否有信息数据。&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/image.png&quot; alt=&quot;定期轮询&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优点：后端程序编写比较容易。&lt;br/&gt;缺点：请求中有大半是无用，浪费带宽和服务器资源。&lt;br/&gt;实例：适于小型应用。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;长轮询：其实和上面的原理差不多，是对ajax轮询进行了改进和提高。客户端和服务端建立连接之后，一直保持通信(阻塞模式)，如果服务器没有新消息就一直保持通信，直到服务器有新的消息，然后返回给客户端，客户端与服务器断开连接，此时客户端可以继续和服务器进行连接。&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/image2.png&quot; alt=&quot;长链接&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优点：在无消息的情况下不会频繁的请求，耗费资源小。&lt;br/&gt;缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。&lt;br/&gt;实例：旧的 WebQQ、Hi网页版、Facebook IM。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;流控制：通常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务 器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。比如在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SSE，Comet,使用长链接进行通讯。&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/image3.png&quot; alt=&quot;流操作&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优点：消息即时到达，不发无用请求；管理起来也相对方便。&lt;br/&gt;缺点：服务器维护一个长连接会增加开销。&lt;br/&gt;实例：Gmail聊天&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Flash Socket：在页面中内嵌入一个使用了Socket类的 Flash 程序JavaScript通过调用此Flash程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优点：实现真正的即时通信，而不是伪即时。&lt;br/&gt;缺点：客户端必须安装Flash插件；非HTTP协议，无法自动穿越防火墙。&lt;br/&gt;实例：网络互动游戏。&lt;/p&gt;
&lt;h4 id=&quot;http1.1和长链接&quot;&gt;HTTP1.1和长链接&lt;/h4&gt;
&lt;p&gt;以上几种服务器“推”的技术中：长轮询和流控制其实都是基于长链接来实现的，也就是 &lt;code&gt;http1.1&lt;/code&gt; 中所谓的 &lt;code&gt;keep-alive&lt;/code&gt;。在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。&lt;/p&gt;
&lt;p&gt;HTTP是无状态的，也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话&lt;/p&gt;
&lt;p&gt;HTTP1.1和HTTP1.0相比较而言，最大的区别就是HTTP1.1默认支持持久连接(最新的 http1.0 可以显示的指定 keep-alive)，但还是无状态的，或者说是不可以信任的。&lt;/p&gt;
&lt;p&gt;在向客户发送所请求文件的同时，服务器并没有存储关于该客户的任何状态信息。即便某个客户在几秒钟内再次请求同一个对象，服务器也不会响应说:自己刚刚给它发送了这个对象。相反，服务器重新发送这个对象，因为它已经彻底忘记早先做过什么。既然HTTP服务器不维护客户的状态信息，我们于是 说HTTP是一个无状态的协议(stateless protocol)。&lt;/p&gt;
&lt;p&gt;基于http协议的长连接减少了请求,减少了建立连接的时间,但是每次交互都是由客户端发起的,客户端发送消息,服务端才能返回客户端消息。因为客户端也不知道服务端什么时候会把结果准备好，所以客户端的很多请求是多余的,仅是维持一个心跳,浪费了带宽。&lt;/p&gt;
&lt;h3 id=&quot;websocket-1&quot;&gt;WebSocket&lt;/h3&gt;
&lt;h4 id=&quot;websocket简介&quot;&gt;WebSocket简介&lt;/h4&gt;
&lt;p&gt;WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范。&lt;/p&gt;
&lt;p&gt;关于HTML5的故事很多人都是知道的，w3c放弃了HTML，然后有一群人（也有说是这些人供职的公司，不过官方的文档上是说的个人）创立了WHATWG组织来推动HTML语言的继续发展，同时，他们还发展了很多关于Web的技术标准，这些标准不断地被官方所接受。WebSocket就属于WHATWG发布的Web Application的一部分（即HTML5）的产物。&lt;/p&gt;
&lt;p&gt;它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;建立在 TCP 协议之上，服务器端的实现比较容易。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据格式比较轻量，性能开销小，通信高效。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以发送文本，也可以发送二进制数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有同源限制，客户端可以与任意服务器通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/image4.png&quot; alt=&quot;websocket&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;Upgrade: websocket Connection: Upgrade&lt;/code&gt; 告诉服务器我们发起的是一个 &lt;code&gt;WebSocket&lt;/code&gt; 请求。&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; 是一个 &lt;code&gt;Base64encode&lt;/code&gt; 的值，这个是浏览器随机生成的，验证服务器是不是真的是Websocket助理。&lt;br/&gt;然后，&lt;code&gt;Sec_WebSocket-Protocol&lt;/code&gt; 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。&lt;br/&gt;最后，&lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 是告诉服务器所使用的WebsocketDraft（协议版本）。&lt;/p&gt;
&lt;h4 id=&quot;html5-web-socket-api&quot;&gt;HTML5 Web Socket API&lt;/h4&gt;
&lt;blockquote readability=&quot;3.0882352941176&quot;&gt;
&lt;p&gt;详细接口文档：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket&quot;&gt;MDN WebSocket&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;创建对象：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;var ws = new WebSocket(url,name);&lt;/code&gt;&lt;br/&gt;url为WebSocket服务器的地址，name为发起握手的协议名称，为可选择项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送文本消息：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ws.send(msg);&lt;/code&gt;&lt;br/&gt;msg为文本消息，对于其他类型的可以通过二进制形式发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收消息：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ws.onmessage = (function(){...})();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误处理：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ws.onerror = (function(){...})();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭连接：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ws.close();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们借助这个测试接口 &lt;code&gt;wss://echo.websocket.org&lt;/code&gt; 来做一个小demo。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公用html（下面的代码基本也是这个结构）:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;h1&amp;gt;客户端简单例子&amp;lt;/h1&amp;gt;
&amp;lt;i&amp;gt;这里我们走Kaazing WebSocket为我们提供的接口，这个接口将完整返回我们所发送的数据。&amp;lt;/i&amp;gt;
&amp;lt;p&amp;gt;状态：&amp;lt;strong id=&quot;state&quot;&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;返回数据：&amp;lt;strong id=&quot;msg&quot;&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;input id=&quot;sendText&quot; type=&quot;text&quot; name=&quot;&quot;&amp;gt;
&amp;lt;button id=&quot;sendBtn&quot;&amp;gt;发送&amp;lt;/button&amp;gt;
&amp;lt;button id=&quot;closeBtn&quot;&amp;gt;关闭&amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;JS：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var show = document.getElementById('state'),
    msg  = document.getElementById('msg'),
    st   = document.getElementById('sendText'),
    sb   = document.getElementById('sendBtn');

if (&quot;WebSocket&quot; in window) {
  var ws = new WebSocket('wss://echo.websocket.org');

  ws.onopen = function(e) { 
    show.innerText = 'WebSocket连接成功～';
    ws.send('Hello WebSockets!');
  };

  ws.onmessage = function(e) {
    msg.innerText = e.data;
  };

  ws.onclose = function(e) {
    show.innerText = 'WebSocket连接关闭～';
  }

  sb.addEventListener('click',function(){
    ws.send(st.value);
  })

}else{
  alert('你的浏览器不支持WebSocket');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/demo.png&quot; alt=&quot;demo1&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nodejs-websocket&quot;&gt;nodejs-websocket&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sitegui/nodejs-websocket&quot;&gt;nodejs-websocket&lt;/a&gt;是一个nodeJs的模块，我们可以用它来轻易地为我们之前的代码单独搭建一个WebSocket的nodeJs服务端。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn add nodejs-websocket&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;var ws = require(&quot;nodejs-websocket&quot;)

// Scream server example: &quot;hi&quot; -&amp;gt; &quot;HI!!!&quot;
var server = ws.createServer(function (conn) {
    console.log(&quot;New connection&quot;)
    conn.on(&quot;text&quot;, function (str) {
        console.log(&quot;Received &quot;+str)
        conn.sendText(str.toUpperCase()+&quot;!!!&quot;)
    })
    conn.on(&quot;close&quot;, function (code, reason) {
        console.log(&quot;Connection closed&quot;)
    })
}).listen(8001)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;socket.io&quot;&gt;Socket.io&lt;/h4&gt;
&lt;p&gt;在某种程度上，socket.io就是websocket，其实socket.io与websocket不是一回事，而且websocket可以说是socket.io的一个子集，socket.io的底层实现其实有5种方式，websocket只是其中一种，只不过在默认的情况下，我们建立的socket.io连接，底层也是调用websocket的实例。当我们io.connect()建立一个socket连接的时候，返回的是namespace实例，namespace实例中有个socket实例，当新建一个连接，或者发送一条消息的时候，namespace-&amp;gt;socket-&amp;gt;transport-&amp;gt;websocket(xhrpolling...)，其实发送一条消息真正的发送者还是底层的websocket或是xhrpolling或其他的几种，而socket.io只是一个组织者，当我们需要建立连接的时候，它自己会在其内部挑选一种连接方式，然后实现连接。&lt;/p&gt;
&lt;p&gt;Socket.io都实现了Polling中的那些通信机制呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Adobe® Flash® Socket&lt;/li&gt;
&lt;li&gt;AJAX long polling&lt;/li&gt;
&lt;li&gt;AJAX multipart streaming&lt;/li&gt;
&lt;li&gt;Forever Iframe&lt;/li&gt;
&lt;li&gt;JSONP Polling&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;websocket和http和socket&quot;&gt;WebSocket和HTTP和Socket&lt;/h3&gt;
&lt;p&gt;应用层的协议，WebSocket在现代的软件开发中被越来越多的实践，和HTTP有一些相似的地方，而且有人也会把WebSocket和Socket混为一谈，那么他们之间到底有什么异同呢？&lt;/p&gt;
&lt;h4 id=&quot;websocket和http&quot;&gt;WebSocket和HTTP&lt;/h4&gt;
&lt;p&gt;我们先看两个协议的截图来领会下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/image4.png&quot; alt=&quot;websocket&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/image5.png&quot; alt=&quot;http&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;相同点&quot;&gt;相同点&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;都是基于TCP的应用层协议。&lt;/li&gt;
&lt;li&gt;都使用Request/Response模型进行连接的建立。&lt;/li&gt;
&lt;li&gt;在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码。&lt;/li&gt;
&lt;li&gt;都可以在网络中传输数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;不同点&quot;&gt;不同点&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用。&lt;/li&gt;
&lt;li&gt;WS的连接不能通过中间人来转发，它必须是一个直接连接。&lt;/li&gt;
&lt;li&gt;WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据。&lt;/li&gt;
&lt;li&gt;WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息。&lt;/li&gt;
&lt;li&gt;WS的数据帧有序。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;websocket和socket&quot;&gt;WebSocket和Socket&lt;/h4&gt;
&lt;p&gt;其实就像Java和JavaScript一样，WebSocket和Socket并没有太大的关系。&lt;/p&gt;
&lt;p&gt;Socket可以有很多意思，和IT较相关的本意大致是指在端到端的一个连接中，这两个端叫做Socket。对于IT从业者来说，它往往指的是TCP/IP网络环境中的两个连接端，大多数的API提供者（如操作系统，JDK）往往会提供基于这种概念的接口，所以对于开发者来说也往往是在说一种编程概念。同时，操作系统中进程间通信也有Socket的概念，但这个Socket就不是基于网络传输层的协议了。&lt;/p&gt;
&lt;p&gt;Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.zengrong.net/uploads/2014/12/socket.gif&quot; alt=&quot;http&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 WebSocket 则不同，它是一个完整的 应用层协议，包含一套标准的 API 。&lt;/p&gt;
&lt;p&gt;所以，从使用上来说，WebSocket 更易用，而 Socket 更灵活。&lt;/p&gt;
&lt;h3 id=&quot;浏览器支持&quot;&gt;浏览器支持&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tianye19941001/github-img/master/images/image6.png&quot; alt=&quot;浏览器支持&quot;/&gt;&lt;/p&gt;
&lt;p&gt;websocket api在浏览器端的广泛实现似乎只是一个时间问题了, 值得注意的是服务器端没有标准的api, 各个实现都有自己的一套api, 并且tcp也没有类似的提案, 所以使用websocket开发服务器端有一定的风险.可能会被锁定在某个平台上或者将来被迫升级。&lt;/p&gt;
&lt;blockquote readability=&quot;3.7142857142857&quot;&gt;
&lt;p&gt;本文相关的Demo已经放在作者的Github上：&lt;a href=&quot;https://github.com/tianye19941001/WebSocket&quot;&gt;小楼兰的github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 15 Mar 2018 06:14:00 +0000</pubDate>
<dc:creator>楼兰小骑士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoloulan/p/8573344.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上：服务器CPU 100%问题是memcached连接数限制引起的 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8572862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8572862.html</guid>
<description>&lt;p&gt;非常抱歉，昨天的&lt;a href=&quot;https://www.cnblogs.com/cmt/p/8568280.html&quot; target=&quot;_blank&quot;&gt;服务器CPU 100%问题&lt;/a&gt;是达到 memcached 的连接数限制引起的，不是阿里云服务器的问题。&lt;/p&gt;
&lt;p&gt;之前我们用的是阿里云“云数据库 memcached 版”，上个周末我们换成了自己搭建——基于阿里云“内存网络增强型”服务器用 docker 跑 memcached 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -d --net=host --restart unless-stopped memcached -m 15360
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但我们在部署 memcached 时没有设置 conn-limit 参数（默认值是 1024） 。&lt;/p&gt;
&lt;p&gt;由于周一周二两天服务器没出现问题，而且周二的访问量超过了上周的最高，我们误以为这次 memcached 的部署调整没问题。而没问题的背后是因为周一周二的web服务器数量比昨天少，刚好没达到 memcached 的连接数限制。&lt;/p&gt;
&lt;p&gt;昨天（周三）我们收到 1 台服务器的 CPU 报警后，多加了 1 台服务器，刚好让 memcached 的连接数达到了临界值，在下午并发连接数上去后，很容易触发 memcached 的连接限制，web 服务器因无法使用缓存而让 CPU 不堪重负。在这样的情况下，减服务器反而是有利的，而我们慌乱之下依照 CPU 负载高就加服务器的错误直觉操作则是雪上加霜。。。&lt;/p&gt;
&lt;p&gt;当今天上午再次有服务器出现 CPU 100% 问题时，我们才想到 memcached 的连接数限制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
STAT max_connections 1024
STAT curr_connections 960
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;赶紧将 max_connections 由默认的 1024 修改为 2048&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d --net=host --restart unless-stopped memcached -m 15360 -c 2048 &amp;amp;&amp;amp; docker stop 51bd3b240ede
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后 CPU 100% 的问题就解决了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
STAT max_connections 2048
STAT curr_connections 1232
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常抱歉，由于我们在处理故障时不够冷静、考虑不周，给您带来了麻烦，请您谅解。&lt;/p&gt;
&lt;p&gt;我们会吸取教训，提高我们在处理故障时的判断与定位能力。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Mar 2018 05:36:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8572862.html</dc:identifier>
</item>
<item>
<title>Spring【DAO模块】就是这么简单 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8572987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8572987.html</guid>
<description>&lt;p&gt;上一篇Spring博文主要讲解了如何使用Spring来实现AOP编程，本博文主要讲解&lt;strong&gt;Spring的DAO模块对JDBC的支持，以及Spring对事务的控制&lt;/strong&gt;...&lt;/p&gt;
&lt;p&gt;对于JDBC而言，我们肯定不会陌生，我们&lt;strong&gt;在初学的时候肯定写过非常非常多的JDBC模板代码&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;我们来回忆一下我们怎么对模板代码进行优化的！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先来看一下我们&lt;strong&gt;原生的JDBC：需要手动去数据库的驱动从而拿到对应的连接&lt;/strong&gt;..&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            String sql = &lt;span class=&quot;st&quot;&gt;&quot;insert into t_dept(deptName) values('test');&quot;&lt;/span&gt;;
            Connection con = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            Statement stmt = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 连接对象&lt;/span&gt;
            con = DriverManager.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql:///hib_demo&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 执行命令对象&lt;/span&gt;
            stmt =  con.&lt;span class=&quot;fu&quot;&gt;createStatement&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 执行&lt;/span&gt;
            stmt.&lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(sql);
            
            &lt;span class=&quot;co&quot;&gt;// 关闭&lt;/span&gt;
            stmt.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            con.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;因为JDBC是面向接口编程的，因此数据库的驱动都是由数据库的厂商给做到好了，我们&lt;strong&gt;只要加载对应的数据库驱动，便可以获取对应的数据库连接&lt;/strong&gt;....因此，我们&lt;strong&gt;写了一个工具类，专门来获取与数据库的连接(Connection)&lt;/strong&gt;,当然啦，为了更加灵活，我们的&lt;strong&gt;工具类是读取配置文件的方式来做的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * 连接数据库的driver，url，username，password通过配置文件来配置，可以增加灵活性&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * 当我们需要切换数据库的时候，只需要在配置文件中改以上的信息即可&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * */&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String  driver = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String  url = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String  username = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String password = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

            &lt;span class=&quot;co&quot;&gt;//获取配置文件的读入流&lt;/span&gt;
            InputStream inputStream = UtilsDemo.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;);

            Properties properties = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Properties();
            properties.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(inputStream);

            &lt;span class=&quot;co&quot;&gt;//获取配置文件的信息&lt;/span&gt;
            driver = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;driver&quot;&lt;/span&gt;);
            url = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;url&quot;&lt;/span&gt;);
            username = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;);
            password = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;);

            &lt;span class=&quot;co&quot;&gt;//加载驱动类&lt;/span&gt;
            Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(driver);


        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }

    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; DriverManager.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(url,username,password);
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(Connection connection, Statement statement, ResultSet resultSet) {

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (resultSet != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                resultSet.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (statement != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                statement.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (connection != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                connection.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;经过上面一层的封装，我们可以&lt;strong&gt;在使用的地方直接使用工具类来得到与数据库的连接...那么比原来就方便很多了！&lt;/strong&gt;但是呢，&lt;strong&gt;每次还是需要使用Connection去创建一个Statement对象。并且无论是什么方法，其实就是SQL语句和传递进来的参数不同！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;于是，我们就自定义了一个JDBC的工具类，详情可以看&lt;a href=&quot;http://blog.csdn.net/hon_3y/article/details/53760782#t6&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/hon_3y/article/details/53760782#t6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我们自定义的工具类其实就是以DbUtils组件为模板来写的，因此我们在开发的时候就一直&lt;strong&gt;使用DbUtils组件了&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;上面已经回顾了一下以前我们的JDBC开发了，那么看看Spring对JDBC又是怎么优化的&lt;/p&gt;
&lt;p&gt;首先，想要使用Spring的JDBC模块，就必须引入两个jar文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引入jar文件
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;spring-jdbc-3.2.5.RELEASE.jar&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spring-tx-3.2.5.RELEASE.jar&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;首先还是看一下我们原生的JDBC代码：&lt;strong&gt;获取Connection是可以抽取出来的，直接使用dataSource来得到Connection就行了&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            String sql = &lt;span class=&quot;st&quot;&gt;&quot;insert into t_dept(deptName) values('test');&quot;&lt;/span&gt;;
            Connection con = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            Statement stmt = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 连接对象&lt;/span&gt;
            con = DriverManager.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql:///hib_demo&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 执行命令对象&lt;/span&gt;
            stmt =  con.&lt;span class=&quot;fu&quot;&gt;createStatement&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 执行&lt;/span&gt;
            stmt.&lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(sql);
            
            &lt;span class=&quot;co&quot;&gt;// 关闭&lt;/span&gt;
            stmt.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            con.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;值得注意的是，&lt;strong&gt;JDBC对C3P0数据库连接池是有很好的支持的。因此我们直接可以使用Spring的依赖注入，在配置文件中配置dataSource就行了&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;driverClass&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql:///hib_demo&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;initialPoolSize&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxPoolSize&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxStatements&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;acquireIncrement&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;// IOC容器注入&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; DataSource dataSource;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDataSource&lt;/span&gt;(DataSource dataSource) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dataSource&lt;/span&gt; = dataSource;
    }

    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            String sql = &lt;span class=&quot;st&quot;&gt;&quot;insert into t_dept(deptName) values('test');&quot;&lt;/span&gt;;
            Connection con = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            Statement stmt = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 连接对象&lt;/span&gt;
            con = dataSource.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 执行命令对象&lt;/span&gt;
            stmt =  con.&lt;span class=&quot;fu&quot;&gt;createStatement&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 执行&lt;/span&gt;
            stmt.&lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(sql);
            
            &lt;span class=&quot;co&quot;&gt;// 关闭&lt;/span&gt;
            stmt.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            con.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Spring来提供了JdbcTemplate这么一个类给我们使用！它封装了DataSource，也就是说我们可以在Dao中使用JdbcTemplate就行了。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建dataSource，创建jdbcTemplate对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:context=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:c=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/c&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;driverClass&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql:///zhongfucheng&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;initialPoolSize&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxPoolSize&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxStatements&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;acquireIncrement&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--扫描注解--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; base-package=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;bb&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 2. 创建JdbcTemplate对象 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbcTemplate&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package bb;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.jdbc.core.JdbcTemplate;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Component;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by ozc on 2017/5/10.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;


&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserDao &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; IUser {

    &lt;span class=&quot;co&quot;&gt;//使用Spring的自动装配&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JdbcTemplate template;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;() {
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;insert into user(name,password) values('zhoggucheng','123')&quot;&lt;/span&gt;;
        template.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql);
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;test33&lt;/span&gt;() {
        ApplicationContext ac = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;bb/bean.xml&quot;&lt;/span&gt;);

        UserDao userDao = (UserDao) ac.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userDao&quot;&lt;/span&gt;);
        userDao.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170514224019265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;jdbctemplate查询&quot;&gt;JdbcTemplate查询&lt;/h2&gt;
&lt;p&gt;我们要是使用JdbcTemplate查询会发现&lt;strong&gt;有很多重载了query()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515121731440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般地，&lt;strong&gt;如果我们使用queryForMap()，那么只能封装一行的数据，如果封装多行的数据、那么就会报错&lt;/strong&gt;！并且，Spring是不知道我们想把一行数据封装成是什么样的，因此返回值是Map集合...我们得到Map集合的话还需要我们自己去转换成自己需要的类型。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们一般使用下面这个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515124848736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以&lt;strong&gt;实现RowMapper，告诉Spriing我们将每行记录封装成怎么样的&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(String id) {
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;select * from USER where password=?&quot;&lt;/span&gt;;

        List&amp;lt;User&amp;gt; query = template.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; RowMapper&amp;lt;User&amp;gt;() {


            &lt;span class=&quot;co&quot;&gt;//将每行记录封装成User对象&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;fu&quot;&gt;mapRow&lt;/span&gt;(ResultSet resultSet, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
                User user = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;User&lt;/span&gt;();
                user.&lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(resultSet.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;));
                user.&lt;span class=&quot;fu&quot;&gt;setPassword&lt;/span&gt;(resultSet.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;));

                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; user;
            }

        },id);


        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(query);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515125056987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当然了，一般我们都是&lt;strong&gt;将每行记录封装成一个JavaBean对象的，因此直接实现RowMapper，在使用的时候创建就好了&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyResult &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; RowMapper&amp;lt;Dept&amp;gt;{

        &lt;span class=&quot;co&quot;&gt;// 如何封装一行记录&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Dept &lt;span class=&quot;fu&quot;&gt;mapRow&lt;/span&gt;(ResultSet rs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
            Dept dept = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Dept&lt;/span&gt;();
            dept.&lt;span class=&quot;fu&quot;&gt;setDeptId&lt;/span&gt;(rs.&lt;span class=&quot;fu&quot;&gt;getInt&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;deptId&quot;&lt;/span&gt;));
            dept.&lt;span class=&quot;fu&quot;&gt;setDeptName&lt;/span&gt;(rs.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;deptName&quot;&lt;/span&gt;));
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dept;
        }
        
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面主要讲解Spring的事务控制，如何使用Spring来对程序进行事务控制....&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Spring的事务控制是属于Spring Dao模块的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般地，我们&lt;strong&gt;事务控制都是在service层做的&lt;/strong&gt;。。为什么是在service层而不是在dao层呢？？有没有这样的疑问...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;service层是业务逻辑层，service的方法一旦执行成功，那么说明该功能没有出错&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个&lt;strong&gt;service方法可能要调用dao层的多个方法&lt;/strong&gt;...如果在dao层做事务控制的话，一个dao方法出错了，仅仅把事务回滚到当前dao的功能，这样是不合适的[因为我们的业务由多个dao方法组成]。如果没有出错，调用完dao方法就commit了事务，这也是不合适的[导致太多的commit操作]。&lt;/p&gt;
&lt;p&gt;事务控制分为两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;编程式事务控制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明式事务控制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编程式事务控制&quot;&gt;编程式事务控制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;自己手动控制事务，就叫做编程式事务控制。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jdbc代码：
&lt;/li&gt;
&lt;li&gt;Hibernate代码：
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【细粒度的事务控制： 可以对指定的方法、指定的方法的某几行添加事务控制】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(比较灵活，但开发起来比较繁琐： 每次都要开启、提交、回滚.)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;声明式事务控制&quot;&gt;声明式事务控制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring提供对事务的控制管理就叫做声明式事务控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring提供了对事务控制的实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果用户想要使用Spring的事务控制，&lt;strong&gt;只需要配置就行了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当不用Spring事务的时候，直接移除就行了。&lt;/li&gt;
&lt;li&gt;Spring的事务控制是&lt;strong&gt;基于AOP实现的&lt;/strong&gt;。因此它的&lt;strong&gt;耦合度是非常低&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;【粗粒度的事务控制： &lt;strong&gt;只能给整个方法应用事务，不可以对方法的某几行应用事务。&lt;/strong&gt;】
&lt;ul&gt;&lt;li&gt;(因为aop拦截的是方法。)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Spring给我们提供了事务的管理器类&lt;/strong&gt;，事务管理器类又分为两种，因为&lt;strong&gt;JDBC的事务和Hibernate的事务是不一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring声明式事务管理器类：
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;我们基于Spring的JDBC来做例子吧&lt;/p&gt;
&lt;p&gt;引入相关jar包&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;AOP相关的jar包【因为Spring的声明式事务控制是基于AOP的，那么就需要引入AOP的jar包。】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入tx名称空间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入AOP名称空间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入jdbcjar包【jdbc.jar包和tx.jar包】&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;搭建配置环境&quot;&gt;搭建配置环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;编写一个接口&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; IUser {
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;UserDao实现类，使用JdbcTemplate对数据库进行操作！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Repository&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserDao &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; IUser {

    &lt;span class=&quot;co&quot;&gt;//使用Spring的自动装配&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JdbcTemplate template;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;() {
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;insert into user(name,password) values('zhong','222')&quot;&lt;/span&gt;;
        template.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;userService&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserService {

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; UserDao userDao;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;() {

        userDao.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;bean.xml配置：配置数据库连接池、jdbcTemplate对象、扫描注解&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:context=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:c=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/c&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;


    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--数据连接池配置--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;driverClass&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql:///zhongfucheng&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;initialPoolSize&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxPoolSize&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxStatements&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;acquireIncrement&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--扫描注解--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; base-package=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;bb&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 2. 创建JdbcTemplate对象 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbcTemplate&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;前面搭建环境的的时候，是没有任何的事务控制的。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;当我在service中调用两次userDao.save()，即时在中途中有异常抛出，还是可以在数据库插入一条记录的&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Service代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserService {

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; UserDao userDao;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;() {

        userDao.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();

        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        userDao.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;测试代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Test2 {

    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;test33&lt;/span&gt;() {
        ApplicationContext ac = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;bb/bean.xml&quot;&lt;/span&gt;);

        UserService userService = (UserService) ac.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userService&quot;&lt;/span&gt;);
        userService.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515141610075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;xml方式实现声明式事务控制&quot;&gt;XML方式实现声明式事务控制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;首先，我们要配置事务的管理器类：因为JDBC和Hibernate的事务控制是不同的。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--1.配置事务的管理器类:JDBC--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;txManage&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;&amp;lt;!--引用数据库连接池--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再而，&lt;strong&gt;配置事务管理器类如何管理事务&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--2.配置如何管理事务--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tx:advice&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;txAdvice&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; transaction-manager=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;txManage&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!--配置事务的属性--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tx:attributes&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!--所有的方法，并不是只读--&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;tx:method&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; read-only=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tx:attributes&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tx:advice&amp;gt;&lt;/span&gt;
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，&lt;strong&gt;配置拦截哪些方法，&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--3.配置拦截哪些方法+事务的属性--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;aop:config&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;aop:pointcut&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;pt&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; expression=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;execution(* bb.UserService.*(..) )&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;aop:advisor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; advice-ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;txAdvice&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; pointcut-ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;pt&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/aop:advisor&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/aop:config&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置完成之后，service中的方法都应该被Spring的声明式事务控制了。因此我们再次测试一下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;test33&lt;/span&gt;() {
        ApplicationContext ac = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;bb/bean.xml&quot;&lt;/span&gt;);

        UserService userService = (UserService) ac.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userService&quot;&lt;/span&gt;);
        userService.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515143020054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;使用注解的方法实现事务控制&quot;&gt;使用注解的方法实现事务控制&lt;/h2&gt;
&lt;p&gt;当然了，有的人可能觉得到XML文件上配置太多东西了。&lt;strong&gt;Spring也提供了使用注解的方式来实现对事务控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步和XML的是一样的，&lt;strong&gt;必须配置事务管理器类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--1.配置事务的管理器类:JDBC--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;txManage&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;&amp;lt;!--引用数据库连接池--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：开启以注解的方式来实现事务控制&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--开启以注解的方式实现事务控制--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tx:annotation-driven&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; transaction-manager=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;txManage&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，&lt;strong&gt;想要控制哪个方法事务，&lt;a href=&quot;mailto:在其前面添加@transactional这个注解就行了&quot;&gt;在其前面添加@Transactional这个注解就行了&lt;/a&gt;！&lt;/strong&gt;如果想要控制整个类的事务，那么在类上面添加就行了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Transactional&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;() {

        userDao.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();

        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        userDao.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515143515728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;其实我们&lt;strong&gt;在XML配置管理器类如何管理事务，就是在指定事务的属性！&lt;/strong&gt;我们来看一下事务的属性有什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515143952122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于事务的隔离级别，不清楚的朋友可参考我之前的博文：&lt;a href=&quot;http://blog.csdn.net/hon_3y/article/details/53760782&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/hon_3y/article/details/53760782&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;事务传播行为&quot;&gt;事务传播行为:&lt;/h2&gt;
&lt;p&gt;看了上面的事务属性，没有接触过的其实就这么一个：&lt;code&gt;propagation = Propagation.REQUIRED&lt;/code&gt;事务的传播行为。&lt;/p&gt;
&lt;p&gt;事务传播行为的属性有以下这么多个，常用的就只有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Propagation.REQUIRED【如果当前方法已经有事务了，&lt;strong&gt;加入当前方法事务&lt;/strong&gt;】&lt;/li&gt;
&lt;li&gt;Propagation.REQUIRED_NEW【如果当前方法有事务了，当前方法事务会挂起。&lt;strong&gt;始终开启一个新的事务&lt;/strong&gt;，直到新的事务执行完、当前方法的事务才开始】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170515144431770?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;当事务传播行为是propagation.required&quot;&gt;&lt;strong&gt;当事务传播行为是Propagation.REQUIRED&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    Propagation.&lt;span class=&quot;fu&quot;&gt;REQUIRED&lt;/span&gt;
    Void  &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;(){
        &lt;span class=&quot;fu&quot;&gt;insertLog&lt;/span&gt;();   
        &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;saveDept()本身就存在着一个事务，当调用insertLog()的时候，insertLog()的事务会加入到saveDept()事务中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;saveDept()方法内始终是一个事务，如果在途中出现了异常，那么insertLog()的数据是会被回滚的【因为在同一事务内】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    Void  &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;(){
        &lt;span class=&quot;fu&quot;&gt;insertLog&lt;/span&gt;();    &lt;span class=&quot;co&quot;&gt;// 加入当前事务&lt;/span&gt;
        .. 异常, 会回滚
        &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3 id=&quot;当事务传播行为是propagation.required_new&quot;&gt;&lt;strong&gt;当事务传播行为是Propagation.REQUIRED_NEW&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    Propagation.&lt;span class=&quot;fu&quot;&gt;REQUIRED&lt;/span&gt;
    Void  &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;(){
        &lt;span class=&quot;fu&quot;&gt;insertLog&lt;/span&gt;();   
        &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行到saveDept()中的insertLog()方法时，&lt;strong&gt;insertLog()方法发现 saveDept()已经存在事务了，insertLog()会独自新开一个事务，直到事务关闭之后，再执行下面的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果在中途中抛出了异常，insertLog()是不会回滚的，因为它的事务是自己的，已经提交了&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    Void  &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;(){
        &lt;span class=&quot;fu&quot;&gt;insertLog&lt;/span&gt;();    &lt;span class=&quot;co&quot;&gt;// 始终开启事务&lt;/span&gt;
        .. 异常, 日志不会回滚
        &lt;span class=&quot;fu&quot;&gt;saveDept&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 15 Mar 2018 04:56:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8572987.html</dc:identifier>
</item>
<item>
<title>iOS学习——UIPickerView的实现年月选择器 - mukekeheart</title>
<link>http://www.cnblogs.com/mukekeheart/p/8572628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mukekeheart/p/8572628.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　最近项目上需要用到一个选择器，选择器中的内容只有年和月，而在iOS系统自带的日期选择器UIDatePicker中却只有四个选项如下，分别是时间（时分秒）、日期（年月日）、日期+时间（年月日时分）以及倒计时。其中并没有我们所需要的只显示年月的选择器，在网上找了很多相关的资料，但是觉得都写得过于麻烦。因此，为了满足项目需求，自己用UIPickerView写了一个只显示年月的选择器界面，同时还可以控制我们的显示的最小时间。当然，如果要控制其他内容也都是可以的，无非就是在数据处理上多一些处理和控制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;typedef NS_ENUM(NSInteger, UIDatePickerMode) {
    UIDatePickerModeTime,           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Displays hour, minute, and optionally AM/PM designation depending on the locale setting (e.g. 6 | 53 | PM)&lt;/span&gt;
    UIDatePickerModeDate,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Displays month, day, and year depending on the locale setting (e.g. November | 15 | 2007)&lt;/span&gt;
    UIDatePickerModeDateAndTime,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Displays date, hour, minute, and optionally AM/PM designation depending on the locale setting (e.g. Wed Nov 15 | 6 | 53 | PM)&lt;/span&gt;
    UIDatePickerModeCountDownTimer, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Displays hour and minute (e.g. 1 | 53)&lt;/span&gt;
} __TVOS_PROHIBITED;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　在整个实现中分为两个部分，首先是用一个基类来布局我们选择器的整体布局，包括我们的选择器的标题，取消、确定按钮，蒙层等大框架的布局，然后是子类在基类的基础上添加UIPickerView来实现选择器的基本功能以及数据加载和显示。首先，我们来看一下整体的一个效果，点击某个设定的控件，然后弹出下图所示的一个选择器，选择器的选项主要就是显年月的信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/926487/201803/926487-20180315094835388-1575232306.png&quot; alt=&quot;&quot; width=&quot;174&quot; height=&quot;308&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　在上一部分说了，基类布局主要是对整体的架构进行布局，我们先看下有哪些内容，包括了背景蒙层视图、弹出视图（包含标题行（又包含取消按钮、确定按钮和标题）、分割线和选择器），在子类中会进行一个整体的布局，在 &lt;span class=&quot;cnblogs_code&quot;&gt;- (&lt;span&gt;void&lt;/span&gt;)initUI&lt;/span&gt; 方法中进行布局。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  BaseView.h&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &amp;lt;UIKit/UIKit.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; kDatePicHeight 200  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择器的高度&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; kTopViewHeight 44   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消 标题 确定 行高度&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; SCREEN_BOUNDS [UIScreen mainScreen].bounds
&lt;span&gt;#define&lt;/span&gt; SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width
&lt;span&gt;#define&lt;/span&gt; SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height&lt;br/&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; BaseView : UIView
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 背景蒙层视图&lt;/span&gt;
@property (nonatomic, strong) UIView *&lt;span&gt;backgroundView;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 弹出视图&lt;/span&gt;
@property (nonatomic, strong) UIView *&lt;span&gt;alertView;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标题行顶部视图&lt;/span&gt;
@property (nonatomic, strong) UIView *&lt;span&gt;topView;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左边取消按钮&lt;/span&gt;
@property (nonatomic, strong) UIButton *&lt;span&gt;leftBtn;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右边确定按钮&lt;/span&gt;
@property (nonatomic, strong) UIButton *&lt;span&gt;rightBtn;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中间标题&lt;/span&gt;
@property (nonatomic, strong) UILabel *&lt;span&gt;titleLabel;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分割线视图&lt;/span&gt;
@property (nonatomic, strong) UIView *&lt;span&gt;lineView;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 初始化子视图 ，整体布局&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initUI;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下三种方法在基类中的实现都是空白的，具体的效果在子类中重写&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;* 点击背景遮罩图层事件 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)didTapBackgroundView:(UITapGestureRecognizer *&lt;span&gt;)sender;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 取消按钮的点击事件 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)clickLeftBtn;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 确定按钮的点击事件 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)clickRightBtn;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　具体的.m文件的实现代码如下，进行折叠了，需要的可以直接拷贝，在后面我们再 进行具体分析每一步的布局和设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('10374494-6248-4030-84c9-7daaf935a101')&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_10374494-6248-4030-84c9-7daaf935a101&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_10374494-6248-4030-84c9-7daaf935a101&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('10374494-6248-4030-84c9-7daaf935a101',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_10374494-6248-4030-84c9-7daaf935a101&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  BaseView.m
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  CJMobile
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Created by mukekeheart on 2017/12/12.
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Copyright © 2017年 长江证券. All rights reserved.
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BaseView.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; BaseView
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initUI {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     self.frame =&lt;span&gt; SCREEN_BOUNDS;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 背景遮罩图层&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;    [self addSubview:self.backgroundView];
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 弹出视图&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;    [self addSubview:self.alertView];
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置弹出视图子视图
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加顶部标题栏&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;    [self.alertView addSubview:self.topView];
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加左边取消按钮&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    [self.topView addSubview:self.leftBtn];
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加右边确定按钮&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    [self.topView addSubview:self.rightBtn];
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加中间标题按钮&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    [self.topView addSubview:self.titleLabel];
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加分割线&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    [self.topView addSubview:self.lineView];
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 背景遮罩图层
&lt;span&gt; 33&lt;/span&gt; - (UIView *&lt;span&gt;)backgroundView {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_backgroundView) {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         _backgroundView =&lt;span&gt; [[UIView alloc]initWithFrame:SCREEN_BOUNDS];
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         _backgroundView.backgroundColor =&lt;span&gt; [UIColor blackColor] ;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         _backgroundView.alpha = &lt;span&gt;0.3f&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         _backgroundView.userInteractionEnabled =&lt;span&gt; YES;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         UITapGestureRecognizer *myTap =&lt;span&gt; [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(didTapBackgroundView:)];
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;        [_backgroundView addGestureRecognizer:myTap];
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _backgroundView;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 弹出视图
&lt;span&gt; 46&lt;/span&gt; - (UIView *&lt;span&gt;)alertView {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_alertView) {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         _alertView = [[UIView alloc]initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, SCREEN_HEIGHT - kTopViewHeight - kDatePicHeight, SCREEN_WIDTH, kTopViewHeight +&lt;span&gt; kDatePicHeight)];
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         _alertView.backgroundColor =&lt;span&gt; [UIColor whiteColor];
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _alertView;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 顶部标题栏视图
&lt;span&gt; 55&lt;/span&gt; - (UIView *&lt;span&gt;)topView {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_topView) {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         _topView =[[UIView alloc]initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, SCREEN_WIDTH, kTopViewHeight + &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)];
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         _topView.backgroundColor =&lt;span&gt; [UIColor whiteColor];
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _topView;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 左边取消按钮
&lt;span&gt; 64&lt;/span&gt; - (UIButton *&lt;span&gt;)leftBtn {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_leftBtn) {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         _leftBtn =&lt;span&gt; [UIButton buttonWithType:UIButtonTypeCustom];
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         _leftBtn.frame = CGRectMake(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         _leftBtn.backgroundColor =&lt;span&gt; [UIColor clearColor];
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         _leftBtn.layer.masksToBounds =&lt;span&gt; YES;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         _leftBtn.titleLabel.font = [UIFont systemFontOfSize:&lt;span&gt;17.0f&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        [_leftBtn setTitleColor:kGrayFontColor forState:UIControlStateNormal];
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         [_leftBtn setTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;取消&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; forState:UIControlStateNormal];
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        [_leftBtn addTarget:self action:@selector(clickLeftBtn) forControlEvents:UIControlEventTouchUpInside];
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _leftBtn;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 右边确定按钮
&lt;span&gt; 79&lt;/span&gt; - (UIButton *&lt;span&gt;)rightBtn {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_rightBtn) {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         _rightBtn =&lt;span&gt; [UIButton buttonWithType:UIButtonTypeCustom];
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         _rightBtn.frame = CGRectMake(SCREEN_WIDTH - &lt;span&gt;65&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         _rightBtn.backgroundColor =&lt;span&gt; [UIColor clearColor];
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         _rightBtn.layer.masksToBounds =&lt;span&gt; YES;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         _rightBtn.titleLabel.font = [UIFont systemFontOfSize:&lt;span&gt;17.0f&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        [_rightBtn setTitleColor:kBlueFontColor forState:UIControlStateNormal];
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         [_rightBtn setTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; forState:UIControlStateNormal];
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        [_rightBtn addTarget:self action:@selector(clickRightBtn) forControlEvents:UIControlEventTouchUpInside];
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _rightBtn;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 中间标题按钮
&lt;span&gt; 94&lt;/span&gt; - (UILabel *&lt;span&gt;)titleLabel {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_titleLabel) {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         _titleLabel = [[UILabel alloc]initWithFrame:CGRectMake(&lt;span&gt;65&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, SCREEN_WIDTH - &lt;span&gt;130&lt;/span&gt;&lt;span&gt;, kTopViewHeight)];
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         _titleLabel.backgroundColor =&lt;span&gt; [UIColor clearColor];
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         _titleLabel.font = [UIFont systemFontOfSize:&lt;span&gt;17.0f&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         _titleLabel.textColor =&lt;span&gt; kBlackFontColor;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         _titleLabel.textAlignment =&lt;span&gt; NSTextAlignmentCenter;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _titleLabel;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 分割线
&lt;span&gt;106&lt;/span&gt; - (UIView *&lt;span&gt;)lineView {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_lineView) {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         _lineView = [[UIView alloc]initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, kTopViewHeight, SCREEN_WIDTH, &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)];
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         _lineView.backgroundColor  = [UIColor colorWithRed:&lt;span&gt;225&lt;/span&gt; / &lt;span&gt;255.0&lt;/span&gt; green:&lt;span&gt;225&lt;/span&gt; / &lt;span&gt;255.0&lt;/span&gt; blue:&lt;span&gt;225&lt;/span&gt; / &lt;span&gt;255.0&lt;/span&gt; alpha:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;        [self.alertView addSubview:_lineView];
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _lineView;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 点击背景遮罩图层事件
&lt;span&gt;116&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;)didTapBackgroundView:(UITapGestureRecognizer *&lt;span&gt;)sender {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 取消按钮的点击事件
&lt;span&gt;121&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)clickLeftBtn {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 确定按钮的点击事件
&lt;span&gt;126&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)clickRightBtn {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BaseView.m&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在BaseView.m中主要是对整体框架进行布局，我们的控件的位置都是通过绝对位置进行布局的，所以需要修改的在话可以直接在对应的位置上进行修改，然后在BaseView.h中的注释我们说过了，点击背景遮罩图层和取消、确定按钮的点击事件实现效果在基类中都是空白的，具体效果在子类中进行重写来控制。而对于弹出视图中的标题行（包含取消按钮、确定按钮和标题）、分割线和选择器的具体布局在这里就不进行展开了，很简单的部分，大家自行看一下代码就OK了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面主要提两个问题：一个是整体布局的方法 &lt;span class=&quot;cnblogs_code&quot;&gt;- (&lt;span&gt;void&lt;/span&gt;)initUI&lt;/span&gt; 的实现。这里大家主要要注意的添加的层次，谁是谁的子视图，一定要区分清楚。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initUI {
    self.frame &lt;/span&gt;=&lt;span&gt; SCREEN_BOUNDS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 背景遮罩图层&lt;/span&gt;
&lt;span&gt;    [self addSubview:self.backgroundView];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 弹出视图&lt;/span&gt;
&lt;span&gt;    [self addSubview:self.alertView];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置弹出视图子视图
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加顶部标题栏&lt;/span&gt;
&lt;span&gt;    [self.alertView addSubview:self.topView];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加左边取消按钮&lt;/span&gt;
&lt;span&gt;    [self.topView addSubview:self.leftBtn];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加右边确定按钮&lt;/span&gt;
&lt;span&gt;    [self.topView addSubview:self.rightBtn];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加中间标题按钮&lt;/span&gt;
&lt;span&gt;    [self.topView addSubview:self.titleLabel];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加分割线&lt;/span&gt;
&lt;span&gt;    [self.topView addSubview:self.lineView];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;二是我们的背景蒙层和弹出视图大家可以通过代码看到蒙层遮罩背景的布局是整个屏幕，那么我们为什么不直接在蒙层上添加弹出式图呢？如果直接在蒙层上添加弹出式图作为子视图的话，我们的布局相对会简单很多，这里涉及到一点就是&lt;span&gt;&lt;strong&gt;子视图的透明度是和父视图保持一致的&lt;/strong&gt;&lt;/span&gt;，如果直接将弹出视图加载到蒙层遮罩视图上，会导致弹出视图的透明度也为0.3，所以弹出视图不能直接加在蒙层遮罩视图上，而是需要加在当前界面上。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (UIView *&lt;span&gt;)backgroundView {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_backgroundView) {
        _backgroundView &lt;/span&gt;=&lt;span&gt; [[UIView alloc]initWithFrame:SCREEN_BOUNDS];
        _backgroundView.backgroundColor &lt;/span&gt;=&lt;span&gt; [UIColor blackColor] ;
        _backgroundView.alpha &lt;/span&gt;= &lt;span&gt;0.3f&lt;/span&gt;&lt;span&gt; ;
        _backgroundView.userInteractionEnabled &lt;/span&gt;=&lt;span&gt; YES;
        UITapGestureRecognizer &lt;/span&gt;*myTap =&lt;span&gt; [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(didTapBackgroundView:)];
        [_backgroundView addGestureRecognizer:myTap];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _backgroundView;
}


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 背景遮罩图层&lt;/span&gt;
&lt;span&gt;    [self addSubview:self.backgroundView];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 弹出视图&lt;/span&gt;
    [self addSubview:self.alertView];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　首先是我们的子类向外暴露的方法只有一个类方法，该方法主要是让使用者提供选择器的标题、最小日期、日期选择完成后的操作等基本信息，方便我们对选择器的数据和操作进行设置。对外暴露类方法也是避免使用者在使用时需要创建对象，比较麻烦，也避免一些不必要的问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  CJYearMonthSelectedView.h&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &amp;lt;UIKit/UIKit.h&amp;gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BaseView.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期选择完成之后的操作&lt;/span&gt;
typedef &lt;span&gt;void&lt;/span&gt;(^BRDateResultBlock)(NSString *&lt;span&gt;selectValue);

&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; CJYearMonthSelectedView : BaseView

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对外开放的类方法&lt;/span&gt;
+ (&lt;span&gt;void&lt;/span&gt;)showDatePickerWithTitle:(NSString *)title minDateStr:(NSString *&lt;span&gt;)minDateStr resultBlock:(BRDateResultBlock)resultBlock;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;　　关于具体的子类的实现，还是先把所有代码都贴上来，有点多，所以折叠一下，后面对其中一些要点进行列出说明一下。还有取消、确定按钮的点击事件也都在这里进行控制和实现，我们根据自己的需要进行这是就可以了，一般是在点击确定按钮的时候调用我们的BRDateResultBlock，实现日期选择完成的操作。其中&lt;/span&gt;&lt;span&gt;&lt;strong&gt;取消按钮就直接没有操作，dismiss当前界面，并注意要进行dealloc，创建的视图要清除，避免内存泄露&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。蒙层背景点击事件看需求，有的需要和取消一样的效果，有的可能就无效果，自己添加即可。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('20c37513-0a1d-4f39-9dc3-8a0cd2ae2a4d')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_20c37513-0a1d-4f39-9dc3-8a0cd2ae2a4d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20c37513-0a1d-4f39-9dc3-8a0cd2ae2a4d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('20c37513-0a1d-4f39-9dc3-8a0cd2ae2a4d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20c37513-0a1d-4f39-9dc3-8a0cd2ae2a4d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  CJYearMonthSelectedView.m&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CJYearMonthSelectedView.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; CJYearMonthSelectedView () &amp;lt;UIPickerViewDelegate,UIPickerViewDataSource&amp;gt;
&lt;span&gt;  6&lt;/span&gt; @property (strong, nonatomic) UIPickerView *picker;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择器&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; @property (copy, nonatomic) NSString *&lt;span&gt;title;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; @property (copy, nonatomic) NSString *&lt;span&gt;minDateStr;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;@property (assign, nonatomic) BRDateResultBlock resultBlock;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; @property (copy, nonatomic) NSString *selectValue;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择的值 &lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; @property (strong, nonatomic) NSMutableArray&amp;lt;NSString *&amp;gt; *&lt;span&gt;data;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;@end&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; CJYearMonthSelectedView
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; + (&lt;span&gt;void&lt;/span&gt;)showDatePickerWithTitle:(NSString *)title minDateStr:(NSString *&lt;span&gt;)minDateStr resultBlock:(BRDateResultBlock)resultBlock{
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     
&lt;span&gt; 19&lt;/span&gt;     CJYearMonthSelectedView *datePicker =&lt;span&gt; [[CJYearMonthSelectedView alloc] initWithTitle:title minDateStr:minDateStr resultBlock:resultBlock];
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    [datePicker showWithAnimation:YES];
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化方法&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; - (instancetype)initWithTitle:(NSString *)title minDateStr:(NSString *&lt;span&gt;)minDateStr resultBlock:(BRDateResultBlock)resultBlock{
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (self =&lt;span&gt; [super init]) {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         _title =&lt;span&gt; title;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         _minDateStr =&lt;span&gt; minDateStr;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         _resultBlock =&lt;span&gt; resultBlock;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        [self initUI];
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;UI布局，主要就是在弹出视图上添加选择器&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initUI{
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;    [super initUI];
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     self.titleLabel.text =&lt;span&gt; _title;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加时间选择器&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    [self.alertView addSubview:self.picker];
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择器的初始化和布局&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; - (UIPickerView *&lt;span&gt;)picker{
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_picker) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         _picker = [[UIPickerView alloc] initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, kTopViewHeight + &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;, SCREEN_WIDTH, kDatePicHeight)];
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        _picker.backgroundColor = [UIColor whiteColor];&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         _picker.showsSelectionIndicator =&lt;span&gt; YES;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置代理&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         _picker.&lt;span&gt;delegate&lt;/span&gt; =&lt;span&gt;self;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         _picker.dataSource =&lt;span&gt;self;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _picker;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择器数据的加载，从设定的最小日期到当前月&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; - (NSMutableArray&amp;lt;NSString *&amp;gt; *&lt;span&gt;)data{
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_data) {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         _data =&lt;span&gt; [[NSMutableArray alloc] init];
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         NSDate *currentDate =&lt;span&gt; [NSDate date];
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         NSDateFormatter *formatter =&lt;span&gt; [[NSDateFormatter alloc] init];
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         [formatter setDateFormat:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         NSCalendar *calendar =&lt;span&gt; [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         NSDateComponents *lastMonthComps =&lt;span&gt; [[NSDateComponents alloc] init];
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         NSString *dateStr =&lt;span&gt; [formatter stringFromDate:currentDate];
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         NSInteger lastIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         NSDate *&lt;span&gt;newdate;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环获取可选月份，从当前月份到最小月份&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (!([dateStr compare:self.minDateStr] ==&lt;span&gt; NSOrderedAscending)) {
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;            [_data addObject:dateStr];
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             lastIndex--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取之前几个月&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            [lastMonthComps setMonth:lastIndex];
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             newdate = [calendar dateByAddingComponents:lastMonthComps toDate:currentDate options:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             dateStr =&lt;span&gt; [formatter stringFromDate:newdate];
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _data;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - UIPickerView的数据和布局，和tableview类似
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回多少列&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; -(NSInteger)numberOfComponentsInPickerView:(UIPickerView *&lt;span&gt;)pickerView{
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回多少行&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt; - (NSInteger)pickerView:(UIPickerView *&lt;span&gt;)pickerView numberOfRowsInComponent:(NSInteger)component{
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data.count;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每一行的数据&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt; -(NSString *)pickerView:(UIPickerView *&lt;span&gt;)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component{
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data[row];
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选中时的效果&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt; -(&lt;span&gt;void&lt;/span&gt;)pickerView:(UIPickerView *&lt;span&gt;)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component{
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     self.selectValue =&lt;span&gt; self.data[row];
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回高度&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; -(CGFloat)pickerView:(UIPickerView *&lt;span&gt;)pickerView rowHeightForComponent:(NSInteger)component{
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;35.0f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回宽度&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; -(CGFloat)pickerView:(UIPickerView *&lt;span&gt;)pickerView widthForComponent:(NSInteger)component{
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ZYAppWidth;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 背景视图的点击事件
&lt;span&gt;114&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;)didTapBackgroundView:(UITapGestureRecognizer *&lt;span&gt;)sender {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    [self dismissWithAnimation:NO];&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 弹出视图方法
&lt;span&gt;119&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)showWithAnimation:(BOOL)animation {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 获取当前应用的主窗口&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;     UIWindow *keyWindow =&lt;span&gt; [[UIApplication sharedApplication] keyWindow];
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    [keyWindow addSubview:self];
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (animation) {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画前初始位置&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt;         CGRect rect =&lt;span&gt; self.alertView.frame;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         rect.origin.y =&lt;span&gt; SCREEN_HEIGHT;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;         self.alertView.frame =&lt;span&gt; rect;
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 浮现动画&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;         [UIView animateWithDuration:&lt;span&gt;0.3&lt;/span&gt; animations:^&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             CGRect rect =&lt;span&gt; self.alertView.frame;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             rect.origin.y -= kDatePicHeight +&lt;span&gt; kTopViewHeight;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             self.alertView.frame =&lt;span&gt; rect;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;        }];
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 关闭视图方法
&lt;span&gt;138&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)dismissWithAnimation:(BOOL)animation {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭动画&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;     [UIView animateWithDuration:&lt;span&gt;0.2&lt;/span&gt; animations:^&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         CGRect rect =&lt;span&gt; self.alertView.frame;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         rect.origin.y += kDatePicHeight +&lt;span&gt; kTopViewHeight;
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         self.alertView.frame =&lt;span&gt; rect;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         
&lt;span&gt;145&lt;/span&gt;         self.backgroundView.alpha = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;     } completion:^&lt;span&gt;(BOOL finished) {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        [self.leftBtn removeFromSuperview];
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        [self.rightBtn removeFromSuperview];
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;        [self.titleLabel removeFromSuperview];
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;        [self.lineView removeFromSuperview];
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;        [self.topView removeFromSuperview];
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;        [self.picker removeFromSuperview];
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;        [self.alertView removeFromSuperview];
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;        [self.backgroundView removeFromSuperview];
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;        [self removeFromSuperview];
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         
&lt;span&gt;157&lt;/span&gt;         self.leftBtn =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         self.rightBtn =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;         self.titleLabel =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         self.lineView =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         self.topView =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         self.picker =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;         self.alertView =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         self.backgroundView =&lt;span&gt; nil;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;    }];
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 取消按钮的点击事件
&lt;span&gt;169&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)clickLeftBtn {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;    [self dismissWithAnimation:YES];
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - 确定按钮的点击事件
&lt;span&gt;174&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)clickRightBtn {
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;点击确定按钮后，执行block回调&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;    [self dismissWithAnimation:YES];
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_resultBlock) {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        _resultBlock(_selectValue);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; 
&lt;span&gt;182&lt;/span&gt; &lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;CJYearMonthSelectedView.m&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里面跟着流程看其实很简单哈，主要需要说明的一点就是UIPickerView的用法，UIPickerView其实和UITableView很类似，在初始化的时候需要设置其数据代理和视图代理（&lt;/span&gt;UIPickerViewDelegate，UIPickerViewDataSource&lt;span&gt;），然后通过这两个代理进内容、行数、列数的控制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
- (UIPickerView *&lt;span&gt;)picker{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_picker) {
        _picker &lt;/span&gt;= [[UIPickerView alloc] initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, kTopViewHeight + &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;, SCREEN_WIDTH, kDatePicHeight)];
        _picker.showsSelectionIndicator &lt;/span&gt;=&lt;span&gt; YES;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置UIPickerView的代理&lt;/span&gt;
        _picker.&lt;span&gt;delegate&lt;/span&gt; =&lt;span&gt;self;
        _picker.dataSource &lt;/span&gt;=&lt;span&gt;self;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _picker;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#pragma&lt;/span&gt; mark - UIPickerView
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回多少列&lt;/span&gt;
-(NSInteger)numberOfComponentsInPickerView:(UIPickerView *&lt;span&gt;)pickerView{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回多少行&lt;/span&gt;
- (NSInteger)pickerView:(UIPickerView *&lt;span&gt;)pickerView numberOfRowsInComponent:(NSInteger)component{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data.count;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每一行的数据&lt;/span&gt;
-(NSString *)pickerView:(UIPickerView *&lt;span&gt;)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data[row];
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选中时的效果&lt;/span&gt;
-(&lt;span&gt;void&lt;/span&gt;)pickerView:(UIPickerView *&lt;span&gt;)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component{
    self.selectValue &lt;/span&gt;=&lt;span&gt; self.data[row];
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回高度&lt;/span&gt;
-(CGFloat)pickerView:(UIPickerView *&lt;span&gt;)pickerView rowHeightForComponent:(NSInteger)component{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;35.0f&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回宽度&lt;/span&gt;
-(CGFloat)pickerView:(UIPickerView *&lt;span&gt;)pickerView widthForComponent:(NSInteger)component{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ZYAppWidth;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　关于数据的控制可以根据我们的需要进行设定，行数和列数也是根据我们的需求来进行控制。下面主要就是说一下如何获取年月这样的数据，主要是用到了NSDateComponents 的直接获取一个月前的信息，然后通过将NSCalendar将NSDateComponents转化为日期Date，最后将Date转化为我们需要的格式的数据。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据获取&lt;/span&gt;
- (NSMutableArray&amp;lt;NSString *&amp;gt; *&lt;span&gt;)data{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_data) {
        _data &lt;/span&gt;=&lt;span&gt; [[NSMutableArray alloc] init];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前日期时间&lt;/span&gt;
        NSDate *currentDate =&lt;span&gt; [NSDate date];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定数据格式为xxxx-mm&lt;/span&gt;
        NSDateFormatter *formatter =&lt;span&gt; [[NSDateFormatter alloc] init];
        [formatter setDateFormat:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过日历可以直接获取前几个月的日期，所以这里直接用该类的方法进行循环获取数据&lt;/span&gt;
        NSCalendar *calendar =&lt;span&gt; [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
        NSDateComponents &lt;/span&gt;*lastMonthComps =&lt;span&gt; [[NSDateComponents alloc] init];
        NSString &lt;/span&gt;*dateStr =&lt;span&gt; [formatter stringFromDate:currentDate];
        NSInteger lastIndex &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        NSDate &lt;/span&gt;*&lt;span&gt;newdate;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环获取可选月份，从当前月份到最小月份，直接用字符串的比较来判断是否大于设定的最小日期&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (!([dateStr compare:self.minDateStr] ==&lt;span&gt; NSOrderedAscending)) {
            [_data addObject:dateStr];
            lastIndex&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取之前n个月, setMonth的参数为正则向后，为负则表示之前&lt;/span&gt;
&lt;span&gt;            [lastMonthComps setMonth:lastIndex];
            newdate &lt;/span&gt;= [calendar dateByAddingComponents:lastMonthComps toDate:currentDate options:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            dateStr &lt;/span&gt;=&lt;span&gt; [formatter stringFromDate:newdate];
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _data;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;四 使用方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;关于自己做的这个在使用上就非常简单了，我们的子类向外就暴露了一个类方法，所以我们再需要弹出选择器的地方调用该方法就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;) btnPress:(UIButton *&lt;span&gt;)sender{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sender.tag == &lt;span&gt;200&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出 按钮&lt;/span&gt;
        [CJYearMonthSelectedView showDatePickerWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;选择月份&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; minDateStr:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;2017-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; resultBlock:^(NSString *&lt;span&gt;selectValue) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择完成后的操作&lt;/span&gt;
            NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;selected month is %@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, selectValue);
        }];
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;以上就是使用UIPickerView自定义一个年月的选择器，包括最初的的完整的界面代码和具体的选择器的创建和布局，以及我们的数据处理。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 15 Mar 2018 04:12:00 +0000</pubDate>
<dc:creator>mukekeheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mukekeheart/p/8572628.html</dc:identifier>
</item>
</channel>
</rss>