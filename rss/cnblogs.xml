<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python爬虫起步... - 踏破凌霄城</title>
<link>http://www.cnblogs.com/zrmw/p/9266008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zrmw/p/9266008.html</guid>
<description>&lt;p&gt;最近在研究python爬虫的相关内容。一点一点来吧，由浅入深，稍微后面一点会搞搞分布式爬虫框架scrapy + MongoDB，现在先做一些requests + bs4的简单爬虫，稍后一点会将数据存放到数据库，这里先预定使用 myssql，而且爬取的基本是一些没有任何反扒机制的网站。&lt;/p&gt;
&lt;p&gt;关于静态网页和动态网页的区别，以后也会介绍的，现在已经11点多了，起个头，洗洗睡了。&lt;/p&gt;
&lt;p&gt;首先介绍下环境搭建。&lt;/p&gt;
&lt;p&gt;我这里用的是win10系统，最最简单快捷的方法，真的是一个软件就解决的事，不需要下载python，不需要配置环境变量，不需要下载pycharm！&lt;/p&gt;
&lt;p&gt;那就是anaconda。它不仅包含了python开发所需要的环境，而且是一个方便快捷的python第三方包安装管理工具，比pip要方便的多，虽然pip和pycharm都可以安装第三方模块。&lt;/p&gt;
&lt;p&gt;这里是官网下载地址：https://www.anaconda.com/download/&lt;/p&gt;
&lt;p&gt;根据自己的电脑和想要使用的python版本，下载相应的版本，一步步安装即可，只有一点需要注意的，安装过程中，记不清具体是什么，大概是 just for me/ for everyone， 这里要选择 for everyone，然后一步步next。&lt;/p&gt;
&lt;p&gt;这里放一张软件截图给大家，让大家先感受下 anaconda 的方便之处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1301446/201807/1301446-20180704232253668-120930613.png&quot; alt=&quot;&quot; width=&quot;1104&quot; height=&quot;590&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击 spyder ，一个仅仅比pycharm逊色一点的开发工具就打开了。如果想要代码自动补全的功能，大家可以百度下哈，这里就不介绍了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1301446/201807/1301446-20180704232923825-1643718058.png&quot; alt=&quot;&quot; width=&quot;1090&quot; height=&quot;584&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Jul 2018 15:30:00 +0000</pubDate>
<dc:creator>踏破凌霄城</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zrmw/p/9266008.html</dc:identifier>
</item>
<item>
<title>(三)lamda - Vincili</title>
<link>http://www.cnblogs.com/vincili/p/9265984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vincili/p/9265984.html</guid>
<description>&lt;h3 id=&quot;lambda&quot;&gt;lambda&lt;/h3&gt;
&lt;p&gt;lambda可以理解为匿名函数，由参数列表 箭头 函数主体组成&lt;br/&gt;语法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(parameters)-&amp;gt;expression 或 (parameters)-&amp;gt;{statements;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一种只有一句表达式，会默认返回表达式的值，所以隐藏了return。例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(Integer x)-&amp;gt; x+x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种用于有多个表达式逻辑的代码块，必须使用return明确返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(Integer x)-&amp;gt; {
            System.out.println(&quot;start ++x&quot;);
            ++x;
            return x;
        };&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数接口&quot;&gt;函数接口&lt;/h3&gt;
&lt;p&gt;函数接口是仅有一个抽象方法的接口，例如Function接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    R apply(T t);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数接口的作用是可以让lambda表达式为函数式接口的抽象方法提供实现，用lambda直接取代内部类&lt;br/&gt;比如runnable内部类接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Runnable r2 = new Runnable(){
    public void run(){
        System.out.println(&quot;Hello World 1&quot;);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Runnable 的lambda方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Runnable r1 = () -&amp;gt; System.out.println(&quot;Hello World 1&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种方式完全等价，可以说离开函数接口，lambda表达式没有任何作用，一个lambda函数始终是函数接口的实现。&lt;/p&gt;
&lt;h4 id=&quot;类型推断&quot;&gt;类型推断&lt;/h4&gt;
&lt;p&gt;lambda表达式可以在编辑期间自动推断参数类型&lt;br/&gt;例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Function&amp;lt;Integer,Integer&amp;gt; fs = (x)-&amp;gt; x+x;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该例子可以通过Function接口的泛型化参数推断出x是Integer类型的参数。&lt;/p&gt;
&lt;h4 id=&quot;初学者如何写好lambda表达式&quot;&gt;初学者如何写好lambda表达式&lt;/h4&gt;
&lt;p&gt;熟悉相关函数接口，明确函数接口抽象方法的结构（参数列表和返回值类型）&lt;br/&gt;例如Function接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    R apply(T t);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察抽象方法 R apply(T t);可见该抽象方法定义为由一个T类型的值返回一个R类型的返回值&lt;br/&gt;例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Function&amp;lt;Integer,String&amp;gt; fs = (x)-&amp;gt; {
          String helloString = &quot;hello&quot; + x.intValue();
          return helloString;
       };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明为输入参数T为Integer类型，返回值R为String类型，所以lambda的参数列表数目（lambda参数可以自动推断）和函数接口抽象方法数目一致，lambda方法体返回结果类型和函数接口返回值类型一致即可。&lt;/p&gt;
&lt;h4 id=&quot;方法引用&quot;&gt;方法引用&lt;/h4&gt;
&lt;p&gt;ClassName::staticMethod或者ClassName::instanceMethod&lt;br/&gt;静态方法的引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main {

    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;();
        strings.forEach(Main::print);
    }
    public static void print(String abc){
        System.out.println(abc);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是所引用的方法需要和相关的函数接口匹配（和函数接口的参数类型和返回值一致），比如这个例子的forEach方法接受的函数接口是Consumer&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Consumer是一个消费型的函数接口,接受一个T类型，无返回值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {
    void accept(T t);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而我们的print方法接受一个String类型的参数，无返回值，且strings被限定为String类型，所以Consumer的T类型是String类型，因此print方法能和Consumer函数接口匹配。&lt;br/&gt;实例方法引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.stream().sorted(String::compareTo);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;静态方法引用与实例方法引用的区别&quot;&gt;静态方法引用与实例方法引用的区别&lt;/h4&gt;
&lt;p&gt;静态方法&lt;br/&gt;ClassName::staticMethod ==== (x)-&amp;gt;{statements}&lt;br/&gt;实例方法引用&lt;br/&gt;ClassName::staticMethod ==== (x，y)-&amp;gt;{statements}&lt;br/&gt;instanceObject::instanceMethod ===== (x)-&amp;gt;{statements}&lt;br/&gt;关注公众号，一起阅读IT经典书籍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5042199-58a60aeb36e2e9ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/140&quot; alt=&quot;关注公众号，一起阅读经典书籍&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Jul 2018 15:25:00 +0000</pubDate>
<dc:creator>Vincili</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vincili/p/9265984.html</dc:identifier>
</item>
<item>
<title>vue - 使用vue实现自定义多选与单选的答题功能 - xing.org1^</title>
<link>http://www.cnblogs.com/padding1015/p/9265985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/9265985.html</guid>
<description>&lt;p&gt;&lt;span&gt;4月底立得flag，五月底插上小旗，结果拖到六月底七月初才来执行。说什么工作忙都是借口，就是睡的比猪早，起的比猪晚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本来实现多选单选这个功能，vue组件中在表单方面提供了一个v-model指令，非常的善解“猿”意，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;能把我们的多选单选功能很完美且很强大得双向绑定起来，实现多选、单选、任意选...根本不在话下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，凡事都有一个但是！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是奈何这个项目设计稿的缘故，使用原生的表单组件是不可能使用了，请看ui图：  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704224642613-989367825.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可悲的是，这个项目两个月后，我才来做项目复盘，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;话说也就在此时，我才发现有一种更简单的方式来实现并且应用上v-model，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么要为了样式放弃功能然后自己吭哧吭哧傻滴呼呼的用js来实现了类似双向绑定的感觉！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flag：今天先专注把我费劲巴拉手动搬得砖总结一下，明天（07-05）我再把所谓的最简单的方法做出来贴这里~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这个需求的难点在于以下几点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1．单选点击后选中状态，需满足如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a) 每次点击只能选中其中一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b) 当选中时再次点击其他选项需要切换选择对应点击项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　c) 选中时点击自身无显示上的反应(同样的逻辑再做一遍也无妨，即再加一遍类名也看不出来)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2．多选样式展示，需满足如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a) 同时可以选中多个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b) 多选已选中状态再次点击取消选中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3．多选选中项的记录，需满足如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a) 选择几个记录几个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b) 选中再取消时需要将本条记录的数据通时消除(依据点击事件，事件点击触发判断哪个被选中了)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4．单选选中项的记录，方便提交数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5．未点击选项不可提交，并给提示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6．可提交状态，需满足如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a) 单选选中任意一个，即可提交。再次修改对提交没有影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b) 多选至少选中一个可提交，再次修改需判断是不是没选东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7．第十四题点下一题切换提交按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8．快速点击下一题，多次提交&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9．点击下一题提交数据后，拿响应结果调取弹层提示用户选择是否正确&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=============接下来一 一解决====================&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先先说结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看似十道题，其实是一道题不停的换数据，所以我的外部结构就是一个form加一个空的div&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;别问我为什么多余一个空的，我也很无措。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
form.question(v-if=&quot;state.ExamInfo&quot;)
　div
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后题目标题很傻瓜式得使用了h3&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
h3.qus-title(:data-id=&quot;state.ExamInfo.QuestionID&quot;) {{state.ExamInfo.ExamQuestionNo}} {{state.ExamInfo.Description}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;选项上，我使用ul&amp;gt;li的形式描述了多个选项&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
ul.qus-list
    li(v-for=&quot;(item,index) in state.ExamInfo.QuestionAnswerCode&quot; @click=&quot;choosed(index)&quot; v-bind:class=&quot;{'li-focus' : chooseNum==index}&quot; ref=&quot;liId&quot;) {{item.Code}}、{{item.Description}}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;大致几个属性&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;v-for是为了遍历题中的每一个选项，&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;click绑定了点击当前li时的事件，v-bind同步click绑定了动态的类名，用于展示选中状态。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;这里值得注意的一个点也是当时抓虾的一个点是，v-on:click和v-bind:class结合，&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;click的时候，每次把当前点击的li的index值传出去，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后定义一个变量chooseNum，点击函数中，将参数index赋给他&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
this.chooseNum = index;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;靠这种间接拿到点击索引值的曲线救国方式，在v-bind的监视下，每次点击获得的索引chooseNum&lt;/span&gt;&lt;span&gt;和这几个li中自己的index对上眼以后，就如正确的钥匙对上了合适的锁，类名绑定就成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是以上难题中的第一个难题的前半部分：&lt;span&gt;&lt;strong&gt;单选点击后选中状态&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704224928962-1086752033.png&quot; alt=&quot;&quot; width=&quot;184&quot; height=&quot;328&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704224941552-1137205357.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704224945867-1028820338.png&quot; alt=&quot;&quot; width=&quot;184&quot; height=&quot;327&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;费这么半天劲，才解决一个点啊！我不服！别急，接下来还有好戏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但其实这个思路还是挺重要的，靠这一点“死皮赖脸”拉关系的劲头，这个法子以后还倒是可以有很多用武之地。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好戏在下一个属性，没错就是ref，这也是我步入万丈深渊一去不复返的梯子啊！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/api/?#ref&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;ref&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;要知道人家可是vue里边的特殊特性，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要知道人家可是很有能力的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要知道我老是连着打不出妖之道这三个字！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了不皮了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官网记载：ref这个特殊特性，被用来给元素或子组件注册引用信息。&lt;/span&gt;&lt;span&gt;引用信息将会注册在父组件的 $refs 对象上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；&lt;/span&gt;&lt;span&gt;如果用在子组件上，引用就指向组件实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的理解大白话来说，他就是给dom元素或者组件实例一个身份证号，身份证号有的特性他也就有，那就是唯一不重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果配合上v-for，就能获取这一批带有ref特性所组成的数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过数组下标索引出来的个体，也就是对应的dom元素本身或者组件实例本人无疑了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就好像拿着身份证号去公安局查人一样，快速不说，还很高效有没有，一查一个准！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但需要说明的是，在created钩子中，这个特性拿不到东西，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生命周期钩子里只有在mounted里可以用（可能还有后边的钩子里也可以使用，我没用过不准确），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;毕竟你想啊，身份证号虽说一出生就有了，但是只有挂载到网上你才能查得到的嘛！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我究竟用它做了什么呢?那就是多选功能啊！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;还是先回到上边说的，绑定了一个事件，并且会传递一个当前点击li的索引号，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并且前边也提到过，ref返回的是数组，有数组有索引号，简直是万事俱备啊。于是乎让我们来呼唤东风（东风别看了，就是说你呢）！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在choose点击函数中就有了这么一段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
if(this.$refs.liId[index].className.length &amp;lt;= 0){
    //首先先判断当前li有没有被选中，因为我这里li除了选中状态的有类名，其他没有类名，所以我就这么判断了。
    //这么看有时候舍弃一小丢丢规范的东西反而省力。

    this.$refs.liId[index].className = 'li-focus';// 添加类

}else{
    //当前li已经被选中，那么在多选的逻辑里，是允许人们选中后再取消选中的，所以前端展示层面上把样式去掉。

    this.$refs.liId[index].className = '';// 选中再取消的情况

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好了，第二个&lt;span&gt;&lt;strong&gt;多选样式&lt;/strong&gt;&lt;/span&gt;搞定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704225051642-1294346763.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;347&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704225055692-1402830463.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704225059152-231211199.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么接下来，选择的结果呢，能不能来一次“趁火打劫”，趁点击的时候偷偷记录下用户的选择？答案当然是可以的啦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先说多选功能的趁火打劫吧，就着上边增删类名的热乎劲，紧接着在每次点击时我们记录下当前点击的是谁&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
       // 获取选中结果

        for (let i = 0; i &amp;lt; this.$refs.liId.length; i++) {

            if(this.$refs.liId[i].className.length &amp;gt; 0){

                this.chooseNumStr += this.$refs.liId[i].innerText.substring(0,1);

            }

        }    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这一段再次利用了ref的特性，找到当前点击的dom，截取人家选项里的第一个字，那就是ABC or D；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拼接到事先准备好的字符串chooseNumStr中(要发给数据用的)，因为这里和后端提前约定的就是将选择结果以字符串的形式提交。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if判断那里，条件再次利用了li谁有类名就是选了谁的不讲理原则。第三个&lt;strong&gt;&lt;span&gt;多选记录选项功能&lt;/span&gt;&lt;/strong&gt;问题搞定。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第四个问题是，既然多选记录搞定了，那么单选呢，也应该在每次点击的时候搞定他吧？那是自然！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我刚刚突然又想到了一个解决方法，于是这里我将呈现俩个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.那就是我当时脑残的解决方法，不过这种方法唯一的好处可能是，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产品大大过来说，那sei，你把选项中的ABCD去掉吧，不好看，那我就傻逼了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，本来人家设计稿里选项处就没有ABCD，我本着你好我好大家好的原则，说服了他们加上的。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不废话了，我发现我进入中年了，絮絮叨叨总是进不了正题，或许这和我上课爱走神有关吧。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
        //索引0-3对应答案A-B,依次类推

        // 注意，这里看看最多的选项是多少个，进行下配置，当前只是配置到了F

        switch(index){

          case 0: this.chooseNumStr = 'A';

          break;

          case 1: this.chooseNumStr = 'B';

          break;

          case 2: this.chooseNumStr = 'C';

          break;

          case 3: this.chooseNumStr = 'D';

          break;

          case 4: this.chooseNumStr = 'E';

          break;

          case 5: this.chooseNumStr = 'F';

          break;

        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;没错，还是在choose方法中，我判断是单选后，用switch来判断index的值，进而匹配到chooseNumStr的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这种方法很笨拙，而且有超出设置范围的选项的危险，但是，我傻啊！那有什么方法！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当初就是觉得这么干很不妥，可是直到今天我再看自己的代码才想到更好的解决方案的啊！那他是啥啊？！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那就是：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. 就还是强大的ref登场，规则和选择多选一样，只不过不用for循环。你是不是已经想到了啊哈！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对的，每次单选点的是哪个就li，截取当前li内部文本的第一个字符，也就是ABC or D啊&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
this.$refs.liId[i].innerText.substring(0,1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;简直soeasy，soshengshi！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，第四个问题&lt;span&gt;&lt;strong&gt;单选的答案记录&lt;/strong&gt;&lt;/span&gt;问题解决。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后，我们接着趁热打铁&lt;span&gt;（才发现他和趁火打劫好像是兄弟啊！）&lt;/span&gt;,解决下边点击按钮的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;需求是没选是灰色，选择选项后可提交：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是两个按钮的结构，为了避免后期下一题和提交按钮的交班时我还得判断点击事件是他俩按钮谁和谁的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我用了两个按钮，绑了两个事件，把不同功能的事件分开绑定了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
.public-btn(v-if=&quot;!isLast&quot; @click=&quot;nextItem&quot; v-bind:class=&quot;{'public-btn-gray': unclickable}&quot;) 下一题

.public-btn(v-else @click=&quot;submitItem&quot; v-bind:class=&quot;{'public-btn-gray': unclickable}&quot;) 提交
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到，除了事件我还绑定了class，那个public-btn-gray的生存与否取决于unclickable。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;先说没选是灰色的处理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个思路上就是，页面初始化时按钮默认肯定就是灰色的，也就是有着public-btn-gray类名的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有一个用于描述按钮是不可点击状态的变量unclickable，专门管理按钮是否是可点击的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化时是true不可点击的。这样，按钮的gray类名public-btn-gray就加了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑上，点击按钮的时候先判断这个值，如果为true就提示用户要先选择答案：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
if(this.unclickable){

    alert('您还没有选择答案哦！');

}else{// do someting you wanted;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704225230483-931376232.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;然后是&lt;span&gt;&lt;strong&gt;选择选项后可提交&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那这不好说嘛！我只要点击事件一触发，就把可点击状态放开不就好了嘛！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那好，我是用户，我在如图第15题选择a、c解锁提交按钮，然后我再点击a、c抹掉我的记录。。。开不开心我的神操作？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但这时我的提交按钮已打开，我可以在他毫无防备的情况下趁虚而入&lt;span&gt;（中华文化真博大，这是第三个同意义的成语了！哈哈哈）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这当然不可以了，直接点击事件就放开下一题按钮，在单选场景下是通的。但是多选的时候我们还要再防御一层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那就是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
        // 置灰提交按钮与否

        if(this.chooseNumStr.length &amp;gt; 0){
        //多选的时候，因为再次点击会把记录抹除，所以chooseNumStr会是动态改变的，
        //如果一个也没选择，多选也好单选也罢，这个字符串肯定是空的，故而判断长度小于0就不让他提交！

          this.unclickable = false;

        }else{

          // 没有选东西，就置灰按钮

          this.unclickable = true;

        }    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704225249318-322457296.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;耶！第六点&lt;span&gt;&lt;strong&gt;多选功能与下一题&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;按钮高亮可跳转功能&lt;/span&gt;&lt;/strong&gt;的结合也完成啦 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;至此，关于按钮的样式和逻辑就完毕了，每次点击下一题下一题的功能就跑通了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，一直跑到&lt;span&gt;&lt;strong&gt;第十四题点击下一题&lt;/strong&gt;&lt;/span&gt;，15题内按钮文案还是下一题，可是这是最后一题了啊，讲点理吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好，那就讲理点，让他改成提交，这时下一题和提交按钮换岗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;换岗的时机我是在数据响应回来后判断本题目的题号/id，如果是14题，那么下一题就是最后一题，点击下一题就让提交按钮上岗，下一题退休。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说了这么多，说的最多的是点击下一题。所以在下一题按钮绑定的事件中，就有一个角落是来干这个事的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 下一题

if(_this.state.ExamInfo.QuestionID == 14){ 
    //点击下一题，数据响应回来后，新数据替换前，判断如果当前是第14题就改变按钮。

    //判断切换下一题和提交按钮

     _this.isLast = true;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后，提交和下一题俩按钮的样式就靠这个状态值控制，只要在条件成立的时候改变状态值让他俩交岗即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（仔细总结会发现，都是这么一个套路，数据改变某个状态值，状态值绑定在结构上，被改变后影响视图的不同展示）&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;后来，还发现一个隐藏的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击下一题后，因为是单页应用，页面结构和数据都没有刷新，&lt;/span&gt;&lt;span&gt;上一道题用户选择的结果绑在li上边的样式还需要清空，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以每次点击下一题甚至提交后，都需要在重新填新题目数据时，把li的样式选中都清空，也就是把类名都清空。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 样式清空

for (let i = 0; i &amp;lt; _this.$refs.liId.length; i++) {

     _this.$refs.liId[i].className = '';

}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;也需要把上一题的用户的选择数据变量清空，也就是&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
chooseNumStr字符串=’’;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;且如果用户翻到下边，离开第一屏时点击提交选项，此时再替换下一题数据，虽然用户看着像换了页面，但其实还在这一页。为了把假象做的更逼真点，需要页面定位到顶部：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 点击下一题，新页面应该定位到顶头题干位置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
document.body.scrollTop = 0;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;正当我看着这个天衣无缝的假功能玩的开心的时候，测试大大跑过来说:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;~我快速点击多次提交就提交了好多次。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;~exm??!你没事一直点提交干嘛？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;~我是测试 :-)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;~好，大大，你别说了，我这就改嘎。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;~恩，辛苦啦辛苦啦&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;~~~&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第⑧个问题：&lt;span&gt;&lt;strong&gt;多次点击下一题/提交按钮&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好吧，这个问题确实是我没考虑到，以后做这种表单提交的，肯定要防御用户多次点击提交。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了上面几次的经验，我现在很会利用data里某个变量来充当状态记录了！但是这样定义多个应该很不好吧。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个变量isClicked专门用于看管按钮是否被提交过，如果在可点击的状态下点击过，那么抱歉，逻辑中断！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化这个isClicked肯定是没有点击状态，为false，然后在下一题/提交按钮的点击事件中判断：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
if(!this.isClicked){//没点击过

    //该干啥干啥！

}else{

    //该干嘛干嘛去！

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以，到底应该干吗？！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;终于说到最后，我好困，如果不是自娱自乐我可能坐着睁眼就睡着了，不，我已经进入梦乡了......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说到拿响应结果,，这无非就是&lt;span&gt;&lt;strong&gt;根据响应结果弹层&lt;/strong&gt;&lt;/span&gt;而已，我不想说什么了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;睡了。晚安世界~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180704225337637-1564946643.png&quot; alt=&quot;&quot; width=&quot;214&quot; height=&quot;343&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b5b94308-c0e4-4eef-83c3-20a51608c63e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b5b94308-c0e4-4eef-83c3-20a51608c63e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b5b94308-c0e4-4eef-83c3-20a51608c63e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//- 题目表单
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    form.question(v-if=&quot;state.ExamInfo&quot;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;      div
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        h3.qus-title(:data-id=&quot;state.ExamInfo.QuestionID&quot;) {{state.ExamInfo.ExamQuestionNo}}、{{state.ExamInfo.Description}}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        ul.qus-list
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;          li(v-for=&quot;(item,index) in state.ExamInfo.QuestionAnswerCode&quot; @click=&quot;choosed(index)&quot; v-bind:class=&quot;{'li-focus' : chooseNum==index}&quot; ref=&quot;liId&quot;) {{item.Code}}、{{item.Description}}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    .public-btn(v-if=&quot;!isLast&quot; @click=&quot;nextItem&quot; v-bind:class=&quot;{'public-btn-gray': unclickable}&quot;) 下一题
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     .public-btn(v-else @click=&quot;submitItem&quot; v-bind:class=&quot;{'public-btn-gray': unclickable}&quot;) 提交
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;完整html结构&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_b96965a0-0c6b-45b1-8bcf-7b98eb97970b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b96965a0-0c6b-45b1-8bcf-7b98eb97970b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b96965a0-0c6b-45b1-8bcf-7b98eb97970b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;   name: 'question'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;  data () {
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;      state: {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         dataUrl: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.ownSet.dataUrl,
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         progress: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.init.ActiveProgressEnum,
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         ExamInfo: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.init.ExamInfo,
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         PersonID: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.init.PersonID,
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         TeamID: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.init.TeamID,
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;      },
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;       unclickable: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否已选择答案，不选择不能下一题，并置灰按钮&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;       showLayer: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否显示弹层&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;      layerItem: {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         isQuestion: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         isSubmit: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是最后一道题时触发“下一题&quot;按钮，点击了提交&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;         isSuccess: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         isLoading: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;      },
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;       chooseNum: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;       isFocus: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;       isLast: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;       isClicked: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否已经点击下一题，防止二次提交&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;  },
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;  created(){
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击开始答题，新页面应该定位到顶头题干位置&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     document.body.scrollTop = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.state.progress &amp;gt; 100107 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.state.progress !== 100112&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;       alert('您已答题完毕！'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.state.ExamInfo.QuestionID == 15){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;答到14题退出的情况&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断切换下一题和提交按钮&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.isLast = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;  },
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;  methods: {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;    choosed(index){
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.chooseNumStr = '';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 单选or多选&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.ExamInfo.IsMulti){
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多选&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.$refs.liId[index].className.length &amp;lt;= 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加类&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;.$refs.liId[index].className = 'li-focus'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选中再取消&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;.$refs.liId[index].className = ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取选中结果&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.$refs.liId.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.$refs.liId[i].className.length &amp;gt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.chooseNumStr += &lt;span&gt;this&lt;/span&gt;.$refs.liId[i].innerText.substring(0,1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 置灰提交按钮与否&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.chooseNumStr.length &amp;gt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;.unclickable = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有选东西，就置灰按钮&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;.unclickable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，再添加按钮的不可点击状态&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;       }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 单选&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.unclickable = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.chooseNum =&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引0-3对应答案A-B&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，这里看看最多的选项是多少个，进行下配置，当前只是配置到了F&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(index){
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 0: &lt;span&gt;this&lt;/span&gt;.chooseNumStr = 'A'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 1: &lt;span&gt;this&lt;/span&gt;.chooseNumStr = 'B'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 2: &lt;span&gt;this&lt;/span&gt;.chooseNumStr = 'C'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 3: &lt;span&gt;this&lt;/span&gt;.chooseNumStr = 'D'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 4: &lt;span&gt;this&lt;/span&gt;.chooseNumStr = 'E'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 5: &lt;span&gt;this&lt;/span&gt;.chooseNumStr = 'F'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     nextItem(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一题&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.state.progress &amp;gt; 100107 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.state.progress != 100112&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         alert('您已答题完毕！不能重复答题。'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;       }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isClicked){
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按钮可以点击-如果提交过一次，不能二次提交，如果提交失败，可以二次提交&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.unclickable){
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             alert('您还没有选择答案哦！'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;           }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.isClicked = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还没提交过，可以提交&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             let postData = `Type=2&amp;amp;PersonID=${&lt;span&gt;this&lt;/span&gt;.state.PersonID}&amp;amp;QuestionID=${&lt;span&gt;this&lt;/span&gt;.state.ExamInfo.QuestionID}&amp;amp;Result=${&lt;span&gt;this&lt;/span&gt;.chooseNumStr}`;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2为下一题&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.state.TeamID &amp;gt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;               postData+= `&amp;amp;TeamID=${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.TeamID}`;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.ajaxFun(postData,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             .then((response)=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(this.state.ExamInfo.ExamQuestionNo)&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             .&lt;span&gt;catch&lt;/span&gt;((err)=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;               &lt;span&gt;this&lt;/span&gt;.isClicked = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;              console.log(err);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     submitItem(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交按钮&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isClicked){
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.unclickable){
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;           alert('您还没有选择答案哦！'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.state.progress &amp;gt; 100107&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;           alert('您已答题完毕！不能重复答题。'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;.showLayer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;.layerItem.isSubmit = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     confirmSubmit(data){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交弹层 之 确定&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isClicked){
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.isClicked = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送ajax&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;         let postData = `Type=3&amp;amp;PersonID=${&lt;span&gt;this&lt;/span&gt;.state.PersonID}&amp;amp;QuestionID=${&lt;span&gt;this&lt;/span&gt;.state.ExamInfo.QuestionID}&amp;amp;Result=${&lt;span&gt;this&lt;/span&gt;.chooseNumStr}`;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3为提交&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.state.TeamID &amp;gt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;           postData+= `&amp;amp;TeamID=${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.TeamID}`;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.ajaxFun(postData,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         .then((response)=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭提交弹层&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;         .&lt;span&gt;catch&lt;/span&gt;((err)=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;.isClicked = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;          console.log(err);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;     changeLayerShow(data){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交弹层 之 取消 + 状态重置&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.showLayer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.layerItem.isSubmit = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;    hideLayer(data){
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.showLayer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    ajaxFun(postData,submitFun){
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;       let _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;        console.log(postData)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(submitFun){
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭提交弹层&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;           _this.layerItem.isSubmit = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         _this.layerItem.isQuestion = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         _this.showLayer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;         _this.layerItem.isLoading = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         $axios.get(_this.state.dataUrl+'ExamAnswer?'+&lt;span&gt;postData)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         .then((response)=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;          console.log(response);
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(response &amp;amp;&amp;amp; response.data &amp;amp;&amp;amp; response.data.result === 1&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             _this.layerItem.isLoading = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;             _this.layerItem.isQuestion = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断返回结果&lt;/span&gt;
&lt;span&gt;167&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(response.data.RetValue.proResult){
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;               _this.layerItem.isSuccess = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;               _this.layerItem.isSuccess = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;            resolve(response);
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;             setTimeout(()=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(submitFun){
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; resolve(response);&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;                 _this.$store.dispatch('setUser'&lt;span&gt;,response.data.RetValue);
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;                 _this.$router.replace('redpacket'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;               }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一题&lt;/span&gt;
&lt;span&gt;181&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(_this.state.ExamInfo.QuestionID == 14){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ExamQuestionNo&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断切换下一题和提交按钮&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;                   _this.isLast = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一题重新赋值&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;                 _this.state.ExamInfo =&lt;span&gt; response.data.RetValue;
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击下一题，新页面应该定位到顶头题干位置&lt;/span&gt;
&lt;span&gt;188&lt;/span&gt;                 document.body.scrollTop = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 样式清空&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; _this.$refs.liId.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;                   _this.$refs.liId[i].className = ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;              } 
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;               _this.showLayer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;               _this.layerItem.isQuestion = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;               _this.chooseNumStr = ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;               _this.chooseNum = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;               _this.unclickable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;               _this.isClicked = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;             }, 2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;           }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;             _this.showLayer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             _this.layerItem.isQuestion = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;             _this.isClicked = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;             reject('数据提交失败，请刷新重试！'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;         .&lt;span&gt;catch&lt;/span&gt;((err)=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;           _this.showLayer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;           _this.layerItem.isQuestion = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;           _this.isClicked = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;          reject(err)
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;      });
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;完整js代码&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;写完这个发现，我好像总是喜欢绕着弯的踩坑。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;虽然问题最终都解决了，但是很能说明其实我基础还是薄弱的，不会很好利用每一个代码的特性，简而言之就是不高级！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2018-07-04  23:18:23 - 2018-07-05  00:00:44好累~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人学习理解和总结，很多不足还请指正~&lt;/span&gt;&lt;/p&gt;








&lt;p&gt;&lt;span&gt;声明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请尊重博客园原创精神，转载或使用图片请注明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　博主：xing.org1^&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出处：http://www.cnblogs.com/padding1015/&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 04 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>xing.org1^</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/padding1015/p/9265985.html</dc:identifier>
</item>
<item>
<title>Nodejs实现爬虫抓取数据 - 狗尾草的博客</title>
<link>http://www.cnblogs.com/bgwhite/p/9265959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bgwhite/p/9265959.html</guid>
<description>&lt;h4&gt;开始之前请先确保自己安装了Node.js环境，还没有安装的的童鞋请自行百度安装教程......&lt;/h4&gt;
&lt;h4&gt;1.在项目文件夹安装两个必须的依赖包&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
npm install superagent --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;superagent 是一个轻量的,渐进式的ajax api,可读性好,学习曲线低,内部依赖nodejs原生的请求api,适用于nodejs环境下&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
npm install cheerio --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;em&gt;cheerio是nodejs的抓取页面模块，为服务器特别定制的，快速、灵活、实施的jQuery核心实现。适合各种Web爬虫程序。相当于node.js中的jQuery&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;2.新建  crawler.js  文件&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
//导入依赖包
const http       = require(&quot;http&quot;);
const path       = require(&quot;path&quot;);
const url        = require(&quot;url&quot;);
const fs         = require(&quot;fs&quot;);
 
const superagent = require(&quot;superagent&quot;);
const cheerio    = require(&quot;cheerio&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.获取 Boos直聘数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
superagent
    .get(&quot;https://www.zhipin.com/job_detail/?city=100010000&amp;amp;source=10&amp;amp;query=%E5%89%8D%E7%AB%AF&quot;)
    .end((error,response)=&amp;gt;{
        //获取页面文档数据
        var content = response.text;
        //cheerio也就是nodejs下的jQuery  将整个文档包装成一个集合，定义一个变量$接收
        var $ = cheerio.load(content);
        //定义一个空数组，用来接收数据
        var result=[];
        //分析文档结构  先获取每个li 再遍历里面的内容(此时每个li里面就存放着我们想要获取的数据)
        $(&quot;.job-list li .job-primary&quot;).each((index,value)=&amp;gt;{
            //地址和类型为一行显示，需要用到字符串截取
            //地址
            let address=$(value).find(&quot;.info-primary&quot;).children().eq(1).html();
            //类型
            let type=$(value).find(&quot;.info-company p&quot;).html();
            //解码
            address=unescape(address.replace(/&amp;amp;#x/g,'%u').replace(/;/g,''));
            type=unescape(type.replace(/&amp;amp;#x/g,'%u').replace(/;/g,''))
            //字符串截取
            let addressArr=address.split('&amp;lt;em class=&quot;vline&quot;&amp;gt;&amp;lt;/em&amp;gt;');
            let typeArr=type.split('&amp;lt;em class=&quot;vline&quot;&amp;gt;&amp;lt;/em&amp;gt;');
            //将获取的数据以对象的形式添加到数组中
            result.push({
                title:$(value).find(&quot;.name .job-title&quot;).text(),
                money:$(value).find(&quot;.name .red&quot;).text(),
                address:addressArr,
                company:$(value).find(&quot;.info-company a&quot;).text(),
                type:typeArr,
                position:$(value).find(&quot;.info-publis .name&quot;).text(),
                txImg:$(value).find(&quot;.info-publis img&quot;).attr(&quot;src&quot;),
                time:$(value).find(&quot;.info-publis p&quot;).text()
            });
            // console.log(typeof $(value).find(&quot;.info-primary&quot;).children().eq(1).html());
        });
        //将数组转换成字符串
        result=JSON.stringify(result);
        //将数组输出到json文件里  刷新目录 即可看到当前文件夹多出一个boss.json文件(打开boss.json文件，ctrl+A全选之后 ctrl+K，再Ctrl+F即可将json文件自动排版)
        fs.writeFile(&quot;boss.json&quot;,result,&quot;utf-8&quot;,(error)=&amp;gt;{
            //监听错误，如正常输出，则打印null
            if(error==null){
                console.log(&quot;恭喜您，数据爬取成功!请打开json文件，先Ctrl+A，再Ctrl+K,最后Ctrl+F格式化后查看json文件(仅限Visual Studio Code编辑器)&quot;);
            }
        });
    });　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;跟着狗尾草走完这篇nodejs爬虫相信大家又get了 一个新技能，狗尾草和大家一起加油，一起努力!&lt;/p&gt;
&lt;p&gt;鸣谢：Mrs.Zhang&lt;/p&gt;
&lt;p&gt;转载至：https://blog.csdn.net/twodogya/article/details/80204322&lt;/p&gt;
</description>
<pubDate>Wed, 04 Jul 2018 15:17:00 +0000</pubDate>
<dc:creator>狗尾草的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bgwhite/p/9265959.html</dc:identifier>
</item>
<item>
<title>.Net Core开发日志——Global Tools - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9265687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9265687.html</guid>
<description>&lt;p&gt;.Net Core 2.1引入了一个新的功能，Global Tools，其本质是包含控制台应用程序的nuget包，目前而言，还没有特别有用的工具，不过相信随着时间的推移，各种有创意或者实用性强的Global Tools会出现在大家的视野里。&lt;/p&gt;
&lt;p&gt;安装一个Global Tools很简单，输入一条命令&lt;code&gt;dotnet tool install -g dotnetsay&lt;/code&gt;，名为dotnetsay的工具便已经安装在特定目录下。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Linux/macOS&lt;/td&gt;
&lt;td&gt;$HOME/.dotnet/tools&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;%USERPROFILE%.dotnet\tools&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201807/991496-20180704222610618-1945160797.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要使用工具的话则需要输入该工具对应的命令，比如&lt;code&gt;dotnetsay&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201807/991496-20180704222905762-2051500831.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然Global Tools属于nuget包的一类，但由于nuget官网上并没有将其特别分类，所以不知道其名字的话，很难从众多nuget包中搜寻出来。较好的方法是在Github的&lt;a href=&quot;https://github.com/natemcmaster/dotnet-tools&quot;&gt;natemcmaster/dotnet-tools&lt;/a&gt;库中找到所需的工具。&lt;/p&gt;
&lt;p&gt;粗粗过了一遍，例如&lt;a href=&quot;https://github.com/natemcmaster/dotnet-serve/tree/master/src/dotnet-serve&quot;&gt;dotnet-serve&lt;/a&gt;，&lt;a href=&quot;https://github.com/billpratt/dotnet-search&quot;&gt;dotnet-search&lt;/a&gt;，&lt;a href=&quot;https://github.com/Rwing/Dotnet.Tool.MD5&quot;&gt;dotnet-md5&lt;/a&gt;等个人觉得还是挺有用的。&lt;/p&gt;
&lt;p&gt;但有些工具在安装完后，会显示指定版本的framework没有被找到的错误。在兼容性方面Global Tools还有待改善。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201807/991496-20180704224255833-1906820127.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要自己创建一个Global Tools也不是件困难的事情。&lt;/p&gt;
&lt;p&gt;因为Global Tools其实就是个控制台应用程序，那么首先即是new一个这样的程序。&lt;code&gt;dotnet new consoel -o helloGlobalTools&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;代码内容很简单，显示包含当前时间的一串字符：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;

namespace helloGlobalTools
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine($&quot;Hello {DateTime.Now}&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在csproj文件中的PropertyGroup节点内需要加入&lt;code&gt;&amp;lt;PackAsTool&amp;gt;true&amp;lt;/PackAsTool&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201807/991496-20180704231125866-1373543931.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;dotnet pack&lt;/code&gt;命令可以在bin\Debug目录下生成helloGlobalTools.1.0.0.nupkg安装包文件。&lt;/p&gt;
&lt;p&gt;将当前目录切换成该文件的路径，然后执行Global Tools安装命令&lt;code&gt;dotnet tool install -g helloGlobalTools --add-source ./&lt;/code&gt;。完成安装后还可以通过&lt;code&gt;dotnet tool list -g&lt;/code&gt;进一步确认是否已成功安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201807/991496-20180704230317034-870569305.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后便是输入你的工具命令名，得到所期望的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201807/991496-20180704231151171-1153820370.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果你对自己的作品有信心，同时又想分享给其他人的话，还可以将nuget包上传至&lt;a href=&quot;https://www.nuget.org/&quot;&gt;nuget.org&lt;/a&gt;的官方网站。这样你的劳动成果便可以最大化的发挥价值了。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools&quot;&gt;global-tools&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Jul 2018 15:17:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9265687.html</dc:identifier>
</item>
<item>
<title>小程序左右联动实现记录 - halolzh</title>
<link>http://www.cnblogs.com/lzh821/p/9265813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzh821/p/9265813.html</guid>
<description>&lt;p&gt;  最近在学习小程序，实现了左右联动的功能，记录一下思绪，方便以后参考。&lt;/p&gt;
&lt;p&gt;  最终的界面如下, 点击左边任意一个项目，右边会跳到相应项目的起始位置，右边滑动，左则会跳到相应的位置。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/384338/201807/384338-20180704222150785-274679614.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/384338/201807/384338-20180704222318795-1816569971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  在这里，右则每一项的高度都是固定的，方便定位当前滑动距离在哪一个大项（左则）里。右则的 scroll-view 使用了一项关键的属性：scroll-into-view，这个属性用来确定 scrollTop 的值的，当 scroll-into-view 的值和 scroll-view 里面的元素的id的值相等时，scroll-view 会定位到该元素，scrollTop 的值就是滑动到该元素的值。&lt;/p&gt;
&lt;p&gt;  做这个功能的时候，遇到一个问题，就是右则的小项种类不多的时候，例如某个类目只有1~2个，那么点击左则的大项的时候，会出现点击不到的现象。这里可以用点小技巧来解决：&lt;/p&gt;
&lt;p&gt;点击左则大项的时候，设置当前点击标记为true，设置 classifySeleted 为当前点击的项目。 然后在滑动触发函数（onGoodsScroll）里面，判断当前触发滑动是否点击产生的，如果是，则不设置 classifySeleted  的值，否则就计算 classifySeleted 的值并设置。&lt;/p&gt;
&lt;p&gt;wxml代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;content-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scroll-view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;classify-container&quot;&lt;/span&gt;&lt;span&gt; scroll-y&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;classify {{classifySeleted==classify.typeId?'active':''}}&quot;&lt;/span&gt;&lt;span&gt; wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{cakeTypes}}&quot;&lt;/span&gt;&lt;span&gt; wx:for-item&lt;/span&gt;&lt;span&gt;=&quot;classify&quot;&lt;/span&gt;&lt;span&gt; wx:key&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; data-id&lt;/span&gt;&lt;span&gt;=&quot;{{classify.typeId}}&quot;&lt;/span&gt;&lt;span&gt; bindtap&lt;/span&gt;&lt;span&gt;=&quot;tapClassify&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{classify.typeName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scroll-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scroll-view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;goods-container&quot;&lt;/span&gt;&lt;span&gt; scroll-y&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; scroll-into-view&lt;/span&gt;&lt;span&gt;=&quot;{{'inToView' + typeIndex}}&quot;&lt;/span&gt;&lt;span&gt; bindscroll&lt;/span&gt;&lt;span&gt;=&quot;onGoodsScroll&quot;&lt;/span&gt;&lt;span&gt; scroll-top&lt;/span&gt;&lt;span&gt;=&quot;{{scrollTop}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{cakeTypes}}&quot;&lt;/span&gt;&lt;span&gt; wx:for-item&lt;/span&gt;&lt;span&gt;=&quot;classify&quot;&lt;/span&gt;&lt;span&gt; wx:key&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;{{'inToView'+classify.typeId}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{classify.typeName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;goods&quot;&lt;/span&gt;&lt;span&gt; wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{classify.productIds}}&quot;&lt;/span&gt;&lt;span&gt; wx:for-item&lt;/span&gt;&lt;span&gt;=&quot;cake&quot;&lt;/span&gt;&lt;span&gt; wx:key&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;{{cake.imgSrc}}&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;{{cake.imgSrc}}&quot;&lt;/span&gt;&lt;span&gt; data-list&lt;/span&gt;&lt;span&gt;=&quot;{{cake.imgSrc}}&quot;&lt;/span&gt;&lt;span&gt; bindtap&lt;/span&gt;&lt;span&gt;=&quot;tapImg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;name ellipsis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{cake.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;sold&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{cake.introduce}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;price&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;￥{{cake.price}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scroll-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   onGoodsScroll: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; scrollTop =&lt;span&gt; e.detail.scrollTop;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; h = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; classifySeleted = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.classifySeleted;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; titleHeight = Math.ceil(70 * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.percent);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; itemHeight = Math.ceil(180 * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.percent);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.data.cakeTypes.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (classify, i) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       console.log(&quot;h:&quot; + h + &quot; scrollTop:&quot; +&lt;span&gt; scrollTop);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; _h = titleHeight + classify.productIds.length *&lt;span&gt; itemHeight;  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (scrollTop &amp;gt;= h - 10&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         classifySeleted =&lt;span&gt; classify.typeId;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       h +=&lt;span&gt; _h;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.isTap)  {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData ({
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         isTap: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      })
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;          classifySeleted: classifySeleted
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        });  
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;  },
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;   tapClassify: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; id =&lt;span&gt; e.target.dataset.id;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;       isTap: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;      classifySeleted: id,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;      typeIndex: id
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;   },
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 04 Jul 2018 14:44:00 +0000</pubDate>
<dc:creator>halolzh</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzh821/p/9265813.html</dc:identifier>
</item>
<item>
<title>《前端之路》之二：数据类型转换 &amp;&amp; 隐式转换 || 显式转换 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/9265806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/9265806.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;数据类型转换-隐式转换-显式转换&quot;&gt;02：数据类型转换 &amp;amp;&amp;amp; 隐式转换 || 显式转换&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;在上一个章节中，我们介绍了 JavaScript 的基本的数据类型，由于是弱类型语言，所以不需要 在很多时候去定义这个数据的类型，而且也不能够在定义了这个数据类型之后再去改变这个数据类型。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;当遇到一个需要对数据类型进行改变的场景的时候，JS 就显示出来它的优势了，可以对数据类型进行轻松的转换，那么下面 我们就开始介绍 如何轻松的对数据类型进行转换，以及在转换的过程中，我们需要非常注意点问题。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;一从-数字类型-转换成-字符串类型&quot;&gt;一、从 数字类型 转换成 字符串类型&lt;/h4&gt;
&lt;h5 id=&quot;a-显式转换&quot;&gt;A、 显式转换&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
const numberA = 123
console.log(typeof numberA)     // number

String(numberA)                 // &quot;123&quot;
numberA.toString()              // &quot;123&quot; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;b-隐式转换&quot;&gt;B、 隐式转换&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const numberB = 456
console.log(typeof numberA)     // number

const stringB = numberB + ''    // &quot;456&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TIPS:&lt;/code&gt; 特殊数值的隐士转换&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
const aNumber = NaN
const bNumber = Infinity
const cNumber = -Infinity
console.log(typeof aNumber)     // number
console.log(typeof bNumber)     // number
console.log(typeof cNumber)     // number

const aString = aNumber + ''    // &quot;NaN&quot;
const bString = bNumber + ''    // &quot;Infinity&quot;
const cString = cNumber + ''    // &quot;-Infinity&quot;

console.log(typeof aString)     // string
console.log(typeof bString)     // string
console.log(typeof aString)     // string&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二从-字符串类型-转换成-数字类型&quot;&gt;二、从 字符串类型 转换成 数字类型&lt;/h4&gt;
&lt;h5 id=&quot;a-显式转换-1&quot;&gt;A、 显式转换&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
const aString = &quot;789&quot;
const bString = &quot;789xxx&quot;
const cString = &quot;xxx789&quot;

// Number()
let aNumber1 = Number(aString)  // 789
let aNumber2 = Number(bString)  // NaN
let aNumber3 = Number(cString)  // NaN

// parseInt()
let bNumber1 = parseInt(aString)    // 789
let bNumber2 = parseInt(bString)    // 789
let bNumber3 = parseInt(cString)    // NaN

/*  是不是很困惑，为什么 bNumber2 和 bNumber3 的返回值是不一样的？*/
/*  那么我们顺手查了一下 手册 parseInt() 方法                */

/*  tips： 如果传入的 string 开头为 1～9 的数字 或者 '0x'、('0X') */ 
/*  那么 parseInt 会返回对应的 整数部分的 数值，从而忽略掉数值后面跟随的 字符串 */
/*  至于 '0x' 则是因为 16 进制的原因。 同理 10进制 */


// parseFloat()
let cNumber1 = parseFloat(aString)  // 789
let cNumber2 = parseFloat(bString)  // 789
let cNumber3 = parseFloat(cString)  // NaN

// 看来 parseFloat 和  parseInt 情况是一样的。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;b-隐式转换-1&quot;&gt;B、 隐式转换&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
const aString = &quot;789&quot;
const bString = &quot;789xxx&quot;
const cString = &quot;xxx789&quot;

let dNumber1 = + aString    // 789
let dNumber2 = + bString    // NaN
let dNumber3 = + cString    // NaN


// tips: 慎用 '789' + 0   || 0 + '789'

let x = '789' + 0   // '7890'
let y = '789' - 0   // 789

// 不要问为什么～ 就是这么 6&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;隐式转换-中-不常见类型的转换结果&quot;&gt;隐式转换 中 不常见类型的转换结果&lt;/h6&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
let aBool = + false         // 0
let bBool = + true          // 1

let aNaN = + NaN            // NaN 
let aNull = + null          // 0
let aUndefind = + undefined     // NaN

let obj = {}

let aObj = + {}             // NaN

// 引用对象类型在被 隐式转换 过后往往都是 NaN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上则为 这个章节的内容， 欢迎 star， 地址 &amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%08%E4%B9%8B%E8%B7%AF/02%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%20%26%26%20%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%20%7C%7C%20%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2.md&quot;&gt;《前端之路》之二：数据类型转换 &amp;amp;&amp;amp; 隐式转换 || 显式转换&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Jul 2018 14:43:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/9265806.html</dc:identifier>
</item>
<item>
<title>单链表-头条面试 - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/9264609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/9264609.html</guid>
<description>&lt;p&gt;大家好，本篇博客将讲述单链表的逆序，希望大家在看这篇博客的时候，手里拿张纸，手写一下过程！！！&lt;/p&gt;

&lt;p&gt;出现情况：第一轮基础笔试或者是技术一面&lt;/p&gt;
&lt;p&gt;难度系数：中&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面试题目&lt;/span&gt;：实现一个单链表的反转。例如：10  9   8   7   6   5   4   3   2   1&lt;/p&gt;
&lt;p&gt;反转之后应为：1   2   3   4    5   6   7   8   9   10&lt;/p&gt;
&lt;p&gt;要求10分钟之内写出代码，&lt;span&gt;注意代码风格以及时间复杂度&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考点分析&lt;/p&gt;
&lt;p&gt;（1）基本概念：链表基础，代码规范问题，代码健壮性问题&lt;/p&gt;
&lt;p&gt;（2）对时间复杂度敏感&lt;/p&gt;

&lt;p&gt;解题思路：“一问，二画，三答”&lt;/p&gt;

&lt;p&gt;其实对于这个问题，我们下面先给出解题思路的几种方式，来解释为什么要先问清楚（首先要问清楚面试官侧重的是什么）！！！&lt;/p&gt;
&lt;p&gt;下面以角色的身份来阐述本问题的思路&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.小张&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“我学过链表的基本操作，我可以重新申请一个链表，&lt;span&gt;利用链表的前插法（头插法），这样就可以实现了链表的反转，我的思路是这样的。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我重新从创建空表开始，一个一个将链表的结点插入到新开辟的链表的表头，也就是头结点之后&lt;/span&gt;，如下图看我的思路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1305302/201807/1305302-20180704153733202-1490939078.jpg&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我还写好了算法了呢，看下面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
LinkList  ReverseList(LinkList &amp;amp;&lt;span&gt;L){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从表尾到表头逆向建立单链表L，每次均在头结点之后插入元素&lt;/span&gt;
    LNode *s;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
    L&lt;/span&gt;=(LinkList)malloc(&lt;span&gt;sizeof&lt;/span&gt;(LNode));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建头结点&lt;/span&gt;
    L-&amp;gt;next=NULL;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始为空链表&lt;/span&gt;
    scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;x);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入结点的值&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(x!=&lt;span&gt;9999&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入 9999 表示结束&lt;/span&gt;
        s=(LNode*)malloc(&lt;span&gt;sizeof&lt;/span&gt;(LNode) );  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建新结点&lt;/span&gt;
        s-&amp;gt;data-&lt;span&gt;x;
        s&lt;/span&gt;-&amp;gt;next=L-&amp;gt;&lt;span&gt;next;
        L&lt;/span&gt;-&amp;gt;next=s;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新结点插入表中，L为头指针&lt;/span&gt;
        scanf (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;x);
    }  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while 结束&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; L;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.小杨&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“是的，你上面的代码可以实现要求，不过，我觉得空间复杂度为比较大，我有一个方法，&lt;span&gt;借助三个指针来实现&lt;/span&gt;，下面是我的思路”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1305302/201807/1305302-20180704163820988-1661650813.jpg&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;563&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是我的思路，下面是我的核心代码，代码和上面思路完全一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;LinkList reverse_link(LinkList list){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL == list || NULL == list-&amp;gt;&lt;span&gt;next)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    LinkList temp ,preV,next;
    preV &lt;/span&gt;=&lt;span&gt; list;
    temp &lt;/span&gt;= list-&amp;gt;&lt;span&gt;next;
    preV&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
    
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (temp !=&lt;span&gt; NULL) {
        next &lt;/span&gt;= temp-&amp;gt;&lt;span&gt;next;
        temp&lt;/span&gt;-&amp;gt;next =&lt;span&gt; preV;
        preV &lt;/span&gt;=&lt;span&gt; temp;
        temp &lt;/span&gt;=&lt;span&gt; next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prev;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个代码的时间复杂度为O(n),另外仅仅申请了两个变量来存储额外信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.小糊涂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“我和你们的思路都不一样，你看看所有的都是后移后移，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们把当前的结点逆序，我们先可以这样，把它的后继结点都逆序了，然后再把逆序好的尾结点的next指针再指向当前结点就好了&lt;/span&gt;吗”&lt;/p&gt;
&lt;p&gt;这样就需要比较少的代码啦，在这个里面要注意一点递归出口，在这里我是把链表为空或者链表只有一个结点当作递归的出口，下面是我的代码，代码比较简洁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
list *reverse(list *p, list *&amp;amp;&lt;span&gt;head)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(p == NULL || p-&amp;gt;next ==&lt;span&gt; NULL)
    {
        head &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        list &lt;/span&gt;*temp = reverse(p-&amp;gt;&lt;span&gt;next, head);
        temp&lt;/span&gt;-&amp;gt;next =&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.小孙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面利用递归操作（也是栈的应用），实际上可以很好的解决问题，我的思路也是利用栈操作，&lt;span&gt;使用栈的先进后出特性，完成对链表的逆序输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面是我的代码，思路大家看代码就会清楚&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逆向输出&lt;/span&gt;
stack&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; reOutput(LinkNode *&lt;span&gt;linkNode) {
LinkNode &lt;/span&gt;*&lt;span&gt;head;
stack&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; s;
head &lt;/span&gt;=&lt;span&gt; linkNode;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (head !=&lt;span&gt; NULL) {
s.push(head&lt;/span&gt;-&amp;gt;&lt;span&gt;value);
head &lt;/span&gt;= head-&amp;gt;&lt;span&gt;next;
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
}

stack&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; s;
s &lt;/span&gt;=&lt;span&gt; reOutput(linkNode);
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;s.empty()) {
cout &lt;/span&gt;&amp;lt;&amp;lt; s.top() &amp;lt;&amp;lt;&lt;span&gt; endl;
s.pop();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面先压栈，然后再出栈，自定义栈的大小，可以很好的解决问题，据听说，这是很多大公司采取的方案！！！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.老师发言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当大家碰到这个题目的时候，首先要问明白这个出题人的思想，问清楚是否对链表做出限制&lt;/p&gt;
&lt;p&gt;（1）如果说不能更改链表的结构，显然第二种方法就不行了，如果对链表的结构没有什么要求，这个方法还是很好的，毕竟时间复杂度为O(n),空间复杂度为常数S(1)&lt;/p&gt;
&lt;p&gt;（2）如果数据比较繁多，虽然递归操作代码量比较少，但是可能会导致栈溢出（而且问题也比较难排查出），所以递归有这个风险，如果能克服这个风险，递归也是个不错的选择。&lt;/p&gt;
&lt;p&gt;（3）假如有100w条数据，可能会导致栈溢出，我们可以利用栈操作，因为栈的特性是先进后出，所以就可以很好的解决了这个倒序问题，而且我们自定义栈，栈溢出，也被考虑到了。&lt;/p&gt;
&lt;p&gt;（4）至于头插法，如果时间复杂度和空间复杂度不要求，应该是个比较容易理解的过程。&lt;/p&gt;
&lt;p&gt;所以各有千秋，大家主要是了解思想，代码很好写。&lt;/p&gt;

</description>
<pubDate>Wed, 04 Jul 2018 14:18:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guohai-stronger/p/9264609.html</dc:identifier>
</item>
<item>
<title>设计模式(六)_观察者模式 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9265650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9265650.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;继续学习设计模式,这个月准备再学习几个重要的设计模式。废话不多说，观察者模式，走起！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;观察者模式定义了对象之间的一对多依赖，这样一来。当一个对象改变状态时，它的所有的依赖着都会收到通知并自动更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;观察者模式属于行为型模式。行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;举例说明&quot;&gt;举例说明&lt;/h4&gt;
&lt;p&gt;比如，我们以订阅报纸为例，当你订阅了一份报纸，每天都会有一份最新的报纸送到你的手上。有多少人订阅报纸，报社就会发多少份报纸，这就是典型的订阅-发布模式，报社和订阅报纸的客户就是一对多的依赖关系。&lt;/p&gt;
&lt;p&gt;根据这个例子，简单画下UML类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/20180704215103.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体代码&lt;/p&gt;
&lt;p&gt;观察者（客户）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Customer {

    public abstract void update();
}

public class CustomerA implements Customer {
    @Override
    public void update() {
        System.out.println(&quot;我是客户A.我收到报纸了&quot;);
    }
}

public class CustomerB implements Customer {
    @Override
    public void update() {
        System.out.println(&quot;我是客户B,我收到报纸了&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;被观察者（报社）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NewsOffice {

    private List&amp;lt;Customer&amp;gt; customers = new ArrayList&amp;lt;&amp;gt;();

    public void addCustomer(Customer customer){
        this.customers.add(customer);
    }

    //报纸来了
    public void newspaperCome(){
        this.notifyAllObservers();
    }

    public void notifyAllObservers(){
        for (Customer customer: customers) {
            customer.update();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NewsOffice office = new NewsOffice();

Customer customerA = new CustomerA();
Customer customerB = new CustomerB();

//客户A订阅报纸
office.addCustomer(customerA);
// 客户B订阅报纸
office.addCustomer(customerB);

office.notifyAllObservers();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是客户A.我收到报纸了
我是客户B,我收到报纸了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察者模式，最重要的一点，就是要搞清楚谁是观察者，谁是被观察者。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;收通知的就是观察者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;客户是订阅报纸，收报纸的人（收通知） 。所以客户就是观察者，那么报社就是被观察者&lt;/p&gt;
&lt;h4 id=&quot;java中提供的观察者模式&quot;&gt;Java中提供的观察者模式&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;java 已经为我们提供观察者模式 所需要的类：Observer类 和 Subject 类，只不过在 Java 中 Subject 不叫 Subject，而叫 Observable。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看Observable类的结构&lt;/p&gt;
&lt;p&gt;我使用idea，直接ctrl+N 输入Observable，打开Observable类，然后输入alt+7 .就显示类的结构了&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/20180704220222.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察源码和我们自己写的代码有什么区别？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保存观察者列表不是用的List&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private Vector&amp;lt;Observer&amp;gt; obs;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通知观察者 用了synchronized关键字&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public void notifyObservers(Object arg) {
        /*
         * a temporary array buffer, used as a snapshot of the state of
         * current Observers.
         */
        Object[] arrLocal;

        synchronized (this) {
            /* We don't want the Observer doing callbacks into
             * arbitrary code while holding its own Monitor.
             * The code where we extract each Observable from
             * the Vector and store the state of the Observer
             * needs synchronization, but notifying observers
             * does not (should not).  The worst result of any
             * potential race-condition here is that:
             * 1) a newly-added Observer will miss a
             *   notification in progress
             * 2) a recently unregistered Observer will be
             *   wrongly notified when it doesn't care
             */
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }
        for (int i = arrLocal.length-1; i&amp;gt;=0; i--)
            ((Observer)arrLocal[i]).update(this, arg);
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们利用java提供的这2个类实现刚刚的情景&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NewsOffice2 extends Observable {

    /**
     * 模拟报纸来了
     */
    public void newspaperCome(){
        this.setChanged();
        this.notifyObservers();
    }
}

public class CustomerC implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;我是客户c 我收到报纸了&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        NewsOffice2 office2 = new NewsOffice2();

        CustomerC customerC = new CustomerC();

        office2.addObserver(customerC);

        office2.newspaperCome();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是客户c 我收到报纸了&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;优缺点&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;观察者和被观察者之间抽象耦合，自有一套触发机制，被观察者无需知道通知的对象是谁，只要是符合观察者接口的就可以&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;观察者只知道被观察发生变化，而无法知道如何变化的&lt;/li&gt;
&lt;li&gt;如果存在多个观察者，一个个通知，比较耗时。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 04 Jul 2018 14:15:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9265650.html</dc:identifier>
</item>
<item>
<title>Linux基础命令总结 - hbsygfz</title>
<link>http://www.cnblogs.com/hbsygfz/p/9265481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hbsygfz/p/9265481.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;数据挖掘工程师并不是一直都在图形化界面中工作，并且随着大数据开源技术的发展，会有更多的任务需要在命令行环境下完成，比如在hadoop环境下进行数据文件的导入导出，在ubuntu环境下进行python库的安装与配置，因此就需要掌握一些基本的、常用的Linux命令。本文针对这一话题进行了总结梳理。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录操作&quot;&gt;1.目录操作&lt;/h2&gt;
&lt;h3 id=&quot;绝对路径与相对路径&quot;&gt;（1）绝对路径与相对路径&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;绝对路径&lt;/strong&gt;：路径的写法一定由根目录”/”写起，比如：/usr/local/lib&lt;br/&gt;&lt;strong&gt;相对路径&lt;/strong&gt;：路径的写法不是由根目录”/”写起，比如：local/lib。这时，这个目录相当于是将当前目录作为“根目录”，如果当前目录变化了，那么这个相对路径就要需要修改。&lt;/p&gt;
&lt;h3 id=&quot;打印当前目录pwd&quot;&gt;（2）打印当前目录：pwd&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式: pwd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回当前目录的绝对路径。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213113860-606625502.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;切换目录cd&quot;&gt;（3）切换目录：cd&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： cd 目录名

cd 绝对路径
cd 相对路径
cd .         --切换到当前目录
cd ..        --切换到上一层目录
cd /         --切换到根目录
cd ~         --切换到home目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213126477-329165026.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建目录mkdir&quot;&gt;（4）创建目录：mkdir&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： mkdir 新目录名（既可以是绝对路径，也可以是相对路径）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213135216-1397562995.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-p参数：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p 新目录名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-p的作用是，不使用-p参数时，如果要创建的目录所在的上层目录不存在时，就会报错；而使用了-p参数后，就会直接一次性连上层目录都创建了。如下：创建tmp3中的tmp4，其中tmp3之前是不存在的。未使用-p时，提示了tmp3不存在；使用-p时，不提示错了，tmp3、tmp4都会一次性创建。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213142682-1342084839.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看目录内容ls&quot;&gt;（5）查看目录内容：ls&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： ls &amp;lt;目录&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;直接使用ls命令&lt;/strong&gt;，查看当前目录下的内容。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213149947-57437437.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用ls命令+路径&lt;/strong&gt;，查看指定目录下的内容。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213156085-1272553459.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的颜色，表示的含义不一样：&lt;br/&gt;白色：普通文件&lt;br/&gt;蓝色：目录&lt;br/&gt;绿色：可执行文件&lt;br/&gt;红色：压缩文件&lt;br/&gt;浅蓝色：链接文件&lt;br/&gt;黄色：设备文件&lt;br/&gt;灰色：其他文件&lt;/p&gt;
&lt;h3 id=&quot;复制目录cp--r&quot;&gt;（6）复制目录：cp -r&lt;/h3&gt;
&lt;p&gt;cp命令既可用于拷贝文件，又可用于拷贝目录，但是&lt;strong&gt;拷贝目录时必须使用-r参数&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： cp -r 源目录 目标目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将tmp1下的tmp2目录拷贝到tmp3目录下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213244923-398780387.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，首先将/usr下的6.csv文件复制一份到/usr/tmp1/tmp2中，然后尝试将tmp2目录复制到tmp3中，未加-r参数时，报错，无法拷贝。增加-r参数后，拷贝成功。并且检查到，发现是连目录中的文件一起拷贝的。&lt;/p&gt;
&lt;h3 id=&quot;移动目录mv&quot;&gt;（7）移动目录：mv&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： mv 源目录 目标目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213309536-386144179.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;移动目录时，会将目录中的文件一起移动。&lt;br/&gt;当目标目录不存在时，就会在移动目录的同时进行重命名操作。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213316621-1506829964.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，/usr/tmp9是不存在的，所以将tmp4移动过去后，就会同时改名。&lt;br/&gt;当源目录和目标目录在同一父目录下，其实就是对原目录进行了重命名操作。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213324676-928309621.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除目录rmdirrm&quot;&gt;（8）删除目录：rmdir、rm&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： rmdir 目录名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在/usr中创建一个新目录tmp5，可以使用rmdir直接删除它。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213333359-505106643.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rmdir -p 目录名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在/usr中递归创建一个新目录tmp6/tmp7，使用rmdir删除tmp7时，只会将tmp7删除，保留了其父目录tmp6；如果使用了-p参数，就会将其父目录tmp6一并删除，如例中删除tmp8时。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213341382-1686853842.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是当要删除了目录非空时，比如tmp2中有6.csv文件时，再使用rmdir删除它时就会报错。这时候就需要使用rm命令了。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213347776-1621891785.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;rm命令既可以用于删除文件，也可以用于删除目录，但是此时必须增加-r参数。&lt;br/&gt;rmdir命令只能用于删除目录。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213357959-1489108148.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;文件操作&quot;&gt;2.文件操作&lt;/h2&gt;
&lt;h3 id=&quot;复制文件cp&quot;&gt;（1）复制文件：cp&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： cp 文件名 目录&amp;lt;/文件名&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213416781-1050726938.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过cp命令，将一个文件复制到指定位置，可以在指定位置目录后设定文件名称，相当于复制后对该文件进行了重命名操作。&lt;/p&gt;
&lt;h3 id=&quot;移动文件mv&quot;&gt;（2）移动文件：mv&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： mv 文件名 目录&amp;lt;/文件名&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213427936-286386228.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除文件rm&quot;&gt;（3）删除文件：rm&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式：rm 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213440251-529741634.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;读取并打印文件内容cat&quot;&gt;（4）读取并打印文件内容：cat&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： cat 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213448646-1379258558.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看更多文件内容moreless&quot;&gt;（5）查看更多文件内容：more、less&lt;/h3&gt;
&lt;p&gt;当文件内容太多，一屏不能显示完，如果用cat就只能显示最后面的部分，这时候就需要用more或者less了。&lt;br/&gt;more看完一屏后，就可以通过空格（打印下一屏）、或者回车键（打印下一行），可以随时通过q结束浏览模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： more 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213458901-397744263.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;less和more的作用一样：分屏浏览长文本内容，但是less比more更方便，可以“回头”打印，即往前看。可以通过上下方向键，向前向后看，空格和回车键和more命令作用一样，使用q随时退出浏览模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： less 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取前n行head&quot;&gt;（6）读取前n行：head&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： head &amp;lt;-n&amp;gt; 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认打印前十行。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213506895-1778859324.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用参数n=3，只打印前三行。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213515442-535218357.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;读取后n行tail&quot;&gt;（7）读取后n行：tail&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： tail &amp;lt;-n&amp;gt; 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认打印后十行。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213528371-1564947016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用参数n=3，只打印后三行。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213536319-980421472.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;搜索文件find&quot;&gt;（8）搜索文件：find&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： find -name filename  --按文件名搜索&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用命令或者类型的模糊匹配搜索。&lt;br/&gt;使用-iname参数而不是-name，可以忽略大小写。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213547291-2127778735.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用-o参数连接多个搜索条件，条件之间是“或”关系。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213555205-581149210.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以设定搜索目录，在指定目录下完成搜索。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213603278-2067468910.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;文件属性&quot;&gt;3.文件属性&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;（1）简介&lt;/h3&gt;
&lt;p&gt;使用ls -l命令查看指定目录下的文件的属性信息。这里的“文件”是广义上的文件，包括文件、目录、设备、分区等等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： ls -l &amp;lt;目录&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213613061-18885906.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;含义解释：&lt;br/&gt;total：该目录下所有文件的大小（单位为KB），是列表中文件属性第五列，文件大小之和，这里的单位是B。&lt;br/&gt;第一列：文件类型和文件权限，共10位。&lt;br/&gt;其中：&lt;br/&gt;第1位：文件类型（d:目录，-:普通文件……）&lt;br/&gt;后9位，每3位为一组，均为rwx三个参数的组合。r——可读，w——可写，x——可执行。&lt;br/&gt;第一个三位，代表文件所属主（user）的权限，第二个三位，代表文件所属组（group）的权限，第三个三位代表其他非所属组用户（others）的权限。&lt;/p&gt;
&lt;h3 id=&quot;更改所属组chgrp&quot;&gt;（2）更改所属组：chgrp&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： chgrp 组名 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213621844-1415231632.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先使用groupadd命令增加一个组testgrp，接着使用chgrp将文件5.txt的所属组更改为这个组。&lt;/p&gt;
&lt;h3 id=&quot;更改所属主chown&quot;&gt;（3）更改所属主：chown&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： chown &amp;lt;-R&amp;gt; 用户名 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213631503-260141468.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先使用useradd命令增加一个用户testusr，接着使用chown将文件5.txt的所属主更改为这个用户。&lt;br/&gt;当修改目录时，需要注意，使用-R参数，实现&lt;strong&gt;级联更改&lt;/strong&gt;，即不仅修改该目录，还修改这个目录下面的所有子目录或者文件。-R只对修改目录有效。&lt;/p&gt;
&lt;h3 id=&quot;更改用户操作权限chmod&quot;&gt;（4）更改用户操作权限：chmod&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： chmod &amp;lt;-R&amp;gt; 权限值 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为方便权限的修改，将权限用数字表示，r：4，w：2，x：1，-：0，三个权限组的值拼接在一起，比如：上面的rw-r--r--，第一个权限组：rw-等于4+2+=6，第二个权限组：r--等于4+0+0=4，第三个权限组：r--等于4+0+0=4，所以其权限值为644。&lt;br/&gt;同样，使用-R参数，实现&lt;strong&gt;级联更改&lt;/strong&gt;。&lt;br/&gt;在linux系统中，默认一个目录的权限为 755，而一个文件的默认权限为644。&lt;br/&gt;-rwxrwx---用数字表示就是770，下面我们通过chmod命令将5.txt文件进行权限修改。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213640658-427623222.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;快捷键&quot;&gt;4.快捷键&lt;/h2&gt;
&lt;h3 id=&quot;终止当前命令ctrlc&quot;&gt;（1）终止当前命令：CTRL+C&lt;/h3&gt;
&lt;p&gt;用于终止当前命令。&lt;/p&gt;
&lt;h3 id=&quot;自动补全tab&quot;&gt;（2）自动补全：TAB&lt;/h3&gt;
&lt;p&gt;帮你自动补全命令或者目录，如果没有反应，说明系统还无法判断，需要输入更多信息。&lt;/p&gt;
&lt;h3 id=&quot;退出当前终端ctrldexit&quot;&gt;（3）退出当前终端：CTRL+D、exit&lt;/h3&gt;
&lt;p&gt;退出当前终端，关闭窗口。&lt;/p&gt;
&lt;h3 id=&quot;暂停当前进程ctrlz&quot;&gt;（4）暂停当前进程：CTRL+Z&lt;/h3&gt;
&lt;p&gt;暂停当前的进程，使用fg恢复。&lt;/p&gt;
&lt;h3 id=&quot;清屏ctrll&quot;&gt;（5）清屏：CTRL+L&lt;/h3&gt;

&lt;h2 id=&quot;其他命令&quot;&gt;5.其他命令&lt;/h2&gt;
&lt;h3 id=&quot;查看命令帮助信息man&quot;&gt;（1）查看命令帮助信息：man&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;命令格式： man 命令名称&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用来看一个命令的帮助文档。&lt;/p&gt;
&lt;h3 id=&quot;文件的打包与压缩&quot;&gt;（2）文件的打包与压缩：&lt;/h3&gt;
&lt;p&gt;在linux下最常见的压缩文件通常都是以.tar.gz为结尾的，除此之外还有.tar,.gz, .bz2,.zip等等。&lt;br/&gt;.gz ： gzip压缩工具压缩的文件&lt;br/&gt;.bz2： bzip2 压缩工具压缩的文件&lt;br/&gt;.tar ： tar打包程序打包的文件(tar并没有压缩功能，只是把一个目录合并成一个文件)&lt;br/&gt;.tar.gz ： 可以理解为先用tar打包，然后再gzip压缩&lt;br/&gt;.tar.bz2 ： 同上，先用tar打包，然后再bzip2压缩&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;压缩：      gzip 文件名
解压缩：    gzip -d 压缩包.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：gzip不可以压缩目录。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213650840-619152951.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;压缩：      bzip2 文件名
解压缩：    bzip2 -d 压缩包.bz2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213659573-1065313834.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;打包：      tar -cvf 文件名.tar 文件名
解包tar：   tar -xvf 压缩包.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213707615-2021885951.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;打包后gzip压缩：    tar -czf 文件名.tar.gz 文件名
解压缩tar.gz：      tar -xzvf 压缩包.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213714919-1811981838.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;打包后bzip2压缩：   tar -cjf 文件名.tar.bz2 文件名
解压缩tar.bz2：     tar -xjvf 压缩包.tar.bz2 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180704213722861-1912837168.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;系统关机与重启&quot;&gt;（3）系统关机与重启：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;halt                立刻关机
poweroff            立刻关机
shutdown -h now     立刻关机(root用户使用)
shutdown -h 10      10分钟后自动关机
reboot              立刻重启
shutdown -r now     立刻重启(root用户使用) 
shutdown -r 10      10分钟后自动重启(root用户使用)&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 04 Jul 2018 13:44:00 +0000</pubDate>
<dc:creator>hbsygfz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hbsygfz/p/9265481.html</dc:identifier>
</item>
</channel>
</rss>