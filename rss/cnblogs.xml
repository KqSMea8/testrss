<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Prometheus 到底 NB 在哪里？- 每天5分钟玩转 Docker 容器技术（84） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/7709970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/7709970.html</guid>
<description>&lt;p&gt;&lt;span&gt;本节讨论 &lt;/span&gt;&lt;span&gt;Prometheus 的核心，多维数据模型&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;我们先来看一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如要监控容器&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;webapp1&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;的内存使用情况，最传统和典型的方法是定义一个指标&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;container_memory_usage_bytes_webapp1&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;来记录&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;webapp1&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;的内存使用数据。假如每1分钟取一次样，那么在数据库里就会有类似下面的记录。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171022-1508656915704001043.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171022-1508656915704001043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好，现在需求发生了点变化，我们需要知道所有 webapp 容器的内存使用情况。如果还是采用前面的方法，就不得不增加新的指标&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;container_memory_usage_bytes_webapp2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;container_memory_usage_bytes_webapp3&lt;/span&gt;&lt;/code&gt;&lt;span&gt;…&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;像 Graphite 这类更高级的监控方案采用了更为优雅的层次化数据模型。为了满足上面的需求，Graphite 会定义指标&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;container.memory_usage_bytes.webapp1&lt;/span&gt;&lt;/code&gt;、&lt;code&gt;&lt;span&gt;container.memory_usage_bytes.webapp2&lt;/span&gt;&lt;/code&gt;、&lt;code&gt;&lt;span&gt;container.memory_usage_bytes.webapp3&lt;/span&gt;&lt;/code&gt;…&lt;/p&gt;
&lt;p&gt;然后就可以用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;container.memory_usage_bytes.webapp*&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;获取所有的 webapp 的内存使用数据。&lt;/p&gt;
&lt;p&gt;此外，Graphite 还支持&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;sum()&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;等函数对指标进行计算和处理，比如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;sum(container.memory_usage_bytes.webapp*)&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;可以得到所有 webapp 容器占用的总内存量。&lt;/p&gt;
&lt;p&gt;目前为止问题处理得都很好。但客户总是会提出更多的需求：现在不仅要按容器名字统计内存使用量，还要按镜像来统计；或者想对比一下某一组容器在生产环境和测试环境中对内存使用的不同情况。&lt;/p&gt;
&lt;p&gt;当然你可以说：只要定义更多的指标就能满足这些需求。比如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;container.memory_usage_bytes.image1.webapp1&lt;/span&gt;&lt;/code&gt;、&lt;code&gt;&lt;span&gt;container.memory_usage_bytes.webapp1.prod&lt;/span&gt;&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;但问题在于我们没办法提前预知客户要用这些数据回答怎样的问题，所以我们没办法提前定义好所有的指标。&lt;/p&gt;
&lt;p&gt;下面来看看 Prometheus 的解决方案。&lt;/p&gt;
&lt;p&gt;Prometheus 只需要定义一个全局的指标&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;container_memory_usage_bytes&lt;/span&gt;&lt;/code&gt;，然后通过添加不同的维度数据来满足不同的业务需求。&lt;/p&gt;
&lt;p&gt;比如对于前面 webapp1 的三条取样数据，转换成 Prometheus 多维数据将变成：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171022-1508656915752002917.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171022-1508656915752002917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后面三列&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;container_name&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;image&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;env&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;span&gt;就是数据的三个维度。想象一下，如果不同&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;env&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（prod、test、dev），不同&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;image&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（mycom/webapp:1.2、mycom/webapp:1.3）的容器，它们的内存使用数据中标注了这三个维度信息，那么将能满足很多业务需求，比如：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;计算 webapp2 的平均内存使用情况：avg(container_memory_usage_bytes{container_name=“webapp2”})&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;计算运行 mycom/webapp:1.3 镜像的所有容器内存使用总量：sum(container_memory_usage_bytes{image=“mycom/webapp:1.3”})&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;统计不同运行环境中 webapp 容器内存使用总量：sum(container_memory_usage_bytes{container_name=~“webapp”}) by (env)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里只列了几个例子，不过已经能够说明 Prometheus 数据模型的优势了：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过维度对数据进行说明，附加更多的业务信息，进而满足不同业务的需求。同时维度是可以动态添加的，比如再给数据加上一个&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;user&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;维度，就可以按用户来统计容器内存使用量了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Prometheus 丰富的查询语言能够灵活、充分地挖掘数据的价值。前面示例中的 avg、sum、by 只是查询语言中很小的一部分功能，已经为我们展现了 Prometheus 对多维数据进行分片、聚合的强大能力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在我们已经知道 Prometheus 的强大之处了，再 NB 的东西也得落地，下一节就开始实践。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 23:49:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/7709970.html</dc:identifier>
</item>
<item>
<title>简易RPC框架-客户端限流配置 - min.jiang</title>
<link>http://www.cnblogs.com/ASPNET2008/p/7712974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ASPNET2008/p/7712974.html</guid>
<description>&lt;h2&gt;关键资源&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17071/201710/17071-20171023023432066-678782400.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关键资源总是有限的，也就意味着处理能力也有限，所以当面对大量业务时，为了保障自己能够有序的提供服务最经济的做法就是限制同一时间处理的事务数。比如银行的工作人员，一个工作人员同时只能为一个客户服务，来多了根本处理不了,不光是一种浪费而且有可以造成混乱的局面导致工作人员无法工作。&lt;/p&gt;
&lt;h2&gt;网络请求漏斗&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17071/201710/17071-20171023023442394-372183807.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;p&gt;越上层的服务器处理的事务越轻，应付请求的能力也越强，也就意味着同一请求越上层处理时间越短。为了有效的保护下层服务器，就需要对发送给下层的请求量做限流，在下层服务器可接受的范围内。否则就可能会出现下层服务器资源耗尽而无法正常提供服务的情况。&lt;/p&gt;
&lt;h2&gt;限流场景&lt;/h2&gt;
&lt;h3&gt;服务端限流&lt;/h3&gt;
&lt;p&gt;如果在服务端做限流，无论有多少个客户端，总的提供能力是固定的，所以不会因为客户端数量过多而导致资源不足，因为处理不过来的请求会被阻塞等待获取资源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缺点也比较明显，由于服务提供者整体设置了最大限流数，此时所有的客户端共享同一份限流数据，那么有可能导致有的服务能分配到资源有些服务请求分配不到资源导致无法请求的情况。&lt;/p&gt;
&lt;h3&gt;客户端限流&lt;/h3&gt;
&lt;p&gt;客户端限流解决上服务端限流提到的问题，它能保证每个客户端都能得到响应。但是从其它方面考虑，必须针对不同的客户端做不同的限流策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求量大，但时效性不高，此时将限流数控制小一些会比较合适&lt;/li&gt;
&lt;li&gt;请求量大，但时效性高，此时将限流数适当调高&lt;/li&gt;
&lt;li&gt;响应时间长，即慢接口，适当降低&lt;/li&gt;
&lt;li&gt;主流业务，核心业务，适当调高&lt;/li&gt;
&lt;li&gt;非主流业务，适当降低&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果客户端的数量不固定，那么有可能导致客户端数量过多造成大量请求打到服务端导致处理不了的结果，所以需要严格监控客户端的调用情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置复杂，需要针对每个客户端做相对精准的判断&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;RPC实现&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;限流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里指的限流是指每秒从客户端提交到服务端的请求数量。&lt;/p&gt;
&lt;blockquote readability=&quot;2.3275862068966&quot;&gt;
&lt;p&gt;过滤器机制可参考：&lt;a href=&quot;http://www.cnblogs.com/ASPNET2008/p/7636276.html&quot;&gt;简易RPC框架-过滤器机制&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;服务引用注解上增加限流&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RpcReference&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;isSync&lt;/span&gt;() default true;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt;*&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;     * 客户端最大并发数&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;     * @return&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;     &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;maxExecutesCount&lt;/span&gt;() default 10;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建动态代理时将限流参数传递到服务端&lt;/h3&gt;
&lt;p&gt;需要修改RpcProxy类,构造函数中增加服务引用注解参数，然后在invoke方法中从服务引用注解中获取限流参数传递给request对象。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; RpcProxy(&lt;span class=&quot;pl-k&quot;&gt;Class&amp;lt;&lt;span class=&quot;pl-smi&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt; clazz,&lt;span class=&quot;pl-smi&quot;&gt;ReferenceConfig&lt;/span&gt; referenceConfig,&lt;span class=&quot;pl-smi&quot;&gt;RpcReference&lt;/span&gt; reference) {
        &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;clazz &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; clazz;
        &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;referenceConfig&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;referenceConfig;
        &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;reference&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;reference;
        &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;isSync&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;reference&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;isSync();
    }

&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Object&lt;/span&gt; invoke(&lt;span class=&quot;pl-smi&quot;&gt;Object&lt;/span&gt; proxy, &lt;span class=&quot;pl-smi&quot;&gt;Method&lt;/span&gt; method, &lt;span class=&quot;pl-k&quot;&gt;Object&lt;/span&gt;[] args) throws &lt;span class=&quot;pl-smi&quot;&gt;Throwable&lt;/span&gt; {

        &lt;span class=&quot;pl-c1&quot;&gt;...&lt;/span&gt;

        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;reference &lt;span class=&quot;pl-k&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;) {
            request&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;setMaxExecutesCount(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;reference&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;maxExecutesCount());
        }

        &lt;span class=&quot;pl-c1&quot;&gt;...&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RpcInvocation增加限流参数&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RpcInvocation&lt;/span&gt; {

    &lt;span class=&quot;pl-c1&quot;&gt;...&lt;/span&gt;

    &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;getMaxExecutesCount&lt;/span&gt;();

}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;AbstractInvoker修改buildRpcInvocation方法&lt;/h3&gt;
&lt;p&gt;从request对象中获取限流参数，传递给RpcInvocation对象。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;RpcInvocation&lt;/span&gt; buildRpcInvocation(&lt;span class=&quot;pl-smi&quot;&gt;RpcRequest&lt;/span&gt; request){
        &lt;span class=&quot;pl-smi&quot;&gt;RpcInvocation&lt;/span&gt; rpcInvocation&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;RpcInvocation&lt;/span&gt;() {
            &lt;span class=&quot;pl-c1&quot;&gt;...&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;getMaxExecutesCount&lt;/span&gt;() {
                &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; request&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;getMaxExecutesCount();
            }
        };
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; rpcInvocation;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;AccessLimitFilter&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;修改令牌管理器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按接口分配令牌管理器，令牌管理器存储在map中共享。如果未初始化则进行令牌管理器的初始化，如果已经初始化则直接申请令牌。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;AccessLimitManager&lt;/span&gt;{

        &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Object&lt;/span&gt; lock&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Object&lt;/span&gt;();

        &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;Map&amp;lt;&lt;span class=&quot;pl-smi&quot;&gt;String&lt;/span&gt;,&lt;span class=&quot;pl-smi&quot;&gt;RateLimiter&lt;/span&gt;&amp;gt;&lt;/span&gt; rateLimiterMap&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Maps&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;newHashMap();

        &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;RpcInvocation&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;invocation&lt;/span&gt;){
            &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;rateLimiterMap&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;containsKey(invocation&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;getClassName())) {
                &lt;span class=&quot;pl-k&quot;&gt;synchronized&lt;/span&gt; (lock) {
                    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;rateLimiterMap&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;containsKey(invocation&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;getClassName())) {
                        &lt;span class=&quot;pl-k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;RateLimiter&lt;/span&gt; rateLimiter &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;RateLimiter&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;create(invocation&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;getMaxExecutesCount());
                        rateLimiterMap&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;put(invocation&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;getClassName(), rateLimiter);
                    }
                }
            }
            &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;pl-smi&quot;&gt;RateLimiter&lt;/span&gt; rateLimiter&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;rateLimiterMap&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;get(invocation&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;getClassName());
                rateLimiter&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;acquire();
            }
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;修改invoke方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将invocation参数传递给acquire方法。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
    &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Object&lt;/span&gt; invoke(&lt;span class=&quot;pl-smi&quot;&gt;RpcInvoker&lt;/span&gt; invoker, &lt;span class=&quot;pl-smi&quot;&gt;RpcInvocation&lt;/span&gt; invocation) {
        logger&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;info(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;before acquire,&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Date&lt;/span&gt;());
        &lt;span class=&quot;pl-smi&quot;&gt;AccessLimitManager&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;acquire(invocation);

        &lt;span class=&quot;pl-smi&quot;&gt;Object&lt;/span&gt; rpcResponse&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;invoker&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;invoke(invocation);
        logger&lt;span class=&quot;pl-k&quot;&gt;.&lt;/span&gt;info(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;after acquire,&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Date&lt;/span&gt;());
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; rpcResponse;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;客户端&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;服务引用配置限流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里配置每秒一个请求&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-java&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;@RpcReference&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;maxExecutesCount&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ProductService&lt;/span&gt; productService;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;执行结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下图所示，每次请求相隔了一秒，达到了限流请求的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17071/201710/17071-20171023023540738-576271336.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;608&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;待完善&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17071/201710/17071-20171023025156316-1392211448.jpg&quot; alt=&quot;&quot; width=&quot;244&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持方法级限流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上只支持客户端接口级别的限流配置，可以再单独创建一个方法级的注解来配置相关参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持服务端限流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务端限流尽管有它的缺点，但为了更好的保护服务提供者，需要结合多种业务场景来配合客户端限流一起完善，取长补短共同发挥作用。&lt;/p&gt;
&lt;h2&gt;本文源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jiangmin168168/jim-framework&quot;&gt;https://github.com/jiangmin168168/jim-framework&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文中代码是依赖上述项目的，如果有不明白的可下载源码&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 22 Oct 2017 18:38:00 +0000</pubDate>
<dc:creator>min.jiang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ASPNET2008/p/7712974.html</dc:identifier>
</item>
<item>
<title>PE格式第九讲,资源表解析 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7712932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7712932.html</guid>
<description>&lt;h2&gt;一丶熟悉Windows管理文件的方法&lt;/h2&gt;
&lt;p&gt;首先,为什么标题是这个,主要是为了下边讲解资源方便,因为资源结构体很乱.如果直接拿出来讲解,那么就会很晕.&lt;/p&gt;
&lt;p&gt;1.windows管理文件方法&lt;/p&gt;
&lt;p&gt;树形结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023001719177-1040367010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出结构&lt;/p&gt;
&lt;p&gt;根目录&lt;/p&gt;
&lt;p&gt;　　子目录&lt;/p&gt;
&lt;p&gt;　　　　文件.xxx&lt;/p&gt;
&lt;p&gt;　　子目录&lt;/p&gt;
&lt;address&gt;　　　　子目录 (子目录里面还可以有文件夹)&lt;/address&gt;
&lt;p&gt;　　.....　　　　&lt;/p&gt;
&lt;p&gt;那么我们的资源也是这样存储的.&lt;/p&gt;
&lt;h2&gt;二丶资源结构体解析&lt;/h2&gt;
&lt;p&gt;首先,资源结构体分为很多个,但是有用的就3个.一般也分为三个&lt;/p&gt;
&lt;pre&gt;
IMAGE_RESOURCE_DIRECTORY　　　　　　　　　　　　根目录(资源目录头)
&lt;/pre&gt;
&lt;pre&gt;
IMAGE_RESOURCE_DIRECTORY_ENTRY　　　　　　　　 子目录(资源目录项)其中根目录下可以有很多子目录(也就是说根目录下会有子目录的)
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
IMAGE_RESOURCE_DATA_ENTRY　　　　　　　　　　　　文件(资源数据)&lt;br/&gt;结构体解析:&lt;p&gt;1.资源目录头(也可以看做管理文件的根目录)&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;　　　　　　　　　　资源属性
    DWORD   TimeDateStamp;　　　　　　　　　　　时间戳
    WORD    MajorVersion;　　　　　　　　　　　　资源大版本号
    WORD    MinorVersion;　　　　　　　　　　　　资源小版本号
    WORD    NumberOfNamedEntries;　　　　　　　按照名称命名的数量
    WORD    NumberOfIdEntries;　　　　　　　　　按照ID命名的数量
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];&lt;/span&gt;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们看到资源目录头的结构体了,这里大家要知道,有用的就最后两个成员,还有一段注释.&lt;/p&gt;
&lt;p&gt;1.按照名称命名的数量&lt;/p&gt;
&lt;p&gt;意思就是我们的资源是字符串命名加载的有多少个&lt;/p&gt;
&lt;p&gt;2.按照ID命名的数量&lt;/p&gt;
&lt;p&gt;意思就是我们的资源如果按照ID有多少个.&lt;/p&gt;
&lt;p&gt;一般都是用ID的.&lt;/p&gt;
&lt;p&gt;最后两个字段主要是资源的标识,是以ID的有多少个,以字符串标识的有多少个.&lt;/p&gt;
&lt;p&gt;2.资源目录项(子目录)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
            DWORD NameOffset:&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt;;　　　　　　　　　　位段: 低31位飘逝偏移 定义了目录项的名称或者ID
            DWORD NameIsString:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;　　　　　　　　　 位段: 高位, 如果这位为1,则表示31位的偏移指向的是一个Unicode字符串的指针偏移
        };　　　　　　　　　　　　　　　　　　　　　　　这里列出结构体,自己去看,IMAGE_RESOURCE_DIR_STRING_U 里面是字符串长度还有字符串,不是\0结尾　　　　　　　　　
        DWORD   Name;　　　　　　　　　　　　　　　　　
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;　　　　　　　　　　　　偏移RVA因为是联合体,所以有不同的解释
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
            DWORD   OffsetToDirectory:&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt;;　　　　看高位,如果高位是1,那么RVA偏移指向的是新的(根目录)
            DWORD   DataIsDirectory:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;　　　　　　
        };
    };
} IMAGE_RESOURCE_DIRECTORY_ENTRY, &lt;/span&gt;*PIMAGE_RESOURCE_DIRECTORY_ENTRY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前边我们说了&lt;/p&gt;
&lt;p&gt;根目录(资源目录头)下面存放的是这个结构体,这个结构体是一个联合体,所以会有不同的解释&lt;/p&gt;
&lt;p&gt;1.首先,联合体是8个字节大小.&lt;/p&gt;
&lt;p&gt;2.其中第一个DWORD大小,看高位,如果高位是1,那么低31位是指向新的目录项名称的结构体IMAGE_RESOURCE_DIR_STRING_U &lt;/p&gt;
&lt;p&gt;3.如果高位为0,则是ID号,这个ID号说的是 资源ID类型,比如3类型指的就是ICON&lt;/p&gt;
&lt;p&gt;具体,可以随便写个RT_XXX开头的宏去查看.&lt;/p&gt;
&lt;p&gt;这里我写下,跟一下看看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023010925441-733950459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.第二个DWORD量,也是RVA偏移,如果高位为1,那么代表它还是一个目录,也就是指向了一个新的根目录了,这是个不断递归的过程.&lt;/p&gt;
&lt;p&gt;如果不是,则指向文件偏移结构体了.&lt;/p&gt;
&lt;p&gt;文件偏移结构体:(应该是资源数据结构体)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;　　　　　　　　　　资源数据的偏移RVA
    DWORD   Size;　　　　　　　　　　　　　　　大小
    DWORD   CodePage;　　　　　　　　　　　　 代码页缓冲(CMD设置窗口的时候就是这个,没用)
    DWORD   Reserved;　　　　　　　　　　　　 保留
} IMAGE_RESOURCE_DATA_ENTRY, &lt;/span&gt;*PIMAGE_RESOURCE_DATA_ENTRY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个就很简单了,直接前边4个字节指向就是ICON资源的位置.&lt;/p&gt;
&lt;h2&gt;三丶实战演练,定位ICON资源.&lt;/h2&gt;
&lt;p&gt;看了上面结构体,可能会晕,因为联合体很多,不同的方式有不同的解释方法,那么一步一步的跟随&lt;/p&gt;
&lt;h3&gt;1.首先通过数据目录定位资源根目录(也就是根目录,占16个字节,第一个结构体)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023011421035-1354140165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此得出 RVA = 1B000 &lt;/p&gt;
&lt;p&gt;然后查看属于哪个节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023011512301-1717037135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此得出,节的虚拟地址也是从1b000开始的,那么直接看文件偏移即可.&lt;/p&gt;
&lt;p&gt;因为此时FA = RVA了,为了方便,一次截图就指明了,在文件的7800h位置&lt;/p&gt;
&lt;p&gt;然后我们定位到7800h的位置&lt;/p&gt;
&lt;h3&gt;2.找到位置,查看结构体&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023011714863-772486932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到位置后,我们对比结构体成员,看看是什么一次,因为这个是资源根目录,所以查看资源根目录结构体&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];&lt;/span&gt;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现,意思就是按照ID分类的资源有多少个,我们得出是7个,字符串标识的资源有0个,所以不用看了.&lt;/p&gt;
&lt;h3&gt;3.定位资源目录项(子目录)&lt;/h3&gt;
&lt;p&gt;我们知道,资源根目录下面是子目录,现在有7个按照ID分类的资源,那么就有7个资源目录项(子目录)&lt;/p&gt;
&lt;p&gt;我们看下结构体.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
            DWORD NameOffset:&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt;;
            DWORD NameIsString:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        };
        DWORD   Name;
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
            DWORD   OffsetToDirectory:&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt;;
            DWORD   DataIsDirectory:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        };
    };
} IMAGE_RESOURCE_DIRECTORY_ENTRY, &lt;/span&gt;*PIMAGE_RESOURCE_DIRECTORY_ENTRY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先,我们不要被这个结构体弄晕.我们首先要知道结构体的大小&lt;/p&gt;
&lt;p&gt;结构体是2个union(联合体,共用体),而里面的最大类型是DWORD,所以这个结构体大小是8个字节.&lt;/p&gt;
&lt;p&gt;那么我们就知道了,在资源根目录下有7各这样的数组大小,也就是 7 * 8 = 56字节,整个数组占56个字节&lt;/p&gt;
&lt;p&gt;那么我们看下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023012412863-654050087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二个红色箭头没有弄完,截图就完了,不好意思,第二个箭头的意思就是,整个56个字节,是资源目录项,其中黄色区域,属于第一个资源目录项&lt;/p&gt;
&lt;p&gt;那么根据上面的结构体,我们先看黄色区域的第一的4个字节,看看高位是否是1&lt;/p&gt;
&lt;p&gt;这里有两种解释方式&lt;/p&gt;
&lt;p&gt;1.如果高位为1,那么表示一个字符串,那么低31位指向了一个字符串结构体&lt;/p&gt;
&lt;p&gt;2.如果高位为0,那么表示是一个双字节的ID (资源类型)&lt;/p&gt;
&lt;p&gt;现在得出  00000003  很显然,高位为0,那么表示一个资源类型,而资源类型上面看过了,3表示是一个ICON&lt;/p&gt;
&lt;p&gt;那么在看黄色区域的第二的4个字节&lt;/p&gt;
&lt;p&gt;1.高位为1,那么低31位表示指向了一个新的&quot;根目录&quot; (结构体大小还是16个字节,还是最后4个字节有用,也就是上面第一个结构体)&lt;/p&gt;
&lt;p&gt;2.如果高位为0,那么低31位表示指向了一个资源数据结构体(可以表示为文件)&lt;/p&gt;
&lt;p&gt;现在得出, 80000048  很显然高位为1,因为高1位是个8,那么低31位则表示指向一个新的&quot;根目录&quot;&lt;/p&gt;
&lt;p&gt;得出RVA偏移得48&lt;/p&gt;
&lt;p&gt;那么根据刚才的FA = RVA  FA = 7800 那么现在新的目录的FA = 7800 + 48 = 7848&lt;/p&gt;
&lt;p&gt;那么在7848h表示新的根目录,跟过去看下.&lt;/p&gt;
&lt;h3&gt;4.定位新的根目录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023013212723-1803008973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,有是4个新的数据目录项,那么我们接着看下4个数组是什么.&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023013311566-875075049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们还是继续,看资源类型为3的,通过上图,我们得出,资源数据类型为三的(ICON)的高4个字节的高1位还是8&lt;/p&gt;
&lt;p&gt;也就会80000140,那么意思就是又指向了一个新的&quot;根目录&quot;&lt;/p&gt;
&lt;h3&gt;5.继续寻找新的根目录&lt;/h3&gt;
&lt;p&gt;上图得出 偏移是140  FA = 7800 + 140  = 7940&lt;/p&gt;
&lt;p&gt;那么文件位置7940是新的根目录,接着数16个字节.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023013611379-1439890913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到7940位置是一个新的根目录,那么我们看出,它按照ID分类,就一项了,那么下面8个字节就是数据目录项了.(子目录)&lt;/p&gt;
&lt;p&gt;那么我们由此得出,它的高位不是1,&lt;/p&gt;
&lt;p&gt;现在的 00000238 高位不是1了,那么根据 &quot;子目录&quot;结构体的定义,高位不是1那么这个RVA偏移则是指向了一个文件结构体的偏移&lt;/p&gt;
&lt;p&gt;我们继续计算FA ,一致FA = 7800 ,得出的RVA = 238  则FA = 7800+238 = 7A38h&lt;/p&gt;
&lt;h3&gt;6.定位资源数据(文件)&lt;/h3&gt;
&lt;p&gt;那么我们定义为7A38的位置,看下资源数据结构是什么样子&lt;/p&gt;
&lt;p&gt;为了防止大家结构体忘记,重新拷贝到这里观看.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, &lt;/span&gt;*PIMAGE_RESOURCE_DATA_ENTRY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就第一个个成员有用,4个字节,表示ICON的RVA偏移.&lt;/p&gt;
&lt;p&gt;那么定位到7A38&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023014124207-1876383770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出第一个成员的RVA偏移是 0001c018&lt;/p&gt;
&lt;p&gt;RVA = 1C018&lt;/p&gt;
&lt;p&gt;按照FA = RVA  ,的知刚才的RVA = 1B000&lt;/p&gt;
&lt;p&gt;求FA = ?&lt;/p&gt;
&lt;p&gt;FA = 1C018 - 1B000 + 7800 =  8818&lt;/p&gt;
&lt;p&gt;那么文件偏移8818的位置,则是ICON的数据了.&lt;/p&gt;
&lt;p&gt;我们看下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023014342191-289177030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,很像图标资源了,那么此时,我们去看下我们的图标二进制,是不是这个.&lt;/p&gt;
&lt;p&gt;对比文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171023014602598-1291893546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看出,位置确实是这个地方了.那么此时就已经成功的找到了ICON类型的资源了&lt;/p&gt;


&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;</description>
<pubDate>Sun, 22 Oct 2017 17:48:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7712932.html</dc:identifier>
</item>
<item>
<title>ModelForm - 张璨</title>
<link>http://www.cnblogs.com/zhang-can/p/7712790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhang-can/p/7712790.html</guid>
<description>&lt;p&gt;这是一个神奇的组件，通过名字我们可以看出来，这个组件的功能就是把model和form组合起来，对，你没猜错，相信自己的英语水平。&lt;/p&gt;
&lt;p&gt;先来一个简单的例子来看一下这个东西怎么用：&lt;/p&gt;
&lt;p&gt;比如我们的数据库中有这样一张学生表，字段有姓名，年龄，爱好，邮箱，电话，住址，注册时间等等一大堆信息，现在让你写一个创建学生的页面，你的后台应该怎么写呢？&lt;/p&gt;
&lt;p&gt;首先我们会在前端一个一个罗列出这些字段，让用户去填写，然后我们从后天一个一个接收用户的输入，创建一个新的学生对象，保存&lt;/p&gt;
&lt;p&gt;其实，重点不是这些，而是合法性验证，我们需要在前端判断用户输入是否合法，比如姓名必须在多少字符以内，电话号码必须是多少位的数字，邮箱必须是邮箱的格式这些&lt;/p&gt;
&lt;p&gt;当然可以一点一点手动写限制，各种判断，这毫无问题，除了麻烦&lt;/p&gt;
&lt;p&gt;我们现在有个更优雅（以后在Python相关的内容里，要多用“优雅”这个词，并且养成习惯）的方法：ModelForm&lt;/p&gt;
&lt;p&gt;先来简单的，生硬的把它用上，再来加验证条件：&lt;/p&gt;
&lt;p&gt;首先导入ModelForm&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.forms &lt;span&gt;import&lt;/span&gt; ModelForm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在视图函数中，定义一个类，比如就叫StudentList，这个类要继承ModelForm，在这个类中再写一个原类Meta（规定写法，并注意首字母是大写的）&lt;/p&gt;
&lt;p&gt;在这个原类中，有以下属性（部分）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentList(ModelForm):
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;= models.Student  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对应的Model中的类&lt;/span&gt;
        fields = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字段，如果是__all__,就是表示列出所有的字段&lt;/span&gt;
        exclude = None          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;排除的字段&lt;/span&gt;
        labels = None           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;提示信息&lt;/span&gt;
        help_texts = None       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;帮助提示信息&lt;/span&gt;
        widgets = None          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义插件&lt;/span&gt;
        error_messages = None   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义错误信息&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;error_messages用法：&lt;/span&gt;
        error_messages =&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,},
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,},
        }

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;widgets用法,比如把输入用户名的input框给为Textarea&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;首先得导入模块&lt;/span&gt;
        &lt;span&gt;from&lt;/span&gt; django.forms &lt;span&gt;import&lt;/span&gt; widgets as wid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为重名，所以起个别名&lt;/span&gt;
        widgets =&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:wid.Textarea(attrs={&quot;class&quot;:&quot;c1&quot;}) #还可以自定义属性
        }&lt;br/&gt;#labels，自定义在前端显示的名字&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　　　labels=&lt;span&gt; {
            &quot;name&quot;&lt;span&gt;:&quot;用户名&quot;
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在url对应的视图函数中实例化这个类，把这个对象传给前端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student(request):

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        student_list &lt;/span&gt;=&lt;span&gt; StudentList()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:student_list})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后前端只需要     {{ student_list.as_p }}   一下，所有的字段就都出来了，可以用as_p显示全部，也可以通过student_list.name........等等自定义显示哪些字段&lt;/p&gt;

&lt;p&gt;保存数据的时候，不用挨个取数据了，只需要save一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student(request):

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        student_list &lt;/span&gt;=&lt;span&gt; StudentList()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:student_list})
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;span&gt;student_list &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= StudentList(request.POST)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; student_list.is_valid():
            &lt;span&gt;student_list.save()
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:student_list})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编辑数据：&lt;/p&gt;
&lt;p&gt;如果不用ModelForm，编辑的时候得显示之前的数据吧，还得挨个取一遍值，如果ModelForm，只需要加一个&lt;span&gt;instance=obj&lt;span&gt;（obj是要修改的数据库的一条数据的对象）&lt;/span&gt;&lt;/span&gt;就可以得到同样的效果&lt;/p&gt;
&lt;p&gt;保存的时候要注意，一定要注意有这个对象（instance=obj），否则不知道更新哪一个数据&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42.5&quot;&gt;&lt;img id=&quot;code_img_closed_e4041603-b8b5-44d4-bc82-33d9cff4f1b9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e4041603-b8b5-44d4-bc82-33d9cff4f1b9&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e4041603-b8b5-44d4-bc82-33d9cff4f1b9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse,redirect
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.forms &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ModelForm
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your views here.&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(request):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; model_form = models.Student&lt;/span&gt;
    model_form =&lt;span&gt; models.Student.objects.all()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;model_form&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:model_form})


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentList(ModelForm):
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;= models.Student  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对应的Model中的类&lt;/span&gt;
        fields = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字段，如果是__all__,就是表示列出所有的字段&lt;/span&gt;
        exclude = None          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;排除的字段&lt;/span&gt;
        labels = None           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;提示信息&lt;/span&gt;
        help_texts = None       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;帮助提示信息&lt;/span&gt;
        widgets = None          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义插件&lt;/span&gt;
        error_messages = None   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义错误信息&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;error_messages用法：&lt;/span&gt;
        error_messages =&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,},
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,},
        }

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;widgets用法,比如把输入用户名的input框给为Textarea&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;首先得导入模块&lt;/span&gt;
        &lt;span&gt;from&lt;/span&gt; django.forms &lt;span&gt;import&lt;/span&gt; widgets as wid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为重名，所以起个别名&lt;/span&gt;
        widgets =&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:wid.Textarea
        }
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;labels，自定义在前端显示的名字&lt;/span&gt;
        labels=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student(request):

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        student_list &lt;/span&gt;=&lt;span&gt; StudentList()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:student_list})
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        student_list &lt;/span&gt;=&lt;span&gt; StudentList(request.POST)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; student_list.is_valid():
            student_list.save()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:student_list})

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student_edit(request,pk):
    obj &lt;/span&gt;= models.Student.objects.filter(pk=&lt;span&gt;pk).first()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; obj:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        student_list &lt;/span&gt;= StudentList(instance=&lt;span&gt;obj)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_edit.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:student_list})

    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        student_list &lt;/span&gt;= StudentList(request.POST,instance=&lt;span&gt;obj)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; student_list.is_valid():
            student_list.save()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_edit.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:student_list})
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;对于验证规则，谷歌浏览器很智能，会自动帮我们做一些验证，可以在form表单上加  novalidate 属性就可以不让浏览器为我们做验证&lt;/p&gt;
&lt;p&gt;ModelForm还支持所有form的功能，比如钩子，所以我们就可以通过钩子来自定义验证规则&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 16:22:00 +0000</pubDate>
<dc:creator>张璨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhang-can/p/7712790.html</dc:identifier>
</item>
<item>
<title>含有重复元素的全排列问题 - nullzx</title>
<link>http://www.cnblogs.com/nullzx/p/7712747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullzx/p/7712747.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简介&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文主要介绍基于分治方式（递归）和枚举方式（循环）来构建指定字符串的全排列方法，两种方法都可以解决重复元素的全排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎探讨，如有错误敬请指正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如需转载，请注明出处&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/nullzx/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/nullzx/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;h4&gt;&lt;span&gt;1. 基于分治方式（递归实现）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）一个元素的全排列只有一种&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）[A0, A1, A2]的全排列等于下面三个全排列的并集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A0开头，拼接上[A1,A2]的所有全排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A1开头，拼接上[A0,A2]的所有全排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A2开头，拼接上[A0,A1]的所有全排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，对于[A0, A1, ……，An]的全排列，我们可以将问题转换成n个子问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A0开头，拼接上[A1,A2 ……，An]的所有全排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A1开头，拼接上[A0,A2 ……，An]的所有全排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;An开头，拼接上[A0,A2 ……，A(n-1)]的所有全排列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而每个子问题又可以继续向下转化成n-1个子问题，最终可以转化到只有一个元素的全排列问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于数组中有重复元素的情况，我们只要保证，重复元素只能有一次作为子问题的开头元素，这样我们就可以避免重复计算。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;2. 基于枚举方式（循环实现）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果我们将全排列按照大小顺序进行排序，假设我们知道了第i个排列是[A0, A1, A2, A3, ……]，那么第i+1个排列就是比[A0, A1, A2, A3, ……]大，且最小的那个。找到i+1个排列的步骤如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）从后往前两两比较，找到第一个满足a[i]&amp;lt;a[i+1]的两个元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）从a[i+1]开始往后找，找到一个大于a[i]中最小的一个元素,这个元素的下标记为j，交换a[i]和a[j]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）将[i+1, a.length-1]的元素全部逆序&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;3. 代码实现&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;下面是java代码的实现&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package interviewquestion;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

public class Permutation {
        
        //返装有回字符串s的全排列的List对象
        public static List&amp;lt;String&amp;gt; byTraverse(String s){
                char[] chArr = s.toCharArray();
                List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;String&amp;gt;();
                byTraverse0(chArr, 0, list);
                return list;
        }
        
        
        private static void byTraverse0(char[] arr, int left, List&amp;lt;String&amp;gt; list){
                if(left &amp;gt;= arr.length-1){
                        list.add(new String(arr));
                        return;
                }
                
                //用于记录交换到left下标的每一个元素，防止计算重复的排列
                HashSet&amp;lt;Character&amp;gt; hs = new HashSet&amp;lt;Character&amp;gt;();

                for(int i = left; i &amp;lt; arr.length; i++){
                        //arr[left]后面的每一个元素arr[i]都和arr[left]交换
                        swap(arr, left, i);
                        if(!hs.contains(arr[left])){
                                hs.add(arr[left]);
                                byTraverse0(arr, left+1, list);
                        }
                        //将left和i交换回来，防止遗漏，重复
                        //已保证下一个交换到left下标的是未交换过的元素
                        swap(arr, left, i);
                }
        }
        /*=================================================*/
        
        //返装有大于等于字符串s的全排列的List对象
        public static List&amp;lt;String&amp;gt; byNext(String s){
                char[] arr = s.toCharArray();
                List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;String&amp;gt;();
                list.add(s);
                
                while(next(arr)){
                        list.add(new String(arr));
                }
                return list;
        }
        
        private static boolean next(char[] arr){
                boolean hasNext = false;
                int i;
                for(i = arr.length-2; i &amp;gt;= 0; i--){
                        if(arr[i] &amp;lt; arr[i+1]){
                                hasNext = true;
                                break;
                        }
                }
                
                //如果所有元素是从大到小排列，说明是最大的字符串
                if(!hasNext){
                        return false;
                }
                
                //从i+1的下标往后找（必定是单调递减）,找一个比arr[i]大的集合中最小的一个
                int j;
                for(j = i+1; j &amp;lt; arr.length; j++){
                        if(arr[j] &amp;lt;= arr[i]){
                                break;
                        }
                }
                j--;
                
                //交换这两个元素，然后逆序i+1以后的所有元素
                swap(arr, i, j);
                reverse(arr, i+1, arr.length-1);
                
                return true;
        }
        
        private static void reverse(char[] arr, int from, int to){
                for(int i = from, j = to; i &amp;lt; j; i++, j--){
                        swap(arr, i, j);
                }
        }
        
        /*=================================================*/
        
        private static void swap(char[] chArr, int i, int j){
                char t = chArr[i];
                chArr[i] = chArr[j];
                chArr[j] = t;
        }
        
        public static void main(String[] args){
                List&amp;lt;String&amp;gt; list1 = Permutation.byNext(&quot;1233&quot;);
                System.out.println(list1);
                System.out.println(list1.size());
                
                System.out.println();
                
                List&amp;lt;String&amp;gt; list2 = Permutation.byTraverse(&quot;1233&quot;);
                System.out.println(list2);
                System.out.println(list2.size());
        }
}
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
[1233, 1323, 1332, 2133, 2313, 2331, 3123, 3132, 3213, 3231, 3312, 3321]
12

[1233, 1323, 1332, 2133, 2313, 2331, 3213, 3231, 3123, 3132, 3312, 3321]
12
&lt;/pre&gt;</description>
<pubDate>Sun, 22 Oct 2017 15:57:00 +0000</pubDate>
<dc:creator>nullzx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullzx/p/7712747.html</dc:identifier>
</item>
<item>
<title>Java8系列之初识 - menghuanzhiwuhen</title>
<link>http://www.cnblogs.com/mhzwh/p/7712737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mhzwh/p/7712737.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;终于有机会在工作中使用高版本的Java8，但是一直没有对java8中添加的新特性进一步了解过，所以趁着这个机会学习一下，能够在编程中熟练的使用。&lt;/p&gt;
&lt;p&gt;一、接口的改变&lt;/p&gt;
&lt;p&gt;       我们知道，在java8版本以前，接口中只能定义静态常量和抽象方法，但是在java8添加了默认方法，也叫扩展方法；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public interface DefaultInterface {
        //默认是public static final，也只能是
         public static final int count=0;
         //抽象方法
         void add();
         
         //默认方法==&amp;gt;扩展方法
         default int add(int x,int y ) {
                 return x+y;
         }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样，实现类不必实现默认方法，只需实现抽象方法，使用时直接调用接口中的方法。（好像和流式的api引入有关）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class DefaultImpl implements DefaultInterface {

        @Override
        public void add() {
                System.out.println(&quot;我是抽象方法的实现&quot;);

        }
        public static void main(String[] args) {
                DefaultInterface di=new DefaultImpl();
                di.add();
                di.add(12, 3);
        }

}
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 22 Oct 2017 15:55:00 +0000</pubDate>
<dc:creator>menghuanzhiwuhen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mhzwh/p/7712737.html</dc:identifier>
</item>
<item>
<title>二叉树的层次遍历 - cccc_hi</title>
<link>http://www.cnblogs.com/liyuhui-Z/p/7712699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyuhui-Z/p/7712699.html</guid>
<description>&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;借助队列来实现&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先初始化队列.然后将根结点压入队列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后出队,输出出队元素的值,&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果存在左孩子.则左孩子入队&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果存在右孩子,则右孩子入队, 循环直到判断条件不成立&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要将节点从下到上 从左到右输出的话.只需要设置一个辅助栈 然后将数据压入栈中 最后出栈即可&lt;/p&gt;
&lt;p&gt;(下面是从下到上,从左到右的输出)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201710/1260476-20171022233959459-1527244513.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 15:43:00 +0000</pubDate>
<dc:creator>cccc_hi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyuhui-Z/p/7712699.html</dc:identifier>
</item>
<item>
<title>关于时钟模块DS1302的使用心得 - Andrew_qian</title>
<link>http://www.cnblogs.com/qsyll0916/p/7712695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qsyll0916/p/7712695.html</guid>
<description>&lt;p&gt;最近在做万年历，用到实时时钟DS1302模块，花了两天时间看资料和写驱动，想记录一下我的学习经过，顺便做一下总结。&lt;/p&gt;
&lt;p&gt;首先就是在图书馆查各种资料，于是查到的大多是这些，主要时硬件方面的资料:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201710/1083998-20171022225837818-413268826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201710/1083998-20171022225814787-1131304821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实能查到很多资料，但是能为我们所用的不是很多。在使用一个芯片时，我一般时按照一下步骤去学习：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、芯片介绍；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、查看引脚定义；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、外围电路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、分析时序图；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、模仿着编写驱动程序，然后自己动手写驱动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、实现功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我就按照这个顺序去学习这款芯片；&lt;/p&gt;
&lt;p&gt;一、芯片介绍&lt;/p&gt;
&lt;p&gt;DS1302是DALLAS(达拉斯)公司出的一款涓流充电时钟芯片，2001年DALLAS被MAXIM(美信)收购，因此我们看到的DS1302的数据手册既有DALLAS的标志，又有MAXIM的标志；&lt;br/&gt;DS1302实时时钟芯片广泛应用于电话、传真、便携式仪器等产品领域，他的主要性能指标如下：&lt;br/&gt;1、DS1302是一个实时时钟芯片，可以提供秒、分、小时、日期、月、年等信息，并且还有软年自动调整的能力，可以通过配置AM/PM来决定采用24小时格式还是12小时格式。&lt;br/&gt;2、拥有31字节数据存储RAM。&lt;br/&gt;3、串行I/O通信方式，相对并行来说比较节省IO口的使用。&lt;br/&gt;4、DS1302的工作电压比较宽，大概是2.0V~5.5V都可以正常工作。采用双电源供电，当主电源比备用电源高0.2V时，由主电源供电，否则采用备用电源，一般是一个纽扣电池。&lt;br/&gt;5、DS1302这种时钟芯片功耗一般都很低，它在工作电压2.0V的时候，工作电流小于300nA。&lt;br/&gt;6、DS1302共有8个引脚，有两种封装形式，一种是DIP-8封装，芯片宽度(不含引脚)是300mil，一种是SOP-8封装，有两种宽度，一种是150mil，一种是208mil。&lt;/p&gt;
&lt;p&gt;二、引脚定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201710/1083998-20171022230131459-1977458588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、外围电路&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201710/1083998-20171022230929412-1683524905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般与单片机IO口相连时要加上拉电阻，提高 IO 口的驱动能力，这样信号比较稳定，计时也比较准确。&lt;/p&gt;
&lt;p&gt;四、分析时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201710/1083998-20171022231321943-459608670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是单字节写入的时序图，可见，先拉高使能端，进行使能选择，然后在时钟上升沿写入一个字节。&lt;/p&gt;
&lt;p&gt;DS1302在进行读写操作时最少读写两个字节，第一个是控制字节，就是一个命令，说明是读还是写操作，第二个时需要读写的数据。&lt;/p&gt;
&lt;p&gt;对于单字节写，只有在SCLK为低电平时才能将 CE 置高电平，所以刚开始将SCLK 置低，CE置高，然后把需要写入的字节送入 IO口，然后跳变SCLK，在SCLK下降沿时，写入数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201710/1083998-20171022231814756-1549643395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;五、编写驱动程序&lt;/p&gt;
&lt;p&gt;有了 上面的分析，我们就可以学着编写驱动程序了，可以把驱动程序分为几个模块来写，由底层慢慢往上累加，比如，我们先编写单个字节的读写操作，在编写整个数据的读写，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DS1302.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*******************&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ds1302_writebyte(uchar &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; t = &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;8&lt;/span&gt;;i++&lt;span&gt;){
        SCIO &lt;/span&gt;= &lt;span&gt;byte&lt;/span&gt; &amp;amp;&lt;span&gt; t;        
        t&lt;/span&gt;&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        DOWN();       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下降沿完成一个位的操作&lt;/span&gt;
&lt;span&gt;    }
    SCIO &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保释放io引脚&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;********************&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ds1302_writedata(uchar addr,uchar data_){
    
    CE &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;        nop();    
    SCLK &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    nop();    
    CE &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;        nop();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能片选信号&lt;/span&gt;
    ds1302_writebyte((addr&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)|&lt;span&gt;0x80&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方便后面写入&lt;/span&gt;
&lt;span&gt;    ds1302_writebyte(data_);
    CE &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;        nop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传送数据结束&lt;/span&gt;
&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*************************&lt;/span&gt;
&lt;span&gt;uchar ds1302_readbyte(){
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; i;
    uchar data_ &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; t = &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;;     
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;7&lt;/span&gt;;i++){     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c51好像不支持直接在for循环里面直接定义变量&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(SCIO){

            data_ &lt;/span&gt;= data_ | t;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;低位在前，逐位读取,刚开始不对，估计是这个的问题&lt;/span&gt;
&lt;span&gt;        }                
        t&lt;/span&gt;&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        DOWN();
    }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data_;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;************************&lt;/span&gt;
&lt;span&gt;uchar ds1302_readdata(uchar addr){

    uchar data_ &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    CE &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;     nop();
    SCLK &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  nop();
    CE &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;      nop();
    ds1302_writebyte((addr&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)|&lt;span&gt;0x81&lt;/span&gt;&lt;span&gt;);
    data_ &lt;/span&gt;=&lt;span&gt; ds1302_readbyte();
    CE &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;       nop();
    SCLK &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  nop();
    SCIO &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  nop();
    SCIO &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  nop();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data_;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*********************&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init_ds1302(){

     uchar i;
     CE &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化引脚&lt;/span&gt;
     SCLK = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
     i  &lt;/span&gt;= ds1302_readdata(&lt;span&gt;0x00&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取秒寄存器,秒在最低位&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt;((i &amp;amp; &lt;span&gt;0x80&lt;/span&gt; != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)){

         ds1302_writedata(&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;0x00&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;撤销写保护，允许写入数据&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;7&lt;/span&gt;;i++&lt;span&gt;){

            ds1302_writedata(i,init_time[i]);
        }
     }    
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;**************&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ds1302_readtime(){       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取时间&lt;/span&gt;
      &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; i;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;7&lt;/span&gt;;i++&lt;span&gt;){

             init_time[i] &lt;/span&gt;=&lt;span&gt; ds1302_readdata(i);
      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中头文件为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef __DS1302_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; __DS1302_H&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reg52.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;intrins.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;#define&lt;/span&gt; uint unsigned int
&lt;span&gt;#define&lt;/span&gt; uchar unsigned char
&lt;span&gt;#define&lt;/span&gt; nop() _nop_()

&lt;span&gt;#define&lt;/span&gt; UP() {SCLK = 0;nop();SCLK = 1;nop();} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上升沿  ,使用宏定义函数时最后一定家分号&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; DOWN() {SCLK = 1;nop();SCLK = 0;nop();} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下降沿&lt;/span&gt;

 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个模块内没有集成上拉电阻，使用时最好接上2&lt;/span&gt;
sbit CE = P2^&lt;span&gt;5&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RET,使能输入引脚，当读写时，置高位&lt;/span&gt;
sbit SCIO = P2^&lt;span&gt;6&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IO     ，双向通信引脚，读写数据都是通过这个完成&lt;/span&gt;
sbit SCLK = P2^&lt;span&gt;7&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SCLK，时钟信号


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为什么有时候好好的，也会出错显示少了分号呢？还气人啊！！！！&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; ds1302_writebyte(uchar &lt;span&gt;byte&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写一个字节; &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ds1302_writedata(uchar addr,uchar data_);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给某地址写数据,data是c51内部的关键字，表示将变量定义在数据存储区，故此处用data_;&lt;/span&gt;
uchar ds1302_readbyte();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读一个字节&lt;/span&gt;
uchar ds1302_readdata(uchar addr);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取某寄存器数据     ;&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init_ds1302();
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ds1302_readtime();


&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt;&lt;span&gt; uchar init_time[];

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;六、功能实现&lt;/p&gt;
&lt;p&gt; 功能实现就简单了，就是加上主函数嘛，然后加上我们可以亲眼看见并感知的模块，比如用数码管显示时间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DS1302.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; DIG P0&lt;span&gt;
sbit LSA &lt;/span&gt;= P2^&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
sbit LSB &lt;/span&gt;= P2^&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
sbit LSC &lt;/span&gt;= P2^&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;



uchar init_time[] &lt;/span&gt;= {&lt;span&gt;0x50&lt;/span&gt;,&lt;span&gt;0x15&lt;/span&gt;,&lt;span&gt;0x14&lt;/span&gt;,&lt;span&gt;0x22&lt;/span&gt;,&lt;span&gt;0x10&lt;/span&gt;,&lt;span&gt;0x06&lt;/span&gt;,&lt;span&gt;0x17&lt;/span&gt;};&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化的时间    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒 分 时 日 月 周 年 &lt;/span&gt;
uchar code DIG_CODE[&lt;span&gt;10&lt;/span&gt;]={&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x06&lt;/span&gt;,&lt;span&gt;0x5b&lt;/span&gt;,&lt;span&gt;0x4f&lt;/span&gt;,&lt;span&gt;0x66&lt;/span&gt;,&lt;span&gt;0x6d&lt;/span&gt;,&lt;span&gt;0x7d&lt;/span&gt;,&lt;span&gt;0x07&lt;/span&gt;,&lt;span&gt;0x7f&lt;/span&gt;,&lt;span&gt;0x6f&lt;/span&gt;}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数码管数字表&lt;/span&gt;
&lt;span&gt;uint&lt;/span&gt; disp[&lt;span&gt;8&lt;/span&gt;]={&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;0x3f&lt;/span&gt;};&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把要显示的数字传给他    &lt;/span&gt;
uchar Num=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; count_flag = &lt;span&gt;0&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断溢出次数&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; time0_init();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器0初始化&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; display();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数码管显示时间&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;){
    
     init_ds1302();     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化时写入起始时间&lt;/span&gt;
&lt;span&gt;     time0_init();

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
            display();
     }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;***************&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
            
     ds1302_readtime();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取时间&lt;/span&gt;
    disp[&lt;span&gt;7&lt;/span&gt;] = DIG_CODE[init_time[&lt;span&gt;0&lt;/span&gt;]&amp;amp;&lt;span&gt;0x0f&lt;/span&gt;&lt;span&gt;];
    disp[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = DIG_CODE[init_time[&lt;span&gt;0&lt;/span&gt;]&amp;gt;&amp;gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
    disp[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;0X40&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示一个横线&lt;/span&gt;
    disp[&lt;span&gt;4&lt;/span&gt;] = DIG_CODE[init_time[&lt;span&gt;1&lt;/span&gt;]&amp;amp;&lt;span&gt;0x0f&lt;/span&gt;&lt;span&gt;];
    disp[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = DIG_CODE[init_time[&lt;span&gt;1&lt;/span&gt;]&amp;gt;&amp;gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
    disp[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;0X40&lt;/span&gt;&lt;span&gt;;
    disp[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = DIG_CODE[init_time[&lt;span&gt;2&lt;/span&gt;]&amp;amp;&lt;span&gt;0x0f&lt;/span&gt;&lt;span&gt;];
    disp[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = DIG_CODE[init_time[&lt;span&gt;2&lt;/span&gt;]&amp;gt;&amp;gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;******************&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; time0_init(){

    TMOD&lt;/span&gt;=&lt;span&gt;0X02&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择为定时器模式，工作方式2，8位自动重装模式，仅用TRX打开启动。&lt;/span&gt;
    TH0=&lt;span&gt;0X9C&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给定时器赋初值，定时100us，0x9c就是156，就是还需计数100次产生溢出，就是0.1ms&lt;/span&gt;
    TL0=&lt;span&gt;0X9C&lt;/span&gt;&lt;span&gt;;    
    ET0&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开定时器0中断允许&lt;/span&gt;
    EA=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开总中断&lt;/span&gt;
    TR0=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开定时器&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DigDisplay() interrupt &lt;span&gt;1&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断入口函数，扫描以实现动态显示&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器在工作方式二会自动重装初，所以不用在赋值。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    TH0=0X9c;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给定时器赋初值，定时0.1ms
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    TL0=0X00;&lt;/span&gt;
&lt;span&gt;
    count_flag&lt;/span&gt;++&lt;span&gt;;    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count_flag==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        count_flag &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        DIG&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(Num)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;位选，选择点亮的数码管，&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;7&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;LSB=&lt;span&gt;0&lt;/span&gt;;LSC=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;LSB=&lt;span&gt;0&lt;/span&gt;;LSC=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;LSB=&lt;span&gt;1&lt;/span&gt;;LSC=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;LSB=&lt;span&gt;1&lt;/span&gt;;LSC=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;LSB=&lt;span&gt;0&lt;/span&gt;;LSC=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;LSB=&lt;span&gt;0&lt;/span&gt;;LSC=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;LSB=&lt;span&gt;1&lt;/span&gt;;LSC=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;):
                LSA&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;LSB=&lt;span&gt;1&lt;/span&gt;;LSC=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;    
        }

        DIG&lt;/span&gt;=disp[Num]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;段选，选择显示的数字。&lt;/span&gt;
        Num++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Num&amp;gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
            Num&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 总结一下：&lt;/p&gt;
&lt;p&gt;这个芯片基本上不是很难，但是想要用的灵活，用的上手，还是得多练的，最好是先把上面的驱动程序对着时序图自己分析一遍，然后自己亲手编写一下。&lt;/p&gt;
&lt;p&gt;还有就是看数据手册，一个芯片所能用到的数据，在数据手册上基本都能查到。资料谁都能查到，就看怎么用了。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 15:42:00 +0000</pubDate>
<dc:creator>Andrew_qian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qsyll0916/p/7712695.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法总结-字符串相关高频面试题算法 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/7712596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/7712596.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;前言：&lt;/strong&gt;周末闲来无事，在七月在线上看了看字符串相关算法的讲解视频，收货颇丰，跟着视频讲解简单做了一下笔记，方便以后翻阅复习同时也很乐意分享给大家。什么字符串在算法中有多重要之类的大路边上的客套话就不多说了，直接上笔记吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、字符串&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;java：String内置类型，不可更改。（如需更改可考虑：StringBuffer, StringBuilder,char[]等）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;二-归类&quot; data-source-line=&quot;7&quot;&gt;&lt;strong&gt;&lt;span&gt;二、归类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　字符串涉及到的相关题型通常会是以下几个方面：&lt;/p&gt;
&lt;ul data-source-line=&quot;8&quot;&gt;&lt;li&gt;概念理解：字典序&lt;/li&gt;
&lt;li&gt;简单操作：插入删除字符、旋转&lt;/li&gt;
&lt;li&gt;规则判断（罗马数字转换 是否是合法的整数、浮点数）&lt;/li&gt;
&lt;li&gt;数字运算（大数加法，二进制加法）&lt;/li&gt;
&lt;li&gt;排序、交换&lt;/li&gt;
&lt;li&gt;字符计数：变位词&lt;/li&gt;
&lt;li&gt;匹配（正则表达式、全串匹配、KMP、周期判断）&lt;/li&gt;
&lt;li&gt;动态规划（LCS、编辑距离、最长回文子串）&lt;/li&gt;
&lt;li&gt;搜索（单词变换、排列组合）&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;三-例题&quot; data-source-line=&quot;18&quot;&gt;&lt;span&gt;&lt;strong&gt;三、例题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-交换把一个只包含01的串排序可交换任意两个数的位置最少需要多少次交换&quot; data-source-line=&quot;19&quot;&gt;1、交换：把一个只包含01的串排序，可交换任意两个数的位置，最少需要多少次交换？&lt;/h4&gt;
&lt;p data-source-line=&quot;20&quot;&gt;　　思路：从两头往中间扫荡，扫荡过程中在左边遇到1就和右边遇到的0交换位置，直接到左有下标相遇时结束。 具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] strs) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arrays = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] {&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; left = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; right = arrays.length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (arrays[left] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 left++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (arrays[right] == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 right--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (left &amp;gt;=&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; arrays[left];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 arrays[left] =&lt;span&gt; arrays[right];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 arrays[right] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Logger.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;交换次数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; count);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; array : arrays) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             Logger.print(array + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;50&quot;&gt;清晰起见，交换次数和排序后的的字符串输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
交换次数：3
0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;2-字符串替换和复制删除一个字符串所有的a并且复制所有的b字符数组足够大&quot; data-source-line=&quot;56&quot;&gt;2、字符串替换和复制：删除一个字符串所有的a，并且复制所有的b（字符数组足够大）&lt;/h4&gt;
&lt;p data-source-line=&quot;57&quot;&gt;　　思路：详细思路见代码注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] strs) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt;[] input = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{'a', 'b', 'c', 'd', 'a', 'f', 'a', 'b', 'c', 'd', 'b', 'b', 'a', 'b'&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt;[] chars = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[50&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; input.length; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             chars[j] =&lt;span&gt; input[j];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Logger.println(&quot;操作前：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c:chars
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                ) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Logger.print(c + &quot;, &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; n = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; countB = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、删除a，用n当做新下标，循环遍历数组，凡是不是a的元素都放到新下标的位置，由于新n增长慢，老下标i增长快，所以元素不会被覆盖。
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并且在删除a时顺便记录b的数量，以便下一步复制b时可以提前确定数组最终的最大的下标。&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; chars[i] != '\u0000' &amp;amp;&amp;amp; i &amp;lt; chars.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (chars[i] != 'a'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 chars[n++] =&lt;span&gt; chars[i];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (chars[i] == 'b'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 countB++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、复制b，由于在第一步中就已经知道了字符串中b的个数，这里就能确定最终字符串的最大下标，从最打下表开始倒着复制原字符串，碰到b时复制即可。&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newMaxIndex = n + countB - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = n - 1; k &amp;gt;= 0; k--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             chars[newMaxIndex--] =&lt;span&gt; chars[k];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (chars[k] == 'b'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 chars[newMaxIndex--] =&lt;span&gt; chars[k];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         Logger.println(&quot;\n操作后：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c:chars
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                ) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             Logger.print(c + &quot;, &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;3-交换星号一个字符串只包含-和数字请把它的-都放在开头&quot; data-source-line=&quot;100&quot;&gt;3、交换星号：一个字符串只包含 * 和数字，请把它的 * 都放在开头。&lt;/h4&gt;
&lt;p data-source-line=&quot;101&quot;&gt;　　如：1 * 2 * 4 * 3 =&amp;gt; * * * 1 2 4 3&lt;/p&gt;
&lt;ul data-source-line=&quot;102&quot;&gt;&lt;li&gt;方案一：倒着操作，从最大下标开始向前遍历，遇到非 * 号的元素则加入&quot;新&quot;下标中，遍历完毕后，j即代表 * 号的个数，然后将0-j赋值为 * 即可。（操作后，数字的相对位置不变） 代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] strs) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt;[] chars = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{'1', '*', '4', '3', '*', '5', '*'&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案一（操作后，数字的相对位置不变）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 倒着操作：从最大下标开始向前遍历，遇到非*号的元素则加入&quot;新&quot;下标中，遍历完毕后，j即代表*号的个数，然后将0-j赋值为*即可。&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j = chars.length - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = j; i &amp;gt;= 0; i--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (chars[i] != '*'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 chars[j--] =&lt;span&gt; chars[i];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (j &amp;gt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             chars[j--] = '*'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c:chars
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                ) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             Logger.print(c + &quot;, &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;125&quot;&gt;输出结果如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
*, *, *, 1, 4, 3, 5,
&lt;/pre&gt;&lt;/div&gt;
&lt;ul data-source-line=&quot;130&quot;&gt;&lt;li&gt;方案二（操作后，数组的相对位置会变）快排划分，根据循环不变式（每一步循环之后条件都成立）:如本题[0..i-1]是*,[i..j-1]是数字,[j...n-1]未探测，循环时，随着i和j增加，维护此条件依然不变，代码如下:&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] strs) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt;[] chars = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{'1', '*', '4', '3', '*', '5', '*'&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案二（操作后，数组的相对位置会变）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 快排划分，根据循环不变式（每一步循环之后条件都成立）:如本题[0..i-1]是*,[i..j-1]是数字,[j...n-1]未探测，循环时，随着i和j增加，维护此条件依然不变&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, j = 0; j &amp;lt; chars.length; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (chars[j] == '*'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;char&lt;/span&gt; temp =&lt;span&gt; chars[i];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 chars[i] =&lt;span&gt; chars[j];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 chars[j] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c:chars
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                ) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             Logger.print(c + &quot;, &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;151&quot;&gt;输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
*, *, *, 3, 1, 5, 4,
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;4-单词翻转&quot; data-source-line=&quot;156&quot;&gt;4、单词翻转&lt;/h4&gt;
&lt;p data-source-line=&quot;157&quot;&gt;　　例如：I am a student =》 student a am I&lt;/p&gt;
&lt;p&gt;　　思路：&lt;/p&gt;
&lt;p&gt;　　1、先将整个字符串翻转：&lt;code class=&quot;hljs&quot;&gt;如：I am &lt;span class=&quot;hljs-tag&quot;&gt;a student =》 tneduts &lt;span class=&quot;hljs-tag&quot;&gt;a ma I&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　2、通过空格判断出每个单词，然后对每个单词进行翻转&lt;/p&gt;
&lt;p&gt;　　代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] strs) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         String input = &quot;I am a student&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt;[] chars =&lt;span&gt; input.toCharArray();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j = chars.length - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; j) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             swap(chars, i++, j--&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; front = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; tail = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (front &amp;lt;&lt;span&gt; chars.length) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (chars[front] == ' '&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; frontTemp = front - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (tail &amp;lt;&lt;span&gt; frontTemp) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     swap(chars, tail++, frontTemp--&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 tail = front + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             front++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c:chars
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                ) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            Logger.print(c);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;char&lt;/span&gt;[] chars, &lt;span&gt;int&lt;/span&gt; index1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index2) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; temp =&lt;span&gt; chars[index1];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         chars[index1] =&lt;span&gt; chars[index2];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         chars[index2] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;197&quot;&gt;输出结果如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
student a am I
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;5-子串变位词给定两个串a和b问b是否a的子串变位词&quot; data-source-line=&quot;202&quot;&gt;5、子串变位词：给定两个串a和b，问b是否a的子串变位词。&lt;/h4&gt;
&lt;p data-source-line=&quot;203&quot;&gt;　　例如：a=hello。b=lel，lle，ello都是true；b=elo是false&lt;/p&gt;
&lt;h4 id=&quot;思路&quot; data-source-line=&quot;204&quot;&gt;　　思路：&lt;/h4&gt;
&lt;ul data-source-line=&quot;205&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;　　一、首先需要了解对两个串是否是变位词的判断：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol data-source-line=&quot;206&quot;&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;　　对两个串按统一规则排序，排序后若相等则是变位词。&lt;/li&gt;
&lt;li&gt;　　对两个串中出现的字母统计，两串中相同的字母出现的次数一致则为变位词。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul data-source-line=&quot;208&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;　　二、然后从母串的第一个元素遍历，每往后遍历一个元素就把从当前元素开始到加上子串的长度的位置作为一个区间和子串比较是否是变位词。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;210&quot;&gt;最后一题综合前几个题用到的一些技巧，还是比较有趣的，这里就不贴出代码了，也激发一下大家的动手能力，感兴趣的童鞋不妨试着写一写。&lt;/p&gt;
&lt;p data-source-line=&quot;212&quot;&gt;以上问题如有不同思路欢迎交流。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 15:32:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/7712596.html</dc:identifier>
</item>
<item>
<title>Django项目搭建和配置总结 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/7712635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/7712635.html</guid>
<description>&lt;h2 id=&quot;安装和创建虚拟环境&quot;&gt;安装和创建虚拟环境&lt;/h2&gt;
&lt;h2 id=&quot;安装django包&quot;&gt;安装Django包&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;先进入虚拟环境，在联网下执行：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;pip install django==1.8.7&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建django项目&quot;&gt;创建django项目&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;进入虚拟环境，先创建一个文件用来存放项目，比如在桌面Desktop创建一个myprojects文件。&lt;/li&gt;
&lt;li&gt;进入myprojects文件，执行：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;django-admin startproject 项目名称
例：
django-admin startproject mytest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会在文件下创建一个mytest的项目，其目录：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135090/201710/1135090-20171022232106615-2101051959.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;目录说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;manage.py：一个命令行工具，可以说Django项目就是从这个文件开始执行的。&lt;/li&gt;
&lt;li&gt;_init _.py：一个空文件，表示mytest应该被看做一个python包；&lt;/li&gt;
&lt;li&gt;settings.py：整个项目的配置参数文件；&lt;/li&gt;
&lt;li&gt;urls.py：项目的URL声明，一般项目的顶级url正则匹配放置在这里；&lt;/li&gt;
&lt;li&gt;wsgi.py：项目与WSGI兼容的Web服务器入口；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建应用&quot;&gt;创建应用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py startapp 应用名称
例：
python manage.py startapp myapp
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;创建后生成目录：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135090/201710/1135090-20171022232134631-530140812.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;admin.py: 模型注册和后台管理相关的文件；&lt;/li&gt;
&lt;li&gt;__init__.py: 应用应该被看做一个Python包；&lt;/li&gt;
&lt;li&gt;migrations: 用来放置应用模型的迁移脚本文件；&lt;/li&gt;
&lt;li&gt;models.py: 定义模型；&lt;/li&gt;
&lt;li&gt;test.py: 放置项目的测试文件；&lt;/li&gt;
&lt;li&gt;viems.py: 定义视图；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;添加应用&quot;&gt;添加应用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;由于项目管理着所有的应用，每个应用都要添加到项目的应用列表中；&lt;/li&gt;
&lt;li&gt;打开mytest/settings.py,INSTALLED_APPS下添加：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135090/201710/1135090-20171022232204959-1898790178.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py runserver ip:port
例：
python manage.py runserver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135090/201710/1135090-20171022232218209-1403842536.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：ip和port可以分别设置服务器的ip和端口；省略不写默认ip为127.0.0.1；端口：8000；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开浏览器输入http://127.0.0.1:8000，得到网页：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135090/201710/1135090-20171022232236740-1458733285.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：当项目文件发生修改时，服务器会自动重启，不需要手动。关闭服务器ctrl+C。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置数据库&quot;&gt;配置数据库&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Django默认数据库sqlite3，其配置参数在mytest/setting.py文件下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135090/201710/1135090-20171022232329381-512866165.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以修改配置，换成需要连接的数据库：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以mysql为例，改成如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mytest',  # 数据库的名字
        'USER': 'root',   # 用户名
        'PASSWORD': 'mysql',  # 密码
        'HOST': 'localhost',  # 主机
        'PORT': '3306',  # 端口
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：这些参数默认数据库已经创建好，如果还没有数据库，需要登录mysql去创建。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;另外django连接mysql需要pymysql包的支持，所以先安装pymysql：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;sudo pip install pymysql&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;安装完毕，需要导入到django中，打开应用mytest/__init__.py文件，加入代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import pymysql

pymysql.install_as_MySQLdb()  # 与mysql交互的函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：一定要记得导入pymysql，否则无法连接数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置模板&quot;&gt;配置模板&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;直接在项目mytest文件夹下，创建名为templates的文件夹；&lt;/li&gt;
&lt;li&gt;在templates文件下创建与应用名字相同的文件夹myapp；&lt;/li&gt;
&lt;li&gt;这个应用的所有模板将放置在myapp文件夹下；&lt;/li&gt;
&lt;li&gt;将模板加入项目配置，在mytest/setting.py文件下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135090/201710/1135090-20171022232348146-1194618255.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此：django项目开发配置基本完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;额外说明：如果在pycharm集成环境下创建的django项目，设置了应用和模板后，pycharm会自动添加应用和模板，这两步无需再手动操作。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 15:30:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/7712635.html</dc:identifier>
</item>
</channel>
</rss>