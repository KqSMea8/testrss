<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一起来读Netty In Action（一） - jy的blog</title>
<link>http://www.cnblogs.com/jy107600/p/8745677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jy107600/p/8745677.html</guid>
<description>&lt;p&gt;    Netty是一款异步事件驱动的网络应用程序框架，支持快速的开发可维护的高性能的面向协议的服务器和客户端。在网络编程中，阻塞、非阻塞、同步、异步经常被提到。同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？&lt;/p&gt;
&lt;p&gt;    常见的I/O模型有如下几种：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182298/201805/1182298-20180503212055853-1676956303.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们举一个场景来说明上面各是什么意思：&lt;/p&gt;
&lt;p&gt;   周末我和宝宝逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和宝宝有以下几种方案：&lt;/p&gt;
&lt;p&gt;（1）阻塞：我和宝宝点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。宝宝本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。&lt;/p&gt;
&lt;p&gt;（2）非阻塞：宝宝不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的轮询，是否准备好了。&lt;/p&gt;
&lt;p&gt;（3）多路复用：与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和宝宝逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的IO多路复用，如select、poll、epoll。&lt;/p&gt;
&lt;p&gt;（4）异步：宝宝不想逛街，又嫌餐厅太吵了，想好好休息一下。于是我们叫外卖，打个电话点餐，然后我和宝宝可以在家好好休息一下(此处忽略带宝宝回家的细节)，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以阻塞非阻塞的区别在于：简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得应答，需要等待，那就阻塞了，否则就可以理解为非阻塞。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;而其实同步和异步的区别：&lt;span&gt;就是在线程在等待的过程中能不能去做另外的事情&lt;/span&gt;，如果是同步，则线程一直等待或者去轮询结果；如果是异步，线程直接返回，去做其他的工作，而本次I/O完成之后会主动通知线程完成。&lt;span&gt;实际上同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实我们经常用的ajax就是异步的&lt;a title=&quot;JavaScript&quot; href=&quot;https://zh.wikipedia.org/wiki/JavaScript&quot;&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/a&gt;与&lt;a title=&quot;XML&quot; href=&quot;https://zh.wikipedia.org/wiki/XML&quot;&gt;&lt;span&gt;XML&lt;/span&gt;&lt;/a&gt;技术，在jquery中我们可以配置async: false属性设置ajax为同步请求，其实在js处理处理ajax的时候，会开启单独的ajax工作线程来处理请求，随后，主线程就去做其他的事情了，在主线程收到该请求的回调通知的时候，他才会回来处理该请求结果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面两幅图展示了java网络编程中的阻塞I/O和java nio提供的非阻塞I/O的模型：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182298/201805/1182298-20180521144032601-40206254.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;250&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182298/201805/1182298-20180521144414909-1555010437.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;238&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;                     使用阻塞I/O处理多个连接                             使用selector的非阻塞I/O&lt;/p&gt;
&lt;p&gt;使用selector的模型有如下的好处：&lt;/p&gt;
&lt;p&gt;    （1）较少的线程处理许多连接，减少内存管理和上下文切换带来的开销。&lt;/p&gt;
&lt;p&gt;    （2）没有I/O需要处理的时候，线程也可以被用于其他任务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;介绍完这些概念，我们来看一下netty有哪些核心构件吧。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.channel&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel是java NIO的一个基本构造，代表着一个到实体的开发连接，如读操作和写操作。&lt;/span&gt;Channel通道和流非常相似，主要有以下几点区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通道可以读也可以写，流一般来说是单向的（只能读或者写）。&lt;/li&gt;
&lt;li&gt;通道可以异步读写。&lt;/li&gt;
&lt;li&gt;通道总是基于缓冲区Buffer来读写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在java中channel有如下的实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileChannel&lt;/li&gt;
&lt;li&gt;DatagramChannel&lt;/li&gt;
&lt;li&gt;SocketChannel&lt;/li&gt;
&lt;li&gt;ServerSocketChannel&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FileChannel用于文件的数据读写。 DatagramChannel用于UDP的数据读写。 &lt;span&gt;SocketChannel用于TCP的数据读写。 ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel.所以ServerSocketChannel并不传输数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.回调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个回调其实就是一个方法。在netty内部使用了回调来处理事件，当一个回调被触发，相关的事件可以被ChannelHandler的实现处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Future&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Future提供了另一种在操作完成时通知应用程序的方式，它提供了对此次异步操作的的结果的访问。在java的concurrent包下的 Future只允许手动的检查对应的操作是否已经完成，或者一直阻塞到它完成，所以netty提供了它的实现-channelFuture用于在执行异步的时候调用。channelFuture还提供了额外的方法这些方法使得我们能够注册一个或者多个channelFutureListener 实例，这些监听器的回调方法：operationComplete(),将会在对应的操作完成时被调用每个netty的出站I/O操作都会返回一个ChannelFuture,如下代码中connect ()方法将会直接返回，不会阻塞。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Channel channel =&lt;span&gt; ...;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ChannelFuture future = channel.connect(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&quot;192.168.0.1&quot;,25)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步的连接到远程节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面的例子展示了ChannelFuture和回调的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Channel channel =&lt;span&gt; ...;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; ChannelFuture future = channel.connect(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&quot;192.168.9.1&quot;,25));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步连接到远程节点&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; future.addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener(){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册一个ChannelFutureListener，以便在操作完成时获得通知&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; operationComplete(ChannelFuture future){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;(future.isSuccess()){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果操作是成功的，执行相应的操作
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;          }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Throwable cause = future.cause();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作失败的异常处理&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            cause.printStackTrace();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;其实可以把&lt;/span&gt;ChannelFutureListener看作是回调的一个更加精细的版本。回调和ChannelFutureListener相互补充，构成netty最为关键的组件之一。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.事件和channelHandler&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;netty使用不同的事件开通知我们状态的改变或者是操作的状态，可能由入站数据或者相关的状态更改而触发的事件包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （1）连接激活或者连接失活&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （2）数据读取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （3）用户事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （4）错误事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出站事件是未来将会触发的某个动作的操作结果，这些动作包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （1）打开或者关闭到远程节点的连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （2）将数据写到或者冲刷到套接字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个事件都可以被分发到ChannelHandler类中的某个用户实现的方法，下图展示了ChannelHandler链是怎么处理入站事件的（出站事件也是一样的）：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182298/201805/1182298-20180521141630123-1034472036.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;118&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;netty的ChannelHandler为处理器提供了基本的抽象，netty也提供了大量的预定义的可以开箱即用的ChannelHandler 实现，包括用于各种协议的（如http或ssl/tls）的 ChannelHandler，在内部，ChannelHandler自己也使用了事件和future。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; netty通过触发事件将selector从应用程序抽象出来，消除了所有本来将需手动编写的派发代码，在内部，将会为每个Channel分配一个EventLoop，用于处理所有的事件，包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     （1）注册感兴趣的事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     （2）将事件派发给ChannelHandler&lt;/p&gt;
&lt;p&gt;     （3）安排进一步的动作&lt;/p&gt;
&lt;p&gt;EventLoop本身只由一个线程驱动，其处理了一个channel的所有的I/O事件，并且在该channel整个生命周期内都不会变，这种设计消除了可以在你的ChannelHandler中需要进行同步的顾虑。&lt;/p&gt;
&lt;p&gt;下一节我们将深入的探讨netty的API和编程模型的基本知识。&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 07:02:00 +0000</pubDate>
<dc:creator>jy的blog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jy107600/p/8745677.html</dc:identifier>
</item>
<item>
<title>Java 面试知识点解析(六)——数据库篇 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/9067197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/9067197.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-958b6a30c60032e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;amp;mid=2650692240&amp;amp;idx=1&amp;amp;sn=dc39f07097656042344e7fee8a17259e&amp;amp;chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=1225zdAW9iFdJ86OiBQSr8mP#rd&quot;&gt;知名互联网公司校招 Java 开发岗面试知识点解析&lt;/a&gt; ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。&lt;/p&gt;
&lt;p&gt;前序文章链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/883260941da8&quot;&gt;Java 面试知识点解析(一)——基础知识篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7382c0a843ff&quot;&gt;Java 面试知识点解析(二)——高并发编程篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bfb876565a1e&quot;&gt;Java 面试知识点解析(三)——JVM篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9c50729464b5&quot;&gt;Java 面试知识点解析(四)——版本特性篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/210f85108c52&quot;&gt;Java 面试知识点解析(五)——网络协议篇&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;1.7462686567164&quot;&gt;
&lt;p&gt;前排引用说明及好文推荐：&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/78308460&quot;&gt;面试/笔试第三弹 —— 数据库面试问题集锦&lt;/a&gt;、&lt;a href=&quot;https://segmentfault.com/a/1190000013517914&quot;&gt;数据库常见面试题(开发者篇)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是存储过程有哪些优缺点&quot;&gt;1）什么是存储过程？有哪些优缺点？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;存储过程就像是编程语言中的函数一样，封装了我们的代码（PLSQL，T-SQL）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-------------创建名为GetUserAccount的存储过程----------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;Procedure&lt;/span&gt; GetUserAccount
&lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; UserAccount
go

&lt;span class=&quot;co&quot;&gt;-------------执行上面的存储过程----------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;exec&lt;/span&gt; GetUserAccount&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;存储过程的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;能够将代码封装起来&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保存在数据库之中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;让编程语言进行调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储过程是一个预编译的代码块，执行效率比较高&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;存储过程的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务逻辑放在数据库上，难以迭代&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;三大范式&quot;&gt;2）三大范式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;思考这样的一个例子：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;我们现在需要建立一个描述学校教务的数据库，该数据库涉及的对象包括学生的学号（Sno）、所在系（Sdept）、系主任姓名（Mname）、课程号（Cno）和成绩（Grade），假设我们使用单一的关系模式 Student 来表示，那么根据现实世界已知的信息，会描述成以下这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-344feccbb3cb1fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这个关系模式存在以下问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1） 数据冗余&lt;/strong&gt;&lt;br/&gt;比如，每一个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同，这将浪费大量的存储空间。&lt;br/&gt;&lt;strong&gt;（2）更新异常（update anomalies）&lt;/strong&gt;&lt;br/&gt;由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。比如，某系更换系主任后，必须修改与该系学生有关的每一个元组。&lt;br/&gt;&lt;strong&gt;（3）插入异常（insertion anomalies）&lt;/strong&gt;&lt;br/&gt;如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。&lt;br/&gt;&lt;strong&gt;（4）删除异常（deletion anomalies）&lt;/strong&gt;&lt;br/&gt;如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢失了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;总结：&lt;/strong&gt; 所以，我们在设计数据库的时候，就需要满足一定的规范要求，而满足不同程度要求的就是不同的范式。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第一范式：&lt;/strong&gt; 列不可分&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;1NF（第一范式）是对属性具有&lt;strong&gt;原子性&lt;/strong&gt;的要求，不可再分，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7a54e7d5d8fbf659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果认为最后一列还可以再分成出生年，出生月，出生日，则它就不满足第一范式的要求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第二范式：&lt;/strong&gt; 消除非主属性对码的部分函数依赖&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;2NF（第二范式）是对记录有&lt;strong&gt;唯一性&lt;/strong&gt;的要求，即实体的唯一性，不存在部分依赖，每一列与主键都相关，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-a10fdbaf10a7e6b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该表明显说明了两个事物：学生信息和课程信息；正常的依赖应该是：学分依赖课程号，姓名依赖学号，但这里存在非主键字段对码的部分依赖，即与主键不相关，不满足第二范式的要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可能存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据冗余&lt;/strong&gt;：每条记录都含有相同信息；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除异常&lt;/strong&gt;：删除所有学生成绩，就把课程信息全删除了；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入异常&lt;/strong&gt;：学生未选课，无法记录进数据库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新异常&lt;/strong&gt;：调整课程学分，所有行都调整。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;正确的做法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-fba36ca283ffd5fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第三范式：&lt;/strong&gt; 消除非主属性对码的传递函数依赖&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;3NF（第三范式）对字段有&lt;strong&gt;冗余性&lt;/strong&gt;的要求，任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在依赖传递，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-8d7548eb839bc8db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显，学院电话是一个冗余字段，因为存在依赖传递：（学号）→（学生）→（学院）→（学院电话）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可能会存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据冗余&lt;/strong&gt;：有重复值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新异常&lt;/strong&gt;：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;正确的做法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-83c0288ea9150976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;数据库索引&quot;&gt;3）数据库索引&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;什么是索引？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;底层数据结构是什么，为什么使用这种数据结构？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（1）底层数据结构是B+树：&lt;/strong&gt;&lt;br/&gt;在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）使用B+树的原因：&lt;/strong&gt;&lt;br/&gt;查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（此时，你应该在白纸上画出什么是B+树）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;索引的分类？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;：唯一索引不允许两行具有相同的索引值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主键索引&lt;/strong&gt;：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚集索引(Clustered)&lt;/strong&gt;：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非聚集索引(Non-clustered)&lt;/strong&gt;：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;索引的优缺点？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（1）优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;大大加快数据的检索速度&lt;/strong&gt;，这也是创建索引的最主要的原因；&lt;/li&gt;
&lt;li&gt;加速表和表之间的连接；&lt;/li&gt;
&lt;li&gt;在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；&lt;/li&gt;
&lt;li&gt;通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（2）缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；&lt;/li&gt;
&lt;li&gt;空间方面：索引需要占物理空间。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;什么样的字段适合创建索引？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;经常作查询选择的字段&lt;/li&gt;
&lt;li&gt;经常作表连接的字段&lt;/li&gt;
&lt;li&gt;经常出现在order by, group by, distinct 后面的字段&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;创建索引时需要注意什么？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;非空字段&lt;/strong&gt;：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;取值离散大的字段&lt;/strong&gt;：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;索引字段越小越好&lt;/strong&gt;：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;听说过事务吗必考&quot;&gt;4）听说过事务吗？（必考）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事务简单来说：一个 Session 中所进行所有的操作，要么同时成功，要么同时失败&lt;/strong&gt;；作为单个逻辑工作单元执行的一系列操作，满足四大特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行&lt;/li&gt;
&lt;li&gt;持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;实例说明：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 我们来模拟A向B账号转账的场景&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *   A和B账户都有1000块，现在我让A账户向B账号转500块钱&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; **/&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//A账户减去500块&lt;/span&gt;
String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE a SET money=money-500 &quot;&lt;/span&gt;;
preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);
preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();

&lt;span class=&quot;co&quot;&gt;//B账户多了500块&lt;/span&gt;
String sql2 = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE b SET money=money+500&quot;&lt;/span&gt;;
preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql2);
preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面看，我们的确可以发现A向B转账，成功了。可是如果A向B转账的过程中出现了问题呢？下面模拟一下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// A账户减去500块&lt;/span&gt;
String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE a SET money=money-500 &quot;&lt;/span&gt;;
preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);
preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();

&lt;span class=&quot;co&quot;&gt;// 这里模拟出现问题&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

String sql2 = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE b SET money=money+500&quot;&lt;/span&gt;;
preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql2);
preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，上面代码是会抛出异常的，我们再来查询一下数据。A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。&lt;/p&gt;
&lt;p&gt;我们可以通过事务来解决上面出现的问题：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 开启事务,对数据的操作就不会立即生效。&lt;/span&gt;
    connection.&lt;span class=&quot;fu&quot;&gt;setAutoCommit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);

    &lt;span class=&quot;co&quot;&gt;// A账户减去500块&lt;/span&gt;
    String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE a SET money=money-500 &quot;&lt;/span&gt;;
    preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);
    preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 在转账过程中出现问题&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;// B账户多500块&lt;/span&gt;
    String sql2 = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE b SET money=money+500&quot;&lt;/span&gt;;
    preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql2);
    preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 如果程序能执行到这里，没有抛出异常，我们就提交数据&lt;/span&gt;
    connection.&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 关闭事务【自动提交】&lt;/span&gt;
    connection.&lt;span class=&quot;fu&quot;&gt;setAutoCommit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);

} &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt;(SQLException e) {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// 如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】&lt;/span&gt;
        connection.&lt;span class=&quot;fu&quot;&gt;rollback&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 关闭事务【自动提交】&lt;/span&gt;
        connection.&lt;span class=&quot;fu&quot;&gt;setAutoCommit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e1) {
        e1.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;事务的并发问题有哪几种&quot;&gt;5）事务的并发问题有哪几种？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;丢失更新：一个事务的更新覆盖了另一个事务的更新；&lt;/li&gt;
&lt;li&gt;脏读：一个事务读取了另一个事务未提交的数据；&lt;/li&gt;
&lt;li&gt;不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；&lt;/li&gt;
&lt;li&gt;幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;事务的隔离级别有哪几种&quot;&gt;6）事务的隔离级别有哪几种？&lt;/h3&gt;
&lt;p&gt;隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。ANSI标准定义了4个隔离级别，MySQL的InnoDB都支持，分别是：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;读未提交（READ UNCOMMITTED）：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没 commit 的数据，这样可能会提高性能，但是会导致脏读问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;读已提交（READ COMMITTED）：在一个事务中只允许对其它事务已经 commit 的记录可见，该隔离级别不能避免不可重复读问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可重复读（REPEATABLE READ）：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务 commit 或 rollback。但是，其他事务的 insert/delete 操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复 select 的结果一样，除非本事务中 update 数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;序列化（SERIALIZABLE）：最高级别的隔离，只允许事务串行执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;MySQL默认的隔离级别是可重复读（REPEATABLE READ）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;MySql 的事务支持&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MyISAM：不支持事务，用于只读程序提高性能；&lt;/li&gt;
&lt;li&gt;InnoDB：支持ACID事务、行级锁、并发；&lt;/li&gt;
&lt;li&gt;Berkeley DB：支持事务。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;什么是视图以及视图的使用场景有哪些&quot;&gt;7）什么是视图？以及视图的使用场景有哪些？&lt;/h3&gt;
&lt;p&gt;视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。&lt;/p&gt;
&lt;p&gt;如下两种场景一般会使用到视图：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。&lt;/li&gt;
&lt;li&gt;查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这个视图是在数据库中创建的 而不是用代码创建的。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;dropdelete与truncate的区别&quot;&gt;8）drop,delete与truncate的区别？&lt;/h3&gt;
&lt;p&gt;drop 直接删除表；truncate 删除表中数据，再插入时自增长id又从1开始 ；delete 删除表中数据，可以加where字句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;drop table：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;属于DDL（Data Definition Language，数据库定义语言）&lt;/li&gt;
&lt;li&gt;不可回滚&lt;/li&gt;
&lt;li&gt;不可带 where&lt;/li&gt;
&lt;li&gt;表内容和结构删除&lt;/li&gt;
&lt;li&gt;删除速度快&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;truncate table：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;属于DDL（Data Definition Language，数据库定义语言）&lt;/li&gt;
&lt;li&gt;不可回滚&lt;/li&gt;
&lt;li&gt;不可带 where&lt;/li&gt;
&lt;li&gt;表内容删除&lt;/li&gt;
&lt;li&gt;删除速度快&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;delete from：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;属于DML&lt;/li&gt;
&lt;li&gt;可回滚&lt;/li&gt;
&lt;li&gt;可带where&lt;/li&gt;
&lt;li&gt;表结构在，表内容要看where执行的情况&lt;/li&gt;
&lt;li&gt;删除速度慢,需要逐行删除&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用简要说明：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;不再需要一张表的时候，用drop&lt;/li&gt;
&lt;li&gt;想删除部分数据行时候，用delete，并且带上where子句&lt;/li&gt;
&lt;li&gt;保留表而删除所有数据的时候用truncate&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;触发器的作用&quot;&gt;9）触发器的作用？&lt;/h3&gt;
&lt;p&gt;触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;数据库的乐观锁和悲观锁是什么&quot;&gt;10）数据库的乐观锁和悲观锁是什么？&lt;/h3&gt;
&lt;p&gt;数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。&lt;/p&gt;
&lt;p&gt;乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;悲观锁是一种利用数据库内部机制提供的锁的方式，也就是对更新的数据加锁，这样在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对数据进行更新了，这就是悲观锁的实现方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL InnoDB中使用悲观锁：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;//&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;.开始事务
&lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt;;/begin &lt;span class=&quot;kw&quot;&gt;work&lt;/span&gt;;/start &lt;span class=&quot;kw&quot;&gt;transaction&lt;/span&gt;; (三者选一就可以)
//&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;.查询出商品信息
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; status &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; t_goods &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt;;
//&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;.根据商品信息生成订单
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; t_orders (&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;,goods_id) &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
//&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;.修改商品status为2
&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt; t_goods &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; status=&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
//&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;.提交事务
&lt;span class=&quot;kw&quot;&gt;commit&lt;/span&gt;;/commit &lt;span class=&quot;kw&quot;&gt;work&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的查询语句中，我们使用了 &lt;code&gt;select…for update&lt;/code&gt; 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。&lt;/p&gt;
&lt;p&gt;上面我们提到，使用 &lt;code&gt;select…for update&lt;/code&gt; 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点与不足：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;乐观锁是一种不会阻塞其他线程并发的控制，它不会使用数据库的锁进行实现，它的设计里面由于不阻塞其他线程，所以并不会引起线程频繁挂起和恢复，这样便能够提高并发能力，所以也有人把它称为非阻塞锁。一般的实现乐观锁的方式就是记录数据版本。&lt;/p&gt;
&lt;p&gt;数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。&lt;/p&gt;
&lt;p&gt;实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用版本号实现乐观锁：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;.查询出商品信息
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; (status,status,version) &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; t_goods &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; id=#{&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;}
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;.根据商品信息生成订单
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;.修改商品status为2
&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt; t_goods 
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; status=&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,version=version&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; id=#{&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;} &lt;span class=&quot;kw&quot;&gt;and&lt;/span&gt; version=#{version};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优点与不足：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5625&quot;&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;http://www.open-open.com/lib/view/open1452046967245.html&quot;&gt;深入理解乐观锁与悲观锁&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;超键候选键主键外键分别是什么&quot;&gt;11）超键、候选键、主键、外键分别是什么？&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;候选键（候选码）：是最小超键，即没有冗余元素的超键。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;主键（主码）：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;外键：在一个表中存在的另一个表的主键称此表的外键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;候选码和主码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码(主键)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;sql-约束有哪几种&quot;&gt;12）SQL 约束有哪几种？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;NOT NULL: 用于控制字段的内容一定不能为空（NULL）。&lt;/li&gt;
&lt;li&gt;UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。&lt;/li&gt;
&lt;li&gt;PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。&lt;/li&gt;
&lt;li&gt;FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。&lt;/li&gt;
&lt;li&gt;CHECK: 用于控制字段的值范围。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;mysql存储引擎中的myisam和innodb区别详解&quot;&gt;13）MySQL存储引擎中的MyISAM和InnoDB区别详解&lt;/h3&gt;
&lt;p&gt;在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，其由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然MyISAM性能极佳，但却有一个显著的缺点： &lt;strong&gt;不支持事务处理&lt;/strong&gt;。不过，MySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。&lt;/p&gt;
&lt;p&gt;InnoDB是MySQL的数据库引擎之一，其由Innobase oy公司所开发，2006年五月由甲骨文公司并购。与传统的ISAM、MyISAM相比，&lt;strong&gt;InnoDB的最大特色就是支持ACID兼容的事务功能&lt;/strong&gt;，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。具体地，MyISAM与InnoDB作为MySQL的两大存储引擎的差异主要包括：&lt;/p&gt;
&lt;ul readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;存储结构&lt;/strong&gt;：每个MyISAM在磁盘上存储成三个文件：第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;存储空间&lt;/strong&gt;：MyISAM可被压缩，占据的存储空间较小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;可移植性、备份及恢复&lt;/strong&gt;：MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;事务支持&lt;/strong&gt;：MyISAM强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务、外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt;：在MyISAM中，可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，它可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引，并且引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;表锁差异&lt;/strong&gt;：MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;：MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;表主键&lt;/strong&gt;：MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;表的具体行数&lt;/strong&gt;：MyISAM保存表的总行数，select count() from table;会直接取出出该值；而InnoDB没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;CURD操作&lt;/strong&gt;：在MyISAM中，如果执行大量的SELECT，MyISAM是更好的选择。对于InnoDB，如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;外键&lt;/strong&gt;：MyISAM不支持外键，而InnoDB支持外键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁、外键等等。尤其在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，必须需要注意的是，任何一种表都不是万能的，合适的才是最好的，才能最大的发挥MySQL的性能优势。如果是不复杂的、非关键的Web应用，还是可以继续考虑MyISAM的，这个具体情况具体考虑。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;myiasm和innodb两种引擎所使用的索引的数据结构是什么&quot;&gt;14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？&lt;/h3&gt;
&lt;p&gt;答案:都是B+树!&lt;/p&gt;
&lt;p&gt;MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，&lt;strong&gt;只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Innodb引擎的索引的数据结构也是B+树，&lt;strong&gt;只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;varchar和char的区别&quot;&gt;15）varchar和char的区别&lt;/h3&gt;
&lt;p&gt;char是一种固定长度的类型，varchar是一种可变长度的类型，例如：&lt;/p&gt;
&lt;p&gt;定义一个char[10]和varchar[10]，如果存进去的是 'test'，那么char所占的长度依然为10，除了字符 'test' 外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的&lt;/p&gt;
&lt;p&gt;char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储于查找&lt;/p&gt;
&lt;p&gt;char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。&lt;/p&gt;
&lt;p&gt;varchar是以空间效率为首位。&lt;/p&gt;
&lt;p&gt;char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。&lt;/p&gt;
&lt;p&gt;varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。&lt;br/&gt;两者的存储数据都非unicode的字符数据。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;主键自增主键主键索引与唯一索引概念区别&quot;&gt;16）主键、自增主键、主键索引与唯一索引概念区别&lt;/h3&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;主键：指字段 &lt;strong&gt;唯一、不为空值&lt;/strong&gt; 的列；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自增主键：字段类型为数字、自增、并且是主键；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;唯一索引：索引列的值必须唯一，但允许有空值。&lt;strong&gt;主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;主键就是聚集索引吗主键和索引有什么区别&quot;&gt;17）主键就是聚集索引吗？主键和索引有什么区别？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。&lt;/strong&gt;在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;实践中如何优化mysql&quot;&gt;18）实践中如何优化MySQL&lt;/h3&gt;
&lt;p&gt;实践中，MySQL的优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7a6deca3ebd226e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;sql语句优化&quot;&gt;⑴ SQL语句优化：&lt;/h4&gt;
&lt;p&gt;SQL语句的优化主要包括三个问题，即如何发现有问题的SQL、如何分析SQL的执行计划以及如何优化SQL，下面将逐一解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。慢查询日志的相关参数如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-79123c126bb94a31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② 通过explain查询和分析SQL的执行计划：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ SQL语句的优化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⒈优化insert语句：一次插入多值；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⒉应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⒊应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⒋优化嵌套查询：子查询可以被更有效率的连接(Join)替代；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⒌很多时候用 exists 代替 in 是一个好的选择。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⒍选择最有效率的表名顺序：数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在FROM子句中包含多个表的情况下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推&lt;/li&gt;
&lt;li&gt;也就是说：选择记录条数最少的表放在最后&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有3个以上的表连接查询：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。&lt;/li&gt;
&lt;li&gt;也就是说：被其他表所引用的表放在最后&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;⒎用IN代替OR：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; emp &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; sal = &lt;span class=&quot;dv&quot;&gt;1500&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;or&lt;/span&gt; sal = &lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;or&lt;/span&gt; sal = &lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; emp &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; sal &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1500&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;⒏SELECT子句中避免使用*号：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们最开始接触 SQL 的时候，“&lt;code&gt;*&lt;/code&gt;” 号是可以获取表中全部的字段数据的，&lt;strong&gt;但是它要通过查询数据字典完成，这意味着将消耗更多的时间&lt;/strong&gt;，而且使用 “&lt;code&gt;*&lt;/code&gt;” 号写出来的 SQL 语句也不够直观。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;索引优化&quot;&gt;⑵ 索引优化：&lt;/h4&gt;
&lt;p&gt;建议在经常作查询选择的字段、经常作表连接的字段以及经常出现在 order by、group by、distinct 后面的字段中建立索引。但必须注意以下几种可能会引起索引失效的情形：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;以 “%(表示任意0个或多个字符)” 开头的 LIKE 语句，模糊匹配；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;OR语句前后没有同时使用索引；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于多列索引，必须满足最左匹配原则(eg,多列索引col1、col2和col3，则 索引生效的情形包括col1或col1，col2或col1，col2，col3)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;数据库表结构的优化&quot;&gt;⑶ 数据库表结构的优化：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;① 选择合适数据类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用较小的数据类型解决问题；&lt;/li&gt;
&lt;li&gt;使用简单的数据类型(mysql处理int要比varchar容易)；&lt;/li&gt;
&lt;li&gt;尽可能的使用not null 定义字段；&lt;/li&gt;
&lt;li&gt;尽量避免使用text类型，非用不可时最好考虑分表；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;② 表的范式的优化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，表的设计应该遵循三大范式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ 表的垂直拆分：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把不常用的字段单独放在同一个表中；&lt;/li&gt;
&lt;li&gt;把大字段独立放入一个表中；&lt;/li&gt;
&lt;li&gt;把经常使用的字段放在一起；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④ 表的水平拆分：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；&lt;/li&gt;
&lt;li&gt;针对不同的hashID将数据存入不同的表中；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；&lt;/li&gt;
&lt;li&gt;表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。&lt;/li&gt;
&lt;li&gt;需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;系统配置的优化&quot;&gt;⑷ 系统配置的优化：&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;操作系统配置的优化：增加TCP支持的队列数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;硬件的优化&quot;&gt;⑸ 硬件的优化：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;CPU：核心数多并且主频高的&lt;/li&gt;
&lt;li&gt;内存：增大内存&lt;/li&gt;
&lt;li&gt;磁盘配置和选择：磁盘性能&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;3.9633027522936&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 21 May 2018 06:54:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/9067197.html</dc:identifier>
</item>
<item>
<title>Scrapy爬虫框架第八讲【项目实战篇：知乎用户信息抓取】--本文参考静觅博主所写 - 疾风_lu</title>
<link>http://www.cnblogs.com/518894-lu/p/9061266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/518894-lu/p/9061266.html</guid>
<description>&lt;p&gt;&lt;span&gt;思路分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）选定起始人（即选择关注数和粉丝数较多的人--大V）&lt;/p&gt;
&lt;p&gt;（2）获取该大V的个人信息&lt;/p&gt;
&lt;p&gt;（3）获取关注列表用户信息&lt;/p&gt;
&lt;p&gt;（4）获取粉丝列表用户信息&lt;/p&gt;
&lt;p&gt;（5）重复（2）（3）（4）步实现全知乎用户爬取&lt;/p&gt;
&lt;p&gt; 实战演练：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）、创建项目：scrapy startproject zhijutest&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）、创建爬虫：cd zhihutest -----scrapy genspider  zhihu www.zhihu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）、选取起始人（这里我选择了以下用户）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520232323104-464426987.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到他关注的人和关注他的人，这些内容是我们（3）（4）步需要获取的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（3）、更改settings.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520231434179-1824361007.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;代码分析：这里我们设置了不遵守robots协议&lt;/p&gt;
&lt;p&gt;robots协议：网络爬虫协议，它用来告诉用户那些内容可以爬取，那些内容禁止爬取，一般我们运行爬虫项目，首先会访问网站的robots.txt页面，它告诉爬虫那些是你可以获取的内容，这里我们为了方便，即不遵守robots协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520231933733-1803062408.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码分析：这里我们设置了User-Agent和authorization字段（这是知乎对请求头的限制了，即反爬），而这里我们通过设置模拟了在没有登陆的前提下伪装成浏览器去请求知乎&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）、页面初步分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右击鼠标打开chrome开发者工具选项，并选中如下箭头所指，将鼠标放在黄色标记上，我们可以发现右侧加载出了一个ajax请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520233008667-513788819.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;单击该ajax请求，得到如下页面：我们可以看见黄色部分为每位用户的详细信息的url,它包含多个参数用来存储信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520233250440-1448538374.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时再将页面下滑可以看到如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520233456324-1995836777.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该字段为上面参数的字段详情（Query String Parameters，英文好的小伙伴应该一眼发现）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）、更改items.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;承接上面将页面点击左侧并翻页，可以看出右侧出现了新的Ajax请求：followees:......这就是他关注者信息，通过点击Preview我们获取了网页源代码，可以发现包含了每一页的用户信息，小伙伴们可以核对下，发现信息能匹配上，我们可以从中发现每页包含20条他的关注者信息，而黑框部分就是包含每一位用户详细信息的参数，我们通过它们来定义item.py(即爬什么？？？)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520234557808-1973867973.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改items.py如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180520235012084-1376782377.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）、更改zhihu.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：模块导入&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ..items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserItem
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZhihuSpider(scrapy.Spider):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhihu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     allowed_domains = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhihu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     start_urls = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://zhihu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设定起始爬取人，这里我们通过观察发现与url_token字段有关&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     start_user = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhouyuan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;选取起始爬取人的页面详情信息，这里我们传入了user和include参数方便对不同的用户进行爬取&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     user_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.zhihu.com/api/v4/members/{user}?include={include}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用户详情参数即包含在include后面的字段&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     user_query = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;allow_message,is_followed,is_following,is_org,is_blocking,employments,answer_count,follower_count,articles_count,gender,badge[?(type=best_answerer)].topics&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这是他的关注者的url,这里包含了每位他的关注者的url，同样我们传入了user和include参数方便对不同用户进行爬取&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     follows_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.zhihu.com/api/v4/members/{user}/followees?include={include}&amp;amp;offset={offset}&amp;amp;limit={limit}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;他的每位关注者详情参数，即包含在include后面的字段&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     follows_query = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;data[*].answer_count,articles_count,gender,follower_count,is_followed,is_following,badge[?(type=best_answerer)].topics&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这是他的粉丝的url,这里包含了每位他的关注者的url，同样我们传入了user和include参数方便对不同用户进行爬取&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     followers_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.zhihu.com/api/v4/members/{user}/followees?include={include}&amp;amp;offset={offset}&amp;amp;limit={limit}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;他的每位粉丝的详情参数，即包含在include后面的字段&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     followers_query = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;data[*].answer_count,articles_count,gender,follower_count,is_followed,is_following,badge[?(type=best_answerer)].topics&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;重新定义起始爬取点的url&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start_requests(self):
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里我们传入了将选定的大V的详情页面的url，并指定了解析函数parseUser&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; scrapy.Request(self.user_url.format(user=self.start_user, include=self.user_query), callback=&lt;span&gt;self.parseUser)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里我们传入了将选定的大V他的关注者的详情页面的url，并指定了解析函数parseFollows&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; scrapy.Request(self.follows_url.format(user=self.start_user, include=self.follows_query, offset=0, limit=20), callback=&lt;span&gt;self.parseFollows)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里我们传入了将选定的大V的粉丝的详情页面的url，并指定了解析函数parseFollowers&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; scrapy.Request(self.followers_url.format(user=self.start_user, include=self.followers_query, offset=0, limit=20), callback=&lt;span&gt;self.parseFollowers)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;爬取每一位用户详情的页面解析函数&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parseUser(self, response):
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里页面上是json字符串类型我们使用json.loads（）方法将其变为文本字符串格式&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         result =&lt;span&gt; json.loads(response.text)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         item =&lt;span&gt; UserItem()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里我们遍历了items.py中定义的字段并判断每位用户的详情页中的keys是否包含该字段，如包含则获取&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; field &lt;span&gt;in&lt;/span&gt;&lt;span&gt; item.fields:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; field &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result.keys():
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 item[field] =&lt;span&gt; result.get(field)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义回调函数，爬取他的关注者与粉丝的详细信息，实现层层迭代&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; scrapy.Request(self.follows_url.format(user=result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), include=self.follows_query, offset=0, limit=20), callback=&lt;span&gt;self.parseFollows)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; scrapy.Request(self.followers_url.format(user=result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), include=self.followers_query, offset=0, limit=20), callback=&lt;span&gt;self.parseFollowers)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;他的关注者的页面解析函数&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parseFollows(self, response):
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         results =&lt;span&gt; json.loads(response.text)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断data标签下是否含有获取的文本字段的keys&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results.keys():
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt; results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 &lt;span&gt;yield&lt;/span&gt; scrapy.Request(self.user_url.format(user=result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), include=self.user_query), callback=&lt;span&gt;self.parseUser)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断页面是否翻到了最后&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; results.keys() &lt;span&gt;and&lt;/span&gt; results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) ==&lt;span&gt; False:
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             next_page = results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; scrapy.Request(next_page, callback=&lt;span&gt;self.parseFollows)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;他的粉丝的页面解析函数&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parseFollowers(self, response):
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         results =&lt;span&gt; json.loads(response.text)
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results.keys():
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt; results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;                 &lt;span&gt;yield&lt;/span&gt; scrapy.Request(self.user_url.format(user=result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), include=self.user_query), callback=&lt;span&gt;self.parseUser)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; results.keys() &lt;span&gt;and&lt;/span&gt; results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)    ==&lt;span&gt; False:
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             next_page = results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; scrapy.Request(next_page, callback=self.parseFollowers)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180521105333294-676302256.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到当我们翻到了最后is_end字段变为了True,而next字段就是下一个页面的url&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）、运行下程序，可以看见已经在爬取了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180521141316939-887343782.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）、将结果存入Mongodb数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;重写pipelines.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymongo
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MongoPipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     collection_name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, mongo_uri, mongo_db):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.mongo_uri =&lt;span&gt; mongo_uri
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.mongo_db =&lt;span&gt; mongo_db
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @classmethod
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; from_crawler(cls, crawler):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cls(
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             mongo_uri=crawler.settings.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MONGO_URI&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             mongo_db=crawler.settings.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MONGO_DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self, spider):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         self.client =&lt;span&gt; pymongo.MongoClient(self.mongo_uri)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         self.db =&lt;span&gt; self.client[self.mongo_db]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self, spider):
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        self.client.close()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         self.db[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].update({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; :item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]},{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:item},True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;我们创建了名为user的集合&lt;/p&gt;
&lt;p&gt;重写了__init__方法指定了数据库的链接地址和数据库名称&lt;/p&gt;
&lt;p&gt;并修改了工厂类函数（具体参见上讲ITEM PIPLELIEN用法）&lt;/p&gt;
&lt;p&gt;打开数据库并插入数据并以url_token字段对重复数据执行了更新操作&lt;/p&gt;
&lt;p&gt;最后我们关闭了数据库&lt;/p&gt;
&lt;p&gt;再配置下settings.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180521142031655-1792918280.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180521142345239-670458745.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次运行程序，可以看见我们的数据就到了数据库了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180521142153226-1782848933.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 21 May 2018 06:26:00 +0000</pubDate>
<dc:creator>疾风_lu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/518894-lu/p/9061266.html</dc:identifier>
</item>
<item>
<title>String是值传递还是引用传递 - 牛初九</title>
<link>http://www.cnblogs.com/boboooo/p/9066831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boboooo/p/9066831.html</guid>
<description>&lt;h2 id=&quot;string是值传递还是引用传递&quot;&gt;String是值传递还是引用传递&lt;/h2&gt;
&lt;p&gt;今天上班时，同事发现了一个比较有意思的问题。他把一个String类型的参数传入方法，并在方法内改变了引用的值。 然后他在方法外使用这个值，发现这个String还是之前的值，并没有改变。&lt;/p&gt;
&lt;p&gt;这里要向大家介绍一下，大家都知道java在传参时分为值 &lt;strong&gt;传递&lt;/strong&gt; 和 &lt;strong&gt;引用传递&lt;/strong&gt; 。参数为基本类型时是值传递， 参数为封装类型时是引用传递。例如：&lt;/p&gt;
&lt;h4 id=&quot;基本类型参数&quot;&gt;基本类型参数&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Test {
    public static void main(String[] args) {
        int num = 0 ;
        changeNum(num);
        System.out.println(&quot;num=&quot;+num);
    }

    private static void changeNum(int num) {
        num = 1;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印的结果是&lt;code class=&quot;highlighter-rouge&quot;&gt;num=0&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;封装类型参数&quot;&gt;封装类型参数&lt;/h4&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Test {
    public static void main(String[] args) {
        Product p = new Product();
        p.setProName(&quot;before&quot;);
        p.setNum(0);
        changeProduct(p);
        System.out.println(&quot;p.proName=&quot;+p.getProName());
        System.out.println(&quot;p.num=&quot;+p.getNum());
    }

    private static void changeProduct(Product p) {
        p.setProName(&quot;after&quot;);
        p.setNum(1);
    }
}

class Product {
    private int num;
    private String proName;

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public String getProName() {
        return proName;
    }

    public void setProName(String proName) {
        this.proName = proName;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;运行的结果是：&lt;code class=&quot;highlighter-rouge&quot;&gt;p.proName=after&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;p.num=1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？我们看一下具体的例子：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Test {
    public static void main(String[] args) {
        String str = &quot;ab&quot;;
        changeString(str);
        System.out.println(&quot;str=&quot;+str);
    }

    private static void changeString(String str) {
        str = &quot;cd&quot;;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;大家猜一下运行结果是什么呢？按照前面的例子，String应该是一个封装类型，它应该是引用传递，是可以改变值得， 运行的结果应该是”cd”。我们实际运行一下看看，&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;str=ab&lt;/code&gt;,这如何解释呢？难道String是基本类型？也说不通呀。&lt;/p&gt;
&lt;p&gt;这就要从java底层的机制讲起了，java的内存模型分为 &lt;strong&gt;堆&lt;/strong&gt; 和 &lt;strong&gt;栈&lt;/strong&gt; 。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;1.基本类型的变量放在栈里；
2.封装类型中，对象放在堆里，对象的引用放在栈里。
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。&lt;/strong&gt; 这句话是很难理解的，也是解释这个 问题的精髓。我们先按照这句话解释一下基本类型的传递&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;虚拟机分配给num一个内存地址，并且存了一个值0.&lt;/li&gt;
&lt;li&gt;虚拟机复制了一个num，我们叫他num’，num’和num的内存地址不同，但存的值都是0。&lt;/li&gt;
&lt;li&gt;虚拟机讲num’传入方法，方法将num’的值改为1.&lt;/li&gt;
&lt;li&gt;方法结束，方法外打印num的值，由于num内存中的值没有改变，还是0，所以打印是0.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我们再解释封装类型的传递：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;虚拟机在堆中开辟了一个Product的内存空间，内存中包含proName和num。&lt;/li&gt;
&lt;li&gt;虚拟机在栈中分配给p一个内存地址，这个地址中存的是1中的Product的内存地址。&lt;/li&gt;
&lt;li&gt;虚拟机复制了一个p，我们叫他p’,p和p’的内存地址不同，但它们存的值是相同的，都是1中Product的内存地址。&lt;/li&gt;
&lt;li&gt;将p’传入方法，方法改变了1中的proName和num。&lt;/li&gt;
&lt;li&gt;方法结束，方法外打印p中变量的值，由于p和p’中存的都是1中Product的地址，但是1中Product里的值发生了改变， 所以，方法外打印p的值，是方法执行以后的。我们看到的效果是封装类型的值是改变的。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;最后我们再来解释String在传递过程中的步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;虚拟机在堆中开辟一块内存，并存值”ab”。&lt;/li&gt;
&lt;li&gt;虚拟机在栈中分配给str一个内存，内存中存的是1中的地址。&lt;/li&gt;
&lt;li&gt;虚拟机复制一份str，我们叫str’，str和str’内存不同，但存的值都是1的地址。&lt;/li&gt;
&lt;li&gt;将str’传入方法体&lt;/li&gt;
&lt;li&gt;方法体在堆中开辟一块内存，并存值”cd”&lt;/li&gt;
&lt;li&gt;方法体将str’的值改变，存入5的内存地址&lt;/li&gt;
&lt;li&gt;方法结束，方法外打印str，由于str存的是1的地址，所有打印结果是”ab”&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这样我们理解了java在方法传参的整个过程。其实还是上面那句比较重要的话 &lt;strong&gt;java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎访问我的个人博客 www.liubo-tech.cn &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 05:44:00 +0000</pubDate>
<dc:creator>牛初九</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boboooo/p/9066831.html</dc:identifier>
</item>
<item>
<title>ScalaPB（5）：用akka-stream实现reactive-gRPC - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/9066799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/9066799.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; 在前面几篇讨论里我们介绍了scala-gRPC的基本功能和使用方法，我们基本确定了选择gRPC作为一种有效的内部系统集成工具，主要因为下面gRPC支持的几种服务模式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;、Unary-Call：独立的一对client-request/server-&lt;span&gt;response，是我们常用的http交互模式

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、Server-&lt;span&gt;Streaming：client发出一个request后从server端接收一串多个response

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;、Client-&lt;span&gt;Streaming：client向server发送一串多个request后从server接收一个response

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;、Bidirectional-Streaming：由client首先发送request启动连接，然后在这个连接上两端可以不断交互信息。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;很明显，gRPC支持双向的streaming。那么如果能把gRPC中ListenableFuture和StreamObserver这两种类型转成akka-stream的基本类型应该就能够实现所谓的reactive-gRPC了。如果我们能用akka-stream编程方式实现gRPC服务调用的话，可能会遭遇下面的场景：在服务端我们只需要实现一种akka-stream的Flow把进来的request转化成出去的response，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Unary case&lt;/span&gt;
&lt;span&gt;Flow[Request].map(computeResponse)
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Server streaming&lt;/span&gt;
&lt;span&gt;Flow[Request].flatMapConcat(computeResponses)
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Client streaming&lt;/span&gt;
&lt;span&gt;Flow[Request].fold(defaultResponse)(computeResponse)
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bidirectional streaming&lt;/span&gt;
Flow[Request].flatMapConcat(computeResponses)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然，这是个akka-stream Flow，我们可以在这个Flow里调用任何akka-stream提供的功能，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;Flow[Request]
  .throttle(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;.millis, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, ThrottleMode.Shaping)
  .map(computeResponse)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在客户端我们可以直接经客户端stub调用Flow，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Source
  .single(request)
  .via(stub.doSomething)
  .runForeach(println)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;刚好，beyond-the-lines gRPCAkkaStream开源项目提供这么一种gRPC StreamObserver到aka-stream Flow转换桥梁。下面是gRPCAkkaStream的使用示范。先从Unary-Call开始：下面是.proto文件的IDL服务描述：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
package learn.grpc.akka.stream.services;
message NumPair {
   int32 num1 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
   int32 num2 &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
}
message Num {
   int32 num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
message SumResult {
   int32 result &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
service SumNumbers {
   rpc SumPair(NumPair) returns (SumResult) {}
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们看看编译后自动产生的SumGrpcAkkaStream.scala文件中一些相关类型和函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务界面描述：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;trait SumNumbers extends AbstractService {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def serviceCompanion =&lt;span&gt; SumNumbers
    def sumPair: Flow[learn.grpc.akka.stream.services.sum.NumPair, learn.grpc.akka.stream.services.sum.SumResult, NotUsed]
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们看到服务函数sumPair是一个akka-stream Fow[NumPair,SumResult,NotUsed]。下面是具体实现SumNumbers.sumPair代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; gRPCAkkaStreamService extends SumGrpcAkkaStream.SumNumbers {
  val logger: Logger &lt;/span&gt;=&lt;span&gt; Logger.getLogger(classOf[gRPCAkkaStreamService].getName)
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def sumPair: Flow[NumPair, SumResult, NotUsed] =&lt;span&gt; {
      logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** calling sumPair ...  ***&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      Flow[NumPair].map {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; NumPair(a,b) =&amp;gt;&lt;span&gt; {
          logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;serving ${a} + ${b} = ???&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          SumResult(a &lt;/span&gt;+&lt;span&gt; b)
        }
      }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;产生的客户端stub源代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SumNumbersStub(
    channel: Channel,
    options: CallOptions &lt;/span&gt;=&lt;span&gt; CallOptions.DEFAULT
  ) extends AbstractStub[SumNumbersStub](channel, options) with SumNumbers {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def sumPair: Flow[learn.grpc.akka.stream.services.sum.NumPair, learn.grpc.akka.stream.services.sum.SumResult, NotUsed] =&lt;span&gt;
      Flow[learn.grpc.akka.stream.services.sum.NumPair].flatMapConcat(request &lt;/span&gt;=&amp;gt;&lt;span&gt;
        Source.fromFuture(
          Grpc.guavaFuture2ScalaFuture(
            ClientCalls.futureUnaryCall(channel.newCall(METHOD_SUM_PAIR, options), request)
          )
        )
      )
  
 def stub(channel: Channel): SumNumbersStub &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SumNumbersStub(channel)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可以通过stub来调用sumPair方法，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  val channel =&lt;span&gt; ManagedChannelBuilder
      .forAddress(host,port)
      .usePlaintext(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
      .build()

  val stub &lt;/span&gt;=&lt;span&gt; SumGrpcAkkaStream.stub(channel)

  def addPair(num1: Int, num2: Int): Source[String,NotUsed] &lt;/span&gt;=&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to add $num1, $num2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source
      .single(NumPair(num1,num2))
      .via(stub.sumPair)
      .map(r &lt;/span&gt;=&amp;gt; s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the result: ${r.result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面是Unary-Call的具体调用方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; UnaryCallClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnaryClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.addPair(&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;&lt;span&gt;).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在Server-Streaming中一个request返回的是stream of responses。IDL的描述如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;service SumNumbers {
   rpc SumPair(NumPair) returns (SumResult) {}
   rpc GenIncsFrom(Num) returns (stream Num) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;编译后自动产生的service trait如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; trait SumNumbers extends AbstractService {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def serviceCompanion =&lt;span&gt; SumNumbers
    def sumPair: Flow[learn.grpc.akka.stream.services.sum.NumPair, learn.grpc.akka.stream.services.sum.SumResult, NotUsed]
    def genIncsFrom: Flow[learn.grpc.akka.stream.services.sum.Num, learn.grpc.akka.stream.services.sum.Num, NotUsed]
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个服务函数genIncsFrom是Flow[Num,Num,NotUsed]，它的具体实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; gRPCAkkaStreamService extends SumGrpcAkkaStream.SumNumbers {
  val logger: Logger &lt;/span&gt;=&lt;span&gt; Logger.getLogger(classOf[gRPCAkkaStreamService].getName)
  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def genIncsFrom: Flow[Num, Num, NotUsed] =&lt;span&gt; {
    logger.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** calling genIncsFrom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Flow[Num].mapConcat {
      n &lt;/span&gt;=&amp;gt; (&lt;span&gt;1&lt;/span&gt; to n.num).map {m =&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;genIncFrom producing num: ${m}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        Num(m)
      }
    }
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为输出response是一个stream，可以用mapConcat展平Seq来产生一个。在客户方调用服务函数genIncsFrom的方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def genIncNumbers(len: Int): Source[Int,NotUsed] =&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to produce ${len} inc numbers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source
      .single(Num(len))
      .via(stub.genIncsFrom)
      .map(n &lt;/span&gt;=&amp;gt;&lt;span&gt; n.num)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们还是用runForeach来运算这个Source：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ServerStreamingClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServerStreamingClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.genIncNumbers(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再来看看Client-Streaming是如何通过reactive-stream实现的。IDL服务描述如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;service SumNumbers {
   rpc SumPair(NumPair) returns (SumResult) {}
   rpc GenIncsFrom(Num) returns (stream Num) {}
   rpc SumStreamNums(stream Num) returns (SumResult) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;自动产生的service接口如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  trait SumNumbers extends AbstractService {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def serviceCompanion =&lt;span&gt; SumNumbers
    def sumPair: Flow[learn.grpc.akka.stream.services.sum.NumPair, learn.grpc.akka.stream.services.sum.SumResult, NotUsed]
    def genIncsFrom: Flow[learn.grpc.akka.stream.services.sum.Num, learn.grpc.akka.stream.services.sum.Num, NotUsed]
    def sumStreamNums: Flow[learn.grpc.akka.stream.services.sum.Num, learn.grpc.akka.stream.services.sum.SumResult, NotUsed]
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;sumStreamNums Flow实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;override&lt;/span&gt; def sumStreamNums: Flow[Num, SumResult, NotUsed] =&lt;span&gt; {
    logger.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** calling sumStreamNums&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Flow[Num].fold(SumResult(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (a, b) =&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receiving operand ${b.num}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        SumResult(b.num &lt;/span&gt;+&lt;span&gt; a.result)
    }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;request是一个stream，可以用aggregation来汇总成一个response。在客户端调用stub.sumStreamNums：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def sumManyNumbers(nums: Seq[Int]): Source[String,NotUsed] =&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to sum up ${nums}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source(nums.map(Num(_)).to[collection.immutable.Iterable])
      .via(stub.sumStreamNums)
      .map(r &lt;/span&gt;=&amp;gt; s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the result: ${r.result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ClientStreamingClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClientStreamingClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.sumManyNumbers(Seq(&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;&lt;span&gt;)).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后我们示范一下BiDirectional-Streaming。先用IDL定义一个流输入输出的服务函数keepAdding：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;service SumNumbers {
   rpc SumPair(NumPair) returns (SumResult) {}
   rpc GenIncsFrom(Num) returns (stream Num) {}
   rpc SumStreamNums(stream Num) returns (SumResult) {}
   rpc KeepAdding(stream Num) returns (stream SumResult) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个函数的实现代码： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;override&lt;/span&gt; def keepAdding: Flow[Num, SumResult, NotUsed] =&lt;span&gt; {
    Flow[Num].scan(SumResult(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (a,b) =&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receiving operand ${b.num}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        SumResult(b.num &lt;/span&gt;+&lt;span&gt; a.result)
    }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个服务函数的作用是把一串输入数字逐个相加并输出当前结果。我们可以用scan来实现这样的功能。下面是客户端调用服务的示范代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def ContSum(nums: Seq[Int]): Source[String,NotUsed] =&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to sum up ${nums}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source(nums.map(Num(_)).to[collection.immutable.Iterable])
      .throttle(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;.millis, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, ThrottleMode.shaping)
      .map { n &lt;/span&gt;=&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sending number: $n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        n
      }
      .via(stub.keepAdding)
      .map(r &lt;/span&gt;=&amp;gt; s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;current sum = ${r.result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用下面这段代码运算：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; BiDiStreamingClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BiDiStreamingClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.ContSum(Seq(&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;&lt;span&gt;)).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好，下面是本次讨论涉及的所有源代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;project/scalapb.sbt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;addSbtPlugin(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sbt-protoc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.99.18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

resolvers &lt;/span&gt;+= Resolver.bintrayRepo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beyondthelines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

libraryDependencies &lt;/span&gt;++=&lt;span&gt; Seq(
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet.scalapb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;compilerplugin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.7.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beyondthelines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grpcakkastreamgenerator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.0.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;build.sbt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import scalapb.compiler.Version.scalapbVersion
import scalapb.compiler.Version.grpcJavaVersion

name :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gRPCAkkaStreamDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

version :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

scalaVersion :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.12.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

resolvers &lt;/span&gt;+= Resolver.bintrayRepo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beyondthelines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

libraryDependencies &lt;/span&gt;++=&lt;span&gt; Seq(
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet.scalapb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scalapb-runtime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % scalapbVersion % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;protobuf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;io.grpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grpc-netty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; grpcJavaVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet.scalapb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scalapb-runtime-grpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; scalapbVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;io.monix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;monix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.3.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for GRPC Akkastream&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beyondthelines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grpcakkastreamruntime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.0.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

PB.targets &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; Compile :=&lt;span&gt; Seq(
  scalapb.gen() &lt;/span&gt;-&amp;gt; (sourceManaged &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Compile).value,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; generate the akka stream files&lt;/span&gt;
  grpc.akkastreams.generators.GrpcAkkaStreamGenerator() -&amp;gt; (sourceManaged &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Compile).value
)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;src/main/protobuf/sum.proto&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

package learn.grpc.akka.stream.services;


message NumPair {
   int32 num1 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
   int32 num2 &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
}

message Num {
   int32 num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

message SumResult {
   int32 result &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

service SumNumbers {
   rpc SumPair(NumPair) returns (SumResult) {}
   rpc GenIncsFrom(Num) returns (stream Num) {}
   rpc SumStreamNums(stream Num) returns (SumResult) {}
   rpc KeepAdding(stream Num) returns (stream SumResult) {}
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;src/main/scala/gRPCAkkaStreamService.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.akka.stream.services.impl

import akka.NotUsed
import akka.stream.scaladsl.Flow
import learn.grpc.akka.stream.services.sum._
import java.util.logging.Logger

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; gRPCAkkaStreamService extends SumGrpcAkkaStream.SumNumbers {
  val logger: Logger &lt;/span&gt;=&lt;span&gt; Logger.getLogger(classOf[gRPCAkkaStreamService].getName)

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def sumPair: Flow[NumPair, SumResult, NotUsed] =&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** calling sumPair ...  ***&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Flow[NumPair].map {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; NumPair(a, b) =&amp;gt;&lt;span&gt; {
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;serving ${a} + ${b} = ???&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        SumResult(a &lt;/span&gt;+&lt;span&gt; b)
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def genIncsFrom: Flow[Num, Num, NotUsed] =&lt;span&gt; {
    logger.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** calling genIncsFrom ... ***&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Flow[Num].mapConcat {
      n &lt;/span&gt;=&amp;gt;&lt;span&gt;
        (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; to n.num).map { m =&amp;gt;&lt;span&gt;
          logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;genIncFrom producing num: ${m}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          Num(m)
        }
    }
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def sumStreamNums: Flow[Num, SumResult, NotUsed] =&lt;span&gt; {
    logger.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** calling sumStreamNums ... ***&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Flow[Num].fold(SumResult(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (a, b) =&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receiving operand ${b.num}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        SumResult(b.num &lt;/span&gt;+&lt;span&gt; a.result)
    }
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def keepAdding: Flow[Num, SumResult, NotUsed] =&lt;span&gt; {
    Flow[Num].scan(SumResult(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (a,b) =&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receiving operand ${b.num}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        SumResult(b.num &lt;/span&gt;+&lt;span&gt; a.result)
    }
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;src/main/scala/gRPCAkkaStreamServer.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.akka.stream.server

import java.util.logging.Logger

import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import io.grpc.Server
import learn.grpc.akka.stream.services.impl.gRPCAkkaStreamService
import io.grpc.ServerBuilder
import learn.grpc.akka.stream.services.sum._
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; gRPCServer(server: Server) {

  val logger: Logger &lt;/span&gt;=&lt;span&gt; Logger.getLogger(classOf[gRPCServer].getName)

  def start(): Unit &lt;/span&gt;=&lt;span&gt; {
    server.start()
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server started, listening on ${server.getPort}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    sys.addShutdownHook {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use stderr here since the logger may has been reset by its JVM shutdown hook.&lt;/span&gt;
      System.err.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** shutting down gRPC server since JVM is shutting down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      stop()
      System.err.println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** server shut down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    ()
  }

  def stop(): Unit &lt;/span&gt;=&lt;span&gt; {
    server.shutdown()
  }

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
    * Await termination on the main thread since the grpc library uses daemon threads.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  def blockUntilShutdown(): Unit &lt;/span&gt;=&lt;span&gt; {
    server.awaitTermination()
  }
}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; DemoServer extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnaryServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)
  val server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; gRPCServer(
    ServerBuilder
      .forPort(&lt;/span&gt;&lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)
        .addService(
          SumGrpcAkkaStream.bindService(
           &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; gRPCAkkaStreamService
          )
      ).build()
  )
  server.start()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  UnaryServer.blockUntilShutdown()&lt;/span&gt;
&lt;span&gt;  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;src/main/scala/gRPCAkkaStreamClient.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.akka.stream.client
import learn.grpc.akka.stream.services.sum._
import java.util.logging.Logger

import akka.stream.scaladsl._
import akka.NotUsed
import akka.actor.ActorSystem
import akka.stream.{ActorMaterializer, ThrottleMode}
import scala.concurrent.duration._
import io.grpc._
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; gRPCAkkaStreamClient(host: String, port: Int) {
  val logger: Logger &lt;/span&gt;=&lt;span&gt; Logger.getLogger(classOf[gRPCAkkaStreamClient].getName)

  val channel &lt;/span&gt;=&lt;span&gt; ManagedChannelBuilder
      .forAddress(host,port)
      .usePlaintext(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
      .build()

  val stub &lt;/span&gt;=&lt;span&gt; SumGrpcAkkaStream.stub(channel)

  def addPair(num1: Int, num2: Int): Source[String,NotUsed] &lt;/span&gt;=&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to add $num1, $num2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source
      .single(NumPair(num1,num2))
      .via(stub.sumPair)
      .map(r &lt;/span&gt;=&amp;gt; s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the result: ${r.result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }
  def genIncNumbers(len: Int): Source[Int,NotUsed] &lt;/span&gt;=&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to produce ${len} inc numbers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source
      .single(Num(len))
      .via(stub.genIncsFrom)
      .map(n &lt;/span&gt;=&amp;gt;&lt;span&gt; n.num)
  }
  def sumManyNumbers(nums: Seq[Int]): Source[String,NotUsed] &lt;/span&gt;=&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to sum up ${nums}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source(nums.map(Num(_)).to[collection.immutable.Iterable])
      .throttle(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;.millis, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, ThrottleMode.shaping)
      .map { n &lt;/span&gt;=&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sending number: $n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        n
      }
      .via(stub.sumStreamNums)
      .map(r &lt;/span&gt;=&amp;gt; s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the result: ${r.result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
  def ContSum(nums: Seq[Int]): Source[String,NotUsed] &lt;/span&gt;=&lt;span&gt; {
    logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requesting to sum up ${nums}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    Source(nums.map(Num(_)).to[collection.immutable.Iterable])
      .throttle(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;.millis, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, ThrottleMode.shaping)
      .map { n &lt;/span&gt;=&amp;gt;&lt;span&gt;
        logger.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sending number: $n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        n
      }
      .via(stub.keepAdding)
      .map(r &lt;/span&gt;=&amp;gt; s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;current sum = ${r.result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }
}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; UnaryCallClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnaryClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.addPair(&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;&lt;span&gt;).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ServerStreamingClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServerStreamingClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.genIncNumbers(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ClientStreamingClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClientStreamingClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.sumManyNumbers(Seq(&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;&lt;span&gt;)).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; BiDiStreamingClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BiDiStreamingClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)

  val client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; gRPCAkkaStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

  client.ContSum(Seq(&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;&lt;span&gt;)).runForeach(println)

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 21 May 2018 05:41:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/9066799.html</dc:identifier>
</item>
<item>
<title>浅谈MySQL存储引擎-InnoDB&amp;MyISAM - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/9066686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/9066686.html</guid>
<description>&lt;p&gt;存储引擎在MySQL的逻辑架构中位于第三层，负责MySQL中的数据的存储和提取。MySQL存储引擎有很多，不同的存储引擎保存数据和索引的方式是不同的。每一种存储引擎都有它的优势和劣势，本文只讨论最常见的InnoDB和MyISAM两种存储引擎进行讨论。本文中关于数据存储形式和索引的可以查看&lt;a href=&quot;http://www.mycookies.cn/article.html?blogId=162&quot;&gt;图解MySQL索引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MySQL逻辑架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p34qzbztu.bkt.clouddn.com/201805211122_27.jpg?imageView1/JannLee/md/01&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;innodb存储引擎&quot;&gt;InnoDB存储引擎&lt;/h2&gt;
&lt;p&gt;InnoDB是默认的事务型存储引擎，也是最重要，使用最广泛的存储引擎。在没有特殊情况下，一般优先使用InnoDB存储引擎。&lt;/p&gt;
&lt;p&gt;1️⃣、数据存储形式&lt;/p&gt;
&lt;p&gt;使用InnoDB时，会将数据表分为.frm 和 idb两个文件进行存储。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p34qzbztu.bkt.clouddn.com/201805211134_341.jpg?imageView1/JannLee/md/01&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2️⃣、锁的粒度&lt;/p&gt;
&lt;p&gt;InnoDB采用&lt;strong&gt;MVCC(多版本并发控制)&lt;/strong&gt;来支持高并发，InnoDB实现了四个隔离级别，默认级别是REPETABLE READ，并通过间隙锁策略防止幻读的出现。它的锁粒度是行锁。【通过MVCC实现，MVCC在稍后会进行介绍】&lt;/p&gt;
&lt;p&gt;3️⃣、事务&lt;/p&gt;
&lt;p&gt;InnoDB是典型的事务型存储引擎，并且通过一些机制和工具，支持真正的热备份。&lt;/p&gt;
&lt;p&gt;4️⃣、数据的存储特点&lt;/p&gt;
&lt;p&gt;InnoDB表是基于聚簇索引(另一篇博客有介绍)建立的，聚簇索引对主键的查询有很高的性能，不过他的二级索引（非主键索引）必须包含主键列，索引其他的索引会很大。&lt;/p&gt;
&lt;h2 id=&quot;myisam存储引擎&quot;&gt;MyISAM存储引擎&lt;/h2&gt;
&lt;p&gt;1️⃣、数据存储形式&lt;/p&gt;
&lt;p&gt;MyISAM采用的是索引与数据分离的形式，将数据保存在三个文件中.frm.MYD,.MYIs。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p34qzbztu.bkt.clouddn.com/201805211156_65.jpg?imageView1/JannLee/md/01&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2️⃣、锁的粒度&lt;/p&gt;
&lt;p&gt;MyISAM不支持行锁，所以读取时对表加上共享锁，在写入是对表加上排他锁。由于是对整张表加锁，相比InnoDB，在并发写入时效率很低。&lt;/p&gt;
&lt;p&gt;3️⃣、事务&lt;/p&gt;
&lt;p&gt;MyISAM不支持事务。&lt;/p&gt;
&lt;p&gt;4️⃣、数据的存储特点&lt;/p&gt;
&lt;p&gt;MyISAM是基于非聚簇索引进行存储的。&lt;/p&gt;
&lt;p&gt;5️⃣、其他&lt;/p&gt;
&lt;p&gt;MyISAM提供了大量的特性，包括全文索引，压缩，空间函数，延迟更新索引键等。&lt;/p&gt;
&lt;p&gt;进行压缩后的表是不能进行修改的，但是压缩表可以极大减少磁盘占用空间，因此也可以减少磁盘IO，从而提供查询性能。&lt;/p&gt;
&lt;p&gt;全文索引，是一种基于分词创建的索引，可以支持复杂的查询。&lt;/p&gt;
&lt;p&gt;延迟更新索引键，不会将更新的索引数据立即写入到磁盘，而是会写到内存中的缓冲区中，只有在清除缓冲区时候才会将对应的索引写入磁盘，这种方式大大提升了写入性能。&lt;/p&gt;
&lt;h2 id=&quot;三对比与选择&quot;&gt;三、对比与选择&lt;/h2&gt;
&lt;p&gt;两种存储引擎各有各的有点，MyISAM专注性能，InnoDB专注事务。&lt;code&gt;两者最大的区别就是InnoDB支持事务，和行锁。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p34qzbztu.bkt.clouddn.com/201805211208_429.jpg?imageView1/JannLee/md/01&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何在两种存储引擎中进行选择？&lt;/p&gt;
&lt;p&gt;① 是否有事务操作？有，InnoDB。&lt;/p&gt;
&lt;p&gt;②是否存储并发修改？有，InnoDB。&lt;/p&gt;
&lt;p&gt;③是否追求快速查询，且数据修改较少？是，MyISAM。&lt;/p&gt;
&lt;p&gt;④是否使用全文索引？如果不引用第三方框架，可以选择MyISAM，但是可以选用第三方框架和InnDB效率会更高。&lt;/p&gt;
&lt;h2 id=&quot;四浅谈mvcc&quot;&gt;四、浅谈MVCC&lt;/h2&gt;
&lt;p&gt;MySQL大多数事务型存储引擎实现的都不是简单的行锁。基于提升并发性能的考虑，他们一般都同时实现了多版本并发控制(MVCC)。&lt;/p&gt;
&lt;p&gt;可以认为MVCC是行级锁的一个变种，它能在大多数情况下避免加锁操作，因此开销更低。无论怎样实现，它们大豆实现了非阻塞的读操作，写操作也只锁定制定的行。&lt;/p&gt;
&lt;p&gt;MVCC是通过保存数据在某一个时间点的快照来实现的，也就是说无论事务执行多久，每个事务看到的数据都是一致的。InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存了行的过期时间(或删除时间)，当然，并非存储的是时间，而是系统版本号。每开启一个事务，版本号都会递增，事务开始时刻的系统版本号会作为事务的版本号。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Mary&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Jann&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;以InnoDB存储引擎的的REPEATABLE READ隔离级别来说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELECT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ ①只查询创建时间版本号小于当前事务版本号的数据行（保证事务读取的行要么在事务开始之前就存在，要么是事务本身插入的行）&lt;/p&gt;
&lt;p&gt;​ ②行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行，在开始事务之前未被删除&lt;/p&gt;
&lt;p&gt;只有复合上诉两个条件的记录才会作为结果返回&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INSERT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 为插入的数据保存当前系统版本号作为行版本号&lt;/p&gt;
&lt;p&gt;DELETE&lt;/p&gt;
&lt;p&gt;​ 保存当前系统版本号作为删除行版本号&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 插入一行数据，并将当前系统版本号赋予行版本号；同事保存当前系统版本号到原来的行作为删除版本号。&lt;/p&gt;
&lt;p&gt;注：MVCC只在REPEATABLE和READ COMMITTED两个隔离级别下才能正常工作。&lt;br/&gt;我的个人博客：&lt;a href=&quot;http://www.cnblogs.com/liqiangchn/p/http：//www.mycookies.cn&quot;&gt;李强的个人博客(基于SSM，Nginx+Redis的后台架构)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 05:01:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiangchn/p/9066686.html</dc:identifier>
</item>
<item>
<title>springboot集成schedule（深度理解） - 名山丶深处</title>
<link>http://www.cnblogs.com/skychenjiajun/p/9057379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skychenjiajun/p/9057379.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; 在项目开发过程中，我们经常需要执行具有周期性的任务。通过定时任务可以很好的帮助我们实现。&lt;/p&gt;
&lt;p&gt;我们拿常用的几种定时任务框架做一个比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1308658/201805/1308658-20180521113144657-1784592945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从以上表格可以看出，Spring Schedule框架功能完善，简单易用。对于中小型项目需求，Spring Schedule是完全可以胜任的。&lt;/p&gt;


&lt;h3&gt;1、springboot集成schedule&lt;/h3&gt;
&lt;hr/&gt;&lt;h4&gt;1.1 添加maven依赖包&lt;/h4&gt;
&lt;p&gt;由于Spring Schedule包含在spring-boot-starter基础模块中了，所有不需要增加额外的依赖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;1.2 启动类，添加启动注解&lt;/h4&gt;
&lt;p&gt;在springboot入口或者配置类中增加@EnableScheduling注解即可启用定时任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@EnableScheduling
@SpringBootApplication
public class ScheduleApplication {
        public static void main(String[] args) {
                SpringApplication.run(ScheduleApplication.class, args);
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;1.3.添加定时任务&lt;/h4&gt;
&lt;p&gt;我们将对Spring Schedule三种任务调度器分别举例说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3.1 Cron表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于Linux下的Cron表达式时间定义规则。Cron表达式由6或7个空格分隔的时间字段组成，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1308658/201805/1308658-20180521113806328-1347594498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;常用表达式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1308658/201805/1308658-20180521114016301-1132085304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;添加一个work()方法，每10秒执行一次。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：当方法的执行时间超过任务调度频率时，调度器会在下个周期执行。&lt;/p&gt;
&lt;p&gt;如：假设work()方法在第0秒开始执行，方法执行了12秒，那么下一次执行work()方法的时间是第20秒。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Component
public class MyTask {
        @Scheduled(cron = &quot;0/10 * * * * *&quot;)
        public void work() {
                // task execution logic
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3.2 固定间隔任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 下一次的任务执行时间，是从方法最后一次任务执行结束时间开始计算。并以此规则开始周期性的执行任务。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;添加一个work()方法，每隔10秒执行一次。&lt;/p&gt;
&lt;p&gt;例如：假设work()方法在第0秒开始执行，方法执行了12秒，那么下一次执行work()方法的时间是第22秒。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Scheduled(fixedDelay = 1000*10)
public void work() {
        // task execution logic
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3.3 固定频率任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 按照指定频率执行任务，并以此规则开始周期性的执行调度。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;添加一个work()方法，每10秒执行一次。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：当方法的执行时间超过任务调度频率时，调度器会在当前方法执行完成后立即执行下次任务。&lt;/p&gt;
&lt;p&gt;例如：假设work()方法在第0秒开始执行，方法执行了12秒，那么下一次执行work()方法的时间是第12秒。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Scheduled(fixedRate = 1000*10)
public void work() {
        // task execution logic
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2、配置TaskScheduler线程池&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt; 在实际项目中，我们一个系统可能会定义多个定时任务。那么多个定时任务之间是可以相互独立且可以并行执行的。&lt;/p&gt;
&lt;p&gt;通过查看org.springframework.scheduling.config.ScheduledTaskRegistrar源代码，发现spring默认会创建一个单线程池。这样对于我们的多任务调度可能会是致命的，当多个任务并发（或需要在同一时间）执行时，任务调度器就会出现时间漂移，任务执行时间将不确定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
protected void scheduleTasks() {
        if (this.taskScheduler == null) {
                this.localExecutor = Executors.newSingleThreadScheduledExecutor();
                this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);
        }
        //省略...
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.1 自定义线程池&lt;/h4&gt;
&lt;p&gt;新增一个配置类，实现SchedulingConfigurer接口。重写configureTasks方法，通过taskRegistrar设置自定义线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Configuration
public class ScheduleConfig implements SchedulingConfigurer {
        @Override
        public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
                taskRegistrar.setScheduler(taskExecutor());
        }
        
        @Bean(destroyMethod=&quot;shutdown&quot;)
        public Executor taskExecutor() {
                return Executors.newScheduledThreadPool(20);
        }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3、实际应用中的问题&lt;/h3&gt;
&lt;hr/&gt;&lt;h4&gt; 3.1 Web应用中的启动和关闭问题&lt;/h4&gt;
&lt;p&gt;我们知道通过spring加载或初始化的Bean，在服务停止的时候，spring会自动卸载（销毁）。但是由于线程是JVM级别的，如果用户在Web应用中启动了一个线程，那么这个线程的生命周期并不会和Web应用保持一致。也就是说，即使Web应用停止了，这个线程依然没有结束（死亡）。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;1）当前对象是通过spring初始化&lt;/p&gt;
&lt;p&gt;spring在卸载（销毁）实例时，会调用实例的destroy方法。通过实现DisposableBean接口覆盖destroy方法实现。在destroy方法中主动关闭线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Component
public class MyTask implements DisposableBean{
        @Override
        public void destroy() throws Exception {
                //关闭线程或线程池
                ThreadPoolTaskScheduler scheduler = (ThreadPoolTaskScheduler)applicationContext.getBean(&quot;scheduler&quot;);
                scheduler.shutdown();
        }
        //省略...
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）当前对象不是通过spring初始化（管理）&lt;/p&gt;
&lt;p&gt;那么我们可以增加一个Servlet上下文监听器，在Servlet服务停止的时候主动关闭线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MyTaskListenter implements ServletContextListener{
        @Override
        public void contextDestroyed(ServletContextEvent arg0) {
                //关闭线程或线程池
        }
        //省略...
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3.2 分布式部署问题&lt;/h4&gt;
&lt;p&gt;在实际项目中，我们的系统通常会做集群、分布式或灾备部署。那么定时任务就可能出现并发问题，即同一个任务在多个服务器上同时在运行。&lt;/p&gt;
&lt;p&gt;解决方法（分布式锁）：&lt;/p&gt;
&lt;p&gt;1）通过数据库表锁&lt;/p&gt;
&lt;p&gt;2）通过缓存中间件&lt;/p&gt;
&lt;p&gt;3）通过Zookeeper实现&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;spring schedule给我们提供了一套简单、快速、高效、稳定的定时任务框架。但需要考虑线程的生命周期及分布式部署问题。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;如果您觉得这篇文章对您有帮助，还望您在右下角帮忙点个&lt;strong&gt;“推荐”&lt;/strong&gt;，博主感激不尽！&lt;/p&gt;

&lt;p&gt;我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2f0jbovt0mtcs&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 03:46:00 +0000</pubDate>
<dc:creator>名山丶深处</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skychenjiajun/p/9057379.html</dc:identifier>
</item>
<item>
<title>Java开源生鲜电商平台-售后模块的设计与架构(源码可下载） - 巨人大哥</title>
<link>http://www.cnblogs.com/jurendage/p/9066307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jurendage/p/9066307.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Java开源生鲜电商平台-售后模块的设计与架构(源码可下载）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：任何一个的电商平台都有售后服务系统，那么对于我们这个生鲜的电商平台，售后系统需要思考以下几个维度。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;          1. 买家的需求维度&lt;/p&gt;
&lt;p&gt;             说明：买家在平台上没找到自己想要的东西，我们需要提供给他一个入口，告诉我们他有这个需求，我们进行改进。系统需要有记录这种情况，同时也有回复客户的情况。&lt;/p&gt;
&lt;p&gt;          2. 投诉入口&lt;/p&gt;
&lt;p&gt;              说明：有客户性子比较急，他有问题，就会马上打电话给客服，客服需要解答与回答，维护客户关系。对于系统而言，需要记录这种情况，然后分析问题与解决问题。&lt;/p&gt;
&lt;p&gt;          3. IM聊天入口&lt;/p&gt;
&lt;p&gt;             说明：客户有时候也不想写信息，也不想打电话，能否有一个时刻的IM聊天记录呢？对于系统而言需要记录这种信息，我们目前系统没处理，采用的是微信，以及销售人员的反馈机制。&lt;/p&gt;
&lt;p&gt;          4. 退货问题&lt;/p&gt;
&lt;p&gt;              说明：售后系统中，退货问题是最繁琐的，买家存在以下两种情况。&lt;/p&gt;
&lt;p&gt;                      4.1 买家要钱不要货。顾名思义，有些买家就是不要货了，他需要我们退钱给他，这个配送端有一个一件退货功能，钱退到买家的余额里面，下次可以继续购买。&lt;/p&gt;
&lt;p&gt;                      4.2  买家要货不要钱，顾名思义，有些买家的确需要这个货物，对于我们退钱给他，他是不接受的，因为他真的需要这种东西，你让他再去买，客户体验非常差，可能 就没有下次购物了。对于这种情况，我们用时间轴来继续整个过程。（说明，由于这个系统设计到生鲜电商方面，其他的电商方面可能会不一样。）&lt;/p&gt;

&lt;p&gt;相关数据库的设计与架构如下：&lt;/p&gt;
&lt;p&gt; 1. 买家平台建议信息表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE TABLE `suggestion` (
  `id` bigint(&lt;/span&gt;20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自动增加ID'&lt;span&gt;,
  `suggestion_content` varchar(&lt;/span&gt;1024) DEFAULT NULL COMMENT '建议内容'&lt;span&gt;,
  `suggestion_imgs` varchar(&lt;/span&gt;255) DEFAULT NULL COMMENT '多张图片'&lt;span&gt;,
  `user_id` bigint(&lt;/span&gt;20) DEFAULT NULL COMMENT '所属用户ID'&lt;span&gt;,
  `create_time` datetime DEFAULT NULL COMMENT &lt;/span&gt;'创建时间'&lt;span&gt;,
  PRIMARY KEY (`id`)
) ENGINE&lt;/span&gt;=InnoDB AUTO_INCREMENT=78 DEFAULT CHARSET=utf8 COMMENT='用户对平台的建议';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明: 平台建议表，是买家对平台的建议以及自己的需求的一个入口，可以是图片与内容两点。&lt;/p&gt;
&lt;p&gt;          比如说：他说我们送的菜有问题，很多烂的，那么他是需要拍图片证明的。&lt;/p&gt;

&lt;p&gt;2. 平台回复信息表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE TABLE `suggestion_reply` (
  `id` bigint(&lt;/span&gt;20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自动增加ID'&lt;span&gt;,
  `suggestion_id` bigint(&lt;/span&gt;20) DEFAULT NULL COMMENT '客户的建议⁯ID'&lt;span&gt;,
  `content` varchar(&lt;/span&gt;512) DEFAULT NULL COMMENT '回复的内容'&lt;span&gt;,
  `create_time` datetime DEFAULT NULL COMMENT &lt;/span&gt;'创建时间'&lt;span&gt;,
  PRIMARY KEY (`id`)
) ENGINE&lt;/span&gt;=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8 COMMENT='客户建议回复信息表';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：作为一个平台，平台需要回复客户的信息，买家也需要看到，当然这边系统是不区分是买家还是卖家的，我们都是可以数据的处理的。&lt;/p&gt;

&lt;p&gt;3. 售后系统时间轴的设计&lt;/p&gt;
&lt;p&gt;说明：其实我们系统需要知道整个售后的过程的，比如买家什么时候发起的不要钱，要货，然后师傅是什么时候知道这个消息的，如何进行售后的，他们会遇到什么问题，&lt;/p&gt;
&lt;p&gt;当然这里面有很多的问题，系统可以做的事情其实是很少的，而我们需要做的是更多的事情。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE TABLE `order_timeline` (
  `id` bigint(&lt;/span&gt;20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自动增加ID'&lt;span&gt;,
  `item_id` bigint(&lt;/span&gt;20) DEFAULT NULL COMMENT '订单项ID'&lt;span&gt;,
  `remarks` varchar(&lt;/span&gt;256) DEFAULT NULL COMMENT '备注'&lt;span&gt;,
  `create_time` datetime DEFAULT NULL COMMENT &lt;/span&gt;'创建时间'&lt;span&gt;,
  PRIMARY KEY (`id`)
) ENGINE&lt;/span&gt;=InnoDB AUTO_INCREMENT=1980 DEFAULT CHARSET=utf8 COMMENT='售后模块，退换货时间轴，针对的是某一个订单项';
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;相关时间轴运营截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/641237/201805/641237-20180521111500103-1654435830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/641237/201805/641237-20180521111525161-1739718793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 整个业务不算复杂，需要的一种思路与解决思路的方案：&lt;/p&gt;
&lt;p&gt;关于补货流程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;补货需求
业务需求：
    当卖家主动点击缺货，则配送师傅看到这个异常订单项，然后他有两种选择，
第一种补货（有货，他也想补或者客户说要货不要钱）
第二种不补货（无货可补，他不想补或者客户说退钱等等）
第一种补货业务：
&lt;/span&gt;1&lt;span&gt;.    当配送师傅点击已补货，则把这个订单项对应的金额从买家中直接扣除，前提是线上付款，如果这个订单是线下付款，则不用处理扣款逻辑，直接修改状态即可。同时记录时间轴日志。
第二种不补货业务：
&lt;/span&gt;2&lt;span&gt;.    当师傅点击不补货，则这个订单项不做任何扣款逻辑，不管线下还是线上，直接修改状态即可，同时记录时间轴日志。
补充说明：补货与不补货属于互斥操作，即已补货后不允许再出现不补货，不补货后不再允许出现补货。按照规则来处理。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 相关业务核心代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 订单项退货&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@RequestMapping(&lt;/span&gt;&quot;/delivery&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderReturnController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseController {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(OrderReturnController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderItemService orderItemService;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderReturnService orderReturnService;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 订单项退货
     * 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(value &lt;/span&gt;= &quot;/order/return/item&quot;, method =&lt;span&gt; { RequestMethod.GET, RequestMethod.POST })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonResult orderReturnItem(HttpServletRequest request, HttpServletResponse response,
            @Param(&lt;/span&gt;&quot;itemId&quot;) Long itemId, @Param(&quot;deliveryId&quot;) Long deliveryId, @Param(&quot;status&quot;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (itemId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(JsonResultCode.FAILURE, &quot;item参数有误&quot;, &quot;&quot;&lt;span&gt;);
            }

            OrderItem orderItem &lt;/span&gt;=&lt;span&gt; orderItemService.getOrderItemByItemId(itemId);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (orderItem == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(JsonResultCode.FAILURE, &quot;无此订单项&quot;, &quot;&quot;&lt;span&gt;);
            }
            
            String returnMsg &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(status ==&lt;span&gt; BuyerStatus.THREE){
                returnMsg &lt;/span&gt;=&lt;span&gt; TimelineTemplate.return_MSG;
            }&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(status ==&lt;span&gt; BuyerStatus.FOUR){
                returnMsg &lt;/span&gt;=&lt;span&gt; TimelineTemplate.BACK_MSG;
            }&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(status ==&lt;span&gt; BuyerStatus.ZERO){
                returnMsg &lt;/span&gt;=&lt;span&gt; TimelineTemplate.OFF_MSG;
            }
            orderItemService.updateOrderItemStatus(itemId, status, deliveryId, returnMsg);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(JsonResultCode.SUCCESS, &quot;操作成功&quot;, &quot;&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            logger.error(&lt;/span&gt;&quot;[OrderReturnController][orderReturnItem] exception :&quot;&lt;span&gt;, ex);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(JsonResultCode.FAILURE, &quot;系统错误,请稍后重试&quot;, &quot;&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 退还列表
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(value &lt;/span&gt;= &quot;/order/return/list&quot;, method =&lt;span&gt; { RequestMethod.GET, RequestMethod.POST })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JsonResult orderReturnList(HttpServletRequest request, HttpServletResponse response,@Param(&quot;deliveryId&quot;) Long deliveryId, @Param(&quot;status&quot;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; 
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组装成为最终的列表结果&lt;/span&gt;
            List&amp;lt;OrderReturnVo&amp;gt; listResult = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OrderReturnVo&amp;gt;&lt;span&gt;();

            List&lt;/span&gt;&amp;lt;OrderGoodsVo&amp;gt; goodsList =&lt;span&gt; orderReturnService.getReturnOrderGoodsList(deliveryId,status);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(goodsList)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(JsonResultCode.SUCCESS, &quot;查询完成&quot;&lt;span&gt;, listResult);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 临时参数，判断时间&lt;/span&gt;
            Map&amp;lt;String, List&amp;lt;OrderReturnEntity&amp;gt;&amp;gt; paramTimeMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, List&amp;lt;OrderReturnEntity&amp;gt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤卖家&lt;/span&gt;
            Map&amp;lt;String, List&amp;lt;OrderGoodsVo&amp;gt;&amp;gt; paramSellerMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, List&amp;lt;OrderGoodsVo&amp;gt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (OrderGoodsVo vo : goodsList) {
                String bestTime &lt;/span&gt;= DateUtil.dateToString(vo.getBestTime(), &quot;yyyy-MM-dd&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间相同&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (paramTimeMap.get(bestTime) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    List&lt;/span&gt;&amp;lt;OrderReturnEntity&amp;gt; mapOrderReturnEntity =&lt;span&gt; paramTimeMap.get(bestTime);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组装时间&lt;/span&gt;
                    OrderReturnVo resultVo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderReturnVo();
                    resultVo.setBestTime(bestTime);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否是同一个卖家的&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (paramSellerMap.get(vo.getSellerName()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
                    {
                        OrderReturnEntity entity &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderReturnEntity();
                        List&lt;/span&gt;&amp;lt;OrderGoodsVo&amp;gt; listVo =&lt;span&gt; paramSellerMap.get(vo.getSellerName());
                        listVo.add(vo);
                        entity.setListOrderGoodsVo(listVo);
                        resultVo.setListOrderReturnEntity(mapOrderReturnEntity);
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不同买家&lt;/span&gt;
                        OrderReturnEntity entity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderReturnEntity();
                        entity.setSellerName(vo.getSellerName());
                        
                        List&lt;/span&gt;&amp;lt;OrderGoodsVo&amp;gt; listVo =&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OrderGoodsVo&amp;gt;&lt;span&gt;();
                        listVo.add(vo);
                        entity.setListOrderGoodsVo(listVo);
                        mapOrderReturnEntity.add(entity);
                        
                        paramSellerMap.put(vo.getSellerName(), listVo);
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组装时间&lt;/span&gt;
                    OrderReturnVo resultVo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderReturnVo();
                    resultVo.setBestTime(bestTime);

                    OrderReturnEntity entity &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderReturnEntity();
                    entity.setSellerName(vo.getSellerName());

                    List&lt;/span&gt;&amp;lt;OrderGoodsVo&amp;gt; paramOrderGoodsVo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OrderGoodsVo&amp;gt;&lt;span&gt;();
                    paramOrderGoodsVo.add(vo);
                    entity.setListOrderGoodsVo(paramOrderGoodsVo);

                    List&lt;/span&gt;&amp;lt;OrderReturnEntity&amp;gt; listOrderReturnEntity = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OrderReturnEntity&amp;gt;&lt;span&gt;();
                    listOrderReturnEntity.add(entity);

                    resultVo.setListOrderReturnEntity(listOrderReturnEntity);

                    listResult.add(resultVo);

                    paramSellerMap.put(vo.getSellerName(), paramOrderGoodsVo);

                    paramTimeMap.put(bestTime, listOrderReturnEntity);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(JsonResultCode.SUCCESS, &quot;查询信息成功&quot;&lt;span&gt;, listResult);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            logger.error(&lt;/span&gt;&quot;[OrderReturnController][orderReturnItem] exception :&quot;&lt;span&gt;, ex);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(JsonResultCode.FAILURE, &quot;系统错误,请稍后重试&quot;, &quot;&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;APP运营截图相对而言比较简单，我这边就不贴出来了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java开源生鲜电商平台-售后模块的设计与架构(源码可下载），如果需要下载的话，可以在我的github下面进行下载。&lt;/strong&gt; &lt;/p&gt;




</description>
<pubDate>Mon, 21 May 2018 03:22:00 +0000</pubDate>
<dc:creator>巨人大哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jurendage/p/9066307.html</dc:identifier>
</item>
<item>
<title>数字签名和数字证书 - MicroHeart！</title>
<link>http://www.cnblogs.com/MicroHeart/p/9057189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MicroHeart/p/9057189.html</guid>
<description>&lt;p&gt;理解数字签名和数字证书前需要了解非对称加密。&lt;/p&gt;
&lt;h2&gt;加密算法&lt;/h2&gt;
&lt;p&gt;加密算法分为：对称加密和非对称加密。&lt;/p&gt;
&lt;h3&gt;1、对称加密&lt;/h3&gt;
&lt;p&gt;对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。&lt;/p&gt;
&lt;p&gt;常见的对称加密算法有：DES算法、3DES算法。&lt;/p&gt;
&lt;h3&gt;2、非对称加密&lt;/h3&gt;
&lt;p&gt;非对称加密算法有两个密钥：公钥和私钥。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。&lt;/p&gt;
&lt;p&gt;例：小A和小B都生成一对公私密钥，想在他俩将公钥通过网络发给对方(注意：因为这两个公钥都是在网络上传播，可能会被C获取)，A跟B通信，A将原文用B给的公钥进行加密生成密文，这段密文只能用B的私钥解密，所以即使C获取密文和A/B的公钥也不能解密。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;数字签名（Digital Signature）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/794803/201805/794803-20180518173641553-600392375.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上图为A和B的通信过程。前提是 A和B都以获取对方的公钥&lt;/p&gt;
&lt;p&gt;A将原文加工生成发送内容：&lt;/p&gt;
&lt;p&gt;1、A用哈希算法（如MD5）计算要发送内容的Hash值(摘要)。&lt;/p&gt;
&lt;p&gt;2、用非对称加密算法（如RSA算法）加密摘要，生成数字签名。&lt;/p&gt;
&lt;p&gt;3、将原文加数字签名作为发送内容。&lt;/p&gt;
&lt;p&gt;B收到数据，进行解密验证内容：&lt;/p&gt;
&lt;p&gt;1、首先对原文进行同样的哈希计算，算出原文的Hash值（摘要1）。&lt;/p&gt;
&lt;p&gt;2、用A的公钥解密签名，得到摘要2。&lt;/p&gt;
&lt;p&gt;3、比对两个摘要是否相等。如果不相等，证明原文或者签名被修改过。&lt;/p&gt;
&lt;p&gt;为什么要通过哈希算法计算发送内容的Hash值？就是防止在发送过程中，内容被修改，如果内容被修改，那么修改后的内容的Hash值就不是之前的了。这时你可能会问，那在传输过程中如果同时修改内容，并将对应的Hash值也修改了，不就行了。这里要注意的是：Hash值已经被A用私钥加密了，就算你计算出修改后内容的Hash值，但是没法用A的私钥加密得到数字签名。&lt;/p&gt;
&lt;p&gt;但是这里有一个Bug：C也有自己的公钥私钥，如果C替换了B手中A的公钥，然后C用自己的私钥给B发送数据，这个时候B是不知道他收到的数据时来自C。为了解决这个问题就出现了证书&lt;/p&gt;
&lt;h2&gt;数字证书(Digital Certificate)&lt;/h2&gt;
&lt;p&gt;数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证。颁发证书机构它也有一对公钥和私钥。证书机构用它的私钥将 A的公钥 和 一些A的信息 加密得到数字证书。然后A发送数据给B时，包含了三个部分：原文+数字签名+数字证书  ，&lt;span&gt;注意，现在B不持有A的公钥，B持有的是证书机构的公钥&lt;/span&gt;，通过证书机构的公钥解密数字证书拿到A的公钥，然后在重复之前的过程计算数字签名，跟发来的数字签名比对。但是有同样的一个问题：如果B现在持有的证书机构的公钥被别人替换呢？&lt;span&gt;这个过程是建立在被大家所认可的证书机构之上得到的公钥，所以这是一种安全的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 03:11:00 +0000</pubDate>
<dc:creator>MicroHeart！</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MicroHeart/p/9057189.html</dc:identifier>
</item>
<item>
<title>工厂模式理解了没有？ - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/9066166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/9066166.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回顾前面：&lt;/p&gt;
&lt;p&gt;昨天写了单例模式了，今天是时候写工厂模式啦~&lt;/p&gt;
&lt;p&gt;工厂模式我&lt;strong&gt;个人认为其实比较难理解的&lt;/strong&gt;，如果有接触过|听过|见过该模式的同学很可能就会想：我自己&lt;code&gt;new&lt;/code&gt;一个对象出来就好了，简单快捷。用得着你这个工厂模式吗？搞一个工厂出来还要写一大堆的代码呢~&lt;/p&gt;
&lt;p&gt;网上的很多资料都是在阐述着：工厂模式的好处就是&lt;strong&gt;解耦&lt;/strong&gt;。相信大家对&lt;strong&gt;解耦&lt;/strong&gt;这个词也不陌生，那解耦究竟有什么好处呢？&lt;/p&gt;
&lt;p&gt;本文章&lt;strong&gt;试图去解释&lt;/strong&gt;为什么要用工厂模式，用了工厂模式的好处是什么，以及工厂模式衍生出的三种形式究竟有什么区别~~&lt;/p&gt;
&lt;p&gt;那么接下来就开始吧，如果有错的地方希望能多多包涵，并不吝在评论区指正！&lt;/p&gt;

&lt;p&gt;在《设计模式之禅》这本书中分了两章节讲工厂模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工厂方法模式
&lt;ul&gt;&lt;li&gt;(ps：其中里面讲到了简单工厂模式)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;抽象工厂模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;网上的大部分资料都是将工厂模式分成&lt;strong&gt;三&lt;/strong&gt;种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单/静态工厂模式&lt;/li&gt;
&lt;li&gt;工厂方法模式&lt;/li&gt;
&lt;li&gt;抽象工厂模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看完上面的叙述是不是想打死我，什么鸟玩意？不急哈，下面我会一一讲到~~&lt;/p&gt;
&lt;h2 id=&quot;为什么要用工厂模式&quot;&gt;1.1为什么要用工厂模式？&lt;/h2&gt;
&lt;p&gt;想想我们为什么要用工厂模式？下面我就简单举例子：&lt;/p&gt;
&lt;p&gt;文件IO的操作我们会经常用得到吧，所以BufferedReader对象&lt;strong&gt;经常要创建&lt;/strong&gt;的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;// 创建一个BufferedReader对象&lt;/span&gt;
    BufferedReader bf = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;st&quot;&gt;&quot;aa.txt&quot;&lt;/span&gt;)));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你说麻烦吗？其实也不麻烦，就一行代码嘛，哪里麻烦了~如果不太熟悉IO流的同学就没有那么机灵了，创建一个BufferedReader可能就是以下的代码了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        File file = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;st&quot;&gt;&quot;aa.txt&quot;&lt;/span&gt;);
        FileReader fileReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(file);
        BufferedReader bufferedReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(fileReader);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你说麻烦吗？其实也不麻烦，不就是三行代码嘛，哪里麻烦了~如果这个应用&lt;strong&gt;很多的类上都用到了&lt;/strong&gt;BufferedReader对象的话，那每个类都写上这三行代码了。那你说麻烦吗？那肯定麻烦啊，还用想啊....&lt;/p&gt;
&lt;p&gt;可以看出来，创建一个BufferReader对象里面需要一个FileReader对象，而FileReader对象又要File对象。那&lt;strong&gt;创建这个BufferReader对象还是比较麻烦的&lt;/strong&gt;(代码上看不麻烦，从构造上看还是挺麻烦的)！&lt;/p&gt;
&lt;p&gt;虽然比较麻烦，但我们还能用，能用就行！于是乎，我们就去写代码了，现在有三个类都要进行文件的读写操作，于是他们就有这样的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FileOperateA {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; FileNotFoundException {
        File file = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;st&quot;&gt;&quot;aa.txt&quot;&lt;/span&gt;);
        FileReader fileReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(file);
        BufferedReader bufferedReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(fileReader);


        &lt;span class=&quot;co&quot;&gt;// 读写文件....&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090cf493123d?w=574&amp;amp;h=115&amp;amp;f=png&amp;amp;s=5445&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时：上头说，我要&lt;strong&gt;换成LineNumberReader来读写&lt;/strong&gt;，有这个需求！那我们作为一个写代码的，能怎么办？很绝望也需要去完成呀。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不熟悉IDE的小伙子就一个一个将BufferedReader改成LineNumberReader，现在就3个类用到了BufferedReader，也就改6次而已。(ps:那如果很多地方都用到了呢？)&lt;/li&gt;
&lt;li&gt;熟悉IDE的小伙子就全局替换重构，妥妥的！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;哎，写个代码屁事真多...那有没有一种方法能够让&lt;strong&gt;创建对象变得简单&lt;/strong&gt;而且&lt;strong&gt;修改对象时能很方便&lt;/strong&gt;呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哎，工厂模式就行了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再说从&lt;strong&gt;面向对象的角度来看&lt;/strong&gt;：我一个操作文件的类还要我会创建BufferReader是不是有点过分了？(职责没有分工好)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;交给工厂来创建对象这就很面向对象了！&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;体验工厂模式&quot;&gt;1.2体验工厂模式&lt;/h2&gt;
&lt;p&gt;何为工厂？将我们的产品都交由工厂来生产！我现在用的iphone5s，从哪来？从富士康组装而来，富士康是工厂。我用得着知道iphone5s在富士康是怎么组装起来的吗？不需要。&lt;/p&gt;
&lt;p&gt;来，我们来改造一下上面的例子。首先我们创建一个工厂类，它可以&lt;strong&gt;生产Reader对象&lt;/strong&gt;！&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// 创建Reader对象的工厂&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ReaderFactory {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Reader &lt;span class=&quot;fu&quot;&gt;getReader&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; FileNotFoundException {
        File file = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;st&quot;&gt;&quot;aa.txt&quot;&lt;/span&gt;);
        FileReader fileReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(file);
        BufferedReader reader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(fileReader);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; reader;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们要得到BufferReader对象就&lt;strong&gt;贼简单&lt;/strong&gt;了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FileOperateA {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; FileNotFoundException {


        &lt;span class=&quot;co&quot;&gt;//-------我有工厂了，还用自己搞吗？不用了！&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//File file = new File(&quot;aa.txt&quot;);&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//FileReader fileReader = new FileReader(file);&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//BufferedReader bufferedReader = new BufferedReader(fileReader);&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//-------我有工厂了，还用自己搞吗？不用了！&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;// 用工厂来创建出对象&lt;/span&gt;
        Reader reader = ReaderFactory.&lt;span class=&quot;fu&quot;&gt;getReader&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 读写文件....&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工厂将我们&lt;strong&gt;创建的对象过程给屏蔽了&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;此时我要改成LineNumberReader怎么玩？在&lt;strong&gt;工厂上改一下&lt;/strong&gt;就好了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090cf4a7d90a?w=1042&amp;amp;h=286&amp;amp;f=png&amp;amp;s=10249&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的调用方&lt;code&gt;FileOperateA|FileOperateB|FileOperateC&lt;/code&gt;这些类完全就不用变！&lt;/p&gt;
&lt;h2 id=&quot;使用工厂方法的好处&quot;&gt;1.3使用工厂方法的好处&lt;/h2&gt;
&lt;p&gt;从上面的工厂模式体验我们就可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们修改了具体的实现类，对客户端(调用方)而言是&lt;strong&gt;完全不用修改的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果我们使用&lt;code&gt;new&lt;/code&gt;的方式来创建对象的话，那么我们就说：&lt;code&gt;new&lt;/code&gt;出来的这个对象和当前客户端(调用方)&lt;strong&gt;耦合&lt;/strong&gt;了！
&lt;ul&gt;&lt;li&gt;也就是，当前客户端(调用方)&lt;strong&gt;依赖着&lt;/strong&gt;这个&lt;code&gt;new&lt;/code&gt;出来的对象！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这就是解耦的好处&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;我再放下我之前练习的时候写过的代码吧：&lt;/p&gt;
&lt;p&gt;我有一个DaoFactory，逻辑很简单就是&lt;strong&gt;专门创建Dao对象&lt;/strong&gt;的~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090cf5dc37b4?w=1001&amp;amp;h=492&amp;amp;f=png&amp;amp;s=14451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么在Service层就可以&lt;strong&gt;使用工厂将想要的Dao对象初始化了&lt;/strong&gt;~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090cf64a92c8?w=1292&amp;amp;h=377&amp;amp;f=png&amp;amp;s=24248&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们的Service与Dao的对象&lt;strong&gt;低耦合&lt;/strong&gt;的~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大家&lt;strong&gt;可能看不出有什么好处&lt;/strong&gt;，还弄了一大堆的字符串啥的~~&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Service与Controller层我也弄了一个ServiceFactory，根据当时业务的需要(添加权限)，我&lt;strong&gt;创建Service时就非常灵活&lt;/strong&gt;了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/cAJjcQk.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在一开始我就说了，工厂模式可以分成三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单/静态工厂模式&lt;/li&gt;
&lt;li&gt;工厂方法模式&lt;/li&gt;
&lt;li&gt;抽象工厂模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我就逐一来介绍一下每一种工厂模式有什么不一样~&lt;/p&gt;
&lt;p&gt;三种模式都以：&lt;strong&gt;Java3y要买宠物的例子来讲解&lt;/strong&gt;~&lt;/p&gt;
&lt;h2 id=&quot;工厂方法模式&quot;&gt;2.1工厂方法模式&lt;/h2&gt;
&lt;p&gt;很多博客都是以简单/静态工厂模式，工厂方法模式，抽象工厂模式这个顺序来讲解工厂模式的。我认为按书上的顺序比较好理解~因为简单/静态工厂模式是在工厂方法模式上&lt;strong&gt;缩减&lt;/strong&gt;，抽象工厂模式是在工厂方法模式上再&lt;strong&gt;增强&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所以我就先讲工厂方法模式了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java3y每天写代码很无聊，想要买只宠物来陪陪自己。于是乎就&lt;strong&gt;去宠物店看宠物啦&lt;/strong&gt;~~~&lt;/p&gt;
&lt;p&gt;作为一间宠物店，号称什么宠物都有！于是乎，店主宣传的时候就说：我的宠物店&lt;strong&gt;什么宠物都有&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;于是构建宠物的工厂就诞生了~&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// 号称什么宠物都有&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; AnimalFactory {

    &lt;span class=&quot;co&quot;&gt;// 可以获取任何的宠物&lt;/span&gt;
    Animal &lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，主流的宠物得进货一些先放在店里充充门面，一些特殊的宠物就告诉顾客要时间进货~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所以，我们就有了构建猫和狗的工厂(继承着所有宠物的工厂)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;猫工厂：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// 继承着宠物工厂&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CatFactory &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; AnimalFactory {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 创建猫&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Animal &lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Cat&lt;/span&gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;狗工厂也是一样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// 继承着宠物工厂&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DogFactory &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; AnimalFactory {

    &lt;span class=&quot;co&quot;&gt;// 创建狗&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Animal &lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Dog&lt;/span&gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，还有我们的实体类：猫、狗、动物(多态：猫和狗都是动物，可以直接用动物来表示了)&lt;/p&gt;
&lt;p&gt;动物实体类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Animal {

    &lt;span class=&quot;co&quot;&gt;// 所有的动物都会吃东西&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;猫实体类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Cat &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Animal {
    
    &lt;span class=&quot;co&quot;&gt;// 猫喜欢吃鱼&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;猫吃鱼&quot;&lt;/span&gt;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;狗实体类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Dog &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Animal {

    &lt;span class=&quot;co&quot;&gt;// 狗喜欢吃肉&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;狗吃肉&quot;&lt;/span&gt;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么现在Java3y想要一只狗，跟了宠物店老板说，宠物店老板就去找狗回来了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;// 去找狗工厂拿一只狗过来&lt;/span&gt;
    AnimalFactory f = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DogFactory&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 店主就拿到了一只狗给Java3y&lt;/span&gt;
    Animal a = f.&lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;();
    a.&lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;关注公众号：Java3y&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么现在Java3y想要一只猫，跟了宠物店老板说，宠物店老板就去找猫回来了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;// 去找猫工厂拿一只猫过来&lt;/span&gt;
    AnimalFactory ff = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CatFactory&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 店主就拿到了一只猫给Java3y&lt;/span&gt;
    Animal aa = ff.&lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;();
    aa.&lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;关注公众号：Java3y&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这个时候Java3y说想要一只蜥蜴怎么办啊？没问题啊，店主&lt;strong&gt;搞个蜥蜴工厂&lt;/strong&gt;就好了~~&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;// 要买蜥蜴..&lt;/span&gt;
        AnimalFactory fff = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LizardFactory&lt;/span&gt;();
        Animal aaa = ff.&lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;();
        aaa.&lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1:客户端不需要在负责对象的创建,&lt;strong&gt;明确了各个类的职责&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;2:如果有&lt;strong&gt;新的对象增加&lt;/strong&gt;,只需要&lt;strong&gt;增加一个具体的类和具体的工厂类&lt;/strong&gt;即可&lt;/li&gt;
&lt;li&gt;3:&lt;strong&gt;不会影响已有的代码&lt;/strong&gt;,后期维护容易,增强系统的扩展性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1:需要额外的编写代码,增加了工作量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;工厂方法类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090cf6b8b892?w=1080&amp;amp;h=1440&amp;amp;f=jpeg&amp;amp;s=111034&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单静态工厂模式&quot;&gt;2.2简单/静态工厂模式&lt;/h2&gt;
&lt;p&gt;现在宠物店生意不好做啊，号称“什么宠物都有&quot;,这吹过头了~~于是店主&lt;strong&gt;只卖两种常见的宠物&lt;/strong&gt;了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;既然就只有两种宠物的话，那就没必要有”猫厂“、”狗厂“了，一个猫狗厂就行了！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们的工厂是这样子的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AnimalFactory {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Dog &lt;span class=&quot;fu&quot;&gt;createDog&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Dog&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Cat &lt;span class=&quot;fu&quot;&gt;createCat&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Cat&lt;/span&gt;();
    }


    &lt;span class=&quot;co&quot;&gt;// 外界想要猫要狗，这里创建就好了&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Animal &lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;(String type) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;dog&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(type)) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Dog&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;cat&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(type)) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Cat&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三个实体还是没变(动物、猫、狗)....&lt;/p&gt;
&lt;p&gt;那么Java3y去宠物店买猫狗的时候，告诉老板我要猫、我要狗：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;// 拿到狗&lt;/span&gt;
        Animal A = AnimalFactory.&lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;dog&quot;&lt;/span&gt;);
        A.&lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 拿到猫&lt;/span&gt;
        Animal C = AnimalFactory.&lt;span class=&quot;fu&quot;&gt;createAnimal&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;cat&quot;&lt;/span&gt;);
        C.&lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在问题来了:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1:我想要一个猪,&lt;strong&gt;可是我的工厂类没有猪&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;2:我就去&lt;strong&gt;改&lt;/strong&gt;代码,写可以创建猪对象的&lt;/li&gt;
&lt;li&gt;3:接着,我又要其他的动物&lt;/li&gt;
&lt;li&gt;4:我还是得&lt;strong&gt;改&lt;/strong&gt;代码&lt;/li&gt;
&lt;li&gt;5...................&lt;/li&gt;
&lt;li&gt;6:这就是简单工厂类的缺点：&lt;strong&gt;当需求改变了,我就要改代码&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单工厂类的优点也很明显：我&lt;strong&gt;就一个具体的工厂来创建对象&lt;/strong&gt;，代码量少。&lt;/p&gt;
&lt;h2 id=&quot;抽象工厂模式&quot;&gt;2.3抽象工厂模式&lt;/h2&gt;
&lt;p&gt;抽象工厂模式就比较复杂了，我们&lt;strong&gt;一般的应用都写不到&lt;/strong&gt;。我首先来简述一下需求吧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现在非常流行在猫狗届也吹起了一股“性别风”
&lt;ul&gt;&lt;li&gt;有的喜欢公的&lt;/li&gt;
&lt;li&gt;有的喜欢母的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那我们的猫和狗都是有性别的，不是公的就是母的~~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们之前在工厂方法模式下是每个动物都开一个工厂，如果动物过多的话，那么就有很多的工厂~&lt;/li&gt;
&lt;li&gt;那现在我们可以&lt;strong&gt;抽取出来&lt;/strong&gt;：每个动物不是公的就是母的~&lt;/li&gt;
&lt;li&gt;所以我们有两个工厂就足够了！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的代码是这样的：&lt;/p&gt;
&lt;p&gt;我们的最大工厂还是定义了创建什么动物&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; AnimalFactory {
    Animal &lt;span class=&quot;fu&quot;&gt;createDog&lt;/span&gt;();
    Animal &lt;span class=&quot;fu&quot;&gt;createCat&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建母猫和母狗的工厂：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FemaleAnimalFactory &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; AnimalFactory {

    &lt;span class=&quot;co&quot;&gt;// 生产母狗和母猫&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Animal &lt;span class=&quot;fu&quot;&gt;createDog&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;FemaleDog&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Animal &lt;span class=&quot;fu&quot;&gt;createCat&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;FemaleCat&lt;/span&gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建公猫和公狗的工厂：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MaleAnimalFactory &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; AnimalFactory {
    
    &lt;span class=&quot;co&quot;&gt;// 生产公狗和公猫&lt;/span&gt;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Animal &lt;span class=&quot;fu&quot;&gt;createDog&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MaleDog&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Animal &lt;span class=&quot;fu&quot;&gt;createCat&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MaleCat&lt;/span&gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是&lt;strong&gt;所有动物都拥有的普遍行为&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Animal {

    &lt;span class=&quot;co&quot;&gt;// 所有的动物都会吃东西&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 所有的动物都有性别&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;gender&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是猫都拥有的普遍行为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Cat &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Animal {
    &lt;span class=&quot;co&quot;&gt;// 猫喜欢吃鱼&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;猫吃鱼&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是狗都拥有的普遍行为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Dog &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Animal {

    &lt;span class=&quot;co&quot;&gt;// 狗喜欢吃肉&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;eat&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;狗吃肉&quot;&lt;/span&gt;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;猫分为公猫、母猫。狗分为公狗和母狗：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FemaleCat &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Cat {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;gender&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;I am a female Cat&quot;&lt;/span&gt;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.....&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090d44e32dc1?w=420&amp;amp;h=187&amp;amp;f=png&amp;amp;s=8687&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说：工厂方法模式的工厂是创建出&lt;strong&gt;一种&lt;/strong&gt;产品，而抽象工厂是创建出&lt;strong&gt;一类&lt;/strong&gt;产品。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一类的产品我们称之为&lt;strong&gt;产品族&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;猫是一类的，狗也是一类的。所以AnimalFactory定义了两类产品---&amp;gt;&lt;code&gt;Animal createDog();&lt;/code&gt;和&lt;code&gt;Animal createCat();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;产品的&lt;strong&gt;继承结构&lt;/strong&gt;称之为&lt;strong&gt;产品等级&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;所有的动物都是会吃东西的，它们都是有性别的，这是最普遍的。所以Animal定义了两个抽象方法：&lt;code&gt;public abstract void eat();&lt;/code&gt;和&lt;code&gt;public abstract void gender();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有的狗都是会吃肉的，所以Dog实现了&lt;code&gt;eat()&lt;/code&gt;方法
&lt;ul&gt;&lt;li&gt;狗又分成了公狗和母狗，所以定义了两个类FemaleDog和MaleDog继承了Dog，实现了&lt;code&gt;gender()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;所有的猫都是会吃鱼的，所以Cat实现了&lt;code&gt;eat()&lt;/code&gt;方法
&lt;ul&gt;&lt;li&gt;猫又分成了公猫和母猫，所以定义了两个类FemaleCat和MaleCat继承了Cat，实现了&lt;code&gt;gender()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;具体的工厂是&lt;strong&gt;面向多个产品等级结构进行生产&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;所以FemaleAnimalFactory定义了&lt;code&gt;createDog()&lt;/code&gt;和&lt;code&gt;createCat()&lt;/code&gt;生产母狗和母猫&lt;/li&gt;
&lt;li&gt;所以MaleAnimalFactory定义了&lt;code&gt;createDog()&lt;/code&gt;和&lt;code&gt;createCat()&lt;/code&gt;生产公狗和共猫&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;找到母工厂就可以创建母猫和母狗，找到公工厂就可以创建公猫和公狗&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090d765ba6b8?w=861&amp;amp;h=290&amp;amp;f=png&amp;amp;s=22027&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {


        &lt;span class=&quot;co&quot;&gt;// 需要性别为母的就去找母工厂&lt;/span&gt;
        AnimalFactory af = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;FemaleAnimalFactory&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 需要一只母猫&lt;/span&gt;
        af.&lt;span class=&quot;fu&quot;&gt;createCat&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;gender&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 需要一只母狗&lt;/span&gt;
        af.&lt;span class=&quot;fu&quot;&gt;createDog&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;gender&lt;/span&gt;();

        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-------------关注公众号：Java3y-------------------------&quot;&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;// 需要性别为公的就去找公工厂&lt;/span&gt;
        AnimalFactory aff = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MaleAnimalFactory&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 需要一只公狗&lt;/span&gt;
        aff.&lt;span class=&quot;fu&quot;&gt;createDog&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;gender&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 需要一只公猫&lt;/span&gt;
        aff.&lt;span class=&quot;fu&quot;&gt;createCat&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;gender&lt;/span&gt;();

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/rFNalCZ.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是抽象工厂模式的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/21/1638090d9e0ba1cc?w=2448&amp;amp;h=3264&amp;amp;f=jpeg&amp;amp;s=380492&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象工厂模式说到底就是&lt;strong&gt;多了一层抽象，减少了工厂的数量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;抽象工厂缺点也很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;难以&lt;strong&gt;扩展产品族&lt;/strong&gt;---&amp;gt;如果我再要宠物猪的话
&lt;ul&gt;&lt;li&gt;那我要修改AnimalFactory、FemaleAnimalFactory、MaleAnimalFactory这些类了~&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说我们&lt;strong&gt;用简单工厂模式比较多&lt;/strong&gt;，工厂方式模式的话代码量会比较大，抽象工厂模式的话需要业务比较大的情况下才会用到(如果有更好的理解方式不妨在评论区留言，一起交流交流涨涨见识~~)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工厂模式配合反射来使用也是极好的~&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;。为了大家方便，刚新建了一下&lt;strong&gt;qq群：742919422&lt;/strong&gt;，大家也可以去交流交流。谢谢支持了！希望能多介绍给其他有需要的朋友&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章的目录导航&lt;/strong&gt;：&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 02:58:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/9066166.html</dc:identifier>
</item>
</channel>
</rss>