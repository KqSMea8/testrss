<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【原创】分布式之延时任务方案解析 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/8972725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/8972725.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在开发中，往往会遇到一些关于延时任务的需求。例如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成订单30分钟未支付，则自动取消&lt;/li&gt;
&lt;li&gt;生成订单60秒后,给用户发短信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对上述的任务，我们给一个专业的名字来形容，那就是&lt;span&gt;&lt;strong&gt;延时任务&lt;/strong&gt;&lt;/span&gt;。那么这里就会产生一个问题，这个&lt;span&gt;&lt;strong&gt;延时任务&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;定时任务&lt;/strong&gt;&lt;/span&gt;的区别究竟在哪里呢？一共有如下几点区别&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定时任务有明确的触发时间，延时任务没有&lt;/li&gt;
&lt;li&gt;定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期&lt;/li&gt;
&lt;li&gt;定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面，我们以判断订单是否超时为例，进行方案分析&lt;/p&gt;
&lt;h2 id=&quot;方案分析&quot;&gt;方案分析&lt;/h2&gt;
&lt;h3 id=&quot;数据库轮询&quot;&gt;(1)数据库轮询&lt;/h3&gt;
&lt;h4 id=&quot;思路&quot;&gt;思路&lt;/h4&gt;
&lt;p&gt;该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作&lt;/p&gt;
&lt;h4 id=&quot;实现&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;博主当年早期是用&lt;span&gt;quartz&lt;/span&gt;来实现的(实习那会的事)，简单介绍一下&lt;br/&gt;maven项目引入一个依赖如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;quartz&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用Demo类MyJob如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.delay1;

import org.quartz.JobBuilder;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.SimpleScheduleBuilder;
import org.quartz.Trigger;
import org.quartz.TriggerBuilder;
import org.quartz.impl.StdSchedulerFactory;
import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

public class MyJob implements Job {
    public void execute(JobExecutionContext context)
            throws JobExecutionException {
        System.out.println(&quot;要去数据库扫描啦。。。&quot;);
    }

    public static void main(String[] args) throws Exception {
        // 创建任务
        JobDetail jobDetail = JobBuilder.newJob(MyJob.class)
                .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();
        // 创建触发器 每3秒钟执行一次
        Trigger trigger = TriggerBuilder
                .newTrigger()
                .withIdentity(&quot;trigger1&quot;, &quot;group3&quot;)
                .withSchedule(
                        SimpleScheduleBuilder.simpleSchedule()
                                .withIntervalInSeconds(3).repeatForever())
                .build();
        Scheduler scheduler = new StdSchedulerFactory().getScheduler();
        // 将任务及其触发器放入调度器
        scheduler.scheduleJob(jobDetail, trigger);
        // 调度器开始调度任务
        scheduler.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码，可发现每隔3秒，输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;要去数据库扫描啦。。。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;优缺点&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;优点:简单易行，支持集群操作&lt;br/&gt;缺点:(1)对服务器内存消耗大&lt;br/&gt;   (2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟&lt;br/&gt;   (3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大&lt;/p&gt;
&lt;h3 id=&quot;jdk的延迟队列&quot;&gt;(2)JDK的延迟队列&lt;/h3&gt;
&lt;h4 id=&quot;思路-1&quot;&gt;思路&lt;/h4&gt;
&lt;p&gt;该方案是利用JDK自带的&lt;span&gt;DelayQueue&lt;/span&gt;来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入&lt;span&gt;DelayQueue&lt;/span&gt;中的对象，是必须实现&lt;span&gt;Delayed&lt;/span&gt;接口的。&lt;br/&gt;&lt;span&gt;DelayedQueue&lt;/span&gt;实现工作流程如下图所示&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_flowdelay.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;其中Poll():获取并移除队列的超时元素，没有则返回空&lt;br/&gt;  take():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。
&lt;h4 id=&quot;实现-1&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;定义一个类OrderDelay实现Delayed，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.delay2;

import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;

public class OrderDelay implements Delayed {
    
    private String orderId;
    private long timeout;

    OrderDelay(String orderId, long timeout) {
        this.orderId = orderId;
        this.timeout = timeout + System.nanoTime();
    }

    public int compareTo(Delayed other) {
        if (other == this)
            return 0;
        OrderDelay t = (OrderDelay) other;
        long d = (getDelay(TimeUnit.NANOSECONDS) - t
                .getDelay(TimeUnit.NANOSECONDS));
        return (d == 0) ? 0 : ((d &amp;lt; 0) ? -1 : 1);
    }

    // 返回距离你自定义的超时时间还有多少
    public long getDelay(TimeUnit unit) {
        return unit.convert(timeout - System.nanoTime(), TimeUnit.NANOSECONDS);
    }

    void print() {
        System.out.println(orderId+&quot;编号的订单要删除啦。。。。&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的测试Demo为，我们设定延迟时间为3秒&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.delay2;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.TimeUnit;

public class DelayQueueDemo {
     public static void main(String[] args) {  
            // TODO Auto-generated method stub  
            List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();  
            list.add(&quot;00000001&quot;);  
            list.add(&quot;00000002&quot;);  
            list.add(&quot;00000003&quot;);  
            list.add(&quot;00000004&quot;);  
            list.add(&quot;00000005&quot;);  
            DelayQueue&amp;lt;OrderDelay&amp;gt; queue = new DelayQueue&amp;lt;OrderDelay&amp;gt;();  
            long start = System.currentTimeMillis();  
            for(int i = 0;i&amp;lt;5;i++){  
                //延迟三秒取出
                queue.put(new OrderDelay(list.get(i),  
                        TimeUnit.NANOSECONDS.convert(3, TimeUnit.SECONDS)));  
                    try {  
                         queue.take().print();  
                         System.out.println(&quot;After &quot; +   
                                 (System.currentTimeMillis()-start) + &quot; MilliSeconds&quot;);  
                } catch (InterruptedException e) {  
                    // TODO Auto-generated catch block  
                    e.printStackTrace();  
                }  
            }  
        }  
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;00000001编号的订单要删除啦。。。。
After 3003 MilliSeconds
00000002编号的订单要删除啦。。。。
After 6006 MilliSeconds
00000003编号的订单要删除啦。。。。
After 9006 MilliSeconds
00000004编号的订单要删除啦。。。。
After 12008 MilliSeconds
00000005编号的订单要删除啦。。。。
After 15009 MilliSeconds&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到都是延迟3秒，订单被删除&lt;/p&gt;
&lt;h4 id=&quot;优缺点-1&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;优点:效率高,任务触发时间延迟低。&lt;br/&gt;缺点:(1)服务器重启后，数据全部消失，怕宕机&lt;br/&gt;   (2)集群扩展相当麻烦&lt;br/&gt;   (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常&lt;br/&gt;   (4)代码复杂度较高&lt;/p&gt;
&lt;h3 id=&quot;时间轮算法&quot;&gt;(3)时间轮算法&lt;/h3&gt;
&lt;h4 id=&quot;思路-2&quot;&gt;思路&lt;/h4&gt;
&lt;p&gt;先上一张时间轮的图(这图到处都是啦)&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_timewheel.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的tick数），tickDuration（一个tick的持续时间）以及 timeUnit（时间单位），例如当ticksPerWheel=60，tickDuration=1，timeUnit=秒，这就和现实中的始终的秒针走动完全类似了。
&lt;p&gt;如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）&lt;/p&gt;
&lt;h4 id=&quot;实现-2&quot;&gt;实现&lt;/h4&gt;
&lt;p&gt;我们用Netty的HashedWheelTimer来实现&lt;br/&gt;给Pom加上下面的依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.24.Final&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码HashedWheelTimerTest如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.delay3;

import io.netty.util.HashedWheelTimer;
import io.netty.util.Timeout;
import io.netty.util.Timer;
import io.netty.util.TimerTask;

import java.util.concurrent.TimeUnit;

public class HashedWheelTimerTest {
    static class MyTimerTask implements TimerTask{
        boolean flag;
        public MyTimerTask(boolean flag){
            this.flag = flag;
        }
        public void run(Timeout timeout) throws Exception {
            // TODO Auto-generated method stub
             System.out.println(&quot;要去数据库删除订单了。。。。&quot;);
             this.flag =false;
        }
    }
    public static void main(String[] argv) {
        MyTimerTask timerTask = new MyTimerTask(true);
        Timer timer = new HashedWheelTimer();
        timer.newTimeout(timerTask, 5, TimeUnit.SECONDS);
        int i = 1;
        while(timerTask.flag){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            System.out.println(i+&quot;秒过去了&quot;);
            i++;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1秒过去了
2秒过去了
3秒过去了
4秒过去了
5秒过去了
要去数据库删除订单了。。。。
6秒过去了&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;优缺点-2&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;优点:效率高,任务触发时间延迟时间比delayQueue低，代码复杂度比delayQueue低。&lt;br/&gt;缺点:(1)服务器重启后，数据全部消失，怕宕机&lt;br/&gt;   (2)集群扩展相当麻烦&lt;br/&gt;   (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常&lt;/p&gt;
&lt;h3 id=&quot;redis缓存&quot;&gt;(4)redis缓存&lt;/h3&gt;
&lt;h4 id=&quot;思路一&quot;&gt;思路一&lt;/h4&gt;
&lt;p&gt;利用redis的zset,zset是一个有序集合，每一个元素(member)都关联了一个score,通过score排序来取集合中的值&lt;br/&gt;&lt;a href=&quot;http://redisdoc.com/sorted_set/&quot;&gt;zset常用命令&lt;/a&gt;&lt;br/&gt;添加元素:&lt;strong&gt;ZADD key score member [[score member] [score member] ...]&lt;/strong&gt;&lt;br/&gt;按顺序查询元素:&lt;strong&gt;ZRANGE key start stop [WITHSCORES]&lt;/strong&gt;&lt;br/&gt;查询元素score:&lt;strong&gt;ZSCORE key member&lt;/strong&gt;&lt;br/&gt;移除元素:&lt;strong&gt;ZREM key member [member ...]&lt;/strong&gt;&lt;br/&gt;测试如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 添加单个元素

redis&amp;gt; ZADD page_rank 10 google.com
(integer) 1


# 添加多个元素

redis&amp;gt; ZADD page_rank 9 baidu.com 8 bing.com
(integer) 2

redis&amp;gt; ZRANGE page_rank 0 -1 WITHSCORES
1) &quot;bing.com&quot;
2) &quot;8&quot;
3) &quot;baidu.com&quot;
4) &quot;9&quot;
5) &quot;google.com&quot;
6) &quot;10&quot;

# 查询元素的score值
redis&amp;gt; ZSCORE page_rank bing.com
&quot;8&quot;

# 移除单个元素

redis&amp;gt; ZREM page_rank google.com
(integer) 1

redis&amp;gt; ZRANGE page_rank 0 -1 WITHSCORES
1) &quot;bing.com&quot;
2) &quot;8&quot;
3) &quot;baidu.com&quot;
4) &quot;9&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何实现呢？我们将订单超时时间戳与订单号分别设置为score和member,系统扫描第一个元素判断是否超时，具体如下图所示&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_redisflow.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;h4 id=&quot;实现一&quot;&gt;实现一&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.delay4;

import java.util.Calendar;
import java.util.Set;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.Tuple;

public class AppTest {
    private static final String ADDR = &quot;127.0.0.1&quot;;
    private static final int PORT = 6379;
    private static JedisPool jedisPool = new JedisPool(ADDR, PORT);
    
    public static Jedis getJedis() {
       return jedisPool.getResource();
    }
    
    //生产者,生成5个订单放进去
    public void productionDelayMessage(){
        for(int i=0;i&amp;lt;5;i++){
            //延迟3秒
            Calendar cal1 = Calendar.getInstance();
            cal1.add(Calendar.SECOND, 3);
            int second3later = (int) (cal1.getTimeInMillis() / 1000);
            AppTest.getJedis().zadd(&quot;OrderId&quot;, second3later,&quot;OID0000001&quot;+i);
            System.out.println(System.currentTimeMillis()+&quot;ms:redis生成了一个订单任务：订单ID为&quot;+&quot;OID0000001&quot;+i);
        }
    }
    
    //消费者，取订单
    public void consumerDelayMessage(){
        Jedis jedis = AppTest.getJedis();
        while(true){
            Set&amp;lt;Tuple&amp;gt; items = jedis.zrangeWithScores(&quot;OrderId&quot;, 0, 1);
            if(items == null || items.isEmpty()){
                System.out.println(&quot;当前没有等待的任务&quot;);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                continue;
            }
            int  score = (int) ((Tuple)items.toArray()[0]).getScore();
            Calendar cal = Calendar.getInstance();
            int nowSecond = (int) (cal.getTimeInMillis() / 1000);
            if(nowSecond &amp;gt;= score){
                String orderId = ((Tuple)items.toArray()[0]).getElement();
                jedis.zrem(&quot;OrderId&quot;, orderId);
                System.out.println(System.currentTimeMillis() +&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;+orderId);
            }
        }
    }
    
    public static void main(String[] args) {
        AppTest appTest =new AppTest();
        appTest.productionDelayMessage();
        appTest.consumerDelayMessage();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时对应输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1525086085261ms:redis生成了一个订单任务：订单ID为OID00000010
1525086085263ms:redis生成了一个订单任务：订单ID为OID00000011
1525086085266ms:redis生成了一个订单任务：订单ID为OID00000012
1525086085268ms:redis生成了一个订单任务：订单ID为OID00000013
1525086085270ms:redis生成了一个订单任务：订单ID为OID00000014
1525086088000ms:redis消费了一个任务：消费的订单OrderId为OID00000010
1525086088001ms:redis消费了一个任务：消费的订单OrderId为OID00000011
1525086088002ms:redis消费了一个任务：消费的订单OrderId为OID00000012
1525086088003ms:redis消费了一个任务：消费的订单OrderId为OID00000013
1525086088004ms:redis消费了一个任务：消费的订单OrderId为OID00000014
当前没有等待的任务
当前没有等待的任务
当前没有等待的任务&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，几乎都是3秒之后，消费订单。&lt;/p&gt;
&lt;p&gt;然而，这一版存在一个致命的硬伤，在高并发条件下，多消费者会取到同一个订单号，我们上测试代码ThreadTest&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.delay4;

import java.util.concurrent.CountDownLatch;

public class ThreadTest {
    private static final int threadNum = 10;
    private static CountDownLatch cdl = new CountDownLatch(threadNum);
    static class DelayMessage implements Runnable{
        public void run() {
            try {
                cdl.await();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            AppTest appTest =new AppTest();
            appTest.consumerDelayMessage();
        }
    }
    public static void main(String[] args) {
        AppTest appTest =new AppTest();
        appTest.productionDelayMessage();
        for(int i=0;i&amp;lt;threadNum;i++){
            new Thread(new DelayMessage()).start();
            cdl.countDown();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1525087157727ms:redis生成了一个订单任务：订单ID为OID00000010
1525087157734ms:redis生成了一个订单任务：订单ID为OID00000011
1525087157738ms:redis生成了一个订单任务：订单ID为OID00000012
1525087157747ms:redis生成了一个订单任务：订单ID为OID00000013
1525087157753ms:redis生成了一个订单任务：订单ID为OID00000014
1525087160009ms:redis消费了一个任务：消费的订单OrderId为OID00000010
1525087160011ms:redis消费了一个任务：消费的订单OrderId为OID00000010
1525087160012ms:redis消费了一个任务：消费的订单OrderId为OID00000010
1525087160022ms:redis消费了一个任务：消费的订单OrderId为OID00000011
1525087160023ms:redis消费了一个任务：消费的订单OrderId为OID00000011
1525087160029ms:redis消费了一个任务：消费的订单OrderId为OID00000011
1525087160038ms:redis消费了一个任务：消费的订单OrderId为OID00000012
1525087160045ms:redis消费了一个任务：消费的订单OrderId为OID00000012
1525087160048ms:redis消费了一个任务：消费的订单OrderId为OID00000012
1525087160053ms:redis消费了一个任务：消费的订单OrderId为OID00000013
1525087160064ms:redis消费了一个任务：消费的订单OrderId为OID00000013
1525087160065ms:redis消费了一个任务：消费的订单OrderId为OID00000014
1525087160069ms:redis消费了一个任务：消费的订单OrderId为OID00000014
当前没有等待的任务
当前没有等待的任务
当前没有等待的任务
当前没有等待的任务&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，出现了多个线程消费同一个资源的情况。&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;(1)用分布式锁，但是用分布式锁，性能下降了，该方案不细说。&lt;br/&gt;(2)对ZREM的返回值进行判断，只有大于0的时候，才消费数据，于是将consumerDelayMessage()方法里的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(nowSecond &amp;gt;= score){
    String orderId = ((Tuple)items.toArray()[0]).getElement();
    jedis.zrem(&quot;OrderId&quot;, orderId);
    System.out.println(System.currentTimeMillis()+&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;+orderId);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(nowSecond &amp;gt;= score){
    String orderId = ((Tuple)items.toArray()[0]).getElement();
    Long num = jedis.zrem(&quot;OrderId&quot;, orderId);
    if( num != null &amp;amp;&amp;amp; num&amp;gt;0){
        System.out.println(System.currentTimeMillis()+&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;+orderId);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这种修改后，重新运行ThreadTest类，发现输出正常了&lt;/p&gt;
&lt;h4 id=&quot;思路二&quot;&gt;思路二&lt;/h4&gt;
&lt;p&gt;该方案使用redis的Keyspace Notifications，中文翻译就是&lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;键空间机制&lt;/a&gt;，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。&lt;/p&gt;
&lt;h4 id=&quot;实现二&quot;&gt;实现二&lt;/h4&gt;
&lt;p&gt;在redis.conf中，加入一条配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;notify-keyspace-events Ex&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.delay5;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPubSub;

public class RedisTest {
    private static final String ADDR = &quot;127.0.0.1&quot;;
    private static final int PORT = 6379;
    private static JedisPool jedis = new JedisPool(ADDR, PORT);
    private static RedisSub sub = new RedisSub();

    public static void init() {
        new Thread(new Runnable() {
            public void run() {
                jedis.getResource().subscribe(sub, &quot;__keyevent@0__:expired&quot;);
            }
        }).start();
    }

    public static void main(String[] args) throws InterruptedException {
        init();
        for(int i =0;i&amp;lt;10;i++){
            String orderId = &quot;OID000000&quot;+i;
            jedis.getResource().setex(orderId, 3, orderId);
            System.out.println(System.currentTimeMillis()+&quot;ms:&quot;+orderId+&quot;订单生成&quot;);
        }
    }
    
    static class RedisSub extends JedisPubSub {
        @Override
        public void onMessage(String channel, String message) {
            System.out.println(System.currentTimeMillis()+&quot;ms:&quot;+message+&quot;订单取消&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1525096202813ms:OID0000000订单生成
1525096202818ms:OID0000001订单生成
1525096202824ms:OID0000002订单生成
1525096202826ms:OID0000003订单生成
1525096202830ms:OID0000004订单生成
1525096202834ms:OID0000005订单生成
1525096202839ms:OID0000006订单生成
1525096205819ms:OID0000000订单取消
1525096205920ms:OID0000005订单取消
1525096205920ms:OID0000004订单取消
1525096205920ms:OID0000001订单取消
1525096205920ms:OID0000003订单取消
1525096205920ms:OID0000006订单取消
1525096205920ms:OID0000002订单取消&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以明显看到3秒过后，订单取消了&lt;/p&gt;
&lt;h4 id=&quot;优缺点-3&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;优点:(1)由于使用Redis作为消息通道，消息都存储在Redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。&lt;br/&gt;   (2)做集群扩展相当方便&lt;br/&gt;   (3)时间准确度高&lt;br/&gt;缺点:(1)需要额外进行redis维护&lt;/p&gt;
&lt;h3 id=&quot;使用消息队列&quot;&gt;(5)使用消息队列&lt;/h3&gt;
&lt;p&gt;我们可以采用rabbitMQ的延时队列。RabbitMQ具有以下两个特性，可以实现延迟队列&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter&lt;/li&gt;
&lt;li&gt;lRabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。&lt;br/&gt;结合以上两个特性，就可以模拟出延迟消息的功能,具体的，我改天再写一篇文章，这里再讲下去，篇幅太长。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;优缺点-4&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;优点: 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。&lt;br/&gt;缺点：本身的易用度要依赖于rabbitMq的运维.因为要引用rabbitMq,所以复杂度和成本变高&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文总结了目前互联网中，绝大部分的延时任务的实现方案。希望大家在工作中能够有所收获。&lt;br/&gt;其实大家在工作中，百分九十的人还是以业务逻辑为主，很少有机会能够进行方案设计。所以博主不推荐在分布式这块，花太多时间，应该看看《&lt;a href=&quot;http://www.cnblogs.com/rjzheng/category/1205773.html&quot;&gt;手把手系列的文章&lt;/a&gt;》。不过，鉴于现在的面试造火箭，工作拧螺丝现象太过严重，所以博主开始写《&lt;a href=&quot;http://www.cnblogs.com/rjzheng/category/1204667.html&quot;&gt;分布式系列&lt;/a&gt;》，最后来个小漫画娱乐一下。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_delay.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 15:25:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/8972725.html</dc:identifier>
</item>
<item>
<title>通讯协议序列化解读（一） Protobuf详解教程 - 望星辰大海</title>
<link>http://www.cnblogs.com/tohxyblog/p/8974641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tohxyblog/p/8974641.html</guid>
<description>&lt;div class=&quot;markdown_views&quot; readability=&quot;24.545102593883&quot;&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：说到JSON可能大家很熟悉，是目前应用最广泛的一种序列化格式，它使用起来简单方便，而且拥有超高的可读性。但是在越来越多的应用场景里，JSON冗长的缺点导致它并不是一种最优的选择。&lt;/p&gt;
&lt;h3 id=&quot;h3--&quot;&gt;一、常用序列化格式介绍&lt;/h3&gt;
&lt;p&gt;目前JAVA常用的序列化有protobuf，json，xml，Serializable，hessian，kryo。他们的优缺点如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;JSON：不多说了，用途广泛，序列化方式还衍生了阿里的fastjson，美团的MSON，谷歌的GSON等更加优秀的转码工具。&lt;br/&gt;优点：使用方便。&lt;br/&gt;缺点：数据冗长，转码性能一般。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;XML：很久之前的转码方法了，现在用的不多。&lt;br/&gt;优点：暂时没发现。&lt;br/&gt;缺点：数据冗长，转码性能一般。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Serialzable：JDK自带的序列化。&lt;br/&gt;优点：使用方便。&lt;br/&gt;缺点：转码性能低下。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;hessian：基于 binary-RPC实现的远程通讯library，使用二进制传输数据。&lt;br/&gt;优点：数据长度小。&lt;br/&gt;缺点：性能低下。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111496/201804/1111496-20180430204711249-1813484597.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说了这么多，全是性能低下，MMP一群智障儿？当然不是！kryo就是一款快速、高效的序列化框架，但是它不是我们今天的主角，因为他只能在java中使用，和前端非java语言的通讯就存在极大的隔阂。我们今天的主角是protobuf？emmm，算是吧，但是也不全是，先给大家说下protobuf吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;protobuf：谷歌公司出的一款开源项目，性能好，效率高，并且支持多种语言，例如：java，C++，python等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　优点：转码性能高，支持多语言。&lt;br/&gt;　　　　缺点：中文文档少，使用相对复杂。&lt;/p&gt;
&lt;h3 id=&quot;h3--protobuf-&quot;&gt;二、protobuf详解&lt;/h3&gt;
&lt;p&gt;在使用protobuf之前，需要安装protobuf编译器和运行时环境。&lt;br/&gt;由于protobuf是跨平台，跨语言的，所以需要下载和安装对应版本的编译器和运行时依赖。&lt;/p&gt;
&lt;h4&gt;2.1 proto语法介绍&lt;/h4&gt;
&lt;br/&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content csdn-tracking-statistics&quot; data-pid=&quot;blog&quot; data-mod=&quot;popu_307&quot; data-dsm=&quot;post&quot;&gt;
&lt;div class=&quot;markdown_views&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;.proto Type&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;C++ Type&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Java Type&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Python Type[2]&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Go Type&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;double&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;double&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;float&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;float64&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;float&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;float&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;float&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;float32&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int32&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;使用可变长度编码。对负数进行编码时比较低效 – 如果你的字段要使用负数值，请使用sint32来代替。&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int32&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int64&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;使用可变长度编码。对负数进行编码时比较低效 – 如果你的字段要使用负数值，请使用sint64来代替。&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int64&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;long&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int/long[3]&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int64&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint32&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;使用可变长度编码&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;uint32&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int[1]&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int/long[3]&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;uint32&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint64&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;使用可变长度编码&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;uint64&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;long[1]&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;int/long[3]&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;uint64&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

详细语法由于篇章太多不在此做介绍，详情点开另一篇博文：&lt;a href=&quot;http://www.cnblogs.com/tohxyblog/p/8974763.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/tohxyblog/p/8974763.html&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h4 id=&quot;h4-2-2-&quot;&gt;2.2使用教程&lt;/h4&gt;
&lt;h5 id=&quot;h5-2-2-1-&quot;&gt;2.2.1导包&lt;/h5&gt;
&lt;/p&gt;
&lt;div class=&quot;markdown_views&quot; readability=&quot;43.052256532067&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
  &amp;lt;!-- protobuf-谷歌 --&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;h5-2-2-1-&quot;&gt;2.2.1下载编译器编译文件&lt;/h5&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/google/protobuf/releases&quot;&gt;https://github.com/google/protobuf/releases&lt;/a&gt;&lt;br/&gt;选择对应系统的版本，下载后解压。&lt;br/&gt;可以通过定义好的.proto文件来生成Java代码，需要基于.proto文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。&lt;br/&gt;通过如下方式调用protocol编译器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;&lt;code&gt;IMPORT_PATH&lt;/code&gt;声明了一个.proto文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用&lt;code&gt;--proto_path&lt;/code&gt;，它们将会顺序的被访问并执行导入。&lt;code&gt;-I=IMPORT_PATH&lt;/code&gt;是&lt;code&gt;--proto_path&lt;/code&gt;的简化形式。&lt;/li&gt;
&lt;li&gt;当然也可以提供一个或多个输出路径： 
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。 &lt;br/&gt;- 你必须提议一个或多个.proto文件作为输入，多个.proto文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。&lt;/p&gt;
&lt;h5 id=&quot;h5-2-2-3proto-&quot;&gt;2.2.3protobuf使用教程&lt;/h5&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//以user为例编码成byte[]
UserOuterClass.User.Builder userBuild = UserOuterClass.User.newBuilder();
userBuild.setUserId(user.getUserId());
userBuild.setUserName(user.getUserName());
userBuild.setPhoneNum(user.getPhoneNum());
userBuild.setCreateTime(user.getCreateTime());
userBuild.setOpenId(user.getOpenId());
userBuild.setIntroduct(user.getIntroduct());
userBuild.setSex(user.isSex());
userBuild.setUserImg(user.getUserImg());
userBuild .toByteArray()；//得到byte[]


//以user为例解码
UserOuterClass.User.Builder userBuild = UserOuterClass.User.newBuilder();
User user= user.build();
user=User.parseFrom(data.getValue().getBytes());
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;h3--protobuf-&quot;&gt;三、protobuf在实际操作中存在的问题&lt;/h3&gt;
&lt;p&gt;protobuf主要用于与前端通信编解码，那么在后台收到二进制如何存入到数据库中呢，或者说从数据库中取得的数据怎么映射到protobean呢。&lt;br/&gt;由于protoc生成的java文件与我们平时写的java文件有区别，但是实际上都是有getset方法，不怕麻烦的童鞋可以直接通过两个类的值getset方法直接转换，效率可观，但是操作起来确实有些麻烦。这里我们提供一个更加便捷的工具类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
   /**
         * 该方法将javabean对象转换成protobuf对应的bean
         * 
         * @param javaBean
         * @param protoBuilder
         */
        @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
        public static Object javaBeanToProtoBean(Object javaBean, Object protoBuilder) {


            try {
                Method mm = protoBuilder.getClass().getMethod(&quot;getDescriptorForType&quot;);


                Descriptors.Descriptor descriptor = (Descriptor) mm.invoke(protoBuilder);


                Field[] fields = javaBean.getClass().getDeclaredFields();


                for (Field item : fields) {
                    try{
                    String fName = item.getName();
                    item.setAccessible(true);
                    Object jObject = item.get(javaBean);
                    if(null == jObject){
                       break;
                    }
                    FieldDescriptor fd = descriptor.findFieldByName(fName);
                    if(null != fd){
                        if(fd.isRepeated()){
                            boolean isDefined = false;
                                Method[] mmm = protoBuilder.getClass().getMethods();
                                for(Method mItem : mmm){
                                    
                                    try{
                                        String mName = mItem.getName();
                                        String mName1 = &quot;add&quot; + StringUtil.firstToUpper(fName);
                                        if(mName1.equals(mName) &amp;amp;&amp;amp; mItem.getParameterTypes().length == 1){
                                            Class[] ccList = mItem.getParameterTypes();
                                            Class cc = ccList[0];
                                            Method me = cc.getMethod(&quot;newBuilder&quot;);
                                            Object oBuilder = me.invoke(null);//获取自定义对象builder
                                            
                                            List&amp;lt;Object&amp;gt; dList = (List&amp;lt;Object&amp;gt;) jObject; //数据为List集合
                                            List&amp;lt;Object&amp;gt; pBeanList = new ArrayList&amp;lt;Object&amp;gt;();
                                           for(Object oItem : dList){
                                              Object pBean = javaBeanToProtoBean(oItem,oBuilder);
                                              pBeanList.add(pBean);
                                           }
                                           Method mee = protoBuilder.getClass().getMethod(&quot;addAll&quot;+StringUtil.firstToUpper(fName),Iterable.class);
                                           mee.invoke(protoBuilder, pBeanList); 
                                            isDefined = true;
                                        }   
                                    }catch(Exception e){
                                        
                                    }
                                
                                }    
                         
                          if(!isDefined){
                            try{
                                Method me = protoBuilder.getClass().getMethod(&quot;addAll&quot;+StringUtil.firstToUpper(fName),Iterable.class);
                                me.invoke(protoBuilder, jObject);
                            }catch(Exception e){
                                logger .info(&quot;this repeated field is a user-defined field&quot;);
                                e.printStackTrace();
                            }
                            } 


                        }else{
                            boolean isDefined1 = false;
                            try{
                               // 自定义对象继续需要通过builder来解析处理，回调、           这一块很占计算时间。有待优化
                                Method bM = protoBuilder.getClass().getMethod(&quot;getFieldBuilder&quot;, FieldDescriptor.class);
                                Object subBuilder = bM.invoke(protoBuilder, fd);
                                Object pBean = javaBeanToProtoBean(jObject,subBuilder); 
                                Method me = protoBuilder.getClass().getMethod(&quot;setField&quot;, FieldDescriptor.class, Object.class);
                                me.invoke(protoBuilder, fd, pBean);
                                isDefined1 = true;
                            }catch(Exception e){
//                              logger .info(&quot;this required field is not a user-defined field&quot;);
                            }
                            
                            if(!isDefined1){
                                Method me = protoBuilder.getClass().getMethod(&quot;setField&quot;, FieldDescriptor.class, Object.class);
                                me.invoke(protoBuilder, fd, jObject);
                            }
                            
                        }
                    }
                    }catch(Exception e){
                        logger .error(&quot;javaBeanToProtoBean method  item reflect error, item name:&quot;+item.getName());
                    }
                }
                
                Method buildM = protoBuilder.getClass().getMethod(&quot;build&quot;);
                Object rObject =  buildM.invoke(protoBuilder);
            /*    Method byteM = rObject.getClass().getMethod(&quot;toByteArray&quot;);
                Object byteObject =  byteM.invoke(rObject);
                byte[] pbByte = (byte[]) byteObject;  
                String pbStr = new String(Base64.getEncoder().encode(pbByte), &quot;UTF-8&quot;);*/
                return rObject;
            } catch (Exception e) {
                e.printStackTrace();
                logger.error(&quot;convert javabean to protobuf bean error,e:&quot;, e);
                return null;
            }

        } 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上方法可以通用的讲前端发送过来的protobean转成我们需要的普通javabean，但是在性能上比getset慢上许多，普通项目用起来是没问题，也能达到每秒几万次，但是对性能有要求的童鞋可以关注我注释的那一行代码。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;markdown_views&quot; readability=&quot;16&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 try{
                               // 自定义对象继续需要通过builder来解析处理，回调、           这一块很占计算时间。有待优化
                                Method bM = protoBuilder.getClass().getMethod(&quot;getFieldBuilder&quot;, FieldDescriptor.class);
                                Object subBuilder = bM.invoke(protoBuilder, fd);
                                Object pBean = javaBeanToProtoBean(jObject,subBuilder); 
                                Method me = protoBuilder.getClass().getMethod(&quot;setField&quot;, FieldDescriptor.class, Object.class);
                                me.invoke(protoBuilder, fd, pBean);
                                isDefined1 = true;
                            }catch(Exception e){
//                              logger .info(&quot;this required field is not a user-defined field&quot;);
                            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于转换中有这里要对包含其他bean做处理，所以在普通操作时经常进了catch代码块，所以浪费了很长时间（众所周知，catch是很浪费时间的），但是去掉这块代码转包含关系的bean就有问题，这块难题暂时博主也没解决，留给你们去，能解决的可以在下方留言。如果解决不了但是还是想简单方便的，可以关注我的下一篇博文，protostuff。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Mon, 30 Apr 2018 15:19:00 +0000</pubDate>
<dc:creator>望星辰大海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tohxyblog/p/8974641.html</dc:identifier>
</item>
<item>
<title>Spring Boot消息队列应用实践 - JeffWong</title>
<link>http://www.cnblogs.com/jeffwongishandsome/p/spring-boot-integrate-messaging-queue-practise.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jeffwongishandsome/p/spring-boot-integrate-messaging-queue-practise.html</guid>
<description>&lt;p&gt;消息队列是大型复杂系统解耦利器。本文根据应用广泛的消息队列RabbitMQ，介绍Spring Boot应用程序中队列中间件的开发和应用。&lt;/p&gt;
&lt;h2&gt;一、RabbitMQ基础&lt;/h2&gt;
&lt;h4&gt;1、RabbitMQ简介&lt;/h4&gt;
&lt;p&gt;RabbitMQ是Spring所在公司Pivotal自己的产品，是基于AMQP高级队列协议的消息中间件，采用erlang开发，所以你的RabbitMQ队列服务器需要erlang环境。&lt;/p&gt;
&lt;p&gt;可以直接官方的说法：RabbitMQ is the most widely deployed open source message broker.言简意赅，一目了然。&lt;/p&gt;
&lt;h4&gt;2、AMQP&lt;/h4&gt;
&lt;p&gt;高级消息队列协议（AMQP）是一个异步消息传递所使用的应用层协议规范。作为线路层协议（AMQP是一个抽象的协议，它不负责处理具体的数据），而不是API（例如Java消息系统JMS），AMQP客户端能够无视消息的来源任意发送和接受信息。&lt;br/&gt;AMQP的原始用途只是为金融界提供一个可以彼此协作的消息协议，而现在的目标则是为通用消息队列架构提供通用构建工具。因此，面向消息的中间件（MOM）系统，例如发布/订阅队列，没有作为基本元素实现。反而通过发送简化的AMQ实体，用户被赋予了构建例如这些实体的能力。这些实体也是规范的一部分，形成了在线路层协议顶端的一个层级：AMQP模型。这个模型统一了消息模式，诸如之前提到的发布/订阅，队列，事务以及流数据，并且添加了额外的特性，例如更易于扩展，基于内容的路由。&lt;/p&gt;
&lt;p&gt;扩展阅读：既然有高级的消息协议，必然有简单的协议，STOMP（Simple (or Streaming) Text Orientated Messaging Protocol），也就是简单消息文本协议，猛击&lt;a title=&quot;http://stomp.github.io/&quot; href=&quot;http://stomp.github.io/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;3、MSMQ&lt;/h4&gt;
&lt;p&gt;这里附带介绍一下MSMQ。.NET开发者接触最多的可能还是这个消息队列，我知道有两个以.NET作为主要开发语言的公司都选择MSMQ来开发公共框架如ESB、日志组件等。&lt;/p&gt;
&lt;p&gt;如果你有.NET下MSMQ（微软消息队列）开发和使用经验，一定不会对队列常用术语陌生。对比一下，对后面RabbitMQ的学习和理解非常有帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430101217407-291607441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逻辑结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430100211815-923141006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;4、基本术语  &lt;/h4&gt;
&lt;p&gt;安装好RabbitMQ后，可以启用插件，打开RabbitMQ自带的后台，一图胜千言，你会看到很多似曾相识的技术术语和名词。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180429212153195-346370708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然你也可以参考&lt;a title=&quot;http://www.rabbitmq.com/getstarted.html&quot; href=&quot;http://www.rabbitmq.com/getstarted.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;的图片示例一个一个验证下面的名词。&lt;/p&gt;
&lt;p&gt;（1）Broker：消息队列服务器实体。&lt;/p&gt;
&lt;p&gt;（2）Producer：生产者。&lt;/p&gt;
&lt;p&gt;（3）Consumer：消费者。&lt;/p&gt;
&lt;p&gt;（4）Queue（队列）：消息队列载体，每个消息都会被投入到一个或多个队列。Queue是 RabbitMQ 的内部对象，用于存储消息；消费者Consumer就是通过订阅队列来获取消息的，RabbitMQ 中的消息都只能存储在 Queue 中，生产者Producer生产消息并最终投递到 Queue 中，消费者可以从 Queue 中获取消息并消费；多个消费者可以订阅同一个 Queue。&lt;/p&gt;
&lt;p&gt;（5）Connection（连接）：Producer 和 Consumer 通过TCP 连接到 RabbitMQ Server。&lt;/p&gt;
&lt;p&gt;（6）Channel（信道）：基于 Connection创建，数据流动都是在 Channel 中进行。&lt;/p&gt;
&lt;p&gt;（7）Exchange（交换器）：生产者将消息发送到 Exchange（交换器），由Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）；Exchange 并不存储消息；Exchange Types 常用的有 &lt;span&gt;Fanout、Direct、Topic&lt;/span&gt; 和Header四种类型，每种类型对应不同的路由规则：&lt;br/&gt;&lt;span&gt;Direct&lt;/span&gt;：完全匹配，消息路由到那些 Routing Key 与 Binding Key 完全匹配的 Queue 中。比如 Routing Key 为mq_cleint-key，只会转发mq_cleint-key，不会转发mq_cleint-key.1，也不会转发mq_cleint-key.1.2。&lt;br/&gt;&lt;span&gt;Topic&lt;/span&gt;：模式匹配，Exchange 会把消息发送到一个或者多个满足通配符规则的 routing-key 的 Queue。其中&lt;span&gt;*&lt;/span&gt;表号匹配一个 word，&lt;span&gt;#&lt;/span&gt;匹配多个 word 和路径，路径之间通过&lt;span&gt;.&lt;/span&gt;隔开。如满足a.*.c的 routing-key 有a.hello.c；满足#.hello的 routing-key 有a.b.c.hello。&lt;br/&gt;&lt;span&gt;Fanout&lt;/span&gt;：忽略匹配，把所有发送到该 Exchange 的消息路由到所有与它绑定 的Queue 中。&lt;/p&gt;
&lt;p&gt;Header：也根据规则匹配，相较于Direct和Topic固定地使用RoutingKey ，Headers 则是一个自定义匹配规则的类型。在队列与交换器绑定时, 会设定一组键值对（Key-Value）规则, 消息中也包括一组键值对( Headers 属性)， 当这些键值对有一对,，或全部匹配时， 消息被投送到对应队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180429215656482-1094037107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（8）Binding（绑定）：是 Exchange（交换器）将消息路由给 Queue 所需遵循的规则。&lt;/p&gt;
&lt;p&gt;（9）Routing Key（路由键）：消息发送给 Exchange（交换器）时，消息将拥有一个路由键（默认为空）， Exchange（交换器）根据这个路由键将消息发送到匹配的队列中。&lt;/p&gt;
&lt;p&gt;（10）Binding Key（绑定键）：指定当前 Exchange（交换器）下，什么样的 Routing Key（路由键）会被下派到当前绑定的 Queue 中。&lt;/p&gt;
&lt;h4&gt;5、应用场景&lt;/h4&gt;
&lt;p&gt;我们使用一个技术或组件或中间件，必须要非常理解它的适用场景，否则很容易误用。&lt;/p&gt;
&lt;p&gt;RabbitMQ的经典应用场景包括：异步处理、应用解耦、流量削峰、日志处理、消息通讯。&lt;/p&gt;
&lt;p&gt;已经有很多人总结了这5种场景下的RabbitMQ实际应用。&lt;/p&gt;
&lt;p&gt;推荐阅读：猛击&lt;a title=&quot;http://www.cnblogs.com/saltlight-wangchao/p/6214334.html&quot; href=&quot;http://www.cnblogs.com/saltlight-wangchao/p/6214334.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里，RabbitMQ基础知识介绍结束，下面开始动手实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('975d50f8-fde6-471c-8b7f-73f4b0c9d8b1')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_975d50f8-fde6-471c-8b7f-73f4b0c9d8b1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_975d50f8-fde6-471c-8b7f-73f4b0c9d8b1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('975d50f8-fde6-471c-8b7f-73f4b0c9d8b1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_975d50f8-fde6-471c-8b7f-73f4b0c9d8b1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-amqp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RabbitMQ&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;配置RabbitMQ&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7d77146e-8829-4554-b5c0-32702bbef3f1')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_7d77146e-8829-4554-b5c0-32702bbef3f1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7d77146e-8829-4554-b5c0-32702bbef3f1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7d77146e-8829-4554-b5c0-32702bbef3f1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7d77146e-8829-4554-b5c0-32702bbef3f1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## RabbitMQ相关配置
spring.application.name&lt;/span&gt;=&lt;span&gt;springbootdemo
spring.rabbitmq.host&lt;/span&gt;=127.0.0.1&lt;span&gt;
spring.rabbitmq.port&lt;/span&gt;=5672&lt;span&gt;
spring.rabbitmq.username&lt;/span&gt;=&lt;span&gt;springbootmq
spring.rabbitmq.password&lt;/span&gt;=123456
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;application.mq.properties&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;新增RabbitMQConfig类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c5c98096-1fba-4b24-9d5c-ee1c81d36142')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_c5c98096-1fba-4b24-9d5c-ee1c81d36142&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c5c98096-1fba-4b24-9d5c-ee1c81d36142&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c5c98096-1fba-4b24-9d5c-ee1c81d36142',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c5c98096-1fba-4b24-9d5c-ee1c81d36142&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.amqp.core.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * RabbitMQ消息队列配置类
 * &amp;lt;p&amp;gt;
 * 注意：如果已在配置文件中声明了Queue对象，就不用在RabbitMQ的管理员页面创建队列（Queue）了
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitMQConfig {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 声明接收字符串的队列 Hello 默认
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue stringQueue() {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;boolean isDurable = true;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否持久化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;boolean isExclusive = false;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;仅创建者可以使用的私有队列，断开后自动删除
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;boolean isAutoDelete = false;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当所有消费客户端连接断开后，是否自动删除队列
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Queue queue = new Queue(MQField.HELLO_STRING_QUEUE, isDurable, isExclusive, isAutoDelete);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return  queue;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return new Queue(MQField.HELLO_STRING_QUEUE); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认支持持久化&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.HELLO_STRING_QUEUE)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.exclusive()
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.autoDelete()&lt;/span&gt;
&lt;span&gt;                .build();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 声明接收Goods对象的队列 Hello  支持持久化
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue goodsQueue() {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.HELLO_GOODS_QUEUE).build();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 声明WorkQueue队列 competing consumers pattern，多个消费者不会重复消费队列的相同消息
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue workQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.MY_WORKER_QUEUE).build();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 消息队列中最常见的模式：发布订阅模式
     * &amp;lt;p&amp;gt;
     * 声明发布订阅模式队列 Publish/Subscribe
     * &amp;lt;p&amp;gt;
     * exchange类型包括：direct, topic, headers 和 fanout
     *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;fanout（广播）队列相关声明开始&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue fanOutAQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.MY_FANOUTA_QUEUE).build();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue fanOutBQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.MY_FANOUTB_QUEUE).build();
    }

    @Bean
    FanoutExchange fanoutExchange() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (FanoutExchange) ExchangeBuilder.fanoutExchange(MQField.MY_FANOUT_EXCHANGE).build();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return new FanoutExchange(MQField.MY_FANOUT_EXCHANGE);&lt;/span&gt;
&lt;span&gt;    }

    @Bean
    Binding bindingExchangeA(Queue fanOutAQueue, FanoutExchange fanoutExchange) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BindingBuilder.bind(fanOutAQueue).to(fanoutExchange);
    }

    @Bean
    Binding bindingExchangeB(Queue fanOutBQueue, FanoutExchange fanoutExchange) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BindingBuilder.bind(fanOutBQueue).to(fanoutExchange);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;fanout队列相关声明结束&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;


    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;topic队列相关声明开始&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue topicAQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.MY_TOPICA_QUEUE).build();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue topicBQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.MY_TOPICB_QUEUE).build();
    }

    @Bean
    TopicExchange topicExchange() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (TopicExchange) ExchangeBuilder.topicExchange(MQField.MY_TOPIC_EXCHANGE).build();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定时，注意队列名称与上述方法名一致&lt;/span&gt;
&lt;span&gt;    @Bean
    Binding bindingTopicAExchangeMessage(Queue topicAQueue, TopicExchange topicExchange) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BindingBuilder.bind(topicAQueue).to(topicExchange).with(MQField.MY_TOPIC_ROUTINGKEYA);
    }

    @Bean
    Binding bindingTopicBExchangeMessages(Queue topicBQueue, TopicExchange topicExchange) {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BindingBuilder.bind(topicBQueue).to(topicExchange).with(MQField.MY_TOPIC_ROUTINGKEYB);

    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;topic队列相关声明结束&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;direct队列相关声明开始&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue directAQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.MY_DIRECTA_QUEUE).build();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue directBQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; QueueBuilder.durable(MQField.MY_DIRECTB_QUEUE).build();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 声明Direct交换机 支持持久化.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the exchange
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    DirectExchange directExchange() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (DirectExchange) ExchangeBuilder.directExchange(MQField.MY_DIRECT_EXCHANGE).durable(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build();
    }

    @Bean
    Binding bindingDirectAExchangeMessage(Queue directAQueue, DirectExchange directExchange) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BindingBuilder.bind(directAQueue).to(directExchange).with(MQField.MY_DIRECT_ROUTINGKEYA);
    }

    @Bean
    Binding bindingDirectBExchangeMessage(Queue directBQueue, DirectExchange directExchange) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BindingBuilder.bind(directBQueue).to(directExchange)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.with(MQField.MY_DIRECT_ROUTINGKEYB)&lt;/span&gt;
&lt;span&gt;                .with(MQField.MY_DIRECT_ROUTINGKEYB);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;direct队列相关声明结束&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RabbitMQConfig&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;RabbitMQConfig我将常用到的模式都配置在里面了，注释已经写得很清楚，在详细介绍模式的地方会用到这里定义的队列、绑定和交换器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久化配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在RabbitMQConfig类中尤其注意这几个参数，包括是否可持久化&lt;span&gt;durable&lt;/span&gt;；仅创建者可以使用的私有队列，断开后自动删除&lt;span&gt;exclusive&lt;/span&gt;；当所有消费客户端连接断开后，是否自动删除队列&lt;span&gt;autoDelete&lt;/span&gt;。其中durable和autoDelete对队列和交换器都可以配置。&lt;/p&gt;
&lt;p&gt;RabbitMQ支持的消息的持久化（durable），也就是将数据写在磁盘上，为了数据安全考虑，绝大多数场景下我们都会选择持久化，可能记录一些不是业务必须的日志稍微例外。&lt;br/&gt;消息队列持久化包括3个部分：&lt;/p&gt;
&lt;p&gt;（1）、队列持久化，在声明时指定Queue.durable为1&lt;/p&gt;
&lt;p&gt;（2）、交换器持久化，在声明时指定Exchange.durable为1&lt;/p&gt;
&lt;p&gt;（3）、消息持久化，在投递时指定消息的delivery_mode为2（而1表示非持久化） 参考：&lt;a title=&quot;https://blog.csdn.net/joeyon1985/article/details/39429117&quot; href=&quot;https://blog.csdn.net/joeyon1985/article/details/39429117&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果Exchange和Queue都是持久化的，那么它们之间的Binding也是持久化的；如果Exchange和Queue两者之间有一个持久化，另一个非持久化，就不允许建立绑定。&lt;/p&gt;
&lt;h2&gt;二、常见模式&lt;/h2&gt;
&lt;p&gt;在Spring Boot下使用RabbitMQ非常容易，直接调用AmqpTemplate类封装好的接口即可。&lt;/p&gt;
&lt;h4&gt;1、hello world&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430103323735-1478353452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;P为生产者，C为消费者，中间红色框表示消息队列。生产者P将消息发送到消息队列Queue，消费者C对消息进行处理。&lt;/p&gt;
&lt;p&gt;生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5182c9f6-758e-43c4-9017-299e65351ef6')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_5182c9f6-758e-43c4-9017-299e65351ef6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5182c9f6-758e-43c4-9017-299e65351ef6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5182c9f6-758e-43c4-9017-299e65351ef6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5182c9f6-758e-43c4-9017-299e65351ef6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.hello;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.entity.vo.GoodsVO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Hello消息生产者
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloSender {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; send(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.HELLO_STRING_QUEUE, message);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;HelloSender发送字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; send(GoodsVO goodsVO) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        rabbitTemplate.convertAndSend(MQField.HELLO_GOODS_QUEUE, goodsVO);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;HelloSender发送对象消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;HelloSender&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0e30f3e1-e322-4309-9ec3-043e52cd8d1c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0e30f3e1-e322-4309-9ec3-043e52cd8d1c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0e30f3e1-e322-4309-9ec3-043e52cd8d1c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0e30f3e1-e322-4309-9ec3-043e52cd8d1c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0e30f3e1-e322-4309-9ec3-043e52cd8d1c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.hello;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.entity.vo.GoodsVO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.util.SerializeUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Hello消息消费者
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloReceiver {

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.HELLO_STRING_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(String message) {

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }

        System.out.println(&lt;/span&gt;&quot;HelloReceiver接收到的字符串消息是 =&amp;gt; &quot; +&lt;span&gt; message);
    }


    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.HELLO_GOODS_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(GoodsVO goodsVO) {
        System.out.println(&lt;/span&gt;&quot;------ 接收实体对象 ------&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;HelloReceiver接收到的实体对象是 =&amp;gt; &quot; +&lt;span&gt; SerializeUtil.Serialize(goodsVO));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;HelloReceiver&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这是最简单的一种模式，这个最简单示例，可以看到应用场景里的异步处理的影子。&lt;/p&gt;
&lt;p&gt;在Controller中，新增一个接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2a955800-7239-4114-b5c7-ac23ee740a8f')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_2a955800-7239-4114-b5c7-ac23ee740a8f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2a955800-7239-4114-b5c7-ac23ee740a8f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2a955800-7239-4114-b5c7-ac23ee740a8f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2a955800-7239-4114-b5c7-ac23ee740a8f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/hello/sendmsg&quot;, method =&lt;span&gt; RequestMethod.GET)
    @ApiOperation(&lt;/span&gt;&quot;简单字符串消息测试&quot;&lt;span&gt;)
    @ApiImplicitParams({
            @ApiImplicitParam(paramType &lt;/span&gt;= &quot;query&quot;, name = &quot;message&quot;, required = &lt;span&gt;true&lt;/span&gt;, value = &quot;字符串消息&quot;, dataType = &quot;String&quot;&lt;span&gt;)
    })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String sendMsg(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK =&lt;span&gt; helloSender.send(message);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; String.valueOf(isOK);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;sendmsg&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;按照传统方式调用RPC接口，通常都是同步等待接口返回，而使用队列后，消息生产者直接向RabbitMQ服务器发送一条消息，不需要同步等待这个消息的处理结果。&lt;/p&gt;
&lt;p&gt;示例代码中，消息消费者会刻意等待5秒（Thread.sleep(5000);）后才处理（打印出）消息，但是实际调用这个接口的时候，非常快就返回成功结果了，因为这个发送消息的动作不需要等待消费者消费消息的结果。&lt;/p&gt;
&lt;p&gt;发送的消息，除了简单消息对象如字符串等，示例里你还看到有一个发送商品对象的消息，也就是说明RabbitMQ支持自定义的复杂对象消息。&lt;/p&gt;
&lt;h4&gt;2、work queues&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430110707093-1639142474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;P为生产者，C1、C2为消费者，中间红色框表示消息队列。生产者P将消息发送到消息队列Queue，消费者C1和C2对消息进行处理。&lt;/p&gt;
&lt;p&gt;这种模式比较容易产生误解的地方是，多个消费者会不会消费队列里的同一条消息。答案是不会。&lt;/p&gt;
&lt;p&gt;官方的说明是因为消费者根据竞争消费模式（&lt;a title=&quot;http://www.enterpriseintegrationpatterns.com/patterns/messaging/CompetingConsumers.html&quot; href=&quot;http://www.enterpriseintegrationpatterns.com/patterns/messaging/CompetingConsumers.html&quot; target=&quot;_blank&quot;&gt;competing consumers pattern&lt;/a&gt;）分派任务（Distributing tasks among workers (the competing consumers pattern) ）。&lt;/p&gt;
&lt;p&gt;对于work queues这种模式，同一条消息M1，要么C1拉取到，要么C2拉取到，不会出现C1和C2同时拉取到并消费。&lt;/p&gt;
&lt;p&gt;当然，这种模式还可以扩展，除了一个生产者，也可以有多个生产者。&lt;/p&gt;
&lt;p&gt;生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('35bc2fc2-3328-40bf-b317-1f8705236d2e')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_35bc2fc2-3328-40bf-b317-1f8705236d2e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35bc2fc2-3328-40bf-b317-1f8705236d2e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('35bc2fc2-3328-40bf-b317-1f8705236d2e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35bc2fc2-3328-40bf-b317-1f8705236d2e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.workqueues;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WorkProducerA {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; send(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.MY_WORKER_QUEUE, message);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;WorkProducerA发送字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;WorkProducerA&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;相同队列下另一个生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5ff7144b-f53c-4bf9-92e1-e439c94a1b9e')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_5ff7144b-f53c-4bf9-92e1-e439c94a1b9e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5ff7144b-f53c-4bf9-92e1-e439c94a1b9e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5ff7144b-f53c-4bf9-92e1-e439c94a1b9e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5ff7144b-f53c-4bf9-92e1-e439c94a1b9e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.workqueues;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WorkProducerB {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; send(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.MY_WORKER_QUEUE, message);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;WorkProducerB发送字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;WorkProducerB&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('17b12366-a4ef-4119-b030-17a82b8ae28e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_17b12366-a4ef-4119-b030-17a82b8ae28e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_17b12366-a4ef-4119-b030-17a82b8ae28e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('17b12366-a4ef-4119-b030-17a82b8ae28e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_17b12366-a4ef-4119-b030-17a82b8ae28e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.workqueues;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WorkConsumerA {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger atomicInteger = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_WORKER_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; process(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; atomicInteger.getAndIncrement();

        Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;WorkConsumerA接收到的字符串消息是 =&amp;gt; &quot; +&lt;span&gt; message);

        System.out.println(&lt;/span&gt;&quot;WorkConsumerA自增序号 =&amp;gt; &quot; +&lt;span&gt; index);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;WorkConsumerA&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;另一个消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('029f65f7-325a-4a52-8df2-9dd9153ba810')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_029f65f7-325a-4a52-8df2-9dd9153ba810&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_029f65f7-325a-4a52-8df2-9dd9153ba810&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('029f65f7-325a-4a52-8df2-9dd9153ba810',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_029f65f7-325a-4a52-8df2-9dd9153ba810&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.workqueues;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WorkConsumerB {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger atomicInteger = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_WORKER_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; process(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; atomicInteger.getAndIncrement();

        Thread.sleep(&lt;/span&gt;10&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;WorkConsumerB接收到的字符串消息是 =&amp;gt; &quot; +&lt;span&gt; message);

        System.out.println(&lt;/span&gt;&quot;WorkConsumerB自增序号 =&amp;gt; &quot; +&lt;span&gt; index);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pub/sub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用最广泛的发布/订阅模式。&lt;/p&gt;
&lt;p&gt;官方的说法是：发送多个消息到多个消费者（Sending messages to many consumers at once.）&lt;/p&gt;
&lt;p&gt;这个模式和work queues模式最明显的区别是，队列Queue前加了一层，多了Exchange（交换器）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430112647832-1604774090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; P为生产者，X为交换器，C1、C2为消费者，中间红色框表示消息队列。生产者P将消息不是直接发送到队列Queue，而是发送到交换器X（注意：交换器Exchange并不存储消息），然后由交换机X发送给两个队列，两个消费者C1和C2各自监听一个队列，来消费消息。&lt;/p&gt;
&lt;p&gt;根据交换器类型的不同，又可以分为Fanout、Direct和Topic这三种消费方式，Headers方式实际应用不是非常广泛，本文暂不讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430114252331-210788270.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3、fanout&lt;/h4&gt;
&lt;p&gt;任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。&lt;/p&gt;
&lt;p&gt;（1）可以理解为路由表的模式&lt;/p&gt;
&lt;p&gt;（2）这种模式不需要RoutingKey，即使配置了也忽略&lt;/p&gt;
&lt;p&gt;（3）这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定&lt;/p&gt;
&lt;p&gt;（4）如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃&lt;/p&gt;
&lt;p&gt;Fanout广播模式实现同一个消息被多个消费者消费，而work queues是同一个消息只能有一个消费者（竞争去）消费。&lt;/p&gt;
&lt;p&gt;生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('435c5ec9-61c1-4049-8383-4eebc6344a85')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_435c5ec9-61c1-4049-8383-4eebc6344a85&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_435c5ec9-61c1-4049-8383-4eebc6344a85&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('435c5ec9-61c1-4049-8383-4eebc6344a85',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_435c5ec9-61c1-4049-8383-4eebc6344a85&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.fanout;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.entity.vo.GoodsVO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FanoutSender {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; send(GoodsVO goodsVO) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (goodsVO == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.MY_FANOUT_EXCHANGE, &lt;/span&gt;&quot;&quot;&lt;span&gt;, goodsVO);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;FanoutSender发送对象消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;FanoutSender&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('05b2a25c-e00c-4f96-846a-6eac4a78b423')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_05b2a25c-e00c-4f96-846a-6eac4a78b423&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_05b2a25c-e00c-4f96-846a-6eac4a78b423&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('05b2a25c-e00c-4f96-846a-6eac4a78b423',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_05b2a25c-e00c-4f96-846a-6eac4a78b423&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.fanout;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.entity.vo.GoodsVO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.util.SerializeUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FanoutReceiverA {

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_FANOUTA_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(GoodsVO goodsVO) {
        System.out.println(&lt;/span&gt;&quot;FanoutReceiverA接收到的商品消息是 =&amp;gt; &quot; +&lt;span&gt; SerializeUtil.Serialize(goodsVO));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;FanoutReceiverA&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;另一个消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0ab47e29-fc84-4279-91b7-423b0de4328a')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0ab47e29-fc84-4279-91b7-423b0de4328a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0ab47e29-fc84-4279-91b7-423b0de4328a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0ab47e29-fc84-4279-91b7-423b0de4328a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0ab47e29-fc84-4279-91b7-423b0de4328a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.fanout;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.entity.vo.GoodsVO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.util.SerializeUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FanoutReceiverB {

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_FANOUTB_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(GoodsVO goodsVO) {
        System.out.println(&lt;/span&gt;&quot;FanoutReceiverB接收到的商品消息是 =&amp;gt; &quot; +&lt;span&gt; SerializeUtil.Serialize(goodsVO));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;FanoutReceiverB&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;4、direct&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430130334742-1967717233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Fanout是1对多以广播的方式，发送给所有的消费者。&lt;/p&gt;
&lt;p&gt;Direct则是创建消息队列的时候，指定一个BindingKey。当发送者发送消息的时候，指定对应的RoutingKey，当RoutingKey和消息队列的BindingKey一致的时候,消息将会被发送到该消息队列中。&lt;br/&gt;Direct广播模式最明显不同于Fanout模式的地方是，消费者可以进行消息过滤，有选择的进行接收想要消费的消息，也就是队列绑定关键字，发送者将数据根据关键字发送到Exchange，Exchange根据关键字判定应该将数据发送（路由）到指定队列。&lt;/p&gt;
&lt;p&gt;任何发送到Direct Exchange的消息都会被转发到RoutingKey中指定的Queue。&lt;/p&gt;
&lt;p&gt;（1）消息传递时需要一个“RoutingKey”，可以简单的理解为要发送到的队列名字&lt;/p&gt;
&lt;p&gt;（2）如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃&lt;/p&gt;
&lt;p&gt;生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('29709fc3-32ba-4add-829f-4c026dc4d9b6')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_29709fc3-32ba-4add-829f-4c026dc4d9b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_29709fc3-32ba-4add-829f-4c026dc4d9b6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('29709fc3-32ba-4add-829f-4c026dc4d9b6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_29709fc3-32ba-4add-829f-4c026dc4d9b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.direct;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectSender {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sendDirectA(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.MY_DIRECT_EXCHANGE, MQField.MY_DIRECT_ROUTINGKEYA, message);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;DirectSender发送DirectA字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sendDirectB(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.MY_DIRECT_EXCHANGE, MQField.MY_DIRECT_ROUTINGKEYB, message);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;DirectSender发送DirectB字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DirectSender&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3ca8dc26-b657-4a62-b4d4-47e7c8450960')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3ca8dc26-b657-4a62-b4d4-47e7c8450960&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3ca8dc26-b657-4a62-b4d4-47e7c8450960&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3ca8dc26-b657-4a62-b4d4-47e7c8450960',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3ca8dc26-b657-4a62-b4d4-47e7c8450960&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.direct;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectReceiverA {

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_DIRECTA_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(String message) {
        System.out.println(&lt;/span&gt;&quot;DirectReceiverA接收到的字符串消息是 =&amp;gt; &quot; +&lt;span&gt; message);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DirectReceiverA&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;另一个消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0d90cdfd-14c5-4309-89eb-7646b513525b')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0d90cdfd-14c5-4309-89eb-7646b513525b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0d90cdfd-14c5-4309-89eb-7646b513525b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0d90cdfd-14c5-4309-89eb-7646b513525b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0d90cdfd-14c5-4309-89eb-7646b513525b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.direct;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectReceiverB {

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_DIRECTB_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(String message) {
        System.out.println(&lt;/span&gt;&quot;DirectReceiverB接收到的字符串消息是 =&amp;gt; &quot; +&lt;span&gt; message);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DirectReceiverB&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;5、topic&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430130826063-1228303784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Topic转发信息主要是依据通配符，队列和交换机的绑定主要是依据一种模式(&lt;span&gt;通配符+字符串&lt;/span&gt;)，而当发送消息的时候，只有指定的RoutingKey和该模式相匹配的时候，消息才会被发送到该消息队列中。&lt;/p&gt;
&lt;p&gt;任何发送到Topic Exchange的消息都会被转发到所有关心RoutingKey中指定话题的Queue上&lt;/p&gt;
&lt;p&gt;（1）每个队列都有其关心的主题，所有的消息都带有一个“标题”(RoutingKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列&lt;/p&gt;
&lt;p&gt;（2）需要RoutingKey，也需要提前绑定Exchange与Queue&lt;/p&gt;
&lt;p&gt;（3）在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RoutingKey为”mq.log.error”的消息会被转发到该队列)&lt;/p&gt;
&lt;p&gt;（4）“#”表示0个或若干个关键字，“*”表示一个关键字。如“log.*”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但“log.#”能与上述两者都匹配&lt;/p&gt;
&lt;p&gt;（5）如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息&lt;/p&gt;
&lt;p&gt;生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('97d47d8b-63e6-4f52-a2c0-a758a4874b41')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_97d47d8b-63e6-4f52-a2c0-a758a4874b41&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_97d47d8b-63e6-4f52-a2c0-a758a4874b41&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('97d47d8b-63e6-4f52-a2c0-a758a4874b41',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_97d47d8b-63e6-4f52-a2c0-a758a4874b41&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.topic;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TopicSender {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sendTopicA(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.MY_TOPIC_EXCHANGE, MQField.MY_TOPIC_ROUTINGKEYA, message);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;TopicSender发送TopicA字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sendTopicB(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
            System.out.println(&lt;/span&gt;&quot;消息为空&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
        }

        rabbitTemplate.convertAndSend(MQField.MY_TOPIC_EXCHANGE, MQField.MY_TOPIC_ROUTINGKEYB, message);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;TopicSender发送TopicB字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; sendToMatchedTopic() {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        String routingKey &lt;/span&gt;= &quot;my_topic_routingkeyA.16&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模糊匹配MQField.MY_TOPIC_ROUTINGKEYA

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String routingKey = &quot;my_topic_routingkeyB.32&quot;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模糊匹配MQField.MY_TOPIC_ROUTINGKEYB&lt;/span&gt;
&lt;span&gt;
        String matchedKeys &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (MQField.MY_TOPIC_ROUTINGKEYA.contains(routingKey.split(&quot;\\.&quot;)[0&lt;span&gt;])) {
            matchedKeys &lt;/span&gt;= &quot;TopicReceiverA&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (MQField.MY_TOPIC_ROUTINGKEYB.contains(routingKey.split(&quot;\\.&quot;)[0&lt;span&gt;])) {
            matchedKeys &lt;/span&gt;= &quot;TopicReceiverB&quot;&lt;span&gt;;
        }

        String msg &lt;/span&gt;= &quot;message to matched receivers:&quot; +&lt;span&gt; matchedKeys;

        rabbitTemplate.convertAndSend(MQField.MY_TOPIC_EXCHANGE, routingKey, msg);

        isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        System.out.println(String.format(&lt;/span&gt;&quot;TopicSender发送字符串消息结果：%s&quot;&lt;span&gt;, isOK));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isOK;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TopicSender&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4822651c-ee0e-4da6-a4b5-63d00e29ff1c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_4822651c-ee0e-4da6-a4b5-63d00e29ff1c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4822651c-ee0e-4da6-a4b5-63d00e29ff1c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4822651c-ee0e-4da6-a4b5-63d00e29ff1c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4822651c-ee0e-4da6-a4b5-63d00e29ff1c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.topic;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TopicReceiverA {

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_TOPICA_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(String message) {
        System.out.println(&lt;/span&gt;&quot;TopicReceiverA接收到的字符串消息是 =&amp;gt; &quot; +&lt;span&gt; message);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TopicReceiverA&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;另一个消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('88c345f3-9f6f-4a5f-a2e6-b2949ff85daf')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_88c345f3-9f6f-4a5f-a2e6-b2949ff85daf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_88c345f3-9f6f-4a5f-a2e6-b2949ff85daf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('88c345f3-9f6f-4a5f-a2e6-b2949ff85daf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_88c345f3-9f6f-4a5f-a2e6-b2949ff85daf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.pubsub.topic;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;


@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TopicReceiverB {

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; MQField.MY_TOPICB_QUEUE)
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(String message) {
        System.out.println(&lt;/span&gt;&quot;TopicReceiverB接收到的字符串消息是 =&amp;gt; &quot; +&lt;span&gt; message);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TopicReceiverB&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;示例代码中，定义了两个topic，生产者通过调用sendToMatchedTopic方法，根据RoutingKey模糊匹配，将消息发送到匹配的队列上。&lt;/p&gt;
&lt;p&gt;到这里，发布订阅模式的介绍就结束了。我们再来总结下发布订阅模式下RabbitMQ消息队列主要工作流程。以Topic为例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者&lt;/strong&gt;&lt;br/&gt;1、获取一个连接（Connection）&lt;br/&gt;2、从连接（Connection）上获取一个信道（ Channel）&lt;br/&gt;3、声明一个交换器（ Exchange）&lt;br/&gt;4、声明1个或多个队列（Queue）&lt;br/&gt;5、把队列（Queue）绑定到交换器（Exchange）上&lt;br/&gt;6、向指定的交换器（Exchange）发送消息，消息路由到特定队列（Queue）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消费者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RabbitMQ消费者消费消息，支持推（push）模式和拉（pull）模式，这里以拉模式说明下流程。&lt;/p&gt;
&lt;p&gt;1、创建一个连接（Connection）&lt;br/&gt;2、启动MainLoop后台线程，通过连接（Connection）循环拉取消息&lt;br/&gt;3、处理并确认消息被消费&lt;/p&gt;
&lt;h4&gt;6、rpc&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201804/32361-20180430132152444-756405870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RPC调用流程说明：&lt;br/&gt;（1）当客户端启动的时候，它创建一个匿名独享的回调队列&lt;/p&gt;
&lt;p&gt;（2）在 RPC 请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性&lt;/p&gt;
&lt;p&gt;（3）将请求发送到一个 rpc_queue 队列中&lt;/p&gt;
&lt;p&gt;（4）服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。&lt;/p&gt;
&lt;p&gt;（5）客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用&lt;/p&gt;
&lt;p&gt;Callback queue回调队列，客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址reply_to。&lt;br/&gt;Correlation id关联标识，客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有correlation_id属性，这样客户端在回调队列中根据correlation_id字段的值就可以分辨此响应属于哪个请求。&lt;/p&gt;
&lt;p&gt;服务端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c368afe2-729f-473b-abd7-93b78bcfd582')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_c368afe2-729f-473b-abd7-93b78bcfd582&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c368afe2-729f-473b-abd7-93b78bcfd582&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c368afe2-729f-473b-abd7-93b78bcfd582',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c368afe2-729f-473b-abd7-93b78bcfd582&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.rpc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Consumer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.DefaultConsumer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.AMQP;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Envelope;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RPCServer {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; fib(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fib(n - 1) + fib(n - 2&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接运行此方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] argv) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;factory.setHost(&quot;localhost&quot;);&lt;/span&gt;
&lt;span&gt;
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            connection &lt;/span&gt;=&lt;span&gt; factory.newConnection();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Channel channel =&lt;span&gt; connection.createChannel();

            channel.queueDeclare(MQField.MY_RPC_QUEUE, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

            channel.basicQos(&lt;/span&gt;1&lt;span&gt;);

            System.out.println(&lt;/span&gt;&quot; [x] Awaiting RPC requests&quot;&lt;span&gt;);

            Consumer consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    AMQP.BasicProperties replyProps &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AMQP.BasicProperties
                            .Builder()
                            .correlationId(properties.getCorrelationId())
                            .build();

                    String response &lt;/span&gt;= &quot;&quot;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        String message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body, &quot;UTF-8&quot;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; Integer.parseInt(message);

                        System.out.println(&lt;/span&gt;&quot; [.] fib(&quot; + message + &quot;)&quot;&lt;span&gt;);
                        response &lt;/span&gt;+=&lt;span&gt; fib(n);

                        System.out.println(String.format(&lt;/span&gt;&quot;RPCServer计算fib数列应答：%s&quot;&lt;span&gt;, response));

                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException e) {
                        System.out.println(&lt;/span&gt;&quot; [.] &quot; +&lt;span&gt; e.toString());
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        channel.basicPublish(&lt;/span&gt;&quot;&quot;, properties.getReplyTo(), replyProps, response.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
                        channel.basicAck(envelope.getDeliveryTag(), &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RabbitMq consumer worker thread notifies the RPC server owner thread&lt;/span&gt;
                        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.notify();
                        }
                    }
                }
            };

            channel.basicConsume(MQField.MY_RPC_QUEUE, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, consumer);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait and be prepared to consume the message from RPC client.&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (consumer) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        consumer.wait();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IOException |&lt;span&gt; TimeoutException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException _ignore) {
                }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RPCServer&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3ababa97-e07c-47e6-8aef-fb1f0163cd09')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_3ababa97-e07c-47e6-8aef-fb1f0163cd09&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3ababa97-e07c-47e6-8aef-fb1f0163cd09&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3ababa97-e07c-47e6-8aef-fb1f0163cd09',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3ababa97-e07c-47e6-8aef-fb1f0163cd09&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.rpc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.power.demo.messaging.MQField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.DefaultConsumer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.AMQP;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Envelope;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.UUID;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ArrayBlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.BlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RPCClient {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Connection connection;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Channel channel;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String replyQueueName;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RPCClient() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, TimeoutException {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;factory.setHost(&quot;localhost&quot;);&lt;/span&gt;
&lt;span&gt;
        connection &lt;/span&gt;=&lt;span&gt; factory.newConnection();
        channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

        replyQueueName &lt;/span&gt;=&lt;span&gt; channel.queueDeclare().getQueue();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call(String message) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String corrId =&lt;span&gt; UUID.randomUUID().toString();

        AMQP.BasicProperties props &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AMQP.BasicProperties
                .Builder()
                .correlationId(corrId)
                .replyTo(replyQueueName)
                .build();

        channel.basicPublish(&lt;/span&gt;&quot;&quot;, MQField.MY_RPC_QUEUE, props, message.getBytes(&quot;UTF-8&quot;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; BlockingQueue&amp;lt;String&amp;gt; response = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;String&amp;gt;(1&lt;span&gt;);

        channel.basicConsume(replyQueueName, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (properties.getCorrelationId().equals(corrId)) {
                    response.offer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(body, &quot;UTF-8&quot;&lt;span&gt;));
                }
            }
        });

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.take();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; close() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        connection.close();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接运行此方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] argv) {
        RPCClient fibonacciRpc &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String response &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            fibonacciRpc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RPCClient();

            System.out.println(&lt;/span&gt;&quot; [x] Requesting fib(10)&quot;&lt;span&gt;);
            response &lt;/span&gt;= fibonacciRpc.call(&quot;10&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot; [.] Got '&quot; + response + &quot;'&quot;&lt;span&gt;);
            System.out.println(String.format(&lt;/span&gt;&quot;RPCClient得到计算fib数列应答：%s&quot;&lt;span&gt;, response));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IOException | TimeoutException |&lt;span&gt; InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fibonacciRpc != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    fibonacciRpc.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException _ignore) {
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;RPCClient&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;示例代码我这里直接改造了一下官方的demo代码。启动RPCServer，再运行RPCClient就可以看到RPC调用结果了。&lt;/p&gt;
&lt;h2&gt; 三、常见问题&lt;/h2&gt;
&lt;h4&gt;1、幂等性&lt;/h4&gt;
&lt;p&gt;生产环境各种业务系统出现重复消息是不可避免的，因为不能保证生产者不发送重复消息。&lt;/p&gt;
&lt;p&gt;对于读操作而言，重复消息可能无害，但是对于写操作，重复消息容易造成业务灾难，比如相同消息多次扣减库存，多次支付请求扣款等。&lt;/p&gt;
&lt;p&gt;有一种情况也会造成重复消息，就是RabbitMQ对设置autoAck=false之后没有被Ack的消息是不会清除掉的，消费者可以多次重复消费。&lt;/p&gt;
&lt;p&gt;我个人认为RabbitMQ只是消息传递的载体，要保证幂等性，还是需要在消费者业务逻辑上下功夫。&lt;/p&gt;
&lt;h4&gt;2、有序消息&lt;/h4&gt;
&lt;p&gt;我碰到过某厂有一个开发团队通过Kafka来实现有序队列，因为发送的消息有先后依赖关系，需要消费者收到多个消息保存起来最后聚合后一起处理业务逻辑。&lt;/p&gt;
&lt;p&gt;但是，其实大部分业务场景下我们都不需要消息有先后依赖关系，因为有序队列产生依赖关系，后续消费很容易造成各种处理难题。&lt;/p&gt;
&lt;p&gt;归根结底，我认为需要有序消息的业务系统在设计上就是不合理的，争取在设计上规避才好。当然良好的设计需要丰富的经验和优化，以及妥协。&lt;/p&gt;
&lt;h4&gt;3、高可用&lt;/h4&gt;
&lt;p&gt;RabbitMQ支持集群，模式主要可分为三种：单一模式、普通模式和镜像模式。&lt;/p&gt;
&lt;p&gt;RabbitMQ支持弹性部署，在业务高峰期间可通过集群弹性部署支撑业务系统。&lt;/p&gt;
&lt;p&gt;RabbitMQ支持消息持久化，如果队列服务器出现问题，消息做了持久化，后续恢复正常，消息数据不丢失不会影响正常业务流程。&lt;/p&gt;
&lt;p&gt;RabbitMQ还有很多高级特性，比如发布确认和事务等，虽然可能会降低性能，但是增强了可靠性。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.rabbitmq.com/&quot; href=&quot;http://www.rabbitmq.com/&quot; target=&quot;_blank&quot;&gt;http://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx&quot; href=&quot;https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/dubing/p/4017613.html&quot; href=&quot;http://www.cnblogs.com/dubing/p/4017613.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/dubing/p/4017613.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/super_rd/article/details/70238869&quot; href=&quot;https://blog.csdn.net/super_rd/article/details/70238869&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/super_rd/article/details/70238869&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/joeyon1985/article/details/39429117&quot; href=&quot;https://blog.csdn.net/joeyon1985/article/details/39429117&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/joeyon1985/article/details/39429117&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/saltlight-wangchao/p/6214334.html&quot; href=&quot;http://www.cnblogs.com/saltlight-wangchao/p/6214334.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/saltlight-wangchao/p/6214334.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/binyue/p/4763766.html&quot; href=&quot;http://www.cnblogs.com/binyue/p/4763766.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/binyue/p/4763766.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://my.oschina.net/u/2948566/blog/1624963&quot; href=&quot;https://my.oschina.net/u/2948566/blog/1624963&quot; target=&quot;_blank&quot;&gt;https://my.oschina.net/u/2948566/blog/1624963&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 15:00:00 +0000</pubDate>
<dc:creator>JeffWong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jeffwongishandsome/p/spring-boot-integrate-messaging-queue-practise.html</dc:identifier>
</item>
<item>
<title>MLDS笔记：Optimization - cherrychenlee</title>
<link>http://www.cnblogs.com/cherrychenlee/p/8974821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherrychenlee/p/8974821.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;当函数空间覆盖到目标函数时，如何通过优化调整神经网络的参数找到这个目标函数呢？&lt;br/&gt;深度学习中的损失函数是非凸的，非凸优化是个NP-hard问题，如何通过梯度下降来解决这个问题呢？&lt;br/&gt;注意，不同于learning，这里只讨论基于训练集的optimization问题，不考虑在测试集上的表现。&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对一个神经网络来说至少存在指数级个数的全局最小值点，因为你将某一层的神经元重新排列后并不改变损失函数值。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430214201047-426739510.png&quot; title=&quot;图0-1&quot; alt=&quot;图0-1&quot;/&gt;&lt;br/&gt;如图0-1所示，线性加权这２组参数所得的loss值不见得变小，说明损失函数是个非凸函数。&lt;br/&gt;但是“非凸”不完全等于“困难”。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430214800866-2007901635.png&quot; title=&quot;图0-2&quot; alt=&quot;图0-2&quot;/&gt;&lt;br/&gt;通常来说，非凸函数优化起来很困难，难以用梯度下降找到全局最小值，如图0-2左边所示。&lt;br/&gt;但深度学习中定义的非凸损失函数是否有可能用梯度下降找到全局最小值呢？如图0-2右边所示，有无可能深度学习中定义的非凸损失函数有很多的全局最小值，却没有局部最小值呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当梯度为０时考虑借助Hessian矩阵进行分析。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430223656071-1607273111.png&quot; title=&quot;图1-1&quot; alt=&quot;图1-1&quot;/&gt;&lt;br/&gt;如图1-1所示，人们通常认为训练停止是因为参数到达了关键点，即梯度为０的点。这个点可能是局部最小值点，也可能是鞍点。&lt;br/&gt;&lt;strong&gt;什么是Hessian矩阵？&lt;/strong&gt;&lt;br/&gt;二阶导数值构成的矩阵。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430224002183-329033219.png&quot; title=&quot;图1-2&quot; alt=&quot;图1-2&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430224048116-361567873.png&quot; title=&quot;图1-3&quot; alt=&quot;图1-3&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;牛顿法&quot;&gt;&lt;span&gt;1.1 牛顿法　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430224529444-882479463.png&quot; title=&quot;图1-1.1&quot; alt=&quot;图1-1.1&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430224600001-466789958.png&quot; title=&quot;图1-1.2&quot; alt=&quot;图1-1.2&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430224605906-2030722886.png&quot; title=&quot;图1-1.3&quot; alt=&quot;图1-1.3&quot;/&gt;&lt;br/&gt;牛顿法是一步到位，梯度下降法是每次走一小步，走许多次。&lt;br/&gt;牛顿法存在的问题：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;H不可逆时，无法使用此种方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当参数量很大时，计算Ｈ以及Ｈ的逆矩阵代价很大；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;梯度为０的点有可能是局部最小值点，有可能是鞍点，也有可能是局部最大值点，牛顿法对此并不区分。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，牛顿法不适合用在深度学习的问题中。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;hessian矩阵的使用&quot;&gt;&lt;span&gt;1.2 Hessian矩阵的使用　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是特征值、特征向量？&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430225507903-49540810.png&quot; title=&quot;图1-2.1&quot; alt=&quot;图1-2.1&quot;/&gt;&lt;br/&gt;&lt;strong&gt;什么是正定、半正定、负定、半负定矩阵？&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430225515715-49566295.png&quot; title=&quot;图1-2.2&quot; alt=&quot;图1-2.2&quot;/&gt;&lt;br/&gt;利用Hessian矩阵帮助区分关键点属性，是局部最小值点，是鞍点，还是局部最大值点？&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430225559664-2137464729.png&quot; title=&quot;图1-2.3&quot; alt=&quot;图1-2.3&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430225735772-1199216457.png&quot; title=&quot;图1-2.4&quot; alt=&quot;图1-2.4&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180430225742096-110909960.png&quot; title=&quot;图1-2.5&quot; alt=&quot;图1-2.5&quot;/&gt;&lt;br/&gt;总之，训练停止不一定是到达局部最小值点，可以通过Hessian矩阵进行验证，也可以观察梯度的L2-norm值进行确定。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 13:56:00 +0000</pubDate>
<dc:creator>cherrychenlee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cherrychenlee/p/8974821.html</dc:identifier>
</item>
<item>
<title>Vue2.0搭建脚手架流程 - 小周sri的码农</title>
<link>http://www.cnblogs.com/zhoulifeng/p/8974879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoulifeng/p/8974879.html</guid>
<description>&lt;h2 id=&quot;articleHeader0&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Vue.js是一套构建用户界面的渐进式框架。&lt;br/&gt;Vue 只关注视图层，采用自底向上增量开发的设计。&lt;br/&gt;Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader2&quot;&gt;安装node.js&lt;/h2&gt;
&lt;p&gt;从&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot;&gt;node官网&lt;/a&gt;下载并安装node，安装步骤很简单，只要一路“next”就可以了。&lt;br/&gt;安装完成后，打开命令行工具输入命令&lt;strong&gt;&lt;em&gt;node -v&lt;/em&gt;&lt;/strong&gt;，如下图，如果出现对应版本号，就说明安装成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188378/201804/1188378-20180430213415440-829517319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们所需要的npm包管理器，是集成在node中的，所以，直接输入&lt;strong&gt;&lt;em&gt;npm -v&lt;/em&gt;&lt;/strong&gt;就会如下图所示，显示出npm的版本信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188378/201804/1188378-20180430213458191-1169540350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里node的环境已经安装完了,npm包管理工具也有了，但是由于npm的有些资源被墙，为了更快更稳定,所以我们需要切换到淘宝的npm镜像——cnpm。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader3&quot;&gt;安装cnpm&lt;/h2&gt;
&lt;p&gt;点击进入淘宝的&lt;a href=&quot;http://npm.taobao.org/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;cnpm&lt;/a&gt;网站,里面有详细的配置方法。&lt;br/&gt;或者直接在命令行输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;pln&quot;&gt;$ npm install &lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;g cnpm &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;registry&lt;span class=&quot;pun&quot;&gt;=&lt;span class=&quot;pln&quot;&gt;https&lt;span class=&quot;pun&quot;&gt;://&lt;span class=&quot;pln&quot;&gt;registry&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;npm&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;taobao&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;org&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后等待，安装完成。&lt;/p&gt;
&lt;p&gt;输入cnpm -v，可以查看当前cnpm版本，这个和npm的版本还是不一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188378/201804/1188378-20180430213754416-1520644652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用cnpm的方法就是，需要用到npm的地方直接使用cnpm替换就可以了&lt;/p&gt;

&lt;h2 id=&quot;articleHeader4&quot;&gt;vue安装&lt;/h2&gt;
&lt;h2 id=&quot;articleHeader5&quot;&gt;安装vue-cli脚手架构建工具&lt;/h2&gt;
&lt;p&gt;vue-cli 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# 全局安装 vue-&lt;span&gt;cli
$ cnpm install &lt;/span&gt;--&lt;span&gt;global&lt;/span&gt; vue-cli&lt;br/&gt;或者&lt;br/&gt;$ cnpm install vue-cli -g
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;articleHeader6&quot;&gt;创建一个基于 webpack 模板的新项目&lt;/h2&gt;
&lt;p&gt;要创建项目，首先我们要选定目录，然后再命令行中把目录转到选定的目录。可以使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#my-&lt;span&gt;project为自定义项目名
$ vue init webpack my&lt;/span&gt;-project
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会出现下面这些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188378/201804/1188378-20180430214528970-1095148846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是项目的名称不能大写，不然会报错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Project name (my-project) # 项目名称（我的项目）&lt;/p&gt;
&lt;p&gt;Project description (A Vue.js project) # 项目描述一个Vue.js 项目&lt;/p&gt;
&lt;p&gt;Author 作者（你的名字）&lt;/p&gt;
&lt;p&gt;Install vue-router? (Y/n) # 是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）&lt;/p&gt;
&lt;p&gt;Use ESLint to lint your code? (Y/n) # 使用 ESLint 到你的代码？ （Y [ yes ] / N [ no ]）&lt;/p&gt;
&lt;p&gt;Pick an ESLint preset (Use arrow keys) # 选择一个预置ESLint（使用箭头键）&lt;/p&gt;
&lt;p&gt;Setup unit tests with Karma + Mocha? (Y/n) # 设置单元测Karma + Mocha？ （Y/ N）&lt;/p&gt;
&lt;p&gt;Setup e2e tests with Nightwatch? (Y/n) # 设置端到端测试，Nightwatch？ （Y/ N）&lt;/p&gt;
&lt;p&gt;当然这些都看你自己个人的情况，我这里是全选了是。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化一个项目，进入你这个项目的目录&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd  my-project&lt;br/&gt;cnpm install   初始化
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;articleHeader8&quot;&gt;运行项目&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ cnpm run dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行这一步只要出现下面就成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188378/201804/1188378-20180430214750964-222738012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在浏览器输入  http://localhost:8081就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188378/201804/1188378-20180430214901718-1506855122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果看到这个界面，说明配置成功。&lt;/p&gt;
&lt;p&gt;如果喜欢，多多关注一下&lt;/p&gt;

</description>
<pubDate>Mon, 30 Apr 2018 13:51:00 +0000</pubDate>
<dc:creator>小周sri的码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoulifeng/p/8974879.html</dc:identifier>
</item>
<item>
<title>聊聊jstack的工作原理 - 清泉^_^</title>
<link>http://www.cnblogs.com/qingquanzi/p/8974850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingquanzi/p/8974850.html</guid>
<description>&lt;h3&gt;实现一个jstack&lt;/h3&gt;
&lt;p&gt;在聊Jstack得工作原理前呢，不如让我们先写一个简单的jstack玩玩。不用怕，很简单的,就几行代码的事，看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyJstack {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        VirtualMachine virtualMachine &lt;/span&gt;= VirtualMachine.attach(&quot;6361&quot;&lt;span&gt;);
        HotSpotVirtualMachine hotSpotVirtualMachine &lt;/span&gt;=&lt;span&gt; (HotSpotVirtualMachine)virtualMachine;
        InputStream inputStream &lt;/span&gt;= hotSpotVirtualMachine.remoteDataDump(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[]{});

        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buff = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[256&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; len;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            len &lt;/span&gt;=&lt;span&gt; inputStream.read(buff);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len &amp;gt; 0&lt;span&gt;) {
                String respone &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(buff, 0, len, &quot;UTF-8&quot;&lt;span&gt;);
                System.out.print(respone);
            }
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(len &amp;gt; 0&lt;span&gt;);

        inputStream.close();
        virtualMachine.detach();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很简单吧，贴到你的开发环境里，运行就好了，别忘了把6361这个进程号换成你自己的Java进程号哦。&lt;/p&gt;
&lt;h3&gt;实现原理&lt;/h3&gt;
&lt;p&gt;jstack有两种实现方式，一种是基于attach api,其实现可以在tools.jar里找到；另一种是基于SA的实现，它被放在了sa-jdi.jar里。如果你通过idea搜索Jstack类，你会看到tools.jar和sa-jdi.jar各有一个Jstack类。&lt;/p&gt;
&lt;p&gt;本文呢，就通过分析attch api的源码，来了解jstack的工作原理。&lt;/p&gt;
&lt;h4&gt;jstack本地源码实现&lt;/h4&gt;
&lt;p&gt;我们来看一下HotSpotVirtualMachine的remoteDataDump方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; InputStream remoteDataDump(Object... var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.executeCommand(&quot;threaddump&quot;&lt;span&gt;, var1);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;他是在执行一个叫threaddump的命令。沿着这个executeCommand方法继续往里追，会发现他是调用了如下方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
InputStream execute(String var1, Object... var2) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AgentLoadException, IOException {
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; var2.length &amp;lt;= 3&lt;span&gt;;

        String var3;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.path == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IOException(&quot;Detached from target VM&quot;&lt;span&gt;);
            }

            var3 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.path;
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; var4 =&lt;span&gt; socket();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            connect(var4, var3);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException var9) {
            close(var4);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var9;
        }

        IOException var5 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.writeString(var4, &quot;1&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.writeString(var4, var1);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;var1参数就是我们的threaddump指令，不难看出，这个方法是建立了一个socket连接，然后将threaddump指令发送给另一端，即我们要检查的jvm进程。&lt;/p&gt;
&lt;p&gt;注意：限于篇幅我并没有贴整个方法代码。execute是HotSpotVirtualMachine的抽象方法，不同平台的jdk有不同的execute方法的实现，我这里的代码是mac下的execute实现，位于BsdVirtualMachine类中。&lt;/p&gt;
&lt;p&gt;通过jtack本地源代码，我们大致可以粗略的认为：jstack就是通过与指定的jvm进程建立socket连接，然后发送指令，最后将jvm进程返回的内容打印出来。&lt;/p&gt;
&lt;h4&gt;JVM的源码实现&lt;/h4&gt;
&lt;p&gt;了解了jstack的本地源码，我们在看看jvm进程是如何处理的。&lt;/p&gt;
&lt;p&gt;当我们使用Java命令启动jvm进程时，Java命令会加载虚拟机共享库，然后执行共享库里的JNI_CreateJavaVM方法完成虚拟机的创建，在JNI_CreateJavaVM方法里会调用如下代码，完成具体的一个创建过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
result = Threads::create_vm((JavaVMInitArgs*) args, &amp;amp;can_try_again);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你有心，或许会留意到，在你启动一个jvm进程时，即便你什么线程也没创建，你用jstack查看还是有很多的线程，如：Signal Dispatcher，VM Thread，Attach Listener等等。当过阅读本文，你会了解到这三个线程的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;01 VM Thread线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Threads::create_vm这个方法很长，接下来咱们跳出一些重要的段落，来分析分析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create the VMThread&lt;/span&gt;
  { TraceTime timer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start VMThread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, TraceStartupTime);
    VMThread::create();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Thread对象&lt;/span&gt;
    Thread* vmthread =&lt;span&gt; VMThread::vm_thread();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!os::create_thread(vmthread, os::vm_thread))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用操作系统api创建线程&lt;/span&gt;
      vm_exit_during_initialization(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot create VM thread. Out of system resources.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait for the VM thread to become ready, and VMThread::run to initialize
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Monitors can have spurious returns, must always check another state flag&lt;/span&gt;
&lt;span&gt;    {
      MutexLocker ml(Notify_lock);
      os::start_thread(vmthread);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
      &lt;span&gt;while&lt;/span&gt; (vmthread-&amp;gt;active_handles() ==&lt;span&gt; NULL) {
        Notify_lock&lt;/span&gt;-&amp;gt;&lt;span&gt;wait();
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过注释，你也知道，这一段代码是从来创建VM Thread线程的。VMThread::create()完成了对现成的命名工作，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; VMThread::create() {
  assert(vm_thread() &lt;/span&gt;== NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;we can only allocate one VMThread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  _vm_thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VMThread();

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create VM operation queue&lt;/span&gt;
  _vm_queue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VMOperationQueue();
  guarantee(_vm_queue &lt;/span&gt;!= NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;just checking&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

  _terminate_lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Monitor(Mutex::safepoint, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VMThread::_terminate_lock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (UsePerfData) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; jvmstat performance counters&lt;/span&gt;
    Thread* THREAD =&lt;span&gt; Thread::current();
    _perf_accumulated_vm_operation_time &lt;/span&gt;=&lt;span&gt;
                 PerfDataManager::create_counter(SUN_THREADS, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vmOperationTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                                 PerfData::U_Ticks, CHECK);
  }
}


VMThread::VMThread() : NamedThread() {
  set_name(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VM Thread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过new VMThread()创建线程对象，在VMThread的构造方法里将线程命名成VM Thread，这就是我们jstack看到的VM Thread线程,同时还为这个线程创建了一个叫VMOperationQueue的队列。&lt;/p&gt;
&lt;p&gt;至于VM Thread线程的作用，我们留到最后再说。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;02 Signal Dispatcher线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续沿着 Threads::create_vm方法往下看，我们会看到如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Signal Dispatcher needs to be started before VMInit event is posted&lt;/span&gt;
  os::signal_init();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这一句代码实现了Signal Dispatcher线程的创建，进入到signal_init()方法看看:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; os::signal_init() {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ReduceSignalUsage) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Setup JavaThread for processing signals&lt;/span&gt;
&lt;span&gt;    EXCEPTION_MARK;
    Klass&lt;/span&gt;* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, CHECK);
    instanceKlassHandle klass (THREAD, k);
    instanceHandle thread_oop &lt;/span&gt;= klass-&amp;gt;&lt;span&gt;allocate_instance_handle(CHECK);

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; thread_name[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Signal Dispatcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    Handle &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; =&lt;span&gt; java_lang_String::create_from_str(thread_name, CHECK);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize thread_oop to put it into the system threadGroup&lt;/span&gt;
&lt;span&gt;    Handle thread_group (THREAD, Universe::system_thread_group());
    JavaValue result(T_VOID);
    JavaCalls::call_special(&lt;/span&gt;&amp;amp;&lt;span&gt;result, thread_oop,
                           klass,
                           vmSymbols::object_initializer_name(),
                           vmSymbols::threadgroup_string_void_signature(),
                           thread_group,
                           &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,
                           CHECK);

    KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
    JavaCalls::call_special(&lt;/span&gt;&amp;amp;&lt;span&gt;result,
                            thread_group,
                            group,
                            vmSymbols::add_method_name(),
                            vmSymbols::thread_void_signature(),
                            thread_oop,         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ARG 1&lt;/span&gt;
&lt;span&gt;                            CHECK);

    os::signal_init_pd();

    { MutexLocker mu(Threads_lock);
      JavaThread&lt;/span&gt;* signal_thread = &lt;span&gt;new&lt;/span&gt; JavaThread(&amp;amp;&lt;span&gt;signal_thread_entry);

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; At this point it may be possible that no osthread was created for the
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JavaThread due to lack of memory. We would have to throw an exception
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; in that case. However, since this must work and we do not allow
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exceptions anyway, check and abort if this fails.&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (signal_thread == NULL || signal_thread-&amp;gt;osthread() ==&lt;span&gt; NULL) {
        vm_exit_during_initialization(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java.lang.OutOfMemoryError&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unable to create new native thread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }

      java_lang_Thread::set_thread(thread_oop(), signal_thread);
      java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);
      java_lang_Thread::set_daemon(thread_oop());

      signal_thread&lt;/span&gt;-&amp;gt;&lt;span&gt;set_threadObj(thread_oop());
      Threads::add(signal_thread);
      Thread::start(signal_thread);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Handle ^BREAK&lt;/span&gt;
&lt;span&gt;    os::signal(SIGBREAK, os::user_handler());
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这个方法里，我们可以看到要创建的线程名字:Signal Dispatcher，以及线程启动后调用的方法signal_thread_entry。（方法较长，看重点就好，没必要每句话都扣清楚）。&lt;/p&gt;
&lt;p&gt;有了对上边代码的分析，我们只需要看看signal_thread_entry方法，就知道Signal Dispatcher线程的作用了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; signal_thread_entry(JavaThread*&lt;span&gt; thread, TRAPS) {
  os::set_priority(thread, NearMaxPriority);
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sig;
    {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; FIXME : Currently we have not decieded what should be the status
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         for this java thread blocked here. Once we decide about
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         that we should fix this.&lt;/span&gt;
      sig = os::signal_wait();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待获取信号&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sig ==&lt;span&gt; os::sigexitnum_pd()) {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Terminate the signal thread&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (sig) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SIGBREAK: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if the signal is a trigger to start the Attach Listener - in that
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; case don't print stack traces.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!DisableAttachMechanism &amp;amp;&amp;amp;&lt;span&gt; AttachListener::is_init_trigger()) {
          &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Print stack traces
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Any SIGBREAK operations added here should make sure to flush
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the output stream (e.g. tty-&amp;gt;flush()) after output.  See 4803766.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Each module also prints an extra carriage return after its output.&lt;/span&gt;
&lt;span&gt;        VM_PrintThreads op;
        VMThread::execute(&lt;/span&gt;&amp;amp;&lt;span&gt;op);
        VM_PrintJNI jni_op;
        VMThread::execute(&lt;/span&gt;&amp;amp;&lt;span&gt;jni_op);
        VM_FindDeadlocks op1(tty);
        VMThread::execute(&lt;/span&gt;&amp;amp;&lt;span&gt;op1);
        Universe::print_heap_at_SIGBREAK();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (PrintClassHistogram) {
          VM_GC_HeapInspection op1(gclog_or_tty, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; force full GC before heap inspection &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
          VMThread::execute(&lt;/span&gt;&amp;amp;&lt;span&gt;op1);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (JvmtiExport::should_post_data_dump()) {
          JvmtiExport::post_data_dump();
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个方法里调用os::signal_wait()获取传给该jvm进程的信号，然后对信号进行处理。&lt;/p&gt;
&lt;p&gt;说下case SIGBREAK里的处理逻辑，当接收到SIGBREAK信号时，会先判断是否禁止Attach机制，如果没有禁止，会调用AttachListener::is_init_trigger()方法触发Attach Listener线程的初始化.如果attach机制被禁用，则会创建VM_PrintThreads、VM_PrintJNI、VM_FindDeadlocks等代表某一个操作的对象，通过VMThread::execute()方法扔到VM Thread线程的VMOperationQueue队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;03 Attach Listener线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续沿着 Threads::create_vm方法往下看，在紧挨着启动Signal Dispatcher线程的下边，就是启动Attach Listener线程的语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start Attach Listener if +StartAttachListener or it can't be started lazily&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;DisableAttachMechanism) {
    AttachListener::vm_start();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (StartAttachListener ||&lt;span&gt; AttachListener::init_at_startup()) {
      AttachListener::init();
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点就在AttachListener::init()方法里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Starts the Attach Listener thread&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; AttachListener::init() {
  EXCEPTION_MARK;
  Klass&lt;/span&gt;* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, CHECK);
  instanceKlassHandle klass (THREAD, k);
  instanceHandle thread_oop &lt;/span&gt;= klass-&amp;gt;&lt;span&gt;allocate_instance_handle(CHECK);

  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; thread_name[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Attach Listener&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  Handle &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; =&lt;span&gt; java_lang_String::create_from_str(thread_name, CHECK);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize thread_oop to put it into the system threadGroup&lt;/span&gt;
&lt;span&gt;  Handle thread_group (THREAD, Universe::system_thread_group());
  JavaValue result(T_VOID);
  JavaCalls::call_special(&lt;/span&gt;&amp;amp;&lt;span&gt;result, thread_oop,
                       klass,
                       vmSymbols::object_initializer_name(),
                       vmSymbols::threadgroup_string_void_signature(),
                       thread_group,
                       &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,
                       THREAD);

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (HAS_PENDING_EXCEPTION) {
    tty&lt;/span&gt;-&amp;gt;print_cr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception in VM (AttachListener::init) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    java_lang_Throwable::print(PENDING_EXCEPTION, tty);
    tty&lt;/span&gt;-&amp;gt;&lt;span&gt;cr();

    CLEAR_PENDING_EXCEPTION;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }

  KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
  JavaCalls::call_special(&lt;/span&gt;&amp;amp;&lt;span&gt;result,
                        thread_group,
                        group,
                        vmSymbols::add_method_name(),
                        vmSymbols::thread_void_signature(),
                        thread_oop,             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ARG 1&lt;/span&gt;
&lt;span&gt;                        THREAD);

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (HAS_PENDING_EXCEPTION) {
    tty&lt;/span&gt;-&amp;gt;print_cr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception in VM (AttachListener::init) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    java_lang_Throwable::print(PENDING_EXCEPTION, tty);
    tty&lt;/span&gt;-&amp;gt;&lt;span&gt;cr();

    CLEAR_PENDING_EXCEPTION;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }

  { MutexLocker mu(Threads_lock);
    JavaThread&lt;/span&gt;* listener_thread = &lt;span&gt;new&lt;/span&gt; JavaThread(&amp;amp;&lt;span&gt;attach_listener_thread_entry);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check that thread and osthread were created&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (listener_thread == NULL || listener_thread-&amp;gt;osthread() ==&lt;span&gt; NULL) {
      vm_exit_during_initialization(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java.lang.OutOfMemoryError&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unable to create new native thread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    java_lang_Thread::set_thread(thread_oop(), listener_thread);
    java_lang_Thread::set_daemon(thread_oop());

    listener_thread&lt;/span&gt;-&amp;gt;&lt;span&gt;set_threadObj(thread_oop());
    Threads::add(listener_thread);
    Thread::start(listener_thread);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;hljs php&quot;&gt;
我们可以通过代码看出其创建了一个叫Attach Listener的线程，线程执行的逻辑封装在了attach_listener_thread_entry方法里。
&lt;/pre&gt;
&lt;p&gt;Attach Listener线程的作用，我们看看attach_listener_thread_entry方法便知:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; attach_listener_thread_entry(JavaThread*&lt;span&gt; thread, TRAPS) {
  os::set_priority(thread, NearMaxPriority);

  thread&lt;/span&gt;-&amp;gt;&lt;span&gt;record_stack_base_and_size();

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AttachListener::pd_init() != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  AttachListener::set_initialized();

  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
    AttachOperation&lt;/span&gt;* op = AttachListener::dequeue();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从队列里获取操作对象&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (op ==&lt;span&gt; NULL) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dequeue failed or shutdown&lt;/span&gt;
&lt;span&gt;    }

    ResourceMark rm;
    bufferedStream st;
    jint res &lt;/span&gt;=&lt;span&gt; JNI_OK;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; handle special detachall operation&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (strcmp(op-&amp;gt;name(), AttachOperation::detachall_operation_name()) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      AttachListener::detachall();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; find the function to dispatch too&lt;/span&gt;
      AttachOperationFunctionInfo* info =&lt;span&gt; NULL;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; funcs[i].name != NULL; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* name =&lt;span&gt; funcs[i].name;
        assert(strlen(name) &lt;/span&gt;&amp;lt;= AttachOperation::name_length_max, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;operation &amp;lt;= name_length_max&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strcmp(op-&amp;gt;name(), name) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
          info &lt;/span&gt;= &amp;amp;&lt;span&gt;(funcs[i]);
          &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
      }

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; check for platform dependent attach operation&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (info ==&lt;span&gt; NULL) {
        info &lt;/span&gt;= AttachListener::pd_find_operation(op-&amp;gt;&lt;span&gt;name());
      }

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (info !=&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dispatch to the function that implements this operation&lt;/span&gt;
        res = (info-&amp;gt;func)(op, &amp;amp;st);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行操作对象&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        st.print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Operation %s not recognized!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, op-&amp;gt;&lt;span&gt;name());
        res &lt;/span&gt;=&lt;span&gt; JNI_ERR;
      }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; operation complete - send result and output to client&lt;/span&gt;
    op-&amp;gt;complete(res, &amp;amp;&lt;span&gt;st);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;hljs php&quot;&gt;
&lt;br/&gt;方法很长，我把重点挑出来分析。
&lt;/pre&gt;
&lt;p&gt;首先我们看看调用AttachListener::pd_init()完了什么：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; AttachListener::pd_init() {
  JavaThread&lt;/span&gt;* thread =&lt;span&gt; JavaThread::current();
  ThreadBlockInVM tbivm(thread);

  thread&lt;/span&gt;-&amp;gt;&lt;span&gt;set_suspend_equivalent();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cleared by handle_special_suspend_equivalent_condition() or
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; java_suspend_self() via check_and_wait_while_suspended()&lt;/span&gt;

  &lt;span&gt;int&lt;/span&gt; ret_code =&lt;span&gt; LinuxAttachListener::init();

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; were we externally suspended while we were waiting?&lt;/span&gt;
  thread-&amp;gt;&lt;span&gt;check_and_wait_while_suspended();

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret_code;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; LinuxAttachListener::init() {
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; path[UNIX_PATH_MAX];          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; socket file&lt;/span&gt;
  &lt;span&gt;char&lt;/span&gt; initial_path[UNIX_PATH_MAX];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; socket file during setup&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; listener;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; listener socket (file descriptor)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; register function to cleanup&lt;/span&gt;
&lt;span&gt;  ::atexit(listener_cleanup);

  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = snprintf(path, UNIX_PATH_MAX, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s/.java_pid%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                   os::get_temp_directory(), os::current_process_id());
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)UNIX_PATH_MAX) {
    n &lt;/span&gt;= snprintf(initial_path, UNIX_PATH_MAX, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s.tmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, path);
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;= (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)UNIX_PATH_MAX) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create the listener socket&lt;/span&gt;
  listener = ::socket(PF_UNIX, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建套接字&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (listener == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bind socket&lt;/span&gt;
  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_un addr;
  addr.sun_family &lt;/span&gt;=&lt;span&gt; AF_UNIX;
  strcpy(addr.sun_path, initial_path);
  ::unlink(initial_path);
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; res = ::bind(listener, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;addr, &lt;span&gt;sizeof&lt;/span&gt;(addr));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定地址&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (res == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
    ::close(listener);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; put in listen mode, set permissions, and rename into place&lt;/span&gt;
  res = ::listen(listener, &lt;span&gt;5&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起监听&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (res == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      RESTARTABLE(::chmod(initial_path, S_IREAD&lt;/span&gt;|&lt;span&gt;S_IWRITE), res);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
          res &lt;/span&gt;=&lt;span&gt; ::rename(initial_path, path);
      }
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
    ::close(listener);
    ::unlink(initial_path);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  }
  set_path(path);
  set_listener(listener);

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不难发现，AttachListener::pd_init()方法又调用了LinuxAttachListener::init()方法，完成了对套接字的创建和监听。这与jstack本地代码建立socket连接发送命令，不谋而合。&lt;/p&gt;
&lt;p&gt;再就是有一个for死循环，不停地调用AttachOperation* op = AttachListener::dequeue();获取操作对象。如果进入到AttachListener::dequeue()方法看一看，其实就是在读上边监听的套接字，我这里就不贴源码了。&lt;/p&gt;
&lt;p&gt;在这个死循环里，我们重点看看如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; find the function to dispatch too&lt;/span&gt;
      AttachOperationFunctionInfo* info =&lt;span&gt; NULL;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; funcs[i].name != NULL; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* name =&lt;span&gt; funcs[i].name;
        assert(strlen(name) &lt;/span&gt;&amp;lt;= AttachOperation::name_length_max, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;operation &amp;lt;= name_length_max&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strcmp(op-&amp;gt;name(), name) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
          info &lt;/span&gt;= &amp;amp;&lt;span&gt;(funcs[i]);
          &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
      }

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; check for platform dependent attach operation&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (info ==&lt;span&gt; NULL) {
        info &lt;/span&gt;= AttachListener::pd_find_operation(op-&amp;gt;&lt;span&gt;name());
      }

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (info !=&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dispatch to the function that implements this operation&lt;/span&gt;
        res = (info-&amp;gt;func)(op, &amp;amp;st);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调动方法&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        st.print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Operation %s not recognized!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, op-&amp;gt;&lt;span&gt;name());
        res &lt;/span&gt;=&lt;span&gt; JNI_ERR;
      }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; operation complete - send result and output to client&lt;/span&gt;
    op-&amp;gt;complete(res, &amp;amp;st);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个for循环会遍历funcs数组，然后根据从队列里拿到的AttachOperation对象的name来找到一个匹配的AttachOperationFunctionInfo对象，然后调用其func方法。&lt;/p&gt;
&lt;p&gt;看到这里你或许很多疑惑，当然看看funcs数组里的东西，就开朗了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; AttachOperationFunctionInfo funcs[] =&lt;span&gt; {
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentProperties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  get_agent_properties },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datadump&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,         data_dump },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dumpheap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,         dump_heap },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,             JvmtiExport::load_agent_library },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,       get_system_properties },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threaddump&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,       thread_dump },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inspectheap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,      heap_inspection },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setflag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,          set_flag },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;printflag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,        print_flag },
  { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jcmd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,             jcmd },
  { NULL,               NULL }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有没有看到上文中我们提到的threaddump命令。jstack通过与jvm进程建立socket连接，然后向jvm进程发送threaddump指令。上文说道调用AttachOperationFunctionInfo对象的func方法处理指令，其实就是调用了thread_dump方法，针对threaddump命令来说。&lt;/p&gt;
&lt;p&gt;坚持，马上就要说完了。来看看thread_dump方法干了些啥吧:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Implementation of &quot;threaddump&quot; command - essentially a remote ctrl-break
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See also: ThreadDumpDCmd class
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; jint thread_dump(AttachOperation* op, outputStream* &lt;span&gt;out&lt;/span&gt;&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; print_concurrent_locks = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (op-&amp;gt;arg(&lt;span&gt;0&lt;/span&gt;) != NULL &amp;amp;&amp;amp; strcmp(op-&amp;gt;arg(&lt;span&gt;0&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    print_concurrent_locks &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; thread stacks&lt;/span&gt;
  VM_PrintThreads op1(&lt;span&gt;out&lt;/span&gt;&lt;span&gt;, print_concurrent_locks);
  VMThread::execute(&lt;/span&gt;&amp;amp;&lt;span&gt;op1);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JNI global handles&lt;/span&gt;
  VM_PrintJNI op2(&lt;span&gt;out&lt;/span&gt;&lt;span&gt;);
  VMThread::execute(&lt;/span&gt;&amp;amp;&lt;span&gt;op2);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Deadlock detection&lt;/span&gt;
  VM_FindDeadlocks op3(&lt;span&gt;out&lt;/span&gt;&lt;span&gt;);
  VMThread::execute(&lt;/span&gt;&amp;amp;&lt;span&gt;op3);

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JNI_OK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很简单，创建了VM_PrintThreads、VM_PrintJNI、VM_FindDeadlocks三个对象，扔给了VM Thread线程的队列。&lt;/p&gt;
&lt;p&gt;说到这里，VM Thread线程的作用，应该真相大白了，就是读取队列，然后执行相应的操作。有兴趣你可以继续追进去看看源代码，我这里就不追下去了。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;看了这么多代码，确实很头疼，总结下吧。&lt;/p&gt;
&lt;p&gt;jstack是通过与jvm进程建立socket连接，然后发送指令来实现相关操作。&lt;/p&gt;
&lt;p&gt;jvm的Attach Listener线程监听套接字，读取jstack发来的指令，然后将相关的操作扔给VM Thread线程来执行，最后返回给jstack。&lt;/p&gt;
&lt;p&gt;在jvm启动的时候，如果没有指定StartAttachListener，Attach Listener线程是不会启动的，在Signal Dispatcher线程收到SIGBREAK信号时，会调用 AttachListener::is_init_trigger（）通过调用用AttachListener::init（）启动了Attach Listener 线程。&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt;&lt;br/&gt;加入知识星球，可以有更多的交流，更多的学习和更快的提高。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1287675/201804/1287675-20180430230009584-1417651003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 13:47:00 +0000</pubDate>
<dc:creator>清泉^_^</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingquanzi/p/8974850.html</dc:identifier>
</item>
<item>
<title>抽象类和接口的异同 - 风之之</title>
<link>http://www.cnblogs.com/fzz9/p/8974403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzz9/p/8974403.html</guid>
<description>&lt;p&gt; 　　Java中的两种抽象定义：一为抽象类（Abstract Class），二为接口（Interface）。&lt;/p&gt;
&lt;h2&gt;一、抽象类Abstract Class&lt;/h2&gt;
&lt;p&gt;　　抽象类是关键字abstract修饰的类，既为抽象类，抽象抽象即不能被实例化。而不能被实例化就无用处，所以抽象类只能作为基类（父类），即被继承的类。抽象类中可以包含抽象方法也可以不包含，但具有抽象方法的类一定是抽象类。&lt;/p&gt;
&lt;p&gt;　　抽象类的使用原则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）&lt;span&gt;&lt;strong&gt;被继承性&lt;/strong&gt;：&lt;/span&gt;抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），&lt;strong&gt;缺省情况下默认为public&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;（2）&lt;span&gt;&lt;strong&gt;抽象性&lt;/strong&gt;：&lt;/span&gt;抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；&lt;/li&gt;
&lt;li&gt;（3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；&lt;/li&gt;
&lt;li&gt;（4）子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.fzz.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象类A&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fun(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通方法&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;存在方法体的方法&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象方法，没有方法体，有abstract关键字做修饰&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单继承特性&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; B &lt;span&gt;extends&lt;/span&gt; A{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;B类是抽象类的子类，是一个普通类&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制要求重写&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;Why is more important than what!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试类&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestDemo {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         A a = &lt;span&gt;new&lt;/span&gt; B();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多态：向上转型&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         a.fun();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;被子类所覆写的过的方法&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　详细可参考：&lt;span&gt;https://blog.csdn.net/wei_zhi/article/details/52736350&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、接口Interface&lt;/h2&gt;
&lt;p&gt;　　在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。&lt;/p&gt;
&lt;h3&gt;　　1、&lt;strong&gt;接口与类相似点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;一个接口可以有多个方法。&lt;/li&gt;
&lt;li&gt;接口文件保存在 .java 结尾的文件中，文件名使用接口名。&lt;/li&gt;
&lt;li&gt;接口的字节码文件保存在 .class 结尾的文件中。&lt;/li&gt;
&lt;li&gt;接口相应的字节码文件必须在与包名称相匹配的目录结构中。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　2、&lt;strong&gt;接口与类的区别&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接口不能用于实例化对象。&lt;/li&gt;
&lt;li&gt;接口没有构造方法。&lt;/li&gt;
&lt;li&gt;接口中所有的方法必须是抽象方法。&lt;/li&gt;
&lt;li&gt;接口不能包含成员变量，除了 static 和 final 变量。&lt;/li&gt;
&lt;li&gt;接口不是被类继承了，而是要被类实现。&lt;/li&gt;
&lt;li&gt;接口支持多继承。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　3、接口特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 &lt;strong&gt;public abstract&lt;/strong&gt;（只能是 public abstract，其他修饰符都会报错）。&lt;/li&gt;
&lt;li&gt;接口中可以含有变量，但是接口中的变量会被隐式的指定为 &lt;strong&gt;public static final&lt;/strong&gt; 变量（并且只能是 public，用 private 修饰会报编译错误）。&lt;/li&gt;
&lt;li&gt;接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　4、接口的继承&lt;/h3&gt;
&lt;p&gt;　　当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。&lt;/p&gt;
&lt;p&gt;　　Java中类不允许多继承但接口可以。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件名: Sports.java&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Sports
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setHomeTeam(String name);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setVisitingTeam(String name);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件名: Football.java&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Football &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Sports
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; homeTeamScored(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; points);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; visitingTeamScored(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; points);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; endOfQuarter(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; quarter);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件名: Hockey.java&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Hockey &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Sports
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; homeGoalScored();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visitingGoalScored();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; endOfPeriod(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; period);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; overtimePeriod(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ot);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、异同&lt;/h2&gt;
&lt;p&gt;　　abstract class和interface是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。具体看下表：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1YAAAGTCAYAAAAr5oNFAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAHCTSURBVHhe7Z3bceQ6r0ZPhg5jaqJwOQo/OAi/OIt5mgD+OPajj8CLCIAgJfXNHnl9VWtvNyWR4A0gutue//tECCGEEEIIIXSVUmL1v//9DwAAAAAAAC7AJFY/ST+tvwgh9F2E/0UIIXQ2kVghhBB6uPC/CCGEziYSK4QQQg8X/hchhNDZRGKFEELo4cL/IoQQOptIrBBCCD1c+F+EEEJnE4kVQgihhwv/ixBC6GwisUIIIfRw4X8RQgidTSRWCCGEHi78L0IIobOJxAohhNDDhf9FCCF0NpFYIYQQerjwvwghhM4mEiuEEEIPF/4XIYTQ2URihRBC6OHC/yKEEDqbSKwQQgg9XPhfhBBCZxOJ1RF9vHw+PT19/n77WwqU0rWXz4/y8pT6+/b5++n3Z9R9hBA6oj3+9+/b7+RzE7/fPr/E9SS/l214ObWDRwghdK1IrA7o42VJqn4vgT4K8NcmVg9JzD4+X645HJBYIYRupL3+NyVXB5OqS56J9ffz7ffgzTSEEELIicRqtyQpkaSi/r8UV5FYIYTQbv0bidWVPhMhhNCPEonVXknikwL14B3Mmhipr41EXx2RT73qtVqHLkuUA0EqXyqo1+v95usxwyTPXTdlg+dW5T6u99ZOBImVtd0nhvlQErVn+sCpBaEfp0sTq+oXjQ9Zrzvf5fyL9Z3aX1W//rE+//JmfXnzYa6NIIEbtzO/hhBC6N8WidVOSTC3iY0LiDVx0UE2lbWEIj2nrv9dAvdaR03MyktRTVpM3rEkNy8qQ+lscW0ud3y+LYeFrD3vvpZDg77p4y3X5xOrpS1zm9jrDjgtAVV2+L7W+hFCP0ZXJVaLH1t9S3kzq/ma/hmR9U/+npos2TeAlqc6n/n37cX6V+cvO5+8/PRWHpjbgBBC6F8XidUe+YSiBHKToHQJjcgmFymomoeURonVVtA1tvlkxmtHYhXYscqPg5d5dtwWhwmE0FWJlfMf3rd2Pib0XeKjrO/s/fO2z7RtTe7ftAEhhNC/LhKrHUqB0yQbQRAeJCQm4Kd7ltdRIB0lVlGEXuuplPq2Ep9Z0C8atikK6s9jo21pfUh1SZlPolI9+drMFoTQeXVVYuUchy/rEqvOZzbyY6M3pWKfufq2Sm1rEAeSNm1ACCH0r4vEalMliQqCoUmQBgF1eAhIz6v7g+ejZ7skTyc7D06s0r3d4cWPQW4z9Tfsi1yb2YwQOqMen1j1/rlpb2LVv6lm2pq1s2kDQgihf10kVlsaJis54K6BOAVNf98oWItcwA6Cbn+ACOoz9m0lTlvX3SHBa6utiw4VszFCCJ1VD02sku+a+b6diVUQD0xbw3ixaNMGhBBC/7pIrDaUAvYg0TDXUuJg700BVyUTHy8qsfABOEjMRolVKyuv1XO5TV3PcjBY78+HhHkSk++xh5Tyy9rGZl9XeW7tr2632FXGxv7yd37OdBMhdHrdPbGK3qgyZYvvWes9klj1rzv7dDvLPfUPDs1tQAgh9K+LxGqqHFSHiUhJplKQrZ/I1AQrYQP7GoQL9mxQk6SFEmijA4StY0lyPnSyk5UPFfUea0O7Zp+xyv2udaz9T22r53xf6xiUy2M7BvUjhH6M9sQb40MmfrEvUz5mLVc+NqF90s7EapG36UNeu+QoJ1DtnnZtZgNCCKF/XSRWCCGEHi78L0IIobOJxAohhNDDhf9FCCF0NpFYIYQQerjwvwghhM4mEiuEEEIPF/4XIYTQ2URihRBC6OHC/yKEEDqbSKwQQgg9XPhfhBBCZxOJFUIIoYcL/4sQQuhsIrFCCCH0cOF/EUIInU0kVgghhB4u/C9CCKGzicQKIYTQw4X/RQghdDaRWCGEEHq48L8IIYTOJhIrhBBCDxf+FyGE0NlEYoUQQujhwv8ihBA6m0isEEIIPVz4X4QQQmdTl1gBAAAAAADAcUxi9d9///0Yflp/AQC+C/hfAAA4GyRWQTkAANwX/C8AAJwNEqugHAAA7gv+FwAAzgaJVVAOAAD3Bf8LAABng8QqKAcAgPuC/wUAgLNBYhWUAwDAfcH/AgDA2SCxCsoBAOC+4H8BAOBskFgF5QAAcF/wvwAAcDZIrIJyAAC4L/hfAAA4GyRWQTkAANwX/C8AAJwNEqugHAAA7gv+FwAAzgaJVVAOAAD3Bf8LAABng8QqKAcAgPuC/wUAgLNxm8Tq/fnz6dfr55/omuP9+enz+T2+thLW9/75/PTr8/VPef3n9fPX0/Pnu7nnGNv9/fP5+uvp8+npGLp/0t+n53dV54L0T5cdGD8AgDOwK96Ibwx87BTtS1OcUHEjIX5dl2U/vxmXAAAANrhNYlUTEJ9AdJTk6F2CnQuGOkkKEo0/r7+CgGkTK7nn1+uf9fUWl/e32DNN7GywNgnlmljJeCx9J6kCgB/GNf63+s6pv9dxROLF6mdbYpX9OEkVAADchoOJVUmg1mRoBzppWBOK/FqSjTAwdolVDqIm+PnESp5Zkrbn90ckVoE9wfVoPFJ/k63yutm/65M8AICTcPUbW5M3pGrC1CM+t8WxNf6YxAsAAOAyLkqsdicAJkHKz7ZESpIP+xWNNblwiVUYRFVilYOo/7rHNpcG9vDrfbuQMVhslv6Z56X8uP0AAP8qFydWyfdf6C8X3/vr9b33t51PBgAAOM7BxEqRgptOsjaSAwlc+h3C8roi5WFiVdoZJVbPkuRcGGQvCuyr3Rttuv6ZZ2qfNL5/AAAn5rLEKr9Bl3zmNBFS92nKM+nNMXeNbwwAAMC1XJ5YFVKASknBLLHKn049P9ffgcpBryZZNaHqE6ty3/Nz/zWNNTlRXwc8yOH+pjalj/XTtslXAqUPfCoFABBycbxZ/Gr6lkL9f/imVOBvO58MAABwWy5KrOKv3k0ShyUheV6SKHkuJVP105wUENtXArvEShIZCYTyfxM8c0JzTVIlHAvsOolqNrd3Rp0ttY+G/Ew9FKz3rgmbeh4A4MQcTax0EmV8aPG167chEtUvO9Iz2n9nasLWngcAADjORYlVpgSuGoxScjBPdHJi1b7fnoKjBLsSLPtPrMqzOrFKQXRpZ0d7W+zvb06qWuDuA3MX3OW1CdQt8WyHgkFSBgBwco7Emxwrmp80iVXC+9Lmb9d7Vp+s/Lf32wAAAFdwMLHKCcb67t8uWnDLiVX/rmL9Kt1mYqXLw8TK1rfFrsCe2vF1BolVIref+lgCdjQWa0IZ1gEAcH72Jlbp0yQdDxb6xKqQ/K7EhZpoOdbESr92dQAAAFzIwcRqQE0iXPDz+MRq+PWLUWKl7wkTq1HCE7MvkYzq29GO9MH0rb2DGh0K1qRSlQEAnJU98WaUQA0Tq5Xmb9ey1ScH/juKMQAAAAe5KrFKiVF6568kOOXTnVGSpROr6F3IFZ+U7E2swmRrzMWJ5M0Tq+AQAABwYi73v3dIrDp/DQAAcJyDiZUEpJpMbXzCUpMslRDVxCoFxSCpaoma+857lFgt6PvD5zZ4TGIlAb7aFySglVGSCQBwQh6WWIkvLn7WvLGn/e8C3xgAAIBrOZhYnYuf1l8AgO8C/hcAAM4GiVVQDgAA9wX/CwAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNkgsQrKAQDgvuB/AQDgbJBYBeUAAHBf8L8AAHA2SKyCcgAAuC/4XwAAOBskVkE5AADcF/wvAACcDRKroBwAAO4L/hcAAM4GiVVQDgAA9wX/CwAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNkgsQrKAQDgvuB/AQDgbHSJFQAAAAAAABzHJFY/ST+tvwgh9F2E/0UIIXQ2kVghhBB6uPC/CCGEziYSK4QQQg8X/hchhNDZRGKFEELo4cL/IoQQOptIrBBCCD1c+F+EEEJnE4kVQgihhwv/ixBC6GwisUIIIfRw4X8RQgidTSRWCCGEHi78L0IIobOJxAohhNDDhf9FCCF0NpFYIYQQerjwvwghhM4mEiuEEEIPF/4XIYTQ2URihRBC6OHC/yKEEDqbSKwQQgg9XPhfhBBCZxOJ1d319/Pt99Pn09Pvz7e/pUj08fL59PJRXjj9ffv87e9X+nh5+gwflTqfpK050bN/335//h40OLs2kzw3a/PrVOZkyyiZB3PPx+fL08vyX6VlzLux2TkPT76uRTK3nV1+rcjr329LL5SissheJT0/m9xlAsW+8TpfxX5wknHr+7FFbtOuiWRTYMxwTG8oEiuEEEJnE4nVXVSTKWFwIPSHZSV7cCsHIXV/PfSMDkWd0sFUbBkfsnM7yz2+vvRs9Nz24e6Sw+cjlMbt9zLGi42z4fu7jLkdt+BQGvUzTHKcunHNa6baYw6269yXMQ/qlvv78bb2etl1lhXVs3udTRS11fo1l3229In9sENik/c/fk3YdVdl1t+dRGKFEELobCKxuqvk0HIwsZKDWzo41wNPPQi1uvKhZ1K3kty7ecivSodGXWc+LO47q+Yk496Hsasl414PlvrnidohUx9Ko0NrkdR7KLHK4+wP4kI6jCc75XWz1Rx8a13rfXPqAT9KdqReX7Y7YdlQWovN6LS+I/sSdfzYD1coWqN1/JSC9WrW151EYoUQQuhsIrG6q9xhb3rwzYedj5dy/3rYUQchKVtOO+nQ85J/rkoHxlqXOiRJ+XpQXp7PP+sDVz4sWlvGhIfuoFz07ZKtNP72oJls7A7aG4f+EHVYXeduIpNYjSR2LPeUeW+y62qc+ASHaKU6P7u40STW9R2Pe5buD/thrNH8tbZ1v6riNZHGUBX61/cQiRVCCKGzicTqHkqHZn/gWQ44b+rwpw/L6yFbH+r0Qc8ehKaHnvIO/0d36CrtLwdyse3328fn3/7sV3Tg3X/ThmMruXig8iFUj2kbw3xtnICI8pjng+rvlHRN7l+TgIl8YiXP+PGr9kbrqdZfr6XO7EgI1cKRfvsEQPoZJgvDBXeJ3Poy45X7kJtjP8y0PX95vdpb+vHrta+/14rECiGE0NlEYjVTdKDdwXqwSc+rA4pOpsLEqmi5Zg9HL58vw0ObPQD5Q7A5aHl7hrrwYFWSA3/Yu1pXzUM5nJtDbS4zh/FiuylT7ebyelAtdVb8gVnq2jpEB3Nuk5f9h/nfy335WZ2UiPLaGbVxOLG6ah6ypC7TzUWp/jpe0dgtZa2O3KcfvR+KtuevrtfyMsmtiVB77rleJFYIIYTOJhKrO0oOOfXAlw47+mCrfzaH7OVQ0yUB7nC81OcPp1XSplzTbVf630PJB3F/35zooFauGaNy+cjOx2hkw6g8j8fvt7fcpy45cnNRlMdajUuZo236ebXkOn1y0BKCxZ6lvF3fMZ+qnvRcdE9EP1gXSMZPEis3qn78jJZn2A+h7pZYyZh2a//2IrFCCCF0NpFY3Uty+P39shwK5WCTD2zp90DWA5lHDjv+YCfP6oPQ8vNy4Hmrh0R/+DEJWpY9aMWHsU7lsDq/78ghdOMg93BtHXIvOWCrPu45mPq5kmeMQWJDPhT3iZMdz3Y96+/6nTZ3sHZt1KRDy68Xka//UoVrr47DYlu/3tgPM0W2H0+s/Gtfx/1EYoUQQuhsIrG6i/Ihq3tHXB9s9c/BAbCpHnxaXeuBWOpQh8n1QJTqCw506d7osKXVrq9/OOCAwkPZtH9fIenjLLGKlfq2zMH+JMOPdV0X5aVWObxb8rMpsVGvvUziU+Y+zYFbH1ZubRZF82fqv1h1HWvp8Yjt6VXrYT+0dWFp7UV90+Mn99vrW2vtliKxQgghdDaRWN1Fy+ElnfQmh0WdWE2VD0Jvy4Gn3r4eJJXygag/rA0PytGBuxxAW9358NUdDLVSQtDabe2J3YMkotORe2+h4+1Jv+qYDcdPqyRK9o8i/F1+zm13c9Wth7Z2UnvOWL0G+uv10Dybu7yubK253nC9HBmsQH29xUZd766EI9t9nv1Q14Mbix0Su6e2pLqd/1FJZjgO5f7R+N1SJFYIIYTOJhKru6odjjvNEit1+Gn/bs9MwQGqKDp0imx5PdzF7ci9/TvY9fBun7EH13m9q3YdqG+pbNf2ObYlKN1clcSp79u+PueDqxqrQ4mVXVf+eq1b483v68yy85c1une/ZEzUeJT1HSYFXTKz6MT7oY3t2ObL1deZ2vNJ5Dq+1va8jrbG+nKRWCGEEDqbLkuslkOgORRJYHbBWoLyVWexB+j7JVblcGbGsh7Gxvhq8sGvMjsYzQ+QVvXgWA+30YFRCPqbkpBJG+FY3FPZ3mGT6iAfHv61ukP/jmdWKTvWMWjjvI6ZamNFrZF6OK/z3rev50faG6/LNRFwbd5qevYd1uu4/IT9oO69xSD7tbJRZ56PgY9aJGN3q7n3+pLEKo39uL9V/mufMk52X8n8t3WSx1GN+x7KurZ1y3oI7JN5dTE20rp/B4rs/P2yxHNXtjJrM43lvL2hdsxD2rc7+nwvtbHa4w8QQijrosRK/k2Y5Iir03NOPx9k+r/+9d30JYEddbrn4Q0h9D31eP9bEuDfy4F5emD/SG886KShT34k/i0H7oMhLh3WnbOzdS+SpMPbtzOxSvcttm35U5OApWeC5CGyoyjH+AlTA/bNw/HEKr/ZcVGi55XGZDsBRwghr4sSqyz1rrd2+iMn/Q1FYoUQQl+jx/pffejeeQBXcU0nP1FytFe7Eqtin7lNx1hRirMumdlAtzFMrHQyFSRWyf6lrrj72e55MnTBPOzWDetLn6jxSRVC6LgOJlbqayt7mTrZrxWJFUIIfY0e53/Lgd9kAzmWdQlCOlC7GLZBO8iP4mM7oO9LrBZFiZR/feDgbxKpRccTKzuG3uZ5wlV1YB4WpU+s1gv1vlJHGVvbh1ZubbHPmPbTc78/3z7q8/kP4+h61jFwbXRzVmyMr09sQAidSgcTKy9xFsUpLf9PTkc7/28uEiuEEPoaPcb/lsNuOcimBGCNUflaf0BWksP0cn/6+rv7emAvqc8lOzppSS93JlZekuQMDuM5qVHtFpvDGrvEsSYVW4lVr5pMzcek6vg8RImV/r2s3H57vZSk5MXW4+t299RkyfczjZOey+W5F3VPea5NSd+Hv2/Lukk/bdiAEDqVLkusVudcnFoNHtVJVQaB4LuIxAohhL5Ge/xvOlzrmLKLfCCuB38dhuyBXpQPuf5gvbZbytNzS0W1zooNcXKA1ofxRTU2ri9zPVpStnXI3r5HHd6lTZ8oOE0/sar2DRKrNifqGXnt+lVVx0xfTmUb8xAlVnYMclmrt09Y+nYW6X6VM0tneuqTm0sj21bYTtGmDQihU+lYYlUTJ++FQkdeHOXUOX2tSKwQQuhrdE//OzroDg/A5SBdvwbWh7ggseni4b0SqxxLu8N/jbG+P2E8tholVsa+IAExY6PKIuS+0XiPynVCEyVWdgy2E6uWBHrKnKQ+6E+9isLEKren68lt9e1qbdqAEDqVjiVWgWPZZMPBf6VIrBBC6Gv0Ff53eKCvSgfqII5NaAfq2yRW/rWvo1NJcGq1URtecWJV3wwdJwmiVH/qe5CQ1Do24n6qY+OemyVWs7HYm1i5MbZt7UisZjYghE6lg4lVpOJU5HesBo7lu4rECiGEvkbfMrGKVA7fEuPmIW70xuPOxKomdea6qlOXX5AA6n7XxMokWCWZeNFl0vf6XGefSyTL9T3ngEclVqkdbaPXzsSqt9e2NUueNm1ACJ1KVyZW2blUh/KvvTNDYoUQQl+jfyKxMp9URId7LZdoBErtuwpS3Fzq7Q/fub18f/55K2mpdU3vU0nZaorqp9SxPq8Tq0iqriPjumce7HkiGntfZs8jWXoMixabTf/2JlbdazdO+vWij5d6/4YNCKFT6cLEqjgK50hE1eEcCl5fJBIr9H3U9tQe7AEDoX9P3zqxWhMGf+guh/fl2iUH49R+cPD3+zlOkPK9fbvKd5SK1jjs7s/lNoGr91YbTGIl4xA6m77NI9ozD8cTq0XrvKnykvTUcmPvzsRquXGdd+H3m/wj0m4uXDvGrpkNCKFT6VhiFTmtkYaB6ftoV2AXh7gGAOtcI6qjlcDRB0Cn5GxtkEsaOfsiCTjh+Kv5mTGfu9rHwK5NRe8YBjJjqhUFz6rtsW9srLnRuK9Sh4aV/BUZW9YYd/n68dwazq9dLwhdpu+YWNWEZs9+Xe/dkyCs+2krHhbfM9p01XeavTu3tSZOfTwqvsnb7/xCNsX730v8WdOexAohhP5FHUusTqa9/U2B0QS6Jfjp1yUQ2cC141A8OODbpEwC7XKPtFEqqwflFJymDRSldnYEw/W+EfNDQQ6Wi+3LvZv9HgTVcZ9uk2RUpTndCuxufuSZ0eEkNnnveEaJ3DbVli9bLwhdoZ8WbxBCCJ1fJFa7JIdndVj/u7yWg3k95I4OqzWB2DxgZ1I19Zn1wF4OysqGfFB2Ng20K4GoB/vRfSVxnJ7J0z3lIK5/jrT2cVGpe0ztYx0P+XmiNNZtXFL/w3pHKLtTXe11S6y0LZFdNxjPpB19/pL1gtD1IrFCCCF0NpFYHdTWQb3/RGMid3AXfbyUw68cvtMBtx6US9lyyk4H5Zf8c5WxSx2MpXy1aXk+/yx1qnbMJyfano0EocrUkZU/vfLP5cN/P16+3UVr/6t2JBmiILHaPSd+Pi5JrK4YzzRmamzGaJvUPKZ6VZtSduv1gtCNRGKFEELobCKxmqochIVyKDUHT3fwbl/J6p9rh1SlLrFSzw0P59kGdUa2kjqXg/JHd0hf6nuTw3f+qp788u3f8KCsbbDtRsrJgLa12ZavBXUUG03zuqwbF9FliVVTtk3PwXgc+wSwJij5+Uli1Wn/eKbxMhUFdZux0XV/1XpB6DKRWCGEEDqbSKz2qLzzn3/Uh88ekzyp5/Ih2R34wwRikUnC8kF5/IcTbJ3+cN6SgUXDpGNRupbr1MmDr7+pHOpNgpTLzCFexsCXlcN8/fqa7U9Pn8xMNOvjIp3sTRMOkZsfm1jVNgZ2HR5PecQnNyPcmvmK9YLQlSKxQgghdDaRWO2RS6zswbMdcuWQ2g64i0xitcjd371OWg7GXbKi7okSFaWaLMj//aE6+j2b9T7VZvTsSrovSKCSRuU5qbDjJvXZvqd2Rx0rdQwvV0XJwGDM6lgN5eZH7s99kH7WNqxdl41nlk9ywj53a+ax6wWhW4nECiGE0NlEYrVHLrHyB1DNNLFaJIfntag7JOeDdKtPDrX6oJwP0esfzjAH6kVdfdlebVOX/K2Sdkq90Sl844CelesY36PaSLar1xNyfVckVkVp7tYxk7Y3koZRYlXGYv7VvuPjmRKr+syU2u5XrheErhOJFUIIobOJxGqPXGK1HjTdwbQ7hAaJlZE87w+7nepBuX16IDakaqV+9fxqW7JLH7j1wdonFPVw3spsP+p1ewCPlZOJWZeTfL+DcfAH/GrHrrrXvvjEYx9rG6mupd/1/7kw1fn75cXM/Tona5u3GM+dfTa693pB6DYisUIIIXQ2kVjtUPokoZxuzYG/HLjf5Ho5jOpDsH6uqR6sMzZ5iJQPytJGraod4ptSW8Fh3dhblO51iYyVtbHrwlCXJFZ9W2LzaNx21b2VCKyJxCy5UXa5ZCS9LnNfn4/mpGnPeOaxq/dsMV43X7FeEDouEiuEEEJnE4nVhvJB+uXzRQ7Gm6f6pnoAT1/DOvBc0nrwlwNxPijPa5B74mRidOAflecDt7R9yacUlyRWTa3tqH2bnMyJbe/7ppMZPca53CYY5d5qt0msxLa9bR7RkWQy9+PR6wWhS0VihRBC6GwisZpqOYCqBCAlS+UAO8Mfbm3CMCb/sYDlZ5N0lAP9BH/gtXZuHLLL7/pUtj9BmynbOj6Aq+RIblIJQd92vbcmAEeSDPvMvr7VcQ7Gq4yRbdvWvc7ZJePpxmEv8ifQkw2PXC8I3UgkVgghhM4mEiuEEEIPF/4XIYTQ2URihRBC6OHC/yKEEDqbSKwQQgg9XPhfhBBCZxOJFUIIoYcL/4sQQuhsIrFCCCH0cOF/EUIInU0kVgghhB4u/C9CCKGzicQKIYTQw4X/RQghdDaRWCGEEHq48L8IIYTOJhIrhBBCDxf+FyGE0NlEYoUQQujhwv8ihBA6m0isEEIIPVz4X4QQQmcTiRVCCKGHC/+LEELobCKxQggh9HDhfxFCCJ1NXWIFAAAAAAAAxzGJ1X///fdj+Gn9BQD4LuB/AQDgbJBYBeUAAHBf8L8AAHA2SKyCcgAAuC/4XwAAOBskVkE5AADcF/wvAACcDRKroBwAAO4L/hcAAM4GiVVQDgAA9wX/CwAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNkgsQrKAQDgvuB/AQDgbJBYBeUAAHBf8L8AAHA2SKyCcgAAuC/4XwAAOBskVkE5AADcF/wvAACcDRKroBwAAO4L/hcAAM7G4cTq/fnp8/ldfv7z+frr1+frn+XnP6+fv369fv5Zrv95/fX56/VP91zi/fnz6fk9/Sz3PT09jSn3zVhtkXqfii3BfSMI7AAAXwP+FwAAzsbhxKolVOX/7y2pkuvvz5MExyVWexKwGZJYtTreP5+fnj/f3T0zCOwAAF8D/hcAAM7GwcRKkpfg0yUhJVfx9ed3X/7r83lJwPQ9HWtiJQlccH3I/k+uCOwAAF8D/hcAAM7GwcSqUpMdm8Skr/epT5ra1wYLF31ipb5y6O6b1rEDAjsAwNeA/wUAgLNxPLGS36eST4aeX9snSSkJev98XhKgX7OEaJZYyTX1lcLG3sQqJ3smkduAwA4A8DXgfwEA4GwcS6xSUlWTnJbwyCdTkmD9en1fysrvOaV73e88SfKUvq73/Pkqn26ln8e0P5IRXzOfkKW6+R0rAIB/AfwvAACcjWOJ1Yr8zlT8KVL9+p9JeuqnXMLVn1jl39dKSdf6zPFPqwQCOwDA14D/BQCAs3EssdIJkmNNalKysyRNuqwi10pilRKw13F9LemSREp/EqUSq/KpWPr0K0zK5hDYAQC+BvwvAACcjWOJleA/Weq+8le+ulc/rdKsiVX5FEr+VHvw9T3zaVZXv/60rH5NsF23f4J9DoEdAOBrwP8CAMDZOJxYvb8viZEkSOunS/YrgekrgEF5oiZWNVnqkqaMTqzMVwqF9EypO/28tLUmese+EkhgBwD4GvC/AABwNg4nVsKaPP16/nxePzFynx6V5MskOSWxWj9VqolRQE6s2tf+WsK2IInWWn9ut93fJ2ojCOwAAF8D/hcAAM7GscSqJkL6E6REToBG5fofCP71+tqSn61PrOonXO56Tqr0J2I1qYtsGLMd2JvdR4g/MZO6gk/xNqljGF3TqDHYxI/56JO+S20GAJhzLLESH9X7Iv3thl1I7Njz+7iD+7pvUFTKG32H6L5S7/vn++z8tDwz6cv0a/HRs3vHxjOI4xWxY9T3/tok3oh9B+J7il/SzubcNNvNG7gjLhmjq8hngEPr3KDOBjJ+aTxuGNfDtftgojWYytS8aRu7a3uI1/iRXz9ZcWt56FcGHPZ7Qunz9lkSruVYYnUybtffHQnIgaAVBqKQcTAbMnRAQV2HAxkAwD52+d/BoTgdKmYHpwF7DzDxYSlO7ubsOBTr2CB9WuNEa68e+P2hSOwcHZRmB77+YJbtbGNZ0Hb5a2Uctw55nY2qj9bG7fHN42BjVTwGuT9x+Thubq4PMz/biG3HYmhOgqK5mY3xjNQnbXPaU0fX8YS0Nm5Y30HymtBrs9gy2EtRHY08/vvnTObmgr67s9XmuvOU/Tja+5Wu3jT3ev1faD9MIbEKyo/jF2fZnGazb1M3ySwgrqSNNQ4QQ9xzvVNaSBtx0IcDQQUAYMQx/+sPRvqAnH1Vd3j3vmuD7HPzIdZeK+0OkrzZ4aY71DpC/5uQvjUfvMYDc1hc0Ae0rT6vB6w6ljVu1XZ0PMllwzi0ttts7Ch2Xp9YufKl7fUZscOPbxqHqJ4FPV4B4/lQTObTc5vE6jqO23CQ2Xg/AJs8uDW9lo/WlkPWx+xctbXHQkp9at37dWj7kF/XNZDmL6w3pveDtj9mz2mb4GaQWAXlnpGzbc7PJ1aODWfuscFmQLBhduGe0xs4UWz1Gz3BJgSAG7HP/8aJzvPz6AA88cPF98mz4wOWtKf9aj2QxT5efPUwsUrtzdqasPjh/A/uu+e1f9b9Fr/sfHuLI/mQudopdaT7cp9kPNJ96fnlmaVNqXOWMK4xTf5vYkJ/gA0PhuUZG+tGh99BuetvVJb+2Fa4hhq6n2Hc00j9XQzU9Vc7+zbXfpZx3ioXsm25Ljsftv42hpo877q+dN86//m+ND9+Tfk+jmxer0Xz9hjynL2WNa7GxfWhrUO3ZlaicZ7h9tUWeu3U/VOu6XWX5+F5Gc88xmL33jb6e+c2Slvx2oFrILEKyj3R4rMBQTbkwLEEzrLDOfLmALYYOYgJyZ72XNe3FCiXsqg/2jEAAFzBsXgzOnTrw8TED6fDZL02O2xIHdqv5nZ/yQE1OHCPDz25jeSng+ca6j5NeSaKBb691Qbn26W8PzTV9uS+frzyoa60NbM7HQzzYdbGIT9+wRipOGJtzGO92rP2x5UnpB2pN/en72fpS2pntC7ys9o20/8RJgb69pfXS0Jc60vzZ8Zxub6M2/p86qO2IepP7at9re/58/pqxlzT2RAlVrq+YpPp08zm9Doa38eQ5mzt32iut6nj0CWVA9r6cmWjfSPjVO9Pc1DaW+xNbxQtz0V1Xsu4zsvHCuaQWAXlHlmY1tH5gDBYoMUBDTeakAKUvW7rHpDqtgEsbaB1s85oz3V9U/aIHSYgyrUbb3oA+Jns8b/7fZpG+cV6gFn81qscnJT/qgcp4+OSL9d+VQ66xbfrg9F6zT+fSXXXg9L0wKTqr2VBTBhRfXT6/+Qf3F/bTnU/lz7quCU/L/dJu8s9EhPWsU/P5r529S73mzgRxAhzXVDjKNda/LFjUceuH6Ns66xNO966n7qu3Kdo/vbjbHFI/+ZzmW2wY+Djv21jvJZiOhtkvNQaT9eDORvb7WxMZxE9P8dZ19ohljbTv4UalL9KH335wmDc1jGta8mNUcegz23N2vKE9h9Sv7pv7b9/NrXj+rBF18d4jU5thasgsQrKPbIAraPzAUE77kLaEMvGTBs0WPwat7ht3QNq/aossrPDPbdu6NAe50CdMwAAuJR9/tcffsXXWr8n/jJfb354eFAJfFg6RK735kOI8Yfat5sDl9g2OFyVw036ubZXYoH10bl/tr2F1RZbfzvw2udSncW3P/v4ofr8Zzlw5q81Sh9y/flrlblPqf7F9vc/S2JVvoqUcX01dbY+RrFrHV9NGR97v24j9y9fU+XloGnbsLbVPrTDpR7Hvo20dsrcHEL1Qb9udpVrZWwa/RqzY+D7l+/Pazy6Pqezwazh2Ma+bGJzmpM2/o/G7DE119IHM05qzRr0eMjPdR7LWuufyXOQ7+vHxbP6Lqmv1u1ssX3YQ+tnfN3h5vyr5+zskFgF5R5Z9N6R2U3rF7m8Vht1tmGC68mpBRu0R22UhcjOLbpnOntUINrqCwDATo4kVjO/J/7SJ1a2jiMo351Q/q+WrX6wv5YOSOr5/sBU+1PvmdWv+iNlS9+rr5Z6pc+57+W+9O79Um86NE3qX/vY6s9228O7Heeonopuv7+nzU9BHTBtHFVtmINfKS+fQpi6Cus468Prwnv6fTo1jnpMSz+j+lbMWM6Qesv6VPOdYrme/1SfbjPbYMfAJQSlbj039vqczoa0llqfuuu+bMtmM1ePJ8+9/JuqNdEptkg/17Wg512RxkKVm2cyaSzUPfn1grtP6Pe7Qq9NaUfdN30uIWOu7R/0Z0Kb07yejqwhOAaJVVDuqUHH0xbmZJGnjds/a3AbSjbA5qIPHL7YuW+zNMfYPeM2vGF2DQDgAEcSq3aoE1+7+L1y2Ov9qfLDq48sz5QDhT1Ie99d762v/YFGY6+lg4s7bA0PTCkuSDu5f10/1AGovXZ1LEiba3+kztJ+jSFx+3o8xP73JWmRGFBtqX3SY+PHYbmm6q0xMoo/2kZjb3ndnmntWbu9XYo6x/rQWkh1pDLVD3Nfrne6HkbrzLW1ss5rfi390+PfbKrPZBvaGPjXgthkx3C0HiK6+zds9GWbNqcxCubmQdS1IjavbzIkW5qdcs2OaXlOjUNC7SF979pHSe5lXAb3VVt02Ypee/K8uq9/TvqhbEvta1vzmujWpe+PI82r3DeyEW4CiVVQ7pFF7zelxTljjdtAHcH1yAl0dBttj52VFlC6Zyb2Tp0GAMABjiRWs8NDPlDJz9YPNz9qDylrefWh9dCUnnMHmtT+wLer9ka+cdtnBvWvPjiIK/pwttD67uNGGbfokNj1MT8bvSsvfxziTyprdqY+meelvjI3QXvaRt/fZPPz8zL+o+dLP/w4VNx4rMgYuj62usb1dX0L4qxl6bua3/S8mx/92tefXwfzZtZMHt91DJNN+hlpZ2xjskHX58amu+7KNm02+2dAOB+3Ia2hdSz8nilr0/Uv2TNaN1G5Z3BfGhvfVkWvVXl+uS+N8zIur/45t67zfb5fG2PuyHVUjj0LxyCxCsqPM1nkZQN15YVoI9oNMMM6qumm1ihHWJ2kYVCHdWAAAJdzJLFqB3PxtdbviV9q1wvid9f7+mcE4y/Xg1I5iBkGvj350flhcdsn20QjscaMIK64eLL2Xfc32SV+PPqrfUI8Hrk897kbT5WU2AO9vb/Gk/a8TmY0uV/TmJL6tNyb+hHPQTS+2QbXv3VMyr31tTq85ufan/JPfdg7x6lPwqDdhdxPOx75T+q7Maj9XsjjmOfFzImqt90Xk+ZIj5FeK9H1rmzD5mTLYI8Uonm6DX6PqNdljKq92fbBWqvI2AQJU8fgvmk/3ZwJ67xJfX6OSv3rek7zVvvg+z2i7Wnb91Y+WztwGRcmVm1Sxsyd0XfgqsTKb5LRZvIbRthwitNgU0l1+DHeMy+ZWr9sWtOWtrdzBN9/TgHg3+BoYpUOe+KH0oFDH/a2Dxjrs47+UCE+VPs5aafV7+vZ8tPbB0pVfzk46Xoju7XNcr2OTRujQVxYD4K2j/ngFj2n8PHGHPLUfYkyN6m93HZ3n9S3jIvYG9WxHibN69x/i5t7qVcfeGsM02WKVO9y7b38v92zI5YO6oSeuj6ja1exrMO8ftR8/ZLft4rmp94zWeeyrvfMa7kv/aXR2u6Qpb26t4e+oF9vabzSc9pe7fdGqPZmfS1kn7HvXtjHFYnVbBK2rn8PrkqsAADgYvC/AD+Bf+M8CHArSKyCcgAAuC/4XwAAOBtXJFb148MRJFYAABCD/wUAgLNxYWJ1DgjsAABfA/4XAADOxgWJ1Z5fnit881/uJLADAHwN+F8AADgbFydWm3/hZe9fV/lCCOwAAF8D/hcAAM7GbRIr/6dYBRIrAAAYgP8FAICzcbvEyidRJFYAADAA/wsAAGfjJolV+wfG1D/WR2IFAAAD8L8AAHA2LkisFN2/7qz/DPv2v4b/1RDYAQC+BvwvAACcjYOJlfv3q57fg3sq9a8Hft9/z4rADgDwNeB/AQDgbBxMrM4FgR0A4GvA/wIAwNkgsQrKAQDgvuB/AQDgbJBYBeUAAHBf8L8AAHA2SKyCcgAAuC/4XwAAOBskVkE5AADcF/wvAACcDRKroBwAAO4L/hcAAM4GiVVQDgAA9wX/CwAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNkgsQrKAQDgvuB/AQDgbJBYBeUAAHBf8L8AAHA2SKyCcgAAuC/4XwAAOBskVkE5AADcF/wvAACcjS6xAgAAAAAAgOOYxOon6af1FyGEvovwvwghhM4mEiuEEEIPF/4XIYTQ2URihRBC6OHC/yKEEDqbSKwQQgg9XPhfhBBCZxOJFUIIoYcL/4sQQuhsIrFCCCH0cOF/EUIInU0kVgghhB4u/C9CCKGzicQKIYTQw4X/RQghdDaRWCGEEHq48L8IIYTOJhIrhBBCDxf+FyGE0NlEYoUQQujhwv8ihBA6m0isEEIIPVz4X4QQQmcTiRVCCKGHC/+LEELobLpNYvXx8vn09PL5UV5G+vv2+/P329/yyunv2+fvjefvoe3+fny+PD0tfTvGS+qIPNv6JP1/yheMPl7q/b3kWqrz99tnG7ls0+iZJrnv9+doyK3+fr79juo8UsdlMutC1pHp636l8b3w2e+mPX2ZrZtrxnG3ZM8eakPW2LIf0l63+8UyXm+jPbQq+SFX38vLZA8/3uegpl3xJprTLZZ1+SFrJbo2Y7CeN9edl1rj+rG9PupQe4O9ftjmTY1iodqvYsvLWx9LUnlsi9g5PBcsSv0I21Uc8kM7leZwI/a5e7KtX+lT9p4N/gWVeFFeifqYt/TXzP1ojQpSlzrPHI5fCO3XbRKrRcmpTBbq32Uhp0Uf7frkoB7vkK7pr5XasKukTPcpTl6ss8j3VGcQBpy9YzUIuKFGdU4C4q1kAusRm5221t+Wrn1+l9I4bwTropRUD8f+7+ffD6lrsEauGMdDknZcf8x8rsrrOi7fNx5ZOXCGfVZKc7mOXbQ3F32Rz0FN1/nffWthS3atRIr9dqe0F6rvjteV7Olte3e2VxTXeXRf7ZGKZ0tfa5sfL6odGYNkeJ4b3YfkzwKfFPuLps35kX18D1+3x1e7e5KtX+pT+nE/pAPx6XKNYoHT36Uv5SxU+2POSsnW7TVl14+MT+nfvdYNQosOJlZ547YAsge9UevCzpsrvr9wsXfYr8cmVouCA69xFkqjIBwHmh3jGSDV5GDgrqX6B3Ve6YxSgHV1rv00h5PKPkef+nGFbdc+v0s+cNXgcAi1ptLz8np7X24GsgPqAlx9sdqjlW3rlqxI7g/HfLs/HaqBaTCt9oW2okfqGv97q/1q18qi0AdtoO0Yriu1DrUubi/aI6X+QZ3hHtwtae/l80USqTdJrN7SpwVvYWIVK4p1Mv4z35TmJ+iL4QbroFOax2C+tPbc81DlNXHxPD+kPzsTqyq1pvT6GZ2PRHpN2f3tYsE91g1Ciw4mVk4bjrQpO+XhncNgdF/t7e/IubeNrTbsqrjPPrh0h9SgnZZcZKe0OeS75yX3zTio8qx1SEV3cEamfWl7Vr9cV+OizUv2yrPmHj8nNlnMzwcJZLpQA8DHer22J3PW7g/WbWBDv4b657q5GGlrHrbG8Ur5NZw12gOt7O/Hsq6i8Vbk/kd1jeXXqn2t6tJ+5ot8Dmq6OLFKc7dnfcjcR+uszbtfO1ayVvetQ+sTFM1p7NiT+9vLfdPrtz4b7514zx6Ram/pi7yZIk3IJ1aSbE37PpHYNfN58/lZFPjCNBdinzy72qPHKq8LW23196WmdY3ZNWRsdeswtedsGdtwqZz/NO3Vfrl7/Pjp+FSet3YKba7Tz/WZ2l7qe7u/n8Ng3NwzQjS1vS3bSD3DPVhIbwboWODmCqFb6arEKm2AaGd4ySdUadH3Dj8pbbhbOJ1jOpJYecdhA4I4Ed83KdvqUw2G5eUq5+SrqjOozq4UGwXOq0PNWdc3qXuxKTy43MEZmfZT26P6l/HUay2NQbNxdcaub3qcasCt+lgcbW0r3WvarsHJjcPSrjVjuUc/5+xK9SzJWf5R5iaa7yy7piZavyYxWAPTcbxUbY2LnXoM6liJ7X6MV6VxEXvzvfEtQf+78Zzsq2DtvyzJHInV99RliVXdl4N1ZhSsFTfvad8P6klr2a0nS7CX13VulfdM2yeRjrXn+yZ1L75UxiboT26/vLhI0p63R2g2RWOp+xS1n65PDFv9+gzn62qbepxT2Xpf7ott1s3N6kvUGJey9bn02vVf2ZJt13P0scSCZtMl+vv2otZA2QurQXWO/Drx/VLXl9c1PHXXRGk96zZES7svasz9uPg2F/1dYm2+PN8DocSGpXKZw9/LGhd7jDlGuf563a5Jsav0T2y+eYxEKOv6xEo23QC/+NPGiDZU2ph9MLq3vj6xGtxTnZmgBrHZYZ3HquLgrBN0Kk6qquubui59NFXJtSudUbRm1vZ1v1dGY5idd7Uv1+vv1ffMHXp63vQt3z8dS1Gyuba7ETSiwKWUgr/pu8Y/N1gDohvMUydVp10Xrs/RXg7GqD6v67J7SkvPxfa+SnO5Gij3B8H0i3wOaroksUp7ZJnbOsf9vtUK1oqbd7tWmvJeHO/V5cllTcZ7st+vyo7B3jzenu+buq7XeVK2K+jmZVr6EO3TNJbhnhq1X8ZrOH+XKY2lrzPNex0/GTtvT7bF+rHe5rr+kkyd8lKvxaiN2ytq08+Nucf4YifXn6R0vyvrZMfO2uTlxnmosjZkL5VBlLGX5/JeqQT2qraTLdEkdHsEodvpqsSqLvRessHHm9FujDH3dkpfnliFQTY/95Lqz19Dy+2Io2ltdA4jOcWlveQI4/FcUc+leobXnROUum88KWZsw/FQKsFO21rNSf3ong0cfnqun5f++XEA6Mes1BcFJq3p9dxeOLx1bstLq/yctSdiYtcOpT1bjJOf8485kPs10a6L6TJW2nbbT32v3VP5dT9X2/sqtbnapPamXl/TMUWP0NF4o/eomePi8/q9GqwVN+92rWTlddi+AjzG7imp6/fLknRI/cmm0o7xm2o9Fl3WXtl7o+u6/bTnbJvHFbWn26x+KGpn4NvKXKTf2/LPlDk9RFkbyW90jWX7c7H+uSrbuK6hga/Wa9DfY66Z8b+tsl/s+x33a5Gxpc1jt1+iPg/70a+HXJ8bx05b16VJqa8feymP+1bqc3tb5Pd3el1t7ipD6Da6IrEabOIkuTZwSt0DA6f7AD02sfKvfR1ZtaxdK8+J0zCDpOtTP4ujmQ2mu971rXte5qf0bavuC2Tal/rXIOEk18wYS5/buklrq3s2cuK5LDlWdX//fBwAZF7MfcmuMvaDYLxqdn3zml07omj95HGZ2HCR7FhLuy9vYlPU/qJ1HvUalW78XurQ+13/POuPKp+tkaI0l+s6beOR5k7mfb2GvlJH4k2aU7eWej8l86v3iV1/SW4v+XrkdV5rUt9sH7nrtV5Vf63L/OW8Ra0N/fPB9rq+Bc/LXkl926r7oJZ61/24qtgTXpP26z5f7iv7dx371c4dGvhCrbTPu/rEPmWD8mdZ2cbV9tROP2bJ5up/3D3mmvRpw87jyjb69dr8YdSvRZEtqSz7w/X+qM/Rs+k+3Y4eOzeOnbauS/VLn4pte+n6rCT1zdpD6Na6OLGyG9opdH55Q/kNYA5TRxzsDXQksYo2c9us4tC8E5YyGYPiDN31VqcuX54pY+oPmfa71VlyTzdcymEOUQ91Tmc2B3eYH9O+1D9YU32wtEEkj6dfc4NAI5oFxaQoAAT1pfGu7U7aE0WBqyg+DBSF4yJt+brsHuvm9lK59pOtYT+rTfJ/NxfrOGkb7X3rmi+Bu1u3U1o9aS6XBur/S2Ea+/SL9qvhgZ3oYdrrf9N6c+vfzK1WsB/3rJVe1W/PsP4jVdPFvsUGX7/c0+3nY+31a1eej33L/NpOpXGNbMp7uY1jtKfKni9vxuThkPuqTTP79H2LRr7B+yc/vmX/t/Zi376WlXb81Bk/beqUl8sY1HbdtZsoqNO06ftQZO+xmvUnyeynrL4+O56mzk7R2O9QikFLPOvWltNknXoO24DQTl2WWA2czqp03W2AtDHs5m7OuEk25aMW/JHEam6Tc/6iMkbRBk79Lvfnn3tnYcchO0zvGBLeYco4Dydmkbve9W3yfDRfVtnO8S1xP9b2B05RridnrfqaXi/Xalt5HJcy1bh9ZnHo+hduU1tt3Pt52BF81/74evRaWO5pRsb7Jtni1o+WXL9o7+Q+dO15ubGYyY+7lYxHUE8UsBfVusb1WUVz3Cncd23e7LgN7EUP0R7/G61z0ajcant+x/XI3pnsydF1F/vWNRtgmz3anu/b7Hm5d1Z3sdPHkqFqW3lfmT8Qs2jkh5qPy6/NPYGPE+XxU/104xup+pVWf2lfDXi6J4gn6zOrH1FteT/t/Jofw1yntf1F99lpcw6KTWs3qo3rM3k+ehvVM0sf2jC4efD3ioLY4Ockv+7r0fP78VLv7+diU3rcU92qfzsk9mlbELq3jidWwabxihyEd7bpHr25Sr1x0LmPdieSm+oDVzQGrY9zRyUy45UcS/9c1G66dzJ4ftxz223cE4Pn/Rx2Sv3zNs4l7Zt+DgNLDRqZHMzbOqnj/aH74+tax1HwzlnVnyoNgr/I1LH0Nb2O5lPdU8pFNYCv5aW+yZTlZ8wN2TZd1M3NtK9Wfk2Eqmt3GVP5C5/h7dJmOOaDsV7vrWMfrZ0SiPX9um92EPq2yr11bExfpU/eXvQwXeN/d63ZHRrXI+tutm9kzQbXjQ9sa9f7kb7do+0pf7UyeH6HX9707cm+pY5lP6X7ZF8l+3Mf7bPZttY9ee3GJBjz5OfUfkxjtPSp/jn33Ny+vkj96f91bLr27PjZ32delNpZxrP8Q+z5Pje+9Z71kcVO50+MDRu+ZnsO6pi0+lK8W+ut4277Zrve1mTCjUuzt4xx8p9+vG0d3diJ0ti0e0wzxSd35U6tr7791r/Z81VSz9a4InRLHUusymbpFrPaKBnv4GUjqDK36RLa6cj1DSd0C12VWPk+bOzwGiRG+1scmq5ij5MVdfetAU9p4uQ6p6Of7+ZpHtDCtjdk2pfnHzDv30Zp3/RrogWUwbineVFlqR59/4JdTNN58Wuvk7czaq9g65F9r22vAXGwjlK9yzWz7sZ7JqnaEnQgHxKisat179tj6D76qsQqr4vKaH3J4bG/Zp6NfJXfmyN19x1tz+8t+7zt49Y6j9vWan56aVfbMfItUh6MT7JrMm/p+vKcTRhE1XdMKPdvtfE9tT0HP0MyDnY+x1L3LvPt1/wuNttA6LiOJVYn00/r770lju2fi2c/Xv6AhtBjhP/9JpIk70QHzH8ysTrZHCD0k0VihRBC6OHC/6J76N/8xAohdBaRWCGEEHq48L8IIYTOJhIrhBBCDxf+FyGE0NlEYoUQQujhwv8ihBA6m0isEEIIPVz4X4QQQmcTiRVCCKGHC/+LEELobCKxQggh9HDhfxFCCJ1NJFYIIYQeLvwvQgihs4nECiGE0MOF/0UIIXQ2kVghhBB6uPC/CCGEziYSK4QQQg8X/hchhNDZRGKFEELo4cL/IoQQOpu6xAoAAAAAAACOYxKr//7778fw0/oLAPBdwP8CAMDZILEKygEA4L7gfwEA4GyQWAXlAABwX/C/AABwNkisgnIAALgv+F8AADgbJFZBOQAA3Bf8LwAAnA0Sq6AcAADuC/4XAADOBolVUA4AAPcF/wsAAGeDxCooBwCA+4L/BQCAs0FiFZQDAMB9wf8CAMDZILEKygEA4L7gfwEA4GyQWAXlAABwX/C/AABwNkisgnIAALgv+F8AADgbJFZBOQAAFP68fv56evp82sWvz9c/QR0B+F8AADgbJFZBeeP98zk8PMx5fh/Vtf/QIbw/lzp/vX7+WcuzTXEbmiPt/fl8/RXVedzmLf68/urGK/H8Xu4RW5Y2X59dv0t5aIvY+fz53pVX8piF7Sr6/udxSddX+zy57l+vf4JrN+R9GQ/Vx7Q2hjbNGc7BgvQjXS91Szvba20Ps/lbSIf3eA7Fhm58ZTzM+igcSgIqxS55VtUZtrvVjwU9fnPU+trC93Xpv7HN2S6IHbf1E5rrfcOueJPWfTAeM5ZxeJ+s8SHRelrYP58FtQb1+Kd6Bm1oDrU32AeHbd5k5EPVGhBbnl/TmjbrLpXHtoidM9+Z+hG2q9gxpodJc7ixvt092dZZHPpKro9T5jxS1vhtYsPC1njP/ICsLbUPttbUbtQ+njFvazteeMT+5/ft2NDajX1xXo/ztufxPa43jov7SDZ5X5DG+QH75lHtLJBYBeXH2XHIGARAi91M4eLduzh2tVcY1TkJiJfSnJ70tbQp7a/tNEeUNqHuQ7IzcgQy/rMx2Z6fyMF07YdI3dcFrF2kwNL6mILcVXOjx8yOj3Z+c8d7hI0AM1zXxTZJtMu+GDNbA46oPSkz8x2tm41+lD18qwNHmuelb74+SRxS0K/2OtvzczlA6+d6oj4qyp7rx3rOnv5f53/F7uv3XRjoDTvnM+3P2v94HcqcbNt7bP3EdW6t0UuQ8S79Wvpa23x/Vu2s8SLPje5DWo+BL23xwJZXNuen27M3Iq37jTF09yRbj/ignaSxO+jr+2eu3C8u/lS/sHedbrJnvM26dvtE7CvrYGtN7WbH2trXVjD2g7rTGjq4T9Izfn2U8Xxe9ufsDCPrZDyHYnc0JzL2dS3kedC+32DsKnP2mtdOeP/K1lq4jJEfujUkVkH5cfwC3FhsA3wgijZSuImuaC/V56+l+gd1Xrkok4N4XgJzemfzeTkwL5tfNtraJ2l3sqlChyTjPwto2bF1fXF4B3NJQLsbLrBdb5seM7t+9RqbO949XLI21VyuhzVdZym/Zi2mwOPWTLC2+v3m1+e+tWXZEzTKuE37qGzRtkd9E9Ia8raMmc+7XTOXcI3/TfNyzfwXuvk9OEYJbcdo7EfjdXF70bor9Q/qvG4fS3vP6aAmb3L8Wnz282LHa5hY6ecakS9J8WByME3zE/TFcIN10JHmcWN977nnBlzi628du26134bsGkvte7N/XNeTrL1i39aa2o3YtNHnaVtmP4i91S842wvjOdP9dqw25jqTLWksW/2pXueTctkRpP3e5+i+S52mT94fjMYz2Rv5zMs53r/btk9iFZR7Rs69LaqNQ8ZGwFkpG6Jva+BMRuxtb6FzDOXZ1Gdfx2hjHKC1lx3N65/iCJZkKz6gTsa1srkxN+ZnwTqFPM7ajmSzjI20k/6/lKexyM7Gzol7Xo9jrcPMdW+bWXPSTn2uXE+OI9Vb2vJz5e5fGa6xSk52a32ds7wYsXMyB+Ec5r7V9kf7MGOfHTnWtS9Re1LWrW9v97wf0q7ZT5dQ5iiupw9um9Q+yZro+hfvDT/vo/Hs6Oofc3G8SeMzWUsro7Fq8x76uZWNNasYjk+tOxx7z/72ct/0+q3P7pvP46j2lr7IG2HSF/nEKr0rPuv7hK39Mp+fhWDPprkQ+4y/0GOV14UdDxk/Zcu6xuwaMra6dZjac7aMbfDodmqdtm2hte+urWM0eiaXR33u67B0a1vuG/U9xZ16r+/vyOaF6Z7u+2RZnlO/OiC2zNbUbpJNUXuWYVsyFsGYRmvelC1r7n0ZB7t2HKmvyl8U/1K/Au33eq3Ll0u7Y78g4z6Yk2C+fF2pTdV/00ezTjyjdbCfaIyHpL7M9uZxSKyCck+0Ue3EbS3AaPEous3nnHxF6lqd12AhHGyv61vaoEtZ1J/avi47yNBZrDYFY6n7FLWfrs8245ZjzkROx8xNdQZmvnLd7dn8uo2pm8tax9qPEtxUv/IYqf6s/W9zrm3L99v10NnuSfNc27Rjnuorz0o9Y8d7BBfEQ9yaLmNV2+/W6orY3/ff2p3bX8vSmLr2dq3vvq2VZG/Qh806NWLnbC17yv3vYrvs22UcR+2Ftti5r/jxk9d27IPnDvb1snij1tFsfSeCuXLzrte6J+2hdW1GBPMUrYGFPJ7Z9ngNH23P9y2vg18yNkF//HweR9rz9gjNpmgsdZ+i9tP1yTxm39bqCHFrrrapxzmVrfflvkT+YX0m8Lm1zPoQ139lS7Zdz9H7kgBEc+/XxfL6tY1JNEbvz7ZeG3OiZ3yfc5vmnsWHdOu54PsW9l3Ga62vrBdV/9RmV19IuqfWke1f+6N8j9iix+JipD23tjxRWzL2qUxscvO2juPAT+h5Sve65xO1r6mOZYwTy9hJDJA6TbmivHmt133dK2OiOfHrtZXpus3YpLlTzwRjk5F6NtbBIeK9oe28ByRWQblnunnSa5m8YDGUxRQvoEK0wPTGUNeaHf0iTlzQXtc3db1bgHJtw9HsR/owdix+vBOj9st43XqzJKejxzK14+e5OUJ5nZyht1HbHdWRymzA8P1P9SpHbG2zNgzX44pfP+P7b+eENhymCZpCtkkOimZsZX2H2LXU2+363LVXyrbW9/AePwcFPfeaulcPstaf1oyUlTGt/fH1+vXb2RLPvR+/tN50vSO2xk9xSbyp6z6thfr/YZvSt2COVVmtpz2Tyf3d2kP+el5jeSz0NWXHYD0cb8/3TV3v1qhb+9ey9CHyz95HNUbtl/E6sGb2kMbS15nmvY5ftFezLWu/yj7yNtf11+5pc2LXYtTGiPm9ps0B/p7+GddG8h/RXMV0+yzqu6uve8YxG8sIub+tu/GalnbD88NRxKaNtdm3JeNc+iFjrObAjkdkv52jdH99XtflfIjcN1o7W8iYjp9VfVHlad7SXOs9Iz/be9vYlPuW6+tYpfUn9UTM18ElpLEs63Pe59tAYhWUe9oCaWV2kwcLMDmKZSKnC6jQOUD5LrvU/z5cuGbTXdFeXnCj63rjLK/15r6QsD3dZrU/akeuBY4uzUX6vS3/TLa/a2uDuumSA9F1Jtts8PDOMDudiPJcVIcuGwUY95y3zbwejFMljZdZz3795j5lu2/l5PbMhRqXZRyeFxvF1jq20T7M5D2jx1Q/l8ntr2V1v6zXS9mOQBqtzTT+qb7tfsZ9qMjzkzFPdi/1eBtC26stpZ/huvBzn/Hjt71mFjbWnedovEljX+o385D2RjSu/brw8x7NZ+5r9r1+7iy2/2l9ih+S+vV+lZ/XNvpxu6w9qWdyXbe/taZ2EbWn26xrLWonX7P7caHMRfq9Lf9MmdNDlLWR9mK3R7P92Qb9cyXbuK6hZFtvl16D/h5zzYz/Nslm1YfuWtefOt4KdU//jO1zXOcY0zdh1vdCXzaxeTDelVSXsdevKVt3t9YuQWwK5kMjdhm/M9j3eX7delDXc/+t3abP+l75udg1Ghczxiv9+K7rboh9xt/f+i7ry97bxma5tthoxkr3xyD2j9fBIaSNxUa/FqQPN1kfE0isgnJPt3kWZHLGi0peR0E1wF2v9bb6S12y8Uw9qo0r2uv61j2vFvpW3YeQep2jWcj2yCGjv5baVw4lb4469sc2pJ2/GLnH9Ffa984xtd82aveMJ6pDl40CjHtubFt2rFt969Hr6R5szE/qd9++9LOOrcy5duoW+6x+LpPHZS2L2pMyHUj9a19HodkVjJ/My0Zwtmyt47ze+v5PqO2nNRJcH6D7mdZbcE/Hgb4eiTd5jNv4ptednxIb9BwEa9rNu69HXue9szUP7nqtV9Vf6zJ/OU+V258Pttf1LXhe5jv1bavugyz19v6l2BNek/brelruK2tkHfvVTv3MADd/EbEPzvtmtWH9uZJtXG1P7fRjlmyua9zdY66lvTa3syfblfaRsr/vT75Pj7O/Z/RM7XM8RmNM34RZ3wu2bMPmwXjPufG69iSbFhs3GPYprev8zw/4scnImGT75bl1PUq7Sx1p/Epd+udUb6pPrZeErLfRmLS2dLlpt8M/s7yWdtO4LG2V8Un9l59dH6VuPTbSh/V12h/ads1t5zTNiVmHt60/gsQqKPekRR0sgLZoJpM1XUCFumHqwl1+7hel/KEHVW+5p9sUh9pzi70+r64bZtd2kYNXaNPqKPI4dnYJ0v5y36vaKJ3DGdhn7ltImy2wQ49nukfXl8bWB0uxuT2X18okoEZ1mDJbXyXb257rbKuHl/SnTCftJybz0LFV1wY7g5On9l+v8XBNJGTMrJ2b81uDg3qmBYc8B77vrU5VXp+J6hPKmu2D6ohLDgt5Ps1XLSJCW9qe0/fqcY+JnzvCXv+bxt3Z7ffzSrCX/BrQ8zesZ9ceaf2XetJ4detgscHXv64zVXawvX7Nz9bNJWvKkcY1simvkzaO3i4h963+meW8rvT6mdmn71tI4xvYocYzWi/5Od2eja+5HVVW2vF7INVd59PUWcagtuuuHcKsYddmcD26p3um9K/2x9i6g+7+Wd8LpmzL5h3jle6v8z3lwnH3iE0bYyR9bOvIrdW6Z8w8ZKQv8pz8366xNk9p/Mqz5j6pd2jXaC9p23Ib/bjNsXujn0u7n5zNC2aspA/BuNzEV5X9HfVhhp2H6yCxCso9dvNEuA2lGS6gwuC6XaiTjeA32MH2ur5NntcbPaY5hfi6o7SV6l36kf6iTa0/2LzpfulzvSe91vfkDdW3n+3S/YwcgUfuMf3t2hN8n8tcuefWtqI6XFlqV9+TrtuyzraFNI6+7d2I3b5vO9gRED1/5C9BTl5rpJ91bNf+hVjb9XMhs/W14J/Vc5J+9vsuqk+QOjeCs+VoYClBpMx5tC7myLxvtJf6lsdlD9NxV+zxvyOfs+2LhO01Pa5nax4G1906mK1ZO05H2/N9mz2/PcfJzt3rtLYl9Uo/bP2yBq1vlfulz/We/LqLO0H7efxUP0f7TJH3qq6/tK/m2e/h7pl1zau2kn9Q45juaa/9GOY6re3y9eb0s2EZP2VbWI8eG29H9VuT/uU1oNdcfq2fid68bdfc+tjoe1e2ZbOrbx+zNT/Dj8UAscn1ySN9tGu9EMyJRuanbz/YF0Kta1Sfup7/QE40JnaPeo7E5DxXbV2neQ72pO+jGSvdp46tOd05f55kt9Q/9x+34MGJVdnMGxwesAu5XX8ni1YW0GBzCWlRBtdlUfaL0C+IoN2D7eVN4eZg8LyxKcJtuJDFvvZVP+UEUh/ts8k25dj6jRmMedk8bQ2VNVf+Ik6tb7MvC3KPGYvAxnCTrxu4sFVHUJbars+Lze6ezjYhtbvllEZIP3zfdiB2bQSfTJmHhG5H1kJbg37vSz9rmZl/wwW2B2s1HNM07ku562O6V5eN1v7u8alIX/bMYRtPPybrnt49L5esmUufa1zjf1MfB37qCON6tg5tg/6bdZAPSsM5Mu0eba/Nf2Pw/GhtKmQ9z/2h2LfUsazndJ+s62R/7qN9NttmfbAbk2DM/Z7K67j9OfdU386+SP3p/3Vsuvbs+NnfZ16up3aW8Ux/aa3e58a33lPKkr2Rn6jPT/Zj7mu91/UvtZOvVft832qfx8/4ORH8GOg5tHR929F3Xza12dW3j609MyC1NV9DCblvMmeC9NGOW1nf0hf5E/DduhNk3L3deS78HOQxa/fWMWx7QY1horYf4dvU9+pr+evL9bluXajxq+vWriuhnxszVqv/aNczO+Z07/wVqo2tj3rd76/nCDdJrPwGGiMdmnUkT3Q/SffhqsSqLupKuEgWogXkno36Kxto5ugq3X0H2+scg37e93FrEQ43S6XNv7Tb7BhtpsF6SHZNNl+xO7+T2ve39Scmmo9/gV37sJvTfYzGpFs/nrW9fQ4sCiR1HiO7PNO5k/Wp7t3aX9mWkd1uzaZ+ln8DTLUR49duXufr9dkcqj5srtP13sleCYO8wo3ZXvbsoa9KrPK8VkZ9j32SeTaap7IONtd6d9/R9nwstc/bPm6t9bhtTdvnS7vajpHPl/JgfJJdk3lL15fn0rcXuv7aPnWU+7fagH+N/f5fM1zzozVbuTBGpn80O/2/tjux27Uva1b7zLp/Yz+a642vjfayPFPLq13zPV+pZ6a1veq70v91Ha6/ro/Zh+z5Iz2Zi+cvjcGOehLV5h0++wA3SaxqR+YdENzAD9gTlG/BVYkVdHjnAI8k763Hjv/2gQxgBP73myAHpCAJ+lchsYIZnFP+bf6F+TuYWO1LjCw+o51lhjlBI7EC2Et7d2b7jQ2A7wP+F+4BiRUAfCUHE6se81Wgwcf/lyVk90+wCOwAAF8D/hcAAM7GhYlV++QpTKxGXy2o381cy6Qe+1WiR37MR2AHAPga8L8AAHA2jidWKTlqyc/wE6vuF9tqWfzplIbECgDg3OB/AQDgbBxMrLZ+R8rj7ucTKwAAWMD/AgDA2TiYWAn2TxkOiX55lE+sAABgAf8LAABn44LEqhL/ifX8N+/3fqrVf2L1SAjsAABfA/4XAADOxhWJVSYnUkuC9Sv/f/hnTuX3r9SnUps84M+lEtgBAL4G/C8AAJyNKxMr+cTJJ0VHfweLT6xgD9FaG/Oor5MCwGXgf6+jvqm5ixP9A8AAAN+ZY4lV9ztSURLlD8BL4vS+73erPPf+B08PBfb0ids8aUz/MOHsHhm/wwGu/E7bQ//BQ2lzlvAeS3IqOdmRZ9sYpcNB0Ld9f8Qkj82uJOrg/OWfNdGzuS/Py73hV2J9v7o/3gLwc9njf6Pk4dfz8zieOP/6/mz9mNRn96r4kB17Uv/F24ij38gQdH3JN3if6/3wDn+3ZedKrmsaY0u8n91z0R+bSmM1iy9X8F3mQTjs73fMSUXqnszzKK7mmNWPvczjrnYBYJNjidXJ2NPf/oBdWJyWD/p7E4HNJKlzyDmR0fXf1xH6QHIpkRO3idUoSNmAnfuvx3oPMj6Xzp8Z3zof6f/t/l+vr6Uvvp+lT8v17TcUbjHOAP8eR+JNuB/dPX1S8Z78mOyz+qxNrIpfkcRqaw/uTlg8uY3WZoCu2xyYmx+uvqr6KO+79tH7sIa04/zsnv7uTJJ8vEr26/pHc3oz7jMP2W41ZkKJ73at7STVtyMmGPt6kp3ROaP08XUUFzVb5xQACCGxCsot4pC1w5fXysmOnE8KOIGzGmHqCZIN7fSVo2/PXEEX1G5VfxsrW+YCqOlbxiZWI4Jx6rhs/vJBQA5mS/0pQYqCftAXYRT0unEG+LncJLHSviPwI+v9pVwfdkf7X9oKfXTIfD+nNiKbCun6sN7s3+S16fukvuEYKPQY1Nd5HCJ/XWm27MPV09nlfLdcH8XSG/CweVj7MRkveU7ui67NkOfS2g+uzVDjOoqrZn8BwFWQWAXlHWsgt8GgBSR3v3AkUAT3TuveCq5HWftXy6SfS2DsvsJpDxGjYNQcdBSo42TEO/woAIyDn8fVf8H85UBjEyv5yl/cXqb22wSpaQAdHWIAzs9dE6vpvosJ929F170yeGOlkuy8cI8v7WX/EyQoq8+S9uO+eHx/1j6afm0lVnv7Et07qzvbEx34b8Ld5yEoN+MqbI2fvR6uQY30qVuPjTC26X1TYmG0VhKDuAgA25BYBeUryREFTifx/Pm6mVhcwSQYbDrdo4z6qR23ccoZcd7DgJ1eR8F04zCSiINQHyxycDABWdt5xfzlfgw+sVqDatC/0uY6BqMAvBloAc7Nrngj+8fsz2XPpDd8yn7UB9juMKuQfblcexeftey7us+7+xZC/xrWPfNl6uA6PaQODrjlGbHFX2v+LvA/gZ26P1F9lfzV5ujalr/eR2o7GosgttyOR8yDQsb/+bXUpfs0WCvpfmnDxoM6Z1GMTUxjW8H1N/eh2mDbM6w2BdcAYBMSq6A8pg9i+qBvD/0DJz2ld3JhILppEJI+1fZ1nYHTDdq9X2IV35PG2IzZiKj+I/NX++ESqxpw1sDj68zzLge3dQzk3tBGoZ9zgJ/CEf9r/Ir2RfoQKD8HSUXaa6W87nPvS/Qh2fqwQlD3zJeldms79f/d80Lga3Wfpkj7rQ8zuv4seJ9n/ZnzbVM/NsD3Ic1b7/PC8b4R95+HQaxfnpO213UVrJ9ky7p+bPt6TEKbZSzDfmS6uU3tL3HJtBfYXdnsNwCMILEKyhsT51OctHF+O5zRsSCSA2cL+tmemwehLmmyTn69JwgM3hbbPxec17L4MLISBCGhH+M8HuadQ9OXy+cv96N8BaS+Q14Drfw/1bM8b8Zp6ZurdxycgzEG+EHcIrEy+1b5jVS+7FH/qYLZm5VUX/YJ8jr00aFPin1Zalvboe1b2rF1D3xUeqb3n2Jb8yeBfw3sNP0pNvRIPbo/Qd0RXeyYo8cmlSV79j9/hMfMg/PjUndpR7fZrSl13y78/XXNzlD3/3l9dvM7iT9HbQMAA4lVUB7TO1dxnNVZGset0PcIYdCekYJAdobJmXfB/QZ0wTFwumKHa9v3TbD9i4Kzdu7R6/EYpTGOAkiHrS9zbP6yDZPEqtwr900Pb2n+IhsFPzYAP4frE6t2GO78xXTfxdQ6pK3oeoz1NdlHtTLvV9oBvt4z8LXpGeWzSn9sP+W6tyemG5+F3jbti3t/2d+zcDCxqv1P9pTkwPvPW/C4eQieWynPpfgR3LMnOVoIx0eenZwF+v4Keu5q/wd0zwLAXkisgnJDcqTiFLOTfH5uh2Z9qI4dWXZe2jGOgvY0uBRn7oP4zeiCYw0W1vmKjV2fyzVNCzoqIK11V+de67bXW51BIOrox7fjwvmTa/nfy1me3UisWn9bXWuZutdSx9iXA/wMLkmszH5Le9v9O3KzA2fyc8ve3Nh30Z5ObXX16oNqfi568ync/8V2nRwa0jNSv37t6ogI7dSU9pb6sm3L+NU+mLGLfPeCrz+NabFRs8eG5b5unG/AY+fB+/HlXnVPand5btrPsi7tWLd50vfW+o5R16her95uhYxJNFYAsAsSq6B8xTi8FmjEubV/wyjfGzru5LStUw2D9oxSR+VYIMoBYZp4CKmfrS9jp2vL8zjM7GljtpapQOyfzUGjjbFNJHNf9FjMSHVfOX+pbOnvWkcNODrwlJ/187n+0jc3fxY3NgA/iN3xRu2h1ZcVPyKvjU+V8uhQr+7f7Rc1YsMkWYj8x6y8Efja1b8M/GexI9VdxmWb7OtS0qH8VGsn/zGf5pODtuthX/vlNK7aT29R67B2xff2JJu/1Ty05/J86P7kdZb6ObE5U8dlmYMyPvvW55/PP26O7GtNnudsn58Hhxqr3C8p9+sBACJIrILyGOtcfYLUOe41kBfnWhzr3sQqBUD1XFc+DRKFvUHv1vet9AEpjZMPMmWsfJDtA5UnB4d9AeiS+attL8+KzSXQrnMg9cmnWcu19NfGSn1S11r3GpxLvStBIAf4Qezxv5EPyGVt35u97PebvK571ey1drDc449TPd5v7aDzKx2BH1j70PvPsT8pHLDT2Nb59r7t5PeKr1vH/1DsyONt/PVavs8Xer+9l/vNQ7yOaoyoffVrtkPqS+Og2Jrn6L4Uj2odfl6kH7VsEn/Wvsnr1vftMQQAgcQqKLc0x9kClnZQGet05Lp1otWxzliTsPRzezZEOdaps97pCFuyMGfTLhVAExvt53EZB1WxK/9VPlXnTnKgu3T+vE2tHj8Gvg/yuv5FQW3PiEsOCgD/OsfjTdmDPnFwh1LZn82fbR/613tnCYm0Mbs+wPqVCHXAVf2oPiHyy7Z/RyhjEcSO7LO0H7I+MPXD9L/FqiHL/TUJ2x67yE9H94xjxYx7zUOXWJZnY5/e1u86LpXINmVHQj+3EVczZY7W8Sxxz9c7JPcrjV16fdnYA/w0SKyC8rMgwcAnAQAA34GfFm/gSiSJ2UzQAAC+FhKroBwAAO4L/hcAAM4GiVVQDgAA9wX/CwAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNkgsQrKAQDgvuB/AQDgbJBYBeUAAHBf8L8AAHA2SKyCcgAAuC/4XwAAOBskVkE5AADcF/wvAACcDRKroBwAAO4L/hcAAM4GiVVQDgAA9wX/CwAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNnoEisAAAAAAAA4jkmsfpJ+Wn8RQui7CP+LEELobCKxQggh9HDhfxFCCJ1NJFYIIYQeLvwvQgihs4nECiGE0MOF/0UIIXQ2kVghhBB6uPC/CCGEziYSK4QQQg8X/hchhNDZRGKFEELo4cL/IoQQOptIrBBCCD1c+F+EEEJnE4kVQgihhwv/ixBC6GwisUIIIfRw4X8RQgidTSRWCCGEHi78L0IIobOJxAohhNDDhf9FCCF0NpFYIYQQerjwvwghhM6mCxKrj8+Xp6fPl4/yUvTx8vm0lFl+f779LdcX/X37bZ8xkjrt/UlBvb/f3lL7vrzyu6tkLAI7Qgh9jfC/CCGEzqYLEiuRS64kAbKZVpAoBQnZqkFiVWXq1/f+/Xz73eqU5I3ECiGEvr/wvwghhM6mCxMrq48X/0nRIFH6+/b5+/fbkg55HU2s4k+rBBIrhBD6/sL/IoQQOpuuT6zS1/WiT6cmiVKno4lVvZdPrBBC6F8U/hchhNDZdCyxkk+c6qdDks2k13FCJJ9i1U+RXl4k+Sqv5RMrXc+ElkuRWCGE0JmE/0UIIXQ2HUusiiSBaYnOAUmCdOSrgEECxh+vQAihf1/4X4QQQmfT1YmV/mSqwydRRxOrKj6xQgihUwn/ixBC6Gy6OrHyyU1WLuuSnJskVlpR2/tFYEcIoa8R/hchhNDZdF1itSQ8KXkyv2uVk50wEbpFYiU/R5+OVcL6YxHYEULoa4T/RQghdDZdnlilREYnQ5Ic5eRm+HU8lVhJHS332pFYhXXziRVCCP2Lwv8ihBA6my5KrOy/W9USKkma3urvXEWfHOlPm8z1QWK13j9KukisEELoXxT+FyGE0Nl0UWKVVb7ytyQ+YWITJEXpD12EX9Xb+MRqlUriJuxNtC4P7NL3LXvb+Gzj6xoljFvjdNvxqVo/XZQ5rQ+Xv9h4tK79amNgf6dvn+SZ0Sens2szJTsuHEOEkNVViZX2RSPpN/K28HXJs0Gs2vJF2kcMCWPgTItfT8/YuJPi6WpL9v2rX0t9f1lKH6t1fFJ8ONi+PDMam9m1mUqcSuO+tV4QQugGuiKx+ve1p7/Tv3oYcoNgNgpKm4eJrcQr9+dYfGl1mk8qS8C6W6xSY3DcZlFJMv2Do7Gt90+4JBlDCMXaFW/0wXgnt9inxtet2n5DbSvxSv05mCCMkpUUm9a2vkNipd4Q3IxVsVKfOrtHbzTW+ydckowhhNAVIrG6SNsB9lKF73imiJKDS3fNBI7t5EA4FO/Wd25bgvUQrYFZ2r3wgJAOItrmPD57+l/n4dBYIYR266p4c+HBfVuRDy0+JCUr/pr1EaH/9hw67LekwidtNrFySrY+OrFqvlpsu2x6cn91Ujvtp1ZNwi9rGCGEbiISq01FgXbMte+WSvA0dZQDhA+qSd27n2LrPPm5POA5dUmLTfz2teHG9iaGXTdf9WAUzWO9dhMzEfrh2htv6r7bx7XJREsOsuqbaLFv9f409NNanc++XDbhyH6vvXSJVU0KtW0mUZzHjSb3Bt8t+7LasoFvsyZUkS0kWwihB4vE6iLVYFteelVnfhA5zEtg7hKrpS2bxBR1QXpfUnGTGJP62Gzy7yp+vG0H3I8XfYDJtkcJzfXamK+izeB+o0MEQujKeFPecBrp0EF9RfxRnFj9lmQiaE/a0cW7ksBbJiNr45PEqsQj7VuznT7x0v2O9fftRfnRkmRN5uEadbEwkkkOI/YmjAghdBuRWE21L1HxzOLM1juaYWJV7vdBPF37qsO+SaxygL02KbIHhVtqX2LVqQTt+yR7CP1s7Yk3uxIVz9Qnik+f+YI4sUr3d29kZb93F5e1Q/sSqxLDbOCw9yZd1pc0P3eKQbsSq06lv18VFxFCP14kVocljnsJtG/lH0fekkt+TGKlkqaq8CCx3uMSmPX5XN49t8HRIGrkPrFqdrt3Pcu7pa1df2jR1xauM+qCcfCHrBKYBWNLdBhBCF2qS+NN9qFvy17f/oSl+oS2b4v/Tnterk32/4q6Z01YROr5VO6f2+DKw/92YjX4pK3zyY0cW3o/qqtI7apr1/YjjHkb+NjbbLJr4n5v1iGEUCwSq0PSQdoG7OrYrQ+394hMYlWu6yAh103Q6JIveUYFc9tgJ7HLB6GbyCVWWbk/KcBtBtt8ENC23S0IlkPPfByU7ZvsOdAhhGa6KN7IXq6+Rf9ckwXvd/Q9STqxkpfiG/R+luv6tfK3VfJM8lPBNa9k1338hfWXk8TKtx/67j0qPlL56BTPNn39Jcr92ar7SFJ2j9CCEEJeJFZ7FQbu4vwHTtsmUVldmQty24mVUnDN118TPs+oyt2aBec9gbs70BRbrzbMqx2kPl6OHybCxDT17z6HJYR+io7Gm+rLtItYD9bhAbzt/aa+rE9QNhKrVdE1V3+NG54bJCO93T6xkn6UZCiIW4ffcAv8ehr/G/TFa/W7Sz8O2yl972zK43Dz8IIQQk4kVjuUApg4agksA4fdOfLQuZdA5L27uvdIYtXX1QfMNUDdWibILmPwovoqNm8lHukeFaTTa31QuIHKoaZVmedqOh7O9jZ+7uCCELpKu+ON2seyH7s9WHyHLR8dpF3ik6Tvlet7E6u+rpzoqeeT7Ru+8EKluLR20Pkn48fyNR2Psp3adunnhp3en5bXUZy7XHkudBxItk7bCPpe7rdjhBBC9xeJ1VTOYUsgEYddkwAdmGqQSfePg3GfDGXVA0MOeLmelUFgaIf+9CoHz5cXE0TtPTdU6q/q4zomQtx3rxT06jNLH28XBMtYDA40uV1vYwno7plwjO90UELoJ2lPvPGHatmP2b/KPlxQ/mL1J9VHh75E9nDgn6pvX/e4ZuDPkg9svqAmKy8v2Yen5t09t5T1l9nu9lInVovW+NTK1vGa9dHJxKdlvD7c/Fyjak88bTm++FhW7THPyL1uzQzrRQihG+tGiVV26nc5wN9RR/u7BpWjHvpA0iFtmHHUB4Q1OFZqkHRBdZEJgAPOF2jqoWjPQaYdzl4+/Pqt9QjBfPlDC0LosI7Hm7ov9yUBTSoRE6aOT9rQe9u+SWaTkeYzkr81CYb2IQNulJD86zqS+OgYnJ4LEiihP4vk+ThfzEMIfTddn1iVw359F/FfSq4uTyQRQghdI/wvQgihs+mqxCq/Q2TfuffvIn1nEdgRQuhrhP9FCCF0Nl2UWNWP4+vH6pJMmU+qyqdY3/3TKwI7Qgh9jfC/CCGEzqZjidUkYZLkyn9/OSdgR78P/zgR2BFC6GuE/0UIIXQ2HUusVrlfBg74F35JlMCOEEJfI/wvQgihs+nCxGqif+gvphHYEULoa4T/RQghdDbdILFSf442fVXw+371z4vAjhBCXyP8L0IIobPpeGK1Jk/564D5K3/9vxER/c7VdxOBHSGEvkb4X4QQQmfT4cSq/UOIOrESLcmVKc///85/GZDAjhBCXyP8L0IIobPpYGJlk6n4Uyn9L9fLz/xVQIQQQlb4X4QQQmfTscTK/2GK9Lr/i4Df/d+vqiKwI4TQ1wj/ixBC6Gw6llidTAR2hBD6GuF/EUIInU0kVgghhB4u/C9CCKGzicQKIYTQw4X/RQghdDaRWCGEEHq48L8IIYTOJhIrhBBCDxf+FyGE0NlEYoUQQujhwv8ihBA6m0isEEIIPVz4X4QQQmcTiRVCCKGHC/+LEELobCKxQggh9HDhfxFCCJ1NJFYIIYQeLvwvQgihs4nECiGE0MOF/0UIIXQ2kVghhBB6uPC/CCGEziYSK4QQQg8X/hchhNDZ1CVWAAAAAAAAcByTWP33338/hp/WXwCA7wL+FwAAzgaJVVAOAAD3Bf8LAABng8QqKAcAgPuC/wUAgLNBYhWUAwDAfcH/AgDA2SCxCsoBAOC+4H8BAOBskFgF5QAAcF/wvwAAcDZIrIJyAAC4L/hfAAA4GyRWQTkAANwX/C8AAJwNEqugHAAA7gv+FwAAzgaJVVAOAAD3Bf8LAABng8QqKAcAgPuC/wUAgLNBYhWUAwDAfcH/AgDA2SCxCsoBAOC+4H8BAOBs3Caxen/+fPr1+vknuib8ef389fT0+aT59fz5/MuVrfz6fP0T1HNj9vX3/fM5tDHm+T0/9/4cXx/z/Ple20zjNR4Dqbu2Y5B5COu2hM8e5Jr+/Xn9FVwf8Pzetf29yevlFmMMcGZ2+d8odmzw6/VPef6I727+Nvm2WTy7CfgJAIAzcpvE6r8/n6+SJG0dgk0Clp/pA4sEnO+UWEWI7cdslGRiDfjpsKASKYe5N43Hcq+MXRnfmlilBGVP4rEeTsZtXsvl/ctIn3zZ7v7tIB2WHpKkcWAC2MNl/rf4w/I68hsNe28i9E025pBYafBnAABHOJhYlQQqHdJ3ogPUMLHSgc0GuXuyJ7CnIBv1a0gN2jkgxff0rIFLAn8aozo+Uo/U2ZI5sen5fV9yd79DwoX9WyCxAoC9iVXyA86fDDG+rvpOVd+OxOox/Ct+An8GAHCEixKr3U7Wf0XwH02s+ndEB0mNCdq2HyaZcME9J0r15/LMOlZST7m3fGqV7n/OP6f6Sh3R4cLYvzyff77FGF/Wv3qvOQzNMMlQXjP9tVKu11qyQfr+utipnkllbT6tLfrAJf0Tu22b+tlEaSdfl/Goz7V79Nx0zwP8UA4lVuteV/5wwfg32YvaB5Q9XPfenObL0n417cl+1nUpH72Wad+RfYbYpfe+8U9rvfV1e269X/u+1NbShm6z1GfaMP5yo87ku5rPqvesNpn+CW6MSjk+DQCgcTCxUpQDZQsM4sCb47X0Ae7X63ty+Pl5uV6f1T/flyP9tYFEbPcBydts+7Ev8YjqkzIdtPX9AeVw8d4lL0t9r0ugXOzOCcf755+rxviS/gX3qnt8WX+g0ve0w0t67dZjmi91iPCv1zJ12Entra/rXNg+mnkubXqbZLyrHbZOeb3MTfkZ4CfzmMTK+k7vm9p9bV9bX1H9gG0z+dS1rbLv12d6P9Dfk+tt1/ProX+rSU5n19gHbtZZ7u/7psfH24lPAwCYcXliVWiHU3Ha6tAZIcHBBaPssMV5V2cuP2/UcyMu6e9+WuDbgw5cMk4tGOaxea7BvMOOlT2EBAePm43t5f0TG1v/MsbOgu6LD+YJs57UPcHhKa1TNS7xWOi1l/tnbcpltS+hTe5w07ULAIlDiVXxI5uY/Zh9pzn0B77B7nu/ZwM/4Pa4YH2BT6IKKTnScW7Dl2j/lp4NfL3pi02cNusM+tH7RWungE8DABhzUWKVHbo/lF6RWJlgZ4PcPdnubw4qYQCf4BMEIQUjH+RCljbNfWKDCp4pwLpgqJB25Fpqz9m19/eyLmF//+r66e0LKQE86k+mP1hIuZ+D9Lw+DJRxjMhj2x8obJk9xMT3LKztPGZNA/wrXPTGVpQMDMl70e/vmLY/ra8I/ECXfPgkZuAbzHO23k3/lvyI9nVR4mTb3awz6EdfFvQfnwYAMOSixCpTDrE1ACWHbB1/hzhkF3zEYa8H7Z0H81txUWAXpB+zd+zSWNQgtp/69chWJoFLAlsd1+XnZYxea8D04xXMgQRXHeBlrPtk4CAX968FfH8w8nYKaV3oxGo25omyJpe2ovrN88FBxRIcKEzZ4PAUPlfaX8rnbQL8HPb437ZvjlD2mPipHT4y79mWJFhfEeznVIdNKm6SWM3826WJ1azOoB99WezPBHwaAEDPwcQqO9k+kM1QTromVibBKo5b/hiDCUzO4d+BfYlVO6xvE9gcBvJavqePMj7yfBsTCWgp0JlxzOUpqKa6A/vSvVLfDcf2cP/iuV1tV2U6sUo/bwTw9aARHEK6Q0YZo+jAkIkOFLasq1NIbY/qjeoE+JkcfWMr8hG1PEwgZC/68tBfWZ9o6wv2bODbosQq9g21bVvvpn8LfJptU8jt1jHarDPy0V3Zls/CpwEAaA4mVgPKYdI6eU92wOm+NeCoACR1mMDUH75vzZHEag0cOlhLEJravJQ95z8WsSY3y7MpcIdJR4SM2/Pn6xIkqw3yvA9koyAaHUb6gOzZGywv6V/uz24717VS1s/6emGZi/WZdCCoNuc50/cmm1yfs53alqWN9Z5oDFxZWfftnmKjKnt/VvVHBxmAH8qheCN7ffGvq5+RffSe97zxCQrxH10ilvag9z+yb9u+TH7B+R3jB4J9bH1q8T/muVxPs8fXW3zHyL8lX2Pt7v14bte3MfeZzh91Zd5ufBoAwIyrEqt8MBWKo01OtpRph1/K++CknL4EDnOo9cHv9tw/sdK0YNsY9FGNY/t3rIL7VuSeuG2ZIzPuG+WJ1P7R8d/XP5ssNcQeHbyF7l41Lon1WnCAKPfaQ0R+rrXjbdb25jrtGAVl6cBTn5c5cPc4m4djDvDDOBpvVsyey3jfMfSJoW+z994qsfJf7bY2jupt9xt/lvps7d5OrBZmdQb9GPYtPV/KXZ34NACAxsHEKgeDXQ61Ol/j+DPZUTuH7uo2AeBO3CqxWn/nSQW+Fowqvr9C63Ouvxz0zZi5cQnw89ASXqFPbjbRfRxwef+i+1RiRdAG+BHs87+B/wt80+qPqu8c+bDkX7JPNH4yiFOXEyQ4AADwIziYWJ2Ln9bfvciBg4QGAO7Jef0viRUAwE+FxCooBwCA+0JiBQAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNkgsQrKAQDgvuB/AQDgbJBYBeUAAHBf8L8AAHA2SKyCcgAAuC/4XwAAOBskVkE5AADcF/wvAACcDRKroBwAAO4L/hcAAM4GiVVQDgAA9wX/CwAAZ4PEKigHAID7gv8FAICzQWIVlAMAwH3B/wIAwNkgsQrKAQDgvuB/AQDgbHSJFQAAAAAAABxnTawQQgghhBBCCF2qz8//B4MB1r/GY8ndAAAAAElFTkSuQmCCAA==&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 13:33:00 +0000</pubDate>
<dc:creator>风之之</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fzz9/p/8974403.html</dc:identifier>
</item>
<item>
<title>MLDS笔记：浅层结构 vs 深层结构 - cherrychenlee</title>
<link>http://www.cnblogs.com/cherrychenlee/p/8890175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherrychenlee/p/8890175.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;深度学习出现之前，机器学习方面的开发者通常需要仔细地设计特征、设计算法，且他们在理论上常能够得知这样设计的实际表现如何；&lt;br/&gt;深度学习出现后，开发者常先尝试实验，有时候实验结果常与直觉相矛盾，实验后再找出出现这个结果的原因进行分析。&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;给定一个网络结构(层数以及每层的神经元个数)，根据参数取不同的值形成不同的函数。换句话说，给定了一个网络结构，即定义了一个函数集合。&lt;br/&gt;给定一个目标函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)=2(2\cos^2(x)-1)^2-1\)&lt;/span&gt;，现在想用一个神经网络来拟合这个函数(根据目标函数采集对应的多组&lt;span class=&quot;math inline&quot;&gt;\((x,y=f(x))\)&lt;/span&gt;对形成训练数据来训练神经网络)。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420113009610-454187461.png&quot; title=&quot;图0-1&quot; alt=&quot;图0-1&quot;/&gt;&lt;br/&gt;从图0-1中可以看出，随着神经元个数/参数数目(参数数目与神经元个数成正比)的增多，拟合的效果越来越好。&lt;br/&gt;从横向看，达到同样的拟合效果，越深的网络结构需要参数的数目越少；&lt;br/&gt;从纵向看，同样的参数数目下，越深的网络结构达到的拟合效果越好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来假设输入X为标量，且取值属于[0,1]，输出Y也为标量，隐藏层激活函数均为ReLU。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420131703006-1382422964.png&quot; title=&quot;图0-2&quot; alt=&quot;图0-2&quot;/&gt;&lt;br/&gt;如图0-2所示，接下来只讨论3个主要的问题：1.浅层结构能够拟合任意函数吗？2.为什么需要深层结构呢？3.浅层结构和深层结构的区别是什么？&lt;br/&gt;至于优化问题不讨论，即只要函数集能够覆盖目标函数，我们就假设能够拟合，不管选择的优化方法之间的区别；&lt;br/&gt;至于泛化问题也不讨论，即只考虑基于训练集数据上表现的拟合，不考虑测试集上的表现。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;答案是能，只要增加神经元个数，最终一定可以拟合目标函数。&lt;br/&gt;给定一个浅层网络结构(只有一层隐藏层)，隐藏层的激活函数为ReLU，以及线性输出层。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420124342510-441333591.png&quot; title=&quot;图1-1&quot; alt=&quot;图1-1&quot;/&gt;&lt;br/&gt;如图1-1所示，很明显，这个浅层网络定义了一个分段线性函数集合。&lt;br/&gt;现给定一个满足L-Lipschitz条件的目标函数&lt;span class=&quot;math inline&quot;&gt;\(f^\ast\)&lt;/span&gt;，需要多少个神经元才能够拟合这个目标函数呢？&lt;br/&gt;&lt;strong&gt;什么是L-Lipschitz？&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420124352572-2073771115.png&quot; title=&quot;图1-2&quot; alt=&quot;图1-2&quot;/&gt;&lt;br/&gt;如图1-2所示，即因变量变化的绝对值不超过自变量变化的绝对值的L倍。显然， 图1-2中蓝色线段不满足1-Lipschitz条件。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何保证拟合&quot;&gt;&lt;span&gt;1.1 如何保证拟合？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420132221058-2103979738.png&quot; title=&quot;图1.1-1&quot; alt=&quot;图1.1-1&quot;/&gt;&lt;br/&gt;当然，最大误差不超过&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;也可以改为两条曲线在[0,1]间面积不超过&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427141256771-1975248550.png&quot; title=&quot;图1.1-2&quot; alt=&quot;图1.1-2&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427141718961-1065822313.jpg&quot; title=&quot;图1.1-3&quot; alt=&quot;图1.1-3&quot;/&gt;&lt;br/&gt;如图1.1-3所示，满足图1.1-2中蓝色方框里上面的条件的话，下面的条件也会自动被满足。&lt;br/&gt;所以现在的问题是使用&lt;span class=&quot;math inline&quot;&gt;\(N(k)\)&lt;/span&gt;这个分段线性函数集合中的某个函数&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;来拟合目标函数&lt;span class=&quot;math inline&quot;&gt;\(f^\ast\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;是如何分段使得最大误差不超过&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;的呢？&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何定义满足条件的分段&quot;&gt;&lt;span&gt;1.2 如何定义满足条件的分段？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;假设每段的长度都是&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420132910354-117804148.png&quot; title=&quot;图1.2-1&quot; alt=&quot;图1.2-1&quot;/&gt;&lt;br/&gt;如图1.2-1所示，因为最大误差点和分段点之间的距离是不超过&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;的，任意两点间的斜率又是不超过&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;的，所以最大误差不超过&lt;span class=&quot;math inline&quot;&gt;\(l{\times}L\)&lt;/span&gt;。&lt;br/&gt;所以可以通过使得&lt;span class=&quot;math inline&quot;&gt;\(l{\times}L\le\epsilon\)&lt;/span&gt;来保证最大误差不超过&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(l\le\frac{\epsilon}{L}\)&lt;/span&gt;，即至少要分&lt;span class=&quot;math inline&quot;&gt;\(\frac{L}{\epsilon}\)&lt;/span&gt;段。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何实现这样的分段&quot;&gt;&lt;span&gt;1.3 如何实现这样的分段？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过多个神经元结果的叠加。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420133814525-2003174990.png&quot; title=&quot;图1.3-1&quot; alt=&quot;图1.3-1&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420133827293-1735060720.png&quot; title=&quot;图1.3-2&quot; alt=&quot;图1.3-2&quot;/&gt;&lt;br/&gt;绿线可以由蓝线叠加生成，每条蓝线需要2个神经元结果叠加形成。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180420133951202-1553040469.png&quot; title=&quot;图1.3-3&quot; alt=&quot;图1.3-3&quot;/&gt;&lt;br/&gt;所以，要分成&lt;span class=&quot;math inline&quot;&gt;\(\frac{L}{\epsilon}\)&lt;/span&gt;段可以通过使用&lt;span class=&quot;math inline&quot;&gt;\(\frac{2L}{\epsilon}\)&lt;/span&gt;个神经元来实现。&lt;br/&gt;需要注意的是，这里是指需要这么多个神经元可以做到这样的分段方式，并没有指这样子做是最有效率的做法。&lt;br/&gt;&lt;em&gt;当L取任意值时，浅层网络结构可以通过调整神经元个数来拟合对应的目标函数，可见浅层结构可以拟合任意函数，那么为什么需要深层结构呢？&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;虽然浅层结构可以拟合任何function，但其所需神经元个数可能为&lt;span class=&quot;math inline&quot;&gt;\(O(\frac{L}{\epsilon})\)&lt;/span&gt;，深层结构的使用可以使其变得更有效率。&lt;br/&gt;&lt;em&gt;举例说，任何演算法都可以用2行程式写出来。如排序，穷举所有排序前可能的字符串作为key，其对应的排序结果作为value构建查询表。&lt;br/&gt;程式第1行根据给定输入查表得对应索引，程式第2行输出该索引对应的value值作为最终的结果。------2步对应shallow&lt;br/&gt;但是，在实际实现排序时，我们并不会这样做，会进行更多的其他步骤，为了实现上更有效率。------多步对应deep&lt;/em&gt;&lt;br/&gt;上面已经讨论过，ReLU网络(激活函数均为ReLU的网络结构)可以表示分段线性函数。&lt;br/&gt;在差不多数目的参数下，深且窄的ReLU网络比起浅且宽的ReLU网络能实现更多的分段。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分段数的上界是多少&quot;&gt;&lt;span&gt;2.1 线性分段数的上界是多少？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423164621605-867720462.png&quot; title=&quot;图2.1-1&quot; alt=&quot;图2.1-1&quot;/&gt;&lt;br/&gt;定义神经元个数为&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;，对应的最大激活模式为&lt;span class=&quot;math inline&quot;&gt;\(2^N\)&lt;/span&gt;种，每一种激活模式对应一个线性分段，所以最大线性分段数为&lt;span class=&quot;math inline&quot;&gt;\(2^N\)&lt;/span&gt;个。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423164627359-961613666.png&quot; title=&quot;图2.1-2&quot; alt=&quot;图2.1-2&quot;/&gt;&lt;br/&gt;但是，不是所有的分段方式都是会出现的。比如图2.1-2中2个神经元，最多只会出现3个分段。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分段数的下界是多少&quot;&gt;&lt;span&gt;2.2 线性分段数的下界是多少？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何定义绝对值激活函数？&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423165058071-1089601809.png&quot; title=&quot;图2.2-1&quot; alt=&quot;图2.2-1&quot;/&gt;&lt;br/&gt;如图2.2-1所示，可以用2个ReLU神经元实现绝对值激活函数功能。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423165239893-301159543.png&quot; title=&quot;图2.2-2&quot; alt=&quot;图2.2-2&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423165232801-848781046.png&quot; title=&quot;图2.2-3&quot; alt=&quot;图2.2-3&quot;/&gt;&lt;br/&gt;绝对值激活函数进行深度上的堆积，每次多加一个节点，分段数变为原来的2倍。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427143856507-1676394668.png&quot; title=&quot;图2.2-4&quot; alt=&quot;图2.2-4&quot;/&gt;&lt;br/&gt;从图2.2-4中可以看出，对于浅层网络结构，每次多加一个节点(宽度方向上)，分段数加1；对于深层网络结构，每次多加一个节点(深度方向上)，分段数乘以2。&lt;br/&gt;&lt;em&gt;当网络结构宽度为K、深度为H时，我们至少可以有&lt;span class=&quot;math inline&quot;&gt;\(K^H\)&lt;/span&gt;个分段数。&lt;/em&gt;&lt;br/&gt;可见深度对于分段数的影响要明显高于宽度，因为深度方向的堆积使得同样的pattern可以被反复利用。&lt;br/&gt;下图的实验结果验证了上述观点，同时显现较低层参数对于网络的表现有更大的影响。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423170451880-230433188.png&quot; title=&quot;图2.2-5&quot; alt=&quot;图2.2-5&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423170456137-1083612472.png&quot; title=&quot;图2.2-6&quot; alt=&quot;图2.2-6&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;深层结构可以比浅层结构好多少&quot;&gt;&lt;span&gt;2.3 深层结构可以比浅层结构好多少？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423171617594-217770742.png&quot; title=&quot;图2.3-1&quot; alt=&quot;图2.3-1&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225021803-907799647.jpg&quot; title=&quot;图2.3-2&quot; alt=&quot;图2.3-2&quot;/&gt;&lt;br/&gt;如上图所证，拟合函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)=x^2\)&lt;/span&gt;时，shallow网络结构所需的神经元个数为&lt;span class=&quot;math inline&quot;&gt;\(O(\frac{1}{\sqrt{\epsilon}})\)&lt;/span&gt;。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423171624054-405802903.png&quot; title=&quot;图2.3-3&quot; alt=&quot;图2.3-3&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427151437627-1666515700.png&quot; title=&quot;图2.3-4&quot; alt=&quot;图2.3-4&quot;/&gt;&lt;br/&gt;如上图所证，拟合函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)=x^2\)&lt;/span&gt;时，deep网络结构所需神经元个数为&lt;span class=&quot;math inline&quot;&gt;\(O(log_2\frac{1}{\sqrt{\epsilon}})\)&lt;/span&gt;。&lt;br/&gt;&lt;em&gt;函数&lt;span class=&quot;math inline&quot;&gt;\(y=x^2\)&lt;/span&gt;是否具有一般性?&lt;/em&gt;&lt;br/&gt;具有，因为可以用拟合函数&lt;span class=&quot;math inline&quot;&gt;\(y=x^2\)&lt;/span&gt;的网络结构作为square net去形成multiply net继而形成polynomial net，就可以用这个多项式网络去拟合其他连续函数了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423171643453-1916494027.png&quot; title=&quot;图2.3-6&quot; alt=&quot;图2.3-6&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;深层结构确实优于浅层结构吗&quot;&gt;&lt;span&gt;2.4 深层结构确实优于浅层结构吗？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;目前证明这一点的力量还不足够，因为上述讨论都是基于存在的某种状态，并不清楚这种状态是否是最佳状态。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180423171649248-1866360503.png&quot; title=&quot;图2.4-1&quot; alt=&quot;图2.4-1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为了求得浅层网络在竭尽全力的状态下拟合函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)=x^2\)&lt;/span&gt;所需的神经元个数，可以放宽各种条件。&lt;br/&gt;首先，假设相邻黑线之间的头尾无需相接。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427152307306-1875586786.png&quot; title=&quot;图3-1&quot; alt=&quot;图3-1&quot;/&gt;&lt;br/&gt;如图3-1所示，左边是可以用ReLU实现的，右边没法通过ReLU实现。因为ReLU无法生成非连续的线。&lt;br/&gt;先假设右边可以实现，因为其对应的error明显更小，称这种状态为梦幻状态。&lt;br/&gt;再来，原来拟合的条件是最大error不超过&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;，满足该条件一定满足面积的近似不超过error的条件，但满足后者不一定满足前者。&lt;br/&gt;现放宽限制条件，变为面积的近似不超过error就好。&lt;br/&gt;现在考虑给定一个分段，最小的error是多少呢？&lt;br/&gt;答案是&lt;span class=&quot;math inline&quot;&gt;\(\frac{l^5}{180}\)&lt;/span&gt;，证明思路如图3-3所示。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427171231845-567564027.png&quot; title=&quot;图3-2&quot; alt=&quot;图3-2&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427171309708-322693867.png&quot; title=&quot;图3-3&quot; alt=&quot;图3-3&quot;/&gt;&lt;br/&gt;如果分段数确定为n，如何分段使得error最小呢？&lt;br/&gt;直觉是等分n段，证明可以参考图3-5。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225224896-400170166.png&quot; title=&quot;图3-4&quot; alt=&quot;图3-4&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225232080-932277870.png&quot; title=&quot;图3-5&quot; alt=&quot;图3-5&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225236101-790127158.png&quot; title=&quot;图3-6&quot; alt=&quot;图3-6&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225241928-908520112.png&quot; title=&quot;图3-7&quot; alt=&quot;图3-7&quot;/&gt;&lt;br/&gt;即使浅层网络结构竭尽全力，其所需的神经元个数还是&lt;span class=&quot;math inline&quot;&gt;\(O(\frac{1}{\sqrt{\epsilon}})\)&lt;/span&gt;，而深层网络结构在随意设计的某种状态下所需的神经元个数为&lt;span class=&quot;math inline&quot;&gt;\(O(log_2\frac{1}{\sqrt{\epsilon}})\)&lt;/span&gt;，&lt;br/&gt;可见，深层网络结构确实好于浅层网络结构，且好的程度是指数级的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225851186-730492508.png&quot; title=&quot;图4-1&quot; alt=&quot;图4-1&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225855518-1528197980.png&quot; title=&quot;图4-2&quot; alt=&quot;图4-2&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225902053-63538003.png&quot; title=&quot;图4-3&quot; alt=&quot;图4-3&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225907149-346919390.png&quot; title=&quot;图4-4&quot; alt=&quot;图4-4&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141302/201804/1141302-20180427225912202-208888231.png&quot; title=&quot;图4-5&quot; alt=&quot;图4-5&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;总之，当目标函数满足某种最低复杂度要求时，使用深层网络结构是优于浅层网络结构的，且优于的程度是指数级别的。&lt;br/&gt;因为实际问题中遇到的问题常较为复杂，所以使用深层结构往往更有效。&lt;/em&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 13:14:00 +0000</pubDate>
<dc:creator>cherrychenlee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cherrychenlee/p/8890175.html</dc:identifier>
</item>
<item>
<title>Web API对application/json内容类型的CORS支持 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/8974595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/8974595.html</guid>
<description>&lt;p&gt;假设有一简单架构分为前后两部分，其一是Angular构成的前端页面站点，另一个则是通过ASP.NET Web API搭建的后端服务站点。两个站点因为分别布署，所有会有CORS(Cross-Origin Resource Sharing)的问题。&lt;/p&gt;
&lt;p&gt;再假设后端已经对此做好相应配置，比如在web.config里加上了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;&amp;lt;httpProtocol&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;customHeaders&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;add&lt;/span&gt; name=&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Allow-Origin&quot;&lt;/span&gt; value=&lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt; /&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;add&lt;/span&gt; name=&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Allow-Methods&quot;&lt;/span&gt; value=&lt;span class=&quot;st&quot;&gt;&quot;GET, PUT, POST, DELETE, HEAD&quot;&lt;/span&gt; /&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;add&lt;/span&gt; name=&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Allow-Headers&quot;&lt;/span&gt; value=&lt;span class=&quot;st&quot;&gt;&quot;Origin, X-Requested-With, Content-Type, Accept&quot;&lt;/span&gt; /&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;/&lt;span class=&quot;kw&quot;&gt;customHeaders&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;/&lt;span class=&quot;kw&quot;&gt;httpProtocol&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么当前端调用后端接口：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;  save(data: any) : Observable&amp;lt;any&amp;gt; {
      return this.http.post(`${this.apiUrl}`, data)
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后端对应接口内的逻辑理论上应该是能够被正常执行的：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;  [HttpPost]
  [Route(&quot;api/save&quot;)]
  public HttpResponseMessage Save(SomeModel model)
  {
      //内部逻辑
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但结果是出现了&lt;code&gt;Message:&quot;The requested resource does not support http method 'OPTIONS'.&quot;&lt;/code&gt;错误。&lt;/p&gt;
&lt;p&gt;产生此问题的原因在于HttpClient的post方法默认是采用application/json的内容类型(Content-Type)。&lt;/p&gt;
&lt;p&gt;而CORS规范中有两种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Simple requests&lt;/li&gt;
&lt;li&gt;Preflighted requests&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前者无需额外的处理，但对于内容类型的支持，仅限三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;multipart/form-data&lt;/li&gt;
&lt;li&gt;text/plain&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于除此以外的内容类型，比如application/json，CORS会以预检请求方式(Preflighted requests)处理。&lt;/p&gt;
&lt;p&gt;Preflighted requests要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。&lt;/p&gt;
&lt;p&gt;而在上面的后端服务代码中并没有准备相应的处理OPTIONS请求的接口，所以才会有这样的错误。&lt;/p&gt;
&lt;p&gt;对应修正方法很简单，在同一接口方法上加上处理OPTIONS请求的逻辑：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;  [HttpOptions, HttpPost]
  [Route(&quot;api/save&quot;)]
  public HttpResponseMessage Save(SomeModel model)
  {
      if (Request.Method == HttpMethod.Options) return new HttpResponseMessage(HttpStatusCode.OK);
      //内部逻辑
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有关CORS的详细描述，建议参考官方文档——&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&quot;&gt;Cross-Origin Resource Sharing (CORS)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 12:50:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/8974595.html</dc:identifier>
</item>
<item>
<title>maven入门（一） - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/8974605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/8974605.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现在基本上很多项目开始使用maven进行构建项目，已经不是直接在lib文件夹下统一放置jar包，所以还是有必要学习掌握下maven的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对maven。这篇文章主要介绍一下几点，大家如果都明白了，就可以参照这个思维导图，再复习下，毕竟知识长时间不用，会忘记的。&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/maven.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一-maven-是什么&quot;&gt;一、 maven 是什么&lt;/h3&gt;
&lt;p&gt;Maven的Apache公司开源项目，是项目构建工具，也用来依赖管理。&lt;/p&gt;
&lt;h3 id=&quot;二maven的好处&quot;&gt;二、maven的好处&lt;/h3&gt;
&lt;p&gt;1、由于maven构建的项目是没有jar包的，所以项目的大小上，肯定是maven的项目比较小。&lt;br/&gt;2、jar包统一交给maven管理。&lt;br/&gt;3、maven同样可以进行项目构建。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;maven主要就是 项目构建和依赖(jar包)管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三maven安装&quot;&gt;三、maven安装&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;maven程序安装前提：maven程序java开发，它的运行依赖jdk。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、 首先去Maven官网，下载Maven的包，地址为http://maven.apache.org/download.cgi&lt;br/&gt;2、下载完解压，然后配置一下环境变量，和JDK的环境变量配置类似（如图）&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430153312.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430153332.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;3、查询maven版本信息&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430153552.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;4、 配置本地仓库&lt;br/&gt;找到 解压目录下的 config/setting.xml，我的就是 E:\app\apache-maven-3.5.3\conf\setting.xml&lt;br/&gt;主要修改2个地方&lt;br/&gt;4.1 修改本地仓库路径&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430161530.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;4.2 修改成阿里云镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;mirror&amp;gt;
        &amp;lt;id&amp;gt;nexus-aliyun&amp;lt;/id&amp;gt;
        &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;
        &amp;lt;name&amp;gt;Nexus aliyun&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public&amp;lt;/url&amp;gt;
    &amp;lt;/mirror&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430161615.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.4 复制刚刚设置好的setting.xml 到你设置的本地仓库路径 我的是E:\dev_maven&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430162308.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.仓库类型有哪些&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四-使用maven构建项目&quot;&gt;四、 使用maven构建项目&lt;/h3&gt;
&lt;p&gt;这里我是用eclipse 进行创建的&lt;/p&gt;
&lt;p&gt;1、eclipse配置&lt;/p&gt;
&lt;p&gt;1.1 配置maven程序&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180430163403.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;1.2 配置userSetting ,知道仓库位置&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180430163505.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;1.3 构建索引，方便查找jar包（Window-&amp;gt;show view -&amp;gt;maven Repository）&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/2018-04-30_164325.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、开始创建项目&lt;br/&gt;2.1 这里选择普通项目- Maven Project ，点击next&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430165750.png&quot; alt=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430165750.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430165900.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2 打包方式选择war ，完成。&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/2018-04-30_170930.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.3 web.xml缺失报错&lt;/p&gt;
&lt;p&gt;此时，会报错，需要在src-main-webapp 下面创建 WEB-INF/web.xml&lt;/p&gt;
&lt;p&gt;目录结构&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430174847.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;web.xml 内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&amp;gt;

    
    
    &amp;lt;welcome-file-list&amp;gt;
        &amp;lt;welcome-file&amp;gt;index.html&amp;lt;/welcome-file&amp;gt;
        &amp;lt;welcome-file&amp;gt;index.htm&amp;lt;/welcome-file&amp;gt;
        &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
        &amp;lt;welcome-file&amp;gt;default.html&amp;lt;/welcome-file&amp;gt;
        &amp;lt;welcome-file&amp;gt;default.htm&amp;lt;/welcome-file&amp;gt;
        &amp;lt;welcome-file&amp;gt;default.jsp&amp;lt;/welcome-file&amp;gt;
    &amp;lt;/welcome-file-list&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时创建一个index.xml_(src\main\webapp\index.html)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello maven&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置jdk编译版本为1.8.默认为1.5&lt;br/&gt;修改pom文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.zhb&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;maven_hello&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
  
  
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt;  
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
                    &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新maven&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/2018-04-30_175425.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;运行项目&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/2018-04-30_175547.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tomcat:run&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430175645.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.大功告成&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430175930.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430175945.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;五maven-常用命令&quot;&gt;五、maven 常用命令&lt;/h3&gt;
&lt;h4 id=&quot;clean清理&quot;&gt;clean：清理&lt;/h4&gt;
&lt;p&gt;将项目根目录下target目录清理掉&lt;/p&gt;
&lt;h4 id=&quot;compile编译&quot;&gt;compile:编译&lt;/h4&gt;
&lt;p&gt;将项目中.java文件编译为.class文件&lt;/p&gt;
&lt;h4 id=&quot;test单元测试&quot;&gt;test：单元测试&lt;/h4&gt;
&lt;p&gt;单元测试类名有要求：XxxxTest.java&lt;br/&gt;将项目根目录下src/test/java目录下的单元测试类都会执行。&lt;/p&gt;
&lt;h4 id=&quot;package打包&quot;&gt;package:打包&lt;/h4&gt;
&lt;p&gt;web project --- war包&lt;br/&gt;java project --- jar 包&lt;br/&gt;将项目打包，打包项目根目录下taget目录。&lt;/p&gt;
&lt;h4 id=&quot;install安装&quot;&gt;install:安装&lt;/h4&gt;
&lt;p&gt;本地多个项目公用一个jar包。&lt;br/&gt;打包到本地仓库&lt;/p&gt;
&lt;p&gt;这里大家自己尝试一下，进入工程目录里面&lt;br/&gt;如打包 则执行 mvn package&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430181242.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/maven/TIM%E6%88%AA%E5%9B%BE20180430181349.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，写了好久。终于弄完了。玩的开心。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 12:37:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/8974605.html</dc:identifier>
</item>
</channel>
</rss>