<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>修改IP地址 - 左思右想</title>
<link>http://www.cnblogs.com/Awangzhen/p/9478882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Awangzhen/p/9478882.html</guid>
<description>&lt;p&gt;手动修改IP感觉很麻烦，今天晚上自己研究了下，通过脚本语言来实现自动修改，来分享下。&lt;/p&gt;
&lt;p&gt;操作方法：&lt;/p&gt;
&lt;p&gt;1、新建txt文档。&lt;/p&gt;
&lt;p&gt;2、复制下面的代码，保存，修改txt文档属性名为：.bat格式。&lt;/p&gt;
&lt;p&gt;3、右击以管理员身份运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1303995/201808/1303995-20180814235144404-54846785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1303995/201808/1303995-20180814235125723-1049210491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;@echo off&lt;br/&gt;echo /***********************1、设置自动获取IP请按 1************************/&lt;br/&gt;echo /***********************2、设置固定IP请按 2****************************/&lt;br/&gt;echo /***********************3、设置自己设定IP请按 3************************/&lt;br/&gt;echo /***********************4、请选择,或退出请按Q**************************/&lt;/p&gt;
&lt;p&gt;set /p shu=&lt;br/&gt;if &quot;%shu%&quot;==&quot;1&quot; cls&amp;amp;goto ONE&lt;br/&gt;if &quot;%shu%&quot;==&quot;2&quot; cls&amp;amp;goto TWO&lt;br/&gt;if &quot;%shu%&quot;==&quot;3&quot; cls&amp;amp;goto Three&lt;br/&gt;if &quot;%shu%&quot;==&quot;Q&quot; exit&lt;br/&gt;if &quot;%shu%&quot;==&quot;q&quot; exit&lt;/p&gt;
&lt;p&gt;:Three&lt;br/&gt;echo 正在设置自己设定的IP地址，请稍候……&lt;br/&gt;echo 请输入要设置的IP地址：&lt;br/&gt;set /p myIP=&lt;br/&gt;echo 请输入要设置的子网掩码：&lt;br/&gt;set /p myNetMark=&lt;br/&gt;echo 请输入网关：&lt;br/&gt;set /p myGateWay=&lt;br/&gt;netsh interface ip set address &quot;WLAN&quot; static %myIP% %myNetMark% %myGateWay% 1&lt;br/&gt;echo ********修改完成！********&lt;br/&gt;echo ******开心每一天！WZ******&lt;br/&gt;set /p wait= 设置成功，按任意键退出&lt;br/&gt;exit&lt;/p&gt;
&lt;p&gt;:TWO&lt;br/&gt;echo 正在设置固定IP，请稍候……&lt;br/&gt;netsh interface ip set address &quot;WLAN&quot; static 10.236.185.58 255.255.254.0 10.236.185.254 1&lt;br/&gt;echo 正在更改IP设置，请稍候……&lt;br/&gt;echo ********修改完成！********&lt;br/&gt;echo ******开心每一天！WZ******&lt;br/&gt;set /p wait= 设置成功，按任意键退出&lt;br/&gt;exit&lt;/p&gt;
&lt;p&gt;:ONE&lt;br/&gt;echo 设置自动获取IP，请稍候……&lt;br/&gt;netsh interface ip set address name=&quot;WLAN&quot; source=dhcp&lt;br/&gt;echo ********修改完成！********&lt;br/&gt;echo ******开心每一天！WZ******&lt;br/&gt;set /p wait= 设置成功，按任意键退出&lt;br/&gt;exit&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 15:49:00 +0000</pubDate>
<dc:creator>左思右想</dc:creator>
<og:description>手动修改IP感觉很麻烦，今天晚上自己研究了下，通过脚本语言来实现自动修改，来分享下。 操作方法： 1、新建txt文档。 2、复制下面的代码，保存，修改txt文档属性名为：.bat格式。 3、右击以管理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Awangzhen/p/9478882.html</dc:identifier>
</item>
<item>
<title>强一致性hash实现java版本及强一致性hash原理 - 叶止水</title>
<link>http://www.cnblogs.com/houbbBlogs/p/9478824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/houbbBlogs/p/9478824.html</guid>
<description>&lt;p&gt;分布式过程中我们将服务分散到若干的节点上，以此通过集体的力量提升服务的目的。然而，对于一个客户端来说，该由哪个节点服务呢？或者说对某个节点来说他分配到哪些任务呢？&lt;/p&gt;

&lt;p&gt;考虑到单服务器不能承载，因此使用了分布式架构，最初的算法为 hash() mod n, hash()通常取用户ID，n为节点数。此方法容易实现且能够满足运营要求。缺点是当单点发生故障时，系统无法自动恢复。同样不也不能进行动态增加节点。&lt;/p&gt;

&lt;p&gt;为了解决单点故障，使用 &lt;code&gt;hash() mod (n/m)&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;这样任意一个用户都有 m 个服务器备选，可由 client 随机选取。&lt;/p&gt;
&lt;p&gt;由于不同服务器之间的用户需要彼此交互，所以所有的服务器需要确切的知道用户所在的位置。&lt;/p&gt;
&lt;p&gt;因此用户位置被保存到 memcached 中。当一台发生故障，client 可以自动切换到对应 backup，由于切换前另外 1 台没有用户的 session，因此需要 client 自行重新登录。&lt;/p&gt;
&lt;p&gt;他比强哈希的好处是：解决了单点问题。&lt;/p&gt;
&lt;p&gt;但存在以下问题：负载不均衡，尤其是单台发生故障后剩下一台会压力过大；不能动态增删节点；节点发生故障时需要 client 重新登录&lt;/p&gt;

&lt;p&gt;一致性 hash 算法提出了在动态变化的 Cache 环境中，判定哈希算法好坏的四个定义：&lt;/p&gt;
&lt;h2 id=&quot;平衡性balance&quot;&gt;平衡性(Balance)&lt;/h2&gt;
&lt;p&gt;平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。&lt;/p&gt;
&lt;h2 id=&quot;单调性monotonicity&quot;&gt;单调性(Monotonicity)&lt;/h2&gt;
&lt;p&gt;单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。&lt;/p&gt;
&lt;h2 id=&quot;分散性spread&quot;&gt;分散性(Spread)&lt;/h2&gt;
&lt;p&gt;在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。&lt;/p&gt;
&lt;p&gt;当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。&lt;/p&gt;
&lt;p&gt;这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。&lt;/p&gt;
&lt;h2 id=&quot;负载load&quot;&gt;负载(Load)&lt;/h2&gt;
&lt;p&gt;负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。&lt;/p&gt;
&lt;p&gt;与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。&lt;/p&gt;
&lt;p&gt;普通的哈希算法（也称硬哈希）采用简单取模的方式，将机器进行散列，这在cache环境不变的情况下能取得让人满意的结果，但是当cache环境动态变化时，&lt;br/&gt;这种静态取模的方式显然就不满足单调性的要求（当增加或减少一台机子时，几乎所有的存储内容都要被重新散列到别的缓冲区中）。&lt;/p&gt;

&lt;h2 id=&quot;实现逻辑&quot;&gt;实现逻辑&lt;/h2&gt;
&lt;p&gt;一致性哈希算法有多种具体的实现，包括 &lt;a href=&quot;https://en.wikipedia.org/wiki/Chord_(peer-to-peer)&quot;&gt;Chord 算法&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Kademlia&quot;&gt;KAD 算法&lt;/a&gt;等实现，以上的算法的实现都比较复杂。&lt;/p&gt;
&lt;p&gt;这里介绍一种网上广为流传的一致性哈希算法的基本实现原理，感兴趣的同学可以根据上面的链接或者去网上查询更详细的资料。&lt;/p&gt;
&lt;p&gt;一致性哈希算法的基本实现原理是将机器节点和key值都按照一样的hash算法映射到一个&lt;code&gt;0~2^32&lt;/code&gt;的圆环上。&lt;/p&gt;
&lt;p&gt;当有一个写入缓存的请求到来时，计算 Key 值 k 对应的哈希值 Hash(k)，如果该值正好对应之前某个机器节点的 Hash 值，则直接写入该机器节点，&lt;br/&gt;如果没有对应的机器节点，则顺时针查找下一个节点，进行写入，如果超过 &lt;code&gt;2^32&lt;/code&gt; 还没找到对应节点，则从0开始查找(因为是环状结构)。&lt;/p&gt;
&lt;p&gt;如图 1 所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.huanghao.me/wp-content/uploads/2011/06/%E5%9B%BE1.png&quot; alt=&quot;hash&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 1 中 Key K 的哈希值在 A 与 B 之间，于是 K 就由节点B来处理。&lt;/p&gt;
&lt;p&gt;另外具体机器映射时，还可以根据处理能力不同，将一个实体节点映射到多个虚拟节点。&lt;/p&gt;
&lt;p&gt;经过一致性哈希算法散列之后，当有新的机器加入时，将只影响一台机器的存储情况，&lt;/p&gt;
&lt;p&gt;例如新加入的节点H的散列在 B 与 C 之间，则原先由 C 处理的一些数据可能将移至 H 处理，&lt;br/&gt;而其他所有节点的处理情况都将保持不变，因此表现出很好的单调性。&lt;/p&gt;
&lt;p&gt;而如果删除一台机器，例如删除 C 节点，此时原来由 C 处理的数据将移至 D 节点，而其它节点的处理情况仍然不变。&lt;/p&gt;
&lt;p&gt;而由于在机器节点散列和缓冲内容散列时都采用了同一种散列算法，因此也很好得降低了分散性和负载。&lt;/p&gt;
&lt;p&gt;而通过引入虚拟节点的方式，也大大提高了平衡性。&lt;/p&gt;
&lt;h2 id=&quot;实现代码&quot;&gt;实现代码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/houbb/consitent-hashing&quot;&gt;consitent-hashing&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://houbb.github.io/2018/08/13/consistent-hash&quot;&gt;consitent-hashing&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 14 Aug 2018 15:39:00 +0000</pubDate>
<dc:creator>叶止水</dc:creator>
<og:description>一致性 hash 分布式过程中我们将服务分散到若干的节点上，以此通过集体的力量提升服务的目的。然而，对于一个客户端来说，该由哪个节点服务呢？或者说对某个节点来说他分配到哪些任务呢？ 强哈希 考虑到单服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/houbbBlogs/p/9478824.html</dc:identifier>
</item>
<item>
<title>Bootstrap Table列宽拖动的方法 - ktkt</title>
<link>http://www.cnblogs.com/legend-123/p/9478799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/legend-123/p/9478799.html</guid>
<description>&lt;p&gt;　　在之前做过的一个web项目中，前端表格是基于jQuery和Bootstrap Table做的，客户要求能利用拖动改变列宽，为了总结和备忘，现将实现的过程记录如下：&lt;/p&gt;
&lt;p&gt;　　1、Bootstrap Table可拖动，需要用到它的Resizable扩展插件，具体可见bootstrap-table的官方文档链接：http://bootstrap-table.wenzhixin.net.cn/zh-cn/extensions/&lt;/p&gt;
&lt;p&gt;　　　　进入之后，找到Resizable插件，点击Home进入github可以找到详细的用法。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176213/201808/1176213-20180814231710011-754786331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、用法是直接引入该js插件，不过可以看到，这个插件还依赖于&lt;a href=&quot;https://github.com/alvaro-prieto/colResizable&quot;&gt;colResizable&lt;/a&gt; v1.6（下载地址：http://www.bacubacu.com/colresizable/）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script src=&quot;colResizable-1.6.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;extensions/bootstrap-table-resizable.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span class=&quot;pl-ent&quot;&gt;&lt;span class=&quot;pl-e&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-ent&quot;&gt;&lt;br/&gt;&lt;span&gt;    3.  另外，在使用Bootstrap Table的时候，建议用js去设置table的列属性，即按照如下方式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
$('#myTable'&lt;span&gt;).bootstrapTable({  
                url: url,
        method: &lt;/span&gt;'post'&lt;span&gt;,  
        columns:[{

            align: &lt;/span&gt;'center'&lt;span&gt;,
            checkbox:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            width:&lt;/span&gt;'15'&lt;span&gt;,
            valign: &lt;/span&gt;'middle'&lt;span&gt;
        },{
            field: &lt;/span&gt;'name'&lt;span&gt;,
            title: &lt;/span&gt;'名称'&lt;span&gt;,
            align: &lt;/span&gt;'center'&lt;span&gt;,
            width:&lt;/span&gt;'100'&lt;span&gt;,
            valign: &lt;/span&gt;'middle'&lt;span&gt;
        },{
            field: &lt;/span&gt;'desc'&lt;span&gt;,
            title: &lt;/span&gt;'描述'&lt;span&gt;,
            width:&lt;/span&gt;500&lt;span&gt;,
            align: &lt;/span&gt;'left'&lt;span&gt;,
            valign: &lt;/span&gt;'middle'&lt;span&gt;
        }]
});    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这种方式可以通过修改width的大小来直接修改列的宽度。而还有一种写法是在HTML中设置table的列头部，这种方式是很难调整宽度的，且很容易导致列头与内容无法对齐，是不推荐的，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
        &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th data-field=&quot;id&quot; data-width=&quot;50px&quot;&amp;gt;编号&amp;lt;/th&amp;gt;
                &amp;lt;th data-field=&quot;name&quot; data-width=&quot;100px&quot;&amp;gt;姓名&amp;lt;/th&amp;gt;
                &amp;lt;th data-field=&quot;desc&quot; data-width=&quot;120px&quot;&amp;gt;描述&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span class=&quot;pl-ent&quot;&gt;&lt;span class=&quot;pl-e&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-ent&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 14 Aug 2018 15:34:00 +0000</pubDate>
<dc:creator>ktkt</dc:creator>
<og:description>在之前做过的一个web项目中，前端表格是基于jQuery和Bootstrap Table做的，客户要求能利用拖动改变列宽，为了总结和备忘，现将实现的过程记录如下： 1、Bootstrap Table可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/legend-123/p/9478799.html</dc:identifier>
</item>
<item>
<title>用树莓派做一个离线下载机 - Summer7C</title>
<link>http://www.cnblogs.com/Summer7C/p/9478773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer7C/p/9478773.html</guid>
<description>&lt;p&gt;用树莓派可以做很多有意思的东西，它相当于一个小型的电脑，装上系统完全可以作为一个家用的小型服务器。&lt;/p&gt;
&lt;p&gt;通过这个小型服务器，可以实现一个“离线”下载机。不过这里的离线下载不是真的离线，因为树莓派还是在线的——既然树莓派当做了小型服务器，那应该长期保持在线状态了——不过由于树莓派的功耗很小，而且占用空间也很小，所以当做家用服务器还是很可以的。&lt;/p&gt;
&lt;p&gt;这个树莓派的离线下载器是使用aria搭建的，aria是一个开源的多线程下载工具，可以完成很多种类的下载任务。通过aria2我们就可以很轻松的完成下载任务，包括wget这类工具做不了的。&lt;/p&gt;
&lt;p&gt;首先是安装aria2，我们可以通过aria2的官网下载安装：http://aria2.github.io/&lt;/p&gt;
&lt;p&gt;同样，如果你的树莓派和我用的一个系统——debian，也可以使用debian的命令安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$&lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt; aria2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要等待片刻，就可以安装成功。&lt;/p&gt;
&lt;p&gt;之后，我们就可以使用aria2进行下载任务，aria2的下载命令很简单，例如，我们想要下载一个mp3,则只用输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$aria2c XXXX/abc.mp3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的aria2的使用方式，我们可以参考aria2的官方文档：http://aria2.github.io/manual/en/html/index.html&lt;/p&gt;
&lt;p&gt;这样就可以了吗？当然不行，这还不够一个离线下载工具的易用性。&lt;/p&gt;
&lt;p&gt;接下来就是给aria2安装图形界面，aria2官方推荐有很多图形界面，并且，aria2也提供了rpc接口可以供我们进行调用，下面我们就使用一个开源的界面给aria2安装图形工具。&lt;/p&gt;
&lt;p&gt;我们选用的图形工具是Aria2 WebUI，这个工具可以在aria2的官网上找到，我们进入它的github，把项目clone下来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/ziahamza/webui-aria2.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拿到代码后，只用输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
node node-server.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图形界面就可以跑起来了，不过在此之前你需要安装nodejs环境，通过以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$&lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt; nodejs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样跑起来并不能使用，我们需要先配置以下启动项，将aria2 webui下的configconfiguration.js打开，将&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
host: location.protocol.startsWith('http') ? location.hostname : 'localhost'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一行改成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
host: location.protocol.startsWith('http') ? location.hostname : '0.0.0.0'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不然在服务器之外没办法访问的。&lt;/p&gt;
&lt;p&gt;然后我们可以在其他主机上输入树莓派的内网IP地址，比如树莓派的IP位192.168.1.122，在和树莓派的路由器同意网段的主机上，访问192.168.1.122:8888，我们就可以看到web页面了。&lt;/p&gt;
&lt;p&gt;但是，这个只是一个页面而已，这个页面和aria2是通过rpc交互的，所以我们需要启动aria2的rpc：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
aria2c --enable-rpc --rpc-listen-all
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们的图形界面就可以访问aria2的服务了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789559/201808/789559-20180814232333513-71159176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就访问到了界面，如果平时我们有什么大文件需要下载的时候，我们就可以睡觉前点击下载，然后把电脑关了，第二天起床就下载到了树莓派上了。接下来我们可以将树莓派的数据通过路由器内网下载到电脑硬盘，这个过程就很快了，如果想要一个简单的方式建立一个http文件访问的话，我们可以在aria2的下载目录下，使用python3的命令快速建立一个http访问文件，进行下载：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
python3 -m http.server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789559/201808/789559-20180814232751248-529928284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击文件，就可以快速下载了，感觉是不是很棒呢？&lt;/p&gt;

</description>
<pubDate>Tue, 14 Aug 2018 15:29:00 +0000</pubDate>
<dc:creator>Summer7C</dc:creator>
<og:description>用树莓派可以做很多有意思的东西，它相当于一个小型的电脑，装上系统完全可以作为一个家用的小型服务器。 通过这个小型服务器，可以实现一个“离线”下载机。不过这里的离线下载不是真的离线，因为树莓派还是在线的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Summer7C/p/9478773.html</dc:identifier>
</item>
<item>
<title>webpack4.0各个击破（1）—— html部分 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9478777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9478777.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;作为前端最火的构建工具，是前端自动化工具链&lt;strong&gt;最重要的部分&lt;/strong&gt;，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过&lt;strong&gt;问题 + 解决方式&lt;/strong&gt;的模式，以前端构建中遇到的具体需求为出发点，学习&lt;code&gt;webpack&lt;/code&gt;工具中相应的处理办法。（本篇中的参数配置及使用方式均基于&lt;code&gt;webpack4.0版本&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/70e37037050f4cceaf20683f1e778f67.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-webpack中的html&quot;&gt;一. webpack中的html&lt;/h2&gt;
&lt;p&gt;对于浏览器而言，&lt;code&gt;html&lt;/code&gt;文件是用户访问的入口点，也是所有资源的挂载点，所有资源都是通过&lt;code&gt;html&lt;/code&gt;中的标记来进行引用的。而在&lt;code&gt;webpack&lt;/code&gt;的构建世界里，&lt;code&gt;html&lt;/code&gt;只是一个展示板，而&lt;code&gt;entry&lt;/code&gt;参数中指定的&lt;code&gt;javascript&lt;/code&gt;入口文件才是真正在构建过程中管理和调度资源的挂载点，&lt;code&gt;html&lt;/code&gt;文件中最终展示的内容，都是&lt;code&gt;webpack&lt;/code&gt;在加工并为所有资源打好标记以后传递给它的，业界将这种有别与浏览器的模式称之为&lt;strong&gt;“webpack的逆向注入”&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二.html文件基本处理需求&quot;&gt;二.html文件基本处理需求&lt;/h2&gt;
&lt;p&gt;前端项目可以大致分为 &lt;strong&gt;单页面应用&lt;/strong&gt; 和 &lt;strong&gt;多页面应用&lt;/strong&gt;，现代化组件中的&lt;code&gt;html&lt;/code&gt;文件主要作为访问入口文件，是&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 样式标签和&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;脚本标签的挂载点，打包中需要解决的基本问题包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;个性化内容填充（例如页面标题，描述，关键词）&lt;/li&gt;
&lt;li&gt;多余空格删除（连续多个空白字符的合并）&lt;/li&gt;
&lt;li&gt;代码压缩（多余空白字符的合并）&lt;/li&gt;
&lt;li&gt;去除注释&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三.入口html文件的处理&quot;&gt;三.入口html文件的处理&lt;/h2&gt;
&lt;h3 id=&quot;单页面应用打包&quot;&gt;3.1 单页面应用打包&lt;/h3&gt;
&lt;p&gt;对于入口&lt;code&gt;html&lt;/code&gt;文件的处理直接使用&lt;code&gt;html-webpack-plugin&lt;/code&gt;插件来设置一定的配置参数即可，详细的配置参数可以参考其github地址:&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin&quot;&gt;html-webpack-plugin项目地址&lt;/a&gt;，在此直接给出基本用法示例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/702cdd3ef99210c8418d07ce328cdc55.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt;模板文件(构建生成的入口页面是以此为模板的):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/8d818faefb11eeb36786d59ec5dafdfd.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打包后生成的&lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;tony stark&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;bruce banner &amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;main.boundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多页面应用打包&quot;&gt;3.2 多页面应用打包&lt;/h3&gt;
&lt;p&gt;如果项目中有多个页面，那么打包的时候需要考虑两个基本问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.如何自动生成多个页面？&lt;/li&gt;
&lt;li&gt;2.如果引用中存在公共的模块，怎样才能提取公共模块？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了演示多页面应用打包的场景，我们来构建如下的一组示例项目及其依赖关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/e0b3ef020053016d8d6b75ffebbb5ad4.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多页面应用的基本结构理解起来并不复杂，可以将其看做是多个单页面应用的组合，在&lt;code&gt;webpack&lt;/code&gt;中需要进行一些配置调整：&lt;/p&gt;
&lt;p&gt;entry参数需要配置多个依赖入口文件:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;entry:{
    &quot;main&quot;:__dirname + &quot;/src/indexController.js&quot;,
    &quot;about&quot;:__dirname + &quot;/src/aboutController.js&quot;,
    &quot;list&quot;:__dirname + &quot;/src/listController.js&quot;,
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;html文件则需要分别引用对应的入口文件并生成对应的访问入口：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    plugins:[
        //index.html
        new HtmlWebpackPlugin({
            title:'MainPage',
            template:'src/index.html',
            filename:'index.html',
            templateParameters:{
                param1:'tony stark',
                param2:'bruce banner'
            },
            chunks:['main'],
       }),
        //about.html
        new HtmlWebpackPlugin({
            title:'AboutPage',
            template:'src/about.html',
            filename:'about.html',
            templateParameters:{
                param1:'tony stark',
                param2:'bruce banner'
            },
            chunks:['about'],
       }),
       //list.html
       new HtmlWebpackPlugin({
            title:'ListPage',
            template:'src/list.html',
            filename:'list.html',
            templateParameters:{
                param1:'tony stark',
                param2:'bruce banner'
            },
            chunks:['list'],
       }),
    ],&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在生成&lt;code&gt;html&lt;/code&gt;文件时已经为其单独引用了&lt;code&gt;chunks&lt;/code&gt;数组中指定的模块，这使得对应的页面生成时只依赖自己需要的脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.关于公共模块提取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/59b76e3a598c7c93c3d51ab2409e7194.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一小节解决了&lt;strong&gt;多页面应用的基本打包&lt;/strong&gt;的需求，从得到的打包后的模块中，很容易看出它存在重复打包的问题，&lt;code&gt;eventbus.js&lt;/code&gt;这个公共库被&lt;code&gt;indexController.js&lt;/code&gt;和&lt;code&gt;aboutController.js&lt;/code&gt;中均被引用，但在不同的chunks中被重复打包，当公共部分的体积较大时，这样的方式明显是不能接受的。实际上分包问题并不是多页面应用中才存在的，而且是非常复杂的，它不仅要考虑公共模块本身的大小，模块之间的引用关系，还需要考虑同步引用和异步引用等等非常多的问题，笔者尚未研究清楚。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;1-3的版本中使用&lt;code&gt;commonsChunkPlugin&lt;/code&gt;插件来解决这个问题，在4.0以上的版本中废弃了原有方法，改为使用&lt;code&gt;optimization.splitChunks&lt;/code&gt;和&lt;code&gt;optimization.runtimeChunk&lt;/code&gt;来解决优化chunk拆分的问题，关于两者的区别可以看&lt;a href=&quot;https://www.cnblogs.com/wmhuang/p/8967639.html&quot;&gt;《webpack4：连奏中的进化》&lt;/a&gt;这篇博文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 组件模板html文件的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在基于&lt;code&gt;Angular&lt;/code&gt;的项目中或许你会需要处理此类问题。github上点赞较多的&lt;code&gt;Angular-webpack-starter&lt;/code&gt;项目对于&lt;em&gt;html&lt;/em&gt;文件的处理是直接使用&lt;code&gt;raw-loader&lt;/code&gt;当做文本文件处理，推测其内部将&lt;em&gt;html&lt;/em&gt;文件中的内容当做模板字符串使用并在框架内部进行了加工。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;html-webpack-plugin&lt;/code&gt;插件是依赖于&lt;code&gt;html-loader&lt;/code&gt;而工作的，当你显式使用&lt;code&gt;/\.html$/&lt;/code&gt;作为规则来筛选文件时，同样会选择到作为入口文件的&lt;code&gt;html&lt;/code&gt;资源，从而造成冲突报错。在&lt;code&gt;Angularjs1.X&lt;/code&gt;项目中可考虑使用&lt;code&gt;ngTemplage-loader&lt;/code&gt;插件。&lt;/p&gt;
&lt;h2 id=&quot;四.-小结&quot;&gt;四. 小结&lt;/h2&gt;
&lt;p&gt;本文使用的&lt;code&gt;html&lt;/code&gt;文件是较为简单的，仅包含基本的标签和属性，并未包含其他资源引用（样式，图片等），毕竟&lt;code&gt;webpack&lt;/code&gt;的组成部分太过庞杂，去除干扰信息有针对性的学习更容易理解。资源管理及定位将在后续的章节阐述。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 15:29:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>作为前端最火的构建工具，是前端自动化工具链 最重要的部分 ，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过 问题 + 解决方式 的模式，以前端构建中遇到的具体需求为出发点，学习 工具中相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9478777.html</dc:identifier>
</item>
<item>
<title>概率软逻辑（PSL，Probabilistic soft logic）通用（可处理中文）版本 - 行者的灵感</title>
<link>http://www.cnblogs.com/zhangjiajia/p/9478683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangjiajia/p/9478683.html</guid>
<description>&lt;p&gt;概率软逻辑（PSL，Probabilistic soft logic）是用于开发概率模型的机器学习框架，由加州大学圣克鲁兹分校和马里兰大学联合开发。目前其复杂的环境构建方式和Groovy语言表达给像作者一样的初学者带来了不小的困难，而且诸多的依赖项使原本已经构建好的模型小错误频繁。&lt;/p&gt;
&lt;p&gt;经过努力，作者将其构建成单个jar包，并且加入编码机制使其可以支持各种语言的数据。主要贡献有三：&lt;/p&gt;
&lt;p&gt;1.将PSL原本复杂的依赖打包为单个jar包，加入依赖即可开始使用。&lt;/p&gt;
&lt;p&gt;2. 将不够熟悉的Groovy语言模型构建方式全部转化为java支持，只需一个.java文件便可进行模型构建。&lt;/p&gt;
&lt;p&gt;3.加入编码机制，使PSL可以处理除英文以外的语言。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1PybpNoPpvk4jmSMw7Rm_7A&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1PybpNoPpvk4jmSMw7Rm_7A&lt;/a&gt; 密码：g1cx&lt;br/&gt;链接文件夹里有三个文件：&lt;br/&gt;PSL_swust1.0.jar 修改过的PSL模型&lt;br/&gt;SimpleAcquaintances.zip PSL官方例子的改编版本（不包含权重学习和函数）&lt;br/&gt;Entity_resolution.zip PSL官方例子的改编版本（包含权重学习和函数）&lt;/p&gt;

&lt;p&gt;以SimpleAcquaintances内SimpleAcquaintances.java为例进行阐述。&lt;/p&gt;
&lt;h3&gt;1.配置项&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * ======【配置项】======
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Tool tool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tool();
        DataStore datastore;
        HashMap&lt;/span&gt;&amp;lt;String, Partition&amp;gt; partitions = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Partition&amp;gt;&lt;span&gt;();
        String path &lt;/span&gt;= tool.getPath(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleAcquaintances().getClass())
                &lt;/span&gt;+ &quot;/../data/&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SimpleAcquaintances改为当前类名&lt;/span&gt;
        String[] paths =&lt;span&gt; tool.getFiles(path);
        PSLMODEL psl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PSLMODEL(paths, &quot;H2&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在安装了postgresql数据库时可H2改为postgresql&lt;/span&gt;
        datastore =&lt;span&gt; psl.getDatastore();
        psl.transcoding &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否给数据编码(此值只决定数据是否编码，谓词默认都要编码)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用时SimpleAcquaintances需要改为当前类名，为了获取当前项目文件夹的数据文件夹data。另外当安装配置了postgreSQL时可将H2改为postgresql来使用postgreSQL数据库（H2为模型自带数据库，运行于内存）。transcoding 项设置为true时候会给数据编码（此时可设置谓词为UniqueIntID属性，提升模型计算效率），可以处理各种语言的数据，但是编码后无法合理使用PSL自带相似度计算函数(因为编码后数据不是原来的字符串了，相似度函数平时很少用到，自定义函数可以正常使用)。&lt;/p&gt;
&lt;h3&gt;2.定义分区&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权重学习分区
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; partitions.put(&quot;learn_obs&quot;, datastore.getPartition(&quot;learn_obs&quot;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; partitions.put(&quot;learn_target&quot;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; datastore.getPartition(&quot;learn_target&quot;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; partitions.put(&quot;learn_truth&quot;, datastore.getPartition(&quot;learn_truth&quot;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实验分区&lt;/span&gt;
        datastore =&lt;span&gt; psl.getDatastore();
        partitions.put(&lt;/span&gt;&quot;obs&quot;, datastore.getPartition(&quot;obs&quot;&lt;span&gt;));
        partitions.put(&lt;/span&gt;&quot;target&quot;, datastore.getPartition(&quot;target&quot;&lt;span&gt;));
        partitions.put(&lt;/span&gt;&quot;truth&quot;, datastore.getPartition(&quot;truth&quot;&lt;span&gt;));
        psl.setPartitions(partitions);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当需要权重学习时（有训练数据时），需要定义权重学习分区。obs代表已知数据分区，target代表要推理的目标数据储存分区（当要使用LazyInference推理时可以不往里面加载数据），truth为真实数据分区。&lt;/p&gt;
&lt;h3&gt;3.谓词（函数）定义&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
HashMap&amp;lt;String, ConstantType[]&amp;gt; p = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, ConstantType[]&amp;gt;&lt;span&gt;();
        HashMap&lt;/span&gt;&amp;lt;String, ExternalFunction&amp;gt; f = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, ExternalFunction&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加谓词&lt;/span&gt;
        p.put(&quot;Lived&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConstantType[] { ConstantType.UniqueStringID,ConstantType.UniqueStringID });
        p.put(&lt;/span&gt;&quot;Likes&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConstantType[] { ConstantType.UniqueStringID,ConstantType.UniqueStringID });
        p.put(&lt;/span&gt;&quot;Knows&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConstantType[] { ConstantType.UniqueStringID,ConstantType.UniqueStringID });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      f.put(&quot;SameInitials&quot;, new SameInitials());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      f.put(&quot;SameNumTokens&quot;, new SameNumTokens());&lt;/span&gt;
        psl.definePredicates(p, f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 谓词、函数输入模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;谓词定义只需替换即可，可随意增加，常用属性有UniqueStringID、UniqueIntID、String等。函数可以定义PSL自带相似度函数（transcoding 为false时）。&lt;/p&gt;
&lt;h3&gt;4.规则定义&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
String[] rules =&lt;span&gt; {

                &lt;/span&gt;&quot;20.0: ( LIVED(P1, L) &amp;amp; (P1 != P2) &amp;amp; LIVED(P2, L) ) &amp;gt;&amp;gt; KNOWS(P1, P2) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;5.0: ( (L1 != L2) &amp;amp; (P1 != P2) &amp;amp; LIVED(P2, L2) &amp;amp; LIVED(P1, L1) ) &amp;gt;&amp;gt; ~( KNOWS(P1, P2) ) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;10.0: ( LIKES(P2, L) &amp;amp; (P1 != P2) &amp;amp; LIKES(P1, L) ) &amp;gt;&amp;gt; KNOWS(P1, P2) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;5.0: ( KNOWS(P1, P2) &amp;amp; KNOWS(P2, P3) &amp;amp; (P1 != P3) ) &amp;gt;&amp;gt; KNOWS(P1, P3) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;1.0 * KNOWS(P1, P2) + -1.0 * KNOWS(P2, P1) = 0.0 .&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;5.0: ~( KNOWS(P1, P2) ) ^2&quot;&lt;span&gt;

        };
        psl.defineRules(rules);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 规则输入模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;权重: 规则体 &amp;gt;&amp;gt; 规则头 ，^2代表平方优化，按照两个例子里的规则格式增加规则即可。&lt;/p&gt;
&lt;h3&gt;5.导入数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * ======【导入数据】======
         * 其中&quot;1-2&quot;表示对数据的一二列进行转码
         * 只有在transcoding = true时作用，表示只对1，2两列进行转码
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        psl.loadData(&lt;/span&gt;&quot;Lived&quot;, path + &quot;Lived_obs.txt&quot;, &quot;obs&quot;, &quot;1-2&quot;&lt;span&gt;);
        psl.loadDataTruth(&lt;/span&gt;&quot;Likes&quot;, path + &quot;likes_obs.txt&quot;, &quot;obs&quot;, &quot;1-2&quot;&lt;span&gt;);
        psl.loadData(&lt;/span&gt;&quot;Knows&quot;, path + &quot;knows_obs.txt&quot;, &quot;obs&quot;, &quot;1-2&quot;&lt;span&gt;);
        psl.loadData(&lt;/span&gt;&quot;Knows&quot;, path + &quot;knows_targets.txt&quot;, &quot;target&quot;,&quot;1-2&quot;&lt;span&gt;);
        psl.loadDataTruth(&lt;/span&gt;&quot;Knows&quot;, path + &quot;knows_truth.txt&quot;, &quot;truth&quot;,&quot;1-2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      ArrayList&amp;lt;String[]&amp;gt; likepe = tool.fileToArrayList(path + &quot;likes_obs.txt&quot;, &quot;1-2-3&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.insertDataTruth(&quot;Likes&quot;, likepe, &quot;obs&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.insertData(&quot;Likes&quot;, likepe, &quot;obs&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;提供了loadData，loadDataTruth，insertData，insertDataTruth四种方法载入数据，loadData(&quot;谓词&quot;,谓词对应文件路径, &quot;导入分区&quot;, &quot;1-2&quot;)，loadData，loadDataTruth区别在于loadDataTruth最后一列为概率值；insertData，insertDataTruth需要将文件转化为List数据，适用于一个数据文件存储了多个谓词的数据， &quot;1-2-3&quot;代表要取出1、2、3作为谓词的数据，insertDataTruth取出的每个数据 &quot;1-2-...-n&quot;的第n项是概率值。其中&quot;1-2&quot;表示对数据的一二列进行转码， 只有在transcoding = true时作用，表示只对数据文件里的1，2两列进行转码，多列增加即可，以“-”分开。&lt;/p&gt;
&lt;h3&gt;6.权重学习&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  psl.learnWeights(&quot;learn_target&quot;, &quot;Lived-Likes&quot;, &quot;learn_obs&quot;, &quot;learn_truth&quot;,&quot;MaxLikelihoodMPE&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(&quot;训练数据目标分区&quot;, &quot;封闭谓词（即：作为已知数据，推理过程不会再新产生的原子）&quot;, &quot;训练数据已知数据分区&quot;, &quot;真实数据分区&quot;,&quot;权重学习方法&quot;)&lt;br/&gt;有训练数据时候可进行权重学习优化规则权重。实现了五种权重优化方法：&lt;br/&gt;&quot;LazyMaxLikelihoodMPE&quot;,&lt;br/&gt;&quot;MaxLikelihoodMPE&quot;,&lt;br/&gt;&quot;MaxPiecewisePseudoLikelihood&quot;，&lt;br/&gt;&quot;MaxPseudoLikelihood&quot;,&lt;br/&gt;&quot;SimplexSampler&quot;&lt;br/&gt;替换即可使用。&lt;/p&gt;
&lt;h3&gt;7.打印输出模型&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
psl.printModel();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可查看已经定义的模型。&lt;/p&gt;
&lt;h3&gt;8.运行推理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.runLazyInference(&quot;已知数据分区&quot;, &quot;目标分区（存放结果）&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.runLazyInference(&quot;obs&quot;, &quot;target&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.runInference(&quot;&quot;已知数据分区&quot;&quot;,&quot;封闭谓词1-封闭谓词2&quot; , &quot;目标分区（包含定义的目标原子）&quot;);&lt;/span&gt;
        psl.runInference(&quot;obs&quot;,&quot;Lived-Likes&quot; , &quot;target&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两种推理方式LazympeInference，mpeInference。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
psl.writeOutput(&quot;target&quot;, &quot;Knows&quot;&lt;span&gt;, path
                &lt;/span&gt;+ &quot;/result/knows_inffer.txt&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(&quot;目标分区&quot;, &quot;要输出的数据对应谓词1-要输出的数据对应谓词2&quot;, 输出路径)。&lt;/p&gt;
&lt;h3&gt;10.评估实验结果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
psl.evalResults(&quot;target&quot;, &quot;truth&quot;, &quot;Knows&quot;&lt;span&gt;, path
                &lt;/span&gt;+ &quot;/result/evalResults.txt&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(&quot;目标分区&quot;, &quot;真实数据分区&quot;, &quot;目标谓词1-目标谓词2&quot;, 评估结果输出路径)。值得一提的是，&quot;目标谓词1-目标谓词2&quot;需要包含所有真实数据分区里所包含数据对应的谓词。&lt;/p&gt;
&lt;h3&gt;11.关闭模型&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
psl.closeModel();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;推理完成，请关闭模型。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>行者的灵感</dc:creator>
<og:description>一、简介 概率软逻辑（PSL，Probabilistic soft logic）是用于开发概率模型的机器学习框架，由加州大学圣克鲁兹分校和马里兰大学联合开发。目前其复杂的环境构建方式和Groovy语言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangjiajia/p/9478683.html</dc:identifier>
</item>
<item>
<title>一款优秀的linux监控工具——nmon - gegeman</title>
<link>http://www.cnblogs.com/lijiaman/p/9466614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiaman/p/9466614.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;（一）nmon工具概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;nmon是以一个用来做linux服务器监控的工具，通过nmon，可以实现对以下参数的监控：&lt;/p&gt;
&lt;p&gt;  --CPU使用率&lt;/p&gt;
&lt;p&gt;  --内存、交换空间使用率&lt;/p&gt;
&lt;p&gt;  --网络使用情况&lt;/p&gt;
&lt;p&gt;  --磁盘I/O，读写速度&lt;/p&gt;
&lt;p&gt;  --网络I/O速度，传输和读写速度&lt;/p&gt;
&lt;p&gt;  --顶级进程，查看哪些应用程序占用的CPU较多&lt;/p&gt;
&lt;p&gt;  --网络文件系统NFS&lt;/p&gt;
&lt;p&gt;  --文件系统使用情况（类似df -h）&lt;/p&gt;
&lt;p&gt;等。。。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（二）nmon工具的部署&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;STEP1&lt;/span&gt;.下载安装包：http://nmon.sourceforge.net/pmwiki.php?n=Site.Download。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注释：这里需要根据自己的linux类型及版本选择合适的安装包，我的redhat 6.6 linux信息为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lsb_release: Distributor ID : RedHatEnterpriseServer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lsb_release: Description    : Red Hat Enterprise Linux Server release 6.6 (Santiago)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;，经测试，可以使用nmon16e_mpginc.tar.gz下面的“nmon_x86_64_rhel6”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;STEP2&lt;/span&gt;.解压安装包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@redhat6 ~]# &lt;span&gt;mkdir&lt;/span&gt; /opt/nmon/&lt;span&gt;nmon16e

[root@redhat6 nmon16e]# &lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;
/opt/nmon/&lt;span&gt;nmon16e
[root@redhat6 nmon16e]# &lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; -xzvf nmon16e_mpginc.&lt;span&gt;tar&lt;/span&gt;&lt;span&gt;.gz
...
nmon_x86_64_opensuse12
nmon_x86_64_rhel6
nmon_x86_64_rhel7
...

[root@redhat6 nmon16e]# ll
total &lt;/span&gt;&lt;span&gt;12540&lt;/span&gt;
-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;3456878&lt;/span&gt; Aug &lt;span&gt;13&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt; nmon16e_mpginc.&lt;span&gt;tar&lt;/span&gt;&lt;span&gt;.gz
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;383072&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_arm_ubuntu15
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;342054&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_32_rhel6
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;353612&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_32_sles11
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;460578&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64_kvm2
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;464824&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64le_fedora22
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;464824&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64le_rhel6
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;464824&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64le_rhel7
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;540615&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64le_ubuntu14
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;561504&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64le_ubuntu15
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;551472&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64le_ubuntu16
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;405725&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64_rhel6
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;460578&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64_rhel7
&lt;/span&gt;-rwxr-x---. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;418328&lt;/span&gt; Apr &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_power_64_sles11
&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;347506&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_x86_64_centos6
&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;402146&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_x86_64_centos7
&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;345503&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_x86_64_opensuse11
&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;394628&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_x86_64_opensuse12
&lt;/span&gt;&lt;span&gt;&lt;strong&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;347506&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; nmon_x86_64_rhel6
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;402146&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_x86_64_rhel7
&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;345503&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_x86_64_sles11
&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;394628&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; nmon_x86_64_sles12
&lt;/span&gt;-rwxr-----. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;481776&lt;/span&gt; Apr &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt; nmon_x86_64_ubuntu15
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;STEP3&lt;/span&gt;.找到与自己操作系统对应的文件，直接执行，即可进入nmon工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@redhat6 nmom6e]# ./nmon_power_64_rhel6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180813135054518-1309689691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（三）nmon实时监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以使用nmon进行实时监控，命令主要包括三种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;帮助命令&lt;/li&gt;
&lt;li&gt;监控参数命令&lt;/li&gt;
&lt;li&gt;监控辅助命令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（3.1）帮助命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;帮助命令为“H”，通过H命令可以了解到nmon的命令及作用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180813135950612-1564395271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; （3.2）监控命令&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;30.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;100PX&quot;&gt;&lt;span&gt;&lt;strong&gt; 命令&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;250PX&quot;&gt;&lt;span&gt;&lt;strong&gt;英文解释&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt; c | C&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;c = CPU Util   ;      &lt;/p&gt;
&lt;p&gt;C = wide view   &lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;用于监控CPU的使用情况。针对每核CPU的四种状态进行统计：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;User%：用户使用CPU百分比                 Sys% ：系统使用CPU百分比&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Wait%：CPU（非空闲）等待百分比       Idle%：空闲CPU百分比&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt; m | L&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;m = memory &amp;amp; swap  ;   &lt;/p&gt;
&lt;p&gt;L = Large(Huge) Page&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;用于监控内存及交换空间的使用情况，还可以使用“L”命令查看Large(Huge) Page的使用情况&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span&gt; n&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;n = network&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt; 监控每块网卡的I/O情况，主要监控&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --每秒接受/发送的流量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --进出网卡的package的数量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --进出流量（默认是2秒）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  --每秒接受/发送的流量的&lt;strong&gt;峰值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt; d&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;d = Disk I/O Graphs         &lt;/p&gt;
&lt;p&gt;D = Status&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;监控磁盘I/O情况，通过这个命令，可以看到磁盘的繁忙程度，读写速度，用“D”可以看到更细节的磁盘I/O信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：如果磁盘sda分区成为：sda1、sda2，那么会显示三个磁盘（sda、sda1、sda2）的信息。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td&gt;&lt;span&gt; k&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;k = kernel status &amp;amp; loadavg&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;监控内核状态及负载，通过这个参数，可以了解到CPU具体消耗在哪些地方&lt;/p&gt;
&lt;p&gt;--全部CPU的使用负载，CPU具体耗费在哪些地方也有所描述，不同于前面c或C对单个CPU统计&lt;/p&gt;
&lt;p&gt;--全部CPU的平均负载（1min、5min、15min）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; M&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;M = MHz by thread &amp;amp; CPU&lt;/td&gt;
&lt;td&gt;CPU的时钟震荡频率 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;&lt;span&gt; t&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;t = Top Process，可选参数：&lt;/p&gt;
&lt;p&gt;  --1：Priority/Nice/STate &lt;/p&gt;
&lt;p&gt;  --3：CPU&lt;/p&gt;
&lt;p&gt;  --4：RAM&lt;/p&gt;
&lt;p&gt;  --5：I/O&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;顶级进程，可通过一下方式排序&lt;/p&gt;
&lt;p&gt;--1：基础方式，个人感觉不实用&lt;/p&gt;
&lt;p&gt;--3：按CPU消耗排序&lt;/p&gt;
&lt;p&gt;--4：按内存消耗排序&lt;/p&gt;
&lt;p&gt;--5：按I/O消耗排序&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; g&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;g = User Defined Disk Groups &lt;/td&gt;
&lt;td&gt;用户定义的磁盘组信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt; r&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;r = Resources OS &amp;amp; Proc&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;操作系统资源信息，如：&lt;/p&gt;
&lt;p&gt;--CPU型号、CPU频率、每颗CPU的物理内核、超线程、虚拟CPU数量&lt;/p&gt;
&lt;p&gt;--操作系统版本：linux版本、redhat版本&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; l&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;l = long term CPU averages&lt;/td&gt;
&lt;td&gt;长期的CPU负载监控。类似于windows任务管理器提供的CPU监控功能 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; V&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;v = Virtual Memory&lt;/td&gt;
&lt;td&gt;虚拟内存使用情况 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; N&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;N = NFS&lt;/td&gt;
&lt;td&gt; NFS网络文件系统I/O统计&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; o&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;o = Disk %Busy Map&lt;/td&gt;
&lt;td&gt;通过MAP图，记录了哪些磁盘在使用，哪些磁盘未使用  &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; j&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;j = Filesystem Usage&lt;/td&gt;
&lt;td&gt;文件系统的使用情况，类似于df -h&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; u&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;u = Top Process with command line Hit u twice to update&lt;/td&gt;
&lt;td&gt;顶级进程，带有两次去更新数据操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; G&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;G = with -g switches Disk Graphs to disk groups only &lt;/td&gt;
&lt;td&gt;不清楚具体作用，略&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(3.3) 辅助监控命令&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr&gt;&lt;td width=&quot;100PX&quot;&gt;命令&lt;/td&gt;
&lt;td width=&quot;250PX&quot;&gt;英文解释&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt; “+” (shift+“+”)&lt;/td&gt;
&lt;td&gt; “+” = double the screen refresh time&lt;/td&gt;
&lt;td&gt; 屏幕刷新频率改为2倍&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt; “-”  (shift+“-”)&lt;/td&gt;
&lt;td&gt;“ - ” = half the screen refresh time &lt;/td&gt;
&lt;td&gt; 屏幕刷新频率改为一半&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; “.”&lt;/td&gt;
&lt;td&gt;“.” = Display only busy disk &amp;amp; CPU &lt;/td&gt;
&lt;td&gt; 标出处于繁忙状态的CPU &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; 0&lt;/td&gt;
&lt;td&gt; 0 = reset peak marks(&quot;&amp;gt;&quot;) to zero&lt;/td&gt;
&lt;td&gt; 将峰值重新设置为0 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; space&lt;/td&gt;
&lt;td&gt;space refresh screen now &lt;/td&gt;
&lt;td&gt; 空格键手动刷新屏幕 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; b&lt;/td&gt;
&lt;td&gt; black &amp;amp; white mode &lt;/td&gt;
&lt;td&gt;颜色显示为黑白模式 &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; q&lt;/td&gt;
&lt;td&gt;q = Quit　　 &lt;/td&gt;
&lt;td&gt;退出 &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（四）nmon数据非实时分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除了实时分析外，还可以对数据进行收集，然后使用nmonchart、nmon_analyser工具将收集的数据进行绘图、展现。&lt;/p&gt;
&lt;p&gt;nmon收集数据命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@redhat6 nmom6e]# ./nmon_x86_64_rhel6 -s1 -c300 -f -m /opt/nmon/nmon16e/&lt;span&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;br/&gt;&lt;span&gt;-s1      ： 每隔n秒抽样一次，这里为1s；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-c300  ： 采样次数，这里为300次；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-f         ： 按照标准格式输出文件名称：&amp;lt;hostname&amp;gt;_YYMMDD_HHMM.nmon&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-m       ： 文件输出路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最终会生成一个nmon文件，在得到nmon文件后，可以使用nmonchart或者是nmon analyser来绘制图形。&lt;/p&gt;
&lt;p&gt;接下来介绍一下nmonchart与nmon_analyser的用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4.1）使用nmonchart生成图形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上所述，nmon收集数据后，会形成一个*.nmon文件，我们可以使用nmonchart来生成html的服务器性能报表，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; nmonchart下载地址&lt;/strong&gt;：http://nmon.sourceforge.net/pmwiki.php?n=Site.Nmonchart&lt;/p&gt;
&lt;p&gt; 使用语法：nmonchart &amp;lt;nmon-file&amp;gt; &amp;lt;output-file&amp;gt;.html&lt;/p&gt;
&lt;p&gt;例子：使用nmonchart将redhat6_180814_1014.nmon转换为html图形报表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@redhat6 ~]/opt/nmon/nmon16e/nmonchart/nmonchart  /opt/nmon/nmon16e/&lt;span&gt;file&lt;/span&gt;/redhat6_180814_1014.nmon  /opt/nmon/nmon16e/&lt;span&gt;file&lt;/span&gt;/redhat6_180814_1014.html 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 执行提示异常:-bash: ./nmonchart: /usr/bin/ksh: bad interpreter: No such file or directory&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.csdn.net/zd470015321/article/details/68923280&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决办法:&lt;/p&gt;
&lt;p&gt;nmonchart需要使用ksh,这里提示没有在&quot;/usr/bin/ksh&quot;没有找到ksh，先确定系统有没有安装ksh。我的系统的redhat6.5，是安装了ksh的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@redhat6 ~]# &lt;span&gt;which&lt;/span&gt;&lt;span&gt; ksh
&lt;/span&gt;/bin/ksh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.csdn.net/zd470015321/article/details/68923280&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然有ksh，就不用安装了，直接修改nmonchart的shell即可，编辑nmonchart文件  vi /home/nmon/nmonchart31/nmonchart ,修改第一行#!/usr/bin/ksh 为#!/bin/ksh。然后再执行转换命令就好了&lt;/p&gt;
&lt;p&gt;按理说打开html文档，可以看到官方提供的这样的图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814213749258-425309119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我打开之后，却是这样的。。。上面的按钮无法点开看到图像，以为是浏览器的原因，试了chrome、firefox、ie都不好使。一时没法搞定，暂放一下，再想想是哪里出了问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814214053866-1772097139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4.2）使用nmon_analyser生成图形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; nmon analyser是一个excel工具，下载地址为：https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power+Systems/page/nmon_analyser 。&lt;/p&gt;
&lt;p&gt;下载解压之后，有2个文件，word文档是analyser的用户指南，对analyser工具的使用介绍得非常详细，excel就是我们用来做数据分析的工具了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814221244524-1201549267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初次使用时，一般会提示“宏已被禁用”，我们需要启用宏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814221918245-391421106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接着点击“Analyze nmon data”按钮，将需要分析的*.nmon文件加载到excel中，分析完成后，会生成一个新的excel，里面记录了服务器的各项参数信息，我们简单的看几个图形：&lt;/p&gt;

&lt;p&gt;图1：SYS_SUMM。这个图对一段时间内服务器的CPU、I/O进行了统计&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814225125985-1542963105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 图2：DISK_SUMM。这个图反映了磁盘的读写速度以及I/O请求的数量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814225027645-1744175813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图3 ：CPU_ALL。反馈了CPU的负载情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814224957163-1795899302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图4：CPU_SUMM。反馈了在真个时间段内每核CPU的负载情况&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814224928767-1436522364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图5 图6 NET。反馈了整体网络I/O情况以及每个网卡的I/O的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814224831020-1970984275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814224840687-1254423072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图7：CPU001：反馈了第1核CPU在监控时间段内的负载情况（这台服务器有48核心，这里只列出1核）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/823295/201808/823295-20180814224750418-1595633804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（五）nmon工具使用心得&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;nmon工具非常小巧，却又非常的强大，nmon大小不足1MB，却能够监控10多项重要参数，相对于其它的工具，例如iostat、top等，nmon显示的信息更多，对用户也更友好，作为一个linux的初级使用者，也能理解其中的大部分信息。&lt;/p&gt;
&lt;p&gt;由于linux和操作系统基础较差，目前我个人只能理解一部分参数，后续还需加强学习。此外nmonchart也未成功draw出图形，也需寻找原因。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 15:04:00 +0000</pubDate>
<dc:creator>gegeman</dc:creator>
<og:description>（一）nmon工具概述 nmon是以一个用来做linux服务器监控的工具，通过nmon，可以实现对以下参数的监控： --CPU使用率 --内存、交换空间使用率 --网络使用情况 --磁盘I/O，读写速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiaman/p/9466614.html</dc:identifier>
</item>
<item>
<title>Java之static作用的全方位总结 - 小勇DW3</title>
<link>http://www.cnblogs.com/gxyandwmm/p/9478569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxyandwmm/p/9478569.html</guid>
<description>&lt;p&gt;　&lt;strong&gt;&lt;span&gt;　引用一位网友的话，说的非常好，如果别人问你static的作用；如果你说静态修饰 类的属性 和 类的方法 别人认为你是合格的；如果是说 可以构成 静态代码块，那别人认为你还可以； 如果你说可以构成 静态内部类， 那别人认为你不错；如果你说了静态导包，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那别人认为你很OK；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那我们就先在这几方面一一对static进行总结；然后说一些模糊的地方，以及一些面试中容易问道的地方；&lt;/p&gt;
&lt;h2&gt;1）static方法&lt;/h2&gt;
&lt;p&gt;　　static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。&lt;/p&gt;
&lt;p&gt;　　但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。举个简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/i/288799/201406/201612439117678.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：&lt;/p&gt;
&lt;p&gt;　　MyObject.print2();&lt;/p&gt;
&lt;p&gt;　　此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。&lt;/p&gt;
&lt;p&gt;　　而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。&lt;/p&gt;
&lt;p&gt;　　因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。&lt;/p&gt;
&lt;p&gt;　　另外记住，关于构造器是否是static方法可参考：http://blog.csdn.net/qq_17864929/article/details/48006835&lt;/p&gt;
&lt;h2&gt;2）static变量&lt;/h2&gt;
&lt;p&gt;　　static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本【存放在方法区】，它当且仅当在类初次加载时会被初始化【加final和不加final的static变量初始化的位置不一样】。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。&lt;/p&gt;
&lt;p&gt;　　static成员变量的初始化顺序按照定义的顺序进行初始化。&lt;/p&gt;
&lt;h2&gt;3）static代码块&lt;/h2&gt;
&lt;p&gt;　　static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，&lt;span&gt;类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次【根据class加载原理 每个类加载一次 使用双亲委托加载】&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;初始化的顺序 静态代码块 &amp;gt; 构造代码块 &amp;gt; 构造函数 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造代码块&lt;/span&gt;
        System.out.println(&quot;执行构造代码块&quot;&lt;span&gt;);
    }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birthDate;
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(Date birthDate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.birthDate =&lt;span&gt; birthDate;
    }
     
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isBornBoomer() {
        Date startDate &lt;/span&gt;= Date.valueOf(&quot;1946&quot;&lt;span&gt;);
        Date endDate &lt;/span&gt;= Date.valueOf(&quot;1964&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; birthDate.compareTo(startDate)&amp;gt;=0 &amp;amp;&amp;amp; birthDate.compareTo(endDate) &amp;lt; 0&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　isBornBoomer是用来这个人是否是1946-1964年出生的，而&lt;span&gt;每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，&lt;/span&gt;如果改成这样效率会更好，其实就是利用了静态代码块在内存中值加载一次的机制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birthDate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Date startDate,endDate;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        startDate &lt;/span&gt;= Date.valueOf(&quot;1946&quot;&lt;span&gt;);
        endDate &lt;/span&gt;= Date.valueOf(&quot;1964&quot;&lt;span&gt;);
    }
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(Date birthDate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.birthDate =&lt;span&gt; birthDate;
    }
     
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isBornBoomer() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; birthDate.compareTo(startDate)&amp;gt;=0 &amp;amp;&amp;amp; birthDate.compareTo(endDate) &amp;lt; 0&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因此，很多时候会将一些&lt;span&gt;只需要进行一次的初始化操作都放在static代码块中进行。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;4）静态内部类&lt;/h2&gt;
&lt;p&gt;这个地方不单独写静态内部类，通过和普通的内部类对比来加深对静态内部类的理解：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为何要用内&lt;/strong&gt;&lt;strong&gt;部类？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   1.   &lt;span&gt;内部类一般只为其外部类使用；【供外部类使用说的很好  举例 hashmap集合中 有一个内部类 Entry 就是 转为为 hashmap 存储来使用】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   2.   内部类提供了某种进入外部类的窗户，内部类存在外部类的引用，所以内部类可以直接访问外部类的属性；&lt;/p&gt;
&lt;p&gt;   3.   也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。&lt;/p&gt;

&lt;p&gt;定义在一个类内部的类叫内部类，包含内部类的类称为外部类。内部类可以声明public、protected、private等访问限制，可以声明 为abstract的供其他内部类或外部类继承与扩展，或者声明为static、final的，也可以实现特定的接口。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;外部类按常规的类访问方式（以对象的方式）使用内部 类，唯一的差别是&lt;strong&gt;外部类可以访问内部类的所有方法与属性，包括私有方法与属性，外部类访问内部类，需要创建对象访问；有一点需要注意，内部类不能访问外部类所在的局部变量，只能访问final修饰的局部变量。&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;举例: 在方法中 定义内部类  然后内部类 调用方法的的入参 则 入参必须是  final 修饰&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在方法内定义内部类时，如果内部类调用了方法中的变量，那么该变量必须申明为final类型，百思不得其解，&lt;span&gt;后来想到应该是生命周期的原因&lt;/span&gt;，因为方法内定义的变量是局部变量，离开该方法，变量就失去了作用，也就会自动被消除，而内部类却不会离开它所在方法就失去作用，它有更广的生命周期，下面通过一个实例加以说明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hi.csdn.net/attachment/201103/15/0_1300176759Dsv5.gif&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://hi.csdn.net/attachment/201103/15/0_1300176760fEui.gif&quot; alt=&quot;image&quot; width=&quot;643&quot; height=&quot;348&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)&lt;/strong&gt;&lt;strong&gt;创建实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   OutClass.InnerClass obj = &lt;span&gt;outClassInstance&lt;/span&gt;.new InnerClass(); //注意是外部类实例.new，内部类&lt;/p&gt;
&lt;p&gt;   AAA.StaticInner in = new &lt;span&gt;AAA&lt;/span&gt;.StaticInner();//注意是外部类本身，静态内部类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   (2)&lt;/strong&gt;&lt;strong&gt;内部类中的this&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   内部类中的this与其他类一样是指的本身。创建内部类对象时，它会与创造它的外围对象有了某种联系，&lt;span&gt;于是能访问外围类的所有成员，不需任何特殊条件，可理解为内部类链接到外部类&lt;/span&gt;。 用外部类创建内部类对象时，此内部类对象会秘密的捕获一个指向外部类的引用，于是，可以通过这个引用来访问外围类的成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   (3)&lt;/strong&gt;&lt;strong&gt;外部类访问内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   内部类类似外部类的属性，因此访问内部类对象时总是需要一个创建好的外部类对象。外部类对象通过‘外部类名.this.xxx’的形式访问内部类的属性与方法。如：&lt;br/&gt;       System.out.println(&quot;Print in inner Outer.index=&quot; + pouter.this.index);&lt;br/&gt;       System.out.println(&quot;Print in inner Inner.index=&quot; + this.index);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）内部类向上转型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类问，从而完全隐藏实现的细节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）方法内的类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   方法内创建的类（注意方法中也能定义类），不能加访问修饰符。另外，方法内部的类也不是在调用方法时才会创建的，它们一样也被事先编译了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）静态内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   定义静态内部类：在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。&lt;/p&gt;
&lt;p&gt;通常称为&lt;strong&gt;嵌套类&lt;/strong&gt;，当内部类是static时，意味着：&lt;/p&gt;
&lt;p&gt;  &lt;span&gt; [1]要创建嵌套类的对象，并不需要其外围类的对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;  [2]不能从嵌套类的对象中访问非静态的外围类对象（不能够从静态内部类的对象中访问外部类的非静态成员）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   嵌 套类与普通的内部类还有一个区别：&lt;span&gt;普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，&lt;/span&gt; 也不能包含嵌套类。但是在嵌套类里可以包含所有这些东西。也就是说，在非静态内部类中不可以声明静态成员，&lt;span&gt;只有将某个内部类修饰为静态类，然后才能够在这 个类中定义静态的成员变量与成员方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   另外，在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。普通非静态内部类的 对象是依附在外部类对象之中的，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。静态类和方法只属于类本身，并不属于 该类的对象，更不属于其他外部类的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（7）内部类标识符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件，但是它的名称却不是内部类的类名，而是有着严格的限制：外围类的名字，加上$,再加上内部类名字。&lt;/p&gt;
&lt;p&gt;代码具体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OutClassTest &lt;br/&gt;{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        System.out.println(&lt;/span&gt;&quot;outer class static function&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new一个外部类&lt;/span&gt;
        OutClassTest oc1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutClassTest();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过外部类的对象new一个非静态的内部类&lt;/span&gt;
        OutClassTest.InnerClass no_static_inner = oc1.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用非静态内部类的方法&lt;/span&gt;
&lt;span&gt;        System.out.println(no_static_inner.getKey());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用静态内部类的静态变量&lt;/span&gt;
&lt;span&gt;        System.out.println(OutClassTest.InnerStaticClass.static_value);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不依赖于外部类实例,直接实例化内部静态类&lt;/span&gt;
        OutClassTest.InnerStaticClass inner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutClassTest.InnerStaticClass();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用静态内部类的非静态方法&lt;/span&gt;
&lt;span&gt;        System.out.println(inner.getValue());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用内部静态类的静态方法&lt;/span&gt;
&lt;span&gt;        System.out.println(OutClassTest.InnerStaticClass.getMessage());
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有在静态内部类中才能够声明或定义静态成员
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; private static String tt = &quot;0&quot;;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; flag = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InnerClass() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三.非静态内部类的非静态成员可以访问外部类的非静态变量和静态变量&lt;/span&gt;
            System.out.println(&quot;InnerClass create a:&quot; +&lt;span&gt; a);
            System.out.println(&lt;/span&gt;&quot;InnerClass create b:&quot; +&lt;span&gt; b);
            System.out.println(&lt;/span&gt;&quot;InnerClass create flag:&quot; +&lt;span&gt; flag);
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            System.out.println(&quot;InnerClass call outer static function&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用外部类的静态方法&lt;/span&gt;
&lt;span&gt;            test();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  String getKey() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;no-static-inner&quot;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerStaticClass {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态内部类可以有静态成员，而非静态内部类则不能有静态成员。&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String static_value = &quot;0&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; flag = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InnerStaticClass() {
            System.out.println(&lt;/span&gt;&quot;InnerClass create a:&quot; +&lt;span&gt; a);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态内部类不能够访问外部类的非静态成员
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; System.out.println(&quot;InnerClass create b:&quot; + b);&lt;/span&gt;
            System.out.println(&quot;InnerStaticClass flag is &quot; +&lt;span&gt; flag);
            System.out.println(&lt;/span&gt;&quot;InnerStaticClass tt is &quot; +&lt;span&gt; static_value);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态内部类访问外部类的静态方法&lt;/span&gt;
&lt;span&gt;            test();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getMessage() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;static-inner&quot;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OutClassTest() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new一个非静态的内部类&lt;/span&gt;
        InnerClass ic = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass();
        System.out.println(&lt;/span&gt;&quot;OuterClass create&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4）静态导包&lt;/h2&gt;
&lt;p&gt; 静态导包就是java包的静态导入，用import static代替import静态导入包是JDK1.5中的新特性。&lt;/p&gt;
&lt;p&gt;一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.*;这里的多了个static，还有就是类名ClassName后面多了个.* ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。&lt;/p&gt;
&lt;p&gt;好处：这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…);就可以将其写入一个静态方&lt;/p&gt;
&lt;p&gt;法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便&lt;/p&gt;
&lt;p&gt;example:&lt;br/&gt;在Java 5中，import语句得到了增强，以便提供甚至更加强大的减少击键次数功能，虽然一些人争议说这是以可读性为代价的。这种新的特性成为静态导入。当你想使用static成员时，可以使用静态导入（在API中的类和你自己的类上，都可以使用该特性）。下面是静态导入前后的代码实例：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在静态导入之前：&lt;/p&gt;
&lt;p&gt;public class TestStatic {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;
&lt;p&gt;System.out.println(Integer.MAX_VALUE);&lt;/p&gt;
&lt;p&gt;System.out.println(Integer.toHexString(42));&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在静态导入之后：&lt;br/&gt;import &lt;span&gt;static&lt;/span&gt; java.lang.System.out;&lt;/p&gt;
&lt;p&gt;import &lt;span&gt;static&lt;/span&gt; java.lang.Integer.*;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;public class TestStaticImport {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;out.println(&lt;/span&gt;MAX_VALUE);&lt;/p&gt;
&lt;p&gt;out.println(&lt;span&gt;toHexString(42&lt;/span&gt;));&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;让我们看一下使用静态导入特性的代码中将发生什么：&lt;br/&gt;1、虽然该特性通常称为“静态导入”，但&lt;span&gt;语法必须是import static&lt;/span&gt;，后面跟你想导入的static成员的完全限定名称，或者通配符。在本例中，我们在System类的out对象上进行静态导入。&lt;/p&gt;
&lt;p&gt;2、在本例中，我们可能想使用java.lang.Integer类的几个static成员。该静态导入语句使用通配符来表达“我想在此类中的所有静态成员上进行静态导入”。&lt;/p&gt;
&lt;p&gt;3、现在我们终于看到静态导入特性的好处！我们不必在System.out.println中键入System。太好了！另外，我们不必在Integer.MAX_VALUE中键入Integer。因此，在这行代码中，我们能够将快捷方式用于静态方法和一个常量。&lt;/p&gt;
&lt;p&gt;4、最后，我们进行更多的快捷操作，这次针对Integer类的方法。&lt;/p&gt;
&lt;p&gt;关于该特性，我们已经有点儿讽刺意味儿了，但不仅我们是这样的。我们不认为节省少量的击键次数会让代码&lt;/p&gt;
&lt;p&gt;难于阅读一点，但许多开发人员要求将它添加到语言中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面是使用静态导入的几条原则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你必须说import static， 不能说static import。&lt;/p&gt;
&lt;p&gt;提防含糊不清的命名static成员。例如，如果你对Integer类和Long类执行了静态导入，引用MAX_VALUE将导致一个编译器错误，因为Integer和Long都有一个MAX_VALUE常量，并且Java不会知道你在引用哪个MAX_VALUE。&lt;/p&gt;
&lt;p&gt;你可以在static对象引用、常量（记住，它们是static 或final）和static方法上进行静态导入。&lt;/p&gt;

&lt;h2&gt;二.static关键字的误区&lt;/h2&gt;
&lt;p&gt;1.static关键字会改变类中成员的访问权限吗？&lt;/p&gt;
&lt;p&gt;　　有些初学的朋友会将java中的static与C/C++中的static关键字的功能混淆了。在这里只需要记住一点：与C/C++中的static不同，&lt;span&gt;Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected&lt;/span&gt;（包括包访问权限）这几个关键字。看下面的例子就明白了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/i/288799/201406/201658474265949.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示错误&quot;Person.age 不可视&quot;，这说明static关键字并不会改变变量和方法的访问权限。&lt;/p&gt;
&lt;p&gt;2.能通过this访问静态成员变量吗？&lt;/p&gt;
&lt;p&gt;　　虽然对于静态方法来说没有this，那么在非静态方法中能够通过this访问静态成员变量吗？先看下面的一个例子，这段代码输出的结果是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {　　
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 33&lt;span&gt;;
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Main().printValue();
    }
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printValue(){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value = 3&lt;span&gt;;
        System.out.println(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.value&lt;/span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出 33&lt;/p&gt;
&lt;p&gt;　　这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。&lt;span&gt;而static变量是被对象所享有的&lt;/span&gt;，因此在printValue中的this.value的值毫无疑问是33。&lt;span&gt;在printValue方法内部的value是局部变量，根本不可能与this关联&lt;/span&gt;，所以输出结果是33。在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。&lt;/p&gt;
&lt;p&gt;3.static能作用于局部变量么？&lt;/p&gt;
&lt;p&gt;　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：&lt;span&gt;static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　具体原因可以参考这篇博文的讨论：http://www.debugease.com/j2se/178932.html&lt;/p&gt;
&lt;h2&gt;三.常见的笔试面试题&lt;/h2&gt;
&lt;p&gt;　　下面列举一些面试笔试中经常遇到的关于static关键字的题目，仅供参考，如有补充欢迎下方留言。&lt;/p&gt;
&lt;p&gt;1.下面这段代码的输出结果是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Base{
 
    &lt;/span&gt;&lt;span&gt;static{
        System.out.println(&quot;test static&quot;);
    }
     
    public Test(){
        System.out.println(&quot;test constructor&quot;);
    }
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
    }
}
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base{
     
    &lt;/span&gt;&lt;span&gt;static{
        System.out.println(&quot;base static&quot;);
    }
     
    public Base(){
        System.out.println(&quot;base constructor&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
    }&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
base static
&lt;/pre&gt;
&lt;pre&gt;
test static
&lt;/pre&gt;
&lt;pre&gt;
base constructor
&lt;/pre&gt;
&lt;pre&gt;
test constructor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至于为什么是这个结果，我们先不讨论，先来想一下这段代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。&lt;/p&gt;
&lt;p&gt;2.这段代码的输出结果是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;Test&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;test static&quot;&lt;span&gt;);
    }
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Test() {
        System.out.println(&lt;/span&gt;&quot;test constructor&quot;&lt;span&gt;);
    }
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyClass();
    }
}
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;person static&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String str) {
        System.out.println(&lt;/span&gt;&quot;person &quot;+&lt;span&gt;str);
    }
}
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyClass &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Test {
    Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;MyClass&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;myclass static&quot;&lt;span&gt;);
    }
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyClass() {
        System.out.println(&lt;/span&gt;&quot;myclass constructor&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
test static
myclass static
person static
person Test
test constructor
person MyClass
myclass constructor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　类似地，我们还是来想一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。&lt;/p&gt;
&lt;p&gt;3.这段代码的输出结果是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
     
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;test static 1&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
         
    }
     
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;test static 2&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
test &lt;span&gt;static&lt;/span&gt; 1&lt;span&gt;
test &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; 2
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 14 Aug 2018 15:00:00 +0000</pubDate>
<dc:creator>小勇DW3</dc:creator>
<og:description>1、深度总结 引用一位网友的话，说的非常好，如果别人问你static的作用；如果你说静态修饰 类的属性 和 类的方法 别人认为你是合格的；如果是说 可以构成 静态代码块，那别人认为你还可以； 如果你说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxyandwmm/p/9478569.html</dc:identifier>
</item>
<item>
<title>基于pandas python sklearn 的美团某商家的评论分类(文本分类） - 多一点</title>
<link>http://www.cnblogs.com/onemorepoint/p/9478429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onemorepoint/p/9478429.html</guid>
<description>&lt;h3 id=&quot;美团店铺评价语言处理以及分类nlp&quot;&gt;美团店铺评价语言处理以及分类（NLP）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上两篇博客中介绍了美团店铺的订单信息以及数据分析以及可视化&lt;/li&gt;
&lt;li&gt;其中还有一部分评论文本信息并没有提及到，自然也就有了这篇&lt;/li&gt;
&lt;li&gt;主要用到的包有jieba，sklearn，pandas&lt;/li&gt;
&lt;li&gt;本篇博文主要先用的是词袋模型(bag of words),将文本以数值特征向量的形式来表示(每个文档构建一个特征向量，有很多的0，类似于前文说的category类的one-hot形式，得到的矩阵为稀疏矩阵)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;导入数据分析常用库&quot;&gt;导入数据分析常用库&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
import numpy as np&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;读取文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;df=pd.read_excel(&quot;all_data_meituan.xlsx&quot;)[[&quot;comment&quot;,&quot;star&quot;]]
df.head()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9bm7nc6tj20qm0bijtc.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看DataFrame的大小&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;df.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(17400, 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;df['sentiment']=df['star'].apply(lambda x:1 if x&amp;gt;30 else 0)
df=df.drop_duplicates() ## 去掉重复的评论，剩余的文本1406条，我们将数据复制为原有数据的三倍
df=df.dropna()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X=pd.concat([df[['comment']],df[['comment']],df[['comment']]])
y=pd.concat([df.sentiment,df.sentiment,df.sentiment])
X.columns=['comment']
X.reset_index
X.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(3138, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
import jieba # 导入分词库
def chinese_word_cut(mytext):
    return &quot; &quot;.join(jieba.cut(mytext))
X['cut_comment']=X[&quot;comment&quot;].apply(chinese_word_cut)
X['cut_comment'].head()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Building prefix dict from the default dictionary ...
DEBUG:jieba:Building prefix dict from the default dictionary ...
Loading model from cache C:\Users\HUANG_~1\AppData\Local\Temp\jieba.cache
DEBUG:jieba:Loading model from cache C:\Users\HUANG_~1\AppData\Local\Temp\jieba.cache
Loading model cost 0.880 seconds.
DEBUG:jieba:Loading model cost 0.880 seconds.
Prefix dict has been built succesfully.
DEBUG:jieba:Prefix dict has been built succesfully.





0    还行 吧 ， 建议 不要 排队 那个 烤鸭 和 羊肉串 ， 因为 烤肉 时间 本来 就 不够...
1    去过 好 几次 了   东西 还是 老 样子   没 增添 什么 新花样   环境 倒 是 ...
2    一个 字 ： 好 ！ ！ ！   # 羊肉串 #   # 五花肉 #   # 牛舌 #   ...
3    第一次 来 吃 ， 之前 看过 好多 推荐 说 这个 好吃 ， 真的 抱 了 好 大 希望 ...
4    羊肉串 真的 不太 好吃 ， 那种 说 膻 不 膻 说 臭 不 臭 的 味 。 烤鸭 还 行...
Name: cut_comment, dtype: object&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;导入sklearn中的数据分割模块，设定test数据集大小，shuffle默认Ture&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import  train_test_split
X_train,X_test,y_train,y_test= train_test_split(X,y,random_state=42,test_size=0.25)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;获取停用词&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_custom_stopwords(stop_words_file):
    with open(stop_words_file,encoding=&quot;utf-8&quot;) as f:
        custom_stopwords_list=[i.strip() for i in f.readlines()]
    return custom_stopwords_list&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;stop_words_file = &quot;stopwords.txt&quot;
stopwords = get_custom_stopwords(stop_words_file) # 获取停用词&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;导入词袋模型&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.feature_extraction.text import  CountVectorizer
vect=CountVectorizer()  # 实例化
vect # 查看参数&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;CountVectorizer(analyzer='word', binary=False, decode_error='strict',
        dtype=&amp;lt;class 'numpy.int64'&amp;gt;, encoding='utf-8', input='content',
        lowercase=True, max_df=1.0, max_features=None, min_df=1,
        ngram_range=(1, 1), preprocessor=None, stop_words=None,
        strip_accents=None, token_pattern='(?u)\\b\\w\\w+\\b',
        tokenizer=None, vocabulary=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# dir(vect)  # 查看vect的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将分割后的文本进行fit_transform,系数矩阵大小为2353*1965&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;vect.fit_transform(X_train[&quot;cut_comment&quot;])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;2353x1965 sparse matrix of type '&amp;lt;class 'numpy.int64'&amp;gt;'
    with 20491 stored elements in Compressed Sparse Row format&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;vect.fit_transform(X_train[&quot;cut_comment&quot;]).toarray().shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(2353, 1965)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pd.DataFrame(vect.fit_transform(X_train[&quot;cut_comment&quot;]).toarray(),columns=vect.get_feature_names()).iloc[:,0:25].head()
# print(vect.get_feature_names())
#  数据维数1956，不算很大（未使用停用词）
# 将其转化为DataFrame&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;发现其中有很多的数字以及无效特征，随后传入实例化参数的同时，加入正则匹配取出这些无意义特征，同时取出停用词&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9c1rlvn1j20mo05c74b.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;vect = CountVectorizer(token_pattern=u'(?u)\\b[^\\d\\W]\\w+\\b',stop_words=frozenset(stopwords)) # 去除停用词，匹配以数字开头的非单词字符
pd.DataFrame(vect.fit_transform(X_train['cut_comment']).toarray(), columns=vect.get_feature_names()).head()
# 1691 columns,去掉以数字为特征值的列，减少了近三百列，由1965减小到1691 
# max_df = 0.8 # 在超过这一比例的文档中出现的关键词（过于平凡），去除掉（可以自行设定）
# min_df = 3 # 在低于这一数量的文档中出现的关键词（过于独特），去除掉。（可以自行设定）&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;取出数字特征之后&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9c4y3h26j20u5057wem.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;模型构建&quot;&gt;模型构建&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;从sklearn 朴素贝叶斯中导入多维贝叶斯&lt;/li&gt;
&lt;li&gt;朴素贝叶斯通常用来处理文本分类垃圾短信，速度飞快，效果一般都不会差很多&lt;/li&gt;
&lt;li&gt;MultinomialNB类可以选择默认参数，如果模型预测能力不符合要求，可以适当调整&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.naive_bayes import MultinomialNB
nb=MultinomialNB()  &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.pipeline import make_pipeline # 导入make_pipeline方法
pipe=make_pipeline(vect,nb)
pipe.steps #  查看pipeline的步骤（与pipeline相似）&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[('countvectorizer',
  CountVectorizer(analyzer='word', binary=False, decode_error='strict',
          dtype=&amp;lt;class 'numpy.int64'&amp;gt;, encoding='utf-8', input='content',
          lowercase=True, max_df=1.0, max_features=None, min_df=1,
          ngram_range=(1, 1), preprocessor=None,
          stop_words=frozenset({'', '范围', '但愿', 'vs', '为', '过去', '集中', '这般', '孰知', '认为', '论', '36', '前后', '每年', '长期以来', 'our', '要不', '使用', '好象', 'such', '不但', '一下', 'how', '召开', '6', '全体', '严格', '除开', 'get', '可好', '毕竟', 'but', '如前所述', '满足', 'your', 'keeps', '只', '大抵', '己', 'concerning', &quot;they're&quot;, '再则', '有意的'...'reasonably', '绝对', '咧', '除此以外', '50', '得了', 'seeming', '只是', '背靠背', '弗', 'need', '其', '第二', '再者说'}),
          strip_accents=None, token_pattern='(?u)\\b[^\\d\\W]\\w+\\b',
          tokenizer=None, vocabulary=None)),
 ('multinomialnb', MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True))]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pipe.fit(X_train.cut_comment, y_train)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Pipeline(memory=None,
     steps=[('countvectorizer', CountVectorizer(analyzer='word', binary=False, decode_error='strict',
        dtype=&amp;lt;class 'numpy.int64'&amp;gt;, encoding='utf-8', input='content',
        lowercase=True, max_df=1.0, max_features=None, min_df=1,
        ngram_range=(1, 1), preprocessor=None,
        stop_words=...e, vocabulary=None)), ('multinomialnb', MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True))])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试集预测结果&quot;&gt;测试集预测结果&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_pred = pipe.predict(X_test.cut_comment) 
# 对测试集进行预测（其中包括了转化以及预测）&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 模型对于测试集的准确率
from sklearn import  metrics
metrics.accuracy_score(y_test,y_pred)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.82929936305732488&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 模型对于测试集的混淆矩阵
metrics.confusion_matrix(y_test,y_pred)
# 测试集中的预测结果：真阳性1231个，假阳性417个，假阴性98个，真阴性为2604个&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[177, 112],
       [ 22, 474]], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_confusion_matrix(conf,clas):
    import  matplotlib.pyplot as  plt
    fig,ax=plt.subplots(figsize=(2.5,2.5))
    ax.matshow(conf,cmap=plt.cm.Blues,alpha=0.3)
    tick_marks = np.arange(len(clas))
    plt.xticks(tick_marks,clas, rotation=45)
    plt.yticks(tick_marks, clas)
    for i in range(conf.shape[0]):
        for j in range(conf.shape[1]):
            ax.text(x=i,y=j,s=conf[i,j],
                   va='center',
                   ha='center')
    plt.xlabel(&quot;predict_label&quot;)
    plt.ylabel(&quot;true label&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;conf=metrics.confusion_matrix(y_test,y_pred)
class_names=np.array(['0','1'])
get_confusion_matrix(np.array(conf),clas=class_names)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9l64amzrj208807vq2x.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对整个数据集进行预测分类&quot;&gt;对整个数据集进行预测分类&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_pred_all = pipe.predict(X['cut_comment'])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.accuracy_score(y,y_pred_all)
# 对于整个样本集的预测正确率，整个数据集的准确率高于测试集，说明有些过拟合
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.85659655831739967&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.confusion_matrix(y,y_pred_all)
#  真个数据集的混淆矩阵&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[ 801,  369],
       [  81, 1887]], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y.value_counts()
# 初始样本中 正类与负类的数量&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1    1968
0    1170
Name: sentiment, dtype: int64&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.f1_score(y_true=y,y_pred=y_pred_all)
# f1_score 评价模型对于真个数据集&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.89346590909090906&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.recall_score(y, y_pred_all)
# 检出率，也就是正类总样本检出的比例   真正/假阴+真正&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.95884146341463417&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.precision_score(y, y_pred_all)
#  准确率，  检测出的来正类中真正类的比例  真正/假阳+真正&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.83643617021276595&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(metrics.classification_report(y, y_pred_all))
# 分类报告&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;             precision    recall  f1-score   support

      0       0.91      0.68      0.78      1170
      1       0.84      0.96      0.89      1968

avg / total       0.86      0.86      0.85      3138&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 14 Aug 2018 14:34:00 +0000</pubDate>
<dc:creator>多一点</dc:creator>
<og:description>美团店铺评价语言处理以及分类（NLP） 上两篇博客中介绍了美团店铺的订单信息以及数据分析以及可视化 其中还有一部分评论文本信息并没有提及到，自然也就有了这篇 主要用到的包有jieba，sklearn，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onemorepoint/p/9478429.html</dc:identifier>
</item>
<item>
<title>Tomcat类加载架构 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9478337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9478337.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;　　主流的Java Web服务器（Tomcat、Jetty、WebLogic、WebSphere等）都有多个自定义的类加载器以及具备的类加载优势，本篇博文主要是通过以Tomcat为例简单认识Java Web服务器具有的特点、以及自定义类加载器是如何实现的。此外，&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本篇博文主要是根据Tomcat 5.x类加载架构编写的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;主要参考资料《深入理解Java虚拟机》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;1、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Web服务器需要解决的问题&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　一个功能健全的&lt;/span&gt;Web&lt;span&gt;服务器，都需要解决如下几个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　（1）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同一个服务器上的两个&lt;/span&gt;Web&lt;span&gt;程序所使用的&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;类库实现相互独立隔离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;span&gt;不能一个类库在同一个服务器上只有一份却被多个程序使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;（2）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同一个服务器上的两个&lt;/span&gt;Web&lt;span&gt;应用程序所使用的&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;类库可以被共享&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;span&gt;如果不能共享的话，虚拟机内部的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Method Area &lt;span&gt;可能会出现过度膨胀现象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务器的类库要与&lt;/span&gt;Web&lt;span&gt;应用程序的类库相互隔离，互不影响（即服务器不收&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;程序的影响）&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span&gt;很多服务器可能是用&lt;/span&gt;Java&lt;span&gt;来实现，自然就得使用一些只属于自己的类库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;（4）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;支持&lt;/span&gt;JSP&lt;span&gt;的热替换（&lt;/span&gt;&lt;span&gt;HotSwap&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;span&gt;大部分主流服务器（WebLogic除外）修改&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;JSP文件都&lt;/span&gt;&lt;span&gt;不需要重启服务器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　试想一下，如果上述的4点中任何一点不能满足，特别是（1）-（3）点，那么整个Java Web服务器都是“混乱”的，或者说是不健全的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、Tomcat类库存放目录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　既然要满足以上四点基本要求，那么当部署一个Web应用时，一个Classpath路径目录是无法满足需求的，通常会&lt;span&gt;提供多个Classpath（一般以classes/lib命名）路径目录&lt;/span&gt;，&lt;span&gt;而&lt;span&gt;目录中都会有一个相应的自定义类加载器去加载里面的Java&lt;/span&gt;&lt;span&gt;&lt;span&gt;类&lt;/span&gt;。在Tomcat中就有三组目录，分别是：/common/*、/server/*、/shared/*；&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　但值得强调的是&lt;span&gt;在Tomcat 6.x之后这三组目录就不存在了，只有一个总的/lib目录，其他都需要进入配置文件需要时单独配置&lt;/span&gt;。所以这里介绍的目录未必能在tomcat安装目录下找到，不过其用意都是一样的；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;span&gt;　&lt;strong&gt;（1）&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;/common/*&lt;/span&gt;&lt;span&gt;：实际创建的时候为&lt;/span&gt;&lt;span&gt;/common/lib/&lt;/span&gt;&lt;span&gt;目录&lt;/span&gt;&lt;span&gt;，可以被&lt;/span&gt;Tomcat&lt;span&gt;与所有的&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;应用共享的类库都在里面；&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　但是在&lt;/span&gt;Tomcat 6&lt;span&gt;之后&lt;/span&gt;&lt;span&gt;/common/lib/&lt;/span&gt;&lt;span&gt;目录被废弃，现在默认的是在&lt;/span&gt;&lt;span&gt;/lib/&lt;/span&gt;&lt;span&gt;下，实际上是将&lt;/span&gt;&lt;span&gt;/common&lt;/span&gt;、&lt;span&gt;/server、/shared&lt;/span&gt;&lt;span&gt;三个目录默认合并到一个&lt;/span&gt;&lt;span&gt;/lib&lt;/span&gt;&lt;span&gt;目录下。如果不满足具体的业务需求的话，可以在&lt;/span&gt;conf/catalina.properties&lt;span&gt;中设置&lt;/span&gt;server.loader&lt;span&gt;与&lt;/span&gt;shared.loader&lt;span&gt;。&lt;/span&gt;&lt;span&gt;打开&lt;/span&gt;conf/catalina.properties&lt;span&gt;可以看到：无论是&lt;/span&gt;${catalina.base}&lt;span&gt;，还是&lt;/span&gt;&quot;${catalina.home}&lt;span&gt;，都会去找&lt;/span&gt;/lib/&lt;span&gt;目录，指定加载的加载器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213344915-421723089.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　CATALINA_BASE&lt;span&gt;：是实例配置位置，也就是一个&lt;span&gt;tomcat&lt;span&gt;可以配置多个实例，实例里面有自己的配置；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;span&gt;CATALINA_HOME&lt;span&gt;：是&lt;span&gt;tomcat&lt;span&gt;安装位置；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　common.loader、server.loader、shared.loade&lt;span&gt;：表示&lt;span&gt;tomcat&lt;span&gt;指定自定义的&lt;span&gt;三个加载器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213532558-2023634130.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213459242-107098713.png&quot; alt=&quot;&quot;/&gt;　　　　　 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213443088-1268129577.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　（2）&lt;/span&gt;/server/*&lt;span&gt;：&lt;/span&gt;&lt;span&gt;实际创建的时候为&lt;/span&gt;/server/lib&lt;span&gt;目录，只能被&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;使用的类库。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　（3）&lt;/span&gt;/shared/*&lt;span&gt;：&lt;/span&gt;&lt;span&gt;实际创建的时候为&lt;/span&gt;/shared/lib&lt;span&gt;目录，可以被所有的&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;应用程序共享使用，但是对&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;是不可见的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　（4）&lt;/span&gt;/webapps(wtswebapps)/project/WEB-INF/*&lt;span&gt;：实际为&lt;/span&gt;&lt;span&gt;/WebApp/project/WEB-INF/lib&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;Project&lt;/span&gt;&lt;span&gt;&lt;span&gt;独享有的类库&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3、Tomcat自定义加载器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;Tomcat&lt;span&gt;自定义的类加载器主要有：&lt;/span&gt;&lt;span&gt;ComnonClassLoader&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;CatalinaClassLoader&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;WebAppClassLoader&lt;/span&gt;&lt;span&gt;四个类加载器。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（1）ComnonClassLoader&lt;span&gt;：加载&lt;/span&gt;/common/*&lt;span&gt;目录下的类，但是上述可知现在的指定加载都会在&lt;/span&gt;&lt;span&gt;Catalina.properties&lt;/span&gt;&lt;span&gt;中配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（2）CatalinaClassLoader&lt;span&gt;：加载&lt;/span&gt;&lt;span&gt;/server/*&lt;/span&gt;&lt;span&gt;目录下的类，同理现在在&lt;/span&gt;Catalina.properties&lt;span&gt;中指定配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（3）SharedClassLoader&lt;span&gt;：加载&lt;/span&gt;&lt;span&gt;/shared/*&lt;/span&gt;&lt;span&gt;目录下的类，同理现在在&lt;/span&gt;Catalina.properties&lt;span&gt;中指定配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（4）WebAppClassLoader&lt;span&gt;：加载&lt;/span&gt;&lt;span&gt;/webapps(wtswebapps)/project/WEB-INF/*&lt;/span&gt;&lt;span&gt;目录下项目&lt;/span&gt;&lt;span&gt;lib&lt;/span&gt;&lt;span&gt;中的类。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; 　　&lt;span&gt;结合之前三个类加载器（&lt;/span&gt;BootstrapClassLoader&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ExtensionClassLoader&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ApplicationLoader&lt;/span&gt;&lt;span&gt;）与&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;自定义的四个加载器组合成的委派关系（&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;服务器的类加载机构）如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814215919494-1270345135.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　    &lt;span&gt;（注：其中JasperLoader为Jsp类加载器，JSP文件编译后为Class文件，需要加载）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　通过此关系图我们可以得到如下两点：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　（1）&lt;span&gt;&lt;strong&gt;CatalinaClassLoader&lt;span&gt;与&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;span&gt;是相互隔离独立的；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　（2）&lt;span&gt;&lt;strong&gt;WebAppClassLoader&lt;span&gt;可以使用&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;加载类&lt;/strong&gt;&lt;/span&gt;，同理&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;WebAppClassLoader&lt;/span&gt;&lt;span&gt;可以代替&lt;/span&gt;&lt;span&gt;JspClassLoader&lt;/span&gt;&lt;span&gt;加载类，&lt;/span&gt;&lt;span&gt;CommonClassLoader&lt;/span&gt;&lt;span&gt;加载的类可以被&lt;/span&gt;&lt;span&gt;CatalinaClassLoader&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;使用&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　同时需要注意还有以下两点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 14 Aug 2018 14:18:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 主流的Java Web服务器（Tomcat、Jetty、WebLogic、WebSphere等）都有多个自定义的类加载器以及具备的类加载优势，本篇博文主要是通过以Tomcat为例简单认识Java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9478337.html</dc:identifier>
</item>
</channel>
</rss>