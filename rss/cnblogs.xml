<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>网络通信之检测远端连接是否断开连接 - 大雨如注</title>
<link>http://www.cnblogs.com/loveyoumi/p/9675023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loveyoumi/p/9675023.html</guid>
<description>&lt;p&gt;&lt;strong&gt;判断对方是否断开连接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、方法层面的实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1，使用输入流的read方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　输入流的read(byte[] ,int ,int) 方法，表示从当前的通道中读取数据，具体读取到的数据有返回的int值决定；这里的返回值和抛出的异常很重要，如果抛出IOException异常，很明显连接已经断开；&lt;/p&gt;
&lt;p&gt;　　　　返回值说明：&lt;/p&gt;
&lt;p&gt;　　　　针对于基于tcp/ip协议的socket连接说明：&lt;/p&gt;
&lt;p&gt;　　　　如果没有设置socket的soTimeout属性，那么该方法将是一个阻塞方法，可以通过设置socket的soTimeout属性，让read方法退出。&lt;/p&gt;
&lt;p&gt;　　　　注意：read方法如果timeout将以抛出socketTimeoutException异常；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;　　客户端：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　如果对方断开连接，客户端的read方法将返回-1；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;　　服务器端：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　如果对方断开连接，服务器端的read方法将抛出IOException异常；&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　提示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　建议使用这种方式，netty底层源码就是使用的这种方式实现的；&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　2，使用socket 的sendUrgentData(int) ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;&lt;strong&gt;　注意：不建议使用此种方式，因为使用该方式有很多不可预测的情况；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　通常情况是：接收端没有开启socket的SO_OOBINLINE属性，那么使用sendUrgentData(int)测试连接时，在发送17次（windows测试数据）时会发生异常；而如果接收端开启socket的SO_OOBINLINE属性，那么接收端就会收到发送的数据，从而导致真实数据的混乱；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;　　socket sendUrgentData(int)  17次异常说明；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　对于17次发送异常，在一片文章中有看到，说：如果接收端没有开启socket的SO_OOBINLINE的属性（当然这也是想把该方法用于心跳检测的必须条件），那么接收端将抛弃接收到的这个数据，也不会向发送端返回对应的ack值；但是，发送端却会占用一个tcp/ip的发送窗口，一直等待接收端的返回，这里肯定等待不到，就会一直占用窗口；而一个tcp/ip基于平台只有8或16个窗口，于是，在第17次发送数据时抛出异常了；&lt;/p&gt;
&lt;p&gt;　　　　意思，作者是懂的，但真正的底层实现却不太清楚；提供tcp/ip窗口详解连接：&lt;/p&gt;
&lt;p&gt;　　　　https://technet.microsoft.com/zh-cn/library/2007.01.cableguy.aspx&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、协议层面的实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过自定义的心跳机制，这也是最常用的方式之一；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义了一个抽象的通道处理类，提供远端断开连接的判断；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.SocketTimeoutException;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 提供基于tcp/ip协议连接的断开判断实现
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; pineapple food
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractChannelHandler {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 连接关闭标志
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; closed;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尝试从输入流中读取数据，具体读取数据的数量，依据返回的int值作为依据；
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; buf 缓存区
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 起始地址
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; length 读取长度
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 值大于零，表示读取到返回值表示大小的数据；等于0： 表示未读取到数据； 等于-1：表示远端已关闭连接；
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryReadMsg(&lt;span&gt;byte&lt;/span&gt;[] buf ,&lt;span&gt;int&lt;/span&gt; index ,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = 0&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;=&lt;span&gt; inputStream().read(buf, index, length);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SocketTimeoutException e) {
            result &lt;/span&gt;= 0&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            result &lt;/span&gt;= -1&lt;span&gt;;
            setClosed();
        }
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setClosed() {
        closed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 连接是否关闭
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; false 未关闭； true 关闭
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isClosed() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; closed;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向远端连接发送心跳数据；
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendHeartbeat() {}
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过协议层的心跳发送，判断远端连接是否关闭；
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isClosedBySendHeartbeat() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置socket 输入流的读取超时时间，用于设置{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; tryReadMsg(byte[] ,int ,int)} 方法的timeout时间
     * 否则将一直阻塞；
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSoTimeout();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回与该通道相关联的输入流；
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; InputStream inputStream() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通道处理类，继承与上述抽象类，方便断开连接的判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.SocketException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ChannelHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractChannelHandler{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Socket socket;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InputStream is;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelHandler(Socket socket) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.socket =&lt;span&gt; socket;
        
        setSoTimeout();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; InputStream inputStream() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(is == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            is &lt;/span&gt;=&lt;span&gt; socket.getInputStream();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; is;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSoTimeout() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            socket.setSoTimeout(&lt;/span&gt;1000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SocketException e) {
            
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;demo，亲测可用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        String host &lt;/span&gt;= &quot;127.0.0.1&quot;&lt;span&gt;;
         
        Socket socket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket();
        socket.connect(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InetSocketAddress(host, 6800&lt;span&gt;));    
        
        ChannelHandler channelHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelHandler(socket);
        
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[20&lt;span&gt;];
        
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = channelHandler.tryReadMsg(b, 0&lt;span&gt;, b.length);
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n == -1 ||&lt;span&gt; channelHandler.isClosed()) {
                System.out.println(&lt;/span&gt;&quot;___________ connection is closed&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[n];
                System.arraycopy(b, &lt;/span&gt;0, data, 0&lt;span&gt;, n);
                System.out.println(n &lt;/span&gt;+ &quot; : receive data = &quot;+&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(data));
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 19 Sep 2018 07:54:00 +0000</pubDate>
<dc:creator>大雨如注</dc:creator>
<og:description>判断对方是否断开连接： 一、方法层面的实现： 1，使用输入流的read方法： 输入流的read(byte[] ,int ,int) 方法，表示从当前的通道中读取数据，具体读取到的数据有返回的int值决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loveyoumi/p/9675023.html</dc:identifier>
</item>
<item>
<title>CSS Grid 读书笔记 - 糊糊糊糊糊了</title>
<link>http://www.cnblogs.com/rynxiao/p/9674944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rynxiao/p/9674944.html</guid>
<description>&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout&quot;&gt;MDN&lt;/a&gt;上的解释是这样的&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;CSS Grid Layout excels at dividing a page into major regions or defining the relationship in terms of size, position, and layer, between parts of a control built from HTML primitives.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，下面一段话摘自&lt;a href=&quot;https://css-tricks.com/snippets/css/complete-guide-grid/&quot;&gt;A Complete Guide to Grid&lt;/a&gt;，对于CSS Grid会有更加清楚地释义&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;CSS Grid Layout (aka &quot;Grid&quot;), is a two-dimensional grid-based layout system that aims to do nothing less than completely change the way we design grid-based user interfaces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CSS Grid 是一个二维的布局系统&lt;/li&gt;
&lt;li&gt;CSS Grid 相比传统布局在页面整体划分布局上更加出色&lt;/li&gt;
&lt;li&gt;CSS Grid 并不是只能单独使用，依然可以搭配&lt;code&gt;Flexbox&lt;/code&gt;以及传统定位布局一起使用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;兼容性&quot;&gt;兼容性&lt;/h2&gt;
&lt;p&gt;摘自&lt;a href=&quot;https://caniuse.com/#feat=css-grid&quot;&gt;Can I Use&lt;/a&gt;中对&lt;code&gt;CSS Grid&lt;/code&gt;的兼容性分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153254224-1230445688.png&quot; alt=&quot;compatibility&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出浏览器的兼容率整体达到84.16%，并且都是无需带前缀的。&lt;/p&gt;
&lt;h2 id=&quot;基本概念-1&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;网格是一组相交的水平线和垂直线，它定义了网格的列和行。我们可以将网格元素放置在与这些行和列相关的位置上。&lt;/p&gt;
&lt;h3 id=&quot;grid-container-网格容器&quot;&gt;Grid Container (网格容器)&lt;/h3&gt;
&lt;p&gt;在一个元素上应用了&lt;code&gt;display: grid;&lt;/code&gt;或者&lt;code&gt;display: inline-grid;&lt;/code&gt;那么就创建了一个网格容器，它下面的直接子元素都会成为网格元素，例如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
.wrapper {
  display: grid;
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;wrapper&quot;&amp;gt;
  &amp;lt;div class=&quot;custom&quot;&amp;gt;One&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom&quot;&amp;gt;Two
    &amp;lt;p&amp;gt;I have some more content in.&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;This makes me taller than 100 pixels.&amp;lt;/p&amp;gt;    
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom&quot;&amp;gt;Three&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom&quot;&amp;gt;Four&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom&quot;&amp;gt;Five&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153329892-372181851.png&quot; alt=&quot;normal-grid&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从网页的基本表现看，和平常的布局没有什么差别，Mac OSX 【alt + command + I】，Windows 【F11】打开网页检查器即可看出网格布局。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153405282-1081893658.png&quot; alt=&quot;inspector-grid&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grid-tracks-网格轨迹&quot;&gt;Grid Tracks (网格轨迹)&lt;/h3&gt;
&lt;p&gt;从字面上的意译来看还是比较绕口，但是我换一种说法你可能就会明白了。可以把&lt;code&gt;tracks&lt;/code&gt;看做是table中的行和列就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153438468-47543978.png&quot; alt=&quot;grid-track&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义一个网格中的行和列的数量分别使用&lt;code&gt;grid-template-rows&lt;/code&gt;和&lt;code&gt;grid-template-columns&lt;/code&gt;来确定这个表格会有多少行以及多少列。例如：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  display: grid;
  grid-template-rows: 100px 50px 100px;
  grid-template-columns: 100px 100px 100px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码写出了一个&lt;code&gt;3 x 3&lt;/code&gt;的网格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153514715-1023854226.png&quot; alt=&quot;sure-grid&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在图中可以看出网格的数量，其中的子元素会根据这些网格的数量自动填充。如果事先不知道要划分多少行，可以使用只使用&lt;code&gt;grid-template-columns&lt;/code&gt;来确定多少列，行数会根据有多少子item来自动计算，例如下面的：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  display: grid;
  grid-template-columns: 200px 200px 200px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153555638-1117872634.png&quot; alt=&quot;single-col&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5个元素如果是划分3列，那么就应该会有两行。&lt;/p&gt;
&lt;h4 id=&quot;fr&quot;&gt;fr&lt;/h4&gt;
&lt;p&gt;如果想要均分容器的宽度，那么可以使用新引入的单位&lt;code&gt;fr&lt;/code&gt;，新的&lt;code&gt;fr单位&lt;/code&gt;代表网格容器中可用空间的一等份。例如：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;repeat&quot;&gt;repeat()&lt;/h4&gt;
&lt;p&gt;可以使用&lt;code&gt;repeat()&lt;/code&gt;函数来标记轨道重复使用的部分，例如上面的样式就可以写成：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;每行高度&quot;&gt;每行高度&lt;/h4&gt;
&lt;p&gt;如果想确定使用每行高度，可以使用&lt;code&gt;grid-auto-rows: 100px;&lt;/code&gt;来确定每行只有100px&lt;/p&gt;
&lt;h4 id=&quot;minmax&quot;&gt;minmax()&lt;/h4&gt;
&lt;p&gt;如果想让每行的高度随着内容自动填充，那么可以使用&lt;code&gt;minmax()&lt;/code&gt;来确定最小值与最大值，例如：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: minmax(100px, auto);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的样式规定了一个3列布局，每行的高度最少为100px的网格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153628358-1018652374.png&quot; alt=&quot;auto-rows&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grid-line-网格线&quot;&gt;Grid Line (网格线)&lt;/h3&gt;
&lt;p&gt;网格线用来构建整个网格，包括水平的和竖直的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153653702-1112599880.png&quot; alt=&quot;grid-line&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一个网格被构建出来，网格线就会被默认地有一个标识，看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153714534-592104397.png&quot; alt=&quot;grid-numbers&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标识的线可以是正向也可以是逆向的，例如第一行的线的标识就是[1|-4]，那么线标识有什么用？线标识主要用来确定一个子元素要占有的面积，也成为&lt;code&gt;Grid Area&lt;/code&gt;，例如下面的代码：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.one {
  grid-column-start: 1;
  grid-column-end: 4;
  grid-row-start: 1;
  grid-row-end: 3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153738403-1461471911.png&quot; alt=&quot;line&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;给线命名&quot;&gt;给线命名&lt;/h4&gt;
&lt;p&gt;默认的线的标识都是用数字来表示的，当然也可以给线来命名，具体如下：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];
  grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153758240-1509824453.png&quot; alt=&quot;grid-names&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，第一列的第一根线被命名成了&lt;code&gt;first&lt;/code&gt;，那么我们就可以将之前的写法稍微改一下了：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.one {
  grid-column-start: first;
  grid-column-end: col4-start;
  grid-row-start: 1;
  grid-row-end: 3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于更多的线的命名使用方法，可以参看&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Layout_using_Named_Grid_Lines&quot;&gt;Naming lines when defining a grid&lt;/a&gt;，这里只是简单的介绍&lt;/p&gt;
&lt;h3 id=&quot;grid-cell-网格单元&quot;&gt;Grid Cell (网格单元)&lt;/h3&gt;
&lt;p&gt;可以简单理解为一个&lt;code&gt;table&lt;/code&gt;中的一个单元格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153821177-1361203706.png&quot; alt=&quot;grid-cell&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grid-area-网格面积&quot;&gt;Grid Area (网格面积)&lt;/h3&gt;
&lt;p&gt;可以通过规定一个&lt;code&gt;item&lt;/code&gt;的起始行和起始列来规定一个area，注意：area必须为一个 规则的举行，而不能为一个类似于&lt;code&gt;L&lt;/code&gt;形状的图形&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153844688-627075015.png&quot; alt=&quot;grid-area&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过行和列标识来确定一个面积，例如：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: minmax(100px, auto);
}
.one {
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 1;
  grid-row-end: 3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码就划定了一个两行两列的区域，上面的写法可以简写为：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.one {
  grid-column: 1 / 3;
  grid-row: 1 / 3;
  
  /* 这种写法对应： */
  grid-column: [grid-column-start] / [grid-column-end];
  grid-row: [grid-row-start] / [grid-row-end];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者使用&lt;code&gt;grid-area&lt;/code&gt;，&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.one { 
  grid-area: 1 / 1 / 3 / 3;
  
  /* 这种写法分别对应： */
  grid-area: [grid-row-start] / [grid-column-start] / [grid-row-end] / [grid-column-end];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以配合&lt;code&gt;grid-template-areas&lt;/code&gt;来提前划分区域，例如：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: minmax(100px, auto);
  grid-template-areas: 
   &quot;header header header&quot;
   &quot;siderbar main main&quot;
   &quot;footer footer footer&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的样式中，规定了一个&lt;code&gt;3 x 3&lt;/code&gt;的网格，并且划分了区域，第一行为&lt;code&gt;header&lt;/code&gt;，第二行为左侧为&lt;code&gt;siderbar&lt;/code&gt;，右侧为&lt;code&gt;main&lt;/code&gt;，第三行为&lt;code&gt;footer&lt;/code&gt;，那么剩余的工作就是制定子元素对应的区域即可，例如：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.header {
  grid-area: header;
}
.siderbar {
  grid-area: siderbar;    
}
.main {
  grid-area: main;    
}
.footer {
  grid-area: footer;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的网页文件为：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;
  &amp;lt;div class=&quot;custom header&quot;&amp;gt;header&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom siderbar&quot;&amp;gt;siderbar&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom main&quot;&amp;gt;main&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom footer&quot;&amp;gt;footer&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919153919349-338307855.png&quot; alt=&quot;template-areas&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grid-gutters-网格间距&quot;&gt;Grid Gutters (网格间距)&lt;/h3&gt;
&lt;p&gt;分为行间距和列间距，类似于&lt;code&gt;table&lt;/code&gt;中的&lt;code&gt;colspan&lt;/code&gt;和&lt;code&gt;rowspan&lt;/code&gt;，具体例子如下：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: minmax(100px, auto);
  grid-gap: 10px;
  
  /* 这里的grid-gap相当于： */
  grid-column-gap: 10px;
  grid-row-gap: 10px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上一个例子中，我也设置了&lt;code&gt;10px&lt;/code&gt;的间距，可以从图中看出来。&lt;/p&gt;
&lt;h3 id=&quot;grid-z-index&quot;&gt;Grid z-index&lt;/h3&gt;
&lt;p&gt;类似于&lt;code&gt;position: absolute;&lt;/code&gt;绝对定位之后的层级，后面渲染的item会覆盖前面的，因此下例中的item为&lt;code&gt;Two&lt;/code&gt;的会覆盖在&lt;code&gt;One&lt;/code&gt;上&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.z-index-1 {
  grid-column: 1 / 3;
  grid-row: 1;
  background-color: aliceblue;
}
.z-index-2 {
  grid-column: 2 / 4;
  grid-row: 1 / 3;
  background-color: antiquewhite;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154000730-939018796.png&quot; alt=&quot;z-index-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调整item1的index之后&lt;code&gt;z-index: 2;&lt;/code&gt;，会看到item1会覆盖在item2上面&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;custom z-index-1&quot; style=&quot;z-index: 2;&quot;&amp;gt;One&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;custom z-index-2&quot; style=&quot;z-index: 1;&quot;&amp;gt;Two&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154025131-1228120668.png&quot; alt=&quot;z-index-2&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;网格布局中的对齐&quot;&gt;网格布局中的对齐&lt;/h2&gt;
&lt;p&gt;如果熟悉&lt;code&gt;flex&lt;/code&gt;，那么一定会知道flex中的布局，相同的，在&lt;code&gt;grid&lt;/code&gt;布局中也有相应的布局&lt;/p&gt;
&lt;h3 id=&quot;网格布局的两条轴线&quot;&gt;网格布局的两条轴线&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;When working with grid layout you have two axes available to align things against – &lt;code&gt;the block axis&lt;/code&gt; and &lt;code&gt;the inline axis&lt;/code&gt;. The block axis is the axis upon which blocks are laid out in block layout. If you have two paragraphs on your page they display one below the other, so it is this direction we describe as the block axis.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;块方向的列轴&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154051034-652550284.png&quot; alt=&quot;block-axis&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文字方向的行轴&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154114568-303518124.png&quot; alt=&quot;inline-axis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上的文字以及图片均摘自&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Box_Alignment_in_CSS_Grid_Layout&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;对齐列项目&quot;&gt;对齐列项目&lt;/h3&gt;
&lt;p&gt;对齐列项目主要的CSS声明有两个：&lt;code&gt;align-items&lt;/code&gt;以及&lt;code&gt;align-self&lt;/code&gt;，&lt;code&gt;align-items&lt;/code&gt;用于所有item的设置，&lt;code&gt;align-self&lt;/code&gt;可以单独进行自定义。这两个声明可取的属性值有以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;auto&lt;/li&gt;
&lt;li&gt;normal&lt;/li&gt;
&lt;li&gt;start&lt;/li&gt;
&lt;li&gt;end&lt;/li&gt;
&lt;li&gt;center&lt;/li&gt;
&lt;li&gt;stretch&lt;/li&gt;
&lt;li&gt;baseline&lt;/li&gt;
&lt;li&gt;first baseline&lt;/li&gt;
&lt;li&gt;last baseline&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们用一个栗子分别说明如下(栗子摘自MDN)：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
.wrapper {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-gap: 10px;
  grid-auto-rows: 100px;
  grid-template-areas: 
    &quot;a a a a b b b b&quot;
    &quot;a a a a b b b b&quot;
    &quot;c c c c d d d d&quot;
    &quot;c c c c d d d d&quot;;
}
.item1 {
  grid-area: a;
  background-color: aqua;
}
.item2 {
  grid-area: b;
  background-color: aqua;
}
.item3 {
  grid-area: c;
  background-color: aqua;
}
.item4 {
  grid-area: d;
  background-color: aqua;
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;wrapper&quot;&amp;gt;
  &amp;lt;div class=&quot;custom item1&quot;&amp;gt;Item 1&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom item2&quot;&amp;gt;Item 2&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom item3&quot;&amp;gt;Item 3&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;custom item4&quot;&amp;gt;Item 4&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义了一个&lt;code&gt;8 x 4&lt;/code&gt;列的网格，其中划分为均匀的四个区域，分别用&lt;code&gt;item[1,2,3,4]&lt;/code&gt;来进行填充，默认的对齐方式为&lt;code&gt;stretch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154144646-1045064666.png&quot; alt=&quot;box-alignment-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以通过几个&lt;code&gt;select&lt;/code&gt;来控制对齐方式，分别通过控制整体和单个item的对齐&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154206514-961208687.png&quot; alt=&quot;box-alignment&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;相对于容器的列对齐&quot;&gt;相对于容器的列对齐&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;align-content&lt;/code&gt;这个属性声明来决定整个网格在容器中的列方向的布局，可选的值如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;normal&lt;/li&gt;
&lt;li&gt;start&lt;/li&gt;
&lt;li&gt;end&lt;/li&gt;
&lt;li&gt;center&lt;/li&gt;
&lt;li&gt;stretch&lt;/li&gt;
&lt;li&gt;space-around&lt;/li&gt;
&lt;li&gt;space-between&lt;/li&gt;
&lt;li&gt;space-evenly&lt;/li&gt;
&lt;li&gt;baseline&lt;/li&gt;
&lt;li&gt;first baseline&lt;/li&gt;
&lt;li&gt;last baseline&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154229814-527732203.png&quot; alt=&quot;align-content&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到图中，当选择了&lt;code&gt;align-content: end&lt;/code&gt;的时候，整个网格就会在容器的下方对齐。&lt;/p&gt;
&lt;p&gt;更多内容请参看&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Box_Alignment_in_CSS_Grid_Layout&quot;&gt;MDN CSS_Grid_Layout&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;grid-布局和其他布局的关系&quot;&gt;Grid 布局和其他布局的关系&lt;/h2&gt;
&lt;h3 id=&quot;grid-和-flex&quot;&gt;Grid 和 Flex&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The basic difference between CSS Grid Layout and CSS Flexbox Layout is that flexbox was designed for layout in one dimension - either a row or a column. Grid was designed for two-dimensional layout - rows, and columns at the same time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Grid布局和Flex布局最大的不同点就是：Grid布局是二维布局，针对行和列的布局，而Flex布局为一维布局，只针对行和列的当行布局。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;: 这两种布局并不冲突，可以搭配使用。可以在整体布局上采用&lt;code&gt;grid&lt;/code&gt;布局，而细节处理可以使用&lt;code&gt;flex&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面看一个栗子，来看看这两种布局之间有什么不同（栗子来源MDN）:&lt;/p&gt;
&lt;h3 id=&quot;编写一个自动换行适应的布局&quot;&gt;编写一个自动换行适应的布局&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Flex方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
  .flex-wrapper {
    display: flex;
    flex-wrap: wrap;
  }
  .flex-wrapper &amp;gt; div {
    flex: 1 1 200px;
  }
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;flex-wrapper&quot;&amp;gt;
  &amp;lt;div&amp;gt;One&amp;lt;/div&amp;gt; 
  &amp;lt;div&amp;gt;Two&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;Three&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;Four&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;Five&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Grid 方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
  .grid-wrapper {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;flex-wrap: wrap;&lt;/code&gt;来限定如果一行不足就自动换行。使用&lt;code&gt;auto-fill&lt;/code&gt;来根据容器宽度决定会有多少列，并且使用&lt;code&gt;minmax()&lt;/code&gt;函数来确定最小为200px，最大为容器宽度来自适应。&lt;/p&gt;
&lt;p&gt;如果屏幕上有很多剩余的空间，&lt;code&gt;flex&lt;/code&gt;布局会均分成5列，而&lt;code&gt;grid&lt;/code&gt;布局则会始终为3列，并且余下的两个item也长度也 相同，而如果屏幕宽度调整为小于200时，&lt;code&gt;flex&lt;/code&gt;布局会弹性地变为1列，但是&lt;code&gt;grid&lt;/code&gt;布局如果没有使用&lt;code&gt;auto-fill&lt;/code&gt;时，会始终为设置的列数。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;grid&lt;/code&gt;布局和&lt;code&gt;flex&lt;/code&gt;布局还有一点不同的是，在最开始的分配的时候&lt;code&gt;grid&lt;/code&gt;布局会优先划分布局，即会优先规定出屏幕中可以最大容忍出 多少个符合条件（这里是最小为200px， 最大为1fr）的item数量，然后依次填充。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154303475-711057444.png&quot; alt=&quot;flex-grid&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grid-和-绝对定位&quot;&gt;Grid 和 绝对定位&lt;/h3&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.positioned {
  grid-template-columns: repeat(4,1fr);
  grid-auto-rows: 200px;
  grid-gap: 20px;
  position: relative;
}
.box3 {
  grid-column-start: 2;
  grid-column-end: 4;
  grid-row-start: 1;
  grid-row-end: 3;
  position: absolute;
  top: 40px;
  left: 40px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681618/201809/681618-20180919154327705-1102733276.png&quot; alt=&quot;grid-position&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果父容器有定位标识&lt;code&gt;relative&lt;/code&gt; Or &lt;code&gt;absolute&lt;/code&gt;等，那么下面的子item会根据原始它们应该布局的位置定位，反之如果父容器没有 定位标识，那么应用了&lt;code&gt;position: absolute;&lt;/code&gt;会脱离&lt;code&gt;gird&lt;/code&gt;布局，并且按照CSS传统的方式布局。&lt;/p&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;h2 id=&quot;参考连接&quot;&gt;参考连接&lt;/h2&gt;
</description>
<pubDate>Wed, 19 Sep 2018 07:45:00 +0000</pubDate>
<dc:creator>糊糊糊糊糊了</dc:creator>
<og:description>基本概念</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rynxiao/p/9674944.html</dc:identifier>
</item>
<item>
<title>推荐六本前端开发必看的书籍 - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/books01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/books01.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;64.510628875111&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191097/201809/191097-20180919154559847-58373947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-javascript-&quot;&gt;第一本：《JavaScript 语言精粹(修订版)》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img.bookist.cc/FmtWRDlw43Po4j4GWmiuCN4VE5q_-w180&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我毕业后工作头一两年读的第一本 JavaScript 书就是《JavaScript 语言精粹》，当时完整地读了两篇，后来还时不时地会翻里面的重点看。对于前端刚工作的人和前端刚入门的人来说，需要反复阅读和理解。这本书可以深入理解 JavaScript 的特质，写出高质量的代码，适合有 JavaScript 语言基础的人学，不适合于作为零基础入门的教材。&lt;/p&gt;
&lt;h2 id=&quot;-javascript-&quot;&gt;第二本：《数据结构与算法 JavaScript 描述》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img.bookist.cc/FnlcqUVj3jfziinH7zd50uZ2l0s8-w180&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你专注前端开发，又想学习数据结构和算法，那么这本书是非常不错的选择，至少在中文书籍中，我还没有见到过一本比这本更好的用 JavaScript 描述的数据结构与算法书。&lt;/p&gt;
&lt;p&gt;其实这本书在实际工作中没有太大的实战性，就像很多人说的，实际工作中几乎用不到算法。但是，算法绝对是值得每一个程序员去学习的。学习算法是为了提高逻辑思维能力和解决问题的能力，这是每个公司都第一看重的能力。&lt;/p&gt;
&lt;p&gt;如果你发现你学的技术已经有了到了瓶颈的感觉，那么说明你需要学习算法了。就算为了给你工作加分，也应该学习算法。如果面试时让你写一个冒泡排序，你不会，那岂不是很尴尬。&lt;/p&gt;
&lt;p&gt;当然，这书讲的都是数据结构和算法基础知识，比如字典、集合、二叉树、排序算法等。但如果你已经有这基础，我觉得对于前端开发这份工作已经够了，如果你想学习机器学习或继续锻炼自己的逻辑思维能力，我推荐关注我的系列教程《算法》，也是基于 JavaScript 语言的。&lt;/p&gt;
&lt;h2 id=&quot;-css-&quot;&gt;第三本：《CSS 揭秘》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img.bookist.cc/Fp-vjWspYk9FyQmzzbyWYtC6ocor-w180&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这本书是一书很好的 CSS 实战性教程。每一节都是先给出一个“难题”，再给出一个或多个“方案”，并会作详细解释。掌握 CSS 的最好学习方法就是多练，这本书是中文 CSS 书籍中我个人最喜欢的一本。为什么它写的好。举个书中的例子：&lt;/p&gt;
&lt;p&gt;书中第二章第 1 节讲的是半透明边框，这个场景是很常见的，看起来很简单，就是设置 boder 属性而已，但默认情况下，背景会延伸到边框的区域下层，也就是说你即使设置了半透明，默认情况这个半透明边框是看不到的。具体解决方案我就不讲了，大家可以去看这本书。&lt;/p&gt;
&lt;h2 id=&quot;-javascript-3-&quot;&gt;第四本：《JavaScript 高级程序设计, 第 3 版》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img.bookist.cc/FvM6u3rv9m8ietMV4w6nAR5SGtww-w180&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这本书和《JavaScript 权威指南, 第 6 版》相比，我强烈推荐《JavaScript 高级程序设计》。如果你想正儿八经地系统性地学习一遍 JavaScript，那么这本书应该是最好的选择。而且我建议看完后可以画画重点，将来既可以作为参考用，对于面试也是能派上用场的。当然，如果你已经有一定基础了，不必每一章每一节都看，可以筛选着看。&lt;/p&gt;
&lt;p&gt;这本书算是基础类的了，如果你想对 JavaScript 有更深入更细的理解和掌握，特别是理解那些比较晦涩难懂的知识点，比如&lt;em&gt;this&lt;/em&gt;、&lt;em&gt;原型&lt;/em&gt;、&lt;em&gt;委托&lt;/em&gt;等，那就看看《你不知道的 JavaScript》这套书，它分为上、中、下三卷。&lt;/p&gt;
&lt;h2 id=&quot;-ecmascript-6-&quot;&gt;第五本：《ECMAScript 6 入门》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img.bookist.cc/Fq6M0ekU5ED4ddKy1HP26jXWEElU-w180&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这本书是阮一峰老师写的，而且是开源的，在线阅读地址是：&lt;a href=&quot;http://es6.ruanyifeng.com&quot;&gt;http://es6.ruanyifeng.com&lt;/a&gt;，讲的是 ES6 标准下的新语法，我个人觉得讲得很好，言简意赅。如果你用过 Vue、React 等前端框架，你就知道 ES6 标准的 JavaScript 语法无处不在。所以如果你还没学，或者学得不够全，那么我建议你看看这个教程。&lt;/p&gt;
&lt;h2 id=&quot;-javascript-&quot;&gt;第六本：《JavaScript 函数式编程》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img.bookist.cc/Fra2EP2cerllJyt6pB-9aMLuIcHC-w180&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数式编程是一种编程范式，它的优点是简洁易读，模块化，低耦合，适合并发编程等，很多前端大咖都推过函数式编程。这本对书函数式编程的相关概念和编程思想都讲的比较好也容易理解，从中你可以学习到纯函数、高阶函数、柯里化（Currying） 等知识。如果你用过 React，这一类知识肯定用得比较多，学好函数式编程也有助于你更好地理解 React 的设计思想。&lt;/p&gt;
&lt;p&gt;不过，有一点不好的就是，比如说柯里化，如果直接说 Currying 反而更容易理解，不是说这本书翻译得不好，很多术语用中文表达总觉得不是很恰当，我觉得如果你能阅读英文版的最好读英文版的。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;今天推荐的这些书，几乎网上都能下载到电子版，我的&lt;a href=&quot;https://bookist.cc/&quot; target=&quot;_blank&quot;&gt;书大师&lt;/a&gt;也都有收藏，喜欢的朋友可以去下载。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 19 Sep 2018 07:39:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>都是经典热闹的前端书籍，前端开发的朋友可以看看。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/books01.html</dc:identifier>
</item>
<item>
<title>RobotFramework - AppiumLibrary 之元素定位 - LeoZhanggg</title>
<link>http://www.cnblogs.com/leozhanggg/p/9670652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leozhanggg/p/9670652.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;一、介绍&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;AppiumLibrary 是 Robot Framework 的App测试库。&lt;/p&gt;
&lt;p&gt;它使用Appium 与Android 和 iOS应用程序进行通信，类似于Selenium WebDriver与Web浏览器的对话。&lt;/p&gt;
&lt;p&gt;AppiumLibrary是继承和引用appiumandroidlibrary，但重新实现使用appium 1.X技术，它完全支持Python 2.7，但对python 3.3+的支持仍然是实验性的。&lt;/p&gt;

&lt;div class=&quot;doc&quot; readability=&quot;10&quot;&gt;
&lt;h3&gt;二、定位控件&lt;/h3&gt;
&lt;p&gt;AppiumLibrary需要在应用程序中查找元素的所有关键字都使用参数locator。&lt;/p&gt;
&lt;p&gt;当提供locator值时，它将与特定元素类型的键属性进行匹配。支持的定位器(locator)有：&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;定位器&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;格式&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;identifier&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| identifier=my_element&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 @id 或 @name 属性&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;id&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| id=my_element&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 @id 属性&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;name&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| name=my_element&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 @name 属性&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| xpath=//UIATableView/UIATableCell/UIAButton&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 XPath&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;class&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| class=UIAPickerWheel&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 class name&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;accessibility_id&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| accessibility_id=t&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 辅助选项&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;android&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| android=new UiSelector().description('Apps')&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 Android UI Automator&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;ios&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| ios=.buttons().withName('Apps')&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 iOS UI Automation&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;css&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Click Element &lt;span class=&quot;name&quot;&gt;| css=.green_button&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;匹配 css in webview&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;











&lt;div class=&quot;doc&quot;&gt;
&lt;h3&gt; &lt;/h3&gt;

&lt;h3&gt;三、定位工具&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;1. Appium通过 uiautomatorviewer.bat工具来查看控件的属性，该工具位于Android SDK的Tools目录下。&lt;/p&gt;

&lt;div class=&quot;doc&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919110300561-525330236.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;2. 双击打开即可，为了方便起见，建议添加快捷方式到桌面。&lt;/p&gt;

&lt;div class=&quot;doc&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919114514082-443297996.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;3. 然后USB连接真机(安装手机驱动，授权连接) 或者打开AVD模拟机，点击获取详细布局。&lt;/p&gt;

&lt;div class=&quot;doc&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919120013754-1957219878.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div class=&quot;doc&quot; readability=&quot;44&quot;&gt;
&lt;h3&gt;四、定位元素&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.　identifier 定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 @id 或 @name 属性，分别对应 resource-id 和 text 属性。&lt;/p&gt;
&lt;p&gt;案例：点击计算器数字“ 9 ”，可以使用id定位，也可以使用name定位。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;identifier=com.android.calculator2:id/digit_9&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Click Element&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;identifier=9&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919125644697-487575355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.　id 定位&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;说明：匹配 @id 属性，对应 resource-id 属性。&lt;/p&gt;
&lt;p&gt;案例：点击计算器输入框，id可以指定也可以不指定，如果不指定策略，默认就是id定位。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;id=com.android.calculator2:id/formula&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;com.android.calculator2:id/formula&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919132352204-843412452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.　name 定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 @name 属性，对应 text 属性。&lt;/p&gt;
&lt;p&gt;案例：点击计算器数字“ 9 ”。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;name=9　　　　　　　　　　　　　　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919133257497-2000079372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.　xpath 定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 Xpath ，这也是功能最强大的一种定位方式，不过通常用于web自动化。&lt;/p&gt;
&lt;p&gt;案例：点击计算器数字“ 7 ”。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;xpath=//android.widget.Button[contains(@text,'7')]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919133310991-587513151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附加Xpath定位表达式说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919151026057-1841580084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;5.　class 定位&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 class name ，对应 class 属性，但通常class属性都不唯一。&lt;/p&gt;
&lt;p&gt;案例：点击计算器数字“ 6 ”。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;class=android.widget.Button　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919133318262-1054058370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;6.　accessibility_id 定位&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 辅助选项，这个方法属于Appium扩展的定位方法，主要就是content-desc属性。&lt;/p&gt;
&lt;p&gt;案例：点击计算器加号“ + ”。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;accessibility_id=plus　　　　　　　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919133323488-562510964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;7.　android 定位&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 Android UI Automator。&lt;/p&gt;
&lt;p&gt;案例：点击计算器加号“ + ”。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Click Element&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;android=new UiSelector().description(\&quot;plus\&quot;)&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1059616/201809/1059616-20180919133336493-610555788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;8.　css 定位&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 css in webview，只适用于webview的html页面，继承自webdriver。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.　ios 定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配 iOS UI Automation，很显然只适用于ios系统。&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;以上就是笔者对RF框架Appium引用控件定位总结，个人感受比较好用的定位器是id、name、xpath、accessibility_id，&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;其他几个相对比较局限，用的不多，其中css、ios定位笔者还未使用过，读者有兴趣可以自己去发掘一下。&lt;/span&gt;&lt;/h3&gt;


&lt;/div&gt;
</description>
<pubDate>Wed, 19 Sep 2018 07:30:00 +0000</pubDate>
<dc:creator>LeoZhanggg</dc:creator>
<og:description>一、介绍 AppiumLibrary 是 Robot Framework 的App测试库。 它使用Appium 与Android 和 iOS应用程序进行通信，类似于Selenium WebDriver</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leozhanggg/p/9670652.html</dc:identifier>
</item>
<item>
<title>C# 在PPT幻灯片中创建图表 - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/9674740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/9674740.html</guid>
<description>&lt;p&gt;图表能够很直观的表现数据在某个时间段的变化趋势，或者呈现数据的整体和局部之间的相互关系，相较于大篇幅的文本数据，图表更增加了我们分析数据时选择的多样性，是我们挖掘数据背后潜在价值的一种更为有效地方式。在做数据汇报时，常用到PPT幻灯片来辅助工作，下面的示例中将演示如何通过C#编程在PPT幻灯片中创建图表。示例中主要介绍了三种图表的创建方法，如下:&lt;/p&gt;
&lt;p&gt;1. 创建柱形图表&lt;/p&gt;
&lt;p&gt;2. 创建饼状图表&lt;/p&gt;
&lt;p&gt;3. 创建混合型图表（柱形图、折线图）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用工具&lt;/strong&gt;：&lt;a href=&quot;https://www.e-iceblue.cn/Introduce/Spire-Presentation-NET.html&quot;&gt;Spire.Presentation for .NET&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS：下载安装后，注意添加引用Spire.Presentation.dll到程序，dll文件可在安装路径下的Bin文件夹中获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201809/706090-20180919144133047-2078239881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;【示例&lt;/strong&gt; &lt;strong&gt;1&lt;/strong&gt; &lt;strong&gt;】创建柱形图表&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;步骤 1 ：添加using指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System.Drawing;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2 ：创建一个&lt;span lang=&quot;EN-US&quot;&gt;PowerPoint文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Presentation presentation = &lt;span&gt;new&lt;/span&gt; Presentation();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3 ：在幻灯片指定位置绘入指定大小和类型的图表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
RectangleF rect = &lt;span&gt;new&lt;/span&gt; RectangleF(&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;680&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
IChart chart &lt;/span&gt;= presentation.Slides[&lt;span&gt;0&lt;/span&gt;].Shapes.AppendChart(ChartType.Column3DClustered, rect);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 4 ：添加图表数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加图表名&lt;/span&gt;
chart.ChartTitle.TextProperties.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年上半年销量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
chart.ChartTitle.TextProperties.IsCentered &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
chart.ChartTitle.Height &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
chart.HasTitle &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个sting[,]数组&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt;[,] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[,]
 {
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;产品大类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DW10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1542&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1057&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1223&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1302&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1145&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1336&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZQ13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4587&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3658&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2515&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3154&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2984&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3890&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YI73&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;558&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;458&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;369&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;576&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;334&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;482&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TR11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2485&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3010&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2785&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2225&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2476&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
 };

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据写入图表后台数据表&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.GetLength(&lt;span&gt;0&lt;/span&gt;); i++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; data.GetLength(&lt;span&gt;1&lt;/span&gt;); j++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数字类型的字符串转换为整数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; number;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result = Int32.TryParse(data[i, j], &lt;span&gt;out&lt;/span&gt;&lt;span&gt; number);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result)
        {
            chart.ChartData[i, j].Value &lt;/span&gt;=&lt;span&gt; number;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            chart.ChartData[i, j].Value &lt;/span&gt;=&lt;span&gt; data[i, j];
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列标签&lt;/span&gt;
chart.Series.SeriesLabel = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别标签&lt;/span&gt;
chart.Categories.CategoryLabels = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为各个系列赋值&lt;/span&gt;
chart.Series[&lt;span&gt;0&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
chart.Series[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
chart.Series[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
chart.Series[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
chart.Series[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
chart.Series[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 5 ：应用图表样式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应用内置图标样式&lt;/span&gt;
chart.ChartStyle =&lt;span&gt; ChartStyle.Style12;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列重叠&lt;/span&gt;
chart.OverLap = -&lt;span&gt;50&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别间距&lt;/span&gt;
chart.GapWidth = &lt;span&gt;200&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 6 ：保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
presentation.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;柱形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Pptx2010);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;柱形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调试运行程序后，生成图表，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201809/706090-20180919145205020-929288580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全部代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;&lt;img id=&quot;code_img_closed_7bb67e3d-d9a6-430a-8fee-dde42c03aef3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7bb67e3d-d9a6-430a-8fee-dde42c03aef3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7bb67e3d-d9a6-430a-8fee-dde42c03aef3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;115&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ColumnChart
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个PowerPoint文档&lt;/span&gt;
            Presentation presentation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presentation();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入柱形图&lt;/span&gt;
            RectangleF rect = &lt;span&gt;new&lt;/span&gt; RectangleF(&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;680&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            IChart chart &lt;/span&gt;= presentation.Slides[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Shapes.AppendChart(ChartType.Column3DClustered, rect);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加图表名&lt;/span&gt;
            chart.ChartTitle.TextProperties.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年上半年销量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            chart.ChartTitle.TextProperties.IsCentered &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            chart.ChartTitle.Height &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
            chart.HasTitle &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个sting[,]数组&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt;[,] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[,]
             {
              {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;产品大类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
              {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DW10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1542&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1057&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1223&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1302&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1145&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1336&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
              {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZQ13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4587&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3658&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2515&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3154&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2984&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3890&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
              {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YI73&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;558&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;458&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;369&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;576&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;334&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;482&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
              {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TR11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2485&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3010&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2785&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2225&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2476&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
             };

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据写入图表后台数据表&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.GetLength(&lt;span&gt;0&lt;/span&gt;); i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; data.GetLength(&lt;span&gt;1&lt;/span&gt;); j++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数字类型的字符串转换为整数&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; number;
                    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result = Int32.TryParse(data[i, j], &lt;span&gt;out&lt;/span&gt;&lt;span&gt; number);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result)
                    {
                        chart.ChartData[i, j].Value &lt;/span&gt;=&lt;span&gt; number;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        chart.ChartData[i, j].Value &lt;/span&gt;=&lt;span&gt; data[i, j];
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列标签&lt;/span&gt;
            chart.Series.SeriesLabel = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别标签&lt;/span&gt;
            chart.Categories.CategoryLabels = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为各个系列赋值&lt;/span&gt;
            chart.Series[&lt;span&gt;0&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            chart.Series[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            chart.Series[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            chart.Series[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            chart.Series[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            chart.Series[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应用内置图标样式&lt;/span&gt;
            chart.ChartStyle =&lt;span&gt; ChartStyle.Style12;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列重叠&lt;/span&gt;
            chart.OverLap = -&lt;span&gt;50&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别间距&lt;/span&gt;
            chart.GapWidth = &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存并打开文档&lt;/span&gt;
            presentation.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;柱形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Pptx2010);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;柱形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;【示例&lt;/strong&gt; &lt;strong&gt;2&lt;/strong&gt; &lt;strong&gt;】创建环形图表&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;步骤 1 ：添加using指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System.Drawing;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2 ：新建一个PPT文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Presentation presentation = &lt;span&gt;new&lt;/span&gt; Presentation();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3 ：插入圆环形图表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
RectangleF rect = &lt;span&gt;new&lt;/span&gt; RectangleF(&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;550&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;&lt;span&gt;);
IChart chart &lt;/span&gt;= presentation.Slides[&lt;span&gt;0&lt;/span&gt;].Shapes.AppendChart(ChartType.Doughnut, rect, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 4 ：添加图表数据内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表名&lt;/span&gt;
chart.ChartTitle.TextProperties.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;市场份额&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
chart.ChartTitle.TextProperties.IsCentered &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
chart.ChartTitle.Height &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
chart.HasTitle &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义数据&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt;[] countries = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;古巴&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;墨西哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;法国&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;德国&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] sales = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] { &lt;span&gt;1800&lt;/span&gt;, &lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;5100&lt;/span&gt;, &lt;span&gt;6200&lt;/span&gt;&lt;span&gt; };

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据写入图表后台数据表&lt;/span&gt;
chart.ChartData[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;国家&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
chart.ChartData[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;销售额&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; countries.Length; ++&lt;span&gt;i)
{
    chart.ChartData[i &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;].Value =&lt;span&gt; countries[i];
    chart.ChartData[i &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;].Value =&lt;span&gt; sales[i];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 5 ：应用图表标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列标签&lt;/span&gt;
chart.Series.SeriesLabel = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置分类标签&lt;/span&gt;
chart.Categories.CategoryLabels = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为系列赋值&lt;/span&gt;
chart.Series[&lt;span&gt;0&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加点到系列&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; chart.Series[&lt;span&gt;0&lt;/span&gt;].Values.Count; i++&lt;span&gt;)
{
    ChartDataPoint cdp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ChartDataPoint(chart.Series[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    cdp.Index &lt;/span&gt;=&lt;span&gt; i;
    chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].DataPoints.Add(cdp);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为系列里的个点添加背景颜色&lt;/span&gt;
chart.Series[&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;0&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;0&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.LightBlue;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;1&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;1&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.MediumPurple;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;2&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;2&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.DarkGray;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;3&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;3&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.DarkOrange;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标签显示数值&lt;/span&gt;
chart.Series[&lt;span&gt;0&lt;/span&gt;].DataLabels.LabelValueVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标签显示百分比&lt;/span&gt;
chart.Series[&lt;span&gt;0&lt;/span&gt;].DataLabels.PercentValueVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置圆环内径大小&lt;/span&gt;
chart.Series[&lt;span&gt;0&lt;/span&gt;].DoughnutHoleSize = &lt;span&gt;60&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 6 ：保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
presentation.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;环形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Pptx2013);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;环形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;圆环图表创建效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201809/706090-20180919150204020-1512581853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全部代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_6948c46a-c566-4b27-befe-3149d30dd9c4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6948c46a-c566-4b27-befe-3149d30dd9c4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6948c46a-c566-4b27-befe-3149d30dd9c4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DoughnutChart
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个PowerPoint文件&lt;/span&gt;
            Presentation presentation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presentation();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入圆环图&lt;/span&gt;
            RectangleF rect = &lt;span&gt;new&lt;/span&gt; RectangleF(&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;550&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;&lt;span&gt;);
            IChart chart &lt;/span&gt;= presentation.Slides[&lt;span&gt;0&lt;/span&gt;].Shapes.AppendChart(ChartType.Doughnut, rect, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表名&lt;/span&gt;
            chart.ChartTitle.TextProperties.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;市场份额&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            chart.ChartTitle.TextProperties.IsCentered &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            chart.ChartTitle.Height &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
            chart.HasTitle &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义数据&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt;[] countries = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;古巴&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;墨西哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;法国&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;德国&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] sales = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] { &lt;span&gt;1800&lt;/span&gt;, &lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;5100&lt;/span&gt;, &lt;span&gt;6200&lt;/span&gt;&lt;span&gt; };

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据写入图表后台数据表&lt;/span&gt;
            chart.ChartData[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;国家&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            chart.ChartData[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;销售额&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; countries.Length; ++&lt;span&gt;i)
            {
                chart.ChartData[i &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;].Value =&lt;span&gt; countries[i];
                chart.ChartData[i &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;].Value =&lt;span&gt; sales[i];
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列标签&lt;/span&gt;
            chart.Series.SeriesLabel = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置分类标签&lt;/span&gt;
            chart.Categories.CategoryLabels = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为系列赋值&lt;/span&gt;
            chart.Series[&lt;span&gt;0&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加点到系列&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; chart.Series[&lt;span&gt;0&lt;/span&gt;].Values.Count; i++&lt;span&gt;)
            {
                ChartDataPoint cdp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ChartDataPoint(chart.Series[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                cdp.Index &lt;/span&gt;=&lt;span&gt; i;
                chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].DataPoints.Add(cdp);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为系列里的个点添加背景颜色&lt;/span&gt;
            chart.Series[&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;0&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;0&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.LightBlue;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;1&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;1&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.MediumPurple;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;2&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;2&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.DarkGray;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;3&lt;/span&gt;].Fill.FillType =&lt;span&gt; FillFormatType.Solid;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints[&lt;span&gt;3&lt;/span&gt;].Fill.SolidColor.Color =&lt;span&gt; Color.DarkOrange;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标签显示数值&lt;/span&gt;
            chart.Series[&lt;span&gt;0&lt;/span&gt;].DataLabels.LabelValueVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标签显示百分比&lt;/span&gt;
            chart.Series[&lt;span&gt;0&lt;/span&gt;].DataLabels.PercentValueVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置圆环内径大小&lt;/span&gt;
            chart.Series[&lt;span&gt;0&lt;/span&gt;].DoughnutHoleSize = &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            presentation.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;环形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Pptx2013);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;环形图.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;【示例&lt;/strong&gt; &lt;strong&gt;3&lt;/strong&gt; &lt;strong&gt;】创建混合型图表&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;步骤 1 ：添加using指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System.Drawing;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2 ：新建文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Presentation presentation = &lt;span&gt;new&lt;/span&gt; Presentation();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3 ：创建图表1：柱形图表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入柱形图&lt;/span&gt;
RectangleF rect = &lt;span&gt;new&lt;/span&gt; RectangleF(&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;650&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;&lt;span&gt;);
IChart chart &lt;/span&gt;= presentation.Slides[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Shapes.AppendChart(ChartType.ColumnClustered, rec

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加表名&lt;/span&gt;
chart.ChartTitle.TextProperties.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2017季度销售情况&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
chart.ChartTitle.TextProperties.IsCentered &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
chart.ChartTitle.Height &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
chart.HasTitle &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个DataTable&lt;/span&gt;
DataTable dataTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.String&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;销售额&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Int32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;同比增长率&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Decimal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;0.6&lt;/span&gt;&lt;span&gt;);
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;250&lt;/span&gt;, &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;);
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;, &lt;span&gt;0.6&lt;/span&gt;&lt;span&gt;);
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;);            

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将DataTable数据导入图表后台数据表&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; dataTable.Columns.Count; c++&lt;span&gt;)
{
    chart.ChartData[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, c].Text =&lt;span&gt; dataTable.Columns[c].Caption;
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; r = &lt;span&gt;0&lt;/span&gt;; r &amp;lt; dataTable.Rows.Count; r++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] datas =&lt;span&gt; dataTable.Rows[r].ItemArray;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; datas.Length; c++&lt;span&gt;)
    {
        chart.ChartData[r &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;, c].Value =&lt;span&gt; datas[c];

    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列标签&lt;/span&gt;
chart.Series.SeriesLabel = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别标签      &lt;/span&gt;
chart.Categories.CategoryLabels = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为系列赋值&lt;/span&gt;
chart.Series[&lt;span&gt;0&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
chart.Series[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 4 ：添加折线图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将系列2的图表类型改为折线图&lt;/span&gt;
chart.Series[&lt;span&gt;1&lt;/span&gt;].Type =&lt;span&gt; ChartType.LineMarkers;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将系列2显示到第二根轴&lt;/span&gt;
chart.Series[&lt;span&gt;1&lt;/span&gt;].UseSecondAxis = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示百分比数据&lt;/span&gt;
chart.SecondaryValueAxis.NumberFormat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不显示第二根轴的网格线&lt;/span&gt;
chart.SecondaryValueAxis.MajorGridTextLines.FillType =&lt;span&gt; FillFormatType.None;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列重叠&lt;/span&gt;
chart.OverLap = -&lt;span&gt;50&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别间距&lt;/span&gt;
chart.GapWidth = &lt;span&gt;200&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 5 ：保存文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
presentation.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;混合图表.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Pptx2010);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;混合图表.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;混合型图表生成效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201809/706090-20180919151409394-1628406068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全部代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43.5&quot;&gt;&lt;img id=&quot;code_img_closed_277d0fbf-6952-46f9-a45a-2dccdb8892fa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_277d0fbf-6952-46f9-a45a-2dccdb8892fa&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_277d0fbf-6952-46f9-a45a-2dccdb8892fa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Presentation.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 混合图表
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个PowerPoint文档&lt;/span&gt;
            Presentation presentation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presentation();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入柱形图&lt;/span&gt;
            RectangleF rect = &lt;span&gt;new&lt;/span&gt; RectangleF(&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;650&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;&lt;span&gt;);
            IChart chart &lt;/span&gt;= presentation.Slides[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Shapes.AppendChart(ChartType.ColumnClustered, rect);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加表名&lt;/span&gt;
            chart.ChartTitle.TextProperties.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2017季度销售情况&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            chart.ChartTitle.TextProperties.IsCentered &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            chart.ChartTitle.Height &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
            chart.HasTitle &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个DataTable&lt;/span&gt;
            DataTable dataTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
            dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.String&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
            dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;销售额&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Int32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
            dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;同比增长率&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Decimal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
            dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;0.6&lt;/span&gt;&lt;span&gt;);
            dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;250&lt;/span&gt;, &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;);
            dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;, &lt;span&gt;0.6&lt;/span&gt;&lt;span&gt;);
            dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;);            

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将DataTable数据导入图表后台数据表&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; dataTable.Columns.Count; c++&lt;span&gt;)
            {
                chart.ChartData[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, c].Text =&lt;span&gt; dataTable.Columns[c].Caption;
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; r = &lt;span&gt;0&lt;/span&gt;; r &amp;lt; dataTable.Rows.Count; r++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] datas =&lt;span&gt; dataTable.Rows[r].ItemArray;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; datas.Length; c++&lt;span&gt;)
                {
                    chart.ChartData[r &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;, c].Value =&lt;span&gt; datas[c];

                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列标签&lt;/span&gt;
            chart.Series.SeriesLabel = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别标签      &lt;/span&gt;
            chart.Categories.CategoryLabels = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为系列赋值&lt;/span&gt;
            chart.Series[&lt;span&gt;0&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            chart.Series[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].Values = chart.ChartData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将系列2的图表类型改为折线图&lt;/span&gt;
            chart.Series[&lt;span&gt;1&lt;/span&gt;].Type =&lt;span&gt; ChartType.LineMarkers;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将系列2显示到第二根轴&lt;/span&gt;
            chart.Series[&lt;span&gt;1&lt;/span&gt;].UseSecondAxis = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示百分比数据&lt;/span&gt;
            chart.SecondaryValueAxis.NumberFormat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不显示第二根轴的网格线&lt;/span&gt;
            chart.SecondaryValueAxis.MajorGridTextLines.FillType =&lt;span&gt; FillFormatType.None;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列重叠&lt;/span&gt;
            chart.OverLap = -&lt;span&gt;50&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类别间距&lt;/span&gt;
            chart.GapWidth = &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存打开文档&lt;/span&gt;
            presentation.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;混合图表.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Pptx2010);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;混合图表.pptx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注：Spire.Presentation 支持创建多大73种不同的图表样式，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201809/706090-20180919151542788-156985601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;以上是本次关于“C# 创建PPT图表”的全部内容。&lt;/p&gt;
&lt;p&gt;如需转载，请注明出处。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Sep 2018 07:17:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<og:description>图表能够很直观的表现数据在某个时间段的变化趋势，或者呈现数据的整体和局部之间的相互关系，相较于大篇幅的文本数据，图表更增加了我们分析数据时选择的多样性，是我们挖掘数据背后潜在价值的一种更为有效地方式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/9674740.html</dc:identifier>
</item>
<item>
<title>【c#】队列（Queue）和MSMQ（消息队列）的基础使用 - YanBigFeg</title>
<link>http://www.cnblogs.com/yanbigfeg/p/9674238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanbigfeg/p/9674238.html</guid>
<description>
&lt;p&gt;    首先我们知道队列是先进先出的机制，所以在处理并发是个不错的选择。然后就写两个队列的简单应用。&lt;/p&gt;
&lt;h2&gt;Queue&lt;/h2&gt;
&lt;h3&gt;命名空间&lt;/h3&gt;
&lt;p&gt;    命名空间：System.Collections，不在这里做过多的理论解释，这个东西非常的好理解。&lt;/p&gt;
&lt;p&gt;    可以看下官方文档：https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.queue?view=netframework-4.7.2&lt;/p&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;我这里就是为了方便记忆做了一个基本的例子，首先创建了QueueTest类：&lt;/p&gt;
&lt;p&gt;包含了获取队列的数量，入队和出队的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueueTest
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Queue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; q = &lt;span&gt;new&lt;/span&gt; Queue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 获取队列数量
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetCount()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; q.Count;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 队列添加数据
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; IntoData(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; qStr)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; threadId =&lt;span&gt; System.Threading.Thread.CurrentThread.ManagedThreadId.ToString();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            q.Enqueue(qStr);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列添加数据: {qStr};当前线程id:{threadId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 队列输出数据
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; OutData()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; threadId =&lt;span&gt; System.Threading.Thread.CurrentThread.ManagedThreadId.ToString();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; q.Dequeue();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列输出数据: {str};当前线程id:{threadId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了模拟并发情况下也不会出现重复读取和插入混乱的问题所以写了TaskTest类里面开辟了两个异步线程进行插入和读取：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskTest
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 队列的操作模拟
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; QueueMian()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            QueueA();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            QueueB();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; QueueA()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             QueueTest queue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueueTest();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; task = Task.Run(() =&amp;gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     queue.IntoData(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueAA插入完成,进行输出:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (queue.GetCount() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                queue.OutData();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; QueueB()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             QueueTest queue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueueTest();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; task = Task.Run(() =&amp;gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     queue.IntoData(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB插入完成,进行输出:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (queue.GetCount() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                queue.OutData();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;效果展示&lt;/h3&gt;
&lt;p&gt;然后在main函数直接调用即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201809/809005-20180919140048083-280849349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的截图可以看出插入线程是无先后的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201809/809005-20180919140153568-1896649341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张去除也是线程无先后，但是数据是根据插入的数据顺序取的，也就是说多线程取随便取，但是取的数据是根据插入的顺序取值。&lt;/p&gt;
&lt;h2&gt;MSMQ&lt;/h2&gt;
&lt;p&gt;msmq是微软提供的消息队列，本来在windows系统中就存在，但是默认没有开启。需要开启。&lt;/p&gt;
&lt;h3&gt;开启安装&lt;/h3&gt;
&lt;p&gt;打开控制面板=&amp;gt;程序和功能=&amp;gt; 启动或关闭windows功能 =&amp;gt; Microsoft Message Queue(MSMQ)服务器=&amp;gt;Microsoft Message Queue(MSMQ)服务器核心&lt;/p&gt;
&lt;p&gt;一般选择：MSMQ Active Directory域服务继承和MSMQ HTTP支持即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201809/809005-20180919140958002-1983022017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击确定等待安装成功。&lt;/p&gt;
&lt;h3&gt;命名空间&lt;/h3&gt;
&lt;p&gt;需要引用System.Messaging.DLL&lt;/p&gt;
&lt;p&gt;命名空间：System.Messaging&lt;/p&gt;
&lt;p&gt;官方资料文档：https://docs.microsoft.com/zh-cn/dotnet/api/system.messaging.messagequeue?view=netframework-4.7.2&lt;/p&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;与上面queue同样的示例方式，创建一个MSMQ类，实现创建消息队列，查询数据，入列，出列功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; MSMQ消息队列
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MSMQ
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.\\Private$\\myQueue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MessageQueue queue;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Createqueue(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; queuePath)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (MessageQueue.Exists(queuePath))
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息队列已经存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取这个消息队列&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;                     queue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageQueue(queuePath);
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不存在，就创建一个新的，并获取这个消息队列对象&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;                     queue =&lt;span&gt; MessageQueue.Create(queuePath);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                     path =&lt;span&gt; queuePath;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;                Console.WriteLine(e.Message);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 获取消息队列的数量
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetMessageCount()
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (queue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; queue.GetAllMessages().Length;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息队列数量：{count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (MessageQueueException e)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;                Console.WriteLine(e.Message);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 发送消息到队列
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SendMessage(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; qStr)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接到本地队列&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;                 MessageQueue myQueue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageQueue(path);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;MessageQueue myQueue = new MessageQueue(&quot;FormatName:Direct=TCP:192.168.12.79&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Private$&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;myQueue1&quot;);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;MessageQueue rmQ = new MessageQueue(&quot;FormatName:Direct=TCP:121.0.0.1&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private$&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;queue&quot;);--远程格式&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;                 Message myMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;                 myMessage.Body =&lt;span&gt; qStr;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;                 myMessage.Formatter = &lt;span&gt;new&lt;/span&gt; XmlMessageFormatter(&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发生消息到队列中&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                myQueue.Send(myMessage);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; threadId =&lt;span&gt; System.Threading.Thread.CurrentThread.ManagedThreadId.ToString();
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息发送成功: {qStr};当前线程id:{threadId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (MessageQueueException e)
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                Console.WriteLine(e.Message);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 连接消息队列读取消息
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReceiveMessage()
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             MessageQueue myQueue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageQueue(path);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;             myQueue.Formatter = &lt;span&gt;new&lt;/span&gt; XmlMessageFormatter(&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从队列中接收消息&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;                 Message myMessage = myQueue.Receive(&lt;span&gt;new&lt;/span&gt; TimeSpan(&lt;span&gt;10&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; myQueue.Peek();--接收后不消息从队列中移除&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                myQueue.Close();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; context =&lt;span&gt; myMessage.Body.ToString();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; threadId =&lt;span&gt; System.Threading.Thread.CurrentThread.ManagedThreadId.ToString();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------------消息内容: {context};当前线程id:{threadId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (System.Messaging.MessageQueueException e)
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt; &lt;span&gt;                Console.WriteLine(e.Message);
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidCastException e)
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                Console.WriteLine(e.Message);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里说明一下path这个字段，这是消息队列的文件位置和队列名称，我这里写的“.”(点)就是代表的位置MachineName字段，，代表本机的意思&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201809/809005-20180919141855575-136059528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后TaskTest类修改成这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskTest
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 消息队列的操作模拟
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MSMQMian()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             MSMQ.Createqueue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.\\Private$\\myQueue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            MSMQA();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            MSMQB();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSMQ结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MSMQA()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; task = Task.Run(() =&amp;gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     MSMQ.SendMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSMQA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSMQA发送完成,进行读取:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (MSMQ.GetMessageCount() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                MSMQ.ReceiveMessage();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MSMQB()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; task = Task.Run(() =&amp;gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     MSMQ.SendMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSMQB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSMQB发送完成,进行读取:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (MSMQ.GetMessageCount() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                MSMQ.ReceiveMessage();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 效果展示&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201809/809005-20180919142359267-2117860194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201809/809005-20180919142541257-2140556128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;本机查看消息队列&lt;/h3&gt;
&lt;p&gt;创建成功的消息队列我们可以在电脑上查看：我的电脑=&amp;gt;管理 =&amp;gt;计算机管理 =&amp;gt;服务与应用程序 =&amp;gt;消息队列 =&amp;gt;专用队列就看到我刚才创建的消息队列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201809/809005-20180919142807300-131138269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Sep 2018 06:29:00 +0000</pubDate>
<dc:creator>YanBigFeg</dc:creator>
<og:description>首先我们知道队列是先进先出的机制，所以在处理并发是个不错的选择。然后就写两个队列的简单应用。 Queue 命名空间 命名空间：System.Collections，不在这里做过多的理论解释，这个东西非</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanbigfeg/p/9674238.html</dc:identifier>
</item>
<item>
<title>在AspNetCore中使用极验做行为认证 - 编程梦</title>
<link>http://www.cnblogs.com/LiangSW/p/9674273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiangSW/p/9674273.html</guid>
<description>&lt;p&gt;先上效果图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201809/832799-20180919140757721-427865150.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;极验官方文档地址 &lt;a href=&quot;https://docs.geetest.com/install/deploy/server/csharp&quot; class=&quot;uri&quot;&gt;https://docs.geetest.com/install/deploy/server/csharp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单说明一下极验的验证流程&lt;/p&gt;
&lt;p&gt;引用官方的图片&lt;br/&gt;&lt;img src=&quot;https://docs.geetest.com/static/install/overview/imgs/geetest_netwoking_sequence.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;向服务器发送请求获取验证参数&lt;/li&gt;
&lt;li&gt;客户端sdk完成验证&lt;/li&gt;
&lt;li&gt;由客户端sdk验证数据提交服务器二次验证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我查看官方的sdk过后,发现不是特别好用，根据极验的流程写了一套适用于netcore的极验sdk &lt;a href=&quot;https://github.com/liangshiw/SharpPlugs/tree/master/src/SharpPlug.Geetest&quot;&gt;开源地址&lt;/a&gt; 已经发了nuget包 搜索&lt;code&gt;sharpplug.geetest&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;使用方式很简单，下面通过一个例子来进行讲解&lt;/p&gt;
&lt;p&gt;使用命令&lt;code&gt;dotnet new mvc&lt;/code&gt;创建一个mvc项目&lt;/p&gt;
&lt;p&gt;下一步使用命令&lt;code&gt;dotnet add package sharpplug.geetest&lt;/code&gt;安装nuget包&lt;/p&gt;
&lt;p&gt;打开startup文件在ConfigureServices中配置geetest服务&lt;br/&gt;我在极验申请了一个测试用的id和key 大家可以直接测试使用&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.Configure&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;
    {
        // This lambda determines whether user consent for non-essential cookies is needed for a given request.
        options.CheckConsentNeeded = context =&amp;gt; true;
        options.MinimumSameSitePolicy = SameSiteMode.None;
    });

    // GeetestOptions中配置id 与 key
    services.AddGeetest(opt=&amp;gt;{
               opt.Id = &quot;e2697c763685a34be93a7d255ee06b59&quot;;
               opt.Key = &quot;7882a2d954106041a731f5e10038982a&quot;;
            });

    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成获取验证参数与二次验证的类是GeetestManager,它主要有两个方法&lt;/p&gt;
&lt;p&gt;获取验证参数方法是Register,它主要有三个参数 userid（用户标识） clientType(客户端类型) 与 ipaddress(客户端ip) 关于参数的细节大家可以去参阅极验文档&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task&amp;lt;GeeTestRegisterResult&amp;gt; Register(string userId = null, string clientType = &quot;unknown&quot;, string ipAddress = &quot;unknown&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二次验证方法 Validate 参数为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;offline 是否离线验证（获取验证参数失败时）&lt;/li&gt;
&lt;li&gt;UserId 用户标识&lt;/li&gt;
&lt;li&gt;Challenge&lt;/li&gt;
&lt;li&gt;Seccode&lt;/li&gt;
&lt;li&gt;Validate&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task&amp;lt;bool&amp;gt; Validate(GeetestValidateInput input)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面打开HomeController添加获取验证参数方法,记得注入GeetestManager&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
private readonly GeetestManager _geetestManager;

public HomeController(GeetestManager geetestManager)
{
    _geetestManager = geetestManager;
}

public async Task&amp;lt;GeeTestRegisterResult&amp;gt; GeetestRegister()
{
    return await _geetestManager.Register(clientType: &quot;web&quot;, ipAddress: &quot;127.0.0.1&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面在HomeController中加入二次验证&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task&amp;lt;bool&amp;gt; GeetestValidate(GeetestValidateInput input)
{
    return await _geetestManager.Validate(input);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端部分已经完成,下面打开index.cshtml先引用gt.js&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://static.geetest.com/static/tools/gt.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后添加html元素&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;h2&amp;gt;Getest&amp;lt;/h2&amp;gt;
&amp;lt;div id=&quot;geetestform&quot;&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;geetest_challenge&quot; id=&quot;geetest_challenge&quot;&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;geetest_validate&quot; id=&quot;geetest_validate&quot;&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;geetest_seccode&quot; id=&quot;geetest_seccode&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;button class=&quot;form-control btn-default&quot; id=&quot;validate&quot;&amp;gt;点我验证&amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;极验有一个初始化的过程,先调用获取验证参数api进行初始化极验&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(function() {
    $.ajax({
        url: &quot;/home/GeetestRegister&quot;,
        type: &quot;get&quot;,
        dataType: &quot;json&quot;,
        success: function(data) {
            // 使用offline判断是否是离线验证
            offline = !data.success;
            initGeetest({
                // 以下配置参数来自服务端 SDK
                gt: data.gt,
                challenge: data.challenge,
                offline: !data.success,
                new_captcha: true,
                product: &quot;float&quot;,
                width: &quot;100%&quot;
            },function(){
                // 初始化元素
                captchaObj.appendTo(document.getElementById('geetestform'));
            })
        }
    });

});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时运行项目已经可以看到极验的验证表单了并且已经可以进行验证,但是还需要添加点击按钮事件进行二次验证&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(&quot;#validate&quot;).click(() =&amp;gt; {
    var validate = captchaObj.getValidate();
    if (validate === undefined || !validate) {
        alert(&quot;请进行验证&quot;);
        return;
    }

    $.ajax({
        url: &quot;/home/GeetestValidate&quot;,
        method:&quot;post&quot;,
        data: {
            offline: offline,
            challenge: validate.geetest_challenge,
            validate: validate.geetest_validate,
            seccode: validate.geetest_seccode
        },
        success: function(res) {
            if (res) {
                alert(&quot;二次校验状态成功! 重置验证状态&quot;);
                captchaObj.reset();
            } else {
                alert(&quot;二次校验状态返回失败! 重置验证状态&quot;);
                captchaObj.reset();
            }
        }
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时功能已经全部完成了,大家可以运行项目查看效果了,关于gt.js的更多用法可以参阅极验的官方文档&lt;/p&gt;
</description>
<pubDate>Wed, 19 Sep 2018 06:08:00 +0000</pubDate>
<dc:creator>编程梦</dc:creator>
<og:description>先上效果图 极验的流程 极验官方文档地址</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiangSW/p/9674273.html</dc:identifier>
</item>
<item>
<title>职场篇:聚焦与复盘 - 范存威</title>
<link>http://www.cnblogs.com/fancunwei/p/9674247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9674247.html</guid>
<description>&lt;p&gt;聚焦与复盘的意思很好理解。聚焦就是集合全部精力做你目标内的事。复盘就是不定期对已发生或未发生的事重新思考改进优化的过程。&lt;/p&gt;
&lt;p&gt;我也趁这个机会谈一下我近期的主要目标。防止精力过分分散到其他地方。&lt;/p&gt;

&lt;p&gt;从九月份写作了《实用中小型公司支付中心设计》，得到一些流量后，积分排名开始飙升，提升了我继续写博客的信心。然后就开始了分布式监控的学习之路，它涉及范围广同时又考虑基础能力，是具有很高价值的学习项目。由于积累不足，又打算博客日更，所以中间就临时写了一些其他分享。对我个人最振奋的是9月13号，当时一天写四更，有三篇轮番上博客园头条，吸引了社区部分大佬的关注，通过评论微信等各种渠道建立了联系。9月份，我的博客园排名也也从3万名上升到1万余名，可以查看我的&lt;a href=&quot;http://note.youdao.com/noteshare?id=bd5ea2aba37f057f8d93f8e87bcc6129&amp;amp;sub=00DDCCCFB5A54685AB011CEF75FAF513&quot; title=&quot;个人9月份排名记录&quot;&gt;个人9月份排名记录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不想这才几天，后面的文章就比较平淡了。但关于zipkin的实践之路确实让我部分知识得到巩固。实践完客户端之后，我开始了解zipkin的持久化，然后也打算了解不同组件的集群。本地安装虚拟机过程中，经历了一番考验，安装好后，又被linux的复制粘贴问题折磨了许久。昨天天晚了，我就停下了折腾，空余时间开始思考聚焦的问题。&lt;/p&gt;
&lt;p&gt;就在前天晚上，我搞定了zipkin的聚合依赖问题，春风得意，仿佛什么都会，之后还接到一个来自XXXX的XX电话，我以饱满的激情，不凡的见识海聊了十分钟，我当时感觉自己飘了，进入到一种及其亢奋的状态。聚焦之极，类似通灵。&lt;/p&gt;
&lt;p&gt;才过了一天，被环境配置问题，折腾的心烦气燥，临走的时候仿佛又丢了一切。我想如果是同一个电话，我估计什么都回答不出来，所以我是幸运的，在我最亢奋的那天接的电话。人的思路真的和心情情绪有关，情绪又很容易被杂事烦扰。&lt;/p&gt;
&lt;p&gt;人力有所不及，于是我觉得调整思路，从单体式单台机器做起，研究透之后，再说集群的事，不然很容易迷失在各种问题中。&lt;span&gt;聚焦于一点，成功后再去扩展。&lt;/span&gt;这里再重申下我当前目标：设计一款实用的中小型分布式调用链系统。先了解清楚调用链，再去考虑分布式。精力聚焦于最核心的事情。&lt;/p&gt;

&lt;p&gt;上面的文字，其实已经是我的复盘了，但这里还可以补充一些其他的事情。&lt;/p&gt;
&lt;p&gt;每个企业都有自己核心的事情要做，企业不断的聚焦，不断的思考复盘工作，才产生了外包。如果没有外包，企业会被不想关的杂事拖垮的。&lt;/p&gt;
&lt;p&gt;在最开始的时代，也是没有什么前短后端产品运维之分的，那时规模小的一个人就做完了所有事。后来客户和社会的要求越来越高，各个行业才细分。每个职业聚焦于自己专注的事情，才能做的更完美。&lt;/p&gt;
&lt;p&gt;当我们空余时间，时常复盘自己或工作的事，是否被不相关的杂事干扰，影响了效率，影响了我们原本目标的深度？吾日三省吾身。&lt;/p&gt;
&lt;p&gt;复盘也可以对过去的成功或失败做分析，提炼需要学习的知识，对未来都是有益的。&lt;/p&gt;

&lt;p&gt;聚焦和复盘息息相关，时时复盘自己，聚焦核心，才能在汪洋大海里准确航行。&lt;/p&gt;
&lt;p&gt;本篇到此结束，感谢观看。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Sep 2018 06:05:00 +0000</pubDate>
<dc:creator>范存威</dc:creator>
<og:description>前言 聚焦与复盘的意思很好理解。聚焦就是集合全部精力做你目标内的事。复盘就是不定期对已发生或未发生的事重新思考改进优化的过程。 我也趁这个机会谈一下我近期的主要目标。防止精力过分分散到其他地方。 聚焦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9674247.html</dc:identifier>
</item>
<item>
<title>并发服务器三种实现方式之进程、线程和select - 柳德维</title>
<link>http://www.cnblogs.com/liudw-0215/p/9664204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudw-0215/p/9664204.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;前言：&lt;/strong&gt;刚开始学网络编程，都会先写一个客户端和服务端，不知道你们有没有试一下：再打开一下客户端，是连不上服务端的。还有一个问题不知道你们发现没：有时启服务器，会提示“Address already in use”，过一会就好了，想过为啥么？在这篇博客会解释这个问题。&lt;/p&gt;
&lt;p&gt;　　但现实的服务器都会连很多客户端的，像阿里服务器等，所以这篇主要介绍如何实现并发服务器，主要通过三种方式：进程、线程和select函数来分别实现。&lt;/p&gt;
&lt;h3&gt;　　一、进程实现并发服务器&lt;/h3&gt;
&lt;p&gt;　　先说下什么是并发服务器吧？不是指有多个服务器同时运行，而是可以同时连接多个客户端。&lt;/p&gt;
&lt;p&gt;　　先简单说下原理吧，先画个图，如下：　　PS：全博客园最丑图，不接受反驳！哈哈哈&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201809/1249620-20180918155849746-1891346148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　先要搞清楚通信的流程，图上参数说明：&lt;/p&gt;
&lt;p&gt;　　lfd：socket函数的返回值，就是监听描述符&lt;/p&gt;
&lt;p&gt;　　cfd1/cfd2/cfd3:accept函数的返回值，用通信的套接字&lt;/p&gt;
&lt;p&gt;　　server：服务器&lt;/p&gt;
&lt;p&gt;　　client：客户端&lt;/p&gt;
&lt;p&gt;　　socket通信过程中，总共有几个套接字呢？答：三个，客户端一个，服务器两个。&lt;/p&gt;
&lt;p&gt;　　根据上图来大致说明一下流程：&lt;/p&gt;
&lt;p&gt;　　客户端创建一个套接字描述符，用于通信，服务器先用socket函数创建套接字，用于监听客户端，然后调用accept函数，会返回一个套接字，用于通信的。图上就是，client1先通过cfd与server建立连接，然后与cfd1建立连接通信，这时lfd就空闲了，再监听客户端，client2再与lfd连接，再跟cfd2通信。client3也是如此。&lt;/p&gt;
&lt;p&gt;　　现在问题就是。如何创建多个进程与客户端通信呢？通过循环创建子进程就可以实现这个问题，可以参考我的这篇博客：https://www.cnblogs.com/liudw-0215/p/9667686.html&lt;/p&gt;
&lt;p&gt;　　服务端程序，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a22360bc-2cde-4087-8637-d6dc3376a654')&quot; readability=&quot;47.5&quot;&gt;&lt;img id=&quot;code_img_closed_a22360bc-2cde-4087-8637-d6dc3376a654&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a22360bc-2cde-4087-8637-d6dc3376a654&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a22360bc-2cde-4087-8637-d6dc3376a654',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a22360bc-2cde-4087-8637-d6dc3376a654&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;signal.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;ctype.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; MAXLINE 8192
&lt;span&gt;#define&lt;/span&gt; SERV_PORT 8000

&lt;span&gt;void&lt;/span&gt; do_sigchild(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (waitpid(&lt;span&gt;0&lt;/span&gt;, NULL, WNOHANG) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        ;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in servaddr, cliaddr;
    socklen_t cliaddr_len;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; listenfd, connfd;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; buf[MAXLINE];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; str[INET_ADDRSTRLEN];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, n;
    pid_t pid;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sigaction newact;

    newact.sa_handler &lt;/span&gt;=&lt;span&gt; do_sigchild;
    sigemptyset(&lt;/span&gt;&amp;amp;&lt;span&gt;newact.sa_mask);
    newact.sa_flags &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    sigaction(SIGCHLD, &lt;/span&gt;&amp;amp;newact, NULL);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立信号，处理子进程退出&lt;/span&gt;
&lt;span&gt;
    listenfd &lt;/span&gt;= Socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int opt = 1;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;opt, sizeof(opt));    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口复用&lt;/span&gt;
&lt;span&gt;
    bzero(&lt;/span&gt;&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));
    servaddr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    servaddr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt; htonl(INADDR_ANY);
    servaddr.sin_port &lt;/span&gt;=&lt;span&gt; htons(SERV_PORT);

    Bind(listenfd, (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));

    Listen(listenfd, &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accepting connections ...\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        cliaddr_len &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cliaddr);
        connfd &lt;/span&gt;= Accept(listenfd, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;cliaddr, &amp;amp;&lt;span&gt;cliaddr_len);
        pid &lt;/span&gt;=&lt;span&gt; fork();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            Close(listenfd);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                n &lt;/span&gt;=&lt;span&gt; Read(connfd, buf, MAXLINE);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the other side has been closed.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;received from %s at PORT %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        inet_ntop(AF_INET, &lt;/span&gt;&amp;amp;cliaddr.sin_addr, str, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(str)),ntohs(cliaddr.sin_port));
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
                    buf[i] &lt;/span&gt;=&lt;span&gt; toupper(buf[i]);
                Write(STDOUT_FILENO, buf, n);
                Write(connfd, buf, n);
            }
            Close(connfd);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pid &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            Close(connfd);
        }  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            perr_exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　客户端程序如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('88819fd3-9cd6-4299-9998-ecc23c5c1525')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_88819fd3-9cd6-4299-9998-ecc23c5c1525&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_88819fd3-9cd6-4299-9998-ecc23c5c1525&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('88819fd3-9cd6-4299-9998-ecc23c5c1525',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_88819fd3-9cd6-4299-9998-ecc23c5c1525&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; client.c &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; MAXLINE 8192
&lt;span&gt;#define&lt;/span&gt; SERV_PORT 8000

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in servaddr;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; buf[MAXLINE];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sockfd, n;

    sockfd &lt;/span&gt;= Socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    bzero(&lt;/span&gt;&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));
    servaddr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    inet_pton(AF_INET, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;servaddr.sin_addr);
    servaddr.sin_port &lt;/span&gt;=&lt;span&gt; htons(SERV_PORT);

    Connect(sockfd, (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (fgets(buf, MAXLINE, stdin) !=&lt;span&gt; NULL) {
        Write(sockfd, buf, strlen(buf));
        n &lt;/span&gt;=&lt;span&gt; Read(sockfd, buf, MAXLINE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the other side has been closed.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            Write(STDOUT_FILENO, buf, n);
    }

    Close(sockfd);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　演示效果，服务器可以同时处理两个客户端，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201809/1249620-20180918163126131-703576636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但我想再测试一下程序，执行./server,发现有个bind error,如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201809/1249620-20180918163338908-419801294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面来解释一下这个问题：&lt;/p&gt;
&lt;p&gt;　　先来一张图片（出自UNP），如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201809/1249620-20180918163622066-1327935145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这张图将三次握手、四次挥手和TCP状态转换图，这些在我的这篇博客都由介绍，可以参考一下：https://www.cnblogs.com/liudw-0215/p/9661583.html&lt;/p&gt;
&lt;p&gt;注意最后有一个TIME_WAIT状态，主动关闭一端会经历2MSL时长等待（大约40秒），再变为最开始的状态CLOSED。&lt;/p&gt;
&lt;p&gt;　　复现上面的“bind error”，只需退出服务器，在启服务器，就会报出此错。因为主动关闭一端，会经历2MSL时长，端口IP会被占用，所以会报“bind error”。&lt;/p&gt;
&lt;p&gt;但可能会问：为啥先退出客户端没有此问题？因为客户端没有调用bind函数地址结构，会“隐式”生成端口。&lt;/p&gt;
&lt;p&gt;　　有没有方法可以解决这个问题呢？当然有的，调用函数setsockopt即可，服务端程序如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('dcfcc513-50d0-40ed-b1f0-303f32a5a2b9')&quot; readability=&quot;47.5&quot;&gt;&lt;img id=&quot;code_img_closed_dcfcc513-50d0-40ed-b1f0-303f32a5a2b9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dcfcc513-50d0-40ed-b1f0-303f32a5a2b9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('dcfcc513-50d0-40ed-b1f0-303f32a5a2b9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dcfcc513-50d0-40ed-b1f0-303f32a5a2b9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;signal.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;ctype.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; MAXLINE 8192
&lt;span&gt;#define&lt;/span&gt; SERV_PORT 8000

&lt;span&gt;void&lt;/span&gt; do_sigchild(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (waitpid(&lt;span&gt;0&lt;/span&gt;, NULL, WNOHANG) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        ;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in servaddr, cliaddr;
    socklen_t cliaddr_len;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; listenfd, connfd;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; buf[MAXLINE];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; str[INET_ADDRSTRLEN];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, n;
    pid_t pid;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sigaction newact;

    newact.sa_handler &lt;/span&gt;=&lt;span&gt; do_sigchild;
    sigemptyset(&lt;/span&gt;&amp;amp;&lt;span&gt;newact.sa_mask);
    newact.sa_flags &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    sigaction(SIGCHLD, &lt;/span&gt;&amp;amp;newact, NULL);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立信号，处理子进程退出&lt;/span&gt;
&lt;span&gt;
    listenfd &lt;/span&gt;= Socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; opt = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &lt;/span&gt;&amp;amp;opt, &lt;span&gt;sizeof&lt;/span&gt;(opt));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口复用&lt;/span&gt;
&lt;span&gt;
    bzero(&lt;/span&gt;&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));
    servaddr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    servaddr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt; htonl(INADDR_ANY);
    servaddr.sin_port &lt;/span&gt;=&lt;span&gt; htons(SERV_PORT);

    Bind(listenfd, (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));

    Listen(listenfd, &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accepting connections ...\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        cliaddr_len &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cliaddr);
        connfd &lt;/span&gt;= Accept(listenfd, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;cliaddr, &amp;amp;&lt;span&gt;cliaddr_len);
        pid &lt;/span&gt;=&lt;span&gt; fork();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            Close(listenfd);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                n &lt;/span&gt;=&lt;span&gt; Read(connfd, buf, MAXLINE);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the other side has been closed.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;received from %s at PORT %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        inet_ntop(AF_INET, &lt;/span&gt;&amp;amp;cliaddr.sin_addr, str, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(str)),ntohs(cliaddr.sin_port));
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
                    buf[i] &lt;/span&gt;=&lt;span&gt; toupper(buf[i]);
                Write(STDOUT_FILENO, buf, n);
                Write(connfd, buf, n);
            }
            Close(connfd);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pid &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            Close(connfd);
        }  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            perr_exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　二、线程实现并发服务器&lt;/h3&gt;
&lt;p&gt;　　理解了进程的方式，就是创建多个线程来实现，就不过多解释了，程序需要对线程有一定了解，之后我还会写篇博客来介绍线程，敬请期待哦。&lt;/p&gt;
&lt;p&gt;　　服务器代码如下，有有详细的解释：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1dbbefa9-fe33-4400-866e-6b7e7c7b623c')&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_1dbbefa9-fe33-4400-866e-6b7e7c7b623c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1dbbefa9-fe33-4400-866e-6b7e7c7b623c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1dbbefa9-fe33-4400-866e-6b7e7c7b623c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1dbbefa9-fe33-4400-866e-6b7e7c7b623c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;pthread.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;ctype.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; MAXLINE 8192
&lt;span&gt;#define&lt;/span&gt; SERV_PORT 8000

&lt;span&gt;struct&lt;/span&gt; s_info {                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个结构体, 将地址结构跟cfd捆绑&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in cliaddr;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; connfd;
};

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *do_work(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,i;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; s_info *ts = (&lt;span&gt;struct&lt;/span&gt; s_info*&lt;span&gt;)arg;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; buf[MAXLINE];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[INET_ADDRSTRLEN];      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define INET_ADDRSTRLEN 16  可用&quot;[+d&quot;查看&lt;/span&gt;

    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        n &lt;/span&gt;= Read(ts-&amp;gt;connfd, buf, MAXLINE);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读客户端&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the client %d closed...\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ts-&amp;gt;&lt;span&gt;connfd);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;                                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳出循环,关闭cfd&lt;/span&gt;
&lt;span&gt;        }
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;received from %s at PORT %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                inet_ntop(AF_INET, &lt;/span&gt;&amp;amp;(*ts).cliaddr.sin_addr, str, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(str)),
                ntohs((&lt;/span&gt;*ts).cliaddr.sin_port));                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印客户端信息(IP/PORT)&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;) 
            buf[i] &lt;/span&gt;= toupper(buf[i]);                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小写--&amp;gt;大写&lt;/span&gt;
&lt;span&gt;
        Write(STDOUT_FILENO, buf, n);                           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写出至屏幕&lt;/span&gt;
        Write(ts-&amp;gt;connfd, buf, n);                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回写给客户端&lt;/span&gt;
&lt;span&gt;    }
    Close(ts&lt;/span&gt;-&amp;gt;&lt;span&gt;connfd);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in servaddr, cliaddr;
    socklen_t cliaddr_len;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; listenfd, connfd;
    pthread_t tid;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; s_info ts[&lt;span&gt;256&lt;/span&gt;];      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据最大线程数创建结构体数组.&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    listenfd &lt;/span&gt;= Socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个socket, 得到lfd&lt;/span&gt;
&lt;span&gt;
    bzero(&lt;/span&gt;&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;(servaddr));                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址结构清零&lt;/span&gt;
    servaddr.sin_family =&lt;span&gt; AF_INET;
    servaddr.sin_addr.s_addr &lt;/span&gt;= htonl(INADDR_ANY);                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定本地任意IP&lt;/span&gt;
    servaddr.sin_port = htons(SERV_PORT);                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定端口号 8000&lt;/span&gt;
&lt;span&gt;
    Bind(listenfd, (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;(servaddr)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定&lt;/span&gt;
&lt;span&gt;
    Listen(listenfd, &lt;/span&gt;&lt;span&gt;128&lt;/span&gt;);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置同一时刻链接服务器上限数&lt;/span&gt;
&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accepting client connect ...\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        cliaddr_len &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cliaddr);
        connfd &lt;/span&gt;= Accept(listenfd, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;cliaddr, &amp;amp;cliaddr_len);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞监听客户端链接请求&lt;/span&gt;
        ts[i].cliaddr =&lt;span&gt; cliaddr;
        ts[i].connfd &lt;/span&gt;=&lt;span&gt; connfd;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        pthread_create(&lt;/span&gt;&amp;amp;tid, NULL, do_work, (&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;ts[i]);
        pthread_detach(tid);                                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子线程分离,防止僵线程产生.&lt;/span&gt;
        i++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　客户端代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c3b59190-c589-4778-ab05-694ed09c6826')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_c3b59190-c589-4778-ab05-694ed09c6826&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c3b59190-c589-4778-ab05-694ed09c6826&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c3b59190-c589-4778-ab05-694ed09c6826',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c3b59190-c589-4778-ab05-694ed09c6826&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; client.c &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; MAXLINE 80
&lt;span&gt;#define&lt;/span&gt; SERV_PORT 8000

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in servaddr;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; buf[MAXLINE];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sockfd, n;

    sockfd &lt;/span&gt;= Socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    bzero(&lt;/span&gt;&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));
    servaddr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    inet_pton(AF_INET, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;servaddr.sin_addr.s_addr);
    servaddr.sin_port &lt;/span&gt;=&lt;span&gt; htons(SERV_PORT);

    Connect(sockfd, (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;servaddr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(servaddr));

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (fgets(buf, MAXLINE, stdin) !=&lt;span&gt; NULL) {
        Write(sockfd, buf, strlen(buf));
        n &lt;/span&gt;=&lt;span&gt; Read(sockfd, buf, MAXLINE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the other side has been closed.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            Write(STDOUT_FILENO, buf, n);
    }

    Close(sockfd);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　三、select实现并发服务器&lt;/h3&gt;
&lt;p&gt;　　select和进程主要区别在于，进程是阻塞的，而select是交给内核自己来实现的，由于select比较复杂，参考我的另一篇博客：https://www.cnblogs.com/liudw-0215/p/9661583.html&lt;/p&gt;
&lt;p&gt;　　总结：有不懂的，欢迎及时评论。&lt;/p&gt;







</description>
<pubDate>Wed, 19 Sep 2018 05:55:00 +0000</pubDate>
<dc:creator>柳德维</dc:creator>
<og:description>前言：刚开始学网络编程，都会先写一个客户端和服务端，不知道你们有没有试一下：再打开一下客户端，是连不上服务端的。还有一个问题不知道你们发现没：有时启服务器，会提示“Address already in</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudw-0215/p/9664204.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S1E8：三十种架构设计模式（下） - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/9674123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/9674123.html</guid>
<description>&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;朱晔的互联网架构实践心得S1E8：三十种架构设计模式（下）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;【&lt;a href=&quot;https://files.cnblogs.com/files/lovecindywang/ZHUYE_ARCH_S1E8.pdf&quot; target=&quot;_blank&quot;&gt;下载本文PDF进行阅读&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;接上文，继续剩下的15个模式。&lt;/p&gt;

&lt;h3&gt;16、分片模式：将数据存储区划分为一组水平分区或分片&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133528886-741474710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133536127-874969676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133541619-861773182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一直有一个说法就是不到没路可走的时候不要考虑数据库分片。有的时候业务量大到单个业务表在经过缓存+队列削峰等措施之后的平均的TPS超过1万，单表实在是扛不住，还是只能考虑分片手段。&lt;/p&gt;
&lt;p&gt;分片前：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要根据数据分布、压力情况、业务逻辑确定分片的方式，按照条件还是范围还是哈希等等（三个图展示了三种策略）。&lt;/li&gt;
&lt;li&gt;需要进行业务代码改造，改掉所有不允许的SQL。&lt;/li&gt;
&lt;li&gt;需要确定用HardCode方式还是框架方式还是中间件方式做数据路由。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分片后：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要有运维工具可以对这么多套分片的数据进行统一的加索引等操作。&lt;/li&gt;
&lt;li&gt;最好有数据仓库可以汇总所有数据，使得adhoc查询可以更方便。&lt;/li&gt;
&lt;li&gt;最好有辅助工具可以用来帮助定位数据会在哪个分片中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;17、静态内容托管模式：将静态内容部署到基于云的存储服务，可以将它们直接传递给客户端&lt;/h3&gt;

&lt;p&gt;相信互联网公司90%+肯定都使用了这个模式。把静态资源从动态网站中剥离由Nginx等高性能服务器来处理静态资源，然后使用三方CDN对静态资源进行加速，不但减轻了动态网站的负载而且数据在边缘节点加速让用户的访问跟快，使用单独的一个或多个子域名做静态资源还能提高下载资源的并行度提高网页加载的速度。&lt;/p&gt;
&lt;p&gt;使用CDN来进行资源加速一般有主动数据传送到CDN存储和在CDN配置回源站拉取两种方式，文件类一般使用主动推送数据，静态资源类一般使用回源方式。在使用CDN的时候考虑下面的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CDN以什么方式来认定同一个文件的，CDN提供了什么工具来刷新边缘节点的缓存？根据不同的策略做相应的缓存刷新方案。&lt;/li&gt;
&lt;li&gt;源站对于相同的文件需要有一致性（最好版本变化后文件名变化），不能今天是这个版本明天是另一个版本，这样很可能导致边缘节点缓存了不同版本的文件，导致各种怪问题。&lt;/li&gt;
&lt;li&gt;使用了CDN后不同地区的用户访问的都是CDN节点上的数据，一旦出现问题排查比较困难，考虑引入前端的错误处理框架来记录前端出现脚本错误时的调用栈，方便定位问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;18、索引表模式：为查询经常引用的数据存储区中的字段创建索引&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133615205-2143997060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第三第五两篇文章中我都提到了索引表的做法。出于下面的原因，我们会考虑索引表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虽然我们的关系型数据库大多支持主键之外的非聚集索引，但是在某些情况下直接对大表做很多索引性能并不好。&lt;/li&gt;
&lt;li&gt;做了Sharding后我们确实没有办法以分片键之外的维度来查询数据。&lt;/li&gt;
&lt;li&gt;希望以空间换时间，直接把某个维度的复合查询作为主键单独保存一份数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过需要考虑一点索引只有在数据区分度高的情况下才能发挥价值，如果90%以上的数据都是相同的值，那么走索引进行查询性能会比全表扫还要差一点。&lt;/p&gt;


&lt;h3&gt;19、前端专用的后端模式：通过使用单独的接口来分离读取数据和更新数据的操作&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133622569-1145389556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里说的是不同的前端配以不同的专用后端。比如PC网站和APP的后端是两套程序。这种模式是否适合其实还是看两端的后端提供的数据差异有多大，我们总是希望可以尽量统一一套后端，业务逻辑不用重复写，但是我们要考虑到PC网站和APP的差异性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;APP系统的接口交互一般会签名验证，有的时候还会加密&lt;/li&gt;
&lt;li&gt;PC系统的流程一般和APP系统不一样&lt;/li&gt;
&lt;li&gt;PC一个页面能显示的内容会比APP一个界面显示的更多&lt;/li&gt;
&lt;li&gt;安全性设计上PC和APP不一样，APP很少有图形验证码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑到这些差异，我们是在一个工程内根据来源做适配，还是独立两套工程来做独立的后端取决于差异度有多大了。&lt;/p&gt;

&lt;h3&gt;20、计算资源整合模式：将多个任务或操作整合到单个计算单元中&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133628689-556178442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个模式从资源节省的角度来说我们的计算单元任务可以进行一些合并，减少因为资源限制导致不必要的开销。&lt;/p&gt;

&lt;h3&gt;21、选举模式：通过选举一个实例作为负责管理其它实例的负责人，来协调分布式应用程序中的协作任务实例集合执行的操作&lt;/h3&gt;
&lt;p&gt;对于分布式服务，我们趋向于把服务设计为无状态可以任意扩展的，但是在某些业务场景下我们不得不在服务中选举出一个Leader（Primary节点，Master节点）来做一些不适合重复做的协调管理工作。这个时候我们需要有算法来做选举。&lt;/p&gt;
&lt;p&gt;最常见的实现方式是使用Zookeeper来实现，我们知道ZK的znode有Sequence和NonSequence两种，前者多个客户端只有一个可创建成功同名节点，后者创建后会自动加上序列号命名多个客户端可以创建多个同名节点，利用这个特性有两种常见实现方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非公平实现。多个客户端同时创建EPHEMERAL+NONSEQUENCE节点。只有一个可以创建成功，创建成功的就是Leader，其它的Follower需要注册watch，一旦Leader放弃节点（注意，EPHEMERAL意味着Leader待机后Session结束节点被删除），再一次重复之前的过程注册节点抢占成为Leader。这个模式实现简单，问题是在节点数量过多的时候一旦发生重新竞选，这个时候可能会有性能问题。&lt;/li&gt;
&lt;li&gt;公平实现。多个客户端同时创建EPHEMERAL+SEQUENCE节点。客户端都可以创建成功节点，客户端如果判断自己是最小的节点则为Leader否则为Follower。每一个Follower都去watch序号比自己小的节点（大家都看前一位）。一旦有Leader节点因为宕机被删除（还是EPHEMERAL特性），收到通知的节点会看自己是不是最小的序号，如果是的话成为Leader。节点宕机后，原先watch宕机节点的客户端重新watch比自己序号小的有效节点。这个模式实现复杂，但是由于watch的都只是一个节点所以不会发生像非公平实现的性能问题，而且竞选根据节点序号来而不是抢占式所以显得Leader的选举公平有序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;22、管道和过滤器模式：将需要执行复杂处理的任务分解成可以重复使用的一系列单独的元素&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133636824-1944620268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在软件设计模式中过滤器构成的管道这种模式很常见（图上的业务逻辑就是Handler，之前的那些Task就是Filter，模式上可以是Filter+Handler也可以是Filter+Handler+Filter也可以是Handler+Filter），不管是Spring MVC框架也好，Netty这种网络框架也好都提供了这样的设计。每一个过滤器单独完成一个功能，可以独立插拔随意组合配置成一套管道，不但数据处理的整个过程清晰可见还增加了灵活性。&lt;/p&gt;
&lt;p&gt;对于架构上也可以有这样的模式，在数据源进入到业务逻辑处理之前（或之后，或前后），我们可以配置一系列的数据过滤器完成各种数据转化和处理的任务。Task和Task之间可以是同步调用，也可以使用MQ做一定的可伸缩性设计。还可以把过滤器的配置信息保存在配置系统中甚至根据上下文动态构建出管道，实现更灵活的前置或后置流程处理。&lt;/p&gt;


&lt;h3&gt;23、竞争消费者模式：使用多个并发消费者来处理在同一消息通道上接收的消息&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133645012-967320634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里说的是消息队列的消息消费者是一组对等的消费者，通过竞争方式来拉取数据执行。之前提到过这是MQ的最常见的一种模式，一般而言我们会部署多个消费节点进行负载均衡，在负载较大的时候可以方便得增加消费者进行消费能力扩容。不过对于这种模式消费者应当是对等的无状态的，在某个消费者在消费失败的时候消息重新回到队列随后可能会被另一个消费者进行处理。&lt;/p&gt;

&lt;h3&gt;24、重试模式：在应用程序尝试连接到服务或网络资源遇到预期的临时故障时，让程序通过透明地重试以前失败的操作来处理&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133650432-1398571197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重试适用于瞬态故障，之后会提到断路器模式，两种模式可以结合使用。首先说说重试的几个发起人：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让用户自己发起，遇到错误的时候及时返回错误信息，让用户自己稍后重试整个业务功能。这种方式不容易产生瞬时的压力，但是体验较差。&lt;/li&gt;
&lt;li&gt;在中间件自动发起，比如在RPC调用的时候遇到服务超时自动进行一定次数的重试，这样可以在外部没有感知的情况下有一定概率消除错误。这个方式要求服务是支持重试的。&lt;/li&gt;
&lt;li&gt;由业务逻辑手动发起，不同的业务逻辑根据需求在代码中去写重试的逻辑（当然也可以通过类似Spring-Retry这种组件来做）。实现繁琐但是不容易出错。&lt;/li&gt;
&lt;li&gt;由补偿逻辑发起进行同步转异步操作，非重要逻辑同步行则行，不行不在主流程重试，由单独的异步流程进行重试补偿。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;重试也要考虑几种策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;次数。最多重试几次。&lt;/li&gt;
&lt;li&gt;异常。遇到什么样的异常（黑白名单）应该去重试。&lt;/li&gt;
&lt;li&gt;等待。考虑每次重试是相同的间隔呢还是有一个延迟的递增，随着重试次数增加而增加延时时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;25、调度、代理、主管模式：在一组分布式服务和其它远程资源之间协调一组操作&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133655923-2000969153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个模式说的是三者的角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调度负责安排任务，在执行每个步骤的时候维护任务的状态，具体业务逻辑由代理负责。&lt;/li&gt;
&lt;li&gt;代理负责和远程的服务和资源进行通讯，实现错误处理和重试。&lt;/li&gt;
&lt;li&gt;管理者负责监视任务的执行状态，作为调度的补充，在合适的时候要求调度进行补偿。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三个角色相互配合完成复杂的，具有较多远程服务参与的任务，确保任务的最终有效执行。在之前架构三马车一文中说到定时任务的时候提到过一种任务驱动表的模式，说到了一些驱动表的实现细节，其实整体和这个模式是类似的思想。当我们的一个复杂逻辑有多个步骤构成，每一步都依赖外部服务，这个时候我们可以选择全程MQ+补偿方式（乐观方式），也可以选择全程任务驱动的被动模式（悲观方式），具体选择取决于更看重可靠性还是及时性。&lt;/p&gt;


&lt;h3&gt;26、舱壁模式：将应用程序的元素隔离到池中，如果其中一个失败，其它的将继续运行&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133702096-609478853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;资源隔离有好几个层次，可以在进程内部做线程池或队列的隔离，在微服务的服务划分上考虑隔离出单独的物理服务，或是在服务器层面通过虚拟化技术或Docker技术进行资源隔离。隔离了就不会相互影响，但是会有成本、性能、管理便利性方面的开销。实现能够根据需求分析出可能的资源相互影响的点，提前规划隔离往往可以避免很多问题的发生。之前有遇到过几个事故是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序内部大量使用了Java8的ParallelStream特性进行并行处理，由于默认共享了相同的线程池，某一个业务的执行占满了线程影响了其它业务的正常进行。&lt;/li&gt;
&lt;li&gt;消息队列因为没有对执行过多次失败的死信消息和正常的新消息进行隔离，导致一些业务下线后无法处理的死消息占满了整个队列，正常消息无法消费。&lt;/li&gt;
&lt;li&gt;某个服务提供了类似文件上传的重量级操作，也提供了数据查询的轻量级操作，在上传业务大的时候服务的线程都被IO所占满，导致其它查询操作无法进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;27、断路器模式：连接到远程服务或资源时, 处理可能需要花费时间来修复的故障&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133707073-1121577108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分布式应用环节多网络环境复杂，如果遇到依赖服务调用失败的情况我们或许可以进行重试期待服务马上可以恢复，但是在某些时候依赖的服务是彻底挂了而不是网络故障无法及时恢复，如果不考虑进行熔断的，可能服务调用方会被服务提供方拖死。这个时候可以引入断路器机制，如图所示断路器一般采用三态实现，瞬间恢复可能会让底层服务压力过大：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关闭：出现错误的时候增加计数器&lt;/li&gt;
&lt;li&gt;打开：计数器到达阈值打开断路器，直接返回错误&lt;/li&gt;
&lt;li&gt;半开：超时后允许一定的请求通过，成功率达到阈值关闭断路器，操作还是失败的话还是进入打开状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现模式的时候考虑下面注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;考虑熔断后怎么来处理，熔断后我们肯定拿不到实际的处理结果，这个时候考虑是功能降级还是采用后备的数据提供方来提供数据&lt;/li&gt;
&lt;li&gt;紧急的时候需要人工介入，最好在外部提供手动的方式可以干预断路器的三态&lt;/li&gt;
&lt;li&gt;不同的业务考虑不同的断路器打开阈值，每一个错误还能有不同的权重，比如对于下游程序返回了太多请求的错误，每次错误可以+2提高权重尽可能早断路&lt;/li&gt;
&lt;li&gt;断路器应当记录熔断时的请求原始信息，在之后必要的时候可以进行重放或数据修复工作&lt;/li&gt;
&lt;li&gt;注意设置好外部服务的超时，如果客户端超时比服务端短，很可能进行错误的熔断&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现上我们可以看一下Netflix的Hystrix进行进一步了解。&lt;/p&gt;

&lt;h3&gt;28、事务补偿模式：撤消通过一系列步骤执行的工作，它们一起定义最终一致的操作&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133713486-1907372429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个模式说的是失败时必须进行撤销的操作，可以由一组补偿程序来做相应的补偿。在这里我想说的更广一点，在服务调用的时候，调用失败有几种可能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求客户端发出但是没到服务端，业务逻辑没有执行&lt;/li&gt;
&lt;li&gt;请求客户端发出服务端收到也处理成功了，业务逻辑执行了客户端没收到结果&lt;/li&gt;
&lt;li&gt;请求客户端发出服务端收到但处理失败了，客户端没收到结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以在出现服务调用失败或超时的时候，服务端执行究竟有没有成功客户端是不明确的（只有客户端收到了明确的服务端返回的业务错误才真正代表执行失败），这个时候需要有补偿逻辑来同步服务端的执行状态。如果这样的补偿不可避免而且需要补偿的服务特别多，这样的逻辑逐一来写是一件很烦的事情，我们可以把这个工作封装成一个补偿中间件来处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有关键服务调用标记为需要自动补偿&lt;/li&gt;
&lt;li&gt;补偿中间件在数据库记录服务的调用状态&lt;/li&gt;
&lt;li&gt;关键服务的提供者提供统一状态查询接口，消费者提供统一的补偿回调接口（来处理成功和失败的情况）&lt;/li&gt;
&lt;li&gt;补偿中间件根据数据库的记录调用服务提供方的状态查询和服务消费方的补偿回调接口进行补偿&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样，我们在服务调用的时候就不需要考虑补偿逻辑的实现，只要实现这个标准即可。&lt;/p&gt;


&lt;h3&gt;29、代客密钥模式：使用向客户端提供对特定资源或服务的有限直接访问权限的令牌或密钥&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133720207-450824554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个模式说的是，在访问敏感资源的时候，我们可以不必让应用程序在其中作为一个代理转一层做权限控制，而是生成一个密钥，让用户直接拿着密钥到资源池换数据。&lt;/p&gt;
&lt;p&gt;一些CDN在提供资源上传下载服务的时候一般都会提供类似的安全策略，需要实现生成Token才能去使用下载和上传服务，避免了CDN数据被非法利用作为图床的可能。&lt;/p&gt;
&lt;p&gt;实现上比较简单，应用程序和资源提供方约定好Token的生成算法，对资源+请求资源的时间+密钥联合在一起做签名，资源提供方如果校验到签名不正确或Token过期或资源不匹配都将拒绝服务。&lt;/p&gt;

&lt;h3&gt;30、联合身份模式：将认证委托给外部身份提供者&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180919133725694-1696379191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个模式说的是将身份验证委托给专门的程序或模块来做。使用专门的模块来统一负责登录授权不仅仅可以提供单点登录的功能，而且服务实现上更简单不需要每次都考虑登录那套东西。实现上可以看一下Spring Security实现的OAuth 2.0。&lt;/p&gt;

&lt;p&gt;总结一下，对于其中的很多模式，我们可以发现其实在之前的一些介绍或多或少有一些涉及。这里提到的30种模式有些体现的是一些设计细节，有些体现的是一种设计理念，它们大多时候是组合使用的，适合的就是最好的，大家可以细细品味一下每种模式的适合场景，在合适的时候可以想到它或许会有一种豁然开朗的感觉。&lt;/p&gt;

</description>
<pubDate>Wed, 19 Sep 2018 05:38:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>朱晔的互联网架构实践心得S1E8：三十种架构设计模式（下） 朱晔的互联网架构实践心得S1E8：三十种架构设计模式（下） 【下载本文PDF进行阅读】 接上文，继续剩下的15个模式。 数据管理模式 数据管</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/9674123.html</dc:identifier>
</item>
</channel>
</rss>