<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>以中间件，路由，跨进程事件的姿势使用WebSocket - 若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9912166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9912166.html</guid>
<description>&lt;p&gt;通过参考koa中间件，socket.io远程事件调用，以一种新的姿势来使用WebSocket。&lt;/p&gt;
&lt;h2 id=&quot;浏览器端&quot;&gt;浏览器端&lt;/h2&gt;
&lt;p&gt;浏览器端使用WebSocket很简单&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket&quot;&gt;MDN&lt;/a&gt;关于WebSocket的介绍&lt;/p&gt;
&lt;p&gt;能注册的事件有onclose，onerror，onmessage，onopen。用的比较多的是onmessage，从服务器接受到数据后，会触发message事件。通过注册相应的事件处理函数，可以根据后端推送的数据做相应的操作。&lt;/p&gt;
&lt;p&gt;如果只是写个demo,单单输出后端推送的信息,如下使用即可：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际使用过程中，我们需要判断后端推送的数据然后执行相应的操作。比如聊天室应用中，需要判断消息是广播的还是私聊的或者群聊的，以及是纯文字信息还是图片等多媒体信息。这时message处理函数里可能就是一堆的if else。那么有没有什么别的优雅的姿势呢？答案就是中间件与事件，跨进程的事件的发布与订阅。在说远程事件发布订阅之前，需要先从中间件开始，因为后面实现的远程事件发布订阅是基于中间件的。&lt;/p&gt;
&lt;h2 id=&quot;中间件&quot;&gt;中间件&lt;/h2&gt;
&lt;p&gt;前面说了，在WebSocket实例上可以注册事件有onclose，onerror，onmessage，onopen。每一个事件的处理函数里可能需要做各种判断，特别是message事件。参考koa，可以将事件处理函数以中间件方式来进行使用，将不同的操作逻辑分发到不同的中间件中，比如聊天室应用中，聊天信息与系统信息(比如用户登录属于系统信息)是可以放到不同的中间件中处理的。&lt;/p&gt;
&lt;p&gt;koa提供use接口来注册中间件。我们针对不同的事件提供相应的中间件注册接口，并且对原生的WebSocket做封装。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default class EasySocket{
    constructor(config) {
       this.url = config.url;
       this.openMiddleware = [];
       this.closeMiddleware = [];
       this.messageMiddleware = [];
       this.errorMiddleware = [];
       
       this.openFn = Promise.resolve();
       this.closeFn = Promise.resolve();
       this.messageFn = Promise.resolve();
       this.errorFn = Promise.resolve();
    }
    openUse(fn) {
        this.openMiddleware.push(fn);
        return this;
    }
    closeUse(fn) {
        this.closeMiddleware.push(fn);
        return this;
    }
    messageUse(fn) {
        this.messageMiddleware.push(fn);
        return this;
    }
    errorUse(fn) {
        this.errorMiddleware.push(fn);
        return this;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;xxxUse&lt;/code&gt;注册相应的中间件。 &lt;code&gt;xxxMiddleware&lt;/code&gt;中就是相应的中间件。&lt;code&gt;xxxFn&lt;/code&gt; 中间件通过compose处理后的结构&lt;/p&gt;
&lt;p&gt;再添加一个connect方法，处理相应的中间件并且实例化原生WebSocket&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;connect(url) {
        this.url = url || this.url;
        if (!this.url) {
            throw new Error('url is required!');
        }
        try {
            this.socket = new WebSocket(this.url, 'echo-protocol');
        } catch (e) {
            throw e;
        }

        this.openFn = compose(this.openMiddleware);
        this.socket.addEventListener('open', (event) =&amp;gt; {
            let context = { client: this, event };
            this.openFn(context).catch(error =&amp;gt; { console.log(error) });
        });

        this.closeFn = compose(this.closeMiddleware);
        this.socket.addEventListener('close', (event) =&amp;gt; {
            let context = { client: this, event };
            this.closeFn(context).then(() =&amp;gt; {
            }).catch(error =&amp;gt; {
                console.log(error)
            });
        });

        this.messageFn = compose(this.messageMiddleware);
        this.socket.addEventListener('message', (event) =&amp;gt; {
            let res;
            try {
                res = JSON.parse(event.data);
            } catch (error) {
                res = event.data;
            }
            let context = { client: this, event, res };
            this.messageFn(context).then(() =&amp;gt; {

            }).catch(error =&amp;gt; {
                console.log(error)
            });
        });

        this.errorFn = compose(this.errorMiddleware);
        this.socket.addEventListener('error', (event) =&amp;gt; {
            let context = { client: this, event };
            this.errorFn(context).then(() =&amp;gt; {

            }).catch(error =&amp;gt; {
                console.log(error)
            });
        });
        return this;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;a href=&quot;https://github.com/koajs/compose&quot;&gt;koa-compose&lt;/a&gt;模块处理中间件。注意context传入了哪些东西，后续定义中间件的时候都已使用。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0588235294118&quot;&gt;
&lt;p&gt;compose的作用可看这篇文章 &lt;a href=&quot;https://juejin.im/post/5bd7238d51882579201028b0&quot;&gt;傻瓜式解读koa中间件处理模块koa-compose&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后就可以使用了：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new EasySocket()
  .openUse((context, next) =&amp;gt; {
    console.log(&quot;open&quot;);
    next();
  })
  .closeUse((context, next) =&amp;gt; {
    console.log(&quot;close&quot;);
    next();
  })
  .errorUse((context, next) =&amp;gt; {
    console.log(&quot;error&quot;, context.event);
    next();
  })
  .messageUse((context, next) =&amp;gt; {
    //用户登录处理中间件
    if (context.res.action === 'userEnter') {
      console.log(context.res.user.name+' 进入聊天室');
    }
    next();
  })
  .messageUse((context, next) =&amp;gt; {
    //创建房间处理中间件
    if (context.res.action === 'createRoom') {
      console.log('创建房间 '+context.res.room.anme);
    }
    next();
  })
  .connect('ws://localhost:8080')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，用户登录与创建房间的逻辑放到两个中间件中分开处理。不足之处就是每个中间件都要判断context.res.action，而这个context.res就是后端返回的数据。怎么消除这个频繁的if判断呢? 我们实现一个简单的消息处理路由。&lt;/p&gt;
&lt;h2 id=&quot;路由&quot;&gt;路由&lt;/h2&gt;
&lt;p&gt;定义消息路由中间件&lt;/p&gt;
&lt;p&gt;messageRouteMiddleware.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default (routes) =&amp;gt; {
    return async (context, next) =&amp;gt; {
        if (routes[context.req.action]) {
            await routes[context.req.action](context,next);
        } else {
            console.log(context.req)
            next();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义路由&lt;/p&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default {
    userEnter:function(context,next){
        console.log(context.res.user.name+' 进入聊天室');
        next();
    },
    createRoom:function(context,next){
        console.log('创建房间 '+context.res.room.anme);
        next();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new EasySocket()
  .openUse((context, next) =&amp;gt; {
    console.log(&quot;open&quot;);
    next();
  })
  .closeUse((context, next) =&amp;gt; {
    console.log(&quot;close&quot;);
    next();
  })
  .errorUse((context, next) =&amp;gt; {
    console.log(&quot;error&quot;, context.event);
    next();
  })
  .messageUse(messageRouteMiddleware(router))//使用消息路由中间件，并传入定义好的路由
  .connect('ws://localhost:8080')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一切都变得美好了，感觉就像在使用koa。想一个问题，当接收到后端推送的消息时，我们需要做相应的DOM操作。比如路由里面定义的userEnter，我们可能需要在对应的函数里操作用户列表的DOM，追加新用户。这使用原生JS或JQ都是没有问题的，但是如果使用vue,react这些，因为是组件化的，用户列表可能就是一个组件，怎么访问到这个组件实例呢？(当然也可以访问vuex,redux的store,但是并不是所有组件的数据都是用store管理的)。&lt;/p&gt;
&lt;p&gt;我们需要一个运行时注册中间件的功能，然后在组件的相应的生命周期钩子里注册中间件并且传入组件实例&lt;/p&gt;
&lt;p&gt;运行时注册中间件，修改如下代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;messageUse(fn, runtime) {
        this.messageMiddleware.push(fn);
        if (runtime) {
            this.messageFn = compose(this.messageMiddleware);
        }
        return this;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 messageRouteMiddleware.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default (routes,component) =&amp;gt; {
    return async (context, next) =&amp;gt; {
        if (routes[context.req.action]) {
            context.component=component;//将组件实例挂到context下
            await routes[context.req.action](context,next);
        } else {
            console.log(context.req)
            next();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似vue mounted中使用&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;mounted(){
  let client = this.$wsClients.get(&quot;im&quot;);//获取指定EasySocket实例
  client.messageUse(messageRouteMiddleware(router,this),true)//运行时注册中间件，并传入定义好的路由以及当前组件中的this
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由中通过 context.component 即可访问到当前组件。&lt;/p&gt;
&lt;p&gt;完美了吗？每次组件mounted 都注册一次中间件，问题很大。所以需要一个判断中间件是否已经注册的功能。也就是一个支持具名注册中间件的功能。这里就暂时不实现了，走另外一条路，也就是之前说到的远程事件的发布与订阅，我们也可以称之为跨进程事件。&lt;/p&gt;
&lt;h2 id=&quot;跨进程事件&quot;&gt;跨进程事件&lt;/h2&gt;
&lt;p&gt;看一段socket.io的代码：&lt;/p&gt;
&lt;p&gt;Server (app.js)&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var app = require('http').createServer(handler)
var io = require('socket.io')(app);
var fs = require('fs');
app.listen(80);
function handler (req, res) {
  fs.readFile(__dirname + '/index.html',
  function (err, data) {
    if (err) {
      res.writeHead(500);
      return res.end('Error loading index.html');
    }

    res.writeHead(200);
    res.end(data);
  });
}
io.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Client (index.html)&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;script src=&quot;/socket.io/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  var socket = io('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意力转到这两部分：&lt;/p&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var socket = io('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用事件，客户端通过on订阅'news'事件，并且当触发‘new’事件的时候通过emit发布'my other event'事件。服务端在用户连接的时候发布'news'事件，并且订阅'my other event'事件。&lt;/p&gt;
&lt;p&gt;一般我们使用事件的时候，都是在同一个页面中on和emit。而socket.io的神奇之处就是同一事件的on和emit是分别在客户端和服务端，这就是跨进程的事件。&lt;/p&gt;
&lt;p&gt;那么，在某一端emit某个事件的时候，另一端如果on监听了此事件，是如何知道这个事件emit(发布)了呢？&lt;/p&gt;
&lt;p&gt;没有看socket.io源码之前，我设想应该是emit方法里做了某些事情。就像java或c#，实现rpc的时候，可以依据接口定义动态生成实现(也称为代理)，动态实现的(代理)方法中，就会将当前方法名称以及参数通过相应协议进行序列化，然后通过http或者tcp等网络协议传输到RPC服务端，服务端进行反序列化，通过反射等技术调用本地实现，并返回执行结果给客户端。客户端拿到结果后，整个调用完成，就像调用本地方法一样实现了远程方法的调用。&lt;/p&gt;
&lt;p&gt;看了socket.io emit的代码实现后，思路也是大同小异，通过将当前emit的事件名和参数按一定规则组合成数据，然后将数据通过WebSocket的send方法发送出去。接收端按规则取到事件名和参数，然后本地触发emit。(注意远程emit和本地emit，socket.io中直接调用的是远程emit)。&lt;/p&gt;
&lt;p&gt;下面是实现代码，事件直接用的&lt;a href=&quot;https://github.com/component/emitter&quot;&gt;emitter&lt;/a&gt;模块，并且为了能自定义emit事件名和参数组合规则，以中间件的方式提供处理方法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default class EasySocket extends Emitter{//继承Emitter
    constructor(config) {
       this.url = config.url;
       this.openMiddleware = [];
       this.closeMiddleware = [];
       this.messageMiddleware = [];
       this.errorMiddleware = [];
       this.remoteEmitMiddleware = [];//新增的部分
       
       this.openFn = Promise.resolve();
       this.closeFn = Promise.resolve();
       this.messageFn = Promise.resolve();
       this.errorFn = Promise.resolve();
       this.remoteEmitFn = Promise.resolve();//新增的部分
    }
    openUse(fn) {
        this.openMiddleware.push(fn);
        return this;
    }
    closeUse(fn) {
        this.closeMiddleware.push(fn);
        return this;
    }
    messageUse(fn) {
        this.messageMiddleware.push(fn);
        return this;
    }
    errorUse(fn) {
        this.errorMiddleware.push(fn);
        return this;
    }
    //新增的部分
    remoteEmitUse(fn, runtime) {
        this.remoteEmitMiddleware.push(fn);
        if (runtime) {
            this.remoteEmitFn = compose(this.remoteEmitMiddleware);
        }
        return this;
    }
    connect(url) {
       ...
       //新增部分
       this.remoteEmitFn = compose(this.remoteEmitMiddleware);
    }
    //重写emit方法，支持本地调用以远程调用
    emit(event, args, isLocal = false) {
        let arr = [event, args];
        if (isLocal) {
            super.emit.apply(this, arr);
            return this;
        }
        let evt = {
            event: event,
            args: args
        }
        let remoteEmitContext = { client: this, event: evt };
        this.remoteEmitFn(remoteEmitContext).catch(error =&amp;gt; { console.log(error) })
        return this;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个简单的处理中间件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;client.remoteEmitUse((context, next) =&amp;gt; {
    let client = context.client;
    let event = context.event;
    if (client.socket.readyState !== 1) {
      alert(&quot;连接已断开!&quot;);
    } else {
      client.socket.send(JSON.stringify({
        type: 'event',
        event: event.event,
        args: event.args
      }));
      next();
    }
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意味着调用&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;client.emit('chatMessage',{
    from:'admin',
    masg:&quot;Hello WebSocket&quot;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就会组合成数据&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    type: 'event',
    event: 'chatMessage',
    args: {
        from:'admin',
        masg:&quot;Hello WebSocket&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送出去。&lt;/p&gt;
&lt;p&gt;服务端接受到这样的数据，可以做相应的数据处理（后面会使用nodejs实现类似的编程模式），也可以直接发送给别的客户端。客户受到类似的数据，可以写专门的中间件进行处理，比如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;client.messageUse((context, next) =&amp;gt; {
    if (context.res.type === 'event') {
      context.client.emit(context.res.event, context.res.args, true);//注意这里的emit是本地emit。
    }
    next();
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果本地订阅的chatMessage事件，回到函数就会被触发。&lt;/p&gt;
&lt;p&gt;在vue或react中使用，也会比之前使用路由的方式简单&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;mounted() {
   let client = this.$wsClients.get(&quot;im&quot;);
   client.on(&quot;chatMessage&quot;, data =&amp;gt; {
      let isSelf = data.from.id == this.user.id;
      let msg = {
        name: data.from.name,
        msg: data.msg,
        createdDate: data.createdDate,
        isSelf
      };
      this.broadcastMessageList.push(msg);
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件销毁的时候移除相应的事件订阅即可，或者清空所有事件订阅&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;destroyed() {
    let client = this.$wsClients.get(&quot;im&quot;);
    client.removeAllListeners();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;心跳重连&quot;&gt;心跳重连&lt;/h2&gt;
&lt;p&gt;核心代码直接从&lt;a href=&quot;https://github.com/zimv/websocket-heartbeat-js&quot;&gt;websocket-heartbeat-js&lt;/a&gt; copy过来的(用npm包，还得在它的基础上再包一层)，相关文章 &lt;a href=&quot;https://www.cnblogs.com/1wen/p/5808276.html&quot;&gt;初探和实现websocket心跳重连&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    heartCheck() {
        this.heartReset();
        this.heartStart();
    }
    heartStart() {
        this.pingTimeoutId = setTimeout(() =&amp;gt; {
            //这里发送一个心跳，后端收到后，返回一个心跳消息
            this.socket.send(this.pingMsg);
            //接收到心跳信息说明连接正常,会执行heartCheck(),重置心跳(清除下面定时器)
            this.pongTimeoutId = setTimeout(() =&amp;gt; {
                //此定时器有运行的机会，说明发送ping后，设置的超时时间内未收到返回信息
                this.socket.close();//不直接调用reconnect，避免旧WebSocket实例没有真正关闭，导致不可预料的问题
            }, this.pongTimeout);
        }, this.pingTimeout);
    }
    heartReset() {
        clearTimeout(this.pingTimeoutId);
        clearTimeout(this.pongTimeoutId);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/wjkang/easy-socket-browser&quot;&gt;easy-socket-browser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nodejs实现的类似的编程模式(有空再细说)：&lt;a href=&quot;https://github.com/wjkang/easy-socket-node&quot;&gt;easy-socket-node&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现的聊天室例子：&lt;a href=&quot;http://jaycewu.coding.me/easy-socket-chat/#/&quot;&gt;online chat demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;聊天室前端源码：&lt;a href=&quot;https://github.com/wjkang/lazy-mock-im&quot;&gt;lazy-mock-im&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;聊天室服务端源码：&lt;a href=&quot;https://github.com/wjkang/lazy-mock/tree/chat&quot;&gt;lazy-mock&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 14:51:00 +0000</pubDate>
<dc:creator>若邪</dc:creator>
<og:description>通过参考koa中间件，socket.io远程事件调用，以一种新的姿势来使用WebSocket。 浏览器端 浏览器端使用WebSocket很简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9912166.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之十 ---- 访问者模式和中介者模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9911997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9911997.html</guid>
<description>&lt;h2 class=&quot;text-danger&quot;&gt;Important Notice&lt;/h2&gt;
&lt;p&gt;Cox Communications has received a notice which claims that someone using your Cox High Speed Internet service has violated U.S. Copyright law by copying or distributing the copyrighted work listed in the complaint. THIS COMPLAINT IS FROM A THIRD PARTY AND NOT FROM COX COMMUNICATIONS. Details of this complaint are available through your &lt;span&gt;&lt;a href=&quot;https://www.cox.com/internet/copyrights.cox&quot; target=&quot;_blank&quot;&gt;customer portal&lt;/a&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We ask that you review the complaint and, if you believe it is valid, promptly take steps to remove or disable access to the infringing material (typically movies, music, books, or TV shows). If other parties are using your account, such as through your WiFi connection, you should ask them to disable file-sharing in peer to peer applications such as BitTorrent, or delete the copyrighted works.&lt;/p&gt;
&lt;p&gt;If you disagree with the claims and believe that no one using your Internet service could have been the source of the alleged infringement, please do not contact Cox Communications to resolve this matter. Cox is simply forwarding the notice to you. However, if you have WiFi, please make sure your WiFi connection is secured with a strong password to prevent unauthorized use of your Internet service. In addition, make sure anti-virus software is installed and up to date to help prevent malware infections.&lt;/p&gt;
&lt;p&gt;The material that you share online or make available for sharing is your responsibility. Cox encourages responsible Internet use, but we do not monitor nor control the information you transmit. We have a policy, however, consistent with the Digital Millennium Copyright Act, to take steps when we receive notifications of claimed infringement. We also have a policy of terminating repeat infringers in compliance with the Digital Millennium Copyright Act Safe Harbor for online service providers.&lt;/p&gt;
&lt;p class=&quot;text-danger&quot;&gt;&lt;strong&gt;If we continue to receive infringement claims notices for your account, we may in appropriate circumstances suspend your account, disable your Internet connection, and/or terminate your Internet service.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For information about Cox's Acceptable Use Policy, including copyright infringement, please refer to:&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cox.com/aboutus/policies.html&quot;&gt;https://www.cox.com/aboutus/policies.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To learn more about your responsibilities concerning copyrighted material, please refer to our help article at:&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cox.com/copyright&quot;&gt;https://www.cox.com/copyright&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;General information &amp;amp; FAQs about DMCA notices:&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.respectcopyrights.org&quot;&gt;http://www.respectcopyrights.org&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.riaa.com/toolsforparents.php?content_selector=resources-music-copyright-notices&quot;&gt;http://www.riaa.com/toolsforparents.php?content_selector=resources-music-copyright-notices&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 05 Nov 2018 14:27:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>http://ibncs.cox.net/ibncs/general/message.cox?uc=DMCA&amp;other_vars=eyJvdGhlcl92YXJzIjpbeyJ1c2VjYXNlbmFtZSI6IkRNQ0EiLCJ2YWx1ZXMiOnsibXNnX2lkIjoiMTQ1MTg1OTE2ZWJiNDA2MTgxZDhkN2Q2MzdlZWZiZjgifX1dfQ==</dc:identifier>
</item>
<item>
<title>Shell编程-01-Shell脚本初步入门 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/9911671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/9911671.html</guid>
<description>&lt;h3 id=&quot;什么是shell&quot;&gt;什么是Shell&lt;/h3&gt;
&lt;p&gt;    简单来说Shell其实就是一个&lt;strong&gt;命令解释器&lt;/strong&gt;，而它的作用就是解释并执行用户输入的命令及程序。用户每输入一条命令，Shell就解释执行一次。这种方式很容易让大家想起在Windows环境中使用的command命令，我们在cmd窗口输入一条命令，按下Enter键，则执行相应的命令和结果。&lt;br/&gt;    &lt;strong&gt;Shell位于操作系统的最外层，对外提供与用户交互式的对话并返回相应的执行结果，对内则是将用户输入的命令解释给操作系统。&lt;/strong&gt;Shell在操作系统中所处的位置如下图所示：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-ba75bb194385aa46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-1 Shell在操作系统的位置.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Shell在英文中的意思就是外壳、贝壳等，从图中也可以看出，Shell就像壳一样包住了系统的核心（Kernel）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shell命令与Command命令对比&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-23a0a410ba2167f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-2 Shell命令与Command命令_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是shell脚本&quot;&gt;什么是Shell脚本&lt;/h3&gt;
&lt;p&gt;    在理解了Shell之后，我们再来看看Shell脚本。当命令或程序语句不是在命令行中执行时，而是通过程序文件来执行时，该程序就称之为Shell脚本，我依然拿Windows来做比例。当我们需要执行比较少的命令时，我们可以一个一个命令的进行手动输入，如果需要执行成百上千的命令时，你会怎么办？聪明的你肯定会脱口而出，用&lt;strong&gt;批处理&lt;/strong&gt;（扩展名一般为bat或cmd）。其实Shell脚本就类似于批处理，通过在脚本中定义变量、执行命令、调用函数和逻辑判断、循环等形成一个有机的整体，便形成一个功能强大、自动化程度较高的脚本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Windows通过批处理获取系统信息保存为txt文件，而后自动打开该文件，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@echo off
set date=%date:~0,4%-%date:~5,2%-%date:~8,2%
echo &quot;当前时间为：&quot;%date%
cd /d &quot;D:\&quot;
mkdir SystemInfo
cd /d &quot;SystemInfo&quot;
systeminfo&amp;gt;systeminfo%date%.txt
start systeminfo%date%.txt
pause&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Shell脚本判断当前登录用户是否为root&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# !/bin/bash
currentName=`whoami`
echo $currentName
if [ &quot;$currentName&quot; = &quot;root&quot; ]
  then
    echo &quot;Current Login User is root&quot;
else
  echo &quot;Current Login User is :&quot;$currentName
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;shell脚本语言的种类&quot;&gt;Shell脚本语言的种类&lt;/h3&gt;
&lt;p&gt;    Shell 脚本语言是&lt;strong&gt;弱类型语言，即无须定义变量类型即可使用&lt;/strong&gt;。在UNIX/Linux中主要有两大类Shell:&lt;strong&gt;Bourne Shell&lt;/strong&gt;和&lt;strong&gt;C Shell&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;bourne-shell&quot;&gt;Bourne Shell&lt;/h4&gt;
&lt;p&gt;    Bourne Shell包括&lt;strong&gt;Bourne Shell（sh）、Korn Shell(ksh)、Bourne Again Shell(bash)&lt;/strong&gt;三种类型。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Bourne Shell&lt;br/&gt;  由AT&amp;amp;T的Steve Bourne开发，是标准的UNIX Shell，很多UNIX系统都配有sh。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Korn Shell(ksh)&lt;br/&gt;  由David Korn开发，是Bournd Shell(sh)的超集合并且添加了csh引入的新功能，是目前很多UNIX系统标配的Shell，这些系统上的/bin/sh往往指向/bin/ksh的符号链接&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Bourne Again Shell(bash)&lt;br/&gt;  由GNU项目组开发，主要目标是与POSIX标准操持一致，同时兼容sh。bash从csh和ksh借鉴了很多功能，是各种Linux发行版本默认配置的Shell。Linux系统上的/bin/sh往往是指向/bin/bash的符号链接。但bash和sh还是有很多不同之处，虽然bash扩展了一些命令和参数，但bash并不完全兼容sh，两者之间有些行为并不一致。在大多数情况下区别不太大，有时还可以使用bash替代sh。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;c-shell&quot;&gt;C Shell&lt;/h4&gt;
&lt;p&gt;    C Shell包括&lt;strong&gt;csh和tcsh&lt;/strong&gt;两种。csh由Berkeley大学开发，随之BSD UNIX发布，它的流程控制语句很像C语言，支持很多Bourne Shell所不支持的功能，如作业控制、别名、系统算术、命令历史、命令行编辑等。tcsh是csh的增强版，加入了命令补全等功能，在FreeBSD、Mac OS X等系统上代替了csh。&lt;br/&gt;    以上介绍的这些Shell中，较为通用的是标准的Bourne Shell（sh）和C Shell(csh)，而其中Bourne Shell(sh)已经被Bourne Again Shell（bash）所取代。可通过以下命令查看CentOS 7.3系统Shell的支持情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 tmp]$ cat /etc/shells
/bin/sh             #Linux常用的Shell,指向/bin/bash
/bin/bash           #Linux常用的Shell,也是默认使用的Shell
/sbin/nologin       #Linux常用的Shell，用于禁止用户登录
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Linux系统中主流的Shell是bash，而bash是由Bourne Shell（sh）发展而来，同时bash还包含了csh和ksh的特色。因此大多数脚本都可以不做修改即可在sh运行，如果使用sh后结果与预期有差异，可以尝试用bash代替sh.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用操作系统默认shell&quot;&gt;常用操作系统默认Shell&lt;/h3&gt;
&lt;p&gt;    在常用的操作系统中，Linux中默认的Shell是Bourne Again Shell(bash)，Solaris和FreeBSD下默认的是Bourne Shell（sh），AIX下默认的是Korn Shell（ksh）。那么问题来了，我们该如何查看所使用系统的Shell？以CentOS为例查看系统默认的Shell：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法一：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 tmp]$ echo $SHELL
/bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;方法二：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 tmp]$ grep root /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;root用户结尾的/bin/bash就是用户登录后的Shell解释器。&lt;strong&gt;后续文章中重点讲解的是Bourne Again Shell(bash)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;shell-脚本的建立和执行&quot;&gt;Shell 脚本的建立和执行&lt;/h3&gt;
&lt;h4 id=&quot;shell脚本的建立&quot;&gt;Shell脚本的建立&lt;/h4&gt;
&lt;p&gt;    在Linux系统中，Shell脚本通常是在编辑器&lt;strong&gt;vi/vim&lt;/strong&gt;中进行编写。可由UNIX/Linux命令、bash shell命令、程序结构控制语句、注释等组成，推荐使用vim。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Shell脚本开头（第一行）&lt;br/&gt;  一个规范标准的Shell脚本会在第一行指出由哪个解释器来执行脚本中的内容，一般如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!/bin/bash
或
#!/bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、第一行一般要求小于255个字符。&lt;br/&gt;2、&lt;strong&gt;#!/bin/bash不是注释&lt;/strong&gt;，在执行脚本时，内核会根据#!后的解释器确定使用哪个解释器来执行脚本的内容。&lt;br/&gt;3、&lt;strong&gt;这一行必须位于每个脚本顶端的第一行，如果不是第一行则是代表注释&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
echo &quot;bash test&quot;
#!/bin/bash #代表该行是注释
#!/bin/sh   #代表该行是注释&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;bash和sh的区别&lt;br/&gt;  早期的bash与sh稍有不同，bash包含csh和ksh的特色，但大多数的脚本都可以直接在sh上运行。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-4c302934ba502abb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-3 bash和sh区别.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从上图可以看到sh为bash的软链接，大多数情况下，脚本开头使用#!/bin/bash和#!/bin/sh是没有区别的。但还是建议采用&lt;strong&gt;#!/bin/bash&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  一般情况下，安装完Linux系统之后会自动安装好bash软件，查看bash版本如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 etc]$ cat /etc/redhat-release
CentOS Linux release 7.3.1611 (Core) #当前系统版本
[admin@CentOS7 etc]$ bash --version
GNU bash, version 4.2.46(1)-release (x86_64-redhat-linux-gnu) # bash 版本，后续省略自由软件提示信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想体验更高版本的bash，升级方法如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y update bash #在线升级
rpm -qa bash  #查看bash安装包
bash-4.2.46-20.el7_2.x86_64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  以下是常用脚本开头的写法，不同语言的脚本在开头一般都要加上如下标识内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh
#!/bin/bash
#!/usr/bin/awk
#!/bin/sed
#!/usr/bin/tcsh
#!/usr/bin/perl&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;    CentOS中默认的Shell均为bash。因此即在脚本中未加#!/bin/bash，它也会使用bash去解释。如果不希望使用系统默认的Shell解释器，就需要自行指定解释器。&lt;strong&gt;建议大家一开始就养成好习惯，遵循Shell编程规范，在开头第一行指定所使用的解释器&lt;/strong&gt;&lt;br/&gt;    如果在开头未指定解释器，要使用对应的解释器来执行脚本时，可以使用如下方法：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Shell脚本： bash test.sh或sh test.sh
Python脚本：python test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;脚本注释&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    在很多编程语言中，都会支持单行和多行注释，方便阅读和维护，在Shell中，使用&lt;strong&gt;#&lt;/strong&gt;对所在行进行注释，注释的内容并不会当作命令执行。注释可单独一行也可以紧跟在命令后面。建议在写脚本添加必要的注释，方便自己也方便后续维护者或使用者。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注释中尽量不要使用中文，脚本中也尽量不要使用中文&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;shell脚本的执行&quot;&gt;Shell脚本的执行&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Shell脚本的执行流程&lt;br/&gt;    当脚本运行时，它会先查找&lt;strong&gt;系统环境变量ENV&lt;/strong&gt;，该变量指定了环境文件（加载顺序通常是/etc/profile、~/.bash_profile、~/.bashrc、/etc/bashrc等），在加载了上述环境变量文件后，Shell开始执行Shell脚本中的内容。&lt;br/&gt;    Shell脚本执行的顺序是&lt;strong&gt;从上到下，从左到右依次执行每一行的命令及语句&lt;/strong&gt;。如果Shell中存在脚本嵌套（子脚本）时，就会执行嵌套脚本的内容，完成后再返回父脚本继续执行父脚本内后续的命令和语句。通常情况下，执行Shell脚本时，会向系统内核启动一个新的进程，以便在该进程中执行脚本的命令和子脚本，其流程图如下所示：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-9daaf4d87a9479a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-4 Shell脚本执行基本流程图_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Shell脚本的执行方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【1】bash script-name或sh script-name&lt;/strong&gt;&lt;br/&gt;    这种方式是当脚本文件本身没有可执行权限（即文件属性没有x占位符）时常使用的方式或脚本文件没有指定解释器时常用的方法。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-7b8c33689b19de23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-5 Shell执行方式-1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【2】path/script-name或./script-name&lt;/strong&gt;&lt;br/&gt;    这种方式是指在当前路径下执行脚本，&lt;strong&gt;前提是脚本必须有可执行权限&lt;/strong&gt;，具体方法为&lt;strong&gt;chmod +x script-name&lt;/strong&gt;。然后通过相对路径或绝对路径执行脚本。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-bfc9c099fffd8049.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-6 Shell执行方式-2.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【3】source script-name或. script-name&lt;/strong&gt;&lt;br/&gt;    这种方法通常使用source或&quot; . &quot;读入或加载指定的Shell脚本，如son.sh，然后依次执行指定的Shell脚本文件son.sh中的所有语句。这些语句将在当前父Shell脚本father.sh中运行（其他几种模式都会启动新的进程执行子脚本）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;使用source或&quot; . &quot;可以将son.sh自身脚本中的变量值或函数等的返回值传递到当前父Shell脚本father.sh中使用，这是和其他两种方法最大的区别，因此需要特别注意。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-6f450348e66be058.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-7 Shell执行方式-3_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【4】sh&amp;lt;script-name或cat script-name | sh&lt;/strong&gt;&lt;br/&gt;    这种方法同样适用于bash，这种方法并不常见，了解知道即可。其原理就是利用了管道技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-e100c186bc0c0eca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-8 Shell执行方式-4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可以看看以下脚本的正确答案是哪一个？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-6b23c4ba123d937f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-9 Shell执行示例-1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考的答案选项如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[ ] 当前用户&lt;/li&gt;
&lt;li&gt;[ ] admin&lt;/li&gt;
&lt;li&gt;[ ] 无内容输入&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正确答案是&lt;strong&gt;无内容输入&lt;/strong&gt;。原因可查看Shell脚本的几种执行方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过这个示例我们可以得出如下结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子Shell脚本会直接继承父Shell的变量、函数等，如儿子继承父亲基因。&lt;/li&gt;
&lt;li&gt;如果希望父Shell继承子Shell的变量，就要使用source或&quot; . &quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-6d22eacda0c782c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-10 Shell执行示例-2.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;脚本规范&quot;&gt;脚本规范&lt;/h3&gt;
&lt;p&gt;    每种语言都有自己的开发规范，虽然不是强制遵守，但有规范的代码不便方便阅读、维护、多人协同开发，同时也能减少出现Bug的概率。主要的规范如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;【1】Shell脚本的第一行指定脚本解释器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!/bin/bash
或
#!/bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;【2】Shell脚本的开关添加版本、版权、作者等&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#Date:2017-11-29 22:50
#Author:Surpassme
#Description:This is sample shell scripts
#Version:1.5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;【3】Shell脚本中尽量不要使用中文&lt;/strong&gt;&lt;br/&gt;  虽说Linux也能兼容中文，但还是存在切换系统环境后中文出现乱码的问题。如果非要用中文，可对系统进行字符集调整。如&lt;strong&gt;export LANG=&quot;zh_CN.UTF-8&quot;&lt;/strong&gt;，并在脚本中重新定义字符集设置和系统保持一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;【4】Shell脚本尽量添加扩展名.sh&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【5】养成良好的脚本书写习惯&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;1、成对的符号尽量一次性写全，防止遗漏
2、中括号（[]）两端至少要保留一个空格。
3、流程控制语句，应一次性将格式写完，再添加内容
4、良好的代码缩进，方便阅读
5、脚本的各个符号必须为英文状态下的符号
6、常规变量的字符串定义时应加双引号（&quot;&quot;）并且等号前后均不能有空格，需要强引用（指所见即所得的字符串引用），则使用单引号（''），如果是命令引用，则用反引号（``）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 13:27:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>什么是Shell     简单来说Shell其实就是一个 命令解释器 ，而它的作用就是解释并执行用户输入的命令及程序。用户每输入一条命令，Shell就解释执行一次。这种方式很容易让</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/9911671.html</dc:identifier>
</item>
<item>
<title>解析·NOIP·冷门 CLZ最小环 - 迷失の风之旅人</title>
<link>http://www.cnblogs.com/Chen574118090/p/9911566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chen574118090/p/9911566.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;赐予我力量，去改变我所能改变的;赐予我勇气，去接受我不能改变的;并赐予我智慧，去分辨这两者。&lt;br/&gt;-----安东尼达斯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NOIP的图论题中有一部分是跟图上的环有关的。蒟蒻的我在USACO上刷题时发现了一种（或许）还没有普及的快速最小环算法，拥有极高的效率，可以在求最短路的时间复杂度内求出经过任意一点的最小环大小或权值。作者将它称作&lt;strong&gt;Calculate lacework zoomly shortest cyclic&lt;/strong&gt;，这里暂译作&lt;strong&gt;CLZ最小环&lt;/strong&gt;。&lt;br/&gt;与Floyd求图上最小环不同，CLZ最小环还可以很快捷地求出经过特定点的最小环。&lt;br/&gt;CLZ最小环的思路也极为简单，很容易理解：对于求经过一个点&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;的最小环时，即首先进行最短路操作，在进行第一次松弛操作后重新将该点标记为未访问，并重新访问。由于是与最短路同时运作，所以其复杂度几乎取决于最短路算法。当然，CLZ最小环仍有其独立的优化方案。&lt;/p&gt;
&lt;h4 id=&quot;朴素情况&quot;&gt;朴素情况&lt;/h4&gt;
&lt;p&gt;首先让我们考虑朴素情况，非负带环有向图。对于求最小环中所含的点数，我们只需要将每一条边的权值修改为1，再按上述过程操作即可。&lt;br/&gt;至于如何回退操作，相信不用细讲。我们可以在最短路算法的最前定义一个布尔型变量bool wait初始值为1，在进行完松弛操作后判断wait的状态来决定是否需要将起点重新放入。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void dijkstra(int u){   
    bool wait=1;
    /*
    blblblblblbl
    */
    if(wait){
       dis[u]=0x3f3f3f3f,vis[u]=0;//对单个点进行初始化
       q.push(u);//将点重新放入
       wait=0;//设定当前松弛次数
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数代码如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void dijkstra(int u){
    pall note;
    bool wait=1;
    for(register int i=0;i&amp;lt;maxn;i++)dis[i]=0x3f3f3f3f,vis[i]=0;
    dis[u]=0;vis[u]=1;
    set&amp;lt;pall,cmp&amp;gt; s;
    s.insert(make_pair(u,0));
    for(register int i=0;i&amp;lt;n &amp;amp;&amp;amp; s.size();i++){
        set&amp;lt;pall,cmp&amp;gt;::iterator it=s.begin();
        u=it-&amp;gt;X;
        s.erase(*it);
        vis[u]=1;
        for(register int j=p[u];~j;j=E[j].next){
            int v=E[j].v;
            int w=E[j].w;
            if(dis[v]&amp;gt;dis[u]+w &amp;amp;&amp;amp; !vis[v]){
                s.erase(make_pair(v,dis[v]));
                s.insert(make_pair(v,dis[v]=dis[u]+w));
                note=make_pair(u,v);
            }
        }
        if(wait){
            dis[u]=0x3f3f3f3f;
            vis[u]=0;
            wait=0;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;无向图&quot;&gt;无向图&lt;/h4&gt;
&lt;p&gt;对于无向图来说，若允许经过同一条边多次，则与上述操作无异。但若每条边只能经过一次，则需要一些额外的操作。因为无向图的性质，我们可以知道，从&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;的路径权值和与从&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;的路径权值和是相等的。因此我们可以考虑判断当前路径的权值&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;与上一条路径的权值&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是否相等，并以此来考虑是否选择当前路径。&lt;br/&gt;当然也有更简单的判断方式。若数据量较大，我们只需将等待的wait往后延长一次松弛操作即可。而数据较小时，我们可以直接暴力求解，不在本题的考虑范围之内。&lt;br/&gt;对于普适且较为常规的情况，我们可以先求出点&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;连向的边与&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;的距离，保存该距离，并枚举每一个距离的总长度即可。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;if(dis[u]==w)continue;
/*-----------写法分割线------------*/
if(wait==1 &amp;amp;&amp;amp; E[i ^ 1].w==w)continue;
wait++;
int wait=0;
if(wait==1){
    dis[u]=0x3f3f3f3f;
    q.push(u);
    //wait=0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;带负权&quot;&gt;带负权&lt;/h4&gt;
&lt;h5 id=&quot;负环判断&quot;&gt;负环判断&lt;/h5&gt;
&lt;p&gt;普通的spfa可以直接解决，也可以将所有边权去反，再判断带负权的正环。详情见下文详述。&lt;/p&gt;
&lt;h5 id=&quot;正环判断&quot;&gt;正环判断&lt;/h5&gt;
&lt;p&gt;所谓正环有两种定义。一个环上所有边为正，或一个环上权值的和为正。&lt;br/&gt;对于第一种定义，我们只需要在遇见负边时跳过即可。&lt;br/&gt;对于第二种定义，则需要些许变通。我们不再直接修改或操作原边权值，而是再在结构体中声明新的变量将点的数量转化为边权值。如下图，两种边权是不会互相干扰的。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14445028-f945333b964edade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;由于有负边权，我们选择使用spfa跑最短路。我们在跑最短路的过程中同时计算两种权值。当且仅当两种边权都有更优解时我们才用新答案替换原有答案（可以稍微思考一下）。当我们按题目给的边权走，使得当前最短路为负数时，我们直接跳过该判断。并不用但担心这里会跳出正确答案，因为由于我们会在每一个点都进行一次spfa寻找操作，所以有且一定有至少一种情况让我们在跑环的过程中边权绝不为负。且这里的为负就跳出也为CLZ最小环算法提供了很好的剪枝。&lt;br/&gt;以下是带负边权的有向图最小环代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void spfa(int u){
    //额外的，E[i].a记录点的数量转化来的边权,即E[i].a恒等于1 
    //ges[u]记录当前最小环内的点数，即a权值维护的最小值 
    bool wait=1;
    for(register int i=0;i&amp;lt;maxn;i++)dis[i]=0x3f3f3f3f,vis[i]=0,ges[i]=0x3f3f3f3f;
    dis[u]=0;vis[u]=1;
    ges[u]=0;
    queue&amp;lt;int&amp;gt; q;
    q.push(u);
    while(!q.empty()){
        u=q.front();
        q.pop();
        vis[u]=0;
        for(register int i=p[u];~i;i=E[i].next){
            int v=E[i].v;
            int w=E[i].w;
            int a=E[i].a;
            if(dis[v]&amp;gt;dis[u]+w &amp;amp;&amp;amp; ges[v]&amp;gt;ges[u]+a &amp;amp;&amp;amp; dis[u]+w&amp;gt;0){
                ges[v]=ges[u]+a;
                dis[v]=dis[u]+w;
                //cout&amp;lt;&amp;lt;dis[v]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;dis[u]+w&amp;lt;&amp;lt;endl;
                if(!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
        if(wait){
            q.push(u);
            dis[u]=0x3f3f3f3f;
            vis[u]=0;
            ges[u]=0x3f3f3f3f;
            wait=0;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现，其实CLZ最小环只是一种延迟操作的思想。作者只不过是使用了这一思路的一小部分，利用其智慧将最短路的松弛操作分开而已。或许在未来作者会以该思路获得更多灵感，笔者也会持续关注。&lt;br/&gt;最后附上朴素写法的板子&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define maxn 3000
#define maxm 5000
#define X first
#define Y second
#define pall pair&amp;lt;int,int&amp;gt;
using namespace std;
inline char get(){
    static char buf[300],*p1=buf,*p2=buf;
    return p1==p2 &amp;amp;&amp;amp; (p2=(p1=buf)+fread(buf,1,30,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
    register char c=get();register int f=1,_=0;
    while(c&amp;gt;'9' || c&amp;lt;'0')f=(c=='-')?-1:1,c=get();
    while(c&amp;lt;='9' &amp;amp;&amp;amp; c&amp;gt;='0')_=(_&amp;lt;&amp;lt;3)+(_&amp;lt;&amp;lt;1)+(c^48),c=get();
    return _*f;
}
struct edge{
    int u,v,w,next;
}E[maxm];
struct cmp{
    operator ()(const pall &amp;amp;a,const pall &amp;amp;b)const{
        if(a.Y!=b.Y)return a.Y&amp;lt;b.Y;
        return a.X&amp;lt;b.X;
    }
};
int p[maxn],eid;
inline void init(){
    for(register int i=0;i&amp;lt;maxn;i++)p[i]=-1;
    eid=0;
}
inline void insert(int u,int v,int w){
    E[eid].u=u;
    E[eid].v=v;
    E[eid].w=w;
    E[eid].next=p[u];
    p[u]=eid++;
}
inline void insert2(int u,int v,int w){
    insert(u,v,w);
    insert(v,u,w);
}
int n,m;
int dis[maxn],vis[maxn];
void dijkstra(int u){
    pall note;
    bool wait=1;
    for(register int i=0;i&amp;lt;maxn;i++)dis[i]=0x3f3f3f3f,vis[i]=0;
    dis[u]=0;vis[u]=1;
    set&amp;lt;pall,cmp&amp;gt; s;
    s.insert(make_pair(u,0));
    for(register int i=0;i&amp;lt;n &amp;amp;&amp;amp; s.size();i++){
        set&amp;lt;pall,cmp&amp;gt;::iterator it=s.begin();
        u=it-&amp;gt;X;
        s.erase(*it);
        vis[u]=1;
        for(register int j=p[u];~j;j=E[j].next){
            int v=E[j].v;
            int w=E[j].w;
            if(dis[v]&amp;gt;dis[u]+w &amp;amp;&amp;amp; !vis[v]){
                s.erase(make_pair(v,dis[v]));
                s.insert(make_pair(v,dis[v]=dis[u]+w));
                note=make_pair(u,v);
            }
        }
        if(wait){
            dis[u]=0x3f3f3f3f;
            vis[u]=0;
            wait=0;
        }
    }
}
int u,v,w;
int main(){
    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);
    init();
    n=read();m=read();
    for(register int i=0;i&amp;lt;m;i++){
        u=read();v=read();w=read();
        insert(u,v,1);
    }
    int ans=0x3f3f3f3f;
    for(register int i=1;i&amp;lt;=n;i++){
        dijkstra(i);
        ans=min(ans,dis[i]);
    }
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 05 Nov 2018 13:09:00 +0000</pubDate>
<dc:creator>迷失の风之旅人</dc:creator>
<og:description>图论里的最小环快速计算！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Chen574118090/p/9911566.html</dc:identifier>
</item>
<item>
<title>python Kmeans算法解析 - zzzzMing</title>
<link>http://www.cnblogs.com/listenfwind/p/9911561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/listenfwind/p/9911561.html</guid>
<description>&lt;p&gt;### 一. 概述 首先需要先介绍一下无监督学习，所谓无监督学习，就是训练样本中的标记信息是位置的，目标是通过对无标记训练样本的学习来揭示数据的内在性质以及规律。通俗得说，就是根据数据的一些内在性质，找出其内在的规律。而这一类算法，应用最为广泛的就是“聚类”。 聚类算法可以对数据进行数据归约，即在尽可能保证数据完整的前提下，减少数据的量级，以便后续处理。也可以对聚类数据结果直接应用或分析。 而Kmeans 算法可以说是聚类算法里面较为基础的一种算法。 ### 二. 从样例开始 我们现在在二维平面上有这样一些点 ``` x y 1.658985 4.285136 -3.453687 3.424321 4.838138 -1.151539 -5.379713 -3.362104 0.972564 2.924086 -3.567919 1.531611 0.450614 -3.302219 -3.487105 -1.724432 2.668759 1.594842 -3.156485 3.191137 3.165506 -3.999838 -2.786837 -3.099354 4.208187 2.984927 -2.123337 2.943366 0.704199 -0.479481 -0.392370 -3.963704 2.831667 1.574018 -0.790153 3.343144 2.943496 -3.357075 ... ``` 它在二维平面上的分布大概是这样的： ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210050092-1399553075.png) 好，这些点看起来隐约分成4个“簇”，那么我们可以假定它就是要分成4个“簇”。（虽然我们可以“看”出来是要分成4个“簇”，但实际上也可以分成其他个，比如说5个。）这里分成“4个簇“是我们看出来的。而在实际应用中其实应该由机器算得，下面也会有介绍的。 找出4个”簇”之后，就要找出每个“簇”的中心了，我们可以“看出”大概的中心点，但机器不知道啊。那么机器是如何知道的呢？答案是通过向量距离，也叫向量相似性。这个相似性计算有多种方法，比如欧式距离，曼哈顿距离，切比雪夫距离等等。 我们这里使用的是欧式距离，**欧式距离其实就是反应空间中两点的直线距离。** 知道这些后，我们就可以开始让机器计算出4个“簇”了。 主要做法是这样，先随机生成4个点，假设这4个点就是4个“簇”的中心。计算平面中每个点到4个**中心点**的距离，平面中每个点选取距离最近的那个**中心**作为自己的中心。 此时我们就完成第一步，将平面中所有点分成4个”簇“。但是刚刚那几个中心都是随机的，这样分成的4个簇明显不是我们想要的结果。怎么办呢？做法如下： 现在有4个簇，根据每个簇中所有点计算出每个簇的**新中心点**。这个新中心点就会比上一个旧的中心点更优，因为它更加中心。然后使用新中心点重复第一步的步骤。即再对平面中所有点算距离，然后分发到4个**新簇**中。不断迭代，直到误差较小。 这就是 Kmeans 算法的过程了。 ### 三. 知识点浅析 #### 3.1 确定“簇”的个数 上面所说的分成 4 个簇，这个 4 其实就是 Kmeans 中的K。要使用 Kmeans 首先就是要选取一个 K 作为聚类个数。而上面的例子其实是我们主观”看“出来的，但多数情况下我们是无法直观”看“出分多少个 K 比较好。那怎么办呢？ 我们可以从较低的 K 值开始。使用较简单的 Kmeans 算法的结果（即较少的迭代次数，不求最佳结果，但求最快）。计算每个点到其归属的“簇”的中心点的距离，然后求和，求和结果就是误差值。 然后再增加 K 值，再计算误差值。比如上面的例子，我们可以从 K=2 开始，计算 K 值从 2 到 7 的 Kmeans 算法的误差值。 这样会得到类似这样一张图： ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210342304-1599281824.png) 里面的 Error 可以理解未 Kmeans 的误差，而当分成越多“簇”的适合，误差肯定是越来越小。 但是不是“簇”越多越好呢？答案是否定的，有时候“簇”过多的话是不利于我们得到想要的结果或是做下一步操作的。 所以我们通常会选择误差减小速度比较平缓的那个临界点，比如上图中的 **4**。 可以发现，在分成 4 个簇之后，再增加簇的数量，误差也不会有很大的减少。而取 4 个簇也和我们所看到的相符。 #### 3.2 欧式距离 #### 3.2 欧式距离 欧氏距离是一个通常采用的距离定义，指在m维空间中两个点之间的真实距离，计算公式如下： ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210113366-1125611006.jpg) 而本例种的是在二维空间种，故而本例的计算公式如下： ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210120839-1494903025.jpg) ### 四. 代码和结果 加载数据的代码，使用了 numpy ，先是将代码加载成 matrix 类型。 ``` import numpy as np def loadDataSet(fileName): ''' 加载数据集 :param fileName: :return: ''' # 初始化一个空列表 dataSet = [] # 读取文件 fr = open(fileName) # 循环遍历文件所有行 for line in fr.readlines(): # 切割每一行的数据 curLine = line.strip().split('\t') # 将数据转换为浮点类型,便于后面的计算 # fltLine = [float(x) for x in curLine] # 将数据追加到dataMat fltLine = list(map(float,curLine)) # 映射所有的元素为 float（浮点数）类型 dataSet.append(fltLine) # 返回dataMat return np.matrix(dataSet) ``` 接下来需要生成 K 个初始的质点，即中心点。这里采用随机生成的方法生成 k 个“簇”。 ``` def randCent(dataMat, k): ''' 为给定数据集构建一个包含K个随机质心的集合, 随机质心必须要在整个数据集的边界之内,这可以通过找到数据集每一维的最小和最大值来完成 然后生成0到1.0之间的随机数并通过取值范围和最小值,以便确保随机点在数据的边界之内 :param dataMat: :param k: :return: ''' # 获取样本数与特征值 m, n = np.shape(dataMat) # 初始化质心,创建(k,n)个以零填充的矩阵 centroids = np.mat(np.zeros((k, n))) # 循环遍历特征值 for j in range(n): # 计算每一列的最小值 minJ = min(dataMat[:, j]) # 计算每一列的范围值 rangeJ = float(max(dataMat[:, j]) - minJ) # 计算每一列的质心,并将值赋给centroids centroids[:, j] = np.mat(minJ + rangeJ * np.random.rand(k, 1)) # 返回质心 return centroids ``` 欧式距离计算 ``` def distEclud(vecA, vecB): ''' 欧氏距离计算函数 :param vecA: :param vecB: :return: ''' return np.sqrt(sum(np.power(vecA - vecB, 2))) ``` cost 方法将执行一个简化的 kMeans ，即较少次数的迭代，计算出其中的误差（即当前点到簇质心的距离,后面会使用该误差来评价聚类的效果） ``` def cost(dataMat, k, distMeas=distEclud, createCent=randCent,iterNum=300): ''' 计算误差的多少，通过这个方法来确定 k 为多少比较合适，这个其实就是一个简化版的 kMeans :param dataMat: 数据集 :param k: 簇的数目 :param distMeans: 计算距离 :param createCent: 创建初始质心 :param iterNum：默认迭代次数 :return: ''' # 获取样本数和特征数 m, n = np.shape(dataMat) # 初始化一个矩阵来存储每个点的簇分配结果 # clusterAssment包含两个列:一列记录簇索引值,第二列存储误差(误差是指当前点到簇质心的距离,后面会使用该误差来评价聚类的效果) clusterAssment = np.mat(np.zeros((m, 2))) # 创建质心,随机K个质心 centroids = createCent(dataMat, k) clusterChanged = True while iterNum &amp;gt; 0: clusterChanged = False # 遍历所有数据找到距离每个点最近的质心, # 可以通过对每个点遍历所有质心并计算点到每个质心的距离来完成 for i in range(m): minDist = np.inf minIndex = -1 for j in range(k): # 计算数据点到质心的距离 # 计算距离是使用distMeas参数给出的距离公式,默认距离函数是distEclud distJI = distMeas(centroids[j, :], dataMat[i, :]) # print(distJI) # 如果距离比minDist(最小距离)还小,更新minDist(最小距离)和最小质心的index(索引) if distJI &amp;lt; minDist: minDist = distJI minIndex = j # 更新簇分配结果为最小质心的index(索引),minDist(最小距离)的平方 clusterAssment[i, :] = minIndex, minDist ** 2 iterNum -= 1; # print(centroids) # 遍历所有质心并更新它们的取值 for cent in range(k): # 通过数据过滤来获得给定簇的所有点 ptsInClust = dataMat[np.nonzero(clusterAssment[:, 0].A == cent)[0]] # 计算所有点的均值,axis=0表示沿矩阵的列方向进行均值计算 centroids[cent, :] = np.mean(ptsInClust, axis=0) # 返回给定迭代次数后误差的值 return np.mat(clusterAssment[:,1].sum(0))[0,0] ``` 最后可以调用 Kmeans 算法来进行计算。 ``` def kMeans(dataMat, k, distMeas=distEclud, createCent=randCent): ''' 创建K个质心,然后将每个店分配到最近的质心,再重新计算质心。 这个过程重复数次,直到数据点的簇分配结果不再改变为止 :param dataMat: 数据集 :param k: 簇的数目 :param distMeans: 计算距离 :param createCent: 创建初始质心 :return: ''' # 获取样本数和特征数 m, n = np.shape(dataMat) # 初始化一个矩阵来存储每个点的簇分配结果 # clusterAssment包含两个列:一列记录簇索引值,第二列存储误差(误差是指当前点到簇质心的距离,后面会使用该误差来评价聚类的效果) clusterAssment = np.mat(np.zeros((m, 2))) # 创建质心,随机K个质心 centroids = createCent(dataMat, k) # 初始化标志变量,用于判断迭代是否继续,如果True,则继续迭代 clusterChanged = True while clusterChanged: clusterChanged = False # 遍历所有数据找到距离每个点最近的质心, # 可以通过对每个点遍历所有质心并计算点到每个质心的距离来完成 for i in range(m): minDist = np.inf minIndex = -1 for j in range(k): # 计算数据点到质心的距离 # 计算距离是使用distMeas参数给出的距离公式,默认距离函数是distEclud distJI = distMeas(centroids[j, :], dataMat[i, :]) # 如果距离比minDist(最小距离)还小,更新minDist(最小距离)和最小质心的index(索引) if distJI &amp;lt; minDist: minDist = distJI minIndex = j # 如果任一点的簇分配结果发生改变,则更新clusterChanged标志 if clusterAssment[i, 0] != minIndex: clusterChanged = True # 更新簇分配结果为最小质心的index(索引),minDist(最小距离)的平方 clusterAssment[i, :] = minIndex, minDist ** 2 # print(centroids) # 遍历所有质心并更新它们的取值 for cent in range(k): # 通过数据过滤来获得给定簇的所有点 ptsInClust = dataMat[np.nonzero(clusterAssment[:, 0].A == cent)[0]] # 计算所有点的均值,axis=0表示沿矩阵的列方向进行均值计算 centroids[cent, :] = np.mean(ptsInClust, axis=0) # 返回所有的类质心与点分配结果 return centroids, clusterAssment ``` 选取不同的 k 值对结果影响有多大呢？我们来看看就知道了，下面给出的是 k 值为 2 到 6 的效果。 图中红色方块即为“簇”的中心点，每个“簇”所属的点用不同的颜色表示。 K = 2 ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210231299-1143375051.png) K = 3 ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210241488-154927530.png) K = 4 ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210250605-1490938386.png) K = 5 ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210300523-1623943286.png) K = 6 ![](https://img2018.cnblogs.com/blog/1011838/201811/1011838-20181105210308463-1168452819.png)&lt;/p&gt;



</description>
<pubDate>Mon, 05 Nov 2018 13:08:00 +0000</pubDate>
<dc:creator>zzzzMing</dc:creator>
<og:description>一. 概述 首先需要先介绍一下无监督学习，所谓无监督学习，就是训练样本中的标记信息是位置的，目标是通过对无标记训练样本的学习来揭示数据的内在性质以及规律。通俗得说，就是根据数据的一些内在性质，找出其内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/listenfwind/p/9911561.html</dc:identifier>
</item>
<item>
<title>【安卓本卓】Android系统源码篇之（一）源码获取、源码目录结构及源码阅读工具简介 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/9911386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/9911386.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;古人常说，“熟读唐诗三百首，不会作诗也会吟”，说明了大量阅读诗歌名篇对学习作诗有非常大的帮助。做开发也一样，Android源码是全世界最优秀的Android工程师编写的代码，也是Android开发中绝对的权威所在。Android系统开源，且占据了当今手机系统世界的绝大部分江山，各大手机厂商要做手机系统定制，就必须对Android系统源码非常熟悉，这就要求他们的工程师们去熟读源码。即使是纯第三方App的开发者，要想成为Android开发真正的行家里手，也必须对系统源码有一定的研究。本系列文章将记录笔者学习Android源码的理解和心得，以此来和广大的同行们进行交流和相互提升。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       本篇文章是这一系列的第一篇，将主要记录或者介绍Android源码的获取，系统源码的宏观结构及内容，源码阅读工具推荐及使用方法等内容。主要内容如下：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181105202442554-66245701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、获取Android系统源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        Android源码的获取方式有许多，既可以在Windows下去获取，也可以Linux下去下载，比较常见的方法是在Linux下用repo工具去下载。笔者使用的方式是在Windows7系统下安装Ubuntu16.04双系统，然后采用repo工具去获取的源码。其中每一个步骤都可以在网上找到很多资料，笔者不赘述，也不自己探索方法，这里仅记录下成功安装获取源码过程中参考的网页、主要步骤以及碰到的若干问题，以供读者和笔者自己以后参考使用。基本操作步骤如下：&lt;/p&gt;
&lt;p&gt;  1、在Win7中分区&lt;/p&gt;
&lt;p&gt;        在Windows7中为Ubuntu系统分区，参考了【&lt;a href=&quot;https://blog.csdn.net/davidhuang2017/article/details/70258173&quot; target=&quot;_blank&quot;&gt;Win7下安装Ubuntu16.04成双系统&lt;/a&gt;】中第一节分区步骤。Android系统源码未编译前就有大约20-30G大小，编译后更大，所以一定要预留足够的空间。&lt;/p&gt;
&lt;p&gt;  2、制作Ubuntu U盘系统启动盘&lt;/p&gt;
&lt;p&gt;        参看网页【&lt;a href=&quot;https://jingyan.baidu.com/article/3c48dd348bc005e10be358eb.html&quot; target=&quot;_blank&quot;&gt;Ubuntu16.04安装基础入门教程&lt;/a&gt;】前5步。Ubutu镜像文件从Ubutu官网下载即可，不过需要注意的是，要先弄清楚下载32位还是64位的系统：在主系统Win7桌面查看“计算机”图标属性，可以看到系统的位数，如下图所示：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181104220954257-1378200705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       所以咱们在选择Ubuntu系统的时候也选择64位的。这里笔者也有一个疑问，既然这里Ubuntu和Win7是独立的双系统，那么应该没有必要两个系统的位数必须一致吧，这里笔者没有研究过，读者可以去查资料探索一下，当然，选择同样的位数总是会比较保险一点。在Ubuntu下载版本中，结尾为amd64的版本为64位系统，结尾为i386的版本为32位系统。&lt;/p&gt;
&lt;p&gt;  3、U盘启动并安装Ubuntu系统&lt;/p&gt;
&lt;p&gt;       在BIOS boot中将默认的硬盘启动修改为U盘启动，然后重启即可进入到Ubuntu的安装界面，根据需要一步一步进行即可。至于如何进入到BIOS设置界面，不同的主板快捷键不一样，笔者这里不详述，读者根据主板型号百度即可。安装成功后，记得修改回来为默认硬盘启动。&lt;/p&gt;
&lt;p&gt;  4、Ubuntu中获取源码&lt;/p&gt;
&lt;p&gt;        参考【&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/&quot; target=&quot;_blank&quot;&gt;Aosp|镜像使用帮助|清华大学开源镜像站&lt;/a&gt;】,笔者选择的是“使用每月更新的初始化包”。源码比较大，所以下载需要好几个小时的时间，所以最好在晚上下载，避开网络使用高峰期。&lt;/p&gt;
&lt;p&gt;  5、碰到的问题记录&lt;/p&gt;
&lt;p&gt;    （1）安装完Ubuntu后，再重启时，系统选项中找不到原Win7系统。&lt;/p&gt;
&lt;p&gt;         安装好Ubuntu后，我们希望再启动电脑的时候出现一个系统选项，选择是进入原Win7系统还是新安装的Ubuntu系统。如提问中描述，找不到Win7系统选项入口，就无法进入到原来的Win7系统中。这种情况，请参考【&lt;a href=&quot;https://blog.csdn.net/weixin_39785834/article/details/80024975&quot; target=&quot;_blank&quot;&gt;Win7系统安装Ubuntu系统后，不能进入Win7&lt;/a&gt;】。笔者曾多次碰到过这个问题，以为是把原Win7系统给覆盖掉了，走过不少的弯路，后来找到链接中的方法才解决。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、Android源码目录结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;Android系统源码内容实在太广，其目录结构也实在庞大，每位开发者也无法做到对每一块都弄明白，工作中接触的也只是其中的一小部分。以下只从宏观上对系统源码的一级目录进行介绍，后续再慢慢完善更细致的内容。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181029234406961-786558760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、Android系统架构和源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在笔者以前的博客&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/9747525.html&quot;&gt;【朝花夕拾】Android性能篇之（五）Android虚拟机&lt;/a&gt;第二大点中简单介绍过Android的系统架构，其实在Native Libraries层Linux Kernel层之间还有一层——HAL层，即Hardware Abstract Layer，硬件抽象层。在众多介绍Android系统架构的展示图中，有的版本显示HAL，有的没有，读者知道有这一层就好了。如下为Android源码官网【&lt;a href=&quot;https://source.android.google.cn/&quot; target=&quot;_blank&quot;&gt;AOSP：Android Open Source Project&lt;/a&gt; 】中Android系统架构图，就展示HAL。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181104142832178-2057176857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       对于Android系统架构每一层，Android源码结构中都对应分配了目录。下图展示了在Android源码一级目录中，各框架层和部分目录的对应关系：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181104202020255-904799744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        理解Android系统结构和Android系统源码的对应关系，有助于帮助咱们理解Anroid系统源码。当然，这幅思维导图中只介绍了源码一级目录和系统架构的对应关系，深入各个目录，每个系统架构层还可以找到很多源码与之对应，读者可以再深入研究研究。与此同时，同一个目录下的源码，也可能包含多个系统架构层，比如，frameworks层中就有frameworks/base/packages/SystemUI这个目录，众所周知，SystemUI是一款系统App，是属于应用层的。所以，对某个目录的功能，也不能一概而论。&lt;/p&gt;

&lt;p&gt;四、Android源码阅读工具&lt;/p&gt;
&lt;p&gt;       选择好的源码阅读工具，可以让工作事半功倍。如今市面上有许多工具来辅助阅读源码，有在线阅读的，比如：AndroidXRef、Android SDK Search等；也有本地阅读的，比如：Source Insight等。同时，Google也提供了官方网站，用于指导开发者使用源码：【AOSP文档网站（中文版）&lt;a href=&quot;https://source.android.google.cn/&quot; target=&quot;_blank&quot;&gt;https://source.android.google.cn/&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;  1、AndroidXRef&lt;/p&gt;
&lt;p&gt;        前文也说过，Android源码非常庞大，下载源码也是非常耗用时间。我们可能经常碰到需要临时查看源码，而当前设备上没有的情况。幸运的是，有一些在线阅读源码的网站，给开发者带来了很大的便利，AndroidXRef就是其中一款备受青睐的源码在线阅读网站【网址：&lt;a href=&quot;http://androidxref.com/&quot; target=&quot;_blank&quot;&gt;http://androidxref.com/&lt;/a&gt;】。在这里，笔者简单介绍一下该网站的基本使用。&lt;/p&gt;
&lt;p&gt;    （1）查看并选择系统版本&lt;/p&gt;
&lt;p&gt;       进入首页后，可以看到Google发布的各个系统版本，按照发布时间排序，包括版本别名，版本号，内核号等，如下图所示，开发者可以根据需要点击进入对应的版本。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181105171926705-437995597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （2）源码查找主界面功能点&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181105181913616-1057092574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （3）搜索条件的解锁及使用&lt;/p&gt;
&lt;p&gt;      1）Full Search&lt;/p&gt;
&lt;p&gt;       进行全文搜索，属于模糊查询，忽略大小写，会匹配所有的单词、字符串、标识符以及数字等，包括注释在内。如下图所示，为全文搜索“Activity”的结果，也显示了所在文件的路径，可以点击进入对应的文件。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181105184828768-372722507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      2）Definition&lt;/p&gt;
&lt;p&gt;       搜索符号定义相关的代码。如下所示，同样输入“Activity”后，显示的搜索结果，“Activity”都是作为包名、类名或定义类型，方法名等出现的，可以和上面Full Search结果做对比。多次尝试搜索的结果来看，这里会区别大小写，搜索的也是整个单词，这里搜索会更精准一些。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181105185019792-310007914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      3）Symbol&lt;/p&gt;
&lt;p&gt;       符号搜索，主要用于搜索类中的成员变量等，也是精确查找，如下图所示，就是根据成员变量“FEATURE_NO_TITLE”搜索的结果。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181105190357665-861551437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       4）File Path&lt;/p&gt;
&lt;p&gt;       搜索源码文件名或路径中包含搜索条件字符串的文件，忽略大小写。如下所示，显示了文件路径或文件名中包含了“Activity”的结果。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181105191612393-1543917185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      5）History&lt;/p&gt;
&lt;p&gt;       该条件暂时没发现怎么使用，有写帖子上甚至直接说该条件没用，这里笔者不做说明，也不举例了。&lt;/p&gt;
&lt;p&gt;       该部分能够帮助开发人员快速定位到想要查看的代码，熟练使用，能极大地提高效率。上述介绍的都是单一条件搜索，开发人员可以根据实际情况对条件进行组合搜索，这样搜索起来就更精准了，使用起来很简单，这里不再举例子了。&lt;/p&gt;
&lt;p&gt;  2、Android SDK Search&lt;/p&gt;
&lt;p&gt;       该工具使用起来使得在线阅读源码更方便，将API和源码完美结合起来。但是使用该工具，需要VPN，即需要FQ，访问境外服务器。这里笔者就不详细介绍了，能FQ的读者，可以参考如下使用方法网址：【&lt;a href=&quot;https://www.jianshu.com/p/a53c807812ea&quot; target=&quot;_blank&quot;&gt;Android SDK Search 使用方法&lt;/a&gt;】。另外提供一个免费FQ工具，简单易用：【&lt;a href=&quot;https://github.com/getlantern/lantern&quot; target=&quot;_blank&quot;&gt;蓝灯（Lantern）&lt;/a&gt;】。&lt;/p&gt;
&lt;p&gt;  3、Source Insight&lt;/p&gt;
&lt;p&gt;       这是一款被开发者们广泛使用和称赞的本地源码阅读软件，除了阅读，还可以方便地进行开发。Source Insight工具功能强大，操作复杂，以后会专门写一篇文章来介绍它的使用，这里篇幅有限，就不详细介绍了。除此之外，还有很多开发工具可以用来阅读源码，比如Eclipse，Android Studio等都可以用来阅读系统源码，但这方面的功能无法和Source Insight相提并论，就不多做介绍了，把使用最广泛，最专业的工具用好就可以了。&lt;/p&gt;

&lt;p&gt;       本篇文章作为Android系统源码系列的第一篇，主要介绍了获取源码，以及源码阅读工具使用方法等方面内容，为后续深入分析和理解源码做准备工作。限于笔者的经验和知识水平，文中有论述不准确或不恰当的地方，请读者们多多指正，谢谢！&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 12:38:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>古人常说，“熟读唐诗三百首，不会作诗也会吟”，说明了大量阅读诗歌名篇对学习作诗有非常大的帮助。做Android开发也一样，要想成为Android开发领域的行家里手，就必须去大量阅读Android源码。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/9911386.html</dc:identifier>
</item>
<item>
<title>类实例化原理 - 那股泥石流</title>
<link>http://www.cnblogs.com/hexinwei1/p/9911202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hexinwei1/p/9911202.html</guid>
<description>&lt;p&gt;Java对象的创建过程包括&lt;span&gt; &lt;span&gt;类初始化（&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hexinwei1/p/9910638.html&quot;&gt;&lt;span&gt;JVM类加载机制&lt;/span&gt;&lt;/a&gt;）&lt;/span&gt;和&lt;span&gt;类实例化&lt;/span&gt;两个阶段。&lt;/p&gt;
&lt;h3 id=&quot;一java对象创建时机&quot;&gt;一、Java对象创建时机&lt;/h3&gt;
&lt;p&gt;（1）使用new关键字创建对象&lt;/p&gt;
&lt;p&gt;（2）反射创建对象&lt;/p&gt;
&lt;p&gt;　　使用Class类的newInstance方法&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;Student student2 = (Student)Class.forName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Student类全限定名&quot;).newInstance()；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用Constructor类的newInstance方法&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;Constructor&amp;lt;Student&amp;gt; constructor = Student.class.getConstructor(Integer.class);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Student stu3 = constructor.newInstance(123);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; （3）使用Clone方法创建对象（实现Cloneable接口）&lt;/p&gt;
&lt;p&gt;　　无论何时我们调用一个对象的clone方法，JVM都会帮我们创建一个新的、一样的对象，特别需要说明的是，用clone方法创建对象的过程中并不会调用任何构造函数。&lt;/p&gt;
&lt;p&gt;（4）使用(反)序列化机制创建对象（实现Serializable接口）&lt;/p&gt;
&lt;p&gt;　　当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。&lt;/p&gt;
&lt;h3 id=&quot;二-java-对象的创建过程&quot;&gt;二. Java 对象的创建过程&lt;/h3&gt;
&lt;p&gt;当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量（即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;主要涉及三种执行对象初始化的结构，分别是&lt;span&gt; &lt;span&gt;实例变量初始化&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、实例代码块初始化、构造函数初始化&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;编译器构造类的构造函数&amp;lt;init&amp;gt;()（按顺序执行）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　父类构造器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　实例变量初始化和实例代码块初始化相关代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　本身构造函数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、实例变量初始化和实例代码块初始化按照编程顺序来执行，不允许顺序靠前的实例代码块访问其后面定义的实例变量，但是可以赋值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译错误：代码块不可以访问其后定义的实例变量&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InstanceInitializer {  
    {  
        &lt;span&gt;j &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; i;&lt;/span&gt;  
    }  

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;  
}  

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没问题：代码块可以赋值其后定义的实例变量&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InstanceInitializer {  
    {  
       &lt;span&gt; j &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;  
    }  

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2、每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Java强制要求所有对象(Object是Java的顶层对象，没有超类)构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数（super()/this()必须在第一句，且不能同时出现）。&lt;span&gt;如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、实例化一个类的对象的过程是一个典型的递归过程。&lt;/p&gt;
&lt;p&gt;　　首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。&lt;/p&gt;
&lt;h3&gt;三、综合实例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;

    Foo() {
        System.out.println(i);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------(1)&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; x =&lt;span&gt; getValue();
        System.out.println(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------(2)&lt;/span&gt;
&lt;span&gt;    }

    {
        i &lt;/span&gt;= 2&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Bar &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Foo {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 1&lt;span&gt;;

    Bar() {
        j &lt;/span&gt;= 2&lt;span&gt;;
    }

    {
        j &lt;/span&gt;= 3&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; j;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConstructorExample {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String... args) {
        Bar bar &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar();
        System.out.println(bar.getValue());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------(3)&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Output: 2 0 2
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Foo类构造函数的等价变换：&lt;/span&gt;
&lt;span&gt;Foo() {
    i &lt;/span&gt;= 1&lt;span&gt;;
    i &lt;/span&gt;= 2&lt;span&gt;;
    System.out.println(i);
    &lt;/span&gt;&lt;span&gt;int x = getValue();// 在执行Foo的构造函数的过程中，由于Bar重载了Foo中的getValue方法，所以其调用的是Bar的getValue方法&lt;/span&gt;
&lt;span&gt;    System.out.println(x);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Bar类构造函数的等价变换&lt;/span&gt;
&lt;span&gt;Bar() {
    Foo();
    j &lt;/span&gt;= 1&lt;span&gt;;
    j &lt;/span&gt;= 3&lt;span&gt;;
    j &lt;/span&gt;= 2&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;参考资料：&lt;/h4&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/72466416&quot; target=&quot;_blank&quot;&gt;深入理解Java对象的创建过程：类的初始化与实例化&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 12:09:00 +0000</pubDate>
<dc:creator>那股泥石流</dc:creator>
<og:description>Java对象的创建过程包括 类初始化（JVM类加载机制）和类实例化两个阶段。 一、Java对象创建时机 （1）使用new关键字创建对象 （2）反射创建对象 使用Class类的newInsta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hexinwei1/p/9911202.html</dc:identifier>
</item>
<item>
<title>浅谈中间件 - [流苏]</title>
<link>http://www.cnblogs.com/lz0504/p/9911206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lz0504/p/9911206.html</guid>
<description>&lt;h2 align=&quot;center&quot;&gt;&lt;strong&gt;浅谈中间件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;由来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为工作的原因，我从金蝶集团调入金蝶中间件公司工作以来，经常遇到一个问题就是中间件公司是个什么公司，中间件是什么？，金蝶不是做ERP的吗？怎么也做中间件？。这是我以前在金蝶集团时无法想象的问题。因为金蝶，金蝶ERP的品牌以及大众对ERP的了解，是无需我解析什么是ERP，什么是财务软件一类的问题的。&lt;/p&gt;
&lt;p&gt;　　毕竟，中间件在实际的应用过程中，是对应用软件起到支撑作用，最终用户并不直接使用中间件，中间件不是大众消费类软件产品。因此，除非是一个行业专业人士，一般不大可能与中间件打交道，不太了解什么是中间件。&lt;/p&gt;
&lt;p&gt;　　因此，在系统软件之中，操作系统、数据库、中间件的三驾马车，中间件是最神秘的。因为，好歹大家通过Windows基本上会了解操作系统是个什么东西，尽管不会很全面，很专业，毕竟是有感觉的。数据库，虽然没有直接见过，但基本上明白数据是要一个仓库来储存的，因此，也大致知道数据库管理系统是干什么的。&lt;/p&gt;
&lt;p&gt;　　长期以来，中间件是一个专业化非常强的细分产业。因为中间件的技术门槛比较高，玩家也不多，无论是国外还是国内都是如此。因此，行业内对什么是中间件并不特别在意。而公司名称直接叫中间件的就更少了，金蝶中间件应该是国内外直接在公司名称中冠以中间件字眼最早，也是很少的公司之一。另一方面，因为中间件软件还处于发展阶段，还没有完全成熟，因此对中间件的定义也就没有深究，或者权威的说法。&lt;/p&gt;
&lt;p&gt;　　但现在情况有点变化，其中一个原因在于2008年底，国家启动了核高基重大科技专项，在基础软件领域明确提出重点支持操作系统、数据库、中间件、文字处理等基础软件产业的自主创新，几乎一夜之间大大小小的软件公司都宣称是做中间件的了，只要不是做最终应用软件的，他们的产品都叫中间件了，一时间，中间件变得蓬勃发展起来了。&lt;/p&gt;
&lt;p&gt;　　作为中间件行业内的专业化和领先企业来说，大家都重视起中间件来了，这是好事，说明社会上重视了。对行业的发展和繁荣固然重要，但这也隐含了重大的风险。中间件名字被滥用，无论是对用户，对这个产业，对政府和投资人来说，都会有负面的影响。鱼目混珠，泥沙俱下的局面，对中间件产业的正常发展未必就是好事情了，也可能对真正的中间件自主创新带来许多困扰，模糊了中间件的本质，可能会弱化中间件核心技术的创新和发展。&lt;/p&gt;
&lt;p&gt;　　因此，在这种情况下，无论是对行业内，还是行业外，突然什么是中间件的问题变成了一个大问题了。&lt;/p&gt;
&lt;p&gt;　　本文试图就中间件的来龙去脉，外延内涵和前世今生，来一个全面的阐释。一家之言，权作业界参考，希望带动大家做一些深入的思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;中间件的起源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.1 &lt;/strong&gt;&lt;strong&gt;中间件发展的历史&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;事情从1946年说起，世界上第一台电子计算机埃尼阿克诞生，人类进入信息时代。1955年，约翰巴克斯发明了最早的程序语言Fortran，现代意义上的软件就诞生了。&lt;/p&gt;
&lt;p&gt;　　1964年，IBM发布OS/360操作系统，软件与硬件分离，同时，软件成为一个独立的产业正式登上产业界的舞台。中间件就是软件产业不断发展过程中自然产生的。&lt;/p&gt;
&lt;p&gt;　　90年代，文顿·瑟夫这位互联网之父的发明成为改变IT业的重大革命性创新。互联网促使分布式系统和网络应用的诞生，中间件就是伴随网络技术的产生、发展而兴起的，可以说没有网络就没有现代意义上的中间件。因为，网络环境需要解决异构分布网络环境下软件系统的通信、互操作、协同、事务、安全等共性问题，提高异构分布网络环境下软件系统的互操作性、可移植性、适应性、可靠性等问题。&lt;/p&gt;
&lt;p&gt;　　1968年IBM发布CICS交易事务控制系统，使得应用软件与系统服务分离，这是中间件技术萌芽的标志，因为CICS还不是分布式环境的产物，因此我们往往还不将CICS作为正式的中间件系统。&lt;/p&gt;
&lt;p&gt;　　一般来说，我们将1990年诞生于ATT公司的BELL实验室的Tuxedo系统（后来被NOVELL从ATT公司随着UNIX系统一起买走，后来又卖给了BEA公司，现在归于ORACLE公司旗下了）作为中间件的诞生标志。Tuxedo解决了分布式交易事务控制问题，中间件开始成为网络应用的基础设施，中间件正式成型，这是最早的交易中间件。&lt;/p&gt;
&lt;p&gt;　　1994年IBM发布消息队列服务MQ系列产品，解决分布式系统异步、可靠、传输的通讯服务问题，消息中间件诞生。&lt;/p&gt;
&lt;p&gt;　　1995年，JAVA之父James Gosling发明JAVA语言，JAVA提供了跨平台的通用的网络应用服务，成为今天中间件的核心技术。JAVA是第一个天生的网络应用平台，特别是J2EE发布以来，JAVA从一个编程语言，演变为网络应用架构，成为应用服务平台的事实标准。应用服务器中间件，成为中间件技术的集大成者，也成为事实上的中间件的核心。&lt;/p&gt;
&lt;p&gt;　　2001年，微软发布.NET，中间件演变为.NET和JAVA两大技术阵营。但由于.NET还不是一个完全开放的技术体系，只有一个玩家，因此，虽然.NET也是一种中间件，但由于IBM/ORACLE/SUN/SAP等巨头都无一例外成了JAVA阵营的支持者，因此，我们习惯上提到中间件时，往往不包括.NET中间件体系。&lt;/p&gt;
&lt;p&gt;　　以上谈的是历史，但透过历史事实背后，为什么会出现中间件，这其中的本质因素是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;2.2&lt;/strong&gt; &lt;strong&gt;中间件发展的驱动力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　中间件出现的驱动力主要来自软件研发过程碰到的种种问题。从软件出现最早是用于科学计算，然后是计算机辅助设计、辅助制造等等工业应用。在企业管理领域大规模应用后，业务需求不断的变化、系统不断增加、流程更复杂、系统越来越不堪重负，出现了需求交付方面的重大挑战，以至于人们用软件危机来描述软件工业所面临的困境。&lt;/p&gt;
&lt;p&gt;　　总结起来，软件工业面临的主要问题是四个方面：质量问题、效率问题、互操作问题、灵活应变问题。这些问题今天依然困扰着这个行业。&lt;/p&gt;
&lt;p&gt;　　造成这个局面的原因是异构性和标准规范的滞后。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;屏蔽异构性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　异构性表现在计算机的软硬件之间的异构性，包括硬件（CPU和指令集、硬件结构、驱动程序等），操作系统（不同操作系统的API和开发环境）、数据库（不同的存储和访问格式）等等。长期以来，高级语言依赖于特定的编译器和操作系统API来编程，而他们是不兼容的，因此软件必须依赖于开发和运行的环境。&lt;/p&gt;
&lt;p&gt;　　造成异构的原因源自市场竞争、技术升级以及保护投资等因素。希望屏蔽异构平台的差异性问题是促成中间件发展的驱动力之一。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;实现互操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　因为异构性，产生的结果是软件依赖于计算环境，使得各种不同软件之间在不同平台之间不能移植，或者移植非常困难。而且，因为网络协议和通信机制的不同，这些系统之间还不能有效地相互集成。&lt;/p&gt;
&lt;p&gt;　　造成互操作性不好的原因，主要是标准的滞后。解决软件之间的互操作性问题也是促成中间件发展的驱动力之一。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;共性凝练和复用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　软件应用领域越来越多，相同领域的应用系统之间许多基础功能和结构是有相似性的，每次开发系统都从零开始绝对不是一种好的方法，也是对质量和效率的很大的伤害。&lt;/p&gt;
&lt;p&gt;　　尽可能多地凝练共性并复用以提高软件开发效率和质量，通过中间件通过提供简单、一致、集成的开发和运行环境，简化分布式系统的设计、编程和管理，这也是中间件发展的重要驱动力。&lt;/p&gt;
&lt;p&gt;　　在长期的探索过程中，解决软件的四个问题的办法总结起来两个方面：工程方法、平台与技术。&lt;/p&gt;
&lt;p&gt;　　工程方法就是用工业工程、系统工程的理论、方法和体系来解决软件研发过程中的管理问题，包括团队管理、项目管理、质量控制等等，这就是软件工程。除了软件工程方法之外，我们发明了更多的架构规划、设计和实施的方法，不断累积领域的知识与经验等等。&lt;/p&gt;
&lt;p&gt;　　更好的技术手段，包括更好的程序设计语言、更好的平台和软件开发技术，如面向对象、组件开发、面向服务等等。而这方面，在技术上逐渐发展的成果大部分都凝聚在今天的中间件平台之中。&lt;/p&gt;
&lt;p&gt;　　而这些更好的技术手段，从本质上是通过复用、松耦合、互操作（标准）等机制来提高软件质量、加快软件研发效率、使研发出来的产品能够相互集成并灵活适应变化。&lt;br/&gt;这些因素逐渐促成了中间件软件的形成和发展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;3.&lt;/strong&gt; &lt;strong&gt;中间件的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　讲了这么多，究竟什么是中间件，也就是中间件的定义是什么？&lt;/p&gt;
&lt;p&gt;　　针对这个问题，应该说还没有一个标准的定义，或者说还没有完全取得学术界和产业界的共识。&lt;/p&gt;
&lt;p&gt;　　顾名思义，中间件就是处于中间的软件。但这种不是从功能，或者特性来定义的概念，而是用位置来定义的名字，就容易被不同的人从不同角度赋予其不同的含义。&lt;/p&gt;
&lt;p&gt;　　IDC曾经给中间件下的定义是中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。&lt;/p&gt;
&lt;p&gt;　　我国学术界一般认可的定义是中间件是指网络环境下处于操作系统、数据库等系统软件和应用软件之间的一种起连接作用的分布式软件，主要解决异构网络环境下分布式应用软件的互连与互操作问题，提供标准接口、协议，屏蔽实现细节，提高应用系统易移植性（北京大学梅宏）。&lt;/p&gt;
&lt;p&gt;　　中科院软件所研究员仲萃豪形象地把中间件定义为平台＋通信。这个定义限定了只有用于分布式系统中的此类软件才能被称为中间件，同时此定义还可以把中间件与支撑软件和实用软件区分开来。&lt;/p&gt;
&lt;p&gt;　　中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。形象地说就是上下之间的中间。&lt;/p&gt;
&lt;p&gt;　　此外，中间件主要为网络分布式计算环境提供通信服务、交换服务、语义互操作服务等系统之间的协同集成服务，解决系统之间的互连互通问题。形象地说就是所谓左右之间的中间。&lt;/p&gt;
&lt;p&gt;　　要深入理解什么是中间件，形式化的定义固然重要，我们还得从概念本身去深入理解其核心特征才是最重要的。要理解一个概念，从内涵和外延两个方面去描述是哲学上非常重要的一套方法体系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;3.1&lt;/strong&gt; &lt;strong&gt;中间件的特征（内涵）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;总结分析，中间件有几个非常重要的特征是必须具备的：&lt;/p&gt;
&lt;p&gt;　　所谓平台就是能够独立运行并自主存在，为其所支撑的上层系统和应用提供运行所依赖的环境。显然，不是所有的系统或者应用都可以称之为平台的。中间件是一个平台，因此中间件是必须独立存在，是运行时刻的系统软件，它为上层的网络应用系统提供一个运行环境，并通过标准的接口和API来隔离其支撑的系统，实现其独立性，也就是平台性。&lt;/p&gt;
&lt;p&gt;　　因此，目前许多的开发语言、组件库和各种报表设计之类的软件，很难满足平台性，将这类软件叫中间件，是很不合适的。例如，JAVA是一种语言，这种语言的开发工具和开发框架，如Eclipse、JBuilder、Struts，Hibernate等等就不能称为中间件，充其量叫中间件开发工具，而不能叫中间件本身，就如同各种建筑工程设备和机械，如吊臂、搅拌机等不能叫建筑，而只能成为建筑工具一样。而J2EE应用服务器提供JAVA应用的运行环境，就是经典的中间件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;应用支撑&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　中间件的最终目的是解决上层应用系统的问题，而且也是软件技术发展到今天对应用软件提供最完善彻底的解决方案。&lt;/p&gt;
&lt;p&gt;　　高级程序设计语言的发明，使得软件开发变成一个独立的科学和技术体系，而操作系统平台的出现，使得应用软件通过标准的API接口，实现了软件与硬件的分离。&lt;/p&gt;
&lt;p&gt;　　现代面向服务的中间件在软件的模型、结构、互操作以及开发方法等四个方面提供了更强的应用支撑能力：&lt;/p&gt;
&lt;p&gt;　　模型：构件模型弹性粒度化，即通过抽象层度更高的构件模型，实现具备更高结构独立性、内容自包含性和业务完整性的可复用构件，即服务。并且在细粒度服务基础上，提供了更粗粒度的服务封装方式，即业务层面的封装，形成业务组件，就可以实现从组件模型到业务模型的全生命周期企业建模的能力。&lt;/p&gt;
&lt;p&gt;　　结构：结构松散化，即，将完整分离服务描述和服务功能实现以及服务的使用者和提供者，从而避免分布式应用系统构建和集成时常见的技术、组织、时间等不良约束。&lt;/p&gt;
&lt;p&gt;　　互操作：交互过程标准化，即，将与互操作相关的内容进行标准化定义，如服务封装、描述、发布、发现、调用等契约，通信协议以及数据交换格式等等。最终实现访问互操作、连接互操作和语义互操作。&lt;/p&gt;
&lt;p&gt;　　开发集成方法：应用系统的构建方式由代码编写转为主要通过服务间的快捷组合及编排，完成更为复杂的业务逻辑的按需提供和改善，从而大大简化和加速应用系统的搭建及重构过程。&lt;/p&gt;
&lt;p&gt;　　而要最终解决软件的质量问题、效率问题、互操作问题、灵活应变问题这四大问题，需要在软件技术的内在结构(Structure)、架构(Architecture)层面进行思考。&lt;/p&gt;
&lt;p&gt;　　解决这些问题，技术的本质是复用、松耦合、互操作(标准)等软件技术的内在机制。这也是中间件技术和产品的本质特征。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;软件复用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　软件复用，即软件的重用，也叫再用，是指同一事物不作修改或稍加改动就多次重复使用。从软件复用技术的发展来看，就是不断提升抽象级别，扩大复用范围。最早的复用技术是子程序，人们发明子程序，就可以在不同系统之间进行复用了。但是，子程序是最原始的复用，因为这种复用范围是一个可执行程序内复用，静态开发期复用，如果子程序修改，意味着所有调用这个子程序的程序必须重新编译、测试和发布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　复用对象复用范围&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;263&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;复用对象&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;290&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;复用范围&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;263&quot;&gt;
&lt;p align=&quot;left&quot;&gt;子程序&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;290&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个可执行程序内复用，静态开发期 复用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;263&quot;&gt;
&lt;p align=&quot;left&quot;&gt;组件(DLL,Com等)&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;290&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;系统内复用，动态运行期复用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;263&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;企业对象组件（Com+,.NET,EJB等)&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;290&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;企业网络内复用，不同系统之间复用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;263&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;服务 (如WebService,SCA/SDO)&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;290&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;不同企业之间，全球复用，动态可配置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　为了解决这个问题，发明了组件（或者叫控件），如MS操作系统下的DLL组件。组件将复用提升了一个层次，因为组件可以在一个系统内复用（同一种操作系统），而且是动态、运行期复用。这样组件可以单独发展，组件与组件调用者之间的耦合度降低。&lt;/p&gt;
&lt;p&gt;　　为解决分布式网络计算之间的组件复用，人们发明了企业对象组件，如（COM+, .NET, EJB等)，或者叫分布式组件。通过远程对象代理，来实现企业网络内复用，不同系统之间复用。&lt;/p&gt;
&lt;p&gt;　　传统中间件的核心是组件对象的管理。但分布式组件也是严重依赖其受控环境，由于构件实现和运行支撑技术之间存在着较大的异构性，不同技术设计和实现的构件之间无法直接组装式复用。&lt;/p&gt;
&lt;p&gt;　　而现代中间件的发展重要趋势就是以服务为核心，如WebService, SCA/SDO等。通过服务，或者服务组件来实现更高层次的复用、解耦和互操作，即SOA架构中间件。&lt;/p&gt;
&lt;p&gt;　　因为服务是通过标准封装，服务组件之间的组装、编排和重组，来实现服务的复用。而且这种复用，可以在不同企业之间，全球复用，达到复用的最高级别，并且是动态可配置的复用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;耦合关系&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;基于SOA架构的中间件，在松耦合解耦过程也发展到了最后的境界。传统软件将软件之中核心三部分——网络连接、数据转换、业务逻辑全部耦合在一个整体之中，形成铁板一块的软件，牵一发而动全身，软件就难以适应变化。分布式对象技术将“连接逻辑”进行分离，消息中间件将“连接逻辑”进行异步处理，增加了更大的灵活性。消息代理和一些分布式对象中间件将数据转换也进行了分离。而SOA架构，通过服务的封装，实现了业务逻辑与网络连接、数据转换等进行完全的解耦。&lt;/p&gt;

&lt;p&gt;                                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1357701/201811/1357701-20181105200538384-428511169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;软件技术的不断解耦的过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;互操作性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;传统软件互操作技术也存在问题。互联网前所未有的开放性意味着各节点可采用不同的中间件技术，对技术细节进行了私有化的约束，构件模型和架构没有统一标准，从而导致中间件平台自身在构件描述、发布、发现、调用、互操作协议及数据传输等方面呈现出巨大的异构性。各种不良技术约束的结果是软件系统跨互联网进行交互变得困难重重，最终导致了跨企业/部门的业务集成和重组难以灵活快速的进行。&lt;/p&gt;
&lt;p&gt;　　在软件的互操作方面，传统中间件只是实现了访问互操作，即通过标准化的API实现了同类系统之间的调用互操作，而连接互操作还是依赖于特定的访问协议，如JAVA使用RMI，CORBA使用IIOP等。而SOA通过标准的、支持Internet、与操作系统无关的SOAP协议实现了连接互操作。而且，服务的封装是采用XML协议，具有自解析和自定义的特性，这样，基于SOA的中间件还可以实现语义互操作。&lt;/p&gt;
&lt;p&gt;                                                                                                                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1357701/201811/1357701-20181105200738550-1415992562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;基于服务的中间件&lt;/p&gt;
&lt;p&gt;　　总之，服务化体现的是中间件在完整业务复用、灵活业务组织方面的发展趋势，其核心目标是提升IT基础设施的业务敏捷性。因此，中间件将成为SOA的主要实现平台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;3.2&lt;/strong&gt; &lt;strong&gt;中间件的分类（外延）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;中间件所包括的范围十分广泛，针对不同的应用需求涌现出多种各具特色的中间件产品。从功能性外延来看，中间件包括交易中间件、消息中间件、集成中间件等各种功能性的中间件技术和产品。&lt;/p&gt;
&lt;p&gt;　　现在，中间件已经成为网络应用系统开发、集成、部署、运行和管理必不可少的工具。由于中间件技术涉及网络应用的各个层面，涵盖从基础通讯、数据访问到应用集成等众多的环节，因此，中间件技术呈现出多样化的发展特点。&lt;/p&gt;
&lt;p&gt;　　根据中间件在软件支撑和架构的定位来看，基本上可以分为三大类产品：应用服务类中间件、应用集成类中间件、业务架构类中间件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;应用服务类中间件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;为应用系统提供一个综合的计算环境和支撑平台，包括对象请求代理（ORB）中间件、事务监控交易中间件、JAVA应用服务器中间件等。&lt;/p&gt;
&lt;p&gt;　　随着对象技术与分布式计算技术的发展，两者相互结合形成了分布对象计算，并发展为当今软件技术的主流方向。1990年底，对象管理组织OMG首次推出对象管理结构OMA(Object Management Architecture)，对象请求代理（Object Request Broker）是这个模型的核心组件。它的作用在于提供一个通信框架，透明地在异构的分布计算环境中传递对象请求。CORBA规范包括了ORB的所有标准接口，是对象请求代理的典型代表。&lt;/p&gt;
&lt;p&gt;　　随着分布计算技术的发展，分布应用系统对大规模的事务处理提出了需求，比如商业活动中大量的关键事务处理。事务处理监控界于Client和Server之间，进行事务管理与协调、负载平衡、失败恢复等，以提高系统的整体性能。它可以被看作是事务处理应用程序的操作系统。这类被称为交易中间件，适用于联机交易处理系统，主要功能是管理分布于不同计算机上的数据的一致性，保障系统处理能力的效率与均衡负载。交易中间件所遵循的主要标准是X/open DTP模型，典型的产品是Tuxedo。&lt;/p&gt;
&lt;p&gt;　　JAVA从2.0企业版之后，不仅仅是一种编程语言，而且演变为一个完整的计算环境和企业架构。为JAVA应用提供组件容器，用来构造Internet应用和其它分布式构件应用，是企业实施电子商务的基础设施，这种应用服务器中间件发展到为企业应用提供数据访问、部署、远程对象调用、消息通信、安全服务、监控服务、集群服务等强化应用支撑的服务。使得JAVA应用服务器成为了事实上的应用服务器工业标准。由于它的开放性，使得交易中间件和对象请求代理逐渐融合到应用服务器之中。典型的应用服务器产品包括IBM Websphere Application Server、Oracle Weblogic Application Server和金蝶Apusic Application Server等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;应用集成类中间件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　应用集成类中间件是提供各种不同网络应用系统之间的消息通信、服务集成和数据集成的功能，包括常见的消息中间件、企业集成EAI、企业服务总线以及相配套的适配器等。&lt;/p&gt;
&lt;p&gt;　　消息中间件指的是利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可在分布环境下扩展进程间的通信，并支持多通讯协议、语言、应用程序、硬件和软件平台，实现应用系统之间的可靠异步消息通信，能够保障数据在复杂的网络中高效、稳定、安全、可靠的传输，并确保传输的数据不错、不重、不漏、不丢。目前流行的消息中间件产品有IBM的MQSeries、 BEA的MessageQ、金蝶Apusic MQ等。&lt;/p&gt;
&lt;p&gt;　　企业应用整合，仅指企业内部不同应用系统之间的互连，以期通过应用整合实现数据在多个系统之间的同步和共享。这种类似集线器的架构模式是在基于消息的基础上，引入了前置机-服务器的概念，使用一种集线器/插头（hub-and-spoke）的架构，将消息路由信息的管理和维护从前置机迁移到了服务器上，巧妙的把集成逻辑和业务逻辑分离开来，大大增加了系统弹性。由于前置机和服务器之间不再直接通信，每个前置机只通过消息和服务器之间通信，将复杂的网状结构变成了简单的星型结构。典型的企业应用集成EAI的产品包括Tibico和Informatica等公司产品。&lt;/p&gt;
&lt;p&gt;　　随着SOA思想和技术的逐渐成熟，EAI发展到透过业务服务的概念来提供IT的各项基本应用功能，让这些服务可以自由地被排列组合、融会贯通，以便在未来能随时弹性配合新的需求而调整。Web Services是SOA的一种具体实现方式，SOA的世界是由服务提供者（Service Provider）、服务请求者（Service Requester） 以及服务代理者（Service Broker）所组成，目标是将所有具备价值的IT资源，不论是旧的或新的，通通都能够透过Web Services的包装，成为随取即用的IT资产，并可将各种服务快速汇整，开发出组合式应用，达到整合即开发的目的。SOA的架构只是实现和解决了服务模块间调用的互操作问题，为了更好的服务于企业应用，引入了企业服务总线的应用架构（Enterprise Service Bus，ESB）。这一构架是基于消息通信、智能路由、数据转换等技术实现的。ESB提供了一个基于标准的松散应用耦合模式，这就是企业服务总线中间件，是一种综合的企业集成中间件。典型的ESB产品包括IBM Websphere ESB、Oracle公司的Weblogic ESB以及金蝶Apusic ESB等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;业务架构类中间件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;作为共性的凝练，中间件不仅要从底层的技术入手，将共性技术的特征抽象进中间层，还要更多地把目光投向到业务层面上来，根据业务的需要，驱动自身能力的不断演进，即，不断出现的新的业务需要驱动了应用模式和信息系统能力的不断演进，进而要求中间件不断地凝练更多的业务共性，提供针对性支撑机制。近年来，这一需求趋势愈发明显，越来越多的业务和应用模式被不断地抽象进入中间件的层次，如业务流程流、业务模型、业务规则、交互应用等等，其结果是中间件凝练的共性功能越来越多，中间件的业务化和领域化的趋势非常明显。&lt;/p&gt;
&lt;p&gt;　　业务架构类中间件包括业务流程、业务管理和业务交互等几个业务领域的中间件。&lt;/p&gt;
&lt;p&gt;　　业务流程是处理业务模型的非常重要方法。管理流程与各职能部门和业务单元有密切关系，须藉各部门间的紧密协调，以达到企业运营和管理功能的目标。在业务流程支持方面，从早期的WfMC定义的工作流，到基于服务的业务流程规范BPEL，由业务流程的支撑，逐渐形成了完整的业务流程架构模型，包括流程建模、流程引擎、流程执行、流程监控和流程分析等。有名的业务流程中间件包括基于工作流的IBM Lotus Workflow，基于BPEL的IBM Webshpere Process Server以及同时支持工作流和BPEL的金蝶Apusic BPM等。&lt;/p&gt;
&lt;p&gt;　　业务管理就是对业务对象的建模和业务规则的定义、运行和监控的中间件平台。策略管理员和开发人员将业务逻辑捕获为业务规则。使用规则管理器可以将规则轻松地嵌入 Web、现有应用程序和后台办公应用程序。常见的业务管理中间件包括IBM Websphere ILOG 业务规则管理系统，金蝶BOS等。&lt;/p&gt;
&lt;p&gt;　　业务交互的中间件平台提供组织的合作伙伴、员工和客户通过WEB和移动设备等交互工具，实现基于角色、上下文、操作、位置、偏好和团队协作需求的个性化的用户体验。这种门户服务器软件基于标准Portlet组合的应用程序访问框架，实现用户集成和交互集成，构建灵活、基于 SOA 的应用架构。典型的门户中间件有IBM Websphere Portal Server和金蝶Apusic Portal Server等。&lt;/p&gt;
&lt;p&gt;　　4. &lt;strong&gt;中间件的未来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　中间件是互联网时代的IT基础设施，提供业务的灵活性，消除信息孤岛，提高IT的研发和运营效率。作为网络计算的核心基础设施，中间件正在呈现出服务化、自治化、业务化、一体化等诸多新的发展趋势，中间件进入2.0时代，将极大提升互联网统一计算平台的敏、睿、融、和能力。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;中间件将变宽变厚&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　以互联网为核心的多网融合产生了丰富多样的新型网络应用模式，作为主流的应用运行支撑环境，中间件无处不在，越来越多的应用模式被抽象到中间件层，中间件将变宽变厚。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;中间件将面向服务、易于集成&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　随着SOA技术逐渐成为主流，以及异构系统的集成问题日益严峻，中间件将向面向服务、易于集成的方向发展。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;中间件将向一体化的方向发展&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　中间件产品的种类日趋多样（如交易中间件、消息中间件、应用服务器、集成中间件、业务中间件等），但其技术架构将向一体化的方向发展，主要包括：&lt;/p&gt;
&lt;p&gt;　　统一内核，易于演化：各大厂商的中间件产品将构建在统一内核之上，使其易于平台演化。&lt;/p&gt;
&lt;p&gt;　　统一编程模型，易于开发：不同中间件产品提供了不同的编程模型，这些编程模型将趋向统一，从而达到易于开发的目的。&lt;/p&gt;
&lt;p&gt;　　统一管理模型，易于系统维护：不同中间件产品提供了不同的管理工具与管理手段，这些管理工具与手段将趋向统一，使其易于管理，降低运维成本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;中间件产品将支持云计算，易于交付&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　中间件产品将成为云计算的支撑平台，使应用易于交付。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;后端平台深度融合&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;一个大胆的设想是：未来五年，浏览器将统一前端，而后端平台（中间件、操作系统、 数据库）走向深度融合。（对中间件的未来发展趋势的详细介绍参加另文《中间件技术的发展趋势分析》，在此不做详细论述。）&lt;/p&gt;
&lt;p&gt;　　综上所述，我们可以认为中间件是一种独立的系统软件平台，为网络应用软件提供综合的服务和完整的计算环境，借助这种软件使得网络应用能够实现集成，达到业务的协同，实现业务的灵活性。&lt;/p&gt;

</description>
<pubDate>Mon, 05 Nov 2018 12:09:00 +0000</pubDate>
<dc:creator>[流苏]</dc:creator>
<og:description>浅谈中间件 1. 由来 因为工作的原因，我从金蝶集团调入金蝶中间件公司工作以来，经常遇到一个问题就是中间件公司是个什么公司，中间件是什么？，金蝶不是做ERP的吗？怎么也做中间件？。这是我以前在金蝶集团</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lz0504/p/9911206.html</dc:identifier>
</item>
<item>
<title>mysql锁机制详解 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/9890832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/9890832.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　大概几个月之前项目中用到事务，需要保证数据的强一致性，期间也用到了mysql的锁，但当时对mysql的锁机制只是管中窥豹，所以本文打算总结一下mysql的锁机制。&lt;/p&gt;
&lt;p&gt;　　本文主要论述关于mysql锁机制，mysql版本为5.7，引擎为innodb，由于实际中关于innodb锁相关的知识及加锁方式很多，所以没有那么多精力罗列所有场景下的加锁过程并加以分析，仅根据现在了解的知识，结合官方文档，说说自己的理解，如果发现有不对的地方，欢迎指正。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;　　总的来说，InnoDB共有七种类型的锁：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享/排它锁(Shared and Exclusive Locks)&lt;/li&gt;
&lt;li&gt;意向锁(Intention Locks)&lt;/li&gt;
&lt;li&gt;记录锁(Record Locks)&lt;/li&gt;
&lt;li&gt;间隙锁(Gap Locks)&lt;/li&gt;
&lt;li&gt;临键锁(Next-key Locks)&lt;/li&gt;
&lt;li&gt;插入意向锁(Insert Intention Locks)&lt;/li&gt;
&lt;li&gt;自增锁(Auto-inc Locks)&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;mysql锁详解&lt;/h2&gt;
&lt;h3&gt;1. 共享/排它锁(Shared and Exclusive Locks)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;共享锁（Share Locks，记为S锁），读取数据时加S锁&lt;/li&gt;
&lt;li&gt;排他锁（eXclusive Locks，记为X锁），修改数据时加X锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　使用的语义为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享锁之间不互斥，简记为：读读可以并行&lt;/li&gt;
&lt;li&gt;排他锁与任何锁互斥，简记为：写读，写写不可以并行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　可以看到，一旦写数据的任务没有完成，数据是不能被其他任务读取的，这对并发度有较大的影响。对应到数据库，可以理解为，写事务没有提交，读相关数据的select也会被阻塞，这里的select是指加了锁的，普通的select仍然可以读到数据(快照读)。&lt;/p&gt;
&lt;h3&gt;2. 意向锁(Intention Locks)&lt;/h3&gt;
&lt;p&gt;　　InnoDB为了支持多粒度锁机制(multiple granularity locking)，即允许行级锁与表级锁共存，而引入了意向锁(intention locks)。意向锁是指，未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;意向锁是一个表级别的锁(table-level locking)；&lt;/li&gt;
&lt;li&gt;意向锁又分为：
&lt;ul&gt;&lt;li&gt;意向共享锁(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁；&lt;/li&gt;
&lt;li&gt;意向排它锁(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　加锁的语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; ... lock &lt;span&gt;in&lt;/span&gt;&lt;span&gt; share mode;　　要设置IS锁；
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; ... &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update;&lt;/span&gt;　　　　　　 要设置IX锁；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务要获得某些行的S/X锁，必须先获得表对应的IS/IX锁，意向锁仅仅表明意向，意向锁之间相互兼容，兼容互斥表如下：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;兼 容&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;兼 容&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;兼 容&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;兼 容&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;　　虽然意向锁之间互相兼容，但是它与共享锁/排它锁互斥，其兼容互斥表如下:&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;S&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;X&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;兼 容&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;互 斥&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;互 斥&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;互 斥&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;　　排它锁是很强的锁，不与其他类型的锁兼容。这其实很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。&lt;/p&gt;
&lt;h3&gt;3. 记录锁(Record Locks)&lt;/h3&gt;
&lt;p&gt;　　记录锁，它封锁索引记录，例如(其中id为pk)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
create table lock_example(id smallint(10),name varchar(20),primary key id)engine=innodb;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　数据库隔离级别为RR，表中有如下数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
10&lt;span&gt;, zhangsan
20&lt;span&gt;, lisi
30, wangwu&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实这里是先获取该表的意向排他锁(IX)，再获取这行记录的排他锁(我的理解是因为这里直接命中索引了)，以阻止其他事务插入，更新，删除id=1的这一行。&lt;/p&gt;
&lt;h3&gt;4. 间隙锁(Gap Locks)&lt;/h3&gt;
&lt;p&gt;　　间隙锁，它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。依然是上面的例子，InnoDB，RR：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; lock_example
    &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; id &lt;span&gt;between&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; 
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个SQL语句会封锁区间(8,15)，以阻止其他事务插入id位于该区间的记录。&lt;/p&gt;
&lt;p&gt;　　间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。&lt;strong&gt;&lt;span&gt;如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5. 临键锁(Next-key Locks)&lt;/h3&gt;
&lt;p&gt;　　临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。&lt;/p&gt;
&lt;p&gt;　　默认情况下，innodb使用next-key locks来锁定记录。但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。&lt;/p&gt;
&lt;p&gt;　　举个例子，依然是如上的表lock_example，&lt;span&gt;但是id降级为普通索引(key)，也就是说即使这里声明了要加锁(for update)，而且命中的是索引，但是因为索引在这里没有UK约束，所以innodb会使用next-key locks&lt;/span&gt;，数据库隔离级别RR：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;事务A执行如下语句，未提交：&lt;br/&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; lock_example &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;p&gt;事务B开始，执行如下语句，会阻塞：
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
insert into lock_example values('zhang',15);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上的例子，事务A执行查询语句之后，默认给id=20这条记录加上了next-key lock，所以事务B插入10(包括)到30(不包括)之间的记录都会阻塞。临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别&lt;strong&gt;降级为RC，临键锁则也会失效&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;6. 插入意向锁(Insert Intention Locks)&lt;/h3&gt;
&lt;p&gt;　　对已有数据行的修改与删除，必须加强互斥锁(X锁)，那么对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。&lt;/p&gt;
&lt;p&gt;　　插入意向锁，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Insert Intention Lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　举个例子(表依然是如上的例子lock_example，数据依然是如上)，事务A先执行，在10与20两条记录中插入了一行，还未提交：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;, xxx);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务B后执行，也在10与20两条记录中插入了一行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
insert into t values(12, ooo);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为是插入操作，虽然是插入同一个区间，但是插入的记录并不冲突，所以使用的是插入意向锁，此处A事务并不会阻塞B事务。&lt;/p&gt;
&lt;h3&gt;7. 自增锁(Auto-inc Locks)&lt;/h3&gt;
&lt;p&gt;　　自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;AUTO-INC lock is a special table-level lock taken by transactions inserting into tables with AUTO_INCREMENT columns. In the simplest case, if one transaction is inserting values into the table, any other transactions must wait to do their own inserts into that table, so that rows inserted by the first transaction receive consecutive primary key values.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　举个例子(表依然是如上的例子lock_example)，但是id为AUTO_INCREMENT，数据库表中数据为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, zhangsan
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, lisi
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, wangwu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务A先执行，还未提交： insert into t(name) values(xxx);&lt;/p&gt;
&lt;p&gt;　　事务B后执行： insert into t(name) values(ooo);&lt;/p&gt;
&lt;p&gt;　　此时事务B插入操作会阻塞，直到事务A提交。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt; 　　以上总结的7种锁，个人理解可以按两种方式来区分：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. 按锁的互斥程度来划分，可以分为共享、排他锁；&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享锁(S锁、IS锁)，可以提高读读并发；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;为了保证数据强一致，InnoDB使用强互斥锁(X锁、IX锁)，保证同一行记录修改与删除的串行性；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;2. 按锁的粒度来划分，可以分为：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表锁：意向锁(IS锁、IX锁)、自增锁；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;行锁：记录锁、间隙锁、临键锁、插入意向锁；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　其中&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;InnoDB的细粒度锁(即行锁)，是实现在索引记录上的(我的理解是如果未命中索引则会失效)；　　&lt;/li&gt;
&lt;li&gt;记录锁锁定索引记录；间隙锁锁定间隔，防止间隔中被其他事务插入；临键锁锁定索引记录+间隔，防止幻读；&lt;/li&gt;
&lt;li&gt;InnoDB使用插入意向锁，可以提高插入并发；&lt;/li&gt;
&lt;li&gt;间隙锁(gap lock)与临键锁(next-key lock)&lt;strong&gt;只在RR以上的级别生效，RC下会失效&lt;/strong&gt;；&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 05 Nov 2018 11:46:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>mysql锁机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/9890832.html</dc:identifier>
</item>
<item>
<title>Node.js(day2) - 风之之</title>
<link>http://www.cnblogs.com/fzz9/p/9911015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzz9/p/9911015.html</guid>
<description>&lt;h2 id=&quot;一使用node实现基本apache的功能&quot;&gt;一、使用Node实现基本Apache的功能&lt;/h2&gt;
&lt;p&gt;在上一篇笔记中，我们提到如果打开一个文件需要进行一次url判断是繁琐的，我们希望我们的Node具有类似Apache这种web服务器的一个功能：将文件放到www这个文件夹下，我们只要输入对应的文件地址就能访问到相应文件。&lt;br/&gt;之前我们是对每一个文件进行&lt;code&gt;request.url&lt;/code&gt;判断，再处理相应的&lt;code&gt;Content-Type&lt;/code&gt;，这样比较麻烦，现在我们对url进行统一处理即可：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要模拟www文件的功能，我们先将我们的项目放到www文件夹下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-ee1d54071296d1c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;统一处理访问www文件夹下文件的url&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var http = require('http');
var fs = require('fs');

var server = http.createServer();
server.listen(8000);
console.log('server running');

server.on('request',function(request,response){
    var url = request.url;
    var rootDir = 'D:/Users/Administrator/Desktop/Node/www';//www文件夹路径
    var filePath = '/index.html';//文件地址，默认打开index.html
    if(url !== '/'){
        filePath = url;
    }

    //根据url打开文件
    fs.readFile(rootDir+filePath,function(err,data){
        if(err){
            return response.end('404,Not Fond!');
        }
        response.end(data);
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理是一样的，只不过进行了统一处理；浏览器其实会自动判断data的类型来处理文件，所以很多时候不用设置Content-Type。&lt;/p&gt;
&lt;h2 id=&quot;二案例使用node实现显示文件目录的效果&quot;&gt;二、案例：使用Node实现显示文件目录的效果&lt;/h2&gt;
&lt;p&gt;在浏览器中输入目录地址我们可以看到这样的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-3fb457a0457f1a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在使用Node来实现这个效果，我们需要知道fs模块的一个方法：&lt;code&gt;readdir()&lt;/code&gt;即读取目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var http = require('http');
var fs = require('fs');

var server = http.createServer();
server.listen(8000);
console.log('server running');

server.on('request',function(request,response){
    var url = request.url;
    var rootDir = 'D:/Users/Administrator/Desktop/Node/www';//www文件夹路径

    //读取目录
    fs.readdir(rootDir,function(err,data){
        if(err){
            return response.end('404,Not Fond!');
        }
        console.log(data);
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-baf8d7491550ecb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，读取的数据data是以数组形式显示出对于路径下的文件（夹）名。&lt;br/&gt;现在我们只需要将这些数据显示在页面中即可，怎么将数据变成网页效果呢，一般情况下我们可以使用模块代码来提高效率，类似这样的逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-1490a1e1db49528d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实就是想数据填到对应的位置，而不用去关心相应的页面效果，页面效果交给模板代码来处理，我们只需要关注两件事：获取数据data；将data填入模板代码中并使用。&lt;br/&gt;（这里的模板代码我们自己随便写一个好了）&lt;/p&gt;
&lt;h3 id=&quot;编写模板代码&quot;&gt;1.编写模板代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;DirShow&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;XXXURL的索引&amp;lt;/h1&amp;gt;
&amp;lt;div style=&quot;display: block;&quot;&amp;gt;
  &amp;lt;a href=&quot;#&quot;&amp;gt;
    &amp;lt;span&amp;gt;[上级目录]&amp;lt;/span&amp;gt;
  &amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;table&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th&amp;gt;名称&amp;lt;/th&amp;gt;
      &amp;lt;th class=&quot;detailsColumn&quot;&amp;gt;
        大小
      &amp;lt;/th&amp;gt;
      &amp;lt;th class=&quot;detailsColumn&quot;&amp;gt;
        修改日期
      &amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/thead&amp;gt;
  &amp;lt;tbody id=&quot;tbody&quot;&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;css/&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;1k&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;2018/11/5 上午10:50:48&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-223bd5115e4e0226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果如上，我们把框起来的部分使用我们读取的data替换掉就好了：&lt;/p&gt;
&lt;h3 id=&quot;获取数据&quot;&gt;2.获取数据&lt;/h3&gt;
&lt;p&gt;上面已经获取过，使用&lt;code&gt;readdir()&lt;/code&gt;方法来获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-9be94618cd7fb498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;将数据填充到模板中并使用&quot;&gt;3.将数据填充到模板中并使用&lt;/h3&gt;
&lt;p&gt;我们发现模板代码其实就是&lt;code&gt;字符串&lt;/code&gt;而已，我们将数据填充进去，其实就是进行简单的字符串替换工作即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var http = require('http');
var fs = require('fs');

var server = http.createServer();
server.listen(8000);
console.log('server running');

server.on('request',function(request,response){
    var url = request.url;
    var rootDir = 'D:/Users/Administrator/Desktop/Node/www'+url;//根据请求路径显示

    //创建模板代码
    var contentTemplate = `
        &amp;lt;tr&amp;gt;
          &amp;lt;td&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;filename&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
          &amp;lt;td&amp;gt;1k&amp;lt;/td&amp;gt;
          &amp;lt;td&amp;gt;2018/11/5 上午10:50:48&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    `;
    var content = '';
    //获取数据
    fs.readdir(rootDir,function(err,data){
        if(err){
            return response.end('404,Not Fond!');
        }
        //将数据填充到模板代码中---字符串替换操作
        data.forEach(function(value,index){
            content += contentTemplate.replace('filename',value);
            //更新和使用模板代码
        });
        var templateStr = `
        &amp;lt;h1&amp;gt;${rootDir}的索引&amp;lt;/h1&amp;gt;
        &amp;lt;div style=&quot;display: block;&quot;&amp;gt;
          &amp;lt;a href=&quot;#&quot;&amp;gt;
            &amp;lt;span&amp;gt;[上级目录]&amp;lt;/span&amp;gt;
          &amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;table&amp;gt;
          &amp;lt;thead&amp;gt;
          &amp;lt;tr&amp;gt;
              &amp;lt;th&amp;gt;名称&amp;lt;/th&amp;gt;
              &amp;lt;th class=&quot;detailsColumn&quot;&amp;gt;
                大小
              &amp;lt;/th&amp;gt;
              &amp;lt;th class=&quot;detailsColumn&quot;&amp;gt;
                修改日期
              &amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
          &amp;lt;/thead&amp;gt;
          &amp;lt;tbody id=&quot;tbody&quot;&amp;gt;
            ${content}
          &amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;
        `;
        response.setHeader('Content-Type','text/html;charset=utf-8');
        response.end(templateStr);
        });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-ccf5e06690f4e33c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-532459eca9f0d1b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三模板引擎&quot;&gt;三、模板引擎&lt;/h2&gt;
&lt;p&gt;模板引擎是什么这里就不过多介绍了，从上面的案例中我们已近手动实现了模板引擎要做的事，&lt;strong&gt;处理字符串&lt;/strong&gt;，更准确地说应该是将数据填充到模板代码这一字符串操作过程我们可以通过模板引擎来完成。&lt;br/&gt;模板引擎有诸多优点，这里不再赘述，我们在使用中感受。比如&lt;code&gt;art-yemplate&lt;/code&gt;模板引擎。官网地址：&lt;a href=&quot;https://aui.github.io/art-template/zh-cn/index.html&quot;&gt;art-yemplate&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装art-template&quot;&gt;1.安装art-template&lt;/h3&gt;
&lt;p&gt;既然使用了Node.js我们就尽量使用npm来安装，新建一个文件夹code来保存代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-002397bf6a13479a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在浏览器中使用art-template&quot;&gt;2.在浏览器中使用art-template&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
    &amp;lt;mata charset=utf-8&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;./code/node_modules/art-template/lib/template-web.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!--显示位置--&amp;gt;
    &amp;lt;p id=&quot;show&quot;&amp;gt;&amp;lt;/p&amp;gt;

    &amp;lt;!--模板代码--&amp;gt;
    &amp;lt;script type=&quot;text/html&quot; id='demo'&amp;gt;
        大家好，我叫{{ name }},
        我喜欢{{each hobbies}}{{$value}} {{/each}}
    &amp;lt;/script&amp;gt;

    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        //数据
        var data = {
            name: '张三',
            hobbies: ['看书','打游戏','写代码']
        };
        //使用template方法将数据填充到模板中
        var html = template('demo',data);
        //将模板显示到页面上
        window.document.getElementById('show').innerHTML = html;
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意几点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var http = require('http');
var fs = require('fs');
var template = require('art-template');//启用art-template模板引擎

var server = http.createServer();
server.listen(8000);
console.log('server running');

server.on('request',function(request,response){
    var url = request.url;
    var rootDir = 'D:/Users/Administrator/Desktop/Node/www'+url;//根据请求路径显示

    //创建模板代码
    var templateStr = `
        &amp;lt;h1&amp;gt;{{dir}}的索引&amp;lt;/h1&amp;gt;
        &amp;lt;div style=&quot;display: block;&quot;&amp;gt;
          &amp;lt;a href=&quot;#&quot;&amp;gt;
            &amp;lt;span&amp;gt;[上级目录]&amp;lt;/span&amp;gt;
          &amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;table&amp;gt;
          &amp;lt;thead&amp;gt;
          &amp;lt;tr&amp;gt;
              &amp;lt;th&amp;gt;名称&amp;lt;/th&amp;gt;
              &amp;lt;th class=&quot;detailsColumn&quot;&amp;gt;
                大小
              &amp;lt;/th&amp;gt;
              &amp;lt;th class=&quot;detailsColumn&quot;&amp;gt;
                修改日期
              &amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
          &amp;lt;/thead&amp;gt;
          &amp;lt;tbody id=&quot;tbody&quot;&amp;gt;
            {{each data}}
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;{{$value}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;1k&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;2018/11/5 上午10:50:48&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            {{/each}}
          &amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;
        `;
    //获取数据
    fs.readdir(rootDir,function(err,data){
        if(err){
            return response.end('404,Not Fond!');
        }
        //使用模板引擎填充数据
        var htmStr = template.render(templateStr,{
            dir:rootDir,
            data:data
        });
        response.setHeader('Content-Type','text/html;charset=utf-8');
        response.end(htmStr);
        });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Node.js中使用&lt;code&gt;require()&lt;/code&gt;来加载模板引擎（注意，如果Node的安装目录的下node_modules（默认安装地址）没有安装模板引擎，需要将执行的js放到和模板引擎保存的文件夹下，比如我们之前是新建了code文件夹来保存代码，所以现在需要将执行的js也放在code下才能找到模板）&lt;/li&gt;
&lt;li&gt;使用模板引擎的&lt;code&gt;render()&lt;/code&gt;方法来处理模板代码（在浏览器在中是template()方法）&lt;/li&gt;
&lt;li&gt;在浏览器中是使用id作为参数，在Node.js中直接使用模板代码作为参数即可。&lt;/li&gt;
&lt;li&gt;注意模板代码要符合使用的模板引擎的规范。&lt;code&gt;${value}&lt;/code&gt;是es6中模板字符串的变量表达式，而&lt;code&gt;{{}}&lt;/code&gt;是art-template模板引擎的表达式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四案例留言板&quot;&gt;四、案例：留言板&lt;/h2&gt;
&lt;p&gt;需求：使用Node.js实现留言板功能，即在如下页面输入评论，首页显示评论，相关html和css代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-8078ed41cd1357e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;1.准备工作&lt;/h3&gt;
&lt;p&gt;目录结构如下：&lt;/p&gt;
&lt;p&gt;html代码（views文件夹下）&lt;br/&gt;js/css/img（public文件夹下，其实只用到了bootstrap.css，可自行网上下载引用）&lt;br/&gt;模板引擎代码（node_modules文件夹下）&lt;br/&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-89de1b0b031de210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;留言本&amp;lt;/title&amp;gt;
  &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;../public/css/bootstrap.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&quot;header container&quot;&amp;gt;
    &amp;lt;div class=&quot;page-header&quot;&amp;gt;
      &amp;lt;h1&amp;gt;Example page header &amp;lt;small&amp;gt;Subtext for header&amp;lt;/small&amp;gt;&amp;lt;/h1&amp;gt;
      &amp;lt;a class=&quot;btn btn-success&quot; href=&quot;/post&quot;&amp;gt;发表留言&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;comments container&quot;&amp;gt;
    &amp;lt;ul class=&quot;list-group&quot;&amp;gt;
      {{each comments}}
      &amp;lt;li class=&quot;list-group-item&quot;&amp;gt;
        &amp;lt;span style=&quot;color: green&quot;&amp;gt;{{ $value.name }}：&amp;lt;/span&amp;gt;{{ $value.message }}
        &amp;lt;span class=&quot;pull-right&quot;&amp;gt;{{ $value.dateTime }}&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
      {{/each}}
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;post.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-bad86ecd76cc6070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;../public/css/bootstrap.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&quot;header container&quot;&amp;gt;
    &amp;lt;div class=&quot;page-header&quot;&amp;gt;
      &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;首页&amp;lt;/a&amp;gt; &amp;lt;small&amp;gt;发表评论&amp;lt;/small&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;comments container&quot;&amp;gt;
    &amp;lt;form action=&quot;/addComment&quot; method=&quot;post&quot;&amp;gt;
      &amp;lt;div class=&quot;form-group&quot;&amp;gt;
        &amp;lt;label for=&quot;input_name&quot;&amp;gt;你的大名&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; required minlength=&quot;2&quot; maxlength=&quot;10&quot; id=&quot;input_name&quot; name=&quot;name&quot; placeholder=&quot;请写入你的姓名&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;form-group&quot;&amp;gt;
        &amp;lt;label for=&quot;textarea_message&quot;&amp;gt;留言内容&amp;lt;/label&amp;gt;
        &amp;lt;textarea class=&quot;form-control&quot; name=&quot;message&quot; id=&quot;textarea_message&quot; cols=&quot;30&quot; rows=&quot;10&quot; required minlength=&quot;1&quot; maxlength=&quot;20&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&amp;gt;发表&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;抱歉!  您访问的页面失联啦...&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写app.js文件post提交&quot;&gt;2.编写app.js文件（post提交）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;var http = require('http');
var fs = require('fs');
var template = require('art-template');

var comments = [];

http.createServer(function(req,res){
    var url = req.url;
    var rootDir = 'D:/Users/Administrator/Desktop/Node/feadback';
    var filePath = '/views/index.html';
    if(url === '/addComment'){
        //request的data事件
        req.on('data',function(postdata){
            //postdata是二进制数据，postdata.toString()返回的数据编码方式任然有问题，所以需要解码
            var decodedata = decodeURIComponent(postdata.toString());//对表单数据进行解码---&amp;gt;name=xxx&amp;amp;massage=xxx
            var data = {},key,value,arr;
            decodedata.split('&amp;amp;').forEach(function(v){
                arr = v.split('=');
                key = arr[0];
                value = arr[1] || '';
                data[key] = value;
            });
            data['dateTime'] = new Date().toLocaleString();
            comments.unshift(data);
        });
        url = '/';
    }
    if(url !== '/'){
        filePath = url;
    }
    if(url === '/post'){
        filePath = '/views/post.html';
    }
    if(url !== '/'){
        fs.readFile(rootDir+filePath,function(err,data){
            if(err){
                fs.readFile(rootDir+'/views/404.html',function(err1,data1){
                    if(err1)
                        return res.end('404,Not Fond.');
                    return res.end(data1);
                })
                return;
            }
            res.end(data);
        });
    }else{
        //index.html需要进行模板渲染
        fs.readFile(rootDir+filePath,function(err,data){
            if(err){
                fs.readFile(rootDir+'/views/404.html',function(err1,data1){
                    if(err1)
                        return res.end('404,Not Fond.');
                    return res.end(data1);
                })
                return;
            }
            var html = template.render(data.toString(),{comments:comments});
            res.end(html);
        });
    }
}).listen(8000);
console.log('server running...');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的一些细节：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意&lt;code&gt;fileRead()&lt;/code&gt;读取到的数据是二进制数据，要当做模板代码需要使用&lt;code&gt;toString()&lt;/code&gt;进行处理。&lt;/li&gt;
&lt;li&gt;我们使用的是post提交，那么表单数据就不会显示在url上，我们需要使用&lt;code&gt;request的data事件&lt;/code&gt;来获取post提交获得的数据。&lt;/li&gt;
&lt;li&gt;postdata也是二进制数据，且使用toString()方法后编码任然可能不是正常编码，需要使用&lt;code&gt;decodeURIComponent()&lt;/code&gt;方法进行解码。&lt;/li&gt;
&lt;li&gt;将表单提交的数据添加到数组中，使用模板引擎渲染到页面即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;get提交的一些区别&quot;&gt;3.get提交的一些区别&lt;/h3&gt;
&lt;p&gt;首先，request.url会变成这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13641355-0236b8cd0dbfe4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是多了后面的参数，那么if(url === '/addComment')就会失效，而request的data事件也不会触发。&lt;br/&gt;所以如果是get提交，我们需要使用另外的处理方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先使用url核心模板即：&lt;code&gt;var url = require('url');&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用url核心模板的&lt;code&gt;parse()&lt;/code&gt;方法来处理request.url。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//将路径解析为一个方便操作的对象，
//第二个参数为 true 表示直接将查询字符串转为一个对象（通过 query 属性来访问）
 var parseObj = url.parse(req.url, true);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;true这个参数很重要，否则parseObj.query会转化为字符串。&lt;/li&gt;
&lt;li&gt;此时parseObj对象就包含了url的相关信息，如&lt;code&gt;parseObj.pathname&lt;/code&gt;表示当前请求连接（不带hash参数，本例中即为'/addComment'）。而&lt;code&gt;parseObj.query&lt;/code&gt;可以获取hash参数转化而成的对象，本例即：{name:xxx,messagexxx}，且不用再使用&lt;code&gt;decodeURIComponent()&lt;/code&gt;进行解码也不会乱码。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 05 Nov 2018 11:34:00 +0000</pubDate>
<dc:creator>风之之</dc:creator>
<og:description>一、使用Node实现基本Apache的功能 在上一篇笔记中，我们提到如果打开一个文件需要进行一次url判断是繁琐的，我们希望我们的Node具有类似Apache这种web服务器的一个功能：将文件放到ww</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fzz9/p/9911015.html</dc:identifier>
</item>
</channel>
</rss>