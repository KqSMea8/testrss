<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>django框架--中间件系统 - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9776395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9776395.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;零参考&quot;&gt;零、参考&lt;/h2&gt;
&lt;p&gt;https://www.jb51.net/article/136422.htm&lt;br/&gt;https://www.jb51.net/article/143832.htm&lt;br/&gt;https://www.jb51.net/article/69953.htm&lt;/p&gt;
&lt;h2 id=&quot;一中间件的基本理解&quot;&gt;一、中间件的基本理解&lt;/h2&gt;
&lt;p&gt;我对&lt;code&gt;django&lt;/code&gt;中间件的理解：&lt;strong&gt;以组件化的形式，为大量的请求或响应提供批量化处理的接口，封装着可插拔式的独立附加功能逻辑，与基本&lt;code&gt;web&lt;/code&gt;业务逻辑功能解耦，通过&lt;code&gt;hook&lt;/code&gt;函数能更细致的处理请求或响应过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;的中间件有如下特点：&lt;br/&gt;1、每个中间件由一个类来表示&lt;br/&gt;2、中间件的逻辑必须写在特定的接口中，这些接口被称为&lt;code&gt;hook&lt;/code&gt;函数&lt;br/&gt;3、中间件的执行有顺序依赖&lt;br/&gt;4、&lt;code&gt;hook&lt;/code&gt;函数的执行有规定顺序&lt;br/&gt;5、中间件的启用会影响所有的请求/响应&lt;br/&gt;6、中间件是可插拔式的，这意味着可以不启用任何中间件&lt;br/&gt;7、中间件应该仅作为数据过滤器的角色对数据过滤、转换、清洗，对数据的业务处理应该放在视图系统中&lt;br/&gt;8、如第7点，中间件应该作为额外功能模块介入请求/响应流程，与普通业务处理模块(视图系统)解耦&lt;/p&gt;
&lt;h2 id=&quot;二中间件的系统定位&quot;&gt;二、中间件的系统定位&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;中间件在&lt;code&gt;django&lt;/code&gt;框架中的定位图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012102613988-1476135912.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三中间件的配置&quot;&gt;三、中间件的配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;配置中间件类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.utils.deprecation import MiddlewareMixin

class MyMiddleware(MiddlewareMixin):
    '''
    自定义类名，继承内置的中间件混合类。
    hook函数有固定的接口，自定义逻辑处理代码
    '''
    def process_request(self, request):
        pass
    
    def process_view(self, request, callback, callback_args, callback_kwargs):
        pass
        
    def process_exception(self, request, exception):
        pass
        
    def process_template_response(self, request, response):
        return response
    
    def process_response(self, request, response):
        return response

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;编写中间件&lt;code&gt;hook&lt;/code&gt;函数逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;code&gt;process_request(self, request)&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;参数&lt;code&gt;request&lt;/code&gt;是&lt;code&gt;HttpRequest&lt;/code&gt;对象，此&lt;code&gt;hook&lt;/code&gt;函数将会在路由分发前执行，有两类返回值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. return None  # 请求流程将会继续按照原计划执行，这应该是默认设置
2. return HttpResponse  # 请求将会跳转到当前中间件的process_response函数处理并进入响应流程

注意：虽然return一个非None且非HttpResonse的值也会使得流程跳转到响应流程，不过并不建议这么做，因为每一个process_response函数都期望接收到一个HttpResponse对象以便做进一步的处理，而不是收到一个奇怪的字符串或者数字。

注意：进入响应流程的入口是当前中间件的process_response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;code&gt;process_view(self, request, callback, callback_args, callback_kwargs)&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;请求流程完成路由分发后，在执行视图函数前将会执行此&lt;code&gt;hook&lt;/code&gt;函数。此函数的&lt;code&gt;callback&lt;/code&gt;是对路由分发确定的视图函数的引用，&lt;code&gt;callback_args&lt;/code&gt;, &lt;code&gt;callback_kwargs&lt;/code&gt;是传递给视图函数的参数，有两类返回值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. return None  # 请求流程将会按照原计划继续，这应该是默认设置
2.return HttpResponse  # 请求将会跳转到最后一个中间件的process_response函数处理并进入响应流程

注意：进入响应流程的入口是最后一个中间件的process_response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;code&gt;process_template_response&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;在 &lt;code&gt;view&lt;/code&gt; 视图函数中使用 &lt;code&gt;render&lt;/code&gt; 渲染一个模版对象完成之后被调用，它必须返回一个&lt;code&gt;render&lt;/code&gt;方法执行后的&lt;code&gt;response&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;code&gt;process_exception(self, request, exception)&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;当视图函数执行出错的时候，会把错误抛给此&lt;code&gt;hook&lt;/code&gt;函数，有两类返回值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. return None  # 将会把错误对象exception提交给前一个中间件的process_exception处理
2. return HttpResponse  # 将会跳转到最后一个中间件的process_response函数处理并进入响应流程

注意：不应该return exception

注意：进入响应流程的入口是最后一个中间件的process_response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5、&lt;code&gt;process_response（self, request, response)&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;此&lt;code&gt;hook&lt;/code&gt;函数将在响应流程中执行，函数必须返回&lt;code&gt;HttpResponse对象&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;return HttpResponse  # 把响应对象交给前一个中间件的process_response函数处理，如果已经是第一个中间件，将会交给wsgi服务器处理并发送给用户浏览器。

注意：必须返回HttpResponse对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启用中间件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目settings文件中添加对中间件类的引用以启动中间件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'app01.my_middlewares.MyMiddleware',  # 添加对自定义中间件类的引用以启动
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四中间件的执行流程&quot;&gt;四、中间件的执行流程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;中间件及&lt;code&gt;hook&lt;/code&gt;函数执行流程(省略&lt;code&gt;process_template_response&lt;/code&gt;)&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012102710955-513234702.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五中间件与装饰器之间的思考&quot;&gt;五、中间件与装饰器之间的思考&lt;/h2&gt;
&lt;p&gt;中间件的功能划分遵循原则：&lt;strong&gt;视图函数仅完成本应完成的工作，额外的功能通过中间件来单独提供&lt;/strong&gt;。&lt;br/&gt;中间件是可插拔式即意味着中间件的启用和禁用均不会影响视图函数的原始工作，这非常像之前学习过的&lt;code&gt;python&lt;/code&gt;装饰器。&lt;code&gt;python&lt;/code&gt;装饰器实现了设计模式中的装饰模式，装饰器的目的是：在保持原有函数功能的基础之上，新增额外的功能，且新增的功能应该与原函数功能解耦，装饰器也可以有选择的增加或者移除。通过自己的研究和网上各大神的博客学习中发现，&lt;code&gt;django&lt;/code&gt;的中间件其实也是一种装饰模式，而且可以和&lt;code&gt;python&lt;/code&gt;的装饰器用法高度适配，我用如下两张图来对&lt;code&gt;django&lt;/code&gt;中间件和装饰器进行了转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图一、&lt;code&gt;django&lt;/code&gt;中间件到装饰器的转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012123245489-424840949.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图二、&lt;code&gt;django&lt;/code&gt;中间件到装饰器的转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012123254648-253698089.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;python&lt;/code&gt;多重装饰器&lt;/strong&gt;&lt;br/&gt;虽然还没研究过&lt;code&gt;django&lt;/code&gt;中间件的源代码，不过我想先尝试着使用&lt;code&gt;python&lt;/code&gt;的装饰器来模拟中间件的效果。&lt;br/&gt;首先，要理解装饰器的核心知识：&lt;strong&gt;利用闭包特性来保存内层函数的执行上下文&lt;/strong&gt;。正因为闭包的存在，内层函数的执行上下文(执行环境)即使在外层函数结束后依然可以被保存，这就意味着在外层函数结束后，依然可以正确的执行内层函数。 &lt;em&gt;（ps：如果不使用闭包，外层函数结束后，该函数中的所有变量都会被销毁）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其次，&lt;strong&gt;装饰器可以迭代使用&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。&lt;br/&gt;---百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@IPFilter
@UserAuth
@DataTransform
@TrafficLog
def index(request):
    # somecode...
    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;利用装饰器函数模拟中间件效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们通过一个多重函数装饰器简单的模拟一下中间件的效果，需求如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有一个&lt;code&gt;ip&lt;/code&gt;黑名单列表，列表中的&lt;code&gt;ip&lt;/code&gt;不能访问页面。此外，有三个函数需要定义：&lt;/em&gt;&lt;br/&gt;&lt;em&gt;一个简单的&lt;code&gt;show_page&lt;/code&gt;函数，将会模拟用户访问某一个页面，并返回简单的内容(当前用户的&lt;code&gt;ip&lt;/code&gt;)。&lt;/em&gt;&lt;br/&gt;&lt;em&gt;一个&lt;code&gt;filter_ip&lt;/code&gt;装饰器，过滤恶意&lt;code&gt;ip&lt;/code&gt;，如果用户&lt;code&gt;ip&lt;/code&gt;在黑名单中就无法正常访问页面。&lt;/em&gt;&lt;br/&gt;&lt;em&gt;一个&lt;code&gt;traffic_log&lt;/code&gt;装饰器，对正常访问的流量进行统计。&lt;/em&gt;&lt;br/&gt;&lt;em&gt;基础需求：通过自定义一个&lt;code&gt;request&lt;/code&gt;对象模拟用户浏览器发出的&lt;code&gt;http&lt;/code&gt;请求对象，&lt;code&gt;request&lt;/code&gt;直接执行&lt;code&gt;show_page&lt;/code&gt;视图函数以得到期望访问的&lt;code&gt;http&lt;/code&gt;页面。&lt;/em&gt;&lt;br/&gt;&lt;em&gt;额外需求：通过添加以上两个装饰器来增加&lt;code&gt;ip&lt;/code&gt;过滤和流量统计的功能。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;代码定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 黑名单的定义
black_ip_list = ['10.1.1.1', '172.16.1.1', '192.168.1.1']

# 这里简单的使用全局变量来表示统计流量
traffic_count = 0  


# request对象的定义
class Request(object):
    def __init__(self, source_ip):
        self.source_ip = source_ip


# filter_ip过滤器函数的定义
def filter_ip(func):
    def inner(request):
        source_ip = request.source_ip
        if source_ip in black_ip_list:
            response = '你的ip在黑名单中'
        else:
            response = func(request)
        return response
    
    return inner

# traffic_log流量统计函数的定义
def traffic_log(func):
    def inner(request):
        global traffic_count  
        traffic_count += 1
        print('当前页面被有效请求的次数是:', traffic_count)

        response = func(request)
        return response

    return inner

# show_page视图函数的定义
def show_page(request):
    source_ip = request.source_ip
    response = '模拟的目标页面内容,此用户的ip是--&amp;gt;' + source_ip

    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果1，实现最基本的用户访问&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143638992-1971009650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果2，实现&lt;code&gt;ip&lt;/code&gt;黑名单过滤&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143645242-239899405.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果3，实现有效流量统计&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143650379-315852718.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果4，实现&lt;code&gt;ip&lt;/code&gt;黑名单过滤+有效流量统计(特别注意顺序依赖)&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143655558-1670987213.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用装饰器类模拟中间件效果&lt;/strong&gt;&lt;br/&gt;虽然简单的模拟出了中间件的可插拔、功能解耦、批量请求处理等功能，但还做的不够好，我们可以基于上面的代码，再做一些必要的封装，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TrafficLogMiddleware(object):
    traffic_count = 0

    def __init__(self, func):
        self.func = func

    def __call__(self, request):
        self.traffic_count += 1
        print('当前页面被有效请求的次数是:', self.traffic_count)

        response = self.func(request)
        return response

class FilterIPMiddleware(object):
    black_ip_list = ['10.1.1.1', '172.16.1.1', '192.168.1.1']

    def __init__(self, func):
        self.func = func

    def __call__(self, request):
        source_ip = request.source_ip
        if source_ip in self.black_ip_list:
            response = '你的ip在黑名单中'
        else:
            response = self.func(request)

        return response


class Request(object):
    def __init__(self, source_ip):
        self.source_ip = source_ip


@FilterIPMiddleware
@TrafficLogMiddleware
def show_page(request):
    source_ip = request.source_ip
    response = '模拟的目标页面内容,此用户的ip是--&amp;gt;' + source_ip

    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;感觉不像&lt;code&gt;django&lt;/code&gt;的中间件接口？可以这样写：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Middleware(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, request):
        response = self.process_request(request)
        if not response:
            response = self.func(request)
        response = self.process_response(request, response)

        return response

    def process_request(self, request):
        pass

    def process_response(self, request, response):
        return response


class TrafficLogMiddleware(Middleware):
    traffic_count = 0

    def process_request(self, request):
        self.traffic_count += 1
        print('当前页面被有效请求的次数是:', self.traffic_count)

    def process_response(self, request, response):
        return response


class FilterIPMiddleware(Middleware):
    black_ip_list = ['10.1.1.1', '172.16.1.1', '192.168.1.1']

    def process_request(self, request):
        source_ip = request.source_ip

        if source_ip in self.black_ip_list:
            response = '你的ip在黑名单中'
        else:
            response = None

        return response

    def process_response(self, request, response):
        return response


class Request(object):
    def __init__(self, source_ip):
        self.source_ip = source_ip


@FilterIPMiddleware
@TrafficLogMiddleware
def show_page(request):
    source_ip = request.source_ip
    response = '模拟的目标页面内容,此用户的ip是--&amp;gt;' + source_ip

    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;执行结果如下：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012153132932-1547947261.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六中间件的应用场景&quot;&gt;六、中间件的应用场景&lt;/h2&gt;
&lt;p&gt;中间件的启用会影响所有的请求/响应---&amp;gt;适用于大量请求/响应的批量化处理场景&lt;br/&gt;中间件相互之间功能解耦，顺序依赖---&amp;gt;适合可插拔式的业务场景&lt;br/&gt;中间件可以介入请求/响应流程---&amp;gt;适用于需要更加细致化处理请求/响应流程的业务场景&lt;br/&gt;1、流量统计&lt;br/&gt;2、恶意ip过滤&lt;br/&gt;3、用户区分&lt;br/&gt;4、缓存CDN&lt;br/&gt;5、URL过滤&lt;br/&gt;6、数据预处理&lt;br/&gt;......&lt;/p&gt;
&lt;h2 id=&quot;七内置中间件&quot;&gt;七、内置中间件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;框架内置了7个中间件，用于提供基本的&lt;code&gt;http&lt;/code&gt;请求和响应处理，内置中间件的基本学习可以参考：&lt;br/&gt;&lt;code&gt;https://www.jb51.net/article/69953.htm&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;八总结&quot;&gt;八、总结&lt;/h2&gt;
&lt;p&gt;1、装饰器和中间件都实现了装饰模式，此模式的目的是为了在不修改原有模块的条件下新增功能代码，并可以提供可插拔的效果，同时新增代码和原有代码功能上解耦。&lt;br/&gt;2、类比学习很重要，可以同时提升对两个同类知识的理解。&lt;br/&gt;3、中间件的角色应该是数据清洗/过滤/转换器，不应该在中间件上处理业务逻辑，而只是处理数据约束，具体的业务逻辑应该放置在视图函数中，这也是它的本职工作。&lt;br/&gt;4、不要滥用中间件，过多的中间件会增加请求/响应流程的环节数，发生错误的时候提升排错难度。中间件的使用应该依赖业务场景，在最合适的地方使用最合适的技术，才能发挥最高的效率。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 07:41:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<og:description>[TOC] 零、参考 https://www.jb51.net/article/136422.htm https://www.jb51.net/article/143832.htm https://w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9776395.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 Canvas 的 3D 渲染引擎界面以及吸附等效果的运用 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/9778453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/9778453.html</guid>
<description>&lt;p&gt;&lt;strong&gt;HT 是啥：Everything you need to create cutting-edge 2D and 3D visualization.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这口号是当年心目中的产品方向，接着就朝这个方向慢慢打磨，如今 HT 算是达到了这样的效果，谈不上用尽洪荒之力，但我们对产品结果很满意，特别是 HT 的用户手册，将例子和文档无缝融合一体，小小 10 来兆开发包居然包含了四十五份手册，数百个活生生的 HTML5 例子，还没体验过的同学可以点击 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/treetableview/examples/example_structure.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/guide/readme.html&lt;/a&gt; HT 手册入口玩一玩。&lt;/p&gt;
&lt;p&gt;这样综合并可搜索的手册入口居然还常被问及 HT 的 Demo 在哪里？只能怪这些年深入人心的极致用户体验理念，把人惯得包括很多程序员都如此之“懒”，当然也怪我们没把用户体验的最后一公里做到位，将数百个手册例子进行了归类整理，最终形成了方便大家直观查找所有 HT 例子的页面：&lt;a href=&quot;http://www.hightopo.com/demos/index.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demos/index.html&lt;/a&gt; 。很明显，对于 HT 老用户包括我们自己做技术支持，都感觉查找例子更直观方便，但对于 HT 初学者，面对这一堆数百个涵括通用组件、网络拓扑图组件、3D 组件、矢量图形、各种编辑器等等五法八门的 HTML5 例子盛宴，往往无从下手。为此，老郑我打算为像我一样喜欢这方面的新手朋友多写几篇这样的博客，慢慢的给大家讲述各种各样的越来越多的有趣的小功能！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201810/1496396-20181012113107441-1489023447.gif&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;

&lt;p&gt;HT 提供了基于 WebGL 的 3D 技术的图形组件 ht.graph3d.Graph3dView，WebGL 基于 OpenGL ES 2.0 图形接口，因此 WebGL 属于底层的图形 API 接口，二次开发还是有很高的门槛，HT 的 Graph3dView 组件通过对 WebGL 底层技术的封装，与 HT 其他组件一样，基于 HT 统一的 DataModel 数据模型来驱动图形显示，极大降低了 3D 图形技术开发的门槛。同时 HT 提供了强大的完全基于 HTML5 技术 3D 图形建模设计器，用户无需编码即可快速可视化搭建各种 3D 场景，可以说 HT 的 3D 开发模式完全打破了传统 3D 开发模式，绝大部分应用不再需要依赖精通 3ds Max 或 Maya 的专业 3D 设计师来建模，也不需要整合 Unity3d 等引擎做图形渲染，HT 一站式的提供了从建模到渲染，包括和 2D 组件呈现和数据融合的一站式解决方案。&lt;/p&gt;
&lt;p&gt;我本次讲解的就是这个 3D 的界面，所以我们首先要创建 3D 渲染引擎组件，可视化呈现数据模型的三维环境场景。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
dataModel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.DataModel();
g3d &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.graph3d.Graph3dView(dataModel);
g3d.addToDOM();
window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
　　g3d.invalidate();
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还要设置眼睛（或Camera）所在位置，默认值为 [0, 300, 1000] ，格式为 [x, y, z] 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
g3d.setEye([0, 300, 600]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201810/1496396-20181012103253853-75568583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里给大家说一下，可参考 3D 手册（ &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/guide/guide/core/3d/ht-3d-guide.html&lt;/a&gt; ）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201810/1496396-20181012104015743-1103129861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再给它加上一些选中效果。Graph3dView 中被选中的图元会显示为较暗的状态，变暗系数是由图元 style 的 brightness 和 select.brightness 属性决定，select.brightness 属性默认值为 0.7，最终返回值大于 1 变亮，小于 1 变暗，等于 1 或为空则不变化。Graph3dView#getBrightness 函数控制最终图元亮度，因此也可以通过重载覆盖该函数自定义选中图元亮度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
g3d.getBrightness = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.s('isFocused'&lt;span&gt;)) {
   　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0.7&lt;span&gt;;
   }
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
lastFocusData = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
g3d.getView().addEventListener('mousemove', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入逻辑坐标点或者交互 event 事件参数，返回当前点下的图元&lt;/span&gt;
   &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; g3d.getDataAt(e);
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data !==&lt;span&gt; lastFocusData) {
   　　i&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt; (lastFocusData) {
      　　astFocusData.s(&lt;/span&gt;'isFocused', &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data) {
         data.s(&lt;/span&gt;'isFocused', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
      }
      astFocusData &lt;/span&gt;=&lt;span&gt; data;
　　}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们写个函数来方便绘制每个部分的模型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createNode (p3, s3, host) {
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拓扑图元类型&lt;/span&gt;
&lt;span&gt;　　var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 获取或设置图元中心点的三维坐标 有三个参数时相当于 setPosition3d 没有相当于 get&lt;/span&gt;
&lt;span&gt;　　node.p3(p3);
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 获取或设置图元的尺寸 有三个参数时相当于 setSize3d 没有相当于 get&lt;/span&gt;
&lt;span&gt;　　node.s3(s3);
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 设置宿主图元，当图元吸附上宿主图元(host)时，宿主移动或旋转时会带动所有吸附者&lt;/span&gt;
&lt;span&gt;　　node.setHost(host);
　　dataModel.add(node);
&lt;/span&gt;&lt;span&gt;　　return&lt;/span&gt;&lt;span&gt; node;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;讲到了这，我们来说说吸附，吸附功能对于设计有层次关系的模型非常方便，例如设备面板吸附上设备机框，设备端口吸附上设备面板，这样从机框 - 面板 - 端口的层次关系吸附，使得用户拖动整体机框时所有这个层次下的图元都会跟随移动。对于 3D 的场景下，吸附的概念更进一步延伸，当机框在三维空间进行任意位置偏移以及任意角度旋转时，所有吸附的相关图元都会正确的跟随平移，并做出相应位置对应的旋转，以达到整体设备各个图形部分保持物理相对位置一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201810/1496396-20181012114601786-2048369632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们来一起创建模型吧！分别是地板 floor，桌面 table，四个桌腿以及盒子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;114&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 地板&lt;/span&gt;
floor = createNode([0, 0, 0], [600, 5, 400&lt;span&gt;]).s({
&lt;/span&gt;　　'all.color': '#A0A0A0',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 六面颜色&lt;/span&gt;
　　'label': '地板',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图元文字内容&lt;/span&gt;
　　'label.face': 'top',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字在3d下的朝向，可取值（left|right|top|bottom|front|back|center）&lt;/span&gt;
　　'label.background': 'yellow',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图元文字背景&lt;/span&gt;
　　'label.position': 22,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图元文字位置&lt;/span&gt;
　　'label.t3': [10, 0, -10],&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字在3d下的偏移，格式为 [x,y,z]&lt;/span&gt;
　　'label.font': '28px arial, sans-serif'&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图元文字字体&lt;/span&gt;
&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 桌面&lt;/span&gt;
table = createNode([0, 120, 0], [400, 10, 280&lt;span&gt;], floor).s({
&lt;/span&gt;　　'shape3d': 'cylinder',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为空时显示为六面立方体，cylinder 圆柱&lt;/span&gt;
　　'shape3d.side': 60,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 决定 3d 图形显示为几边型，为 0 时显示为平滑的曲面效果&lt;/span&gt;
　　'shape3d.color': '#E5BB77',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3d 图形整体颜色&lt;/span&gt;
　　'label': '桌子'&lt;span&gt;,
&lt;/span&gt;　　'label.face': 'top'&lt;span&gt;,
&lt;/span&gt;　　'label.background': 'yellow'&lt;span&gt;,
&lt;/span&gt;　　'label.position': 23&lt;span&gt;,
&lt;/span&gt;　　'label.t3': [0, 0, -10&lt;span&gt;],
&lt;/span&gt;　　'label.font': '20px arial, sans-serif'&lt;span&gt;
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 四个桌腿&lt;/span&gt;
foot1 = createNode([100, 60, 80], [20, 110, 20&lt;span&gt;], table).s({
&lt;/span&gt;　　'shape3d': 'cylinder'&lt;span&gt;,
&lt;/span&gt;　　'shape3d.color': '#E5BB77'&lt;span&gt;,
});
foot2 &lt;/span&gt;= createNode([-100, 60, 80], [20, 110, 20&lt;span&gt;], table).s({
&lt;/span&gt;　　'shape3d': 'cylinder'&lt;span&gt;,
&lt;/span&gt;　　'shape3d.color': '#E5BB77'&lt;span&gt;,
});
foot3 &lt;/span&gt;= createNode([100, 60, -80], [20, 110, 20&lt;span&gt;], table).s({
&lt;/span&gt;　　'shape3d': 'cylinder'&lt;span&gt;,
&lt;/span&gt;　　'shape3d.color': '#E5BB77'&lt;span&gt;,
});
foot4 &lt;/span&gt;= createNode([-100, 60, -80], [20, 110, 20&lt;span&gt;], table).s({
&lt;/span&gt;　　'shape3d': 'cylinder'&lt;span&gt;,
&lt;/span&gt;　　'shape3d.color': '#E5BB77'&lt;span&gt;,
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 盒子&lt;/span&gt;
box = createNode([0, 150, 0], [100, 50, 60&lt;span&gt;], table).s({
&lt;/span&gt;　　'all.color': '#2e2f32'&lt;span&gt;,
&lt;/span&gt;　　'front.color': '#BDC3C7',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前面颜色&lt;/span&gt;
　　'note': '盯着你看', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图元冒泡标注&lt;/span&gt;
　　'note.face': 'top'&lt;span&gt;,
&lt;/span&gt;　　'note.position': 7&lt;span&gt;,
&lt;/span&gt;　　'note.t3': [0, 0, 10&lt;span&gt;],
&lt;/span&gt;　　'note.autorotate': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图标在 3D 下是否自动朝向眼睛的方向&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中有一些属性，我已经帮大家写好了详细的注释。在此献上各种关于 'shape3d' 的图形的值，方便大家玩耍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201810/1496396-20181012143112656-766850474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个小 demo 就说到这里吧，还有更多精彩想自己探索的朋友，可以直接去我们的公司中文版主页了解（&lt;a href=&quot;http://www.hightopo.com/cn-index.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/cn-index.html&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;我每周尽量都写一些技术随笔，既帮助自己整理知识，也能够跟大家一起学习，我们由浅至深，循序渐进。希望看了我的文章能得你们带来帮助，同时也希望大家能多多支持和鼓励！&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 07:35:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>HT 是啥：Everything you need to create cutting-edge 2D and 3D visualization. 这口号是当年心目中的产品方向，接着就朝这个方向慢慢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/htdaydayup/p/9778453.html</dc:identifier>
</item>
<item>
<title>数据结构与算法学习笔记之 提高读取性能的链表（上） - Dawnzhang</title>
<link>http://www.cnblogs.com/clwydjgs/p/9778394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clwydjgs/p/9778394.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;链表（Linked list）比数组稍微复杂一点，在我们生活中用到最常见的应该是缓存，它是一种提高数据读取性能的技术，常见的如cpu缓存，浏览器缓存，数据库缓存等。今天我们就来学习一下链表&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;一、链表的定义？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.一种线性表（数据排成像一条线一样的结构。每个线性表上的数据最多有前后两个方向）；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.从存储结构来看，通过“指针”，将一组零散的内存块串联起来使用的数据结构；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.链表中的每一个内存块被称为结点Node，结点除了存储数据外，还需记录链上下一个节点的地址（next）&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;二、链表的优缺点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.插入、删除数据效率高，时间复杂度为O(1)（只需更改指针指向即可），随机访问效率低，时间复杂度为O(n)级别（需要从链头至链尾进行遍历）。&lt;br/&gt;2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;br/&gt;三、常用链表：单链表、循环链表、双向链表、双向循环链表和块状链表&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;1.单链表&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181012144542817-1381337720.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）每个节点只包含一个指针，即后继指针。&lt;br/&gt;2）单链表有两个特殊的节点，即首节点和尾节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;用首节点地址表示整条链表，尾节点的后继指针指向空地址null。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;br/&gt;2.循环链表&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181012145239779-97383399.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。&lt;br/&gt;2）适用于存储有循环特点的数据，比如约瑟夫问题。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;br/&gt;3.双向链表&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181012145228251-2059853760.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。&lt;br/&gt;2）当此“连接”为第一个“连接”时，指向空值或者空列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当此“连接”为最后一个“连接”时，指向空值或者空列表）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）性能特点：&lt;br/&gt;和单链表相比，存储相同的数据，需要消耗更多的存储空间。&lt;br/&gt;插入、删除操作比单链表效率更高O(1)级别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以删除操作为例，删除操作分为2种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给定数据值删除对应节点和给定节点地址删除节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&amp;gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;对于一个有序链表，双向链表的按值查询效率要比单链表高一些。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;4&lt;span&gt;.双向循环链表（双向，循环链表的结合）&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;&lt;span id=&quot;块状链表&quot; class=&quot;mw-headline&quot;&gt;块状链表&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;span&gt;块状链表本身是一个链表，但是链表储存的并不是一般的数据，而是由这些数据组成的顺序表。每一个块状链表的节点，也就是顺序表，可以被叫做一个&lt;strong&gt;块&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;块状链表通过使用可变的顺序表的长度和特殊的插入、删除方式，可以在达到&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;{\displaystyle O({\sqrt {n}})}&lt;img class=&quot;mwe-math-fallback-image-inline&quot; src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/f5526ab1252c0f682bbe07c0ad67c0f29de5522b&quot; alt=&quot;O({\sqrt n})&quot;/&gt;的复杂度。块状链表另一个特点是相对于普通链表来说节省内存，因为不用保存指向每一个数据节点的指针。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;br/&gt;&lt;span&gt;四、数组VS链表&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;1.插入、删除和随机访问的时间复杂度&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.数组缺点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3.链表缺点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）内存空间消耗更大，因为需要额外的空间存储指针信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4.如何选择&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果代码对内存的使用非常苛刻，那数组就更适合&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;CPU缓存机制指的是什么？为什么就数组更好了？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;span&gt;CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关文章&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/clwydjgs/p/9755971.html&quot;&gt;数据结构与算法学习笔记之 从0编号的数组&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以上内容为个人的学习笔记，仅作为学习交流之用。&lt;/p&gt;

&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/clwydjgs/&quot; target=&quot;_blank&quot;&gt;Dawnzhang&lt;/a&gt; &lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/clwydjgs/p/9778394.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/clwydjgs/p/9778394.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;版权：本文版权归作者&lt;br/&gt;转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 07:33:00 +0000</pubDate>
<dc:creator>Dawnzhang</dc:creator>
<og:description>前言 链表（Linked list）比数组稍微复杂一点，在我们生活中用到最常见的应该是缓存，它是一种提高数据读取性能的技术，常见的如cpu缓存，浏览器缓存，数据库缓存等。今天我们就来学习一下链表 正文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clwydjgs/p/9778394.html</dc:identifier>
</item>
<item>
<title>vue中动态加载组件+开发者模式+JS参数值传递和引用传递 - 恋冬lll</title>
<link>http://www.cnblogs.com/lian-dong/p/9777172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lian-dong/p/9777172.html</guid>
<description>&lt;p&gt;今天写vue里面通过接口反参动态加载组件时候 跟着同学。。。学习到了&lt;/p&gt;
&lt;p&gt;一、先说说vue 内置组件 component 的用法&lt;/p&gt;
&lt;p&gt;component组件可以来专门用来进行组件的切换，使用is来绑定你的组件名，本次系统写的比较简单。。。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480181/201810/1480181-20181012110818080-392146612.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;此处：:is='组件名'可以直接条用组件。&lt;/p&gt;
&lt;p&gt;因为全页面有十个组件加载，所以用到了循环、数组。就遇到了在方法里可以打印数组里的值，但绑定组件名的地方获取不到的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480181/201810/1480181-20181012111102897-937167782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来加上了一个数组b，并把b数组的值赋值给a。a就可以获取到了。就是实现了动态加载组件。&lt;/p&gt;
&lt;p&gt;二、观察者模式&lt;/p&gt;
&lt;p&gt;   我需要遍历的数组值更新了,值也赋值了,为什么视图不更新？这个问题网上也有很多解释。&lt;/p&gt;
&lt;p&gt; 数组之所以获取不到是因为绑定中的观察者模式没有检测到b数组的改变，补习了一下观察者模式。https://blog.csdn.net/xidongdong1/article/details/78613654&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意图：&lt;/strong&gt;定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决：&lt;/strong&gt;一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用：&lt;/strong&gt;一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决：&lt;/strong&gt;使用面向对象技术，可以将这种依赖关系弱化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码：&lt;/strong&gt;在抽象类里有一个 ArrayList 存放观察者们。&lt;/p&gt;
&lt;p&gt;    在vue中model被定义为观察者，而view里面进行一处或多处依赖数据绑定即为观察者。https://www.cnblogs.com/pi-xia/articles/9351432.html中还列举了一些被观察者对观察者的控制方法。&lt;/p&gt;
&lt;p&gt;    当a赋值为b后才被观察者模式检测到，由此也补习了点JS参数值传递和引用传递的知识&lt;/p&gt;
&lt;p&gt;三、JS参数值传递和引用传递&lt;/p&gt;
&lt;p&gt; 字符串、数字、布尔、数组、对象、Null、Undefined&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;js&lt;/code&gt;中的变量是松散类型的，所以它提供了一种检测当前变量的数据类型的方法，也就是typeof关键字.&lt;/p&gt;
&lt;p&gt;typeof   123　　 //Number //NaN/isNaN&lt;/p&gt;
&lt;p&gt;typeof   'abc'　　//String&lt;/p&gt;
&lt;p&gt;typeof    true       //Boolean  //true/false&lt;/p&gt;
&lt;p&gt;typeof    undefined   //Undefined&lt;/p&gt;
&lt;p&gt;typeof    null        //Object  //被当一个空对象引用了&lt;/p&gt;
&lt;p&gt;typeof    { }           //Object&lt;/p&gt;
&lt;p&gt;typeof    [ ]           //Object&lt;/p&gt;
&lt;p&gt;typeof    console.log()       //Function&lt;/p&gt;
&lt;h4&gt;三大引用类型:object /Array/Function   (按存储类型)&lt;/h4&gt;
&lt;p&gt;值类型，复制值&lt;/p&gt;
&lt;p&gt;引用类型，复制值，但其实是地址，实际上是指针。两个变量都保存了同一个对象地址，则这两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480181/201810/1480181-20181012152948467-1823240746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以这样理解 数组里的值改变之后，观察者监听的是a的值，其实是地址，但地址值并没有改变。所以监听不到。而a[]=b[]后，地址值改变就监听到了。&lt;/p&gt;
&lt;p&gt;下面的代码：&lt;/p&gt;
&lt;p&gt;var a=[1,2,3]&lt;/p&gt;
&lt;p&gt;function aaa(b){&lt;/p&gt;
&lt;p&gt;b.push(4)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;aaa(a)&lt;/p&gt;
&lt;p&gt;alert(a)// [1,2,3,4]&lt;/p&gt;

&lt;p&gt;这里b、a所指地址一样，所以b加了值4,a中的值也改变了。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;此外，值类型赋值应该是存储的就是a1=3，这样的值。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1480181/201810/1480181-20181012153057525-1756396694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是我目前的理解，这都是以前看过的东西，没有深刻理解，就忘记了。基础的东西不应该忘呀！&lt;/p&gt;

</description>
<pubDate>Fri, 12 Oct 2018 07:31:00 +0000</pubDate>
<dc:creator>恋冬lll</dc:creator>
<og:description>今天写vue里面通过接口反参动态加载组件时候 跟着同学。。。学习到了 一、先说说vue 内置组件 component 的用法 component组件可以来专门用来进行组件的切换，使用is来绑定你的组件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lian-dong/p/9777172.html</dc:identifier>
</item>
<item>
<title>深度学习基础系列（五）| 深入理解交叉熵函数及其在tensorflow和keras中的实现 - 可可心心</title>
<link>http://www.cnblogs.com/hutao722/p/9761387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hutao722/p/9761387.html</guid>
<description>&lt;p&gt;　　在统计学中，损失函数是一种衡量损失和错误（这种损失与“错误地”估计有关，如费用或者设备的损失）程度的函数。假设某样本的实际输出为a，而预计的输出为y，则y与a之间存在偏差，深度学习的目的即是通过不断地训练迭代，使得a越来越接近y，即 a - y →0，而训练的本质就是寻找损失函数最小值的过程。&lt;/p&gt;
&lt;p&gt;　　常见的损失函数为两种，一种是均方差函数，另一种是交叉熵函数。对于深度学习而言，交叉熵函数要优于均方差函数，原因在于交叉熵函数配合输出层的激活函数如sigmoid或softmax函数能更快地加速深度学习的训练速度。这是为什么呢？让我们来详细了解下。&lt;/p&gt;
&lt;h3&gt; 一、函数定义&lt;/h3&gt;
&lt;h4&gt;1. 第一种损失函数：均方差函数，其定义为：&lt;/h4&gt;
&lt;p&gt;　　L(a, y) = ½ (a - y)&lt;sup&gt;2 &lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;　　令y=0，则L(a, y) = ½ a&lt;sup&gt;2&lt;/sup&gt; ，当a处于(-1, 1)区间范围时，其图形特征为：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201810/891145-20181009173042615-386105670.png&quot; alt=&quot;&quot; width=&quot;346&quot; height=&quot;260&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　可以看出当y = 0, a =0时，L(a, y) →0，其值是最小的。&lt;/p&gt;
&lt;p&gt;　　其求导公式为：dL(a, y) / da = a - y， 从函数本身来看当a = y时，L&lt;sup&gt;' &lt;/sup&gt;(a, y) = 0，也即求得最小值。&lt;/p&gt;

&lt;h4&gt;2. 第二种损失函数：交叉熵函数，其定义为：&lt;/h4&gt;
&lt;p&gt;　　L(a, y) = - [y * ln a + (1 - y) ln (1 - a)]&lt;/p&gt;
&lt;p&gt;　　为什么该函数能帮我们找到最小值呢？假设a和y都是在(0, 1)这个区间内取值。&lt;/p&gt;
&lt;p&gt;　　令 y=0, 则 L(a, y) = - ln (1 - a)， 当a →0时， L(a, y) ≈ - ln 1 = 0&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　 当a →1时， L(a, y) ≈ - ln 0 = +∞&lt;/p&gt;
&lt;p&gt;　　故y=0, a=0时，L(a, y) →0，符合找到最小值的目标。图形解释如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201810/891145-20181009171643775-465540578.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　反之，令 y=1, 则 L(a, y) = - ln a， 当a →0时， L(a, y) ≈ - ln 0 =  +∞&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　     当a →1时， L(a, y) ≈ - ln 1 = 0&lt;/p&gt;
&lt;p&gt;　　故y=1, a=1时，L(a, y) →0，也符合找到最小值的目标。图形解释如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201810/891145-20181009171915979-683022193.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，我们也可以令y=0.5，则 L(a, y) = -[0.5 * ln a + 0.5 * ln (1 - a)]。&lt;/p&gt;
&lt;p&gt;　　同样可以绘制出其图形：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201810/891145-20181009172205149-1394061675.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;270&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　可以发现，当y=0.5, a=0.5时， L(a, y) →0，也符合找到最小值的目标。&lt;/p&gt;
&lt;p&gt;　　以上描述简单地证明交叉熵函数是一个有效寻找最小值目标的损失函数。&lt;/p&gt;
&lt;p&gt;　　以下代码可以简单地绘制出上述交叉熵函数的图形特征：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; loss_5(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -0.5 * np.log(x) - 0.5 * np.log(1 -&lt;span&gt; x)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; loss_0(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1 * np.log(1 -&lt;span&gt; x)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; loss_1(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1 *&lt;span&gt; np.log(x)

x &lt;/span&gt;= np.arange(0, 1, 0.01&lt;span&gt;)
y &lt;/span&gt;=&lt;span&gt; loss_5(x)
plt.plot(x, y)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　最后，我们来求导下交叉熵函数，以为后续证明用：&lt;/p&gt;
&lt;p&gt;　　dL(a, y)/da = (- [y * ln a + (1 - y) ln (1 - a)])&lt;sup&gt;' &lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　 = -(y / a + (-1) * (1 -y) / (1 - a))&lt;/p&gt;
&lt;p&gt;　　　　　　     = - y / a + (1- y) / (1 - a ) 　&lt;/p&gt;
&lt;p&gt;　　　　　　　 =  (a - y) / [a * (1 - a)]&lt;/p&gt;

&lt;h3&gt;二、为什么交叉熵函数优于均方差函数？&lt;/h3&gt;
&lt;p&gt;　　前面的内容已让我们了解两种函数的特点，现在让我们看看为什么交叉熵函数要优于均方差函数。我们知道深度学习的训练过程是通过梯度下降法反向传播更新参数值，具体来说，每一次前向传播结束后，通过对损失函数+激活函数反向在每一层对每个w和b参数进行求导，得到dL/dw和dL/db的值，最后更新w和b，即 w → w - λ * dL/dw，b → b - λ * dL/db，其中λ为学习率。&lt;/p&gt;
&lt;p&gt;　　我们假设激活函数定义为sigmoid函数，并有如下前向传播路径：&lt;/p&gt;
&lt;p&gt;　　z&lt;sub&gt;1 &lt;/sub&gt;= w&lt;sub&gt;1 &lt;/sub&gt;x + b&lt;sub&gt;1 &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;1&lt;/sub&gt;= sigmoid(z&lt;sub&gt;1&lt;/sub&gt;)　&lt;/p&gt;
&lt;p&gt;　　z&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;= w&lt;sub&gt;2 &lt;/sub&gt; a&lt;sub&gt;1&lt;/sub&gt; + b&lt;sub&gt;2&lt;/sub&gt;　　&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;2&lt;/sub&gt;= sigmoid(z&lt;sub&gt;2&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;　　在此条件下，我们看看均方差函数和交叉熵函数在反向传播上的求导结果：&lt;/p&gt;
&lt;h4&gt;1. 均方差函数+sigmoid函数的反向求导：　　&lt;/h4&gt;
&lt;p&gt;　　令L(a, y) = ½ (a - y)&lt;sup&gt;2&lt;/sup&gt;  ，由前述可知，其求导为：L&lt;sup&gt;'&lt;/sup&gt;(a, y) = a - y&lt;/p&gt;
&lt;p&gt;　　而激活函数sigmoid的求导为：a&lt;sup&gt;'&lt;/sup&gt; (z)&lt;sup&gt; &lt;/sup&gt;= a (1 - a)&lt;/p&gt;
&lt;p&gt;　　我们对w&lt;sub&gt;2&lt;/sub&gt;进行求导，由链式法则可知：&lt;/p&gt;
&lt;p&gt;　　dL/dw&lt;sub&gt;2&lt;/sub&gt; = dL/da&lt;sub&gt;2  &lt;/sub&gt;*  da&lt;sub&gt;2&lt;/sub&gt;/dz&lt;sub&gt;2&lt;/sub&gt;  * dz&lt;sub&gt;2&lt;/sub&gt;/dw&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　　 = (a&lt;sub&gt;2&lt;/sub&gt; - y) * a&lt;sub&gt;2&lt;/sub&gt;(1 - a&lt;sub&gt;2&lt;/sub&gt;) * a&lt;sub&gt;1&lt;/sub&gt;　&lt;/p&gt;
&lt;h4&gt;2. 交叉熵函数+sigmoid函数的反向求导：&lt;/h4&gt;
&lt;p&gt;　  令L(a, y) = - [y * ln a + (1 - y) ln (1 - a)]，其求导为：L&lt;sup&gt;'&lt;/sup&gt;(a, y)  = (a - y) / [a * (1 - a)]&lt;/p&gt;
&lt;p&gt;　  同样激活函数sigmoid的求导为：a&lt;sup&gt;'&lt;/sup&gt; (z)&lt;sup&gt; &lt;/sup&gt;= a (1 - a)&lt;/p&gt;
&lt;p&gt;　  我们依旧对w&lt;sub&gt;2&lt;/sub&gt;进行求导，由链式法则可知：&lt;/p&gt;
&lt;p&gt;　  dL/dw&lt;sub&gt;2&lt;/sub&gt; = dL/dσ&lt;sub&gt;2  &lt;/sub&gt;*  dσ&lt;sub&gt;2&lt;/sub&gt;/dz&lt;sub&gt;2&lt;/sub&gt;  * dz&lt;sub&gt;2&lt;/sub&gt;/dw&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　　= (a&lt;sub&gt;2&lt;/sub&gt; - y) / [a&lt;sub&gt;2&lt;/sub&gt; * (1 - a&lt;sub&gt;2&lt;/sub&gt;)] * a&lt;sub&gt;2&lt;/sub&gt;(1 - a&lt;sub&gt;2&lt;/sub&gt;) * a&lt;sub&gt;1&lt;/sub&gt;　&lt;/p&gt;
&lt;p&gt;　　　　    = (a&lt;sub&gt;2&lt;/sub&gt; - y) * a&lt;sub&gt;1&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;　  &lt;strong&gt;比较上述两个反向求导w&lt;sub&gt;2&lt;/sub&gt;的结果，有没有发现交叉熵函数的求导结果要更简洁，因为它没有 a&lt;sub&gt;2&lt;/sub&gt;(1 - a&lt;sub&gt;2&lt;/sub&gt;) 这一项，即输出层激活函数a&lt;sub&gt;2&lt;/sub&gt;的自身求导。没有它非常重要，通过前文&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/hutao722/p/9732223.html&quot;&gt;深度学习基础系列（三）| sigmoid、tanh和relu激活函数的直观解释&lt;/a&gt;， 我们可知激活函数的自身斜率在趋近两端时变得很平滑，这也意味着反向求导时迭代值dL/dw会比较小，从而使得训练速度变慢，这即是交叉熵函数优于均方差函数的原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　  &lt;/strong&gt;也许大家会问，在sigmoid函数上交叉熵函数占优，那在softmax函数上又表现如何呢？我们继续验证，前向传播图作如下改造：&lt;/p&gt;
&lt;p&gt;　　z&lt;sub&gt;1 &lt;/sub&gt;= w&lt;sub&gt;1 &lt;/sub&gt;x + b&lt;sub&gt;1 &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;1&lt;/sub&gt;= sigmoid(z&lt;sub&gt;1&lt;/sub&gt;)　&lt;/p&gt;
&lt;p&gt;　　z&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;= w&lt;sub&gt;2  &lt;/sub&gt;a&lt;sub&gt;1&lt;/sub&gt; + b&lt;sub&gt;2&lt;/sub&gt;　　&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;2&lt;/sub&gt;= softmax(z&lt;sub&gt;2&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;　　假设softmax最后的输出结果a&lt;sub&gt;2&lt;/sub&gt;是由三个分类值组成，即y&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt; +  y&lt;sub&gt;2 &lt;/sub&gt; +  y&lt;sub&gt;3 &lt;/sub&gt; = 1，三种分类的概率和为1，其中y&lt;sub&gt;1&lt;/sub&gt; 概率为0.9，y&lt;sub&gt;2&lt;/sub&gt; 概率为0.05，y&lt;sub&gt;3&lt;/sub&gt; 的概率为0.05。自然，我们希望某个分类的概率最接近1，以说明这个分类就是我们的预测值，因此可认为y = 1。 而激活函数softmax，参考前文&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_0&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/hutao722/p/9754822.html&quot;&gt;深度学习基础系列（四）| 理解softmax函数&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;　　令y&lt;sub&gt;1&lt;/sub&gt; = e&lt;sup&gt;x1 &lt;/sup&gt;/ (e&lt;sup&gt;x1 &lt;/sup&gt;+ e&lt;sup&gt;x2 &lt;/sup&gt;+ e&lt;sup&gt;x3&lt;/sup&gt; )&lt;sup&gt; &lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;　　   y&lt;sub&gt;2&lt;/sub&gt; = e&lt;sup&gt;x2 &lt;/sup&gt;/ (e&lt;sup&gt;x1 &lt;/sup&gt;+ e&lt;sup&gt;x2 &lt;/sup&gt;+ e&lt;sup&gt;x3&lt;/sup&gt; )&lt;sup&gt; &lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;　　   y&lt;sub&gt;3&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt; = e&lt;sup&gt;x3 &lt;/sup&gt;/ (e&lt;sup&gt;x1 &lt;/sup&gt;+ e&lt;sup&gt;x2 &lt;/sup&gt;+ e&lt;sup&gt;x3&lt;/sup&gt; )&lt;sup&gt; &lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;　　可知其求导为：&lt;/p&gt;
&lt;p&gt;　　dy&lt;sub&gt;1&lt;/sub&gt;/dx&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt; &lt;/sup&gt;= y&lt;sub&gt;1&lt;/sub&gt; (1 - y&lt;sub&gt;1&lt;/sub&gt;) &lt;/p&gt;
&lt;p&gt;       dy&lt;sub&gt;2&lt;/sub&gt;/dx&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt; &lt;/sup&gt;= - y&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;* y&lt;sub&gt;2 &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　dy&lt;sub&gt;3&lt;/sub&gt;/dx&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt; &lt;/sup&gt;= - y&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;* y&lt;sub&gt;3&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;   &lt;/p&gt;
&lt;p&gt;　　在此条件下，我们看看均方差函数和交叉熵函数在反向传播上的求导结果：　&lt;/p&gt;
&lt;h4&gt;3. 均方差函数+softmax函数的反向求导：　&lt;/h4&gt;
&lt;p&gt;　　若在y&lt;sub&gt;1&lt;/sub&gt;进行反向求导，令L(y&lt;sub&gt;1&lt;/sub&gt;, y) = ½ (y&lt;sub&gt;1&lt;/sub&gt; - y)&lt;sup&gt;2&lt;/sup&gt;  ，其求导为：L&lt;sup&gt;'&lt;/sup&gt;(y&lt;sub&gt;1&lt;/sub&gt;, y) = y&lt;sub&gt;1&lt;/sub&gt; - y = y&lt;sub&gt;1 &lt;/sub&gt;- 1 &lt;/p&gt;
&lt;p&gt;　　我们对w&lt;sub&gt;2&lt;/sub&gt;进行求导，由链式法则可知：&lt;/p&gt;
&lt;p&gt;　　dL/dw&lt;sub&gt;2&lt;/sub&gt; = dL/dy&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;  &lt;/sub&gt;*  dy&lt;sub&gt;1&lt;/sub&gt;/dz&lt;sub&gt;2&lt;/sub&gt;  * dz&lt;sub&gt;2&lt;/sub&gt;/dw&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　　 = (y&lt;sub&gt;1&lt;/sub&gt; - 1) * y&lt;sub&gt;1&lt;/sub&gt;(1 - y&lt;sub&gt;1&lt;/sub&gt;) * a&lt;sub&gt;1&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;　　另一方面，若在y&lt;sub&gt;2&lt;/sub&gt;进行反向求导，令L(y&lt;sub&gt;2&lt;/sub&gt;, y) = ½ (y&lt;sub&gt;2&lt;/sub&gt; - y)&lt;sup&gt;2&lt;/sup&gt;  ，其求导为：L&lt;sup&gt;'&lt;/sup&gt;(y&lt;sub&gt;2&lt;/sub&gt;, y) = y&lt;sub&gt;2&lt;/sub&gt; - y = y&lt;sub&gt;2 &lt;/sub&gt;- 1&lt;/p&gt;
&lt;p&gt;　　我们对w&lt;sub&gt;2&lt;/sub&gt;进行求导，由链式法则可知：&lt;/p&gt;
&lt;p&gt;　　dL/dw&lt;sub&gt;2&lt;/sub&gt; = dL/dy&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;  &lt;/sub&gt;*  dy&lt;sub&gt;2&lt;/sub&gt;/dz&lt;sub&gt;2&lt;/sub&gt;  * dz&lt;sub&gt;2&lt;/sub&gt;/dw&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　　 = (y&lt;sub&gt;2&lt;/sub&gt; - 1) *  (- y&lt;sub&gt;1&lt;/sub&gt; * y&lt;sub&gt;2&lt;/sub&gt;) * a&lt;sub&gt;1&lt;/sub&gt;　&lt;/p&gt;

&lt;h4&gt;4. 交叉熵函数+softmax函数的反向求导：　&lt;/h4&gt;
&lt;p&gt;　　若在y&lt;sub&gt;1&lt;/sub&gt;进行反向求导，令 - [y * ln y&lt;sub&gt;1&lt;/sub&gt; + (1 - y) ln (1 - y&lt;sub&gt;1&lt;/sub&gt;)]，其求导为：L&lt;sup&gt;'&lt;/sup&gt;(y&lt;sub&gt;1&lt;/sub&gt;, y)  = (y&lt;sub&gt;1&lt;/sub&gt; - y) / [y&lt;sub&gt;1&lt;/sub&gt; * (1 - y&lt;sub&gt;1&lt;/sub&gt;)] =  (y&lt;sub&gt;1&lt;/sub&gt; - 1) / [y&lt;sub&gt;1&lt;/sub&gt; * (1 - y&lt;sub&gt;1&lt;/sub&gt;)] = -1/y&lt;sub&gt;1&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　我们对w&lt;sub&gt;2&lt;/sub&gt;进行求导，由链式法则可知：&lt;/p&gt;
&lt;p&gt;　　dL/dw&lt;sub&gt;2&lt;/sub&gt; = dL/dy&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;  &lt;/sub&gt;*  dy&lt;sub&gt;1&lt;/sub&gt;/dz&lt;sub&gt;2&lt;/sub&gt;  * dz&lt;sub&gt;2&lt;/sub&gt;/dw&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　　 = -1/y&lt;sub&gt;1&lt;/sub&gt; * y&lt;sub&gt;1&lt;/sub&gt;(1 - y&lt;sub&gt;1&lt;/sub&gt;) * a&lt;sub&gt;1&lt;/sub&gt;　&lt;/p&gt;
&lt;p&gt;　　　　　 = - (1 - y&lt;sub&gt;1&lt;/sub&gt;) * a&lt;sub&gt;1&lt;/sub&gt;　&lt;/p&gt;

&lt;p&gt;　　另一方面，若在y&lt;sub&gt;2&lt;/sub&gt;进行反向求导，令 - [y * ln y&lt;sub&gt;2&lt;/sub&gt; + (1 - y) ln (1 - y&lt;sub&gt;2&lt;/sub&gt;)]，其求导为：L&lt;sup&gt;'&lt;/sup&gt;(y&lt;sub&gt;2&lt;/sub&gt;, y)  = (y&lt;sub&gt;2&lt;/sub&gt; - y) / [y&lt;sub&gt;2&lt;/sub&gt; * (1 - y&lt;sub&gt;2&lt;/sub&gt;)] =  (y&lt;sub&gt;2&lt;/sub&gt; - 1) / [y&lt;sub&gt;2&lt;/sub&gt; * (1 - y&lt;sub&gt;2&lt;/sub&gt;)] = -1/y&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　我们对w&lt;sub&gt;2&lt;/sub&gt;进行求导，由链式法则可知：&lt;/p&gt;
&lt;p&gt;　　dL/dw&lt;sub&gt;2&lt;/sub&gt; = dL/dy&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;  &lt;/sub&gt;*  dy&lt;sub&gt;2&lt;/sub&gt;/dz&lt;sub&gt;2&lt;/sub&gt;  * dz&lt;sub&gt;2&lt;/sub&gt;/dw&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　　 = -1/y&lt;sub&gt;2&lt;/sub&gt; *  (- y&lt;sub&gt;1 *&lt;/sub&gt; y&lt;sub&gt;2&lt;/sub&gt;) * a&lt;sub&gt;1&lt;/sub&gt;　&lt;/p&gt;
&lt;p&gt;　　　　　 =  y&lt;sub&gt;1&lt;/sub&gt; * a&lt;sub&gt;1&lt;/sub&gt;　&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt; 综上比较，交叉熵函数在反向求导中，依旧完美地避开了softmax函数自身导数的影响，还是优于均方差函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;还需补充的是，在反向传播过程中，每一层对w和b求导，通过链式法则可知，依旧会受到该层的激活函数影响，若为sigmoid函数，依然不可避免地降低学习速度。因此深层网络中隐藏层的激活函数目前大都为relu函数，可以确保其导数要么为0，要么为1。 　&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;三、交叉熵函数在tensorflow和keras的实现说明 &lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;1.  sigmoid + 交叉熵函数&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;在tensorflow上&lt;/strong&gt;&lt;/em&gt;体现为sigmoid_cross_entropy_with_logits，对应的官网地址为：&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/sigmoid_cross_entropy_with_logits&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/api_docs/python/tf/nn/sigmoid_cross_entropy_with_logits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　说明：可应用于二元分类，如判断一张图片是否为猫；但如果图片里有多个分类，也并不互斥，比如一张图片里既包含狗，也包含猫，但如果我们给了猫和狗两个标签，那判断这张图片，既可以认为是狗，也可以认为是猫。　&lt;/p&gt;
&lt;p&gt;　　官网已给出数学推导后的公式：&lt;/p&gt;
&lt;p&gt;　　L = &lt;code&gt;&lt;span class=&quot;pln&quot;&gt;max&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;x&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;0&lt;span class=&quot;pun&quot;&gt;)&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt; x &lt;span class=&quot;pun&quot;&gt;*&lt;span class=&quot;pln&quot;&gt; z &lt;span class=&quot;pun&quot;&gt;+&lt;span class=&quot;pln&quot;&gt; log&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;lit&quot;&gt;1&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;+&lt;span class=&quot;pln&quot;&gt; exp&lt;span class=&quot;pun&quot;&gt;(-&lt;span class=&quot;pln&quot;&gt;abs&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;x&lt;span class=&quot;pun&quot;&gt;)))，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;其中x可认为是logits，z可认为是labels&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　　举一个简单的例子：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras.backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; nn

y_target &lt;/span&gt;= K.constant(value=[1&lt;span&gt;])
y_output &lt;/span&gt;= K.constant(value=[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_target: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_target))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_output))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the loss is: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, K.eval(nn.sigmoid_cross_entropy_with_logits(labels=y_target, logits=y_output)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
y_target:  [1.]
y_output:  [1.]
the loss is:  [0.3132617]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以把参数带入公式验证：max&lt;span class=&quot;pun&quot;&gt;(1&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;0&lt;span class=&quot;pun&quot;&gt;)&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt; 1 &lt;span class=&quot;pun&quot;&gt;*&lt;span class=&quot;pln&quot;&gt; 1 &lt;span class=&quot;pun&quot;&gt;+&lt;span class=&quot;pln&quot;&gt; log&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;lit&quot;&gt;1&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;+&lt;span class=&quot;pln&quot;&gt; exp&lt;span class=&quot;pun&quot;&gt;(-&lt;span class=&quot;pln&quot;&gt;abs&lt;span class=&quot;pun&quot;&gt;(1&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;))) = ln(1  + e&lt;sup&gt;-1&lt;/sup&gt;) = 0.3132617&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　　&lt;em&gt;&lt;strong&gt;而&lt;/strong&gt;&lt;strong&gt;在keras上&lt;/strong&gt;&lt;/em&gt;体现为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;binary_crossentropy，用途与上面的sigmoid_cross_entropy_with_logits是一样的，但两者有差别：&lt;/p&gt;
&lt;p&gt;　　sigmoid_cross_entropy_with_logits还原了预计值和输出值在数学公式中的差值，但不是一种概率差。上述例子中，输出值和预计值明明一样，概率差应该为0，但结果却为0.3132617&lt;/p&gt;
&lt;p&gt;　　而binary_crossentropy则先把输出值进行概率包装后，再带入sigmoid_cross_entropy_with_logits数学公式中。&lt;/p&gt;
&lt;p&gt;　　举一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras.backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; math_ops
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; clip_ops
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ops

y_target &lt;/span&gt;= K.constant(value=[1&lt;span&gt;])
y_output &lt;/span&gt;= K.constant(value=[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_target: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_target))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_output))

epsilon_ &lt;/span&gt;=&lt;span&gt; ops.convert_to_tensor(K.epsilon(), y_output.dtype.base_dtype)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;epsilon: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(epsilon_))
output &lt;/span&gt;= clip_ops.clip_by_value(y_output, epsilon_, 1 -&lt;span&gt; epsilon_)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(output))
output &lt;/span&gt;= math_ops.log(output / (1 -&lt;span&gt; output))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(output))
&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
print(&quot;the loss is: &quot;, K.eval(nn.sigmoid_cross_entropy_with_logits(labels=y_target, logits=output)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
y_target:  [1&lt;span&gt;.]
y_output:  [&lt;/span&gt;1&lt;span&gt;.]
epsilon:  &lt;/span&gt;1e-07&lt;span&gt;
output:  [&lt;/span&gt;0.9999999&lt;span&gt;]
output:  [&lt;/span&gt;15.942385&lt;span&gt;]
the loss &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;:  [1.1920933e-07]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后的结果1.1920933e-07相当于0.00000012，符合我们对预测值和输出值差别不大的认知。因此可以理解keras的损失函数输出值更加人性化。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;2. softmax + 交叉熵函数&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　在tensorflow上&lt;/strong&gt;体现为softmax_cross_entropy_with_logits_v2，对应的官网地址为：&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits_v2&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits_v2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;说明：可用于多元分类，如判断一张图片是否为猫；但如果图片里多个类别则是互斥的，比如一张图片里既包含狗，也包含猫，那我们也只能给唯一的标签，要么是狗，要么是猫。&lt;/p&gt;
&lt;p&gt;　　其数学公式为：L = ∑ -(y * lna）　&lt;/p&gt;
&lt;p&gt;　　举个例子说明：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras.backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; nn

y_target &lt;/span&gt;= K.constant(value=[1, 2&lt;span&gt;])
y_output &lt;/span&gt;= K.constant(value=[1, 2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_target: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_target))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_output))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the loss is: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, K.eval(nn.softmax_cross_entropy_with_logits_v2(labels=y_target, logits=y_output)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
y_target:  [1. 2.]
y_output:  [1. 2.]
the loss is:  1.939785
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：y_output有两个输出值1和2，通过softmax函数转化后，我们可知1的对应softmax值为0.268941422，而2的对应softmax值为0.731058581；同时1对应的预测值为1,2对应的预测值为2。将上述值带入公式验证：&lt;/p&gt;
&lt;p&gt;　　L = ∑ -(y * lna)　&lt;/p&gt;
&lt;p&gt;　　   = -(1 * ln (e&lt;sup&gt; &lt;/sup&gt;/ (e + e&lt;sup&gt;2&lt;/sup&gt;)) ) + -(2 * ln (e&lt;sup&gt;2 &lt;/sup&gt;/ (e + e&lt;sup&gt;2&lt;/sup&gt;)))&lt;/p&gt;
&lt;p&gt;　　   = -(1* ln0.268941422) + -(2 * ln0.731058581)&lt;/p&gt;
&lt;p&gt;　　   = 1.939785&lt;/p&gt;

&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;而在keras中&lt;/strong&gt;&lt;/em&gt;，与此对应的是categorical_crossentropy，采用的算法和上述基本一致，只是需要把y_output按分类值做概率转换。&lt;/p&gt;
&lt;p&gt;　　我们来举例说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras.backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; nn
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; math_ops
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; clip_ops
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ops

y_target &lt;/span&gt;= K.constant(value=[1, 2&lt;span&gt;])
y_output &lt;/span&gt;= K.constant(value=[1, 2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_target: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_target))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_output))

output &lt;/span&gt;= y_output / math_ops.reduce_sum(y_output, -1&lt;span&gt;, True)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(output))
epsilon_ &lt;/span&gt;=&lt;span&gt; ops.convert_to_tensor(K.epsilon(), output.dtype.base_dtype)
output &lt;/span&gt;= clip_ops.clip_by_value(output, epsilon_, 1. -&lt;span&gt; epsilon_)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(output))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the loss is: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, K.eval(-math_ops.reduce_sum(y_target * math_ops.log(output), -1)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
y_target:  [1. 2&lt;span&gt;.]
y_output:  [&lt;/span&gt;1. 2&lt;span&gt;.]
output:  [&lt;/span&gt;0.33333334 0.6666667&lt;span&gt; ]
output:  [&lt;/span&gt;0.33333334 0.6666667&lt;span&gt; ]
the loss &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;:  1.9095424
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其计算公式为：&lt;/p&gt;
&lt;p&gt;　　L = ∑ -(y * lna)　&lt;/p&gt;
&lt;p&gt;　　   = -(1 * ln 0.33333334 ) + -(2 * ln 0.66666667)&lt;/p&gt;
&lt;p&gt;　　   = 1.9095424&lt;/p&gt;

&lt;h4&gt;3. sparse + softmax + 交叉熵函数：　&lt;/h4&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;在tensorflows中&lt;/strong&gt;&lt;/em&gt;体现为sparse_softmax_cross_entropy_with_logits，对应的官网地址为：&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/sparse_softmax_cross_entropy_with_logits&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/api_docs/python/tf/nn/sparse_softmax_cross_entropy_with_logits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　说明：可用于多元分类，如判断一张图片是否为猫；但如果图片里多个类别则是互斥的，比如一张图片里既包含狗，也包含猫，那我们也只能给唯一的标签，要么是狗，要么是猫。&lt;/p&gt;
&lt;p&gt;　　加上sparse的区别在于：不加sparse给定的labels是允许有概率分布的，如[0.3, 0.4, 0.2, 0.05, 0.05]，而加sparse，则如其名sparse稀疏矩阵，概率只允许要么存在，要么不存在，如[0, 0, 0, 1, 0]&lt;/p&gt;
&lt;p&gt;　　我们常见的mnist数据集、cifar-10数据集等都是这种类型。&lt;/p&gt;
&lt;p&gt;　　其数学公式为：L = -y * ln a，其中a为概率为1的输出值&lt;/p&gt;
&lt;p&gt;　　依旧举例说明： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras.backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.python.ops &lt;span&gt;import&lt;/span&gt;&lt;span&gt; nn

y_target &lt;/span&gt;= K.constant(value=1, dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;int32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
y_output &lt;/span&gt;= K.constant(value=[1, 2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_target: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_target))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_output))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the loss is: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, K.eval(nn.sparse_softmax_cross_entropy_with_logits(labels=y_target, logits=y_output)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
y_target:  1&lt;span&gt;
y_output:  [&lt;/span&gt;1. 2&lt;span&gt;.]
the loss &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;:  0.31326166
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：本例中，输出值y_output为1和2，表示两种分类，而y_target的值为1，表示为分类的index，也就是对应了输出值2；更直白地说，输出值1的概率为0，输出值2的概率为1。&lt;/p&gt;
&lt;p&gt;　　具体计算方式为：a = e&lt;sup&gt;2 &lt;/sup&gt;/ (e + e&lt;sup&gt;2&lt;/sup&gt;) = 0.731058581&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　L = - ln a = 0.313261684&lt;/p&gt;

&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;而&lt;/strong&gt;&lt;strong&gt;在keras中&lt;/strong&gt;&lt;/em&gt;，与此对应的为sparse_categorical_crossentropy，该函数会调用上述函数，最大的不同在于：1. 其参数y_output被设定为经过softmax之后的值；2. y_output还会被log处理下&lt;/p&gt;
&lt;p&gt;　　举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras.backend as K

y_target &lt;/span&gt;= K.constant(value=1, dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;int32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
y_output &lt;/span&gt;= K.constant(value=[0.2, 0.2, 0.6&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_target: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_target))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_output: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, K.eval(y_output))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the loss is: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, K.eval(K.sparse_categorical_crossentropy(y_target, y_output)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
y_target:  1&lt;span&gt;
y_output:  [&lt;/span&gt;0.2 0.2 0.6&lt;span&gt;]
the loss &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;:  [1.609438]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：本例中y_output的值已经假设按照softmax处理后的值：0.2,0.2和0.6&lt;/p&gt;
&lt;p&gt;　　其计算方式为：&lt;/p&gt;
&lt;p&gt;　　a = e&lt;sup&gt;ln0.2&lt;/sup&gt;/(e&lt;sup&gt;ln0.2 &lt;/sup&gt;+ e&lt;sup&gt;ln0.2&lt;/sup&gt;&lt;sup&gt; &lt;/sup&gt;+ e&lt;sup&gt;ln0,6&lt;/sup&gt;) = 0.2/(0.2 + 0.2 +0.6) = 0.2&lt;/p&gt;
&lt;p&gt;　　L = - ln 0.2 = 1.609438&lt;/p&gt;

&lt;p&gt;　　以上即是交叉熵函数作为损失函数的使用理由，及其在tensorflow和keras中的实现说明。　　&lt;/p&gt;

</description>
<pubDate>Fri, 12 Oct 2018 07:20:00 +0000</pubDate>
<dc:creator>可可心心</dc:creator>
<og:description>在统计学中，损失函数是一种衡量损失和错误（这种损失与“错误地”估计有关，如费用或者设备的损失）程度的函数。假设某样本的实际输出为a，而预计的输出为y，则y与a之间存在偏差，深度学习的目的即是通过不断地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hutao722/p/9761387.html</dc:identifier>
</item>
<item>
<title>深入出不来nodejs源码-timer模块(JS篇) - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/9776812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/9776812.html</guid>
<description>&lt;p&gt;　　鸽了好久，最近沉迷游戏，继续写点什么吧，也不知道有没有人看。&lt;/p&gt;
&lt;p&gt;　　其实这个node的源码也不知道该怎么写了，很多模块涉及的东西比较深，JS和C++两头看，中间被工作耽搁回来就一脸懵逼了，所以还是挑一些简单的吧！&lt;/p&gt;

&lt;p&gt;　　这一篇选的是定时器模块，简单讲就是初学者都非常熟悉的setTimeout与setInterval啦，源码的JS内容在目录lib/timers.js中。&lt;/p&gt;
&lt;p&gt;　　node的定时器模块是自己单独实现的，与Chrome的window.setTimeout可能不太一样，但是思想应该都是相通的，学一学总没错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　定时器模块实现中有一个关键数据结构：链表。用JS实现的链表，大体上跟其他语言的链表的原理还是一样，每一个节点内容可分为前指针、后指针、数据。&lt;/p&gt;
&lt;p&gt;　　源码里的链表构造函数有两种，一个是List的容器，一个是容器里的item。&lt;/p&gt;
&lt;p&gt;　　这里看看List：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; TimersList(msecs, unrefed) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前指针&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._idleNext = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后指针&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._idlePrev = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._unrefed =&lt;span&gt; unrefed;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msecs =&lt;span&gt; msecs;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...更多&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个很典型的链表例子，包含2个指针(属性)以及数据块。item的构造函数大同小异，也是包含了两个指针，只是数据内容有些不同。&lt;/p&gt;
&lt;p&gt;　　关于链表的操作，放在了一个单独的JS文件中，目录在lib/internal/linkedlist.js，实现跟C++、Java内置的有些许不一样。&lt;/p&gt;
&lt;p&gt;　　看一下增删就差不多了，首先看删：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; remove(item) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理前后节点的指针指向&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (item._idleNext) {
    item._idleNext._idlePrev &lt;/span&gt;=&lt;span&gt; item._idlePrev;
  }

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (item._idlePrev) {
    item._idlePrev._idleNext &lt;/span&gt;=&lt;span&gt; item._idleNext;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置节点自身指针指向&lt;/span&gt;
  item._idleNext = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  item._idlePrev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　关于数据结构的代码，都是虽然看起来少，但是理解起来都有点恶心，能画出图就差不多了，所以这里给一个简单的示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201810/858904-20181012110253193-590890144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　应该能看懂吧……反正中间那个假设就是item，首先让前后两个对接上，然后把自身的指针置null。&lt;/p&gt;
&lt;p&gt;　　接下来是增。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; append(list, item) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先保证传入节点是空白节点&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (item._idleNext ||&lt;span&gt; item._idlePrev) {
    remove(item);
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理新节点的头尾链接&lt;/span&gt;
  item._idleNext =&lt;span&gt; list._idleNext;
  item._idlePrev &lt;/span&gt;=&lt;span&gt; list;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理list的前指针指向&lt;/span&gt;
  list._idleNext._idlePrev =&lt;span&gt; item;
  list._idleNext &lt;/span&gt;=&lt;span&gt; item;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里需要注意，初始化的时候就有一个List节点，该节点只作为链表头，与其余item不一样，一开始前后指针均指向自己。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201810/858904-20181012111917227-1862572353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上是append节点的三步示例图。&lt;/p&gt;
&lt;p&gt;　　之前说过JS实现的链表与C++、Java有些许不一样，就在这里，每一次添加新节点时：&lt;/p&gt;
&lt;p&gt;C++/Java：node-node =&amp;gt; node-node-new&lt;/p&gt;
&lt;p&gt;JS(node)：list-node-node =&amp;gt; list-new-node-node&lt;/p&gt;
&lt;p&gt;　　总的来说，JS用了一个list来作为链表头，每一次添加节点都是往前面塞，整体来讲是一个双向循环链表。&lt;/p&gt;
&lt;p&gt;　　而在C++/Java中则是可以选择，API丰富多彩，链表类型也分为单向、单向循环、双向等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;setTimeout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　链表有啥用，后面就知道了。&lt;/p&gt;
&lt;p&gt;　　首先从setTimeout这个典型的API入手，node的调用方式跟window.setTimeout一致，所以就不介绍了，直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 
 * @param {Function} callback 延迟触发的函数
 * @param {Number} after 延迟时间
 * @param {*} arg1 额外参数1
 * @param {*} arg2 额外参数2
 * @param {*} arg3 额外参数3
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setTimeout(callback, after, arg1, arg2, arg3) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有第一个函数参数是必须的&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; callback !== 'function'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ERR_INVALID_CALLBACK();
  }

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i, args;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 参数修正
   * 简单来说 就是将第三个以后的参数包装成数组
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (arguments.length) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
      args &lt;/span&gt;=&lt;span&gt; [arg1];
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 4&lt;span&gt;:
      args &lt;/span&gt;=&lt;span&gt; [arg1, arg2];
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      args &lt;/span&gt;=&lt;span&gt; [arg1, arg2, arg3];
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 5; i &amp;lt; arguments.length; i++&lt;span&gt;) {
        args[i &lt;/span&gt;- 2] =&lt;span&gt; arguments[i];
      }
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个Timeout对象&lt;/span&gt;
  const timeout = &lt;span&gt;new&lt;/span&gt; Timeout(callback, after, args, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  active(timeout);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该对象&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; timeout;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，调用方式基本一致，但是有一点很不一样，该方法返回的不是一个代表定时器ID的数字，而是直接返回生成的Timeout对象。&lt;/p&gt;
&lt;p&gt;　　稍微测试一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201810/858904-20181012140047816-898090874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然说返回的是对象，但是clearTimeout需要的参数也正是一个timeout对象，总体来说也没啥需要注意的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Timeout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　接下来看看这个对象的内容，源码来源于lib/internal/timers.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 
 * @param {Function} callback 回调函数
 * @param {Number} after 延迟时间
 * @param {Array} args 参数数组
 * @param {Boolean} isRepeat 是否重复执行(setInterval/setTimeout)
 * @param {Boolean} isUnrefed 不知道是啥玩意
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Timeout(callback, after, args, isRepeat, isUnrefed) {
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 对延迟时间参数进行数字类型转换
   * 数字类型字符串 会变成数字
   * 非数字非数字字符串 会变成NaN
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  after &lt;/span&gt;*= 1&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(after &amp;gt;= 1 &amp;amp;&amp;amp; after &amp;lt;=&lt;span&gt; TIMEOUT_MAX)) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大为2147483647 官网有写&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (after &amp;gt;&lt;span&gt; TIMEOUT_MAX) {
      process.emitWarning(`${after} does not fit into` &lt;/span&gt;+
                          ' a 32-bit signed integer.' +
                          '\nTimeout duration was set to 1.'&lt;span&gt;,
                          &lt;/span&gt;'TimeoutOverflowWarning'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小于1、大于最大限制、非法参数均会被重置为1&lt;/span&gt;
    after = 1&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用标记&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._called = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 延迟时间&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._idleTimeout =&lt;span&gt; after;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前后指针&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._idlePrev = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._idleNext = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._idleStart = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; V8层面的优化我也不太懂 留下英文注释自己研究吧&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this must be set to null first to avoid function tracking&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; on the hidden class, revisit in V8 versions after 6.2&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._onTimeout = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调函数&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._onTimeout =&lt;span&gt; callback;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._timerArgs =&lt;span&gt; args;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setInterval的参数&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._repeat = isRepeat ? after : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摧毁标记&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;._destroyed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[unrefedSymbol] =&lt;span&gt; isUnrefed;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂时不晓得干啥的&lt;/span&gt;
  initAsyncResource(&lt;span&gt;this&lt;/span&gt;, 'Timeout'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之前讲过，整个方法，只有第一个参数是必须的，如果不传延迟时间，默认设置为1。&lt;/p&gt;
&lt;p&gt;　　这里有意思的是，如果传一个字符串的数字，也是合法的，会被转换成数字。而其余非法值会被转换为NaN，且NaN与任何数字比较都返回false，所以始终会重置为1这个合法值。&lt;/p&gt;
&lt;p&gt;　　后面的属性基本上就可以分为两个指针和数据块了，最后的initAsyncResource目前还没搞懂，其余模块也见过这个东西，先留个坑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;active/insert&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　生成了Timeout对象，第三步就会利用前面的链表进行处理，这里才是重头戏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
const refedLists = Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
const unrefedLists &lt;/span&gt;= Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

const active &lt;/span&gt;= exports.active = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item) {
  insert(item, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 
 * @param {Timeout} item 定时器对象
 * @param {Boolean} unrefed 区分内部/外部调用
 * @param {Boolean} start 不晓得干啥的
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; insert(item, unrefed, start) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出延迟时间&lt;/span&gt;
  const msecs =&lt;span&gt; item._idleTimeout;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msecs &amp;lt; 0 || msecs === undefined) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; start === 'number'&lt;span&gt;) {
    item._idleStart &lt;/span&gt;=&lt;span&gt; start;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    item._idleStart &lt;/span&gt;=&lt;span&gt; TimerWrap.now();
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部使用定时器使用不同对象&lt;/span&gt;
  const lists = unrefed === &lt;span&gt;true&lt;/span&gt; ?&lt;span&gt; unrefedLists : refedLists;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 延迟时间作为键来生成一个链表类型值&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; lists[msecs];
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list ===&lt;span&gt; undefined) {
    debug(&lt;/span&gt;'no %d list was found in insert, creating a new one'&lt;span&gt;, msecs);
    lists[msecs] &lt;/span&gt;= list = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimersList(msecs, unrefed);
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 留个坑 暂时不懂这个&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!item[async_id_symbol] ||&lt;span&gt; item._destroyed) {
    item._destroyed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    initAsyncResource(item, &lt;/span&gt;'Timeout'&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把当前timeout对象添加到对应的链表上&lt;/span&gt;
&lt;span&gt;  L.append(list, item);
  assert(&lt;/span&gt;!&lt;span&gt;L.isEmpty(list));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从这可以看出node内部处理定时器回调函数的方式。&lt;/p&gt;
&lt;p&gt;　　首先有两个空对象，分别保存内部、外部的定时器对象。对象的键是延迟时间，值则是一个链表头，即以前介绍的list。每一次生成一个timeout对象时，会链接到list后面，通过这个list可以引用到所有该延迟时间的对象。&lt;/p&gt;
&lt;p&gt;　　画个图示意一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201810/858904-20181012144709129-1884417709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么问题来了，node是在哪里开始触发定时器的？实际上，在生成对应list链表头的时候就已经开始触发了。&lt;/p&gt;
&lt;p&gt;　　完整的list构造函数源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; TimersList(msecs, unrefed) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._idleNext = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._idlePrev = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._unrefed =&lt;span&gt; unrefed;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msecs =&lt;span&gt; msecs;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 来源于C++内置模块&lt;/span&gt;
  const timer = &lt;span&gt;this&lt;/span&gt;._timer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerWrap();
  timer._list &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (unrefed === &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    timer.unref();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发&lt;/span&gt;
&lt;span&gt;  timer.start(msecs);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终还是指向了内置模块，将list本身作为属性添加到timer上，通过C++代码触发定时器。&lt;/p&gt;
&lt;p&gt;　　C++部分单独写吧。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 07:04:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<og:description>鸽了好久，最近沉迷游戏，继续写点什么吧，也不知道有没有人看。 其实这个node的源码也不知道该怎么写了，很多模块涉及的东西比较深，JS和C++两头看，中间被工作耽搁回来就一脸懵逼了，所以还是挑一些简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QH-Jimmy/p/9776812.html</dc:identifier>
</item>
<item>
<title>单页面vue引入百度统计的使用方法！ - 雨吻蝶</title>
<link>http://www.cnblogs.com/zengfp/p/9778119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengfp/p/9778119.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近组长安排着做一个项目，h5的应用下载项目，想着做起来还是比较容易，可是看到提出的需求，我就有点懵逼了！需要对应用的下载进行统计！！！我当时就想着我前端怎么对页面点击按钮就行数据统计啊！我以前的项目也有对应用的下载量就行数据统计的，可是那些项目都是后台人员编写进行数据统计的。我当时就有点不知所措了。想着怎么进行统计，怎么搞定这个！百度得知，百度统计可以帮着解决这个问题，可是没有用过啊！硬着头皮，进入自己的踩坑之旅！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、首先还是先在百度统计注册账号，并且新增网站，设置网站域名。如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012112657982-101812817.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在自己构建的vue项目中，引入vue-ba&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install --save vue-ba&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后在main.js中引入：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The Vue build version to load with the `import` command&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; (runtime-only or standalone) has been set in webpack.base.conf with an alias.&lt;/span&gt;
import Vue from 'vue'&lt;span&gt;
import App from &lt;/span&gt;'./App'&lt;span&gt;
import ba from &lt;/span&gt;'vue-ba'&lt;span&gt;
import &lt;/span&gt;'./assets/css/normalize.css'
Vue.config.productionTip = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;Vue.use(ba, &lt;/span&gt;&quot;175015a6227dca437e13abb9a6e845ac&quot;&lt;span&gt;);
Vue.use(ba, { siteId: &lt;/span&gt;&quot;175015a6227dca437e13abb9a6e845ac&quot;&lt;span&gt; });


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-disable no-new &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  components: { App },
  template: &lt;/span&gt;'&amp;lt;App/&amp;gt;'&lt;span&gt;
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;siteId让我找了蛮久，刚开始有误操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012141347188-1022062327.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚开始以为这个就是siteId=12603119，可是使用这个siteId没有效果，后来才得知，siteId是在这里：管理-&amp;gt;获取代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012141642734-902902434.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012141837625-1050893397.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在上图的红线框内，才是这个域名下的siteId，使用正确的siteId之后，就验证是否正确引入，就进行代码检查：管理-&amp;gt;代码检查&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012142237004-2060303601.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012142349191-964481516.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击开始检查，如果你的网址就是此处的网站首页，就会出来检查结果，如果你的网址与这里的网站首页地址不一样，你就把你的网址输入在&quot;其他网页&quot;这一栏，点击开始检查，就会出现以下结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012142817388-423649523.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就证明你的引入成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一种手动检查的方法，就是在chrome浏览器中输入你的网址，按F12，调试模式，按Network，如果找到了hm.js?xxxxxx这个文件，也说明你的代码引入成功，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012143157311-1182602525.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、siteId配置成功之后，就需要在你的html内对点击事件等进行监测了。vue-ba这款插件有详细的使用方法，我就不介绍使用了，我就写我使用到的。详细的使用地址： &lt;span class=&quot;cnblogs_code&quot;&gt;https://github.com/minlingchao1/vue-ba&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我就只用到了trackEvent这个api，vue-ba 提供 track-event，track-pageview 两个指令，我们可以直接在 html 模版中使用来统计网站数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1 track-event　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用指令 v-track-event 监听事件， 通过 modifiers 指定事件类型，将自动为绑定元素添加事件监听，当事件触发调用统计代码。 如不指定事件，默认监听 click 事件。可通过逗号分隔的字符串或对象字面量传递参数，以字符串传递时请注意参数顺序，可参考trackEvent API。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-track-event.click&lt;/span&gt;&lt;span&gt;=&quot;'category, action''&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; // 统计click事件

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-track-event&lt;/span&gt;&lt;span&gt;=&quot;'category, action'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; // 统计click事件简写

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-track-event.keypress&lt;/span&gt;&lt;span&gt;=&quot;'category, action'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; // 统计keypress事件

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-track-event&lt;/span&gt;&lt;span&gt;=&quot;'category, action, opt_label, opt_value'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; // 以字符串传递参数

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-track-event&lt;/span&gt;&lt;span&gt;=&quot;{category:'event', action:'click'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; // 以对象字面量传递参数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3.2 track-pageview&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用指令 track-pageview 统计虚拟 PV ，一般可以配合 v-show 或 v-if 来统计局部动态视图的 PV。可通过逗号分隔的字符串或对象字面量传递参数，以字符串传递时请注意参数顺序，可参考trackPageview API 用法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-show&lt;/span&gt;&lt;span&gt;=&quot;show&quot;&lt;/span&gt;&lt;span&gt; v-track-pageview&lt;/span&gt;&lt;span&gt;=&quot;'/bar'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;bar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; //  跟踪 v-show 绑定元素的虚拟pv

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;show&quot;&lt;/span&gt;&lt;span&gt; v-track-pageview&lt;/span&gt;&lt;span&gt;=&quot;'/foo'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;foo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; // 跟踪 v-if 绑定元素的虚拟pv

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-track-pageview&lt;/span&gt;&lt;span&gt;=&quot;'/tar'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; // 以字符串指定受访页面和来源

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-track-pageview&lt;/span&gt;&lt;span&gt;=&quot;{pageURL:'/zoo''}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; // 以对象字面量指定受访页面和来源&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我在app.vue中的使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-container swiper-container1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;swiper &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-wrapper&quot;&lt;/span&gt;&lt;span&gt; :options&lt;/span&gt;&lt;span&gt;=&quot;bannerOptions&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bannerSwiper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;swiper-slide &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-slide&quot;&lt;/span&gt;&lt;span&gt; v-for&lt;/span&gt;&lt;span&gt;=&quot;(item,index) in banner&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-link&quot;&lt;/span&gt;&lt;span&gt; :href&lt;/span&gt;&lt;span&gt;=&quot;item.link&quot;&lt;/span&gt;&lt;span&gt; v-track-event&lt;/span&gt;&lt;span&gt;=&quot;{category:'download', action:'click',opt_label: item.link}&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container1-img&quot;&lt;/span&gt;&lt;span&gt; :src&lt;/span&gt;&lt;span&gt;=&quot;item.icon&quot;&lt;/span&gt;&lt;span&gt; :alt&lt;/span&gt;&lt;span&gt;=&quot;item.desc&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;swiper-slide&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;swiper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;list-download&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;:href&lt;/span&gt;&lt;span&gt;=&quot;item.packagename&quot;&lt;/span&gt;&lt;span&gt; v-track-event&lt;/span&gt;&lt;span&gt;=&quot;{category:'download', action:'click',opt_label: item.packagename}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;下载&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;通过这种方法，就可以让你在百度统计里面看到你想要统计的数据。但是这种统计的结果不会很快就出来，需要过一段时间，两三个小时是需要的。我也等了将近3个小时，才看到统计的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201810/1475852-20181012144608833-1042578905.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、总算是大功告成了，虽然百度统计里面可能还是还有蛮多没有吃透，但是先把项目完成才是最重要的，接下来的就是慢慢去搞。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 12 Oct 2018 06:50:00 +0000</pubDate>
<dc:creator>雨吻蝶</dc:creator>
<og:description>最近组长安排着做一个项目，h5的应用下载项目，想着做起来还是比较容易，可是看到提出的需求，我就有点懵逼了！需要对应用的下载进行统计！！！我当时就想着我前端怎么对页面点击按钮就行数据统计啊！我以前的项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zengfp/p/9778119.html</dc:identifier>
</item>
<item>
<title>Redis偶发连接失败案例分析 - 携程DBA</title>
<link>http://www.cnblogs.com/CtripDBA/p/9776466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CtripDBA/p/9776466.html</guid>
<description>&lt;h2 id=&quot;作者&quot;&gt;【作者】&lt;/h2&gt;
&lt;p&gt;张延俊：携程技术保障中心资深DBA，对数据库架构和疑难问题分析排查有浓厚的兴趣。&lt;br/&gt;寿向晨：携程技术保障中心高级DBA，主要负责携程Redis及DB的运维工作，在自动化运维，流程化及监控排障等方面有较多的实践经验，喜欢深入分析问题，提高团队运维效率。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;【问题描述】&lt;/h2&gt;
&lt;p&gt; 生产环境有一个Redis会偶尔发生连接失败的报错，报错的时间点、客户端IP并没有特别明显的规律，过一会儿，报错会自动恢复。&lt;br/&gt; 以下是客户端报错信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CRedis.Client.RExceptions.ExcuteCommandException: Unable to Connect redis server: ---&amp;gt; CRedis.Third.Redis.RedisException: &lt;span&gt;Unable to Connect redis server:&lt;/span&gt;
   在 CRedis.Third.Redis.RedisNativeClient.CreateConnectionError()
   在 CRedis.Third.Redis.RedisNativeClient.SendExpectData(Byte[][] cmdWithBinaryArgs)
   在 CRedis.Client.Entities.RedisServer.&amp;lt;&amp;gt;c__DisplayClassd`1.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 从报错的信息来看，应该是连接不上Redis所致。Redis的版本是2.8.19。虽然版本有点老，但基本运行稳定。&lt;br/&gt; 线上环境只有这个集群有偶尔报错。这个集群的一个比较明显的特征是客户端服务器比较多，有上百台。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;【问题分析】&lt;/h2&gt;
&lt;p&gt; 从报错的信息来看，客户端连接不到服务端。常见的原因有以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个常见的原因是由于端口耗尽，对网络连接进行排查，在出问题的点上，TCP连接数远没有达到端口耗尽的场景，因此这个不是Redis连接不上的根本原因。&lt;/li&gt;
&lt;li&gt;另外一种常见的场景是在服务端有慢查询，导致Redis服务阻塞。我们在Redis服务端，把运行超过10毫秒的语句进行抓取，也没有抓到运行慢的语句。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 从服务端的部署的监控来看，出问题的点上，连接数有一个突然飙升，从3500个连接突然飙升至4100个连接。如下图显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1247138/201810/1247138-20181012101824869-679048866.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时间，服务器端显示Redis服务端有丢包现象：345539 – 344683 = 856个包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Sat Apr  7 10:41:40 CST 2018
   1699 outgoing packets dropped
   92 dropped because of missing route
   &lt;span&gt;344683 SYNs to LISTEN sockets dropped&lt;/span&gt;
   &lt;span&gt;344683 times the listen queue of a socket overflowed&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Sat Apr  7 10:41:41 CST 2018
   1699 outgoing packets dropped
   92 dropped because of missing route
   &lt;span&gt;345539 SYNs to LISTEN sockets dropped&lt;/span&gt;
   &lt;span&gt;345539 times the listen queue of a socket overflowed&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 客户端报错的原因基本确定，是因为建连速度太快，导致服务端backlog队列溢出，连接被server端reset。&lt;/p&gt;
&lt;h3 id=&quot;关于backlog-overflow&quot;&gt;【关于backlog overflow】&lt;/h3&gt;
&lt;p&gt; 在高并发的短连接服务中，这是一种很常见的tcp报错类型。一个正常的tcp建连过程如下：&lt;/p&gt;
&lt;p&gt; 1.client发送一个(SYN)给server&lt;/p&gt;
&lt;p&gt; 2.server返回一个(SYN,ACK)给client&lt;/p&gt;
&lt;p&gt; 3.client返回一个(ACK)&lt;/p&gt;
&lt;p&gt; 三次握手结束，对client来说建连成功，client可以继续发送数据包给server，但是这个时候server端未必ready，如下图所示 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1247138/201810/1247138-20181012103427725-527925065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在BSD版本内核实现的tcp协议中，server端建连过程需要两个队列，一个是SYN queue，一个是accept queue。前者叫半开连接（或者半连接）队列，在接收到client发送的SYN时加入队列。（一种常见的网络攻击方式就是不断发送SYN但是不发送ACK从而导致server端的半开队列撑爆，server端拒绝服务。）后者叫全连接队列，server返回(SYN,ACK)，在接收到client发送ACK后（此时client会认为建连已经完成，会开始发送PSH包），如果accept queue没有满，那么server从SYN queue把连接信息移到accept queue；如果此时accept queue溢出的话，server的行为要看配置。如果tcp_abort_on_overflow为0（默认），那么直接drop掉client发送的PSH包，此时client会进入重发过程，一段时间后server端重新发送SYN,ACK，重新从建连的第二步开始；如果tcp_abort_on_overflow为1，那么server端发现accept queue满之后直接发送reset。&lt;/p&gt;
&lt;p&gt;通过wireshark搜索发现在一秒内有超过2000次对Redis Server端发起建连请求。我们尝试修改tcp backlog大小，从511调整到2048, 问题并没有得到解决。所以此类微调，并不能彻底的解决问题。&lt;/p&gt;
&lt;h3 id=&quot;网络包分析&quot;&gt;【网络包分析】&lt;/h3&gt;
&lt;p&gt;我们用wireshark来识别网络拥塞的准确时间点和原因。我们已经有了准确的报错时间点，先用editcap把超大的tcp包裁剪一下，裁成30秒间隔，并通过wireshark I/O 100ms间隔分析网络阻塞的准确时间点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1247138/201810/1247138-20181012104909783-1847776536.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 根据图标可以明显看到tcp的packets来往存在block。&lt;/p&gt;
&lt;p&gt; 对该block前后的网络包进行明细分析，网络包来往情况如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;  12:01:54.6536050  &lt;/td&gt;
&lt;td&gt;  Redis-Server  &lt;/td&gt;
&lt;td&gt;  Clients  &lt;/td&gt;
&lt;td&gt;  TCP:Flags=…AP…&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;  12:01:54.6538580  &lt;/td&gt;
&lt;td&gt;  Redis-Server  &lt;/td&gt;
&lt;td&gt;  Clients  &lt;/td&gt;
&lt;td&gt;  TCP:Flags=…AP…&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;  12:01:54.6539770  &lt;/td&gt;
&lt;td&gt;  Redis-Server  &lt;/td&gt;
&lt;td&gt;  Clients  &lt;/td&gt;
&lt;td&gt;  TCP:Flags=…AP…&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;  12:01:54.6720580  &lt;/td&gt;
&lt;td&gt;  Redis-Server  &lt;/td&gt;
&lt;td&gt;  Clients  &lt;/td&gt;
&lt;td&gt;  TCP:Flags=…A..S..&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;  12:01:54.6727200  &lt;/td&gt;
&lt;td&gt;  Redis-Server  &lt;/td&gt;
&lt;td&gt;  Clients  &lt;/td&gt;
&lt;td&gt;  TCP:Flags=…A……&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;  &lt;span&gt;12:01:54.6808480&lt;/span&gt;  &lt;/td&gt;
&lt;td&gt;  &lt;span&gt;Redis-Server&lt;/span&gt;  &lt;/td&gt;
&lt;td&gt;  &lt;span&gt;Clients&lt;/span&gt;  &lt;/td&gt;
&lt;td&gt;  &lt;span&gt;TCP:Flags=…AP…..&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;  12:01:54.6910840  &lt;/td&gt;
&lt;td&gt;  Redis-Server  &lt;/td&gt;
&lt;td&gt;  Clients  &lt;/td&gt;
&lt;td&gt;  TCP:Flags=…A…S.,&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;  12:01:54.6911950  &lt;/td&gt;
&lt;td&gt;  Redis-Server  &lt;/td&gt;
&lt;td&gt;  Clients  &lt;/td&gt;
&lt;td&gt;  TCP:Flags=…A……&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;  …   &lt;/td&gt;
&lt;td&gt;  …   &lt;/td&gt;
&lt;td&gt;   …   &lt;/td&gt;
&lt;td&gt;   …&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;  &lt;span&gt;12:01:56.1181350&lt;/span&gt;  &lt;/td&gt;
&lt;td&gt;  &lt;span&gt;Redis-Server&lt;/span&gt;  &lt;/td&gt;
&lt;td&gt;  &lt;span&gt;Clients&lt;/span&gt;  &lt;/td&gt;
&lt;td&gt;  &lt;span&gt;TCP:Flags=…AP….&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;12:01:54.6808480, Redis Server端向客户端发送了一个Push包，也就是对于查询请求的一个结果返回。后面的包都是在做连接处理，包括Ack包，Ack确认包，以及重置的RST包，紧接着下面一个Push包是在12:01:56.1181350发出的。中间的间隔是1.4372870秒。也就是说，在这1.4372870秒期间，Redis的服务器端，除了做一个查询，其他的操作都是在做建连，或拒绝连接。&lt;/p&gt;
&lt;p&gt;客户端报错的前后逻辑已经清楚了，redis-server卡了1.43秒，client的connection pool被打满，疯狂新建连接，server的accept queue满，直接拒绝服务，client报错。开始怀疑client发送了特殊命令，这时需要确认一下client的最后几个命令是什么，找到redis-server卡死前的第一个包，装一个wireshark的redis插件，看到最后几个命令是简单的get，并且key-value都很小，不至于需要耗费1.43秒才能完成。服务端也没有slow log，此时排障再次陷入僵局。&lt;/p&gt;
&lt;h3 id=&quot;进一步分析&quot;&gt;【进一步分析】&lt;/h3&gt;
&lt;p&gt;为了了解这1.43秒之内，Redis Server在做什么事情，我们用pstack来抓取信息。Pstack本质上是gdb attach. 高频率的抓取会影响redis的吞吐。死循环0.5秒一次无脑抓，在redis-server卡死的时候抓到堆栈如下(过滤了没用的栈信息)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu May 31 11:29:18 CST 2018
Thread 1 (Thread 0x7ff2db6de720 (LWP 8378)):
#0  0x000000000048cec4 in ?? ()
#1  0x00000000004914a4 in je_arena_ralloc ()
#2  0x00000000004836a1 in je_realloc ()
#3  0x0000000000422cc5 in zrealloc ()
#4  0x00000000004213d7 in sdsRemoveFreeSpace ()
&lt;span&gt;#5  0x000000000041ef3c in clientsCronResizeQueryBuffer ()&lt;/span&gt;
#6  0x00000000004205de in clientsCron ()
#7  0x0000000000420784 in serverCron ()
#8  0x0000000000418542 in aeProcessEvents ()
#9  0x000000000041873b in aeMain ()
#10 0x0000000000420fce in main ()
Thu May 31 11:29:19 CST 2018
Thread 1 (Thread 0x7ff2db6de720 (LWP 8378)):
#0  0x0000003729ee5407 in madvise () from /lib64/libc.so.6
#1  0x0000000000493a4e in je_pages_purge ()
#2  0x000000000048cf70 in ?? ()
#3  0x00000000004914a4 in je_arena_ralloc ()
#4  0x00000000004836a1 in je_realloc ()
#5  0x0000000000422cc5 in zrealloc ()
#6  0x00000000004213d7 in sdsRemoveFreeSpace ()
&lt;span&gt;#7  0x000000000041ef3c in clientsCronResizeQueryBuffer ()&lt;/span&gt;
#8  0x00000000004205de in clientsCron ()
#9  0x0000000000420784 in serverCron ()
#10 0x0000000000418542 in aeProcessEvents ()
#11 0x000000000041873b in aeMain ()
#12 0x0000000000420fce in main ()
Thu May 31 11:29:19 CST 2018
Thread 1 (Thread 0x7ff2db6de720 (LWP 8378)):
#0  0x000000000048108c in je_malloc_usable_size ()
#1  0x0000000000422be6 in zmalloc ()
#2  0x00000000004220bc in sdsnewlen ()
#3  0x000000000042c409 in createStringObject ()
#4  0x000000000042918e in processMultibulkBuffer ()
#5  0x0000000000429662 in processInputBuffer ()
#6  0x0000000000429762 in readQueryFromClient ()
#7  0x000000000041847c in aeProcessEvents ()
#8  0x000000000041873b in aeMain ()
#9  0x0000000000420fce in main ()
Thu May 31 11:29:20 CST 2018
Thread 1 (Thread 0x7ff2db6de720 (LWP 8378)):
#0  0x000000372a60e7cd in write () from /lib64/libpthread.so.0
#1  0x0000000000428833 in sendReplyToClient ()
#2  0x0000000000418435 in aeProcessEvents ()
#3  0x000000000041873b in aeMain ()
#4  0x0000000000420fce in main ()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重复多次抓取后，从堆栈中发现可疑堆栈clientsCronResizeQueryBuffer位置，属于serverCron()函数下，这个redis-server内部的定时调度，并不在用户线程下，这个解释了为什么卡死的时候没有出现慢查询。&lt;/p&gt;
&lt;p&gt;查看redis源码，确认到底redis-server在做什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;clientsCron(server.h):
#define CLIENTS_CRON_MIN_ITERATIONS 5
void clientsCron(void) {
    /* Make sure to process at least numclients/server.hz of clients
     * per call. Since this function is called server.hz times per second
     * we are sure that in the worst case we process all the clients in 1
     * second. */
    int numclients = listLength(server.clients);
    int iterations = numclients/server.hz;
    mstime_t now = mstime();

    /* Process at least a few clients while we are at it, even if we need
     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract
     * of processing each client once per second. */
    if (iterations &amp;lt; CLIENTS_CRON_MIN_ITERATIONS)
        iterations = (numclients &amp;lt; CLIENTS_CRON_MIN_ITERATIONS) ?
                     numclients : CLIENTS_CRON_MIN_ITERATIONS;

    while(listLength(server.clients) &amp;amp;&amp;amp; iterations--) {
        client *c;
        listNode *head;

        /* Rotate the list, take the current head, process.
         * This way if the client must be removed from the list it's the
         * first element and we don't incur into O(N) computation. */
        listRotate(server.clients);
        head = listFirst(server.clients);
        c = listNodeValue(head);
        /* The following functions do different service checks on the client.
         * The protocol is that they return non-zero if the client was
         * terminated. */
        if (clientsCronHandleTimeout(c,now)) continue;
        if (clientsCronResizeQueryBuffer(c)) continue;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;clientsCron首先判断当前client的数量，用于控制一次清理连接的数量，生产服务器单实例的连接数量在5000不到，也就是一次清理的连接数是50个。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;clientsCronResizeQueryBuffer(server.h):

/* The client query buffer is an sds.c string that can end with a lot of
 * free space not used, this function reclaims space if needed.
 *
 * The function always returns 0 as it never terminates the client. */
int clientsCronResizeQueryBuffer(client *c) {
    size_t querybuf_size = sdsAllocSize(c-&amp;gt;querybuf);
    time_t idletime = server.unixtime - c-&amp;gt;lastinteraction;

    /* 只在以下两种情况下会Resize query buffer:
     * 1) Query buffer &amp;gt; BIG_ARG(在server.h 中定义#define PROTO_MBULK_BIG_ARG     (1024*32)) 
           且这个Buffer的小于一段时间的客户端使用的峰值.
     * 2) 客户端空闲超过2s且Buffer size大于1k. */
    if (((querybuf_size &amp;gt; PROTO_MBULK_BIG_ARG) &amp;amp;&amp;amp;
         (querybuf_size/(c-&amp;gt;querybuf_peak+1)) &amp;gt; 2) ||
         (querybuf_size &amp;gt; 1024 &amp;amp;&amp;amp; idletime &amp;gt; 2))
    {
        /* Only resize the query buffer if it is actually wasting space. */
        if (sdsavail(c-&amp;gt;querybuf) &amp;gt; 1024) {
            c-&amp;gt;querybuf = sdsRemoveFreeSpace(c-&amp;gt;querybuf);
        }
    }
    /* Reset the peak again to capture the peak memory usage in the next
     * cycle. */
    c-&amp;gt;querybuf_peak = 0;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果redisClient对象的query buffer满足条件，那么就直接resize掉。满足条件的连接分成两种，一种是真的很大的，比该客户端一段时间内使用的峰值还大；还有一种是很闲（idle&amp;gt;2）的，这两种都要满足一个条件，就是buffer free的部分超过1k。那么redis-server卡住的原因就是正好有那么50个很大的或者空闲的并且free size超过了1k大小连接的同时循环做了resize，由于redis都属于单线程工作的程序，所以block了client。那么解决这个问题办法就很明朗了，让resize 的频率变低或者resize的执行速度变快。&lt;/p&gt;
&lt;p&gt;既然问题出在query buffer上，我们先看一下这个东西被修改的位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;readQueryFromClient（networking.c）:
redisClient *createClient(int fd) {
    redisClient *c = zmalloc(sizeof(redisClient));

    /* passing -1 as fd it is possible to create a non connected client.
     * This is useful since all the Redis commands needs to be executed
     * in the context of a client. When commands are executed in other
     * contexts (for instance a Lua script) we need a non connected client. */
    if (fd != -1) {
        anetNonBlock(NULL,fd);
        anetEnableTcpNoDelay(NULL,fd);
        if (server.tcpkeepalive)
            anetKeepAlive(NULL,fd,server.tcpkeepalive);
        if (aeCreateFileEvent(server.el,fd,AE_READABLE,
            readQueryFromClient, c) == AE_ERR)
        {
            close(fd);
            zfree(c);
            return NULL;
        }
    }

    selectDb(c,0);
    c-&amp;gt;id = server.next_client_id++;
    c-&amp;gt;fd = fd;
    c-&amp;gt;name = NULL;
    c-&amp;gt;bufpos = 0;
    &lt;span&gt;c-&amp;gt;querybuf = sdsempty();&lt;/span&gt; 初始化是0

readQueryFromClient(networking.c):
void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
    redisClient *c = (redisClient*) privdata;
    int nread, readlen;
    size_t qblen;
    REDIS_NOTUSED(el);
    REDIS_NOTUSED(mask);

    server.current_client = c;
    readlen = REDIS_IOBUF_LEN;
    /* If this is a multi bulk request, and we are processing a bulk reply
     * that is large enough, try to maximize the probability that the query
     * buffer contains exactly the SDS string representing the object, even
     * at the risk of requiring more read(2) calls. This way the function
     * processMultiBulkBuffer() can avoid copying buffers to create the
     * Redis Object representing the argument. */
    if (c-&amp;gt;reqtype == REDIS_REQ_MULTIBULK &amp;amp;&amp;amp; c-&amp;gt;multibulklen &amp;amp;&amp;amp; c-&amp;gt;bulklen != -1
        &amp;amp;&amp;amp; c-&amp;gt;bulklen &amp;gt;= REDIS_MBULK_BIG_ARG)
    {
        int remaining = (unsigned)(c-&amp;gt;bulklen+2)-sdslen(c-&amp;gt;querybuf);

        if (remaining &amp;lt; readlen) readlen = remaining;
    }

    qblen = sdslen(c-&amp;gt;querybuf);
    if (c-&amp;gt;querybuf_peak &amp;lt; qblen) c-&amp;gt;querybuf_peak = qblen;
    &lt;span&gt;c-&amp;gt;querybuf = sdsMakeRoomFor(c-&amp;gt;querybuf, readlen);&lt;/span&gt; 在这里会被扩大
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见c-&amp;gt;querybuf在连接第一次读取命令后的大小就会被分配至少1024*32，所以回过头再去看resize的清理逻辑就明显存在问题，每个被使用到的query buffer的大小至少就是1024*32，但是清理的时候判断条件是&amp;gt;1024，也就是说，所有的idle&amp;gt;2的被使用过的连接都会被resize掉，下次接收到请求的时候再重新分配到1024*32，这个其实是没有必要的，在访问比较频繁的群集，内存会被频繁得回收重分配，所以我们尝试将清理的判断条件改造为如下，就可以避免大部分没有必要的resize操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (((querybuf_size &amp;gt; REDIS_MBULK_BIG_ARG) &amp;amp;&amp;amp;
         (querybuf_size/(c-&amp;gt;querybuf_peak+1)) &amp;gt; 2) ||
         &lt;span&gt;(querybuf_size &amp;gt; 1024*32 &amp;amp;&amp;amp; idletime &amp;gt; 2))&lt;/span&gt;
    {
        /* Only resize the query buffer if it is actually wasting space. */
        if (sdsavail(c-&amp;gt;querybuf) &amp;gt; 1024*32) {
            c-&amp;gt;querybuf = sdsRemoveFreeSpace(c-&amp;gt;querybuf);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个改造的副作用是内存的开销，按照一个实例5k连接计算，5000*1024*32=160M，这点内存消耗对于上百G内存的服务器完全可以接受。&lt;/p&gt;
&lt;h2 id=&quot;问题重现&quot;&gt;【问题重现】&lt;/h2&gt;
&lt;p&gt;在使用修改过源码的Redis server后，问题仍然重现了，客户端还是会报同类型的错误，且报错的时候，服务器内存依然会出现抖动。抓取内存堆栈信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu Jun 14 21:56:54 CST 2018
#3  0x0000003729ee893d in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7f2dc108d720 (LWP 27851)):
#0  0x0000003729ee5400 in madvise () from /lib64/libc.so.6
#1  0x0000000000493a1e in je_pages_purge ()
&lt;span&gt;#2  0x000000000048cf40 in arena_purge ()&lt;/span&gt;
#3  0x00000000004a7dad in je_tcache_bin_flush_large ()
#4  0x00000000004a85e9 in je_tcache_event_hard ()
#5  0x000000000042c0b5 in decrRefCount ()
#6  0x000000000042744d in resetClient ()
#7  0x000000000042963b in processInputBuffer ()
#8  0x0000000000429762 in readQueryFromClient ()
#9  0x000000000041847c in aeProcessEvents ()
#10 0x000000000041873b in aeMain ()
#11 0x0000000000420fce in main ()
Thu Jun 14 21:56:54 CST 2018
Thread 1 (Thread 0x7f2dc108d720 (LWP 27851)):
#0  0x0000003729ee5400 in madvise () from /lib64/libc.so.6
#1  0x0000000000493a1e in je_pages_purge ()
&lt;span&gt;#2  0x000000000048cf40 in arena_purge ()&lt;/span&gt;
#3  0x00000000004a7dad in je_tcache_bin_flush_large ()
#4  0x00000000004a85e9 in je_tcache_event_hard ()
#5  0x000000000042c0b5 in decrRefCount ()
#6  0x000000000042744d in resetClient ()
#7  0x000000000042963b in processInputBuffer ()
#8  0x0000000000429762 in readQueryFromClient ()
#9  0x000000000041847c in aeProcessEvents ()
#10 0x000000000041873b in aeMain ()
#11 0x0000000000420fce in main ()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，Querybuffer被频繁resize的问题已经得到了优化，但是还是会出现客户端报错。这就又陷入了僵局。难道还有其他因素导致query buffer resize变慢？我们再次抓取pstack。但这时，jemalloc引起了我们的注意。此时回想Redis的内存分配机制，Redis为避免libc内存不被释放导致大量内存碎片的问题，默认使用的是jemalloc用作内存分配管理，这次报错的堆栈信息中都是je_pages_purge () redis在调用jemalloc回收脏页。我们看下jemalloc做了些什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;arena_purge(arena.c)
static void
arena_purge(arena_t *arena, bool all)
{
    arena_chunk_t *chunk;
    size_t npurgatory;
    if (config_debug) {
        size_t ndirty = 0;

        arena_chunk_dirty_iter(&amp;amp;arena-&amp;gt;chunks_dirty, NULL,
            chunks_dirty_iter_cb, (void *)&amp;amp;ndirty);
        assert(ndirty == arena-&amp;gt;ndirty);
    }
    assert(arena-&amp;gt;ndirty &amp;gt; arena-&amp;gt;npurgatory || all);
    assert((arena-&amp;gt;nactive &amp;gt;&amp;gt; opt_lg_dirty_mult) &amp;lt; (arena-&amp;gt;ndirty -
        arena-&amp;gt;npurgatory) || all);

    if (config_stats)
        arena-&amp;gt;stats.npurge++;
    npurgatory = arena_compute_npurgatory(arena, all);
    arena-&amp;gt;npurgatory += npurgatory;

    while (npurgatory &amp;gt; 0) {
        size_t npurgeable, npurged, nunpurged;

        /* Get next chunk with dirty pages. */
        chunk = arena_chunk_dirty_first(&amp;amp;arena-&amp;gt;chunks_dirty);
        if (chunk == NULL) {
            arena-&amp;gt;npurgatory -= npurgatory;
            return;
        }
        npurgeable = chunk-&amp;gt;ndirty;
        assert(npurgeable != 0);

        if (npurgeable &amp;gt; npurgatory &amp;amp;&amp;amp; chunk-&amp;gt;nruns_adjac == 0) {
    
            arena-&amp;gt;npurgatory += npurgeable - npurgatory;
            npurgatory = npurgeable;
        }
        arena-&amp;gt;npurgatory -= npurgeable;
        npurgatory -= npurgeable;
        npurged = arena_chunk_purge(arena, chunk, all);
        nunpurged = npurgeable - npurged;
        arena-&amp;gt;npurgatory += nunpurged;
        npurgatory += nunpurged;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Jemalloc每次回收都会判断所有实际应该清理的chunck并对清理做count，这个操作对于高响应要求的系统是很奢侈的，所以我们考虑通过升级jemalloc的版本来优化purge的性能。Redis 4.0版本发布后，性能有很大的改进，并可以通过命令回收内存，我们线上也正准备进行升级，跟随4.0发布的jemalloc版本为4.1，jemalloc的版本使用的在jemalloc的4.0之后版本的arena_purge()做了很多优化，去掉了计数器的调用，简化了很多判断逻辑，增加了arena_stash_dirty()方法合并了之前的计算和判断逻辑，增加了purge_runs_sentinel，用保持脏块在每个arena LRU中的方式替代之前的保持脏块在arena树的dirty-run-containing chunck中的方式，大幅度减少了脏块purge的体积，并且在内存回收过程中不再移动内存块。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;arena_purge(arena.c)
static void
arena_purge(arena_t *arena, bool all)
{
    chunk_hooks_t chunk_hooks = chunk_hooks_get(arena);
    size_t npurge, npurgeable, npurged;
    arena_runs_dirty_link_t purge_runs_sentinel;
    extent_node_t purge_chunks_sentinel;

    arena-&amp;gt;purging = true;

    /*
     * Calls to arena_dirty_count() are disabled even for debug builds
     * because overhead grows nonlinearly as memory usage increases.
     */
    if (false &amp;amp;&amp;amp; config_debug) {
        size_t ndirty = arena_dirty_count(arena);
        assert(ndirty == arena-&amp;gt;ndirty);
    }
    assert((arena-&amp;gt;nactive &amp;gt;&amp;gt; arena-&amp;gt;lg_dirty_mult) &amp;lt; arena-&amp;gt;ndirty || all);

    if (config_stats)
        arena-&amp;gt;stats.npurge++;

    npurge = arena_compute_npurge(arena, all);
    qr_new(&amp;amp;purge_runs_sentinel, rd_link);
    extent_node_dirty_linkage_init(&amp;amp;purge_chunks_sentinel);

    npurgeable = arena_stash_dirty(arena, &amp;amp;chunk_hooks, all, npurge,
        &amp;amp;purge_runs_sentinel, &amp;amp;purge_chunks_sentinel);
    assert(npurgeable &amp;gt;= npurge);
    npurged = arena_purge_stashed(arena, &amp;amp;chunk_hooks, &amp;amp;purge_runs_sentinel,
        &amp;amp;purge_chunks_sentinel);
    assert(npurged == npurgeable);
    arena_unstash_purged(arena, &amp;amp;chunk_hooks, &amp;amp;purge_runs_sentinel,
        &amp;amp;purge_chunks_sentinel);

    arena-&amp;gt;purging = false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解决问题&quot;&gt;【解决问题】&lt;/h2&gt;
&lt;p&gt;实际上我们有多个选项。可以使用Google的tcmalloc来代替jemalloc，可以升级jemalloc的版本等等。我们根据上面的分析，尝试通过升级jemalloc版本，实际操作为升级Redis版本来解决。我们将Redis的版本升级到4.0.9之后观察，线上客户端连接超时这个棘手的问题得到了解决。&lt;/p&gt;
&lt;h2 id=&quot;问题总结&quot;&gt;【问题总结】&lt;/h2&gt;
&lt;p&gt;Redis在生产环境中因其支持高并发，响应快，易操作被广泛使用，对于运维人员而言，其响应时间的要求带来了各种各样的问题，Redis的连接超时问题是其中比较典型的一种，从发现问题，客户端连接超时，到通过抓取客户端与服务端的网络包，内存堆栈定位问题，也被其中一些假象所迷惑，最终通过升级jemalloc（Redis）的版本解决问题，这次最值得总结和借鉴的是整个分析的思路。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 06:50:00 +0000</pubDate>
<dc:creator>携程DBA</dc:creator>
<og:description>【作者】 张延俊：携程技术保障中心资深DBA，对数据库架构和疑难问题分析排查有浓厚的兴趣。 寿向晨：携程技术保障中心高级DBA，主要负责携程Redis及DB的运维工作，在自动化运维，流程化及监控排障等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CtripDBA/p/9776466.html</dc:identifier>
</item>
<item>
<title>显微镜下的webpack4入门 - cherryvsun</title>
<link>http://www.cnblogs.com/cherryvenus/p/9778009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherryvenus/p/9778009.html</guid>
<description>&lt;p&gt;前端的构建打包工具很多，比如grunt，gulp。相信这两者大家应该是耳熟能详的，上手相对简单，而且所需手敲的代码都是比较简单的。然后webpack的出现，让这两者打包工具都有点失宠了。webpack比起前两者打包工具，对于前端程序员JS编程能力的要求还是挺高的。不过需要兼容ie8及以下的小伙伴们，就不要考虑webpack了，他很傲娇地不兼容！&lt;/p&gt;
&lt;h2 id=&quot;webpack-前期准备&quot;&gt;webpack 前期准备&lt;/h2&gt;
&lt;p&gt;webpack，这是一个组合词“web”+“pack”，web就是网站的意思，“pack”有打包的意思，webpack组合在一起就是网站打包的意思，这个名字相当暴力简单明了啊。webpack这款工具虽然很难学，但是自由度很大，玩转之后有种随心所欲的感觉。&lt;/p&gt;
&lt;p&gt;在学习webpack之前，有几个基础的概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JavaScript，如果这个编程能力不过关，比如不清楚ES6的语法，那么webpack学起来有些费力，还是要先去学习基础知识。&lt;/li&gt;
&lt;li&gt;nodejs，关于nodejs的日常用法，还是需要了解的，不然webpack改如何启动，都无从下手。&lt;/li&gt;
&lt;li&gt;CommonJS，这个规范是需要学习下的，webpack的配置文件就是按照这个规则。&lt;/li&gt;
&lt;li&gt;如果以上几个技能都具备，那么恭喜我们可以开始webpack的学（求）习（虐）之旅了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;webpack-打包原理&quot;&gt;webpack 打包原理&lt;/h2&gt;
&lt;p&gt;在使用webpack之前，我们需要了解webpack的工作原理。webpack打包出来的JS不仅仅是压缩混淆我们的源文件，而且还对它做了其他的处理。&lt;/p&gt;
&lt;p&gt;下面是webpack打包出来的JS文件和源文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;./src/index.js&quot;&lt;/code&gt;源文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;let str=&quot;index&quot;
console.log(str)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack打包后&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;(function(modules) { // webpackBootstrap
    /*此处省略N+1行*/
    return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);
})
({
    &quot;./src/index.js&quot;:(function(module, exports) {
        eval(&quot;let str=\&quot;index\&quot;\r\nconsole.log(str)\n\n//# sourceURL=webpack:///./src/index.js?&quot;);
    })
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是感觉本来小巧的JS，一下子变得臃肿了？？似乎用webpack没有意义啊！不仅不能忙我压缩文件，还把源文件变胖了。&lt;/p&gt;
&lt;p&gt;不要急，我们再看一个例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;./src/index.js&quot;&lt;/code&gt;源文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;require(&quot;./page1.js&quot;)
let str=&quot;index&quot;
console.log(str)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;./src/page1.js&quot;&lt;/code&gt;源文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;let str=&quot;page1&quot;
console.log(str)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack打包后&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;(function(modules) { // webpackBootstrap
    /*此处省略N+1行*/
    return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);
})
({
    &quot;./src/index.js&quot;: (function(module, exports, __webpack_require__) {
        eval(&quot;__webpack_require__(/*! ./page1.js */ \&quot;./src/page1.js\&quot;)\r\nlet str=\&quot;index\&quot;\r\nconsole.log(str)\n\n//# sourceURL=webpack:///./src/index.js?&quot;);
    }),
    &quot;./src/page1.js&quot;:(function(module, exports) {
        eval(&quot;let str=\&quot;page1\&quot;\r\nconsole.log(str)\n\n//# sourceURL=webpack:///./src/page1.js?&quot;);
    })
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当有模块导入的时候，这个胖JS就展现了他真正的实力。通过&lt;code&gt;__webpack_require__&lt;/code&gt;来实现JS之间导入的功能。相当于我们不再需要用requirejs，seajs此类包管理器管理我们的前端模块了。webpack帮助我们完成了此类工作。是不是突然觉得这个胖JS不胖了。&lt;/p&gt;
&lt;p&gt;webpack的打包原理，就是将各个模块变成字符串，存入健值或者数组之中，然后每个模块之间的关系，通过&lt;code&gt;__webpack_require__&lt;/code&gt;这个方法来实现。最后通过&lt;code&gt;eval&lt;/code&gt;这个函数将字符串变成可执行代码。&lt;/p&gt;
&lt;p&gt;如果大家对&lt;code&gt;__webpack_require__&lt;/code&gt;的实现原理感兴趣，可以自己打包一个文件，不要压缩混淆，然后研究研究。&lt;/p&gt;
&lt;h2 id=&quot;对webpack的期许&quot;&gt;对webpack的期许&lt;/h2&gt;
&lt;p&gt;webpack这个工具，不可能只有打包压缩这个功能吧。既然是前端工具，那么必然要具备以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码处理，如打包，编译等&lt;/li&gt;
&lt;li&gt;自动生成HTML文件，比如模板生成页面&lt;/li&gt;
&lt;li&gt;本地服务器，这个是必备功能，不然无法调试页面&lt;/li&gt;
&lt;li&gt;自动编译代码，刷新浏览器，这个大家喜欢称之为hot replacement（热替换，热更新），也就是（修改过的）部分更新&lt;/li&gt;
&lt;li&gt;那我们逐步来了解下webpack这些功能该如何实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;webpack从0开始&quot;&gt;webpack从0开始&lt;/h2&gt;
&lt;p&gt;如果你之前并未使用过webpack，那么就需要安装一下webpack，顺便学习下如何启动webpack。&lt;/p&gt;
&lt;h3 id=&quot;step-1-install&quot;&gt;STEP 1 INSTALL&lt;/h3&gt;
&lt;p&gt;webpack从4开始，webpack分成了两个包一个webpack一个webpack-cli，所以安装的时候要安装两个包，以及这个包我们是工具，非网站所依赖的包，所以记得放在开发依赖包之中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install webpack webpack-cli -save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也许我们想可以直接安装webpack，不要webpack-cli。但是现实很残酷，如果没有安装CLI，系统就会告诉你，cli是必不可少的，不然webpack就罢工了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;One CLI for webpack must be installed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;step2-run&quot;&gt;STEP2 RUN&lt;/h3&gt;
&lt;p&gt;安装好了之后，我们应该怎么运行呢？这里有两个途径：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;npm v8.5以上有一个操作叫做&lt;code&gt;npx&lt;/code&gt;，这个是干嘛的呢，是帮忙我们直接执行.bin，目录下的文件。&lt;code&gt;node_modules\.bin\webpack.cmd&lt;/code&gt;在这个路径下有webpack的执行命令，我们可以打开看看。当我们&lt;code&gt;npx webpack&lt;/code&gt;的时候，就是运行了这个文件。&lt;/li&gt;
&lt;li&gt;通过配置&lt;code&gt;package.json&lt;/code&gt;来运行文件，有个字段叫做&lt;code&gt;scripts&lt;/code&gt;，我们加一个&lt;code&gt;start&lt;/code&gt;，然后后面跟上命令。到时候我们呼唤&lt;code&gt;npm start&lt;/code&gt;就要可以运行webpack了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack --config webpack.config.js&quot;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;webpack4开始支持零配置，也就是说我不用写&lt;code&gt;webpack.config.js&lt;/code&gt;也可以运行。那我们就运行试试，结果出现了一个警告：&lt;/p&gt;
&lt;blockquote readability=&quot;7.9561128526646&quot;&gt;
&lt;p&gt;WARNING in configuration&lt;br/&gt;The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.&lt;br/&gt;You can also set it to 'none' to disable any default behavior. Learn more: &lt;a href=&quot;https://webpack.js.org/concepts/mode/&quot; class=&quot;uri&quot;&gt;https://webpack.js.org/concepts/mode/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个警告就是告诉我们，webpack4中的&lt;code&gt;mode&lt;/code&gt;参数默认是&lt;code&gt;production&lt;/code&gt;，所以如果是&lt;code&gt;development&lt;/code&gt;的情况就一定要配置了。感觉是零配置似乎是非常牛逼的一个操作，但是实际上还是需要手动配置的，因为这个零配置只是帮我们做掉了一些简单的事，比如线上就压缩JS，开发版就不压缩JS，还有一些默认的路径之类的。实际上开发的时候，默认的路径肯定是不够用的。我们还是老老实实写配置吧。&lt;/p&gt;
&lt;p&gt;我们配置一下，并且运行一下，在开发环境下打包，生成了一个&lt;code&gt;/dist/main.js&lt;/code&gt;文件。奇怪我的html文件怎么没有打包过来？对，HTML文件需要我们自己在dist之中创建的，也就是&lt;code&gt;/dist/index.html&lt;/code&gt;。并且路径要写好即将生成的JS链接。比如&lt;code&gt;/dist/main.js&lt;/code&gt;在html中引入，我就需要写成&lt;code&gt;&amp;lt;script src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
    mode:&quot;development&quot;,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个配置文件，大家都没有觉得写法很熟悉？对！就是CommonJs规范！下一节会详细解释&lt;code&gt;webpack.config.js&lt;/code&gt;该如何配置。&lt;/p&gt;
&lt;h2 id=&quot;webpack的心脏webpack.config.js&quot;&gt;webpack的心脏——webpack.config.js&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596424/201810/596424-20181012143301756-1147739831.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;webpack的一切操作都配置在&lt;code&gt;webpack.config.js&lt;/code&gt;之中，可以说配好&lt;code&gt;webpack.config.js&lt;/code&gt;，我们就可以坐等新鲜出炉的网站了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.js.org/concepts/&quot;&gt;从官方文档来看，webpack一共有5个主要地配置参数&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Entry：切入点，也就是JS程序入口，按照这个入口开始创建模块依赖，默认&lt;code&gt;./src/index.js&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Output：输出口，打包程序的安放位置，默认&lt;code&gt;./dist/main.js&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Loaders：加载器，将除了JS和JSON以外的文件解析加载，比如txt，css等等。&lt;/li&gt;
&lt;li&gt;Plugins：插件，可以做一些更加牛逼的效果，一般要new一个插件对象。&lt;/li&gt;
&lt;li&gt;Mode（新增）：&lt;code&gt;production&lt;/code&gt;和&lt;code&gt;development&lt;/code&gt;，这个是webpack4新增的一个属性，用于区分开发版与线上版，也是很贴心的设置了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;entryoutput以及chunk的概念&quot;&gt;Entry&amp;amp;Output，以及chunk的概念&lt;/h3&gt;
&lt;p&gt;在学些webpack的配置之前，我们最先接触的就是输入Entry和输出Output的配置。这里需要引入一个chunk的概念，我们在配置Entry的时候，有时候会设置好多个入口，这每一个入口都是一个chunk，也就是说chunk是根据Entry的配置而来的。大家一定要区分清楚chunk和module的概念啊。module就是编程的时候，我们所写的一块一块的功能块，然后模块之间会有依赖。然后chunk只是将当前模块和他的依赖模块，一起打包起来的代码块。&lt;/p&gt;
&lt;p&gt;配置Entry，切入点JS入口也不是件容易的事。&lt;/p&gt;
&lt;h4 id=&quot;entry配置&quot;&gt;Entry配置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单一入口，单个文件。整个程序只有一个JS，这个配置就很简单了，我么也可以不配置，因为默认&lt;code&gt;./src/index.js&lt;/code&gt;。单个文件之间传入字符串即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;entry: '需要打包的JS的相对或者绝对地址'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;单一入口，多个文件。有时候我们有好多独立的JS文件，但是我只想导出一个JS，这个时候就需要传入数组了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;entry: [&quot;待打包JS-1&quot;,&quot;待打包JS-2&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;多个入口，单个文件。这个时候我们就要配置健值了，都是默认值，怎么识别谁是谁。一般来说一个HTML只需要一个chunk，也就是一个入口点。所以这个一般用于多张页面的配置。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;entry: {
    JS1: &quot;待打包JS-1&quot;,
    JS2: &quot;待打包JS-2&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;多个入口，多个文件。前面提到一个HTML只需要一个入口点，所以这里我们可以借鉴数组来完成此操作。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;entry: {
    JS1: [&quot;待打包JS1-1&quot;,&quot;待打包JS1-2&quot;],
    JS2: [&quot;待打包JS2-1&quot;,&quot;待打包JS2-2&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;output配置&quot;&gt;Output配置&lt;/h4&gt;
&lt;p&gt;输出口，安放打包好的JS，不配置就打包到默认文件，默认&lt;code&gt;./dist/main.js&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不需要分入口点，整个网站用一个JS。那么配置一个文件名就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;output: {
    filename: 'bundle.js',
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要指定文件夹的操作，就再加一个path字段即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;output: {
    filename: 'bundle.js',
    path: __dirname + '/dist'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而现实中，我们不可能只有一个JS，所以这个时候我们就需要配置多个输出口，不过这个不像entry可以配置健值。但是有一个很简便的办法&lt;code&gt;filename: '[name].js'&lt;/code&gt;，文件名我们用&lt;code&gt;[name]&lt;/code&gt;，这样打包出来的Js文件就会按照Entry配置的chunk名，来命名了。&lt;/p&gt;
&lt;p&gt;当然我们经常回碰到CDN的问题，一个JS会被缓住，这时候我们可以用&lt;code&gt;[hash]&lt;/code&gt;这个参数，来帮我们&lt;code&gt;filename: '[name].[hash].js'&lt;/code&gt;这样每次生成的JS名就不一样了。&lt;/p&gt;
&lt;h3 id=&quot;loader模块的概念&quot;&gt;LOADER，模块的概念&lt;/h3&gt;
&lt;p&gt;在webpack中，任何文件都可以变成一个模块，然后被打包到JS之中。但是JS只认识JS，像CSS，或者typescript这类的非标准JS，该如何处理？这个时候Loader就出现了，他帮助webpack将CSS此类文件变成JS可识别的内容然后打包。所有的loader都需要额外下载安装，这里以最常用的CSS为例子，看我们如何将CSS打包到JS之中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装css-loader这个加载器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;npm install --save-dev css-loader&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于css-loader的用法，大家可以参考下&lt;a href=&quot;https://github.com/webpack-contrib/css-loader&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在webpack中配置。大家不要把loader的配置名写成了loader，他的在webpack中的配置名是&lt;code&gt;module.rule&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;module: {
    rules: [
        {
          test: /\.css$/,
          use: [
            { loader: 'style-loader'},
            { loader: 'css-loader',options: {modules: true}}
          ]
        }
      ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;添加style-loader&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说loader所有的配置都在rules之下。这里我还配置了style-loader，那么我们既然又了css-loader为什么还要style-loader呢？感觉很累赘啊。那么接下来就要说说这两个loader的不同了。&lt;/p&gt;
&lt;p&gt;打开styleloader的&lt;a href=&quot;https://github.com/webpack-contrib/style-loader&quot;&gt;官网&lt;/a&gt;，我们可以发现:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Adds CSS to the DOM by injecting a&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 12 Oct 2018 06:33:00 +0000</pubDate>
<dc:creator>cherryvsun</dc:creator>
<og:description>前端的构建打包工具很多，比如grunt，gulp。相信这两者大家应该是耳熟能详的，上手相对简单，而且所需手敲的代码都是比较简单的。然后webpack的出现，让这两者打包工具都有点失宠了。webpack</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cherryvenus/p/9778009.html</dc:identifier>
</item>
<item>
<title>【详解JavaScript系列】JavaScript之流程语句 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/9774189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/9774189.html</guid>
<description>&lt;p&gt;&lt;span&gt;一 开篇概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本讲主要讲解JavaScript流程语句，其大致内容包括如下：&lt;/p&gt;
&lt;p&gt;其中，常用的if,while,do..while,for在本片文章就不论述，重点论述for..in..,label,break和continue,whth，switch等语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201810/1066923-20181012145714438-571791846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二 内容区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;（一）常用语句&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于如下语句比较通用，本篇文章就不再论述&lt;/p&gt;
&lt;p&gt;1.条件语句&lt;/p&gt;
&lt;p&gt;if&lt;/p&gt;
&lt;p&gt;2.循环语句&lt;/p&gt;
&lt;p&gt;while,do..while,for&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）  for..in..语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.定义&lt;/p&gt;
&lt;p&gt;for...in...，是一种迭代语句，用来枚举对象的属性，其语法定义为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (propName &lt;span&gt;in&lt;/span&gt; expression) statement
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于在JavaScript开发中&quot;能使用局部变量，就不要使用全局变量&quot;原则， 建议将propName属性定义为局部变量，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; propName &lt;span&gt;in&lt;/span&gt; expression) statement
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.注意点&lt;/p&gt;
&lt;p&gt;(1)for....in是用来枚举对象属性的，而不是枚举对象属性值。&lt;/p&gt;
&lt;p&gt;例子1：&lt;/p&gt;
&lt;p&gt;如下例子，for..in..输出的是数组索引(即数组属性)，而不是数组索引值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; i = 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; arr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; n = 0; n &amp;lt; i; n++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         arr[n] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; propName &lt;span&gt;in&lt;/span&gt;&lt;span&gt; arr) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         alert(propName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0,1,2,3,4&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子2：&lt;/p&gt;
&lt;p&gt;如下例子，for..in..输出的是对象userInfo的属性(name,age,address)，而不属性值(Alan_beijing,38,china-shanghai)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; userInfo = { name: 'Alan_beijing', age: 38, address: 'china-shanghai'&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; property &lt;span&gt;in&lt;/span&gt;&lt;span&gt; userInfo) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         alert(property);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name,age,address&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)for..in..枚举属性，没有确定的顺序，不同的浏览器，会有所差别。&lt;/p&gt;
&lt;p&gt;(3)ECMAScript5版本之前，如果被迭代对象变量值null或undefined,for语句会抛出错误，ECMAScript5之后，这种情况不会抛出错误，但不执行循环体。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三） label&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1.定义&lt;/p&gt;
&lt;p&gt;在JavaScript中，label语句表示标签语句，通常与循环语句使用，表示循环语句跳转到指定位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; label:statement
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例1：&lt;/p&gt;
&lt;p&gt;如下代码包含一个label语句outermost,其内容为两个嵌套的循环体，当循环体执行到1==5且j==5时，break语句将跳转到outermost语句继续执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; num = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    outermost:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; 10; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (i == 5 &amp;amp;&amp;amp; j == 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt; outermost;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             num++
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     alert(num);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（四） break和continue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1.定义&lt;/p&gt;
&lt;p&gt;break和continue都表示在循环体中，根据特定的条件退出循环体，但两者又存在区别，break表示退出整个循环体，continue表示退出满足条件的该次循环体。&lt;/p&gt;
&lt;p&gt;例子1：&lt;/p&gt;
&lt;p&gt;如下代码，当执行i=5时，就退出整个循环体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; num = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i % 5 == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         num++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     alert(num);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子2：&lt;/p&gt;
&lt;p&gt;如下代码，当执行i=5时，退出本次循环，然后返回for语句开头，继续执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; num = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i % 5 == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         num++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     alert(num);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.注意点&lt;/p&gt;
&lt;p&gt;(1)break和continue跳出循环体时，表示只跳出直接所在循环体，而不是除了直接循环体外的其他循环体。&lt;/p&gt;
&lt;p&gt;例子1：&lt;/p&gt;
&lt;p&gt;如下例子，break只跳出直接循环体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201810/1066923-20181012111827959-227276312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子2：&lt;/p&gt;
&lt;p&gt;如下例子，continue只跳出直接循环体&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; num = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; 10; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (i == 5 &amp;amp;&amp;amp; j == 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             num++
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     alert(num);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;99&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.break和continue一般结合标签语句运用，表示跳转到指定位置 &lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;如下代码，当执行到i=5 &amp;amp;&amp;amp; j==5时，就跳到标签语句outermost处，继续执行。这里需要注意的是，JavaScrip没有块级作用域，因此在for语句外部是能够访问变量i的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; num = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    outermost:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; 10; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (i == 5 &amp;amp;&amp;amp; j == 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt; outermost;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             num++
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     alert(num);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（五） with&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1.定义&lt;/p&gt;
&lt;p&gt;with语句将代码作用域设定到特定对象中，其主要目的是简化多次编写同一对象，提高复用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; (expression) statement
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;如下代码定义了一个获取用户信息函数，在函数体内new了一个person对象，且定义两个属性(name和address)，然后将person对象with起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetUserInfo() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         person.name = &quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         person.address = &quot;China-shanghai&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;with&lt;/span&gt;&lt;span&gt; (person) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; name +&quot;,&quot;+&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     alert(GetUserInfo());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Alan_beijing,China-shanghai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.注意点&lt;/p&gt;
&lt;p&gt;(1)在JavaScript开发中，慎用with语句，主要原因有二：其一是with语句影响性能；其二是with语句在严格模式下，会出错&lt;/p&gt;
&lt;p&gt;(2)with语句将公有对象括起来，从而提高代码简洁度和提高代码复用性&lt;/p&gt;
&lt;p&gt;(3)在执行with语句体内查找变量时，先看with体内是否存在所查找变量，若不存在，再查找with括起来的变量是否有要查找的属性。&lt;/p&gt;
&lt;p&gt;如下例子更好地体现这一原则：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetUserInfo() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         person.name = &quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         person.address = &quot;China-shanghai&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         person.age = 35&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;with&lt;/span&gt;&lt;span&gt; (person) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sex = &quot;男&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; age = 40&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; name + &quot;,&quot; + sex + &quot;,&quot; + age +&quot;,&quot;+&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     alert(GetUserInfo());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Alan_beijing,男,40,China-shanghai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（六）  switch&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.定义&lt;/p&gt;
&lt;p&gt;switch语句就是我们平时所说的开关语句，它非常适用于多条件情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (expression) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; value: statement
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; value: statement
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:statement
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;如下代码，根据城市名称，查询城市类别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据不同城市，判断其属于几线城市&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; CityType(address) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (address) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; &quot;Shanghai&quot;: alert(&quot;中国一线城市&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; &quot;Shenzhen&quot;: alert(&quot;中国一线城市&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; &quot;Beijing&quot;: alert(&quot;中国一线城市&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;: alert(&quot;中国非一线城市&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     CityType(&quot;Shenzhen&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中国一线城市&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2 注意点&lt;/p&gt;
&lt;p&gt;(1)switch本质与if是一样的，都是解决多条件多分支问题；&lt;/p&gt;
&lt;p&gt;(2)使用switch语句的真正目的是避免使用过多的if..else if ...else....语句；&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 三  总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本篇文章主要结合代码介绍了JavaScript的流程语句及其使用，重点结束了with,switch，for...in..,label,break和continue等语句，&lt;span&gt;需要注意的是，在JavaScript中，流程语句都没有块级作用域，至于什么是块级作用域，将在接下来的文章中与大家分享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四   已发布文章&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【01】&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl14_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/wangjiming/p/9774189.html&quot;&gt;JavaScript之流程语句&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【02】&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl14_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/wangjiming/p/9656942.html&quot;&gt;JavaScript之函数(一)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 12 Oct 2018 06:02:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>一 开篇概述 本讲主要讲解JavaScript流程语句，其大致内容包括如下： 其中，常用的if,while,do..while,for在本片文章就不论述，重点论述for..in..,label,bre</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/9774189.html</dc:identifier>
</item>
</channel>
</rss>