<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java I/O流输入输出，序列化，NIO，NIO.2 - 谁将新樽辞旧月，今月曾经照古人</title>
<link>http://www.cnblogs.com/jiangwz/p/9193776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangwz/p/9193776.html</guid>
<description>
&lt;h2&gt;File类：&lt;/h2&gt;
&lt;p&gt;File类是java.io包下代表和平台无关的文件和目录，File不能访问文件内容本身。&lt;/p&gt;
&lt;p&gt;File类基本操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        System.out.println(&quot;判断文件是否存在：&quot;+file.exists());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断文件是否存在，返回Boolean值&lt;/span&gt;
        System.out.println(&quot;创建文件夹：&quot;+file.mkdir());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件夹，只能创建一层，返回Boolean值&lt;/span&gt;
        System.out.println(&quot;文件目录：&quot;+file.getParent());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回文件最后一级子目录&lt;/span&gt;
        System.out.println(&quot;创建文件夹：&quot;+file2.mkdirs());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件夹，创建多层，返回Boolean值&lt;/span&gt;
        System.out.println(&quot;创建新文件：&quot;+file3.createNewFile());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建新文件，此处需处理异常，返回Boolean值&lt;/span&gt;
        System.out.println(&quot;删除文件：&quot;+file3.delete());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除文件，返回Boolean值&lt;/span&gt;&lt;span&gt;
        System.out.println(&lt;/span&gt;&quot;文件改名：&quot;+file.renameTo(file4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件改名，传入另一个文件&lt;/span&gt;
        System.out.println(&quot;文件名：&quot;+file.getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回名&lt;/span&gt;
        System.out.println(&quot;文件路径：&quot;+file.getPath());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回文件路径&lt;/span&gt;
        System.out.println(&quot;绝对路径：&quot;+file.getAbsolutePath());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回绝对路径&lt;/span&gt;
        System.out.println(&quot;文件夹：&quot;+file.isDirectory());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回是否文件夹&lt;/span&gt;
        System.out.println(&quot;是否文件：&quot;+file.isFile());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回是否文件&lt;/span&gt;
        System.out.println(&quot;是否文件夹：&quot;+file.isDirectory());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回是否文件夹&lt;/span&gt;
        System.out.println(&quot;是否绝对路径：&quot;+file.isAbsolute());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回是否绝对路径&lt;/span&gt;
        System.out.println(&quot;文件长度：&quot;+file.length());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回文件长度&lt;/span&gt;
        System.out.println(&quot;最后修改时间：&quot;+file.lastModified());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回最后修改时间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180617211847717-1431398195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以当前路径来创建一个File对象&lt;/span&gt;
        File file = &lt;span&gt;new&lt;/span&gt; File(&quot;.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接获取文件名，输出一点&lt;/span&gt;
&lt;span&gt;        System.out.println(file.getName());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取相对路径的父路径可能出错，下面代码输出null&lt;/span&gt;
&lt;span&gt;        System.out.println(file.getParent());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取绝对路径&lt;/span&gt;
&lt;span&gt;        System.out.println(file.getAbsoluteFile());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取上一级路径&lt;/span&gt;
&lt;span&gt;        System.out.println(file.getAbsoluteFile().getParent());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在当前路径下创建一个临时文件&lt;/span&gt;
        File tmpFile = File.createTempFile(&quot;aaa&quot;, &quot;.txt&quot;&lt;span&gt;, file);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定当JVM退出时删除该文件&lt;/span&gt;
&lt;span&gt;        tmpFile.deleteOnExit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以系统当前时间作为新文件名来创建新文件&lt;/span&gt;
        File newFile = &lt;span&gt;new&lt;/span&gt; File(System.currentTimeMillis() + &quot;&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;newFile对象是否存在：&quot; +&lt;span&gt; newFile.exists());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以指定newFile对象来创建一个文件&lt;/span&gt;
&lt;span&gt;        newFile.createNewFile();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以newFile对象来创建一个目录，因为newFile已经存在，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以下面方法返回false，即无法创建该目录&lt;/span&gt;
&lt;span&gt;        newFile.mkdir();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用list()方法来列出当前路径下的所有文件和路径&lt;/span&gt;
        String[] fileList =&lt;span&gt; file.list();
        System.out.println(&lt;/span&gt;&quot;====当前路径下所有文件和路径如下====&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String fileName : fileList)
        {
            System.out.println(fileName);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; listRoots()静态方法列出所有的磁盘根路径。&lt;/span&gt;
        File[] roots =&lt;span&gt; File.listRoots();
        System.out.println(&lt;/span&gt;&quot;====系统所有根路径如下====&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File root : roots)
        {
            System.out.println(root);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180617212250752-1928559836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件过滤器：&lt;/p&gt;
&lt;p&gt;File类的list()方法中可以接受一个FilenameFilter参数，通过该参数可以只列出符合条件的文件。FilenameFilter接口里包含了一个accept(**)方法，该方法将一次对指定File的所有子目录或者文件进行迭代，如果该方法返回true，则list()方法会列出该子目录或者文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　　　 File file = &lt;span&gt;new&lt;/span&gt; File(&quot;.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Lambda表达式（目标类型为FilenameFilter）实现文件过滤器。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果文件名以.java结尾，或者文件对应一个路径，返回true&lt;/span&gt;
        String[] nameList = file.list((dir, name) -&amp;gt; name.endsWith(&quot;.java&quot;&lt;span&gt;)
            &lt;/span&gt;|| &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(name).isDirectory());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String name : nameList)
        {
            System.out.println(name);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180617213007435-312072965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FilenameFilter接口内只有一个抽象方法，因此改接口也是一个函数式接口，可使用Lambda表达式创建实现该接口的对象。&lt;/p&gt;
&lt;h2&gt;Java的IO流概念&lt;/h2&gt;
&lt;p&gt;Java的IO流是实现输入输出的基础，在Java中把不同的输入输出源抽象表述为流，通过流的方式允许Java使用相同的方式来访问不同的输入输出源。&lt;/p&gt;
&lt;p&gt;stream是从起源(source)到接收(sink)的有序数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180617213522036-582099937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;IO（in / out）流的分类&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;流向：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　输入流  读取数据&lt;/p&gt;
&lt;p&gt;　　　　输出流  写出数据&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;数据类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　字节流&lt;/p&gt;
&lt;p&gt;　　　　一个字节占8位, 以一个字节为单位读数据　　&lt;/p&gt;
&lt;p&gt;　　　　八大数据类型所占字节数:&lt;br/&gt;　　　　byte(1), short(2), int(4), long(8),float(4), double(8),boolean(1),char(2)&lt;/p&gt;
&lt;p&gt;　　　　　　字节输入流  读取数据　　InputStream&lt;/p&gt;
&lt;p&gt;                     &lt;img src=&quot;https://images2017.cnblogs.com/blog/1176316/201707/1176316-20170731202207474-1030752605.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　字节输出流  写出数据　　OutputStream&lt;/p&gt;
&lt;p&gt;                     &lt;img src=&quot;https://images2017.cnblogs.com/blog/1176316/201707/1176316-20170731202223396-1039896213.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　字符流&lt;/p&gt;
&lt;p&gt;　　　　一个字符占两个字节, 以一个字符为一个单位&lt;/p&gt;
&lt;p&gt;　　　　　　字符输入流  读取数据　　Reader&lt;/p&gt;
&lt;p&gt;                    &lt;img src=&quot;https://images2017.cnblogs.com/blog/1176316/201707/1176316-20170731202245443-825282440.gif&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　字符输出流  写出数据　　Writer&lt;/p&gt;
&lt;p&gt;                    &lt;img src=&quot;https://images2017.cnblogs.com/blog/1176316/201707/1176316-20170731203557630-1831239121.gif&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;

&lt;p&gt;字节流的基本抽象类&lt;/p&gt;
&lt;p&gt; InputStream    OutputStream&lt;/p&gt;
&lt;p&gt;字符流的基本抽象类&lt;/p&gt;
&lt;p&gt;Reader   Writer&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;功能：&lt;/strong&gt;&lt;br/&gt;　　　　节点流: 只有一个根管道套在文件上进行传输&lt;br/&gt;　　　　处理流: 将节点流处理一下, 增强管道的功能, 相当于在管道上套一层&lt;/p&gt;
&lt;h2&gt; 字节流和字符流：&lt;/h2&gt;
&lt;p&gt;InputStream和Reader是所有输入流的抽象基类，本身并不能创建实例来执行输入，但它们将成为所有输入流的模板，他们的方法是有输入流都可以使用的方法。&lt;/p&gt;
&lt;p&gt;这两个基类的功能基本是一样的。&lt;/p&gt;
&lt;p&gt;他们分别有一个用于读取文件的输入流:FileInputStream和FileReader，他们都是节点流，会直接和指定文件关联。&lt;/p&gt;
&lt;p&gt;使用FileInputStream读取文件自身：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字节输入流&lt;/span&gt;
        FileInputStream fis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(
                &lt;/span&gt;&quot;D:\\idea_project\\mybootbill\\src\\main\\java\\com\\jiangwenzhang\\mybootbill\\learn\\FileIO\\FileInputStreamTest.java&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个长度为1024的“竹筒”&lt;/span&gt;
        &lt;span&gt;byte&lt;/span&gt;[] bbuf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于保存实际读取的字节数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用循环来重复“取水”过程&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((hasRead = fis.read(bbuf)) &amp;gt; 0&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出“竹筒”中水滴（字节），将字节数组转换成字符串输入！&lt;/span&gt;
            System.out.print(&lt;span&gt;new&lt;/span&gt; String(bbuf , 0&lt;span&gt; , hasRead ));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭文件输入流，放在finally块里更安全&lt;/span&gt;
&lt;span&gt;        fis.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180618205403928-1718442302.png&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意，如果bbuf字节数组的长度较小，遇到中文时可能会乱码，因为如果文件本身保存时采用GBK编码方式，在这种方式下，每个中文字符占两个字节，如果read方法读取时只读取到了半个中文就会乱码。&lt;/p&gt;
&lt;p&gt;程序里打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以要显示关闭文件IO资源。&lt;/p&gt;
&lt;p&gt;使用FileReader：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字符输入流&lt;/span&gt;
                FileReader fr = &lt;span&gt;new&lt;/span&gt; FileReader(&quot;D:\\idea_project\\mybootbill\\src\\main\\java\\com\\jiangwenzhang\\mybootbill\\learn\\FileIO\\FileReaderTest.java&quot;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个长度为32的“竹筒”&lt;/span&gt;
            &lt;span&gt;char&lt;/span&gt;[] cbuf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[32&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于保存实际读取的字符数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用循环来重复“取水”过程&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((hasRead = fr.read(cbuf)) &amp;gt; 0&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出“竹筒”中水滴（字符），将字符数组转换成字符串输入！&lt;/span&gt;
                System.out.print(&lt;span&gt;new&lt;/span&gt; String(cbuf , 0&lt;span&gt; , hasRead));
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180618205952170-576446744.png&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;InputStream和Reader还支持如下几个方法来移动记录指针：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;方法&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;释义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;void mark(int readlimit)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Marks the current position in this input stream.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;boolean markSupported()&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Tests if this input stream supports the mark and reset methods.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;void reset()&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Repositions this stream to the position at the time the mark method was last called on this input stream.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;long skip(long n)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Skips over and discards n bytes of data from this input stream.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;OuputStream和Writer：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字节输入流&lt;/span&gt;
                FileInputStream fis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(
                        &lt;/span&gt;&quot;D:\\idea_project\\mybootbill\\src\\main\\java\\com\\jiangwenzhang\\mybootbill\\learn\\FileIO\\FileOutputStreamTest.java&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字节输出流&lt;/span&gt;
                FileOutputStream fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;newFile.txt&quot;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件在项目根&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bbuf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[32&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环从输入流中取出数据&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((hasRead = fis.read(bbuf)) &amp;gt; 0&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每读取一次，即写入文件输出流，读了多少，就写多少。&lt;/span&gt;
                fos.write(bbuf , 0&lt;span&gt; , hasRead);
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)
        {
            ioe.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：使用IO流执行输出时，不要忘记关闭输出流，关闭输出流处可以保证流的物流自愿被回收，还可以将输出流缓冲区的数据flush到物理节点里。&lt;/p&gt;
&lt;p&gt;如果希望直接输出字符串内容，使用Writer更好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                FileWriter fw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;poem.txt&quot;&lt;span&gt;))
        {
            fw.write(&lt;/span&gt;&quot;锦瑟 - 李商隐\r\n&quot;&lt;span&gt;);
            fw.write(&lt;/span&gt;&quot;锦瑟无端五十弦，一弦一柱思华年。\r\n&quot;&lt;span&gt;);
            fw.write(&lt;/span&gt;&quot;庄生晓梦迷蝴蝶，望帝春心托杜鹃。\r\n&quot;&lt;span&gt;);
            fw.write(&lt;/span&gt;&quot;沧海月明珠有泪，蓝田日暖玉生烟。\r\n&quot;&lt;span&gt;);
            fw.write(&lt;/span&gt;&quot;此情可待成追忆，只是当时已惘然。\r\n&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)
        {
            ioe.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;输入输出流体系：&lt;/h2&gt;
&lt;p&gt;使用处理流的典型思路是，使用处理流来包装节点流，程序通过处理流来执行输入输入，让节点流与底层设备、文件交互。&lt;/p&gt;
&lt;p&gt;使用PrintStream处理流包装OutStream：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                FileOutputStream fos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;test.txt&quot;&lt;span&gt;);
                PrintStream ps &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintStream(fos))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用PrintStream执行输出&lt;/span&gt;
            ps.println(&quot;普通字符串&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接使用PrintStream输出对象&lt;/span&gt;
            ps.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintStreamTest());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)
        {
            ioe.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常如果要输出文本内容，都应将输出流包装成PrintStream后输出。&lt;/p&gt;
&lt;p&gt;注意，在使用处理流包装了底层节点之后，关闭输入输出流资源是，只要关闭最上层的处理流即可，关闭最上层处理流时，系统会自动关闭被该处理流包装的节点流。&lt;/p&gt;
&lt;p&gt;Java输入输出流体系常用流分类：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;流分类&lt;/td&gt;
&lt;td&gt;使用分类&lt;/td&gt;
&lt;td&gt;字节输入流&lt;/td&gt;
&lt;td&gt;字节输出流&lt;/td&gt;
&lt;td&gt;字符输入流&lt;/td&gt;
&lt;td&gt;字符输出流&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;抽象基类&lt;/td&gt;
&lt;td&gt;&lt;em&gt;InputStream&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;em&gt;OutputStream&lt;/em&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Reader&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Writer&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;4&quot;&gt;节点流&lt;/td&gt;
&lt;td&gt;访问文件&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;FileInputStream&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;FileOutStream&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;FileReader&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;FileWriter&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;访问数值&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ByteArrayInputStream&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ByteArrayOutStream&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;CharArrayReader&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;CharArrayWriter&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;访问管道&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;PipedInputStream&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;PipedOutStream&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;PipedReader&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;PipedWriter&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;访问字符串&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;StringReader&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;StringWriter&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;7&quot;&gt;处理流&lt;/td&gt;
&lt;td&gt;缓冲流&lt;/td&gt;
&lt;td&gt;BufferedInputStream&lt;/td&gt;
&lt;td&gt;BufferedOutputStream&lt;/td&gt;
&lt;td&gt;BufferedReader&lt;/td&gt;
&lt;td&gt;BufferedWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;转换流&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;InputStreamReader&lt;/td&gt;
&lt;td&gt;OutputStreamWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对象流&lt;/td&gt;
&lt;td&gt;ObjectInputStream&lt;/td&gt;
&lt;td&gt;ObjectOutputStream&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;抽象基类（过滤）&lt;/td&gt;
&lt;td&gt;&lt;em&gt;FilterInputStream&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;FilterOutputStream&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;FilterReader&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;FilterWriter&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;打印流&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;PrintStream&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;PrintWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;推回输入流&lt;/td&gt;
&lt;td&gt;PushbackInputStream&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;PushbackReader&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;特殊流&lt;/td&gt;
&lt;td&gt;DataInputStream&lt;/td&gt;
&lt;td&gt;DataOutputStream&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;通常来说，字节流的功能比字符流强大，因为计算机所有数据都是二进制的，字节流可以处理所有的二进制文件，但是需要使用合适的方式把这些字节转换成字符，通常：如果进行输入输出的内容是文本内容，则应该考虑使用字符流，如果是二进制内容，则使用字节流。&lt;/p&gt;
&lt;p&gt;使用字符串作为物理节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        String src &lt;/span&gt;= &quot;从明天起，做一个幸福的人\n&quot;
                + &quot;喂马，劈柴，周游世界\n&quot;
                + &quot;从明天起，关心粮食和蔬菜\n&quot;
                + &quot;我有一所房子，面朝大海，春暖花开\n&quot;
                + &quot;从明天起，和每一个亲人通信\n&quot;
                + &quot;告诉他们我的幸福\n&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[32&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                StringReader sr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringReader(src))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 采用循环读取的访问读取字符串&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;((hasRead = sr.read(buffer)) &amp;gt; 0&lt;span&gt;)
            {
                System.out.print(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(buffer ,0&lt;span&gt; , hasRead));
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)
        {
            ioe.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建StringWriter时，实际上以一个StringBuffer作为输出节点
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面指定的20就是StringBuffer的初始长度&lt;/span&gt;
                StringWriter sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用StringWriter的方法执行输出&lt;/span&gt;
            sw.write(&quot;有一个美丽的新世界，\n&quot;&lt;span&gt;);
            sw.write(&lt;/span&gt;&quot;她在远方等我,\n&quot;&lt;span&gt;);
            sw.write(&lt;/span&gt;&quot;哪里有天真的孩子，\n&quot;&lt;span&gt;);
            sw.write(&lt;/span&gt;&quot;还有姑娘的酒窝\n&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;----下面是sw的字符串节点里的内容----&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用toString()方法返回StringWriter的字符串节点的内容&lt;/span&gt;
&lt;span&gt;            System.out.println(sw.toString());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和前面使用FileReader和FileWriter相似，只是创建对象时传入的是字符串节点，用于String是不可变得字符串对象，所以StringWriter使用StringBuffer作为输出节点。&lt;/p&gt;
&lt;p&gt;转换流&lt;/p&gt;
&lt;p&gt;InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流。&lt;/p&gt;
&lt;p&gt;以键盘输入为例，java使用System.in代表标准输入也就是键盘输入，但这个标准输入流是InputStream类的实例，可以使用InputStreamReader将其转换成字符输入流，再讲普通的Reader再次包装成BufferedReader：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将Sytem.in对象转换成Reader对象&lt;/span&gt;
                InputStreamReader reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将普通Reader包装成BufferedReader&lt;/span&gt;
                BufferedReader br = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(reader))
        {
            String line &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 采用循环方式来一行一行的读取&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((line = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果读取的字符串为&quot;exit&quot;，程序退出&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (line.equals(&quot;exit&quot;&lt;span&gt;))
                {
                    System.exit(&lt;/span&gt;1&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印读取的内容&lt;/span&gt;
                System.out.println(&quot;输入内容为:&quot; +&lt;span&gt; line);
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)
        {
            ioe.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180618214634725-1877380183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推回输入流：&lt;/p&gt;
&lt;p&gt;PushbackInputStream和PushbackReader&lt;/p&gt;
&lt;p&gt;推回输入流都带有一个推回缓冲区，当程序调用推回输入流的unread()方法，系统将会把指定数组内容推回到该缓冲区，而推回输入流每次调用read()方法总是先从推回缓冲区读取，只有完全读取了推回缓冲区的内容后，但还没有装满read()所需的数组时才会从原输入流读取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个PushbackReader对象，指定推回缓冲区的长度为64&lt;/span&gt;
                PushbackReader pr = &lt;span&gt;new&lt;/span&gt; PushbackReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader(
                        &lt;/span&gt;&quot;D:\\idea_project\\mybootbill\\src\\main\\java\\com\\jiangwenzhang\\mybootbill\\learn\\FileIO\\PushbackTest.java&quot;) , 64&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[32&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用以保存上次读取的字符串内容&lt;/span&gt;
            String lastContent = &quot;&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环读取文件内容&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((hasRead = pr.read(buf)) &amp;gt; 0&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将读取的内容转换成字符串&lt;/span&gt;
                String content = &lt;span&gt;new&lt;/span&gt; String(buf , 0&lt;span&gt; , hasRead);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; targetIndex = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将上次读取的字符串和本次读取的字符串拼起来，
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看是否包含目标字符串, 如果包含目标字符串&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((targetIndex = (lastContent +&lt;span&gt; content)
                        .indexOf(&lt;/span&gt;&quot;new PushbackReader&quot;)) &amp;gt; 0&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将本次内容和上次内容一起推回缓冲区&lt;/span&gt;
                    &lt;span&gt;&lt;strong&gt;pr.unread((lastContent +&lt;span&gt; content).toCharArray());&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新定义一个长度为targetIndex的char数组&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(targetIndex &amp;gt; 32&lt;span&gt;)
                    {
                        buf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[targetIndex];
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再次读取指定长度的内容（就是目标字符串之前的内容）&lt;/span&gt;
                    &lt;strong&gt;&lt;span&gt;pr.read(buf , 0&lt;/span&gt;&lt;span&gt;&lt;span&gt; , targetIndex)&lt;/span&gt;;
                    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印读取的内容&lt;/span&gt;
                    System.out.print(&lt;span&gt;new&lt;/span&gt; String(buf , 0&lt;span&gt; ,targetIndex));
                    System.exit(&lt;/span&gt;0&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印上次读取的内容&lt;/span&gt;
&lt;span&gt;                    System.out.print(lastContent);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将本次内容设为上次读取的内容&lt;/span&gt;
                    lastContent =&lt;span&gt; content;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)
        {
            ioe.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180618215533112-970873209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;粗体下划线部分实现了将制定内容推回到推回缓冲区，于是程序再次调用read()方法时，实际上只是读取了推回缓冲区的部分内容，从而实现了只打印目标字符串前面内容的功能。&lt;/p&gt;
&lt;h2&gt;重定向标准输入输出：&lt;/h2&gt;
&lt;p&gt;        一般情况下，System.in代表的是键盘、System.out是代表的控制台（显示器）。当程序通过System.in来获取输入的时候，默认情况下，是从键盘读取输入；当程序试图通过System.out执行输出时，程序总是输出到显示器。如果我们想对这样的情况做一个改变，例如获取输入时，不是来自键盘，而是来自文件或其他的位置；输出的时候，不是输出到显示器上显示，而是输出到文件或其他位置，怎么实现？于是，java重定标准输入输出应运而生。&lt;/p&gt;
&lt;p&gt;  static void setErr（PrintStream err）、重定向标准错误输出流&lt;/p&gt;
&lt;p&gt;  static void setIn（InputStream in）、重定向标准输入流&lt;/p&gt;
&lt;p&gt;  static void setOut（PrintStream out） 重定向标准输出流&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一次性创建PrintStream输出流&lt;/span&gt;
                PrintStream ps = &lt;span&gt;new&lt;/span&gt; PrintStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;out.txt&quot;&lt;span&gt;)))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将标准输出重定向到ps输出流&lt;/span&gt;
&lt;span&gt;            System.setOut(ps);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向标准输出输出一个字符串&lt;/span&gt;
            System.out.println(&quot;普通字符串&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向标准输出输出一个对象&lt;/span&gt;
            System.out.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedirectOut());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                FileInputStream fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;RedirectIn.java&quot;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将标准输入重定向到fis输入流&lt;/span&gt;
&lt;span&gt;            System.setIn(fis);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用System.in创建Scanner对象，用于获取标准输入&lt;/span&gt;
            Scanner sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加下面一行将只把回车作为分隔符&lt;/span&gt;
            sc.useDelimiter(&quot;\n&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否还有下一个输入项&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(sc.hasNext())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出输入项&lt;/span&gt;
                System.out.println(&quot;键盘输入的内容是：&quot; +&lt;span&gt; sc.next());
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Java虚拟机读写其他进程数据&lt;/h2&gt;
&lt;p&gt; 读取其他进程的输出信息：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行javac命令，返回运行该命令的子进程&lt;/span&gt;
        Process p = Runtime.getRuntime().exec(&quot;javac&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以p进程的错误流创建BufferedReader对象
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个错误流对本程序是输入流，对p进程则是输出流&lt;/span&gt;
                BufferedReader br = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                        InputStreamReader(p.getErrorStream())))
        {
            String buff &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 采取循环方式来读取p进程的错误输出&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;((buff = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                System.out.println(buff);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Java程序中启动Java虚拟机运行另一个Java程序，并像另一个Java程序中输入数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jiangwenzhang.mybootbill.learn.FileIO;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WriteToProcess
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行java ReadStandard命令，返回运行该命令的子进程&lt;/span&gt;
        Process p = Runtime.getRuntime().exec(&quot;java ReadStandard&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以p进程的输出流创建PrintStream对象
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个输出流对本程序是输出流，对p进程则是输入流&lt;/span&gt;
                PrintStream ps = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintStream(p.getOutputStream()))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向ReadStandard程序写入内容，这些内容将被ReadStandard读取&lt;/span&gt;
            ps.println(&quot;普通字符串&quot;&lt;span&gt;);
            ps.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WriteToProcess());
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个ReadStandard类，该类可以接受标准输入，
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并将标准输入写入out.txt文件。&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadStandard
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用System.in创建Scanner对象，用于获取标准输入&lt;/span&gt;
                Scanner sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
                PrintStream ps &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintStream(
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;out.txt&quot;&lt;span&gt;)))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加下面一行将只把回车作为分隔符&lt;/span&gt;
            sc.useDelimiter(&quot;\n&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否还有下一个输入项&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(sc.hasNext())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出输入项&lt;/span&gt;
                ps.println(&quot;键盘输入的内容是：&quot; +&lt;span&gt; sc.next());
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException ioe)
        {
            ioe.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;RandomAccessFile&lt;/h2&gt;
&lt;p&gt; 随机流（RandomAccessFile）不属于IO流，支持对文件的读取和写入随机访问。&lt;/p&gt;
&lt;p&gt;RandomAccessFile允许自由定位文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因为RandomAccessFile可以向已存在的文件后追加内容。&lt;/p&gt;
&lt;p&gt;RandomAccessFile最大的局限就是只能读写文件，不能读写其他IO节点。&lt;/p&gt;
&lt;p&gt;RandomAccessFile对象包含了一个记录指针，用以标识当前读写位置。RandomAccessFile可以自由移动该记录指针。&lt;/p&gt;
&lt;p&gt;使用RandomAccessFile来访问指定的中间部分数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                RandomAccessFile raf &lt;/span&gt;=  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RandomAccessFile(
                        &lt;/span&gt;&quot;D:\\idea_project\\mybootbill\\src\\main\\java\\com\\jiangwenzhang\\mybootbill\\learn\\FileIO\\RandomAccessFileTest.java&quot; , &quot;r&quot;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取RandomAccessFile对象文件指针的位置，初始位置是0&lt;/span&gt;
            System.out.println(&quot;RandomAccessFile的文件指针的初始位置：&quot;
                    +&lt;span&gt; raf.getFilePointer());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动raf的文件记录指针的位置&lt;/span&gt;
            raf.seek(300&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bbuf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于保存实际读取的字节数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用循环来重复“取水”过程&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((hasRead = raf.read(bbuf)) &amp;gt; 0&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出“竹筒”中水滴（字节），将字节数组转换成字符串输入！&lt;/span&gt;
                System.out.print(&lt;span&gt;new&lt;/span&gt; String(bbuf , 0&lt;span&gt; , hasRead ));
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180619213707214-1432229544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方法以只读方式打开文件，从300字节处开始读取。&lt;/p&gt;
&lt;p&gt;像文件中追加内容，为了追加内容，程序应该先将记录指针移动到文件最后，然后项文件中输出内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以读、写方式打开一个RandomAccessFile对象&lt;/span&gt;
                RandomAccessFile raf = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;out.txt&quot; , &quot;rw&quot;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将记录指针移动到out.txt文件的最后&lt;/span&gt;
&lt;span&gt;            raf.seek(raf.length());
            raf.write(&lt;/span&gt;&quot;追加的内容！\r\n&quot;&lt;span&gt;.getBytes());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定文件，指定位置插入内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jiangwenzhang.mybootbill.learn.FileIO;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InsertContent
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(String fileName , &lt;span&gt;long&lt;/span&gt;&lt;span&gt; pos
            , String insertContent) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        File tmp &lt;/span&gt;= File.createTempFile(&quot;tmp&quot; , &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        tmp.deleteOnExit();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                RandomAccessFile raf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RandomAccessFile(fileName , &quot;rw&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用临时文件来保存插入点后的数据&lt;/span&gt;
                FileOutputStream tmpOut = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(tmp);
                FileInputStream tmpIn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(tmp))
        {
            raf.seek(pos);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ------下面代码将插入点后的内容读入临时文件中保存------&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt;[] bbuf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[64&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于保存实际读取的字节数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用循环方式读取插入点后的数据&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((hasRead = raf.read(bbuf)) &amp;gt; 0&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将读取的数据写入临时文件&lt;/span&gt;
                tmpOut.write(bbuf , 0&lt;span&gt; , hasRead);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ----------下面代码插入内容----------
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把文件记录指针重新定位到pos位置&lt;/span&gt;
&lt;span&gt;            raf.seek(pos);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 追加需要插入的内容&lt;/span&gt;
&lt;span&gt;            raf.write(insertContent.getBytes());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 追加临时文件中的内容&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((hasRead = tmpIn.read(bbuf)) &amp;gt; 0&lt;span&gt; )
            {
                raf.write(bbuf , &lt;/span&gt;0&lt;span&gt; , hasRead);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        insert(&lt;/span&gt;&quot;InsertContent.java&quot; , 45 , &quot;插入的内容\r\n&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Java9改进的对象序列化&lt;/h2&gt;
&lt;p&gt;对象序列化的目标是将对象保存到磁盘中，或允许在网络中直接传输对象。所有分布式应用常常需要跨平台，跨网络，因此要求所有传的参数、返回值都必须实现序列化。&lt;/p&gt;
&lt;p&gt;序列化：把Java对象转换为字节序列的过程。 &lt;/p&gt;
&lt;p&gt;反序列化：把字节序列恢复为Java对象的过程。&lt;/p&gt;
&lt;p&gt;对象的序列化是指将一个Java对象写入IO流中，对象的反序列化则是是指从IO流中恢复该Java对象。&lt;/p&gt;
&lt;p&gt;Java9增强了对象序列化机制，他允许对读入的序列化数据进行过滤，这种过滤可以在反序列化之前对数据执行校验，从而提高安全性和健壮性。&lt;/p&gt;
&lt;p&gt;让某个类可序列化，必须实现如下两个接口之一：&lt;/p&gt;
&lt;p&gt;Serializable&lt;/p&gt;
&lt;p&gt;Externailzable&lt;/p&gt;
&lt;p&gt;Java的很多类已经实现了Serializable，这是一个标记接口，无需实现任何方法，只是表明该类的实例是可以序列化的。&lt;/p&gt;
&lt;p&gt;所有可能在网络上传输的对象的类都应该是可序列化的。&lt;/p&gt;
&lt;h3&gt;使用对象流实现序列化：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class Person
        implements java.io.Serializable
{
    private String name;
    private &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意此处没有提供无参数的构造器!&lt;/span&gt;
    public Person(String name , &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        System.out.println(&lt;/span&gt;&quot;有参数的构造器&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略name与age的setter和getter方法&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; name的setter和getter方法&lt;/span&gt;
    public &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    public String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; age的setter和getter方法&lt;/span&gt;
    public &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    public &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WriteObject
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectOutputStream输出流&lt;/span&gt;
                ObjectOutputStream oos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;object.txt&quot;&lt;span&gt;)))
        {
            Person per &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;孙悟空&quot;, 500&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将per对象写入输出流&lt;/span&gt;
&lt;span&gt;            oos.writeObject(per);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180621161327219-201904938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;从而二进制流中恢复Java对象：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadObject
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectInputStream输入流&lt;/span&gt;
            ObjectInputStream ois = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;object.txt&quot;&lt;span&gt;)))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从输入流中读取一个Java对象，并将其强制类型转换为Person类&lt;/span&gt;
            Person p =&lt;span&gt; (Person)ois.readObject();
            System.out.println(&lt;/span&gt;&quot;名字为：&quot; +&lt;span&gt; p.getName()
                &lt;/span&gt;+ &quot;\n年龄为：&quot; +&lt;span&gt; p.getAge());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：反序列化读取的仅仅是Java对象的数据，而不是Java类，因此采用反序列化恢复Java对象必须提供Java对象所属类的class文件。&lt;/p&gt;
&lt;p&gt;反序列化机制无需通过构造器来初始化Java对象。&lt;/p&gt;
&lt;p&gt;如果使用序列化机制向文件中写入了多个Java对象，使用反序列化机制恢复对象必须按实际写入的顺序读取。&lt;/p&gt;
&lt;h3&gt;对象引用的序列化&lt;/h3&gt;
&lt;p&gt;如果某个类的成员变量的类型不是基本类型或String而是引用类型，那么这个引用类必须是可序列化的，否则拥有该类型成员变量的的类也是不可序列化的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Person student;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Teacher(String name , Person student)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.student =&lt;span&gt; student;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处省略了name和student的setter和getter方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; student的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStudent(Person student)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.student =&lt;span&gt; student;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person getStudent()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.student;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特殊情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            Person per = &lt;span&gt;new&lt;/span&gt; Person(&quot;孙悟空&quot;, 500&lt;span&gt;);
            Teacher t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Teacher(&quot;唐僧&quot;&lt;span&gt; , per);
            Teacher t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Teacher(&quot;菩提祖师&quot; , per);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201806/1176316-20180621164917941-634353920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两种对象互相引用，这样如果先序列化t1，系统将t1对象引用的Person对象一起序列化，在序列化t2，程序将一样会序列化该t2对象，并且再次序列化Person对象，如果程序在显示序列化per对象，系统又一次序列化person对象。这个过程向输出流中输出三个Person对象。&lt;/p&gt;
&lt;p&gt;这样程序从输入流中反序列化这些对象，将会得到三个person对象，从而引起t1和t2所引用的Person对象不是同一个对象。&lt;/p&gt;
&lt;p&gt;Java序列化机制采用了一种特殊的序列化算法：&lt;/p&gt;
&lt;p&gt;1、所有保存到磁盘中的对象都有一个序列化编号。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;当程序试图序列化一个对象时，会先检查该对象是否已经被序列化过，只有该对象从未（在本次虚拟机中）被序列化，系统才会将该对象转换成字节序列并输出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、如果对象已经被序列化，程序将直接输出一个序列化编号，而不是重新序列化。&lt;/p&gt;
&lt;p&gt;通过以上算法，当第二次第三次序列化，程序不会再次将Person对象转换成字节序列并输出，而是仅仅输出一个序列化编号。&lt;/p&gt;
&lt;p&gt;当多次调用wirteObject()方法输出同一个对象时，只有第一次调用wirteObject()方法才会将该对象转换成字节序列并输出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectOutputStream输出流&lt;/span&gt;
            ObjectOutputStream oos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;teacher.txt&quot;&lt;span&gt;)))
        {
            Person per &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;孙悟空&quot;, 500&lt;span&gt;);
            Teacher t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Teacher(&quot;唐僧&quot;&lt;span&gt; , per);
            Teacher t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Teacher(&quot;菩提祖师&quot;&lt;span&gt; , per);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次将四个对象写入输出流&lt;/span&gt;
&lt;span&gt;            oos.writeObject(t1);
            oos.writeObject(t2);
            oos.writeObject(per);
            oos.writeObject(t2);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectInputStream输出流&lt;/span&gt;
            ObjectInputStream ois = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;teacher.txt&quot;&lt;span&gt;)))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次读取ObjectInputStream输入流中的四个对象&lt;/span&gt;
            Teacher t1 =&lt;span&gt; (Teacher)ois.readObject();
            Teacher t2 &lt;/span&gt;=&lt;span&gt; (Teacher)ois.readObject();
            Person p &lt;/span&gt;=&lt;span&gt; (Person)ois.readObject();
            Teacher t3 &lt;/span&gt;=&lt;span&gt; (Teacher)ois.readObject();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出true&lt;/span&gt;
            System.out.println(&quot;t1的student引用和p是否相同：&quot;
                + (t1.getStudent() ==&lt;span&gt; p));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出true&lt;/span&gt;
            System.out.println(&quot;t2的student引用和p是否相同：&quot;
                + (t2.getStudent() ==&lt;span&gt; p));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出true&lt;/span&gt;
            System.out.println(&quot;t2和t3是否是同一个对象：&quot;
                + (t2 ==&lt;span&gt; t3));
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码依次读取了序列化文件中的4个Java对象，通过比较可以看出t2和t3是同一个对象。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;由于Java序列化机制使然，多次序列化同一个Java对象时，只有第一次序列化该对象才会把该Java对象转换成字节序列并输出，因此程序序列化一个可变对象之后，后面改变了对象的实例变量值，再次序列化也只是输出前面的序列化编号，改变的实例变量值也不会输出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectOutputStream输入流&lt;/span&gt;
            ObjectOutputStream oos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;mutable.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectInputStream输入流&lt;/span&gt;
            ObjectInputStream ois = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;mutable.txt&quot;&lt;span&gt;)))
        {
            Person per &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;孙悟空&quot;, 500&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统会per对象转换字节序列并输出&lt;/span&gt;
&lt;span&gt;            oos.writeObject(per);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变per对象的name实例变量&lt;/span&gt;
            per.setName(&quot;猪八戒&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统只是输出序列化编号，所以改变后的name不会被序列化&lt;/span&gt;
&lt;span&gt;            oos.writeObject(per);
            Person p1 &lt;/span&gt;= (Person)ois.readObject();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①&lt;/span&gt;
            Person p2 = (Person)ois.readObject();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面输出true，即反序列化后p1等于p2&lt;/span&gt;
            System.out.println(p1 ==&lt;span&gt; p2);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面依然看到输出&quot;孙悟空&quot;，即改变后的实例变量没有被序列化&lt;/span&gt;
&lt;span&gt;            System.out.println(p2.getName());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java9增加的过滤功能：&lt;/p&gt;
&lt;p&gt;Java9为ObjectInputStream增加了setObjectInputFilter()和getObjectInputFilter()两个方法，其中第一个方法用于为对象输入流设置过滤器。当程序通过ObjectInputStream反序列化时，过滤器的checkInput()方法会被自动激发，用于检查序列化数据是否有效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectInputStream输入流&lt;/span&gt;
            ObjectInputStream ois = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;object.txt&quot;&lt;span&gt;)))
        {
            ois.setObjectInputFilter((info) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                System.out.println(&lt;/span&gt;&quot;===执行数据过滤===&quot;&lt;span&gt;);
                ObjectInputFilter serialFilter &lt;/span&gt;=&lt;span&gt; ObjectInputFilter.Config.getSerialFilter();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serialFilter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先使用ObjectInputFilter执行默认的检查&lt;/span&gt;
                        ObjectInputFilter.Status status =&lt;span&gt; serialFilter.checkInput(info);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果默认检查的结果不是Status.UNDECIDED&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (status !=&lt;span&gt; ObjectInputFilter.Status.UNDECIDED) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接返回检查结果&lt;/span&gt;
                            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果要恢复的对象不是1个&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(info.references() != 1&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不允许恢复对象&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ObjectInputFilter.Status.REJECTED;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (info.serialClass() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果恢复的不是Person类&lt;/span&gt;
                        info.serialClass() != Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不允许恢复对象&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ObjectInputFilter.Status.REJECTED;
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ObjectInputFilter.Status.UNDECIDED;
                });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从输入流中读取一个Java对象，并将其强制类型转换为Person类&lt;/span&gt;
            Person p =&lt;span&gt; (Person)ois.readObject();
            System.out.println(&lt;/span&gt;&quot;名字为：&quot; +&lt;span&gt; p.getName()
                &lt;/span&gt;+ &quot;\n年龄为：&quot; +&lt;span&gt; p.getAge());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义序列化&lt;/p&gt;
&lt;p&gt;通过在实例变量前使用transient关键字修饰，可以指定Java序列化时无需理会该实例变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意此处没有提供无参数的构造器!&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Person(String name , &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        System.out.println(&lt;/span&gt;&quot;有参数的构造器&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略name与age的setter和getter方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; age的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransientTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectOutputStream输出流&lt;/span&gt;
            ObjectOutputStream oos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;transient.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectInputStream输入流&lt;/span&gt;
            ObjectInputStream ois = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;transient.txt&quot;&lt;span&gt;)))
        {
            Person per &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;孙悟空&quot;, 500&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统会per对象转换字节序列并输出&lt;/span&gt;
&lt;span&gt;            oos.writeObject(per);
            Person p &lt;/span&gt;=&lt;span&gt; (Person)ois.readObject();
            System.out.println(p.getAge());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序将输出0&lt;/p&gt;
&lt;p&gt;被transient修饰的的实例变量被完全隔离在序列化机制之外，这导致在反序列化恢复Java对象时无法取得该实例变量值。&lt;/p&gt;
&lt;p&gt;Java提供了一种自定义序列化机制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意此处没有提供无参数的构造器!&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Person(String name , &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        System.out.println(&lt;/span&gt;&quot;有参数的构造器&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略name与age的setter和getter方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; age的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeObject(java.io.ObjectOutputStream out)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将name实例变量的值反转后写入二进制流&lt;/span&gt;
        out.writeObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer(name).reverse());
        out.writeInt(age);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(java.io.ObjectInputStream in)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将读取的字符串反转后赋给name实例变量&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; ((StringBuffer)in.readObject()).reverse()
            .toString();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; in.readInt();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一种更彻底的自定义机制，他可以在序列化对象时将该对象替换成其他对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意此处没有提供无参数的构造器!&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Person(String name , &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        System.out.println(&lt;/span&gt;&quot;有参数的构造器&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略name与age的setter和getter方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; age的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    重写writeReplace方法，程序在序列化该对象之前，先调用该方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Object writeReplace()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ObjectStreamException
    {
        ArrayList&lt;/span&gt;&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(name);
        list.add(age);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java的序列化机制保证在序列化某个对象之前，先调用该对象的writeReplace()方法，如果方法返回的是另一个对象，则系统转为序列化另一个对象，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReplaceTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectOutputStream输出流&lt;/span&gt;
            ObjectOutputStream oos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;replace.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个ObjectInputStream输入流&lt;/span&gt;
            ObjectInputStream ois = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;replace.txt&quot;&lt;span&gt;)))
        {
            Person per &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;孙悟空&quot;, 500&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统将per对象转换字节序列并输出&lt;/span&gt;
&lt;span&gt;            oos.writeObject(per);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反序列化读取得到的是ArrayList&lt;/span&gt;
            ArrayList list =&lt;span&gt; (ArrayList)ois.readObject();
            System.out.println(list);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;序列化机制里还有一个特殊的方法，他可以实现保护整个对象，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Orientation
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Orientation HORIZONTAL = &lt;span&gt;new&lt;/span&gt; Orientation(1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Orientation VERTICAL = &lt;span&gt;new&lt;/span&gt; Orientation(2&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Orientation(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为枚举类增加readResolve()方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Object readResolve()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ObjectStreamException
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == 1&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; HORIZONTAL;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == 2&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; VERTICAL;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java的另一种自定义序列化机制：&lt;/p&gt;
&lt;p&gt;Java还提供了另一种自定义序列化机制，这种序列化机制完全由程序员存储和恢复对象数据。需要实现Externalizable接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Externalizable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意必须提供无参数的构造器，否则反序列化时会失败。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(){}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name , &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        System.out.println(&lt;/span&gt;&quot;有参数的构造器&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略name与age的setter和getter方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; age的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeExternal(java.io.ObjectOutput out)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将name实例变量的值反转后写入二进制流&lt;/span&gt;
        out.writeObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer(name).reverse());
        out.writeInt(age);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readExternal(java.io.ObjectInput in)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将读取的字符串反转后赋给name实例变量&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; ((StringBuffer)in.readObject()).reverse().toString();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; in.readInt();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;NIO&lt;/h2&gt;
&lt;p&gt;NIO(新IO)和传统的IO具有相同的目的，都用于进行输入输出，但新IO采用了不同的方式来处理，NIO采用内存映射文件的方式来处理，NIO将文件或文件的一段区域映射到内存中，从而像访问内存一样访问文件。就像操作系统的虚拟内存概念。&lt;/p&gt;
&lt;p&gt;Channel(通道)和Buffer(缓冲)是NIO的两个核心对象，Channel是对传统输入输出系统的模拟，在NIO中所有的数据都需要通过通道传输，Channel和传统的输入输出最大的区别在于它提供了一个map()方法,该方法可以直接将一块数据映射到内存中。&lt;/p&gt;
&lt;p&gt;IO是面向流的，NIO是面向快(缓冲区)的。&lt;/p&gt;
&lt;p&gt;Buffer可以被理解成一个容器，他的本质是数组，发送到Channel中的所有对象都必须首相放到Buffer中，从Channel中取出的数据也必须先放到Buffer中，Buffer可以一次次去Channel中取数据，也允许用Channel将文件的某块数据映射成Buffer。&lt;/p&gt;
&lt;p&gt;NIO还提供了用于将Unicode字符串映射成字节序列以及逆映射操作的Charset累和用于支持非阻塞式输入输出的Selector类。&lt;/p&gt;
&lt;h3&gt;Buffer&lt;/h3&gt;
&lt;p&gt;Buffer就像一个数组可以保存多个类型相同的数据，Buffer是一个抽象类，最常用的子类是ByteBuffer，他可以在底层字节数组上进行getset操作。其他基本数据类型除了boolean都有相应的Buffer类。&lt;/p&gt;
&lt;p&gt;在Buffer中有几个重要概念&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Capacity&lt;/td&gt;
&lt;td&gt;容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Limit&lt;/td&gt;
&lt;td&gt;上界，缓冲区中当前数据量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Position&lt;/td&gt;
&lt;td&gt;位置，下一个要被读或写的元素的索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Mark&lt;/td&gt;
&lt;td&gt;标记，调用mark()来设置mark=position，再调用reset()可以让position恢复到标记的位置即position=mark&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;并遵循：capacity&amp;gt;=limit&amp;gt;=position&amp;gt;=mark&amp;gt;=0&lt;/p&gt;
&lt;p&gt;Buffer的主要作用是装入数据然后输出数据，开始时Buffer的postiton为0，limit为capatity，程序通过put()方法像Buffer装入数据，或者从Channel中获取数据，Buffer的postion相应的后移。&lt;/p&gt;
&lt;p&gt;Buffer装入数据后，调用Buffer的flip()方法，将limit位置设为postiton所在位置，并将postiton设为0，是的Buffer的读写指针移动到了开始的位置，为输出数据做好准备，当BUffer输出数据结束后，Buffer调用clear方法，不是清空数据，仅仅将postiton设置为0，两limit设置为capatity，为再次向Buffer中装入数据做好了准备。&lt;/p&gt;
&lt;p&gt;Buffer常规操作：&lt;/p&gt;
&lt;p&gt;ByteBuffer buffer=ByteBuffer.allocate(1024);       //非直接    大小为1024个字节  此时它的position=0 limit=1024 capacity=1024&lt;/p&gt;
&lt;p&gt;ByteBuffer buf =ByteBuffer.allocateDirect(1024);     //直接    大小为1024个字节&lt;/p&gt;
&lt;p&gt;buffer.put(&quot;abcde&quot;.getBytes());                       //将一个字节数组写入缓冲区 此时它的position=5 limit=1024 capacity=1024&lt;/p&gt;
&lt;p&gt;buffer.put(&quot;abcde&quot;.getBytes()); //该数组会在之前position开始写 写完后 position=10 limit=1024 capacity=1024&lt;/p&gt;
&lt;p&gt;buffer.flip();                                                   //这一步的作用是 使position=0 limit为可以操作的最大字节数 这里limit=10 capacity不变 还是1024&lt;/p&gt;
&lt;p&gt;System.out.println(new String(byteBuffer.array(),0,2));          //它的结果在这里是：ab&lt;/p&gt;
&lt;p&gt;这个方法的作用是什么呢？回到属性，执行下面语句：&lt;/p&gt;
&lt;p&gt;System.out.println(byteBuffer.position());&lt;br/&gt;System.out.println(byteBuffer.limit());&lt;br/&gt;System.out.println(byteBuffer.capacity());&lt;/p&gt;
&lt;p&gt;输出的结果是（以空格代替换行）： 0      1024       1024&lt;/p&gt;
&lt;p&gt;也就是说，现在这个缓冲区现在可以从索引0位置开始操作了。那就put试一试：&lt;/p&gt;
&lt;p&gt;byteBuffer.put(&quot;hhh&quot;.getBytes());                               //注意这里只put3个字节&lt;/p&gt;
&lt;p&gt;那么如果put之后的position、limit、capacity又是多少呢？&lt;/p&gt;
&lt;p&gt;此时position=3    limit=1024  capacity=1024&lt;/p&gt;
&lt;p&gt;对于上面的结果？也许会有疑问？先保留吧，接下来我们读取该buffer的内容：&lt;/p&gt;
&lt;p&gt;byteBuffer.flip();         //读之前先翻转    翻转后position=3    limit=3  capacity=1024&lt;/p&gt;
&lt;p&gt;System.out.println(new String(buffer.array(),0,buffer.limit()));&lt;/p&gt;
&lt;p&gt;结果是：hhh&lt;/p&gt;
&lt;p&gt;不知道小伙伴有没有疑问，不是说之前的数据还在吗？它去哪了呢？&lt;/p&gt;
&lt;p&gt;被遗忘了，这里还是要把clear()方法再次提出来，之前说过，它并不会将缓冲区中的数据清空，也就是说缓冲区中之前的数据还在。执行clear后我们可以像操作一个空的缓冲区&lt;/p&gt;
&lt;p&gt;一样从索引0位置开始来操作这个缓冲区。但是之前的数据还存在，只是被遗忘了。如果上面我们没有执行byteBuffer.flip(); 那么，结果就会是：hhhdeworld&lt;/p&gt;
&lt;p&gt;所以啊，flip()一定不要忘了。&lt;/p&gt;
&lt;p&gt;mark() :标记当前position&lt;/p&gt;
&lt;p&gt;reset() :恢复position到mark标记的位置&lt;/p&gt;
&lt;p&gt;hasRemaining :判断缓冲区中是否含有元素&lt;/p&gt;
&lt;p&gt;get() :从缓冲区中读取单个字节&lt;/p&gt;
&lt;p&gt;get(byte[] dst) :批量读取多个字节到dst数组&lt;/p&gt;
&lt;p&gt;get(int index) : 读取指定位置的字节(position不会改变)&lt;/p&gt;
&lt;p&gt;put(byte b) :将单个字节写入缓冲区position位置&lt;/p&gt;
&lt;p&gt;put(byte[] dst) :将多个字节从缓冲区position位置开始写入&lt;/p&gt;
&lt;p&gt;put(int index，byte b) : 将指定字节写入缓冲区索引位置，不会移动position&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BufferTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Buffer&lt;/span&gt;
        CharBuffer buff = CharBuffer.allocate(8);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①&lt;/span&gt;
        System.out.println(&quot;capacity: &quot;    +&lt;span&gt; buff.capacity());
        System.out.println(&lt;/span&gt;&quot;limit: &quot; +&lt;span&gt; buff.limit());
        System.out.println(&lt;/span&gt;&quot;position: &quot; +&lt;span&gt; buff.position());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放入元素&lt;/span&gt;
        buff.put('a'&lt;span&gt;);
        buff.put(&lt;/span&gt;'b'&lt;span&gt;);
        buff.put(&lt;/span&gt;'c');      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ②&lt;/span&gt;
        System.out.println(&quot;加入三个元素后，position = &quot;
            +&lt;span&gt; buff.position());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用flip()方法&lt;/span&gt;
        buff.flip();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ③&lt;/span&gt;
        System.out.println(&quot;执行flip()后，limit = &quot; +&lt;span&gt; buff.limit());
        System.out.println(&lt;/span&gt;&quot;position = &quot; +&lt;span&gt; buff.position());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出第一个元素&lt;/span&gt;
        System.out.println(&quot;第一个元素(position=0)：&quot; + buff.get());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ④&lt;/span&gt;
        System.out.println(&quot;取出一个元素后，position = &quot;
            +&lt;span&gt; buff.position());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用clear方法&lt;/span&gt;
        buff.clear();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ⑤&lt;/span&gt;
        System.out.println(&quot;执行clear()后，limit = &quot; +&lt;span&gt; buff.limit());
        System.out.println(&lt;/span&gt;&quot;执行clear()后，position = &quot;
            +&lt;span&gt; buff.position());
        System.out.println(&lt;/span&gt;&quot;执行clear()后，缓冲区内容并没有被清除：&quot;
            + &quot;第三个元素为：&quot; +  buff.get(2));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ⑥&lt;/span&gt;
        System.out.println(&quot;执行绝对读取后，position = &quot;
            +&lt;span&gt; buff.position());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Buffer的创建成本很高，所以直接Buffer适用于长期生存的Buffer。&lt;/p&gt;
&lt;p&gt;只有ByteBuffer提供allocateDirect()方法，所以只能在ByteBuffer级别上创建直接ByteBuffer，如果希望使用其他类型，将该Buffer转换成其他类型Buffer。&lt;/p&gt;
&lt;h3&gt;Channel&lt;/h3&gt;
&lt;p&gt;channel类似于传统流对象，区别：&lt;/p&gt;
&lt;p&gt;channel可以直接将指定文件的部分或者全部映射成Buffer。&lt;/p&gt;
&lt;p&gt;程序不能直接访问channel中的数据，channel只能和Buffer进行交互。&lt;/p&gt;
&lt;p&gt;所有的channel都不应该通过构造器直接创建，而是通过传统节点InputStream、outPutstream的getChannel()方法返回对应的channel，不同的节点流获得的channel也不一样。&lt;/p&gt;
&lt;p&gt;channel中最常用的三类方法map() , read() , write() 。map()用于将数据映射成ByteBuffer，另外两个有一系列重载，用于对Buffer读写数据。&lt;/p&gt;
&lt;p&gt;将FileChannel的全部数据映射成ByteBuffer：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileChannelTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        File f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;FileChannelTest.java&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建FileInputStream，以该文件输入流创建FileChannel&lt;/span&gt;
            FileChannel inChannel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(f).getChannel();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以文件输出流创建FileBuffer，用以控制输出&lt;/span&gt;
            FileChannel outChannel = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;a.txt&quot;&lt;span&gt;)
                .getChannel())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将FileChannel里的全部数据映射成ByteBuffer&lt;/span&gt;
            MappedByteBuffer buffer =&lt;span&gt; inChannel.map(FileChannel
                .MapMode.READ_ONLY , &lt;/span&gt;0 , f.length());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用GBK的字符集来创建解码器&lt;/span&gt;
            Charset charset = Charset.forName(&quot;GBK&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接将buffer里的数据全部输出&lt;/span&gt;
            outChannel.write(buffer);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ②
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再次调用buffer的clear()方法，复原limit、position的位置&lt;/span&gt;
&lt;span&gt;            buffer.clear();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建解码器(CharsetDecoder)对象&lt;/span&gt;
            CharsetDecoder decoder =&lt;span&gt; charset.newDecoder();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用解码器将ByteBuffer转换成CharBuffer&lt;/span&gt;
            CharBuffer charBuffer =&lt;span&gt;  decoder.decode(buffer);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CharBuffer的toString方法可以获取对应的字符串&lt;/span&gt;
&lt;span&gt;            System.out.println(charBuffer);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex)
        {
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;FileInputStream&lt;/span&gt;获取的 channel只能读，FileOutputStream获取的 channel只能写。RandomAccessFile中也包含getChannel方法，他是只读的还是读写的，取决于RandomAccessFile打开文件的模式。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RandomFileChannelTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        File f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;a.txt&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个RandomAccessFile对象&lt;/span&gt;
            RandomAccessFile raf = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(f, &quot;rw&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取RandomAccessFile对应的Channel&lt;/span&gt;
            FileChannel randomChannel =&lt;span&gt; raf.getChannel())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将Channel中所有数据映射成ByteBuffer&lt;/span&gt;
            ByteBuffer buffer =&lt;span&gt; randomChannel.map(FileChannel
                .MapMode.READ_ONLY, &lt;/span&gt;0&lt;span&gt; , f.length());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把Channel的记录指针移动到最后&lt;/span&gt;
&lt;span&gt;            randomChannel.position(f.length());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将buffer中所有数据输出&lt;/span&gt;
&lt;span&gt;            randomChannel.write(buffer);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Channel和Buffer使用传统的IO的多次获取数据的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadFile
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建文件输入流&lt;/span&gt;
            FileInputStream fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;ReadFile.java&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个FileChannel&lt;/span&gt;
            FileChannel fcin =&lt;span&gt; fis.getChannel())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个ByteBuffer对象，用于重复取水&lt;/span&gt;
            ByteBuffer bbuff = ByteBuffer.allocate(256&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将FileChannel中数据放入ByteBuffer中&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;( fcin.read(bbuff) != -1&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁定Buffer的空白区&lt;/span&gt;
&lt;span&gt;                bbuff.flip();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Charset对象&lt;/span&gt;
                Charset charset = Charset.forName(&quot;GBK&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建解码器(CharsetDecoder)对象&lt;/span&gt;
                CharsetDecoder decoder =&lt;span&gt; charset.newDecoder();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将ByteBuffer的内容转码&lt;/span&gt;
                CharBuffer cbuff =&lt;span&gt; decoder.decode(bbuff);
                System.out.print(cbuff);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将Buffer初始化，为下一次读取数据做准备&lt;/span&gt;
&lt;span&gt;                bbuff.clear();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;字符集和Charset&lt;/h2&gt;
&lt;p&gt;Java默认采用Unicode字符集。JDK1.4提供了Charset来处理字节序列和字符序列之间的转换关系。该类提供了创建解码器和编码器的方法。&lt;/p&gt;
&lt;p&gt;获取JDK支持的全部字符集：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CharsetTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Java支持的全部字符集&lt;/span&gt;
        SortedMap&amp;lt;String,Charset&amp;gt;  map =&lt;span&gt; Charset.availableCharsets();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String alias : map.keySet())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出字符集的别名和对应的Charset对象&lt;/span&gt;
            System.out.println(alias + &quot;-----&amp;gt;&quot;
                +&lt;span&gt; map.get(alias));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;知道了字符集别名，可以调用Charset的forName方法创建对应的Charset对象，forName方法的参数是字符集别名。&lt;/p&gt;
&lt;p&gt;获得了Charset对象之后，可以获得Charset的编码器和解码器，然后可以实现字节序列和字符序列的转换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CharsetTransform
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建简体中文对应的Charset&lt;/span&gt;
        Charset cn = Charset.forName(&quot;GBK&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取cn对象对应的编码器和解码器&lt;/span&gt;
        CharsetEncoder cnEncoder =&lt;span&gt; cn.newEncoder();
        CharsetDecoder cnDecoder &lt;/span&gt;=&lt;span&gt; cn.newDecoder();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个CharBuffer对象&lt;/span&gt;
        CharBuffer cbuff = CharBuffer.allocate(8&lt;span&gt;);
        cbuff.put(&lt;/span&gt;'孙'&lt;span&gt;);
        cbuff.put(&lt;/span&gt;'悟'&lt;span&gt;);
        cbuff.put(&lt;/span&gt;'空'&lt;span&gt;);
        cbuff.flip();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将CharBuffer中的字符序列转换成字节序列&lt;/span&gt;
        ByteBuffer bbuff =&lt;span&gt; cnEncoder.encode(cbuff);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环访问ByteBuffer中的每个字节&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; bbuff.capacity() ; i++&lt;span&gt;)
        {
            System.out.print(bbuff.get(i) &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将ByteBuffer的数据解码成字符序列&lt;/span&gt;
        System.out.println(&quot;\n&quot; +&lt;span&gt; cnDecoder.decode(bbuff));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Charset本身也提供了编码解码方法，如果仅需编码解码操作，可以直接使用，不必创建编码器和解码器对象。&lt;/p&gt;
&lt;p&gt;String的getBytes方法也是使用指定字符集将字符串转换成字节序列。&lt;/p&gt;
&lt;h3&gt;文件锁&lt;/h3&gt;
&lt;p&gt;如果多个程序需要并发修改同一个文件，程序需要某种机制来进行通信，使用文件锁可以有效地阻止多个进程并发修改同一个文件。&lt;/p&gt;
&lt;p&gt;文件锁控制文件的全部或部分字节的访问。在NIO中Java提供FileLock来支持文件锁定功能。&lt;/p&gt;
&lt;p&gt;lock()：对文件从position开始，长度为size的内容加锁，阻塞。&lt;/p&gt;
&lt;p&gt;tryLock()：非阻塞。&lt;/p&gt;
&lt;p&gt;当穿的shared参数是true时，表示这是共享锁，允许多个进程读取文件，但阻止其他进程获得对该文件的排它锁。&lt;/p&gt;
&lt;p&gt;直接使用lock() tryLock()获取文件锁就是排它锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileLockTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用FileOutputStream获取FileChannel&lt;/span&gt;
            FileChannel channel = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;a.txt&quot;&lt;span&gt;)
                .getChannel())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用非阻塞式方式对指定文件加锁&lt;/span&gt;
            FileLock lock =&lt;span&gt; channel.tryLock();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 程序暂停10s&lt;/span&gt;
            Thread.sleep(10000&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
&lt;span&gt;            lock.release();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;NIO.2&lt;/h2&gt;
&lt;p&gt;Java7 NIO.2对NIO进行了重大改进，主要包括：&lt;/p&gt;
&lt;p&gt;提供了全文见IO和文件系统访问支持。&lt;/p&gt;
&lt;p&gt;基于异步的Channel的IO。&lt;/p&gt;
&lt;h3&gt;Path、Paths、Files&lt;/h3&gt;
&lt;p&gt;Path接口代表和平台无关的平台路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PathTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以当前路径来创建Path对象&lt;/span&gt;
        Path path = Paths.get(&quot;.&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;path里包含的路径数量：&quot;
            +&lt;span&gt; path.getNameCount());
        System.out.println(&lt;/span&gt;&quot;path的根路径：&quot; +&lt;span&gt; path.getRoot());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取path对应的绝对路径。&lt;/span&gt;
        Path absolutePath =&lt;span&gt; path.toAbsolutePath();
        System.out.println(absolutePath);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取绝对路径的根路径&lt;/span&gt;
        System.out.println(&quot;absolutePath的根路径：&quot;
            +&lt;span&gt; absolutePath.getRoot());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取绝对路径所包含的路径数量&lt;/span&gt;
        System.out.println(&quot;absolutePath里包含的路径数量：&quot;
            +&lt;span&gt; absolutePath.getNameCount());
        System.out.println(absolutePath.getName(&lt;/span&gt;3&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以多个String来构建Path对象&lt;/span&gt;
        Path path2 = Paths.get(&quot;g:&quot; , &quot;publish&quot; , &quot;codes&quot;&lt;span&gt;);
        System.out.println(path2);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Files是一个操作文件的工具类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FilesTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制文件&lt;/span&gt;
        Files.copy(Paths.get(&quot;FilesTest.java&quot;&lt;span&gt;)
            , &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;a.txt&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断FilesTest.java文件是否为隐藏文件&lt;/span&gt;
        System.out.println(&quot;FilesTest.java是否为隐藏文件：&quot;
            + Files.isHidden(Paths.get(&quot;FilesTest.java&quot;&lt;span&gt;)));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一次性读取FilesTest.java文件的所有行&lt;/span&gt;
        List&amp;lt;String&amp;gt; lines =&lt;span&gt; Files.readAllLines(Paths
            .get(&lt;/span&gt;&quot;FilesTest.java&quot;), Charset.forName(&quot;gbk&quot;&lt;span&gt;));
        System.out.println(lines);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断指定文件的大小&lt;/span&gt;
        System.out.println(&quot;FilesTest.java的大小为：&quot;
            + Files.size(Paths.get(&quot;FilesTest.java&quot;&lt;span&gt;)));
        List&lt;/span&gt;&amp;lt;String&amp;gt; poem = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        poem.add(&lt;/span&gt;&quot;水晶潭底银鱼跃&quot;&lt;span&gt;);
        poem.add(&lt;/span&gt;&quot;清徐风中碧竿横&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接将多个字符串内容写入指定文件中&lt;/span&gt;
        Files.write(Paths.get(&quot;pome.txt&quot;&lt;span&gt;) , poem
            , Charset.forName(&lt;/span&gt;&quot;gbk&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Java 8新增的Stream API列出当前目录下所有文件和子目录&lt;/span&gt;
        Files.list(Paths.get(&quot;.&quot;)).forEach(path -&amp;gt;&lt;span&gt; System.out.println(path));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Java 8新增的Stream API读取文件内容&lt;/span&gt;
        Files.lines(Paths.get(&quot;FilesTest.java&quot;) , Charset.forName(&quot;gbk&quot;&lt;span&gt;))
            .forEach(line &lt;/span&gt;-&amp;gt;&lt;span&gt; System.out.println(line));
        FileStore cStore &lt;/span&gt;= Files.getFileStore(Paths.get(&quot;C:&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断C盘的总空间，可用空间&lt;/span&gt;
        System.out.println(&quot;C:共有空间：&quot; +&lt;span&gt; cStore.getTotalSpace());
        System.out.println(&lt;/span&gt;&quot;C:可用空间：&quot; +&lt;span&gt; cStore.getUsableSpace());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;使用FileVisitor遍历文件和目录：&lt;/h3&gt;
&lt;p&gt;FileVisitor代表一个文件访问器，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileVisitorTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历g:\publish\codes\15目录下的所有文件和子目录&lt;/span&gt;
        Files.walkFileTree(Paths.get(&quot;g:&quot;, &quot;publish&quot; , &quot;codes&quot; , &quot;15&quot;&lt;span&gt;)
            , &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SimpleFileVisitor&amp;lt;Path&amp;gt;&lt;span&gt;()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问文件时候触发该方法&lt;/span&gt;
&lt;span&gt;            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FileVisitResult visitFile(Path file
                , BasicFileAttributes attrs) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
            {
                System.out.println(&lt;/span&gt;&quot;正在访问&quot; + file + &quot;文件&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到了FileInputStreamTest.java文件&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (file.endsWith(&quot;FileInputStreamTest.java&quot;&lt;span&gt;))
                {
                    System.out.println(&lt;/span&gt;&quot;--已经找到目标文件--&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FileVisitResult.TERMINATE;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FileVisitResult.CONTINUE;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始访问目录时触发该方法&lt;/span&gt;
&lt;span&gt;            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FileVisitResult preVisitDirectory(Path dir
                , BasicFileAttributes attrs) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
            {
                System.out.println(&lt;/span&gt;&quot;正在访问：&quot; + dir + &quot; 路径&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FileVisitResult.CONTINUE;
            }
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;使用WatchService监控文件变化&lt;/h3&gt;
&lt;p&gt;以前的Java中，需要监控文件变化，可以考虑启动一个后台线程，每隔一段时间遍历一次指定目录，如果发现遍历结果和上次不同则认为文件发生了变化。&lt;/p&gt;
&lt;p&gt;WatchService&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WatchServiceTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取文件系统的WatchService对象&lt;/span&gt;
        WatchService watchService =&lt;span&gt; FileSystems.getDefault()
            .newWatchService();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为C:盘根路径注册监听&lt;/span&gt;
        Paths.get(&quot;C:/&quot;&lt;span&gt;).register(watchService
            , StandardWatchEventKinds.ENTRY_CREATE
            , StandardWatchEventKinds.ENTRY_MODIFY
            , StandardWatchEventKinds.ENTRY_DELETE);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取下一个文件改动事件&lt;/span&gt;
            WatchKey key = watchService.take();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (WatchEvent&amp;lt;?&amp;gt;&lt;span&gt; event : key.pollEvents())
            {
                System.out.println(event.context() &lt;/span&gt;+&quot; 文件发生了 &quot;
                    + event.kind()+ &quot;事件！&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重设WatchKey&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; valid =&lt;span&gt; key.reset();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果重设失败，退出监听&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;valid)
            {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;访问文件属性&lt;/h3&gt;
&lt;p&gt;NIO.2中提供了大量工具类，可以简单的读取修改文件属性&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AttributeViewTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取将要操作的文件&lt;/span&gt;
        Path testPath = Paths.get(&quot;AttributeViewTest.java&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取访问基本属性的BasicFileAttributeView&lt;/span&gt;
        BasicFileAttributeView basicView =&lt;span&gt; Files.getFileAttributeView(
            testPath , BasicFileAttributeView.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取访问基本属性的BasicFileAttributes&lt;/span&gt;
        BasicFileAttributes basicAttribs =&lt;span&gt; basicView.readAttributes();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问文件的基本属性&lt;/span&gt;
        System.out.println(&quot;创建时间：&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(basicAttribs
            .creationTime().toMillis()));
        System.out.println(&lt;/span&gt;&quot;最后访问时间：&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(basicAttribs
            .lastAccessTime().toMillis()));
        System.out.println(&lt;/span&gt;&quot;最后修改时间：&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(basicAttribs
            .lastModifiedTime().toMillis()));
        System.out.println(&lt;/span&gt;&quot;文件大小：&quot; +&lt;span&gt; basicAttribs.size());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取访问文件属主信息的FileOwnerAttributeView&lt;/span&gt;
        FileOwnerAttributeView ownerView =&lt;span&gt; Files.getFileAttributeView(
            testPath, FileOwnerAttributeView.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取该文件所属的用户&lt;/span&gt;
&lt;span&gt;        System.out.println(ownerView.getOwner());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取系统中guest对应的用户&lt;/span&gt;
        UserPrincipal user =&lt;span&gt; FileSystems.getDefault()
            .getUserPrincipalLookupService()
            .lookupPrincipalByName(&lt;/span&gt;&quot;guest&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用户&lt;/span&gt;
&lt;span&gt;        ownerView.setOwner(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取访问自定义属性的FileOwnerAttributeView&lt;/span&gt;
        UserDefinedFileAttributeView userView =&lt;span&gt; Files.getFileAttributeView(
            testPath, UserDefinedFileAttributeView.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;String&amp;gt; attrNames =&lt;span&gt; userView.list();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有的自定义属性&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name : attrNames)
        {
            ByteBuffer buf &lt;/span&gt;=&lt;span&gt; ByteBuffer.allocate(userView.size(name));
            userView.read(name, buf);
            buf.flip();
            String value &lt;/span&gt;=&lt;span&gt; Charset.defaultCharset().decode(buf).toString();
            System.out.println(name &lt;/span&gt;+ &quot;---&amp;gt;&quot; +&lt;span&gt; value) ;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一个自定义属性&lt;/span&gt;
        userView.write(&quot;发行者&quot;&lt;span&gt;, Charset.defaultCharset()
            .encode(&lt;/span&gt;&quot;疯狂Java联盟&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取访问DOS属性的DosFileAttributeView&lt;/span&gt;
        DosFileAttributeView dosView =&lt;span&gt; Files.getFileAttributeView(testPath
            , DosFileAttributeView.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将文件设置隐藏、只读&lt;/span&gt;
        dosView.setHidden(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        dosView.setReadOnly(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 21 Jun 2018 22:23:00 +0000</pubDate>
<dc:creator>谁将新樽辞旧月，今月曾经照古人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangwz/p/9193776.html</dc:identifier>
</item>
<item>
<title>什么是Docker并且它为什么这么受欢迎 - 学习会让你青春永驻</title>
<link>http://www.cnblogs.com/blackgan/p/9211574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blackgan/p/9211574.html</guid>
<description>&lt;h4 id=&quot;什么是docker-why-its-so-hot-than-hot&quot;&gt;什么是Docker (why it's so hot than hot)&lt;/h4&gt;
&lt;p&gt;Docker是一个使用容器来方便快捷的创建，部署，运行程序的工具，容器允许开发人员将应用程序的一切打包（镜像），例如库和其他的依赖项，并可以将这个包（镜像）发布出去。通过这样做，开发人员可以尽情将应用程序在其他linux 机器上运行，并且不用去考虑机器的各种配置的不同。&lt;/p&gt;
&lt;p&gt;另一方面，Docker有一点点像虚拟机，但是又不像虚拟机，相比于虚拟机，Docker不需要创建整个虚拟系统，Docker允许应用程序使用和当前所运行的操作系统相同的linux内核，也没有什么硬件虚拟。并且仅仅需要应用程序携带主机上没有的东西，这大大提升了性能并且减少了应用程序的大小&lt;/p&gt;
&lt;p&gt;最重要的是，Docker是一个开源项目，这意味着每一个人都可以给docker做贡献，并且可以去根据自己的需求扩展docker.&lt;/p&gt;
&lt;p&gt;总而言之，Docker是一个来帮我们抹平操作系统的配置、环境的差异，让我们的程序随心所欲的在各个系统快速跑起来的工具。&lt;/p&gt;
&lt;h4 id=&quot;docker是给哪些人使用的呢&quot;&gt;Docker是给哪些人使用的呢？&lt;/h4&gt;
&lt;p&gt;Docker是一个让开发人员和运维人员都会受益的一个工具，它已经成为了许多开发和运维人员的工具链中的一部分了。对于开发人员而言，这意味着我们不必再去操心程序最终运行的操作系统的环境等等各种配置了，我们只需要安心的专心的去写代码就行了。同时我们可以使用Docker给我们提供的一千多种的镜像，并且镜像中给我们的程序提供了一部分基础部分，这大大提升了我们的开发时构建项目的效率。对于运维同学而言，Docker提供了灵活性，并且由于docker的体积小、开销小。运维也可能不需要去维护特别多的系统了。&lt;/p&gt;
&lt;p&gt;所以说，开发人员和运维人员都可以来使用Docker。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;上述部分翻译自 &lt;a href=&quot;https://opensource.com/resources/what-docker&quot; class=&quot;uri&quot;&gt;https://opensource.com/resources/what-docker&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;docker中的重要组成部分&quot;&gt;Docker中的重要组成部分&lt;/h4&gt;
&lt;p&gt;Docker中包括了三个基本概念&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;镜像&lt;/li&gt;
&lt;li&gt;容器&lt;/li&gt;
&lt;li&gt;仓库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;镜像：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;镜像为容器的基础，镜像就是一堆只读层的视角&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容器：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;容器的定义和镜像差不多，容器也是一堆层的唯一视角，不同的是，容器最上边的一层是可读可写的。这里需要注意的是，容器并不是指运行态的容器，容器=镜像+读写层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;而与此对应的运行态的容器，就是独立的进程空间+运行的进程+可读写层，运行的进程对于文件进行的操作（增加，删除，修改等）针对的是可读写层，并且这个可读写层也是封闭的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仓库：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;仓库是存放镜像的场所&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于Docker的这三个基本概念，后续在对应的章节详解。&lt;/p&gt;
&lt;p&gt;文中如有错误，还请斧正！&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 16:27:00 +0000</pubDate>
<dc:creator>学习会让你青春永驻</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blackgan/p/9211574.html</dc:identifier>
</item>
<item>
<title>【python】python中的json、字典dict - AmyZYX</title>
<link>http://www.cnblogs.com/amyzhu/p/9211543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amyzhu/p/9211543.html</guid>
<description>&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;python中，json和dict非常类似，都是key-value的形式，而且json、dict也可以非常方便的通过dumps、loads互转。既然都是key-value格式，为啥还需要进行格式转换？&lt;/p&gt;
&lt;p&gt;json（JavaScript Object Notation）&lt;br/&gt;json：是一种数据格式，是纯字符串。可以被解析成Python的dict或者其他形式。&lt;/p&gt;
&lt;p&gt;dict：是一个完整的数据结构，是对Hash Table这一数据结构的一种实现，是一套从存储到提取都封装好了的方案。它使用内置的哈希函数来规划key对应value的存储位置，从而获得O（1）的数据读取速度。&lt;/p&gt;
&lt;h2 id=&quot;json和dict对比&quot;&gt;json和dict对比&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;json的key只能是字符串，python的dict可以是任何可hash对象（hashtable type）；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;json的key可以是有序、重复的；dict的key不可以重复。&lt;/li&gt;
&lt;li&gt;json的value只能是字符串、浮点数、布尔值或者null，或者它们构成的数组或者对象。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;json任意key存在默认值undefined，dict默认没有默认值；&lt;/li&gt;
&lt;li&gt;json访问方式可以是[],也可以是.，遍历方式分in、of；dict的value仅可以下标访问。&lt;/li&gt;
&lt;li&gt;json的字符串强制双引号，dict字符串可以单引号、双引号；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;dict可以嵌套tuple，json里只有数组。&lt;/li&gt;
&lt;li&gt;json:true、false、null&lt;/li&gt;
&lt;li&gt;python：True、False、None&lt;/li&gt;
&lt;li&gt;json中文必须是unicode编码，如&quot;\u6211&quot;.&lt;/li&gt;
&lt;li&gt;json的类型是字符串，字典的类型是字典。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;hashtable&quot;&gt;hashtable&lt;/h2&gt;
&lt;p&gt;一个对象当其声明周期内的hash值不发生改变，而且可以跟其他对象进行比较时，这个对象就是hashtable的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、python中的基本类型都是Hashtable，如str、bytes、数字类型、tuple等；  
2、用户自定义的类型默认都是hashtable，因为它们的hash值就是id()值；  
3、frozenset始终都是hashtable的，因为它们所有的项目都是被定义成hashtable的；  
4、只有当tuple内的所有项都是hashtable的时候，tuple才是hashtable；&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 21 Jun 2018 16:10:00 +0000</pubDate>
<dc:creator>AmyZYX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amyzhu/p/9211543.html</dc:identifier>
</item>
<item>
<title>canvas之fillStyle - WuMon</title>
<link>http://www.cnblogs.com/wumon/p/9211486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wumon/p/9211486.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.runoob.com/tags/ref-canvas.html&quot; target=&quot;_blank&quot;&gt;菜鸟canvas&lt;/a&gt;  &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  cvs = document.getElementById(&quot;canvas&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  ctx = cvs.getContext(&quot;2d&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ctx.fillStyle = &lt;span&gt;wumon&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;　　那么这里的&lt;span&gt;wumon&lt;/span&gt;是什么呢？&lt;/p&gt;
&lt;p&gt;　　ctx.fillStyle = color | grdient | pattern;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;color&lt;/span&gt;，十六进制、rgb、rgba、HSL、HSLA······。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;gradient&lt;/span&gt;，有两种：&lt;/p&gt;
&lt;p&gt;　　　　线性：ctx.createLinearGradient(x,y,x1,y1);其中x、y为渐变开始的坐标，x1、y1为渐变结束时坐标;&lt;/p&gt;
&lt;p&gt;　　　　放射：ctx.createRadialGradient(x,y,r,x1,y1,r1);其中x、y、r为渐变开始坐标及半径，x1、y1、r1为渐变结束坐标及半径;&lt;/p&gt;
&lt;p&gt;　　　　同时还有一个addColorStop(stop,color);用来配合渐变使用，stop为0.0-1.0之间值，color为stop颜色，addColorStop可多次调用来调节渐变。&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;p&gt;　　　　　　　var linear = ctx.createLinearGradient(x,y,x1,y1);&lt;/p&gt;
&lt;p&gt;　　　　　　　linear.addColorStop(0,&quot;red&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　　linear.addColorStop(1,&quot;blue&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　　ctx.fillStyle = linear;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;pattern&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　　　ctx.createPattern(imageEle,&quot;repeat&quot; | &quot;repeat-x&quot; | &quot;repeat-y&quot; | &quot;no-repeat&quot;);&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;p&gt;　　　　　　var img = document.getElementById(&quot;img&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　var pat = ctx.createPattern(img,&quot;repeat&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　ctx.fillStyle = pat;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 15:42:00 +0000</pubDate>
<dc:creator>WuMon</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wumon/p/9211486.html</dc:identifier>
</item>
<item>
<title>Java关键字(四)——final - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9202015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9202015.html</guid>
<description>&lt;p&gt;　　对于Java中的 final 关键字，我们首先可以从字面意思上去理解，百度翻译显示如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621080149078-282773135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也就是说 final 英文意思表示是最后的，不可更改的。那么对应在 Java 中也是表达这样的意思，可以用 final 关键字修饰变量、方法和类。不管是用来修饰什么，其本意都是指 “它是无法更改的”，这是我们需要牢记的，为什么要无法更改？无非就是设计所需或者能提高效率，与前面介绍 static 关键字需要记住其与对象无关的理念一样，牢记 final 的不可变的设计理念后再来了解 final 关键字的用法，便会顺其自然了。&lt;/p&gt;
&lt;h3&gt;1、修饰变量&lt;/h3&gt;
&lt;p&gt;　　稍微有点Java基础的都知道用final关键字修饰的变量称为常量，常量的意思是不可更改。变量为基本数据类型，不可更改很容易理解，那么对于引用类型呢？不可能改的是其引用地址，还是对象的内容？&lt;/p&gt;
&lt;p&gt;　　我们首先构造一个实体类：Person&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('04b5c81c-dbb8-464a-b309-dd77c561c953')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_04b5c81c-dbb8-464a-b309-dd77c561c953&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04b5c81c-dbb8-464a-b309-dd77c561c953&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('04b5c81c-dbb8-464a-b309-dd77c561c953',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_04b5c81c-dbb8-464a-b309-dd77c561c953&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String name;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　接着根据创建一个 Person 对象：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621203318523-67929805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，首先通过 final 关键字修饰一个对象 p，然后接着将 p 对象指向另一个新的对象，发现报错，也就是说final修饰的引用类型是不能改变其引用地址的。&lt;/p&gt;
&lt;p&gt;　　接着我们改动 p 对象的 name 属性：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621203519749-361874978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　发现程序没有报错。&lt;/p&gt;
&lt;p&gt;　　结论：被 final 修饰的变量不可更改其引用地址，但是可以更改其内部属性。&lt;/p&gt;
&lt;h3&gt;2、修饰方法&lt;/h3&gt;
&lt;p&gt;　　final 关键字修饰的方法不可被覆盖。&lt;/p&gt;
&lt;p&gt;　　在《Java编程思想》第 4 版 7.8.2 章节 final 方法p176 页这样描述：使用 final 方法原因有两个：&lt;/p&gt;
&lt;p&gt;　　①、第一个原因是把方法锁定，以防止任何继承类修改它的含义，这是出于设计的考虑：想要确保在继承中使方法的行为保持不变，并且不会被覆盖。&lt;/p&gt;
&lt;p&gt;　　②、第二个原因是效率，在 Java 的早期实现中，如果将一个方法声明为 final，就是同意编译器将针对该方法的所有调用都转为内嵌调用，内嵌调用能够提高方法调用效率，但是如果方法很大，内嵌调用不会提高性能。而在目前的Java版本中（JDK1.5以后），虚拟机可以自动进行优化了，而不需要使用 final 方法。&lt;/p&gt;
&lt;p&gt;　　所以&lt;strong&gt;final 关键字只有明确禁止覆盖方法时，才使用其修饰方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　PS：《Java编程思想》中指出类中所有的 private 方法都隐式指定为 final 的，所以对于 private 方法，我们显式的声明 final 并没有什么效果。但是我们创建一个父类，并在父类中声明一个 private 方法，其子类中是能够重写其父类的private 方法的，这是为什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　父类：Parent.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Create by YSOcean
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
        System.out.println(&lt;/span&gt;&quot;parent&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　子类：Son.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Create by YSOcean
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Parent {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
        System.out.println(&lt;/span&gt;&quot;son&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实仔细看看，这种写法是方法的覆盖吗？我们通过多态的形式并不能调用到父类的 say() 方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621210117804-1988915508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　并且，如果我们在子类的 say() 方法中，添加 @Override 注解也是会报错的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621210206647-794954558.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　所以这种形式并不算方法的覆盖。&lt;/p&gt;
&lt;h3&gt;3、修饰类&lt;/h3&gt;
&lt;p&gt;　　final 修饰类表示该类不可被继承。&lt;/p&gt;
&lt;p&gt;　　也就是说不希望某个类有子类的时候，用final 关键字来修饰。并且由于是用 final 修饰的类，其类中所有的方法也被隐式的指为 final 方法。&lt;/p&gt;
&lt;p&gt;　　在 JDK 中有个最明显的类 String ，就是用 final 修饰的，将 String 类用 final 修饰很重要的一个原因是常量池。关于 String 类的描述，可以&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8571426.html&quot; target=&quot;_blank&quot;&gt;参考我的这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621210937598-1783125709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 15:36:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9202015.html</dc:identifier>
</item>
<item>
<title>.Net Core小技巧 - Swagger适配虚拟目录及二级目录 - 编程玩家</title>
<link>http://www.cnblogs.com/Erik_Xu/p/9195803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erik_Xu/p/9195803.html</guid>
<description>&lt;p&gt;　　随着前后端分离模式与微服务架构的出现，Web API变得越来越重要及普遍。而后出现的网关技术，使开发者更倾向于使用二级/多级目录来暴露Web API，一是暴露的端口更少，方便管理；二是在网关中可以处理一些公共的事务，如认证。但swagger默认是适配根（root）目录的，想要适配二级/多级目录，需要额外处理，同时还要区分开发环境与其它环境。一种思路是在开发环境就让Web API是处于二级目录，此时可以在本机通过nginx和iis虚拟目录来模拟，但这种思路明显略微麻烦。另一种思路是通过配置多环境的方式实现。&lt;/p&gt;


&lt;p&gt;1. 安装Swagger&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Swashbuckle.AspNetCore
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.  配置Swagger服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.AddSwaggerGen(c =&amp;gt;&lt;span&gt;
{
    c.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. 配置swagger中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; virtualPath = Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;virtualPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

app.UseSwagger(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    c.PreSerializeFilters.Add((swaggerDoc, httpReq) &lt;/span&gt;=&amp;gt; swaggerDoc.BasePath =&lt;span&gt; virtualPath);
});

app.UseSwaggerUI(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    c.SwaggerEndpoint(virtualPath &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API V1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    c.RoutePrefix &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. 配置appsettings.json&lt;/p&gt;
&lt;p&gt;在appsettings.json中添加virtualPath的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;virtualPath&quot;: &quot;/sg&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设二级目录或虚拟目录是/sg&lt;/span&gt;
  &quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IncludeScopes&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;Debug&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Default&quot;: &quot;Warning&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;Console&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Default&quot;: &quot;Warning&quot;&lt;span&gt;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在appsettings.Development.json中添加virtualPath的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;virtualPath&quot;: &quot;&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用根目录&lt;/span&gt;
  &quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IncludeScopes&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;Default&quot;: &quot;Debug&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;System&quot;: &quot;Information&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;Microsoft&quot;: &quot;Information&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1. 开发环境测试&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180618192259870-718003380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180618192400511-1121668063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 模拟生产环境测试&lt;/p&gt;
&lt;p&gt;修改launchSettings.json，改变环境变量参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180618192727472-2011656542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180621225603674-1509635474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;准备nginx.conf，并启动nginx。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
worker_processes  1&lt;span&gt;;

events {
    worker_connections  &lt;/span&gt;1024&lt;span&gt;;
}

http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-stream;
&lt;span&gt;    sendfile        on;
    keepalive_timeout  &lt;/span&gt;65&lt;span&gt;;

    server {
        listen       &lt;/span&gt;80&lt;span&gt;;
        server_name  localhost;

        location &lt;/span&gt;/sg/&lt;span&gt; {
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:30925/;  &lt;/span&gt;
&lt;span&gt;            
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;访问二级目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180621225942064-2047527546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　本文涉及的代码并不多，主要想表达的是设计思路，以及对多环境的处理方案，不得不说的是，.Net Core在环境适配以及其它方面的设计都十分优秀。&lt;/p&gt;
&lt;p&gt;　　二级目录适配虽然是个很小的问题，但是却是微服务实践中一个很常见的问题。&lt;/p&gt;
&lt;p&gt;　　二级目录适配能否自动适配而非配置适配，也是一个值得思考的问题。　　&lt;/p&gt;


&lt;p&gt;　　&lt;a href=&quot;https://github.com/ErikXu/.NetCoreTips/tree/master/SwaggerVirtualPath&quot; target=&quot;_blank&quot;&gt;https://github.com/ErikXu/.NetCoreTips/tree/master/SwaggerVirtualPath&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 15:24:00 +0000</pubDate>
<dc:creator>编程玩家</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Erik_Xu/p/9195803.html</dc:identifier>
</item>
<item>
<title>jq选择器 - 所爱隔山隔海</title>
<link>http://www.cnblogs.com/zhengleilei/p/9211392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengleilei/p/9211392.html</guid>
<description>&lt;p&gt;                          基本选择器&lt;br/&gt;    1.获取唯一id:$(&quot;#&quot;)&lt;br/&gt;    $(&quot;#myid&quot;).css(&quot;color&quot;,&quot;blue&quot;);&lt;br/&gt;    2.获取所有class:$(&quot;.&quot;)&lt;br/&gt;    $(&quot;.class&quot;).css(&quot;color&quot;,&quot;yellow&quot;);&lt;br/&gt;    3.获取所有元素:$(&quot;*&quot;)&lt;br/&gt;    $(&quot;*&quot;).css(&quot;color&quot;,&quot;green&quot;);&lt;br/&gt;    4.获取所有标签:$(&quot;标签&quot;)&lt;br/&gt;    $(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    5.获取同时满足两个选择器的元素:$(&quot;选择器1选择器2&quot;)&lt;br/&gt;   $(&quot;#id,.class&quot;).css(&quot;color&quot;,&quot;orange&quot;);&lt;br/&gt;                                层叠选择器&lt;br/&gt;    1.父元素中包含的所有元素:($&quot;选择器1  选择器2&quot;)&lt;br/&gt;     $(&quot;#second .second&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    2.父元素的子元素:($&quot;选择器1&amp;gt;选择器2&quot;)&lt;br/&gt;     $(&quot;#second&amp;gt;div&quot;).css(&quot;color&quot;,&quot;grey&quot;);&lt;br/&gt;    3.相邻的下一个兄弟元素:$(&quot;选择器1+选择器2&quot;)&lt;br/&gt;      $(&quot;h2+h3&quot;).css(&quot;color&quot;,&quot;orange&quot;);&lt;br/&gt;    4.后面的所有兄弟元素&lt;br/&gt;    $(&quot;#as1~div&quot;).css(&quot;color&quot;,&quot;orange&quot;);&lt;br/&gt;                            方法选择器&lt;br/&gt;    1.符合条件的第一个元素&lt;br/&gt;    $(&quot;.first:first&quot;).css(&quot;color&quot;,&quot;yellow&quot;);&lt;br/&gt;    2.符合条件的最后一个元素&lt;br/&gt;    $(&quot;.first:last&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    3.符合条件的索引为偶数的元素&lt;br/&gt;    $(&quot;.first:even&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    4.符合条件的索引为奇数的元素&lt;br/&gt;    $(&quot;.first:odd&quot;).css(&quot;color&quot;,&quot;green&quot;);   &lt;br/&gt;    5.符合条件的索引值元素&lt;br/&gt;       $(&quot;.first:eq(0)&quot;).css(&quot;color&quot;,&quot;greenyellow&quot;);&lt;br/&gt;    6.符合条件的大于索引值的元素&lt;br/&gt;       $(&quot;.first:gt(0)&quot;).css(&quot;color&quot;,&quot;blue&quot;);&lt;br/&gt;    7.符合条件的小于索引值的元素    &lt;br/&gt;     $(&quot;.first:lt(1)&quot;).css(&quot;color&quot;,&quot;green&quot;);&lt;br/&gt;    8.获取满足第一个条件且不满(满足)足第二个条件(empty、checked...)的元素:$(&quot;选择器:条件&quot;)&lt;br/&gt;    $(&quot;div:not(empty)&quot;).css(&quot;background&quot;,&quot;yellow&quot;);&lt;br/&gt;    $(&quot;div:empty&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;    9.所有标题元素&lt;br/&gt;    $(&quot;:header&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;    10.所有动画元素&lt;br/&gt;    $(&quot;:animated&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;    11.包含指定字符串的所有元素&lt;br/&gt;    $(&quot;div:contains('child')&quot;).css(&quot;width&quot;,&quot;500px&quot;);&lt;br/&gt;    12.所有带有匹配选择的元素&lt;br/&gt;    $(&quot;h5,.child_child,#myid&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;             属性选择器&lt;br/&gt;    1.属性等于属性值的元素&lt;br/&gt;    $(&quot;[href='#']&quot;);&lt;br/&gt;    2.属性不等于属性值的元素&lt;br/&gt;    $(&quot;[href!='#']&quot;);&lt;br/&gt;    3.属性以属性值结尾的元素&lt;br/&gt;    $(&quot;[href$='.jpg']&quot;);&lt;br/&gt;    4.带有某属性的元素&lt;br/&gt;    $(&quot;[href]&quot;);&lt;br/&gt;            表单选择器&lt;br/&gt;    1.所有input元素&lt;br/&gt;    $(&quot;:input&quot;);&lt;br/&gt;    2.通过input的类型选则元素&lt;br/&gt;    $(&quot;:text&quot;);文字框&lt;br/&gt;    $(&quot;:password&quot;);密码框&lt;br/&gt;    $(&quot;:radio&quot;);单选框&lt;br/&gt;    $(&quot;:checkbox&quot;);复选框&lt;br/&gt;    $(&quot;:submit&quot;);提交按钮&lt;br/&gt;    $(&quot;:buttom&quot;);普通按钮&lt;br/&gt;    $(&quot;:reset&quot;);重置按钮&lt;br/&gt;    $(&quot;:image&quot;);图片按钮&lt;br/&gt;    $(&quot;:file&quot;);上传文件&lt;br/&gt;    3.通过input的状态选则元素&lt;br/&gt;    $(&quot;:endabled&quot;);所有激活的input元素&lt;br/&gt;    $(&quot;:disable&quot;);所有禁用的input元素&lt;br/&gt;    $(&quot;:selecte&quot;);所有被选取的input元素&lt;br/&gt;    $(&quot;:checked&quot;);所有被选中的input元素&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 15:14:00 +0000</pubDate>
<dc:creator>所爱隔山隔海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhengleilei/p/9211392.html</dc:identifier>
</item>
<item>
<title>JAVA | 学生选课系统 - M-William</title>
<link>http://www.cnblogs.com/mz-xiansheng/p/9211383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mz-xiansheng/p/9211383.html</guid>
<description>&lt;p&gt;这里使用JAVA语言编写的简易的学生选课系统，展现的都是这个系统核心代码。&lt;/p&gt;
&lt;p&gt;其中有不足欢迎批评和指正！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;链接数据库的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;package connection;&lt;br/&gt;//连接数据库student&lt;/p&gt;
&lt;p&gt;import java.sql.Connection;&lt;br/&gt;import java.sql.DriverManager;&lt;br/&gt;//import java.sql.Statement;&lt;br/&gt;import java.sql.SQLException;&lt;/p&gt;
&lt;p&gt;public class xu{&lt;/p&gt;&lt;p&gt;private static Connection conn = null;&lt;br/&gt;static {&lt;br/&gt;try {&lt;br/&gt;// 注册驱动&lt;br/&gt;Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;);&lt;br/&gt;// 获得一个数据库连接&lt;br/&gt;conn = DriverManager.getConnection(&quot;jdbc:sqlserver://localhost:1433;DatabaseName=student&quot;,&quot;sa&quot;,&quot;123456&quot;);&lt;br/&gt;}catch(ClassNotFoundException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} catch (SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static Connection getConnection() {&lt;br/&gt;return conn;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;选课的操作代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;package connection;&lt;/p&gt;
&lt;p&gt;import java.sql.*;&lt;br/&gt;import java.util.*;&lt;/p&gt;
&lt;p&gt;public class test1{&lt;/p&gt;&lt;p&gt;private static String ID; // 此处的ID设为全局变量，在下面某些方法里会用到&lt;br/&gt;private static Scanner console = new Scanner(System.in);&lt;br/&gt;private static String managerPass = &quot;123456&quot;;&lt;br/&gt;private static Connection conn = xu.getConnection();&lt;/p&gt;&lt;p&gt;public static void main(String [] args) throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Welcome to the student selection system!\n\n&quot;&lt;br/&gt;+&quot;if you are maneger please choose 6、7、8、9、10\n&quot;&lt;br/&gt;+&quot;if you are student Please choose 1、2、3、4、5、10\n&quot;);&lt;br/&gt;ShowMenu();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void ShowMenu() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;-----------option-------------\n&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;1--Student login&quot;); // 学生登录&lt;br/&gt;System.out.println(&quot;2--Change password&quot;); // 学生修改密码&lt;br/&gt;System.out.println(&quot;3--Choose course&quot;); // 学生选课&lt;br/&gt;System.out.println(&quot;4--Get course list&quot;); // 学生查看自己的课程表&lt;br/&gt;System.out.println(&quot;5--Student rigistration&quot;); // 学生注册账号&lt;br/&gt;System.out.println(&quot;6--Create student&quot;); // 管理员创建学生&lt;br/&gt;System.out.println(&quot;7--Create course&quot;); // 管理员创建课表&lt;br/&gt;System.out.println(&quot;8--Get student list&quot;); // 管理员查看学生表&lt;br/&gt;System.out.println(&quot;9--Get course list1&quot;); // 管理员查看选课表里的课程&lt;br/&gt;System.out.println(&quot;10--exit\n&quot;); // 退出&lt;/p&gt;&lt;p&gt;Test();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void Test() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;manager choose 1 ,student choose 0&quot;);&lt;br/&gt;int choose1 = console.nextInt(); //int 用nextInt()&lt;/p&gt;&lt;p&gt;if(choose1 == 1) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your password :&quot;);&lt;br/&gt;String password = console.next(); //String 用next()&lt;/p&gt;&lt;p&gt;if(password.equals(managerPass)) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Welcome manager!\n&quot;);&lt;br/&gt;ManagerMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Your password is worry!&quot;); }&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else if(choose1 == 0) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Welcome Student!&quot;);&lt;br/&gt;StudentMenu1();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*管理员操作菜单*/&lt;br/&gt;public static void ManagerMenu1() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;----------Manager----------\n&quot;);&lt;br/&gt;System.out.println(&quot;Please choose option&quot;);&lt;br/&gt;int choose2 = console.nextInt();&lt;/p&gt;&lt;p&gt;switch(choose2) {&lt;/p&gt;&lt;p&gt;case 1 :&lt;br/&gt;case 2 :&lt;br/&gt;case 3 :&lt;br/&gt;case 4 :&lt;br/&gt;case 5 :&lt;br/&gt;System.out.println(&quot;This is student`s option,try again!&quot;);&lt;br/&gt;ManagerMenu1();&lt;br/&gt;break;&lt;br/&gt;case 6 : CreateStu();break;&lt;br/&gt;case 7 : CreateCourse();break;&lt;br/&gt;case 8 : GetStudentList();break;&lt;br/&gt;case 9 : GetCourseList1();break;&lt;br/&gt;case 10 : System.exit(0);break;&lt;br/&gt;default : System.out.println(&quot;Please input an right number , try again!&quot;); ManagerMenu1();&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生操作菜单*/&lt;br/&gt;public static void StudentMenu1() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;----------Student----------\n&quot;);&lt;br/&gt;System.out.println(&quot;Please input option&quot;);&lt;br/&gt;int choose3 = console.nextInt();&lt;/p&gt;&lt;p&gt;switch(choose3) {&lt;/p&gt;&lt;p&gt;case 1 : StuLogin();break;&lt;br/&gt;case 2 : ChangePass();break;&lt;/p&gt;&lt;p&gt;//在进行Choose course,Get course list之前都要求学生进行StuLogin操作&lt;/p&gt;&lt;p&gt;case 3 :&lt;br/&gt;case 4 : System.out.println(&quot;you must login before you can do it!\n&quot;);StuLogin();break;&lt;br/&gt;case 5 : StuRigistration();break;&lt;br/&gt;case 6 :&lt;br/&gt;case 7 :&lt;br/&gt;case 8 :&lt;br/&gt;case 9 : System.out.println(&quot;This is manager`s option,try again!&quot;);StudentMenu1();break;&lt;br/&gt;case 10 : System.exit(0);break;&lt;br/&gt;default : System.out.println(&quot;Please input an right number,try again!&quot;);StudentMenu1();&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;/*管理员创建课程*/&lt;br/&gt;public static void CreateCourse() throws SQLException{&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;/* 通过connection数据库链接对象 创建一个statement对象数据库操作对象,stat对象再获取一个执行sql的语句。&lt;br/&gt;* stat对象就是java程序与Database的一个连接通道*/&lt;/p&gt;&lt;p&gt;Statement stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;insert into course(couID,couName,couTeacher)values(1,'软件工程','黄伟国')&quot;;&lt;br/&gt;String sql2 = &quot;insert into course(couID,couName,couTeacher)values(2,'数据库','韦美雁')&quot;;&lt;br/&gt;String sql3 = &quot;insert into course(couID,couName,couTeacher)values(3,'算法设计','黎明')&quot;;&lt;br/&gt;String sql4 = &quot;insert into course(couID,couName,couTeacher)values(4,'大学英语','章琴')&quot;;&lt;br/&gt;String sql5 = &quot;insert into course(couID,couName,couTeacher)values(5,'Java','唐雅媛')&quot;;&lt;/p&gt;&lt;p&gt;int a = stat.executeUpdate(sql1);&lt;br/&gt;int b = stat.executeUpdate(sql2);&lt;br/&gt;int c = stat.executeUpdate(sql3);&lt;br/&gt;int d = stat.executeUpdate(sql4);&lt;br/&gt;int e = stat.executeUpdate(sql5);&lt;/p&gt;&lt;p&gt;int sum = a + b + c + d + e;&lt;br/&gt;System.out.println(&quot;成功添加&quot;+ sum + &quot;行课程数据&quot;);&lt;br/&gt;ManagerMenu1();&lt;/p&gt;&lt;p&gt;} catch (SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;// e.printStackTrace();&lt;br/&gt;System.out.println(&quot;Course already exists&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*管理员创建学生*/&lt;br/&gt;public static void CreateStu() throws SQLException {&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;Statement stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;insert into student(stuID,stuName) Values(20160501,'徐明正')&quot;;&lt;/p&gt;&lt;p&gt;// 这里对学生信息的输入也必须一个一个输入，这是系统的缺陷，问题待解决&lt;/p&gt;&lt;p&gt;int a = stat.executeUpdate(sql1);&lt;br/&gt;System.out.println(&quot;成功添加&quot;+ a + &quot;行学生数据&quot;);&lt;br/&gt;ManagerMenu1();&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;System.out.println(&quot;The student already exists&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生登录*/&lt;br/&gt;public static void StuLogin() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your stuID&quot;); // 输入账号&lt;br/&gt;ID = console.next();&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your Password&quot;); // 输入密码&lt;br/&gt;String stuPassword = console.next();&lt;/p&gt;&lt;p&gt;String stuID = null;&lt;br/&gt;String Password = null;&lt;/p&gt;&lt;p&gt;Statement stat ;&lt;br/&gt;ResultSet rs ;&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;select * from login &quot;; /* 从login表中查询其所有属性值，则stuID 和 Password都有了。&lt;br/&gt;rs是结果集。查询出的记录是一个列表，初始时指针指向的是第一条记录之前的。*/&lt;br/&gt;boolean flag;&lt;br/&gt;rs = stat.executeQuery(sql1);&lt;/p&gt;&lt;p&gt;while(flag = rs.next()) { // rs.next(); //返回值为true or false&lt;/p&gt;&lt;p&gt;stuID = rs.getString(&quot;stuID&quot;);&lt;br/&gt;Password = rs.getString(&quot;Password&quot;);&lt;/p&gt;&lt;p&gt;if( ID.equals(stuID) &amp;amp;&amp;amp; stuPassword.equals(Password)) // 注意这里，跳出循环的条件很重要&lt;/p&gt;&lt;p&gt;break;&lt;/p&gt;&lt;p&gt;// 如果在数据库里没有找到与用户输入的stuID和Password相匹配的stuID和Password,flag则变为false&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if(!flag){ // 当flag 为 false 时&lt;/p&gt;&lt;p&gt;System.out.println(&quot;The ID or Password is worry!Please input your ID and Password again\n&quot;);&lt;br/&gt;StuLogin();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else {&lt;br/&gt;System.out.println(&quot;***&quot;+ID+&quot;***&quot;+stuID +&quot;***&quot;+stuPassword+&quot;***&quot;+Password+&quot;***&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Login Successful!\n&quot;);&lt;br/&gt;System.out.println(&quot;------------------Please choose option------------------\n&quot;&lt;br/&gt;// +&quot;If you want to Change Password ,Please choose 2\n&quot;&lt;br/&gt;+&quot;If you want to Choose Course,Please choose 3\n&quot;+&quot;If you want to Get Course List,Please choose 4\n&quot;&lt;br/&gt;+&quot;If you want to exit ,Please choose 8\n&quot;);&lt;/p&gt;&lt;p&gt;int choose4 = console.nextInt();&lt;/p&gt;&lt;p&gt;switch(choose4) {&lt;/p&gt;&lt;p&gt;// case 2 : ChangePass();break;&lt;br/&gt;case 3 : ChooseCourse();break;&lt;br/&gt;case 4 : GetCourseList();break;&lt;br/&gt;case 10 : System.exit(0);break;&lt;br/&gt;default : System.out.println(&quot;You input an invalid number!&quot;);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;} catch (SQLException e) {&lt;/p&gt;&lt;p&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;/*在这里说明一下 方法execute 、executeQuery、executeUpdate三者的区别&lt;br/&gt;* 方法executeQuery 用于单个结果集的语句，如select。他会把查询的结果放入ResultSet类对象中供使用。&lt;br/&gt;* 方法executeUpdate 用于执行insert、update或delete语句&amp;lt;返回值为整数&amp;gt;以及SQL DDL（数据定义语言），如create table 和 drop table &amp;lt;返回值为零&amp;gt;。&lt;br/&gt;* 方法execute 用于执行返回多个结果集、多个更新计数或二者组合的语句。*/&lt;/p&gt;&lt;p&gt;/*学生修改密码*/&lt;br/&gt;public static void ChangePass() throws SQLException {&lt;/p&gt;&lt;p&gt;// System.out.println(ID);&lt;/p&gt;&lt;p&gt;/*此处的ID应该必须要重新输入，否则当选择对数据库中某个ID更新的Password进行修改时，没有对应的ID*/&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your ID&quot;);&lt;br/&gt;String ID = console.next();&lt;br/&gt;System.out.println(&quot;Please input your new Password&quot;);&lt;br/&gt;String NewPassword = console.next();&lt;/p&gt;&lt;p&gt;Statement stat ;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement(); // 两种写法都可以&lt;br/&gt;// stat = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);&lt;br/&gt;String sql =&quot;UPDATE login SET Password =&quot; + &quot;&quot; + NewPassword + &quot; where stuID =&quot;+ ID;&lt;/p&gt;&lt;p&gt;//注意，此处的NewPassword 和 ID 没有要用''括起来&lt;/p&gt;&lt;p&gt;// String sql1 =&quot;UPDATE login SET Password = 111 where stuID = 20156022&quot;;&lt;/p&gt;&lt;p&gt;int a = stat.executeUpdate(sql);&lt;br/&gt;System.out.println(a);&lt;/p&gt;&lt;p&gt;if(a != 0) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;成功修改&quot;+a+&quot;行记录&quot;);&lt;br/&gt;System.out.println(&quot;Your new Password is &quot;+ NewPassword);&lt;/p&gt;&lt;p&gt;StudentMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else System.out.println(&quot;\n&quot;+&quot;Changing the Password is failed!&quot;);&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;/p&gt;&lt;p&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;/*学生选课*/&lt;br/&gt;public static void ChooseCourse() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(ID);&lt;br/&gt;String couID = null;&lt;br/&gt;String couName = null;&lt;br/&gt;String couTeacher = null;&lt;/p&gt;&lt;p&gt;Statement stat;&lt;br/&gt;ResultSet rs;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from course&quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;--------可选课程的信息-------&quot;);&lt;br/&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;couID = rs.getString(&quot;couID&quot;);&lt;br/&gt;couName = rs.getString(&quot;couName&quot;);&lt;br/&gt;couTeacher = rs.getString(&quot;couTeacher&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(couID + &quot; &quot; + couName + &quot; &quot; + couTeacher);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n Please choose your course \n&quot;);&lt;/p&gt;&lt;p&gt;stat= conn.createStatement();&lt;/p&gt;&lt;p&gt;// 此处stuID固定位学生登录时所用的ID,这样可以保证登录自己的账号却能选别的账号的课程&lt;/p&gt;&lt;p&gt;System.out.println(&quot;input CourseID&quot;);&lt;br/&gt;int ID1 = console.nextInt();&lt;br/&gt;int ID2 = console.nextInt();&lt;br/&gt;int ID3 = console.nextInt();&lt;/p&gt;&lt;p&gt;// 这样写 ，学生选课的数目必须固定为3门，问题待解决&lt;/p&gt;&lt;p&gt;String sql1 = &quot;insert into stuCourse(stuID,couID1,couID2,couID3)VALUES(&quot; + ID + &quot;,&quot;+ ID1 + &quot;,&quot; + ID2 + &quot;,&quot; +ID3 +&quot;)&quot;;&lt;br/&gt;int i = stat.executeUpdate(sql1);&lt;/p&gt;&lt;p&gt;if(i != 0) {&lt;br/&gt;System.out.println(&quot;成功选入课程&quot;);&lt;/p&gt;&lt;p&gt;GetCourseList();&lt;br/&gt;}&lt;br/&gt;else System.out.println(&quot;选课错误&quot;);&lt;/p&gt;&lt;p&gt;} catch (SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生获取已选课程列表*/&lt;br/&gt;public static void GetCourseList() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\nHere is your course that you have choose\n&quot;);&lt;/p&gt;&lt;p&gt;Statement stat = null;&lt;br/&gt;ResultSet rs = null;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from stuCourse &quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;String stuID = null;&lt;br/&gt;String couID1 = null;&lt;br/&gt;String couID2 = null;&lt;br/&gt;String couID3 = null;&lt;br/&gt;String couID4 = null;&lt;/p&gt;&lt;p&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;stuID = rs.getString(&quot;stuID&quot;);&lt;br/&gt;couID1 = rs.getString(&quot;couID1&quot;);&lt;br/&gt;couID2 = rs.getString(&quot;couID2&quot;);&lt;br/&gt;couID3 = rs.getString(&quot;couID3&quot;);&lt;br/&gt;couID4 = rs.getString(&quot;couID4&quot;);&lt;/p&gt;&lt;p&gt;if(stuID.equals(ID))&lt;/p&gt;&lt;p&gt;System.out.println(stuID + &quot; &quot; + couID1 + &quot; &quot; + couID2 + &quot; &quot; + couID3 + &quot; &quot; + couID4 + &quot;\n&quot;);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生注册*/&lt;br/&gt;public static void StuRigistration() throws SQLException{&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your ID &quot;);&lt;br/&gt;String ID = console.next();&lt;br/&gt;System.out.println(&quot;Please input your Password&quot;);&lt;br/&gt;String Password = console.next();&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;Statement stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;insert into login(stuID,Password)Values(&quot; + ID + &quot;, &quot; + Password + &quot;)&quot;;&lt;br/&gt;//这里密码只能输入数字,问题待解决&lt;/p&gt;&lt;p&gt;int a = stat .executeUpdate(sql1);&lt;br/&gt;System.out.println(&quot;成功注册&quot;+ a +&quot;个账号&quot;);&lt;/p&gt;&lt;p&gt;StudentMenu1();&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;System.out.println(&quot;ID already exists&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 管理员查看学生表 */&lt;br/&gt;public static void GetStudentList() {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n Here is student` information \n&quot;);&lt;/p&gt;&lt;p&gt;Statement stat = null;&lt;br/&gt;ResultSet rs = null;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from student &quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;String stuID = null;&lt;br/&gt;String stuName = null;&lt;/p&gt;
&lt;p&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;stuID = rs.getString(&quot;stuID&quot;);&lt;br/&gt;stuName= rs.getString(&quot;stuName&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(stuID + &quot; &quot; + stuName + &quot;\n&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 管理员查看选课表里的课程*/&lt;br/&gt;public static void GetCourseList1() {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n Here is course`information \n&quot;);&lt;/p&gt;&lt;p&gt;Statement stat = null;&lt;br/&gt;ResultSet rs = null;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from course &quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;String couID = null;&lt;br/&gt;String couName = null;&lt;br/&gt;String couTeacher = null;&lt;/p&gt;&lt;p&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;couID = rs.getString(&quot;couID&quot;);&lt;br/&gt;couName = rs.getString(&quot;couName&quot;);&lt;br/&gt;couTeacher = rs.getString(&quot;couTeacher&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(couID + &quot; &quot; + couName + &quot; &quot; + couTeacher + &quot;\n&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 15:11:00 +0000</pubDate>
<dc:creator>M-William</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mz-xiansheng/p/9211383.html</dc:identifier>
</item>
<item>
<title>社招面试总结 - 玉菲莎</title>
<link>http://www.cnblogs.com/zllwebstudy/p/9211349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zllwebstudy/p/9211349.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;span&gt;前言&lt;/span&gt;：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　对没错，时隔上一次更新是1年又x月（懒得算了），之前的更新内容都是我校招的经历和为了准备校招而做的项目总结和学习记录，这次，终于！Finally！又更新了，结果还是因为面试哈哈哈😂可以说平时真的很懒了，而且在安全区太舒适不想写东西orz而今天之所以更新，确实是因为心里有非常多想说的话，所以写下来，也把我的社招的经历分享给大家，希望能够让大家在面试准备中更好的规划重点，同样也记录下这一段时间自己的状态，闲话放在最后跟大家扯，接下来正文，我会把这段时间中面试的国内大小知名不知名公司的社招面试写在下面，后续的话，希望还有更新吧，或许大约也不会了😂&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;正文：【以下问题根据面试官提到的次数排序，次数多的排在前面】&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1、Javascript部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;1)ES6【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：面试官问到的问题，如：“你对ES6有没有了解？”或者“你在平时的工作中会用到ES6语法吗？”&lt;/p&gt;
&lt;p&gt;　　　　答：当面试官问出这种语法结构的问题时，ta就是在试探你对于ES6的了解，这个时候呢，ta希望能够听到你说出你了解到的尽可能多的ES6语法，然后ta会再在你说出的中，挑出ta觉得有必要深入的内容，更加详细的询问你。所以，你这个时候可以很平淡的抛出“有了解（用到过），像是let，const，解构，class定义类，Promise这些”，然后面试官就会根据你说出的内容，挑出一些ta认为很重要的或者本身就是难点的跟你继续详细让你说明你的理解呀，或者这个知识点的用处呀之类的，所以，如果你想面试前端，怎么能不了解ES6呢？什么？你问ES6是什么！？➡️赶紧点开教程学起来吧！&lt;a title=&quot;阮一峰 ES6入门教程&quot; href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;阮一峰ECMAScript 6 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;2)闭包【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：“你说说JS里面的闭包是什么吧”“你知道什么是闭包么？”&lt;/p&gt;
&lt;p&gt;　　　　答：当面试官问出这类问题时，请你一定要在心里偷笑😏我已经不知道该什么告诉你面试前端会可能不问闭包的？emmmm如果有对闭包心里没得x数的，请你先不要投简历浪费自己和面试官的时间了，先把闭包的定义、实现方法以及用处好好在心里滚瓜烂熟到一听面试官问这个问题，就在心里窃喜拿下一道送分题的程度，OK，我也不说你了，不会的赶紧学起来➡️&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot; target=&quot;_blank&quot;&gt;学习Javascript闭包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)原型链【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：“讲讲原型链把”“JS里的原型链是用于做什么的”&lt;/p&gt;
&lt;p&gt;　　　　答：嗯，吐槽不想多说了，如果看到这三个字就能自动巴拉巴拉得自动把考点难点都跟面试官解释清楚的，就放下手机给自己鼓鼓掌👏吧，至于不会的小可爱，没事啦，大牛都是小菜🐦一步一步努力变的，多多学习吸取别人总结的经验吧😁一点都不了解或者说不清楚原型链的看这个➡️&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499763408e24c210985d34edcabbca944b4239e20000&quot; target=&quot;_blank&quot;&gt;面向对象编程&lt;/a&gt; 如果对ES5中的继承方式有不清楚的可以看这篇➡️&lt;a href=&quot;https://www.cnblogs.com/humin/p/4556820.html&quot; target=&quot;_blank&quot;&gt;JS实现继承的几种方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;4)算法题【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：问题不一定呀，这个看面试官心情，但是总体来说，给前端出的算法真心不难，而且如果你爱刷leetcode，那就肯定没问题的，说不定还能看到原题😂我就遇到两次原题&lt;/p&gt;
&lt;p&gt;　　　　答：说一下我遇到的算法题吧。&lt;br/&gt;　　　　　　a)问题：“现在有100个台阶，你每次能够走一步或者两步，最后走到100个台阶有几种走法？” 思路提示：f(n) = f(n-1) + f(n-2) &lt;/p&gt;
&lt;p&gt;　　　　　　b)问题：“我输入一个串数字比如12345，最后输出‘一万二千三百四十五’，考虑边界情况比如10010” 思路提示： 一个数字对应中文的obj，一个放置单位的arr，每次取数字最后一位，然后依次往前添加单位和对应的中文，最后将最前面的数字拼接到最前面。&lt;/p&gt;
&lt;p&gt;　　　　　　c)问题：“列举出尽可能多的数组去重的方法” 思路提示：这个我当时只想出了5种，后来看到网上有人给出了10种解法，大家可以看看-&amp;gt; &lt;a href=&quot;https://www.jb51.net/article/121410.htm&quot; target=&quot;_blank&quot;&gt;数组去重的10种方法&lt;/a&gt; 我觉得按这个文章算解法不止10种😂总之大家可以开动你们可爱的小脑瓜给出尽可能多的解法，面试官对你的印象会大大加分的～&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2、CSS部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;1)CSS3特性【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　问：“都用到过什么CSS3的特性”“display：flex有用过么”&lt;/p&gt;
&lt;p&gt;　　　　　　答：如果问的是一个问题，那你可以拿第二个问题的知识点去回答，也就是解释一下flex布局，如果问到的是第二个点，那你就没得选了，乖乖解释一下flex布局，总而言之，CSS3特性中的flex布局，你不得不掌握，推荐一个教程，让你分分钟学会flex布局，戳这里➡️&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot; target=&quot;_blank&quot;&gt;我是打火机快来点我呀&lt;/a&gt; 如果第一个问题用flex回答以后，面试官不满意或者很满意，ta可能会继续追问你，除了这个，你还有别的了解吗？这个时候你可以说transform或者transition以及@media媒体查询，知识点预习复习来这里 &lt;a href=&quot;http://www.runoob.com/css3/css3-2dtransforms.html&quot; target=&quot;_blank&quot;&gt;小可爱们跟我一起学习CSS3呀&amp;lt;(￣︶￣)&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;2)reflow和repaint【必考指数：四星半】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　问：“你对前端性能优化有没有什么了解？”“你能说出哪些css元素会触发重排，哪些会触发重绘吗？”&lt;/p&gt;
&lt;p&gt;　　　　　　答：老实说，我被问到这两个问题的时候更本没有把它们联系起来，但是后来去了解后，觉得可以把这两个问题放在一起说，当然前端的性能优化并不只包括减少重排和重绘，我之所以把这两个问题放在一起，是方便大家将这两个问题联系起来，并且如果面试官在问到你后面这个问题，你可以在先讲清楚哪些元素触发重排和重绘后，引申到前端性能优化问题，我觉得应该会是加分的操作👋&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html&quot; target=&quot;_blank&quot;&gt;想了解性能问题点这里&lt;/a&gt;&amp;amp;&lt;a href=&quot;http://caibaojian.com/css-reflow-repaint.html&quot; target=&quot;_blank&quot;&gt;哪些元素重排哪些重绘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)布局【必考指数：四星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　问：“如何实现垂直布局？说出你知道的所有方法”“如何实现一个左侧定宽，右侧宽度不定，两个元素的高度撑满屏幕的布局？”“如何实现子元素的宽高固定为屏幕的一半，并且随屏幕大小自适应”&lt;/p&gt;
&lt;p&gt;　　　　　　答：考到布局一般会让你写一下关键的样式，并且说明一下思路，不论是垂直布局的实现，还是左右结构圣杯结构，又或者自适应的视图，都是比较考验切图的基础功的，解法都不唯一，大家可以留言提供一下自己比较得意的解法呀，楼楼期待拜读一下大家的高作~(￣▽￣)~* 当然还是提供一下楼楼在网上看到的还不错的文，大家没有思路的可以参考一下 &lt;a href=&quot;https://www.cnblogs.com/zhouhuan/p/vertical_center.html&quot; target=&quot;_blank&quot;&gt;垂直居中戳这里&lt;/a&gt; | &lt;a href=&quot;https://www.jianshu.com/p/f9bcddb0e8b4&quot; target=&quot;_blank&quot;&gt;圣杯布局看这里&lt;/a&gt; | &lt;a href=&quot;http://caibaojian.com/web-app-rem.html&quot; target=&quot;_blank&quot;&gt;rem实现自适应布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3、不分类技术问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　1)跨域问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：emmm这个几乎每个面试都被问到了，所以如果你还不知道什么是跨域以及常用的解决方法，&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot;&gt;那就快戳这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;2)从用户输入url到网页展示到用户面前的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：已经有非常多大牛的详细解释了，我也不再多做赘述，传送门在此👋&lt;a href=&quot;https://segmentfault.com/a/1190000006879700&quot; target=&quot;_blank&quot;&gt;戳我戳我戳我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)浏览器缓存机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：这个问题被问到两次，楼楼都没有答好orz所以还要赶紧恶补一下知识盲区呀&lt;a href=&quot;https://segmentfault.com/a/1190000011212929&quot; target=&quot;_blank&quot;&gt;快来一起学习呀&lt;/a&gt;　　　　&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;4)事件代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：来来来，瞧一瞧看一看了呀，你买不了吃亏买不了上当，&lt;a href=&quot;https://www.cnblogs.com/liugang-vip/p/5616484.html&quot; target=&quot;_blank&quot;&gt;看一眼不会死呀(￣ε(#￣)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;5)XSS攻击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：楼楼当时答得很不好，语言组织不行，答到最后都没有底气了，只能认栽跟面试官说，这一块确实是知识盲区，了解不多orz所以平时多学点知识是好的，就不会在面试的时候那么囧了，如果你也跟楼楼一样对XSS是啥玩意儿都不了解的话，&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/09/csp.html&quot; target=&quot;_blank&quot;&gt;赶紧来一起学习一下(￣&amp;gt;￣)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4、非技术问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;1)未来职业规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：这个就是看个人随机答的了，我觉得可以从宏观到细节的剖析一下你自己的内心独白，如果能够说得面试官动容的话，我就叫你一声大爷👍&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;2)平时如何度过非工作时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：这个也是比较个人的问题，你当然可以着实说，也可以编一段感天动地的故事，甚至可以讲一段脱口秀，总之，聚光灯，麦克风，音响调到最大，来，请开始你的表演🎤&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)你还有什么要问我的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：没有了。。。（╯‵□′）╯︵┴─┴ 你想面到最后面直接挂掉吗！？面试官这么问你，十有一二三四五是有戏的，人家给你个机会让你了解一下你可能即将上岗的公司和岗位，你直接一句话回绝了，不论面试官觉得你是缺心眼还是对这个岗位抱着可有可无的心态，总归会对你的印象分扣上几分嘛，当然如果你就是那种，老子对这个岗位无所谓面着玩的态度，当然随便你怎么说了，如果你想在最后给面试官刷一下好印象，可以问一些，比如，“会不会有每周的分享会呀？”“我以后会得到哪些技术成长的助力呀？”大概这种表现你积极向上，求知欲旺盛的套路，嗯，套路，都是套路，楼楼之前就是那种傻傻的说，没有了的人，后来总觉得面试官看我的眼神，像是在看一个二傻子，所以后来在网上一搜，哦，原来最后还有这种套路呀😂嗯，所以大家就不要再踩楼楼，嗯，坑太深有水，大家就不要往里面跳了(-ω- )&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;后话：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　啊啊啊啊啊嗷嗷哦嗷嗷，楼楼一口气写这篇社招的总结容易么！写了3个小时容易么！你都看到这了还不给我点赞评论你有理么！嘻嘻嘻嘻嘻嘻点个赞评论一下就当交个盆友咯，楼楼是喜欢蓝孩子的可爱的抠脚大汉（em？好像没什么问题？）如果不想看楼楼碎碎念的，可以点赞评论然后退出了，但是请一定不要忘记点赞评论（正经脸）&lt;/p&gt;
&lt;p&gt;　　好，我要开始我的表演了，emmmm，其实写这么就是为了吐槽😂或者正经点说是为了记录一下最近两周准备面试的心路历程吧（播放背景音乐“浪奔～浪流～🌊🌊🌊”）准备面试真的很累，心情大概是一边埋冤自己平时都太安逸了，不思进取不多学点技术，一边又不得不调整心情，告诉自己，现在想这些有的没的根本没有任何帮助，保持一个高度集中和高效率的学习状态，将不必要的负面情绪都丢出脑外才是最有用的做法。总之，准备面试的时候，晚上做梦都在写代码debug然后又去把不会的恶补一下orz醒过来就安慰自己，没事没事，等开始面试了就好了，然后就又美滋滋的喝奶茶去了orz不是楼楼不怕月半，这个呢其实是一种科学的心里鼓励机制（正经脸）而且吃甜的是可以保持好心情，然后高效率的学习，算了，编不下去了，跳过这个段落，直接讲开始面试了。&lt;/p&gt;
&lt;p&gt;　　楼楼刚刚说了，自己本来想的是开始面试了嘛，就没那么累了，总比一整天一整天没事就看书看博客看文章查漏补缺还一边鄙视自己的纠结心情好吧？然而，我错了，我真的错了，我错在一开始就不应该来到这个伤心的地方，我果然还是应该回我的阿米拉密达虫洞次时空暗极宇宙姆星中去，但是我开启宇宙飞船的钥匙被人偷走了，所以我不得不暂留🌍请好心人救救孩子，嗯，拿错剧本了，有点跳戏，回来回来，讲到开始面试了，然后绝望的发现，面试T*D累得**orz身心俱疲，所以真的面试这件事，是一个耗时耗力的事，大家如果觉得面试找工作很累，没关系，你不是一个人😂&lt;/p&gt;
&lt;p&gt;　　不过，累还是值得的，说真的，从开始准备面试到面试了各个大公司小公司，这几天的成长速度很快，楼楼每天都觉得很充实，而且就在今天洗澡的时候悟出了一个道理，不知道哪个名人或者不知名的人说的，人的灵感蓬勃爆发的时期有两个，一个是在澡堂子，一个是在马桶上，嗯，吾与子同orz哦，对，说楼楼悟出来的道理，其实真的，你得感谢这些面试官，你去面试能当面试官的总归比你资历高些吧？人家专门花时间花经历的给你挑刺，让你知道自己的知识盲区，从而查漏补缺，快速进步，而且另外一方面，还给你时间听你哔哩吧啦，让你练习你的表达能力，多好，所以呀，想对曾经害怕面试的我（如果你去看我之前校招写的总结就能多少感觉到我内心对于面试的抗拒和整个过程中的不安）以及正在看这篇文章，想要学习一些面经的你说，不要怕，大家都是一步一个脚印走出来的，现在的你不行，那就努力，等回过头来看，如果没有曾经那么不服输那么挣扎着努力的自己，也就不会有现在的你了，而如果想要在将来成为一个了不起的人，那现在的你就努力努力吧～(=￣ω￣=)&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 15:04:00 +0000</pubDate>
<dc:creator>玉菲莎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zllwebstudy/p/9211349.html</dc:identifier>
</item>
<item>
<title>微信小程序小结 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/9191303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/9191303.html</guid>
<description>&lt;p&gt; 前几日抽空看了下小程序，发现挺好玩的，mvvm的结构，语法比vue要简单，内置了一系列的组件，很方便。然后开发者工具直接上传代码，提交审核，然后发布，感觉挺好。虽然不打算做个工具类的，但是做个介绍类小程序就很合适了。不用去做什么官网，也不用买服务器域名什么的，用邮箱注册个号，把自己想介绍的东西方式去，手机上发给别人也挺方便。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;01.语法结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201806/417688-20180621214457879-1826536751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结构上很好理解，app.js可以直接获取用户的登录信息，也可以什么都不做，关键还是app.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;pages&quot;&lt;span&gt;:[
    &lt;/span&gt;&quot;pages/index/index&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;pages/about/about&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;pages/location/location&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;pages/logs/logs&quot;&lt;span&gt;
  ],
  &lt;/span&gt;&quot;window&quot;&lt;span&gt;:{
    &lt;/span&gt;&quot;backgroundTextStyle&quot;:&quot;light&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;navigationBarTitleText&quot;: &quot;书山有路&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;navigationBarTextStyle&quot;:&quot;black&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;tabBar&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;list&quot;&lt;span&gt;: [{
      &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/index/index&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;text&quot;: &quot;首页&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;iconPath&quot;: &quot;images/m.png&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;images/m1.png&quot;&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/location/location&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;text&quot;: &quot;位置&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;iconPath&quot;: &quot;images/w.png&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;images/w1.png&quot;&lt;span&gt;
    },{
      &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/about/about&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;text&quot;: &quot;关注&quot;&lt;span&gt;,
     &lt;/span&gt;&quot;iconPath&quot;: &quot;images/g.png&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;images/g1.png&quot;&lt;span&gt;
    }
    ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每一个页面必须在pages中进行注册，window是一些基本的外观配置，tabBar就是用来设置一个页底导航。基本上每个页面都包含了.js，.wxml和.wxss文件，.js以&lt;/p&gt;
&lt;p&gt;Page({})开始，设置数据和方法，很简单。wxml也就是页面文件，有很多微信自己定义的元素，比如view，text和image，可以分别对应div,span和img。wxss就和css一样。&lt;/p&gt;
&lt;h3&gt;02.滑动&lt;/h3&gt;
&lt;p&gt;swiper挺方便的，有个问题就是不能自适应高度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;swiper &lt;/span&gt;&lt;span&gt;indicator-dots&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
  autoplay&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; interval&lt;/span&gt;&lt;span&gt;=&quot;{{interval}}&quot;&lt;/span&gt;&lt;span&gt; duration&lt;/span&gt;&lt;span&gt;=&quot;{{duration}}&quot;&lt;/span&gt;&lt;span&gt;  style&lt;/span&gt;&lt;span&gt;='height:{{Hei}}' &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block &lt;/span&gt;&lt;span&gt;wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{imgUrls}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;swiper-item &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;{{item}}&quot;&lt;/span&gt;&lt;span&gt; mode&lt;/span&gt;&lt;span&gt;=&quot;widthFix&quot;&lt;/span&gt;&lt;span&gt;  bindload&lt;/span&gt;&lt;span&gt;=&quot;imgH&quot;&lt;/span&gt;&lt;span&gt;   class&lt;/span&gt;&lt;span&gt;=&quot;slide-image&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;swiper-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;swiper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找了个网友的办法，亲测有效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  imgH: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; winWid = wx.getSystemInfoSync().windowWidth;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前屏幕的宽度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; imgh = e.detail.height;　　　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片高度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; imgw =&lt;span&gt; e.detail.width;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; swiperH = winWid * imgh / imgw + &quot;px&quot;　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等比设置swiper的高度。  即 屏幕宽度 / swiper高度 = 图片宽度 / 图片高度    ==》swiper高度 = 屏幕宽度 * 图片高度 / 图片宽度&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      Hei: swiperH　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置高度&lt;/span&gt;
&lt;span&gt;    })
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要忘了在data里面设置Hei属性。&lt;/p&gt;
&lt;h3&gt;03.地图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201806/417688-20180621220531096-810494271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地图&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/map.html#map&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;说的很详细，我也没必要说了，主要是用百度找经纬度：&lt;a href=&quot;http://api.map.baidu.com/lbsapi/getpoint/index.html&quot; target=&quot;_blank&quot;&gt;拾取坐标系统&lt;/a&gt;，很方面。&lt;/p&gt;
&lt;h3&gt;04.获取用户信息&lt;/h3&gt;
&lt;p&gt;在默认的app.js里面已经提供了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取用户信息&lt;/span&gt;
&lt;span&gt;    wx.getSetting({
      success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.authSetting['scope.userInfo'&lt;span&gt;]) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框&lt;/span&gt;
&lt;span&gt;          wx.getUserInfo({
            success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以将 res 发送给后台解码出 unionId&lt;/span&gt;
              &lt;span&gt;this&lt;/span&gt;.globalData.userInfo =&lt;span&gt; res.userInfo
              console.log(res.userInfo)

              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回&lt;/span&gt;
              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以此处加入 callback 以防止这种情况&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userInfoReadyCallback) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userInfoReadyCallback(res)
              }
            }
          })
        }
      }
    })
  },
  globalData: {
    userInfo: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们要在别的页面用userInfo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = getApp();&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;Page({
data:{
 userInfo:{}
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt; onLoad() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;span&gt;setData&lt;/span&gt;({ userInfo: app.globalData.userInfo })
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对data对象复制都需要使用setData。这样你就可以在页面显示用户的头像和名称。&lt;/p&gt;
&lt;h3&gt;05.长按扫码 &lt;/h3&gt;
&lt;p&gt;这个功能其实有点鸡肋，因为只能扫小程序的二维码，如果用户都已经进了这个页面，扫码还有个什么意义，因为小程序肯定已经下载了。关键用户还是想扫微信二维码或者公众号的二维码。微信确实管的比较严。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  previewImage: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        wx.previewImage({
      current: &lt;/span&gt;'http://images.cnblogs.com/xxxxx', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前显示图片的http链接     &lt;/span&gt;
      urls: ['http://images.cnblogs.com/xxxx'] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要预览的图片http链接列表     &lt;/span&gt;
&lt;span&gt;    })

  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='img' &lt;/span&gt;&lt;span&gt;bindtap&lt;/span&gt;&lt;span&gt;=&quot;&lt;span&gt;previewImage&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;  src&lt;/span&gt;&lt;span&gt;='images/actv.jpg' &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的current和urls必须是http链接，没法用相对路径。于是最简单的，我就把图片传到了博客园的图册里面... 这样用户点击图片就能出现保存，发送给朋友，收藏。只有小程序二维码才会出现扫码识别.... &lt;/p&gt;
&lt;h3&gt;06.图标&lt;/h3&gt;
&lt;p&gt;我们需要一些图标，个人毕竟不想去找美工。发现阿里的这个还不错：&lt;a href=&quot;http://www.iconfont.cn/&quot; target=&quot;_blank&quot;&gt;http://www.iconfont.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201806/417688-20180621222331619-1174824584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然还有https://www.easyicon.net/，不过这家有时候不稳定。&lt;/p&gt;
&lt;p&gt;小结：以上只是些简单功能的小程序开发，整体感觉不错，开发速度很快，只是这个流量和转化有点难，但确实方便。而且这名称就相当于是pc时代的域名了，如果用户有了搜一搜小程序的习惯，想在微信上看你们家东西，如果没有搜到是不是有点遗憾。早点占个名字也行。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 14:29:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/9191303.html</dc:identifier>
</item>
</channel>
</rss>