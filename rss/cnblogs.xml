<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一个程序员被骗去养猪 - Vamei</title>
<link>http://www.cnblogs.com/vamei/p/9496012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vamei/p/9496012.html</guid>
<description>&lt;p&gt;2015年的一个傍晚，接到老友电话。&lt;/p&gt;
&lt;p&gt;“飞哥，我想招个程序员”，老友问。&lt;/p&gt;
&lt;p&gt;blablablabla，我大放厥词，讲了很多高标准严要求。&lt;/p&gt;
&lt;p&gt;“飞哥，要不你加入我们？”&lt;/p&gt;
&lt;p&gt;我知道老友的创业项目，玩高科技养猪。据说已经有了一个产品，是给猪戴的手环。老友毕竟是电子博士，算学以致用。我一个码农，恐怕只能给猪做H5游戏了。&lt;/p&gt;
&lt;p&gt;不过，和朋友玩玩也不错。我来自好玩的射手座，喜欢和信任的朋友一起，享受做事的乐趣。更何况，老友答应我只用操心技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I'm in.&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;第一次进猪场，是一场灵魂的洗礼。&lt;/p&gt;
&lt;p&gt;进场前戏特别多。先被消毒液喷了一分钟，然后洗了八遍澡。场长说，这里的防控等级比军事禁区都要高。我顿时心生敬畏，怀着神圣的心情走进一间大房舍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;白花花的，全是猪。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201808/413416-20180818004528266-1970153810.jpg&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;422&quot;/&gt;&lt;br/&gt;现代猪场&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;整个栋舍有两三百米长，分成一个个小隔间。每只猪戴在自己的隔间里，偶尔发出两声哼唧。地上有漏粪板，所以并没有想象中堆积如山的污物。通风系统吸走大部分臭味，但热烘烘的异样空气还是不可避免。忽然听到哗啦啦的声响，所有的猪都躁动起来。饲料沿着管道自动运到每个小隔间，又到了放料的时间。看着拱食的猪，我开始对比人生与猪生。&lt;/p&gt;
&lt;p&gt;场长又偷偷告诉我，建这个场花了一个亿。狗日的，比人还金贵。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;全国每年吃掉7亿头猪，每人吃掉半头猪。顺其自然，中国也是第一大养猪国。这两年正逢产业升级，各大养殖集团都在引入高科技。像手环这样的可穿戴设备，满大街都是。照着做一款猪用可穿戴设备，肯定不难。&lt;/p&gt;
&lt;p&gt;于是，设计、打样、开模、配套软件开发…… 紧锣密鼓，热火朝天。第一个版本的产品出来了，欢天喜地，连忙赶到猪场测试。&lt;/p&gt;
&lt;p&gt;猪甩了两下，产品就掉了。&lt;/p&gt;
&lt;p&gt;人买个智能手表会心疼，猪对电子产品可没有那么关爱。后面的故事就简单多了，失败N次。原本两个月的研发计划拉长到两年，大版本号都更新了6代了，产品化希望还有些渺茫。又是一年春光，看窗外树梢新芽，心里嘀咕干嘛老和猪过不去。&lt;/p&gt;
&lt;p&gt;这时候，老友在旁边接了个前线的电话，&lt;/p&gt;
&lt;p&gt;“戴上了？”&lt;/p&gt;
&lt;p&gt;“没应激？”&lt;/p&gt;
&lt;p&gt;“信号正常？”&lt;/p&gt;
&lt;p&gt;“数据准的？”&lt;/p&gt;
&lt;p&gt;老友一挂电话，激动得说不出话。我很镇定：&lt;/p&gt;
&lt;p&gt;“我就说嘛，坚持是成功的妈妈。”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201808/413416-20180818004613647-1788043332.jpg&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;229&quot;/&gt;&lt;br/&gt;猪用可穿戴产品&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;可穿戴产品拿到几家大客户。这几家大客户都是养猪业的大佬，数一数二的上市公司。别人的成功是开宝马迎娶白富美，从此走上人生巅峰。我和老友的成功，就是能下到更多的猪场。&lt;/p&gt;
&lt;p&gt;作为一个程序员，我自然会注意猪场的软件。大猪场信息化都搞了一二十年了，ERP软件、数据库、移动端、云端、微信小程序都玩得溜溜的。不过，对于注意力都在猪上的一线工人来说，多个手机录入信息，总有些不方便。这个问题也是很长时间没解决方案。&lt;/p&gt;
&lt;p&gt;当然，对于一个（身兼产品经理的）程序员来说，没有做不到的。&lt;/p&gt;
&lt;p&gt;于是，我拉了几个人，搞起AI养猪。目标很简单，通过视频分析来省去人工的数据录入。我还给这个产品起了一个拉风的名字：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;天蓬&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在给开发团队介绍这个名字时，我知道开发小伙伴的内心是崩溃的。谁也不想摊上一个中二病的老大。更何况，我说的还是“人工智能养猪”，总有点标题党的意思。&lt;/p&gt;
&lt;p&gt;等介绍完产品，我习惯性地总结：“这东西不难，你们很容易就能搞出来。”&lt;/p&gt;
&lt;p&gt;“飞哥说的简单，一般都不简单。” 有人嘀咕，我装没听到。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;传说中的“天蓬”上线，行业老大率先下了订单。小伙伴们有些激动，我装作没看到。 &lt;/p&gt;


&lt;p&gt;程序员想的，无非是创造产品。如果产品不小心改变了行业，更是兴奋异常。&lt;/p&gt;
&lt;p&gt;总归不负这养猪三年。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 16:47:00 +0000</pubDate>
<dc:creator>Vamei</dc:creator>
<og:description>2015年的一个傍晚，接到老友电话。 “飞哥，我想招个程序员”，老友问。 blablablabla，我大放厥词，讲了很多高标准严要求。 “飞哥，要不你加入我们？” 我知道老友的创业项目，玩高科技养猪。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vamei/p/9496012.html</dc:identifier>
</item>
<item>
<title>7.0  启动app权限弹窗问题 - 佬贰</title>
<link>http://www.cnblogs.com/pythontest/p/9495928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythontest/p/9495928.html</guid>
<description>&lt;p&gt;&lt;span&gt;这里提供两种解决方案！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/span&gt;安卓&lt;/span&gt;6.0+&lt;span&gt;是可以直接利用&lt;/span&gt;&lt;span&gt;uiautomator&lt;/span&gt;&lt;span&gt;定位元素点击！这个不细说&lt;/span&gt;,&lt;span&gt;定位方式很多种&lt;/span&gt;&lt;span&gt;...这个等待时间大家自己定大概两到三秒即可！&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#安卓6.0+点击方式&lt;br/&gt;driver.find_element_by_android_uiautomator(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new UiSelector().textContains(&quot;允许&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是一般来说弹窗大多数都是好多个---利用显示等待：启动app之后，在三秒内  没0.5秒寻找一次元素，如果存在则点击，不存在则报错直接pass&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        Element &lt;/span&gt;= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[contains(@text,'允许')]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        ac &lt;/span&gt;= WebDriverWait(driver, 3, 0.5).until(&lt;span&gt;lambda&lt;/span&gt; driver:driver.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[contains(@text,&quot;允许&quot;)]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        ac.click()
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     &lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/span&gt;还有一种定位方式如下，亲测支持高版本，但是我没有亲自试过是否支持低版本手机的权限弹窗-----因为我不是用的这两种---个人用的方法比较简单粗暴+直接&lt;/p&gt;
&lt;p&gt;但是呢，这里建议大家搞个低版本的手机试下，我没测是因为条件不允许，找不到低版本的手机.......希望有朋友测了之后截图留言一波，让我有个底....&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        Element &lt;/span&gt;= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[contains(@text,'允许')]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        ac &lt;/span&gt;= WebDriverWait(driver, 1, 0.5&lt;span&gt;).until(EC.presence_of_element_located(Element))
        ac.click()
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;然后手动给每台手机安装一遍&lt;/span&gt;app，并用记事本获其他玩意记下设备名称&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;&lt;span&gt;打开&lt;/span&gt;app，准备好uiautomatorview（sdk目录下那个定位元素的玩意..），如下图所示记住这个坐标，如：
&lt;p class=&quot;pre&quot;&gt;admin_lists={'2905bdb6':[360,1149],'xxxx':[1,1]}，&lt;span&gt;如果定位不到【允许】这个坐标，就手动点一下允许，按照不动，你会发现在屏幕最上面有一个坐标DX:--/DY:--，记下这个坐标也是一样的！&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180817230248948-271331365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
admin_list={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2905bdb6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[(360,1149)],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[(1,1&lt;span&gt;)]}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; a &lt;span&gt;in&lt;/span&gt;&lt;span&gt; admin_list:
    deviceList&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;.join(os.popen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adb devices&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).readlines())
    Device&lt;/span&gt;=re.findall(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(.+?)\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,deviceList)[0]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Device)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==&lt;span&gt;Device:
        driver.tap(admin_list[a])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;　　　　　　原理就是先把我们测试机弹出权限允许的那个坐标给记录下来，第一次安装启动的时候查询一下设备名称然后取到坐标，然后点击---这个方法也是适合多设备&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;方法有点捞，但是实用靠谱&lt;/span&gt;---另外这里不要想着去适配屏幕，这个不存在的，据我了解不同手机的弹窗样式可能是不一样的..&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;如果只弹出一个&lt;/span&gt;-直接用上面的方法就可以了，但是如果权限弹窗有多个呢：&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;  &lt;span&gt;加个方法就可以了&lt;/span&gt;---有多个的话，这个就得根据自己的app调试了...但是大同小异&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
admin_list={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2905bdb6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[(360,1149)],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[(1,1&lt;span&gt;)]}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; a &lt;span&gt;in&lt;/span&gt;&lt;span&gt; admin_list:
    deviceList&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;.join(os.popen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adb devices&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).readlines())
    Device&lt;/span&gt;=re.findall(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(.+?)\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,deviceList)[0]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Device)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==&lt;span&gt;Device:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i  &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
            driver.tap(admin_list[a])
            time.sleep(&lt;/span&gt;3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;


&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;具体应该还有很多骚方法&lt;/span&gt;--大家可以自己研究一下，只要能实现就可以，我个人方面对于执行效率并没有太过--（想不到词了）&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;这章有一定的&lt;/span&gt;python语法：&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;   &lt;span&gt;循环、正则、&lt;/span&gt;os、range、readlines、dict取值----如果这个不太懂得-建议看下 廖雪峰的python3教程---直接百度廖雪峰就可以了&lt;/p&gt;

</description>
<pubDate>Fri, 17 Aug 2018 16:39:00 +0000</pubDate>
<dc:creator>佬贰</dc:creator>
<og:description>这里提供两种解决方案！ 1.安卓6.0+是可以直接利用uiautomator定位元素点击！这个不细说,定位方式很多种...这个等待时间大家自己定大概两到三秒即可！ 但是一般来说弹窗大多数都是好多个 利</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythontest/p/9495928.html</dc:identifier>
</item>
<item>
<title>补习系列-springboot 实现拦截的五种姿势 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9496009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9496009.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;AOP(面向切面编程)常用于解决系统中的一些耦合问题，是一种编程的模式&lt;br/&gt;通过将一些通用逻辑抽取为公共模块，由容器来进行调用，以达到模块间隔离的效果。&lt;br/&gt;其还有一个别名，叫面向关注点编程，把系统中的核心业务逻辑称为&lt;strong&gt;核心关注点&lt;/strong&gt;，而一些通用的非核心逻辑划分为&lt;strong&gt;横切关注点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOP常用于...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志记录&lt;/strong&gt;&lt;br/&gt;你需要为你的Web应用程序实现访问日志记录，却又不想在所有接口中一个个进行打点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全控制&lt;/strong&gt;&lt;br/&gt;为URL 实现访问权限控制，自动拦截一些非法访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事务&lt;/strong&gt;&lt;br/&gt;某些业务流程需要在一个事务中串行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常处理&lt;/strong&gt;&lt;br/&gt;系统发生处理异常，根据不同的异常返回定制的消息体。&lt;/p&gt;
&lt;p&gt;在笔者刚开始接触编程之时，AOP还是个新事物，当时曾认为AOP会大行其道。&lt;br/&gt;果不其然，目前流行的Spring 框架中，AOP已经成为其关键的核心能力。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接下来，我们要看看在SpringBoot 框架中，怎么实现常用的一些拦截操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看看下面的一个Controller方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/intercept&quot;)
public class InterceptController {

    @PostMapping(value = &quot;/body&quot;, consumes = { MediaType.TEXT_PLAIN_VALUE, MediaType.APPLICATION_JSON_UTF8_VALUE })
    public String body(@RequestBody MsgBody msg) {
        return msg == null ? &quot;&amp;lt;EMPTY&amp;gt;&quot; : msg.getContent();
    }

    public static class MsgBody {
        private String content;

        public String getContent() {
            return content;
        }

        public void setContent(String content) {
            this.content = content;
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述代码的 body 方法中，会接受一个MsgBody请求消息体，最终简单的输出content字段。&lt;br/&gt;下面，我们将介绍如何为这个方法实现拦截动作。算起来，共有五种姿势。&lt;/p&gt;
&lt;h2 id=&quot;姿势一使用-filter-接口&quot;&gt;姿势一、使用 Filter 接口&lt;/h2&gt;
&lt;p&gt;Filter 接口由 J2EE 定义，在Servlet执行之前由容器进行调用。&lt;br/&gt;而SpringBoot中声明 Filter 又有两种方式：&lt;/p&gt;
&lt;h3 id=&quot;注册-filterregistrationbean&quot;&gt;1. 注册 FilterRegistrationBean&lt;/h3&gt;
&lt;p&gt;声明一个FilterRegistrationBean 实例，对Filter 做一系列定义，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Bean
    public FilterRegistrationBean customerFilter() {
        FilterRegistrationBean registration = new FilterRegistrationBean();

        // 设置过滤器
        registration.setFilter(new CustomerFilter());

        // 拦截路由规则
        registration.addUrlPatterns(&quot;/intercept/*&quot;);

        // 设置初始化参数
        registration.addInitParameter(&quot;name&quot;, &quot;customFilter&quot;);

        registration.setName(&quot;CustomerFilter&quot;);
        registration.setOrder(1);
        return registration;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 CustomerFilter 实现了Filter接口，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CustomerFilter implements Filter {

    private static final Logger logger = LoggerFactory.getLogger(CustomerFilter.class);
    private String name;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        name = filterConfig.getInitParameter(&quot;name&quot;);
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        logger.info(&quot;Filter {} handle before&quot;, name);
        chain.doFilter(request, response);
        logger.info(&quot;Filter {} handle after&quot;, name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;webfilter-注解&quot;&gt;2. @WebFilter 注解&lt;/h3&gt;
&lt;p&gt;为Filter的实现类添加 &lt;strong&gt;@WebFilter&lt;/strong&gt;注解，由SpringBoot 框架扫描后注入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;@WebFilter的启用需要配合@ServletComponentScan才能生效&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@ServletComponentScan
@WebFilter(urlPatterns = &quot;/intercept/*&quot;, filterName = &quot;annotateFilter&quot;)
public class AnnotateFilter implements Filter {

    private static final Logger logger = LoggerFactory.getLogger(AnnotateFilter.class);
    private final String name = &quot;annotateFilter&quot;;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        logger.info(&quot;Filter {} handle before&quot;, name);
        chain.doFilter(request, response);
        logger.info(&quot;Filter {} handle after&quot;, name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用注解是最简单的，但其缺点是仍然无法支持 order属性(用于控制Filter的排序)。&lt;br/&gt;而通常的&lt;strong&gt;@Order&lt;/strong&gt;注解只能用于定义Bean的加载顺序，却真正无法控制Filter排序。&lt;br/&gt;这是一个已知问题，&lt;a href=&quot;https://github.com/spring-projects/spring-boot/issues/8276&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐指数&lt;/strong&gt;&lt;br/&gt;3 颗星，Filter 定义属于J2EE规范，由Servlet容器调度执行。&lt;br/&gt;由于独立于框架之外，无法使用 Spring 框架的便捷特性，&lt;br/&gt;目前一些第三方组件集成时会使用该方式。&lt;/p&gt;
&lt;h2 id=&quot;姿势二hanlderinterceptor&quot;&gt;姿势二、HanlderInterceptor&lt;/h2&gt;
&lt;p&gt;HandlerInterceptor 用于拦截 Controller 方法的执行，其声明了几个方法：&lt;br/&gt;|方法 | 说明|&lt;br/&gt;|-----|-----|&lt;br/&gt;|preHandle | Controller方法执行前调用 |&lt;br/&gt;|preHandle | Controller方法后，视图渲染前调用 |&lt;br/&gt;|afterCompletion| 整个方法执行后(包括异常抛出捕获) |&lt;/p&gt;
&lt;p&gt;基于 HandlerInterceptor接口 实现的样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CustomHandlerInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(CustomHandlerInterceptor.class);

    /*
     * Controller方法调用前，返回true表示继续处理
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        HandlerMethod method = (HandlerMethod) handler;
        logger.info(&quot;CustomerHandlerInterceptor preHandle, {}&quot;, method.getMethod().getName());

        return true;
    }

    /*
     * Controller方法调用后，视图渲染前
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {

        HandlerMethod method = (HandlerMethod) handler;
        logger.info(&quot;CustomerHandlerInterceptor postHandle, {}&quot;, method.getMethod().getName());

        response.getOutputStream().write(&quot;append content&quot;.getBytes());
    }

    /*
     * 整个请求处理完，视图已渲染。如果存在异常则Exception不为空
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
            throws Exception {

        HandlerMethod method = (HandlerMethod) handler;
        logger.info(&quot;CustomerHandlerInterceptor afterCompletion, {}&quot;, method.getMethod().getName());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了上面的代码实现，还不要忘了将 Interceptor 实现进行注册：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class InterceptConfig extends WebMvcConfigurerAdapter {

    // 注册拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(new CustomHandlerInterceptor()).addPathPatterns(&quot;/intercept/**&quot;);
        super.addInterceptors(registry);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;推荐指数&lt;/strong&gt;&lt;br/&gt;4颗星，HandlerInterceptor 来自SpringMVC框架，基本可代替 Filter 接口使用；&lt;br/&gt;除了可以方便的进行异常处理之外，通过接口参数能获得Controller方法实例，还可以实现更灵活的定制。&lt;/p&gt;
&lt;h2 id=&quot;姿势三exceptionhandler-注解&quot;&gt;姿势三、@ExceptionHandler 注解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;@ExceptionHandler&lt;/strong&gt; 的用途是捕获方法执行时抛出的异常，&lt;br/&gt;通常可用于捕获全局异常，并输出自定义的结果。&lt;/p&gt;
&lt;p&gt;如下面的实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@ControllerAdvice(assignableTypes = InterceptController.class)
public class CustomInterceptAdvice {

    private static final Logger logger = LoggerFactory.getLogger(CustomInterceptAdvice.class);

    /**
     * 拦截异常
     * 
     * @param e
     * @param m
     * @return
     */
    @ExceptionHandler(value = { Exception.class })
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ResponseBody
    public String handle(Exception e, HandlerMethod m) {

        logger.info(&quot;CustomInterceptAdvice handle exception {}, method: {}&quot;, e.getMessage(), m.getMethod().getName());

        return e.getMessage();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;@ExceptionHandler 需要与 @ControllerAdvice&lt;/strong&gt;配合使用&lt;br/&gt;其中 @ControllerAdvice的 assignableTypes 属性指定了所拦截类的名称。&lt;br/&gt;除此之外，该注解还支持指定包扫描范围、注解范围等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐指数&lt;/strong&gt;&lt;br/&gt;5颗星，@ExceptionHandler 使用非常方便，在异常处理的机制上是首选；&lt;br/&gt;目前也是SpringBoot 框架最为推荐使用的方法。&lt;/p&gt;
&lt;h2 id=&quot;姿势四requestbodyadviceresponsebodyadvice&quot;&gt;姿势四、RequestBodyAdvice/ResponseBodyAdvice&lt;/h2&gt;
&lt;p&gt;RequestBodyAdvice、ResponseBodyAdvice 相对于读者可能比较陌生，&lt;br/&gt;而这俩接口也是 Spring 4.x 才开始出现的。&lt;/p&gt;
&lt;h3 id=&quot;requestbodyadvice-的用法&quot;&gt;RequestBodyAdvice 的用法&lt;/h3&gt;
&lt;p&gt;我们都知道，SpringBoot 中可以利用&lt;strong&gt;@RequestBody&lt;/strong&gt;这样的注解完成请求内容体与对象的转换。&lt;br/&gt;而&lt;strong&gt;RequestBodyAdvice&lt;/strong&gt; 则可用于在&lt;strong&gt;请求内容对象转换的前后时刻&lt;/strong&gt;进行拦截处理，其定义了几个方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;supports&lt;/td&gt;
&lt;td&gt;判断是否支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;handleEmptyBody&lt;/td&gt;
&lt;td&gt;当请求体为空时调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;beforeBodyRead&lt;/td&gt;
&lt;td&gt;在请求体未读取(转换)时调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;afterBodyRead&lt;/td&gt;
&lt;td&gt;在请求体完成读取后调用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@ControllerAdvice(assignableTypes = InterceptController.class)
public class CustomRequestAdvice extends RequestBodyAdviceAdapter {

    private static final Logger logger = LoggerFactory.getLogger(CustomRequestAdvice.class);

    @Override
    public boolean supports(MethodParameter methodParameter, Type targetType,
            Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) {
        // 返回true，表示启动拦截
        return MsgBody.class.getTypeName().equals(targetType.getTypeName());
    }

    @Override
    public Object handleEmptyBody(Object body, HttpInputMessage inputMessage, MethodParameter parameter,
            Type targetType, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) {
        logger.info(&quot;CustomRequestAdvice handleEmptyBody&quot;);

        // 对于空请求体，返回对象
        return body;
    }

    @Override
    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType,
            Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) throws IOException {
        logger.info(&quot;CustomRequestAdvice beforeBodyRead&quot;);

        // 可定制消息序列化
        return new BodyInputMessage(inputMessage);
    }

    @Override
    public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType,
            Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) {
        logger.info(&quot;CustomRequestAdvice afterBodyRead&quot;);

        // 可针对读取后的对象做转换，此处不做处理
        return body;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码实现中，针对前面提到的 &lt;strong&gt;MsgBody&lt;/strong&gt;对象类型进行了拦截处理。&lt;br/&gt;在beforeBodyRead 中，返回一个&lt;strong&gt;BodyInputMessage&lt;/strong&gt;对象，而这个对象便负责&lt;strong&gt;源数据流解析转换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static class BodyInputMessage implements HttpInputMessage {
        private HttpHeaders headers;
        private InputStream body;

        public BodyInputMessage(HttpInputMessage inputMessage) throws IOException {
            this.headers = inputMessage.getHeaders();

            // 读取原字符串
            String content = IOUtils.toString(inputMessage.getBody(), &quot;UTF-8&quot;);
            MsgBody msg = new MsgBody();
            msg.setContent(content);

            this.body = new ByteArrayInputStream(JsonUtil.toJson(msg).getBytes());
        }

        @Override
        public InputStream getBody() throws IOException {
            return body;
        }

        @Override
        public HttpHeaders getHeaders() {
            return headers;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码说明&lt;/strong&gt;&lt;br/&gt;完成数据流的转换，包括以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取请求内容字符串；&lt;/li&gt;
&lt;li&gt;构建 MsgBody 对象，将内容字符串作为其 content 字段；&lt;/li&gt;
&lt;li&gt;将 MsgBody 对象 Json 序列化，再次转成字节流供后续环节使用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;responsebodyadvice-用法&quot;&gt;ResponseBodyAdvice 用法&lt;/h3&gt;
&lt;p&gt;ResponseBodyAdvice 的用途在于对返回内容做拦截处理，如下面的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @ControllerAdvice(assignableTypes = InterceptController.class)
    public static class CustomResponseAdvice implements ResponseBodyAdvice&amp;lt;String&amp;gt; {

        private static final Logger logger = LoggerFactory.getLogger(CustomRequestAdvice.class);

        @Override
        public boolean supports(MethodParameter returnType, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) {
            // 返回true，表示启动拦截
            return true;
        }

        @Override
        public String beforeBodyWrite(String body, MethodParameter returnType, MediaType selectedContentType,
                Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; selectedConverterType, ServerHttpRequest request,
                ServerHttpResponse response) {

            logger.info(&quot;CustomResponseAdvice beforeBodyWrite&quot;);

            // 添加前缀
            String raw = String.valueOf(body);
            return &quot;PREFIX:&quot; + raw;
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看，还是容易理解的，我们在返回的字符串中添加了一个前缀！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐指数&lt;/strong&gt;&lt;br/&gt;2 颗星，这是两个非常冷门的接口，目前的使用场景也相对有限；&lt;br/&gt;一般在需要对输入输出流进行特殊处理(比如加解密)的场景下使用。&lt;/p&gt;
&lt;h2 id=&quot;姿势五aspect-注解&quot;&gt;姿势五、@Aspect 注解&lt;/h2&gt;
&lt;p&gt;这是目前最灵活的做法，直接利用注解可实现任意对象、方法的拦截。&lt;br/&gt;在某个Bean的类上面** @Aspect** 注解便可以将一个Bean 声明为具有AOP能力的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Aspect
@Component
public class InterceptControllerAspect {

    private static final Logger logger = LoggerFactory.getLogger(InterceptControllerAspect.class);

    @Pointcut(&quot;target(org.zales.dmo.boot.controllers.InterceptController)&quot;)
    public void interceptController() {

    }

    @Around(&quot;interceptController()&quot;)
    public Object handle(ProceedingJoinPoint joinPoint) throws Throwable {

        logger.info(&quot;aspect before.&quot;);

        try {
            return joinPoint.proceed();
        } finally {
            logger.info(&quot;aspect after.&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;简单说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Pointcut&lt;/strong&gt; 用于定义切面点，而使用&lt;strong&gt;target&lt;/strong&gt;关键字可以定位到具体的类。&lt;br/&gt;&lt;strong&gt;@Around&lt;/strong&gt; 定义了一个切面处理方法，通过注入ProceedingJoinPoint对象达到控制的目的。&lt;/p&gt;
&lt;p&gt;一些常用的切面注解：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Before&lt;/td&gt;
&lt;td&gt;方法执行之前&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@After&lt;/td&gt;
&lt;td&gt;方法执行之后&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Around&lt;/td&gt;
&lt;td&gt;方法执行前后&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@AfterThrowing&lt;/td&gt;
&lt;td&gt;抛出异常后&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@AfterReturing&lt;/td&gt;
&lt;td&gt;正常返回后&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;深入一点&lt;/strong&gt;&lt;br/&gt;aop的能力来自于&lt;strong&gt;spring-boot-starter-aop&lt;/strong&gt;，进一步依赖于&lt;strong&gt;aspectjweaver&lt;/strong&gt;组件。&lt;br/&gt;有兴趣可以进一步了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐指数&lt;/strong&gt;&lt;br/&gt;5颗星，&lt;strong&gt;aspectj&lt;/strong&gt; 与 SpringBoot 可以无缝集成，这是一个经典的AOP框架，&lt;br/&gt;可以实现任何你想要的功能，笔者之前曾在多个项目中使用，效果是十分不错的。&lt;br/&gt;注解的支持及自动包扫描大大简化了开发，然而，你仍然需要先对 Pointcut 的定义有充分的了解。&lt;/p&gt;
&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;
&lt;p&gt;到这里，读者可能想知道，这些实现拦截器的接口之间有什么关系呢？&lt;br/&gt;答案是，没有什么关系！ 每一种接口都会在不同的时机被调用，我们基于上面的代码示例做了日志输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; - Filter customFilter handle before
 - Filter annotateFilter handle before
 - CustomerHandlerInterceptor preHandle, body
 - CustomRequestAdvice beforeBodyRead
 - CustomRequestAdvice afterBodyRead
 - aspect before.
 - aspect after.
 - CustomResponseAdvice beforeBodyWrite
 - CustomerHandlerInterceptor postHandle, body
 - CustomerHandlerInterceptor afterCompletion, body
 - Filter annotateFilter handle after
 - Filter customFilter handle after&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，各种拦截器接口的执行顺序如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180818003815677-1701569820.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;AOP 是实现拦截器的基本思路，本文介绍了SpringBoot 项目中实现拦截功能的&lt;strong&gt;五种常用姿势&lt;/strong&gt;。&lt;br/&gt;对于每一种方法都给出了真实的代码样例，读者可以根据需要选择自己适用的方案。&lt;br/&gt;最后，欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 16:39:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 简介 AOP(面向切面编程)常用于解决系统中的一些耦合问题，是一种编程的模式 通过将一些通用逻辑抽取为公共模块，由容器来进行调用，以达到模块间隔离的效果。 其还有一个别名，叫面向关注点编程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9496009.html</dc:identifier>
</item>
<item>
<title>应用监控CAT之cat-consumer源码阅读 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/9494904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/9494904.html</guid>
<description>&lt;p&gt;　　之前讲了 cat-client 进行cat埋点上报，那么上报给谁呢？以及后续故事如何？让我们来看看 cat-consumer 是如何接收处理的？&lt;/p&gt;
&lt;p&gt;　　由cat-client发送数据，cat-consumer进行接收请求处理，开始了处理问题之旅！&lt;/p&gt;
&lt;p&gt;首先，让我们来回顾一下 TcpSocketSender 是如何发送数据的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TcpSocketSender 往channel中写入数据，此处有兴趣的同学可以延伸下 netty 的源码！&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendInternal(MessageTree tree) {
        ChannelFuture future &lt;/span&gt;=&lt;span&gt; m_manager.channel();
        ByteBuf buf &lt;/span&gt;= PooledByteBufAllocator.DEFAULT.buffer(10 * 1024); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10K&lt;/span&gt;
&lt;span&gt;
        m_codec.encode(tree, buf);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; buf.readableBytes();
        Channel channel &lt;/span&gt;=&lt;span&gt; future.channel();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以 ByteBuf 形式发送数据&lt;/span&gt;
&lt;span&gt;        channel.writeAndFlush(buf);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新统计数据&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (m_statistics != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) { 
            m_statistics.onBytes(size);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// TcpSocketReceiver, 接收发送过来的数据，默认端口 2280, 注册服务，线上为分布式部署，即为接口调用式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            startServer(m_port);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            m_logger.error(e.getMessage(), e);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startServer(&lt;span&gt;int&lt;/span&gt; port) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; linux = getOSMatches(&quot;Linux&quot;) || getOSMatches(&quot;LINUX&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; threads = 24&lt;span&gt;;
        ServerBootstrap bootstrap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrap();

        m_bossGroup &lt;/span&gt;= linux ? &lt;span&gt;new&lt;/span&gt; EpollEventLoopGroup(threads) : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup(threads);
        m_workerGroup &lt;/span&gt;= linux ? &lt;span&gt;new&lt;/span&gt; EpollEventLoopGroup(threads) : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup(threads);
        bootstrap.group(m_bossGroup, m_workerGroup);
        bootstrap.channel(linux &lt;/span&gt;? EpollServerSocketChannel.&lt;span&gt;class&lt;/span&gt; : NioServerSocketChannel.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加处理handler, 进行请求逻辑处理&lt;/span&gt;
        bootstrap.childHandler(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(SocketChannel ch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                ChannelPipeline pipeline &lt;/span&gt;=&lt;span&gt; ch.pipeline();
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处仅为一个解码器，实际功能在该解码器中完成&lt;/span&gt;
                pipeline.addLast(&quot;decode&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageDecoder());
            }
        });

        bootstrap.childOption(ChannelOption.SO_REUSEADDR, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        bootstrap.childOption(ChannelOption.TCP_NODELAY, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        bootstrap.childOption(ChannelOption.SO_KEEPALIVE, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        bootstrap.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            m_future &lt;/span&gt;=&lt;span&gt; bootstrap.bind(port).sync();
            m_logger.info(&lt;/span&gt;&quot;start netty server!&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            m_logger.error(&lt;/span&gt;&quot;Started Netty Server Failed:&quot; +&lt;span&gt; port, e);
        }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息解码器，并处理具体业务逻辑，先确认数据已上传完成，再进行逻辑处理&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MessageDecoder &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ByteToMessageDecoder {

        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, ByteBuf buffer, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (buffer.readableBytes() &amp;lt; 4&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            buffer.markReaderIndex();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; buffer.readInt();
            buffer.resetReaderIndex();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (buffer.readableBytes() &amp;lt; length + 4&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (length &amp;gt; 0&lt;span&gt;) {
                    ByteBuf readBytes &lt;/span&gt;= buffer.readBytes(length + 4&lt;span&gt;);
                    readBytes.markReaderIndex();
                    readBytes.readInt();

                    DefaultMessageTree tree &lt;/span&gt;=&lt;span&gt; (DefaultMessageTree) m_codec.decode(readBytes);

                    readBytes.resetReaderIndex();
                    tree.setBuffer(readBytes);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交由handler处理实际逻辑&lt;/span&gt;
&lt;span&gt;                    m_handler.handle(tree);
                    m_processCount&lt;/span&gt;++&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; flag = m_processCount %&lt;span&gt; CatConstants.SUCCESS_COUNT;

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flag == 0&lt;span&gt;) {
                        m_serverStateManager.addMessageTotal(CatConstants.SUCCESS_COUNT);
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; client message is error&lt;/span&gt;
&lt;span&gt;                    buffer.readBytes(length);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                m_serverStateManager.addMessageTotalLoss(&lt;/span&gt;1&lt;span&gt;);
                m_logger.error(e.getMessage(), e);
            }
        }
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// handler 处理流程，由DefaultMessageHandler接手，安排后续工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DefaultMessageHandler, 接过处理器的第一棒, 交由另一实际的consumer(RealtimeConsumer) handler处理&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handle(MessageTree tree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m_consumer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            m_consumer &lt;/span&gt;= lookup(MessageConsumer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            m_consumer.consume(tree);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            m_logger.error(&lt;/span&gt;&quot;Error when consuming message in &quot; + m_consumer + &quot;! tree: &quot; +&lt;span&gt; tree, e);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RealtimeConsumer, 进行消费数据&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; consume(MessageTree tree) {
        String domain &lt;/span&gt;=&lt;span&gt; tree.getDomain();
        String ip &lt;/span&gt;=&lt;span&gt; tree.getIpAddress();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行权限检测，ip,domain&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;m_blackListManager.isBlack(domain, ip)) {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timestamp =&lt;span&gt; tree.getMessage().getTimestamp();
            Period period &lt;/span&gt;=&lt;span&gt; m_periodManager.findPeriod(timestamp);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到period, 再将消息分配过去，否则算作网络异常&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (period != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                period.distribute(tree);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                m_serverStateManager.addNetworkTimeError(&lt;/span&gt;1&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            m_black&lt;/span&gt;++&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m_black % CatConstants.SUCCESS_COUNT == 0&lt;span&gt;) {
                Cat.logEvent(&lt;/span&gt;&quot;Discard&quot;&lt;span&gt;, domain);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// Period.distribute, 将消息依次取出，进行分发到队列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; distribute(MessageTree tree) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 统计进行数进行加1&lt;/span&gt;
        m_serverStateManager.addMessageTotal(tree.getDomain(), 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; success = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        String domain &lt;/span&gt;=&lt;span&gt; tree.getDomain();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将各种类型的监控数据分别取出进行处理&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;String, List&amp;lt;PeriodTask&amp;gt;&amp;gt;&lt;span&gt; entry : m_tasks.entrySet()) {
            List&lt;/span&gt;&amp;lt;PeriodTask&amp;gt; tasks =&lt;span&gt; entry.getValue();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; tasks.size();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; manyTasks = length &amp;gt; 1&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (manyTasks) {
                index &lt;/span&gt;= Math.abs(domain.hashCode()) %&lt;span&gt; length;
            }
            PeriodTask task &lt;/span&gt;=&lt;span&gt; tasks.get(index);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有金条消息，将task重新入队&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; enqueue =&lt;span&gt; task.enqueue(tree);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enqueue == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (manyTasks) {
                    task &lt;/span&gt;= tasks.get((index + 1) %&lt;span&gt; length);
                    enqueue &lt;/span&gt;=&lt;span&gt; task.enqueue(tree);

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enqueue == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                        success &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    success &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;success) {
            m_serverStateManager.addMessageTotalLoss(tree.getDomain(), &lt;/span&gt;1&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PeriodTask.enqueue, 重新入队消息，让消费线程自行消费 LinkedBlockingQueue.offer(..)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(MessageTree tree) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result =&lt;span&gt; m_queue.offer(tree);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!result) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; trace queue overflow, 记录入队失败日志&lt;/span&gt;
            m_queueOverflow++&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m_queueOverflow % (10 * CatConstants.ERROR_COUNT) == 0&lt;span&gt;) {
                m_logger.warn(m_analyzer.getClass().getSimpleName() &lt;/span&gt;+ &quot; queue overflow number &quot; +&lt;span&gt; m_queueOverflow);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，一条消费线路就完成了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;// PeriodTask 线程，作为第二个消费线路&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分析各消息数据，做后台消费处理&lt;/span&gt;
&lt;span&gt;            m_analyzer.analyze(m_queue);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            Cat.logError(e);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用统一的抽象类的模板方法，由各类进行具体的 process 处理&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; analyze(MessageQueue queue) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!isTimeout() &amp;amp;&amp;amp;&lt;span&gt; isActive()) {
            MessageTree tree &lt;/span&gt;=&lt;span&gt; queue.poll();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用具体类的process &lt;/span&gt;
&lt;span&gt;                    process(tree);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                    m_errors&lt;/span&gt;++&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m_errors == 1 || m_errors % 10000 == 0&lt;span&gt;) {
                        Cat.logError(e);
                    }
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果出现超时或者停止动作，则把剩余队列处理完成再退出线程&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            MessageTree tree &lt;/span&gt;=&lt;span&gt; queue.poll();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    process(tree);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                    m_errors&lt;/span&gt;++&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m_errors == 1 || m_errors % 10000 == 0&lt;span&gt;) {
                        Cat.logError(e);
                    }
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时规则，当前时间 &amp;gt; 开始时间+1小时+设置额外超时时间&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isTimeout() {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; currentTime =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; endTime = m_startTime + m_duration +&lt;span&gt; m_extraTime;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; currentTime &amp;gt;&lt;span&gt; endTime;
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;// 具体的 Anlalyzer示例: DumpAnlalyzer.process&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体的 Anlalyzer示例: DumpAnlalyzer.process&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(MessageTree tree) {
        String domain &lt;/span&gt;=&lt;span&gt; tree.getDomain();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;PhoenixAgent&quot;&lt;span&gt;.equals(domain)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            MessageId messageId &lt;/span&gt;=&lt;span&gt; MessageId.parse(tree.getMessageId());

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (messageId.getVersion() == 2&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算出当前时间范围，&lt;/span&gt;
                &lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; tree.getMessage().getTimestamp();
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; fixedTime = time - time %&lt;span&gt; (TimeHelper.ONE_HOUR);
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; idTime =&lt;span&gt; messageId.getTimestamp();
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; duration = fixedTime -&lt;span&gt; idTime;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (duration == 0 || duration == ONE_HOUR || duration == -&lt;span&gt;ONE_HOUR) {
                    m_bucketManager.storeMessage(tree, messageId);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    m_serverStateManager.addPigeonTimeError(&lt;/span&gt;1&lt;span&gt;);
                }
            }
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储log消息到本地文件，并后续上传到hdfs&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; storeMessage(&lt;span&gt;final&lt;/span&gt; MessageTree tree, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageId id) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; errorFlag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = Math.abs((id.getDomain() + '-' +&lt;span&gt; id.getIpAddress()).hashCode());
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (&lt;span&gt;int&lt;/span&gt;) (hash %&lt;span&gt; m_gzipThreads);
        MessageItem item &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageItem(tree, id);
        LinkedBlockingQueue&lt;/span&gt;&amp;lt;MessageItem&amp;gt; queue = m_messageQueues.get(index % (m_gzipThreads - 1&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result =&lt;span&gt; queue.offer(item);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result) {
            errorFlag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (m_last.offer(item)) {
                errorFlag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (errorFlag) {
            m_serverStateManager.addMessageDumpLoss(&lt;/span&gt;1&lt;span&gt;);
        }
        logStorageState(tree);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每1000个消息添加一个messageDump=1000&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; logStorageState(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageTree tree) {
        String domain &lt;/span&gt;=&lt;span&gt; tree.getDomain();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; ((DefaultMessageTree) tree).getBuffer().readableBytes();

        m_serverStateManager.addMessageSize(domain, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((++m_total) % CatConstants.SUCCESS_COUNT == 0&lt;span&gt;) {
            m_serverStateManager.addMessageDump(CatConstants.SUCCESS_COUNT);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;// EventAnalyzer.process 处理event消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(MessageTree tree) {
        String domain &lt;/span&gt;=&lt;span&gt; tree.getDomain();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (m_serverFilterConfigManager.validateDomain(domain)) {
            EventReport report &lt;/span&gt;= m_reportManager.getHourlyReport(getStartTime(), domain, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            Message message &lt;/span&gt;=&lt;span&gt; tree.getMessage();
            String ip &lt;/span&gt;=&lt;span&gt; tree.getIpAddress();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (message &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Transaction) {
                processTransaction(report, tree, (Transaction) message, ip);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (message &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Event) {
                processEvent(report, tree, (Event) message, ip);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环处理多个transation&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processTransaction(EventReport report, MessageTree tree, Transaction t, String ip) {
        List&lt;/span&gt;&amp;lt;Message&amp;gt; children =&lt;span&gt; t.getChildren();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Message child : children) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Transaction) {
                processTransaction(report, tree, (Transaction) child, ip);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (child &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Event) {
                processEvent(report, tree, (Event) child, ip);
            }
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; StateAnalyzer.process 对cat的机器作展示&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(MessageTree tree) {
        String domain &lt;/span&gt;=&lt;span&gt; tree.getDomain();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (m_serverFilterConfigManager.validateDomain(domain)) {
            StateReport report &lt;/span&gt;= m_reportManager.getHourlyReport(getStartTime(), Constants.CAT, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            String ip &lt;/span&gt;=&lt;span&gt; tree.getIpAddress();
            Machine machine &lt;/span&gt;=&lt;span&gt; report.findOrCreateMachine(NetworkInterfaceManager.INSTANCE.getLocalHostAddress());

            machine.findOrCreateProcessDomain(domain).addIp(ip);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;// 所有分析线程，由 Period 进行初始化启动所有的Analyzer备用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        SimpleDateFormat df &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);

        m_logger.info(String.format(&lt;/span&gt;&quot;Starting %s tasks in period [%s, %s]&quot;&lt;span&gt;, m_tasks.size(),
              df.format(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Date(m_startTime)), df.format(&lt;span&gt;new&lt;/span&gt; Date(m_endTime - 1&lt;span&gt;))));

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;String, List&amp;lt;PeriodTask&amp;gt;&amp;gt;&lt;span&gt; tasks : m_tasks.entrySet()) {
            List&lt;/span&gt;&amp;lt;PeriodTask&amp;gt; taskList =&lt;span&gt; tasks.getValue();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; taskList.size(); i++&lt;span&gt;) {
                PeriodTask task &lt;/span&gt;=&lt;span&gt; taskList.get(i);

                task.setIndex(i);

                Threads.forGroup(&lt;/span&gt;&quot;Cat-RealtimeConsumer&quot;&lt;span&gt;).start(task);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;// 为保证高可用，使用 ChannelManager, 专门检查channel通道是否仍然存活，如果出问题，则发起重连。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (m_active) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; make save message id index asyc&lt;/span&gt;
&lt;span&gt;            m_idfactory.saveMark();
            checkServerChanged();

            ChannelFuture activeFuture &lt;/span&gt;=&lt;span&gt; m_activeChannelHolder.getActiveFuture();
            List&lt;/span&gt;&amp;lt;InetSocketAddress&amp;gt; serverAddresses =&lt;span&gt; m_activeChannelHolder.getServerAddresses();

            doubleCheckActiveServer(activeFuture);
            reconnectDefaultServer(activeFuture, serverAddresses);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;10 * 1000L); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; check every 10 seconds&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignore&lt;/span&gt;
&lt;span&gt;            }
        }
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;总结起来就几个东西：&lt;br/&gt;　　1. 使用netty开启高性能的接收服务;&lt;br/&gt;　　2. 使用队列进行保存消息;&lt;br/&gt;　　3. 使用单独线程检测channel有效性，保证高可用;&lt;br/&gt;　　4. 所有单小时的数据，保存在内存中，速度特别快；&lt;/p&gt;&lt;p&gt;等等，来个图展示下：。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201808/830731-20180817235106668-448808560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;task 运行过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201808/830731-20180817235349842-946217060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 Aug 2018 15:59:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>之前讲了 cat-client 进行cat埋点上报，那么上报给谁呢？以及后续故事如何？让我们来看看 cat-consumer 是如何接收处理的？ 由cat-client发送数据，cat-consume</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yougewe/p/9494904.html</dc:identifier>
</item>
<item>
<title>【设计模式】桥接模式 Bridge Pattern - 蓝之风</title>
<link>http://www.cnblogs.com/vaiyanzi/p/9495941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vaiyanzi/p/9495941.html</guid>
<description>&lt;p&gt;开篇还是引用&lt;a href=&quot;https://www.cnblogs.com/zhenyulu/&quot;&gt;吕振宇老师&lt;/a&gt;的那篇经典的文章《&lt;a href=&quot;https://www.cnblogs.com/zhenyulu/articles/67016.html&quot;&gt;设计模式随笔－蜡笔与毛笔的故事&lt;/a&gt;》。这个真是太经典了，没有比这个例子能更好的阐明桥接模式了，这里我就直接盗来用了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235222609-1477777590.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235224227-359761058.png&quot; alt=&quot;image&quot; width=&quot;356&quot; height=&quot;330&quot; border=&quot;0&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235225767-788782116.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235228057-404253661.png&quot; alt=&quot;image&quot; width=&quot;358&quot; height=&quot;318&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在市面上卖的蜡笔很多，各种型号，各种颜色种类繁多, 假如一盒蜡笔有24种颜色，那么它能涂抹出24种不同的颜色来，蜡笔型号是固定的，如果想画出各种线条那么就要购买不同型号的蜡笔，假如我们要涂抹出粗，中，细三种线条，那么我们就要买3盒粗，中，细型号的蜡笔才能满足需求，那么就是3盒*24色=72只蜡笔。假如使用毛笔来作画，我们需要准备3只粗，中，细的毛笔和24种颜料就好了， 那么就是3只毛笔+24种颜料。使用毛笔和使用蜡笔的差别是：用毛笔只需要3+24=27，用蜡笔需要准备3*24=72. 为什么会出现这么大的差别呢？仔细分析就会发现，画画的时候不仅对笔的型号有要求，而且还对颜色有要求，也就是说有两个引起变化的点或者说有两个变化的维度。蜡笔的型号和颜色直接绑定在一起了，他们二者完全融合（耦合）在一起了，他们的属性从生产出来就已经固化了（是静态的），不能被改变了。 而毛笔的型号和颜料的颜色是毫无关系（解耦），毛笔厂家生产不同型号的毛笔，颜料厂家生产不同颜色的颜料，二者互不相干，只有在使用的时候用户决定用什么型号的毛笔蘸什么颜色的颜料（动态设置）来作画，这个时候毛笔和颜料才动态发生关系，如果用户想使用一个型号的毛笔画不同颜色的画，毛笔可以洗掉再蘸不同的颜色就可以。&lt;/p&gt;
&lt;p&gt;在看看蜡笔和毛笔在应对变化的优劣比较， 如果用户需要画一个加粗线条，蜡笔需要买一盒（24),毛笔只需要买一支就可以了。如果要加一种颜色，蜡笔需要增加4支（加粗，粗，中，细），而毛笔仅仅只需要增加一种颜色就够了。 从数学的角度来讲蜡笔不管是颜色或者型号的变化都会形成：型号数*颜色数，毛笔却是：型号数+颜色数。这样看来毛笔更有优势，更容易应对变化的需求。&lt;/p&gt;
&lt;p&gt;那么在软件开发的过程中也会碰到类似的问题，怎么来解决这类问题呢?这就是我们将要探讨的桥接模式（Brigde）。&lt;/p&gt;
&lt;h2&gt;一、桥接模式的定义&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;二、桥接模式结构图&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235229160-1932247610.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235230030-1024441996.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;627&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1、Abstraction（抽象类）：&lt;/h3&gt;
&lt;p&gt;用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。&lt;/p&gt;
&lt;h3&gt;2、RefinedAbstraction（扩充抽象类）：&lt;/h3&gt;
&lt;p&gt;扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。&lt;/p&gt;
&lt;h3&gt;3、Implementor（实现类接口）：&lt;/h3&gt;
&lt;p&gt;定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。&lt;/p&gt;
&lt;h3&gt;4、ConcreteImplementor（具体实现类）：&lt;/h3&gt;
&lt;p&gt;具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。&lt;/p&gt;
&lt;h2&gt;三、桥接模式经典实现&lt;/h2&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Implementor
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Operation();
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Abstraction
{
    &lt;span&gt;protected&lt;/span&gt; Implementor implementor;

    &lt;span&gt;public&lt;/span&gt; Implementor Implementor
    {
        &lt;span&gt;set&lt;/span&gt; { &lt;span&gt;this&lt;/span&gt;.implementor = &lt;span&gt;value&lt;/span&gt;; }
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Operation()
    {
        implementor.Operation();
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteImplementorA : Implementor
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Operation()
    {
        Console.WriteLine(&lt;span&gt;this&lt;/span&gt;.GetType().Name + &quot;&lt;span&gt; Operation&lt;/span&gt;&quot;);
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteImplementorB : Implementor
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Operation()
    {
        Console.WriteLine(&lt;span&gt;this&lt;/span&gt;.GetType().Name + &quot;&lt;span&gt; Operation&lt;/span&gt;&quot;);
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RefinedAbstraction : Abstraction
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Operation()
    {
        &lt;span&gt;base&lt;/span&gt;.Operation();
    }
}
&lt;/pre&gt;
&lt;p&gt;客户端调用：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    Abstraction abstraction = &lt;span&gt;new&lt;/span&gt; RefinedAbstraction();
    Implementor implementor = &lt;span&gt;new&lt;/span&gt; ConcreteImplementorA();
    abstraction.Implementor = implementor;
    abstraction.Operation();

    implementor = &lt;span&gt;new&lt;/span&gt; ConcreteImplementorB();
    abstraction.Implementor = implementor;
    abstraction.Operation();

    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235230679-1345132379.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235231364-740425944.png&quot; alt=&quot;image&quot; width=&quot;541&quot; height=&quot;87&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;四、桥接模式的实例&lt;/h2&gt;
&lt;p&gt;我们分别模拟实现开头提到的蜡笔和毛笔。我们只选择三种型号（Large，Middle，Small）和三种颜色（Red，Green, Blue).&lt;/p&gt;
&lt;h3&gt;1、蜡笔的实现&lt;/h3&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235232417-597981590.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235233932-843784319.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;634&quot; border=&quot;0&quot;/&gt;&lt;/a&gt; 蜡笔类结构图&lt;/p&gt;
&lt;p&gt;蜡笔类代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Crayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; size;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; color;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize();
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Display()
    {
        SetSize();
        SetColor();
        Console.WriteLine(&lt;span&gt;this&lt;/span&gt;.GetType().Name + &quot;&lt;span&gt;: [Size]=&lt;/span&gt;&quot; + size + &quot;&lt;span&gt;[Color]=&lt;/span&gt;&quot; + color);
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LargeCrayon : Crayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize()
    {
        size = &quot;&lt;span&gt;Large&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MiddleCrayon : Crayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize()
    {
        size = &quot;&lt;span&gt;Middle&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SmallCrayon : Crayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize()
    {
        size = &quot;&lt;span&gt;Small&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedLargeCrayon : LargeCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Red&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GreenLargeCrayon : LargeCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Green&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BlueLargeCrayon : LargeCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Blue&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedMiddleCrayon : MiddleCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Red&lt;/span&gt;&quot;;
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GreenMiddleCrayon : MiddleCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Green&lt;/span&gt;&quot;;
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BlueMiddleCrayon : MiddleCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Blue&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedSmallCrayon : SmallCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Red&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GreenSmallCrayon : SmallCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Green&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BlueSmallCrayon : SmallCrayon
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor()
    {
        color = &quot;&lt;span&gt;Blue&lt;/span&gt;&quot;;
    }
}
&lt;/pre&gt;
&lt;p&gt;客户端调用：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    Crayon.Crayon redLargeCrayon, greenLargeCrayon, blueLargeCrayon,
                redMiddleCrayon, greenMiddleCrayon, blueMiddleCrayon,
                redSmallCrayon, greenSmallCrayon, blueSmallCrayon;
            
    redLargeCrayon = &lt;span&gt;new&lt;/span&gt; RedLargeCrayon();
    greenLargeCrayon = &lt;span&gt;new&lt;/span&gt; GreenLargeCrayon();
    blueLargeCrayon = &lt;span&gt;new&lt;/span&gt; BlueLargeCrayon();

    redMiddleCrayon = &lt;span&gt;new&lt;/span&gt; RedMiddleCrayon();
    greenMiddleCrayon = &lt;span&gt;new&lt;/span&gt; GreenMiddleCrayon();
    blueMiddleCrayon = &lt;span&gt;new&lt;/span&gt; BlueMiddleCrayon();

    redSmallCrayon = &lt;span&gt;new&lt;/span&gt; RedSmallCrayon();
    greenSmallCrayon = &lt;span&gt;new&lt;/span&gt; GreenSmallCrayon();
    blueSmallCrayon = &lt;span&gt;new&lt;/span&gt; BlueSmallCrayon();

    redLargeCrayon.Display();
    greenLargeCrayon.Display();
    blueLargeCrayon.Display();

    redMiddleCrayon.Display();
    greenMiddleCrayon.Display();
    blueMiddleCrayon.Display();

    redSmallCrayon.Display();
    greenSmallCrayon.Display();
    blueSmallCrayon.Display();

    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235234607-1791034792.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235235516-357547394.png&quot; alt=&quot;image&quot; width=&quot;537&quot; height=&quot;212&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;蜡笔是一种典型的多层继承结构， 型号和颜色实在继承体系中得以实现，在程序编译的时候型号和颜色就已经绑定好了，在运行时无法再动态改变，并且类非常多，如果增加型号或者颜色将非常难以维护。&lt;/p&gt;
&lt;h3&gt;2、墨笔的实现&lt;/h3&gt;
&lt;p&gt; &lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235236389-299525447.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180817235237117-312113216.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;329&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;毛笔类结构图&lt;/p&gt;
&lt;p&gt;毛笔类代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Brush
{
    &lt;span&gt;private&lt;/span&gt; Color color;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; size;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetColor(Color color)
    {
        &lt;span&gt;this&lt;/span&gt;.color = color;
    }

    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize();
      

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Draw()
    {
        SetSize();
        Console.WriteLine(&lt;span&gt;this&lt;/span&gt;.GetType().Name + &quot;&lt;span&gt;: [Size]=&lt;/span&gt;&quot; + &lt;span&gt;this&lt;/span&gt;.size + &quot;&lt;span&gt;-&amp;gt;[Color]=&lt;/span&gt;&quot; + &lt;span&gt;this&lt;/span&gt;.color.CurrentColor);
    } 
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Color
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; color;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CurrentColor { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; color; } }       
}
&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt; RedColor:Color
{
    &lt;span&gt;public&lt;/span&gt; RedColor()
    {
        &lt;span&gt;this&lt;/span&gt;.color = &quot;&lt;span&gt;Red&lt;/span&gt;&quot;;
    }       
}

&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt; GreenColor:Color
{
    &lt;span&gt;public&lt;/span&gt; GreenColor()
    {
        &lt;span&gt;this&lt;/span&gt;.color = &quot;&lt;span&gt;Green&lt;/span&gt;&quot;;
    }       
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BlueColor : Color
{
    &lt;span&gt;public&lt;/span&gt; BlueColor()
    {
        &lt;span&gt;this&lt;/span&gt;.color = &quot;&lt;span&gt;Blue&lt;/span&gt;&quot;;
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LargeBrush : Brush
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize()
    {
        &lt;span&gt;this&lt;/span&gt;.size = &quot;&lt;span&gt;Large&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MiddleBrush : Brush
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize()
    {
        &lt;span&gt;this&lt;/span&gt;.size = &quot;&lt;span&gt;Middle&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SmallBrush : Brush
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSize()
    {
        &lt;span&gt;this&lt;/span&gt;.size = &quot;&lt;span&gt;Small&lt;/span&gt;&quot;;
    }
}
&lt;/pre&gt;
&lt;p&gt;  客户端调用：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    Brush largeBrush, middleBrush, smallBrush;
    Color red, green, blue;
  
    red = &lt;span&gt;new&lt;/span&gt; RedColor();
    green = &lt;span&gt;new&lt;/span&gt; GreenColor();
    blue = &lt;span&gt;new&lt;/span&gt; BlueColor();

    largeBrush = &lt;span&gt;new&lt;/span&gt; LargeBrush();
    middleBrush = &lt;span&gt;new&lt;/span&gt; MiddleBrush();
    smallBrush = &lt;span&gt;new&lt;/span&gt; SmallBrush();

    largeBrush.SetColor(red);
    largeBrush.Draw();

    largeBrush.SetColor(green);
    largeBrush.Draw();

    largeBrush.SetColor(blue);
    largeBrush.Draw();

    middleBrush.SetColor(red);
    middleBrush.Draw();

    middleBrush.SetColor(green);
    middleBrush.Draw();

    middleBrush.SetColor(blue);
    middleBrush.Draw();
   
    smallBrush.SetColor(red);
    smallBrush.Draw();

    smallBrush.SetColor(green);
    smallBrush.Draw();

    smallBrush.SetColor(blue);
    smallBrush.Draw();
        
    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
LargeBrush: [Size]=Large-&amp;gt;[Color]=Red
LargeBrush: [Size]=Large-&amp;gt;[Color]=Green
LargeBrush: [Size]=Large-&amp;gt;[Color]=Blue
MiddleBrush: [Size]=Middle-&amp;gt;[Color]=Red
MiddleBrush: [Size]=Middle-&amp;gt;[Color]=Green
MiddleBrush: [Size]=Middle-&amp;gt;[Color]=Blue
SmallBrush: [Size]=Small-&amp;gt;[Color]=Red
SmallBrush: [Size]=Small-&amp;gt;[Color]=Green
SmallBrush: [Size]=Small-&amp;gt;[Color]=Blue
&lt;/pre&gt;
&lt;p&gt;毛笔类之间的结构发生了一些变化，将蜡笔的深度继承关系变成了一个平行的关联关系，这样带来的好处是毛笔的型号和颜色可以在两个体系中独立的变化而互不影响。这样就降低了耦合度，提高了扩展性，和可维护性，使得类的数量也急剧减少，降低了复杂度。&lt;/p&gt;
&lt;h2&gt;五、桥接模式的优点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便各自子类的组合，从而获得多维度组合对象。&lt;/li&gt;
&lt;li&gt;在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“&lt;a href=&quot;https://www.cnblogs.com/vaiyanzi/p/6877436.html&quot;&gt;单一职责原则(SRP)&lt;/a&gt;”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了类的个数。&lt;/li&gt;
&lt;li&gt;桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“&lt;a href=&quot;https://www.cnblogs.com/vaiyanzi/p/6894636.html&quot;&gt;开闭原则(OCP)&lt;/a&gt;”。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;六、桥接模式的缺点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就就要针对抽象层进行设计与编程。&lt;/li&gt;
&lt;li&gt;桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;七、桥接模式的使用场景&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。&lt;/li&gt;
&lt;li&gt;“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。&lt;/li&gt;
&lt;li&gt;一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。&lt;/li&gt;
&lt;li&gt;对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，使用桥接模式。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;八、练习&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;某软件公司欲开发一个数据转换工具，可以将数据库中的数据转换成多种文件格式，例如txt、xml、pdf等格式，同时该工具需要支持多种不同的数据库。试使用桥接模式对其进行设计。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以使用桥接模式做一个简单的实现如下：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Database
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetData();
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Exportor
{
    &lt;span&gt;private&lt;/span&gt; Database database;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetDatabase(Database database)
    {
        &lt;span&gt;this&lt;/span&gt;.database = database;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Export()
    {
        var data = &lt;span&gt;this&lt;/span&gt;.database.GetData();
        var fileType = &lt;span&gt;this&lt;/span&gt;.GetFileType();
        Console.WriteLine(&lt;span&gt;this&lt;/span&gt;.GetType().Name + &quot;&lt;span&gt;[Database] is [&lt;/span&gt;&quot; + data + &quot;&lt;span&gt;] [FileType] is [&lt;/span&gt;&quot; + fileType + &quot;&lt;span&gt;]&lt;/span&gt;&quot;);
    }

    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFileType();
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SQLDatabase : Database
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetData()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;SQLDatabase&lt;/span&gt;&quot;;
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OracalDatabase : Database
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetData()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;OracalDatabase&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SQLiteDatabase : Database
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetData()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;SQLiteDatabase&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DBaseDatabase : Database
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetData()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;DBaseDatabase&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ExcelExportor : Exportor
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFileType()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;Excel&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TxtExportor : Exportor
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFileType()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;TxT&lt;/span&gt;&quot;;
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XmlExportor : Exportor
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFileType()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;XML&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PDFExportor : Exportor
{
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFileType()
    {
        &lt;span&gt;return&lt;/span&gt; &quot;&lt;span&gt;PDF&lt;/span&gt;&quot;;
    }
}
&lt;/pre&gt;
&lt;p&gt;客户端调用：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ExecuteExport()
{
    Exportor exportExcel, exportPdf, exportXml, exportTxt;
    Database sql, sqlite, dbase, oracal;
    sql = &lt;span&gt;new&lt;/span&gt; SQLDatabase();
    sqlite = &lt;span&gt;new&lt;/span&gt; SQLiteDatabase();
    dbase = &lt;span&gt;new&lt;/span&gt; DBaseDatabase();
    oracal = &lt;span&gt;new&lt;/span&gt; OracalDatabase();

    exportExcel = &lt;span&gt;new&lt;/span&gt; ExcelExportor();
    exportPdf = &lt;span&gt;new&lt;/span&gt; PDFExportor();
    exportTxt = &lt;span&gt;new&lt;/span&gt; PDFExportor();
    exportXml = &lt;span&gt;new&lt;/span&gt; XmlExportor();

    exportXml.SetDatabase(sql);
    exportXml.Export();
    exportXml.SetDatabase(oracal);
    exportXml.Export();
}
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
XmlExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [XML]
XmlExportor[Database] &lt;span&gt;is&lt;/span&gt; [OracalDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [XML]
&lt;/pre&gt;
&lt;p&gt;抽出一个泛型执行器，使客户端调用代码更优雅一点，泛型执行器的代码如下：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IExportorExcutor&amp;lt;&lt;span&gt;in&lt;/span&gt; T, &lt;span&gt;in&lt;/span&gt; V&amp;gt;
    where T : Exportor
    where V : Database
{
    &lt;span&gt;void&lt;/span&gt; Execute();

}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ExportorExcutor&amp;lt;T, V&amp;gt; : IExportorExcutor&amp;lt;T, V&amp;gt;
    where T : Exportor, &lt;span&gt;new&lt;/span&gt;()
    where V : Database, &lt;span&gt;new&lt;/span&gt;()
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IExportorExcutor&amp;lt;T, V&amp;gt; Of()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ExportorExcutor&amp;lt;T, V&amp;gt;();
    }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Execute()
    {
        var export = &lt;span&gt;new&lt;/span&gt; T();
        var database = &lt;span&gt;new&lt;/span&gt; V();
        export.SetDatabase(database);
        export.Export();
    }
}
&lt;/pre&gt;
&lt;p&gt;客户端调用代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    ExportorExcutor&amp;lt;ExcelExportor, SQLiteDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;ExcelExportor, OracalDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;ExcelExportor, SQLDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;ExcelExportor, DBaseDatabase&amp;gt;.Of().Execute();

    ExportorExcutor&amp;lt;PDFExportor, SQLiteDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;PDFExportor, OracalDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;PDFExportor, SQLDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;PDFExportor, DBaseDatabase&amp;gt;.Of().Execute();

    ExportorExcutor&amp;lt;TxtExportor, SQLiteDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;TxtExportor, OracalDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;TxtExportor, SQLDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;TxtExportor, DBaseDatabase&amp;gt;.Of().Execute();

    ExportorExcutor&amp;lt;XmlExportor, SQLiteDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;XmlExportor, OracalDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;XmlExportor, SQLDatabase&amp;gt;.Of().Execute();
    ExportorExcutor&amp;lt;XmlExportor, DBaseDatabase&amp;gt;.Of().Execute();        

    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
ExcelExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLiteDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [Excel]
ExcelExportor[Database] &lt;span&gt;is&lt;/span&gt; [OracalDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [Excel]
ExcelExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [Excel]
ExcelExportor[Database] &lt;span&gt;is&lt;/span&gt; [DBaseDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [Excel]
PDFExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLiteDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [PDF]
PDFExportor[Database] &lt;span&gt;is&lt;/span&gt; [OracalDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [PDF]
PDFExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [PDF]
PDFExportor[Database] &lt;span&gt;is&lt;/span&gt; [DBaseDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [PDF]
TxtExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLiteDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [TxT]
TxtExportor[Database] &lt;span&gt;is&lt;/span&gt; [OracalDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [TxT]
TxtExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [TxT]
TxtExportor[Database] &lt;span&gt;is&lt;/span&gt; [DBaseDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [TxT]
XmlExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLiteDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [XML]
XmlExportor[Database] &lt;span&gt;is&lt;/span&gt; [OracalDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [XML]
XmlExportor[Database] &lt;span&gt;is&lt;/span&gt; [SQLDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [XML]
XmlExportor[Database] &lt;span&gt;is&lt;/span&gt; [DBaseDatabase] [FileType] &lt;span&gt;is&lt;/span&gt; [XML]
&lt;/pre&gt;
&lt;p&gt;桥接模式就探讨到这里。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 15:53:00 +0000</pubDate>
<dc:creator>蓝之风</dc:creator>
<og:description>开篇还是引用吕振宇老师的那篇经典的文章《设计模式随笔－蜡笔与毛笔的故事》。这个真是太经典了，没有比这个例子能更好的阐明桥接模式了，这里我就直接盗来用了。 现在市面上卖的蜡笔很多，各种型号，各种颜色种类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vaiyanzi/p/9495941.html</dc:identifier>
</item>
<item>
<title>IdentityServer4  well-known/openid-configuration - tianyamoon</title>
<link>http://www.cnblogs.com/tianyamoon/p/9490953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianyamoon/p/9490953.html</guid>
<description>&lt;p&gt;在.net core出来以后很多人使用identityServer做身份验证。&lt;/p&gt;
&lt;p&gt;ids4和ids3的token验证组件都是基于微软的oauth2和bearer验证组件。园子里也很多教程，我们通过教程了解到is4有一个discovery endpoint。&lt;/p&gt;
&lt;p&gt;顾名思义，Discovery定义了一个服务发现的规范，它定义了一个api（ /.well-known/openid-configuration ），这个api返回一个json数据结构，其中包含了一些OIDC中提供的服务以及其支持情况的描述信息，这样可以使得oidc服务的RP可以不再硬编码OIDC服务接口信息。这个api返回的示例信息如下（这里面只是一部分）。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79.652677279305&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,发行网址，也就是说我们的权限验证站点。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jwks_uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/.well-known/openid-configuration/jwks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,这个接口获取的是公钥，用于验证jwt的数字签名部分（数字签名由sso维护的私钥生成）用的。　　　&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorization_endpoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/connect/authorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,授权服务器的授权端点的URL。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token_endpoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/connect/token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,获取token的网址&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userinfo_endpoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/connect/userinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,根据token获取用户信息&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;end_session_endpoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/connect/endsession&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span class=&quot;transSent highlight&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;2-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;2-1&quot;&gt;登录注销。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;　　 &quot;&lt;/span&gt;&lt;span&gt;check_session_iframe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/connect/checksession&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;客户端对&lt;code&gt;check_session_iframe&lt;/code&gt;执行监视，可以获取用户的登出状态。&lt;/span&gt;&lt;span&gt;　　 &quot;&lt;/span&gt;&lt;span&gt;revocation_endpoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/connect/revocation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-0&quot;&gt; 这个网址允许撤销访问令牌(仅access tokens 和reference tokens)。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;它实现了令牌撤销规范(RFC 7009)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　 &quot;&lt;/span&gt;&lt;span&gt;introspection_endpoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/connect/introspect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt; introspection_endpoint是&lt;/em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;RFC 7662的实现。 &lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;2-0&quot;&gt;它可以用于验证reference tokens(或如果消费者不支持适当的JWT或加密库，则JWTs)。&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　 &quot;&lt;/span&gt;&lt;span&gt;frontchannel_logout_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, 可选。基于前端的注销机制。&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;frontchannel_logout_session_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;可选。基于session的注销机制。&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;backchannel_logout_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, 指示OP支持后端通道注销&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;backchannel_logout_session_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;可选的。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;指定RP是否需要在注销令牌中包含sid(session ID)声明，以在使用backchannel_logout_uri时用OP标识RP会话。&lt;/span&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-2&quot;&gt;如果省略，默认值为false。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;scopes_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;offline_access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ], 支持的范围&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;claims_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [], 支持的claims&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;grant_types_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_credentials&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refresh_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ], 授权类型&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;response_types_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code id_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code id_token token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ], &lt;br/&gt;　　支持的请求方式&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;response_modes_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form_post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fragment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ],&lt;br/&gt;　　传值方式&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;token_endpoint_auth_methods_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_secret_basic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_secret_post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ],&lt;br/&gt;　　&lt;/span&gt;JSON数组，包含此令牌端点支持的客户端身份验证方法列表。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;subject_types_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ], &lt;br/&gt;&lt;/span&gt;　　JSON数组，包含此OP支持的主题标识符类型列表。 有效值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;pairwise&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;&lt;span&gt;.类型。 &lt;/span&gt;&lt;a href=&quot;https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes&quot;&gt;更多信息&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;id_token_signing_alg_values_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RS256&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ], &lt;br/&gt;　　&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　&quot;&lt;/span&gt;&lt;span&gt;code_challenge_methods_supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S256&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ] &lt;br/&gt;&lt;/span&gt;　　JSON数组，包含此授权服务器支持的PKCE代码方法列表。&lt;span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;相关链接：&lt;br/&gt;&lt;a href=&quot;https://developer.okta.com/docs/api/resources/oidc#2-okta-as-the-identity-platform-for-your-app-or-api&quot; target=&quot;_blank&quot;&gt;OpenID Connect &amp;amp; OAuth 2.0 API&lt;/a&gt;&lt;a href=&quot;http://openid.net/specs/openid-connect-backchannel-1_0.html&quot; target=&quot;_blank&quot;&gt;OpenID Connect Back-Channel Logout 1.0 - draft 04&lt;/a&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 15:50:00 +0000</pubDate>
<dc:creator>tianyamoon</dc:creator>
<og:description>在.net core出来以后很多人使用identityServer做身份验证。 ids4和ids3的token验证组件都是基于微软的oauth2和bearer验证组件。园子里也很多教程，我们通过教程了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianyamoon/p/9490953.html</dc:identifier>
</item>
<item>
<title>最小白的webpack+react环境搭建 - 我的天空-老潘</title>
<link>http://www.cnblogs.com/mysky7511/p/9495924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mysky7511/p/9495924.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;本文也同步发表在我的公众号“&lt;strong&gt;我的天空&lt;/strong&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/1131813/201704/1131813-20170417170941102-1261679178.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从零开始，用最少的配置、最少的代码、最少的依赖来搭建一个最简单的webpack+react环境。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近在玩webpack+react+移动端，那么第一步自然是搭建相关的环境，本来网上的教程很不错，只是前端相关的东西发展太过迅猛，只相隔了半年有些东西的版本就不对了，有些配置、命令等照着之前的教程做就可能会掉到坑里去，别问我怎么知道的，我刚刚从坑里爬出来，因此赶紧写篇文章来记录一下，也算是让自己再巩固一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇完全是从零开始，用最少的配置、最少的代码、最少的依赖来搭建一个最简单的webpack+react环境。会把一个小白的经历原原本本的写出来，遇到的坑都用红色的&lt;span&gt;&lt;strong&gt;坑&lt;/strong&gt;&lt;span&gt;字标注出来，&lt;span&gt;由于我也是第一次学习相关的知识点如果有不正确的地方也多多欢迎大家来指出。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇文章写作的日期是2018-7-21，因此所有依赖的版本到当前日期为止，以后如果有升级变化的话，那也是无法当前预料得到的。我的操作系统是win7，因此不涉及到linux的相关知识点。编辑器是Sublime Text3.0，顺便安利一下Sublime Text，好用速度又快，真心不错！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我是参考这篇教程：https://segmentfault.com/a/1190000006178770&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;现在让我们开始吧，第一步我们先配置一个webpack的web服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;webpack依赖于node.js，那么第一步是安装node.js，这个没什么好说的，windows环境的安装就更友好了，官网下载安装包，一路默认安装即可，现在的node.js安装完毕后，npm也就自带安装好了，后面我们就要一路与npm打交道了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们要用npm初始化项目，电脑上新建一个目录保存我们的练习文件，随后进入cmd命令行，转到该目录下。如果命令行不会操作的话，请先掌握&lt;strong&gt;cd&lt;/strong&gt;这个命令。接下来在该目录下输入&lt;strong&gt;npm init&lt;/strong&gt;命令：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;根据提示一路回车就可以了，不过这个地方可能会有一个&lt;span&gt;&lt;strong&gt;坑&lt;/strong&gt;&lt;span&gt;存在，如图：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817222845744-1809198137.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里报错：Sorry，name can only contain URL-friendly characters。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该错误产生的原因是npm初始化时，会向我们询问项目名，如果我们不指定的话（通常都是如此），那么就会用当前文件夹来命名，而我们的文件夹的名称为“练习-react环境”，其包含了一个中划线（-），因此导致命名错误了。那么我们只要输入一个项目名称（譬如test）就可以了， 或者干脆把文件夹重命名为符合规范的名称就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本例中我们手动输入了test，将项目名称指定为test：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817223028786-1758375257.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来就一路回车，最后询问“&lt;strong&gt;Is this OK？&amp;lt;y&amp;gt;&lt;/strong&gt;”时输入y后回车，完成npm初始化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817223135557-1437123482.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;npm初始化后，在文件夹下将会出现一个&lt;strong&gt;node_modules&lt;/strong&gt;文件夹（目前为空），以及&lt;strong&gt;pack.json&lt;/strong&gt;文件。其实我们刚才npm init命令就是为了配置这个package.json，因此也可以完全自己来手动创建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来安装webpack和webpack-dev-server，执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install webpack webpack-dev-server --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;安装webpack很顺利，没有遇到任何问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完毕后，node_modules文件夹中就不再为空了，里面存放的都是webpack的相关依赖。package.json中也多了&quot;&lt;strong&gt;dependencies&lt;/strong&gt;&quot;和&quot;&lt;strong&gt;devDependencies&lt;/strong&gt;&quot;两项，其记录的是当前依赖及版本信息，其中&quot;dependencies&quot;为空。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;devDependencies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webpack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^4.16.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webpack-dev-server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^3.1.4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
},
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;随后在当前文件夹下新建一个public文件夹（文件夹名任意），在里面写一个index.html页面，内容随意。接下来我们就要配置webpack了，在文件夹下新建一个&lt;strong&gt;&lt;span&gt;webpack.config.js&lt;/span&gt;&lt;/strong&gt;文件，此时目录结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817223642863-828558272.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编辑webpack.config.js，由于我们的目的是创建一个web服务器，因此只需要配置以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
module.exports=&lt;span&gt;{
    devServer:{
        contentBase:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./public&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;devServer是webpack中web服务器的相关配置项，contentBase指定的是页面加载目录，而其加载页面默认为index.html，由于我们的index.html是在public目录下，因此就将contentBase设置为&quot;./public“。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来在package.json中配置web服务启动命令，该命令配置在scripts中的，其命令名称为“server”，命令详情为“webpack-dev-sever --open”：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webpack-dev-server --open&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将其插入scripts中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scripts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webpack-dev-server --open&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在命令行中输入&quot;npm run server”回车以便启动web服务，此时会遇到一个&lt;strong&gt;&lt;span&gt;坑&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，webpack并没有启动web服务，而是报错：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817224026516-389829489.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其大意是缺少webpack-cli，那么我们自然就安装这个webpack-cli，执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install webpack-cli --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;webpack-cli安装过程很顺利，随后再执行“npm run server”就可以正常启动web服务了，并且启动默认浏览器，显示public下的Index.html页面，web服务的默认端口是8080。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817224138277-324255368.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，我们第一部分的目的：启动一个web服务便完成了，总结一下，要从零开始启动webpack的web服务需要做：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;安装node.js、npm&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;安装webpack、webpack-cli、webpack-server-dev&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;npm初始化&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;编写一个显示页面并命名为index.html&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;创建webpack.config.js，并配置devServer信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;配置package.json，设置web启动命令。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;到目前为止，我们丝毫未提及另一位主角：react，接下来我们就继续搭建环境，让其支持react。首先自然是要安装react，我们需要安装react和react-dom，执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install react react-dom --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于react是在正式环境中也需要的，因此npm安装时没有带-dev参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来修改之前的index.html，不管以前是怎么编写的，请在HTML中增加一个 &amp;lt;div&amp;gt;，将其的ID设置为&quot;boot“，同时编写外部js引入，引入的js名为bundle.js。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='root'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script  &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='bundle.js'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来在public目录下创建index.jsx文件，注意后缀名是&lt;strong&gt;jsx&lt;/strong&gt;，其内容为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;
import { render } from &lt;/span&gt;'react-dom'&lt;span&gt;

class Hello extends React.Component {
    render() {
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
           &lt;/span&gt;&amp;lt;p&amp;gt;hello react！&amp;lt;/p&amp;gt;
&lt;span&gt;        )
    }
}
render(
    &lt;/span&gt;&amp;lt;Hello/&amp;gt;,
    document.getElementById('root'&lt;span&gt;)
)   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;react的语法细节我们暂时不关心，只要知道最后页面上会输出&lt;strong&gt;hello react！&lt;/strong&gt;就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jsx是react的专用语法，HTML是无法引用的，因此我们需要将其转换为HTML能够识别的JS，而这个正是webpack大显身手的时候，我们开始来配置webpack，配置之前，再确认一下的当前的目录结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817224540699-145850740.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们是通过babel来转换jsx的，因此需要安装babel相关的环境，我们需要安装：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;babel-core&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;babel-loader&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;babel-preset-es2015&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;babel-preset-react&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install babel-core babel-loader babel-preset-es2015 babel-preset-react --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于我们要转换的源文件是index.jsx，转换后的目标文件是bundle.js，因此需要在webpack中配置入口和出口，在文本webpack.config.js中增加以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;entry:__dirname+&quot;/public/index.jsx&quot;,
output:{
     path:__dirname+&quot;/public&quot;,
     filename:'bundle.js'
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;entry&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是转换的入口，而&lt;strong&gt;output&lt;/strong&gt;是转换的出口。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时还要在webpack.config.js中配置loader，让其通过外部工具来处理文件，而我们当前要处理的是通过babel来处理jsx文件。因此到了这一步我们大致会有些明白了，并不是webpack本身帮我们处理这些，而是像个中介一样，把要处理的部分与相关的工具联系在一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在webpack.config.js中加入：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module: {
    loaders: [
        { test: &lt;/span&gt;/\.(jsx)$/, exclude: /node_modules/, loader: 'babel'&lt;span&gt; }
    ]    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其表明jsx文件需要用babel来处理，但是对于node_modules文件夹中的文件忽略掉（exclude设置）。此时webpack.config.js的内容就是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
module.exports=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;entry:__dirname&lt;/span&gt;+&quot;/app/index.jsx&quot;&lt;span&gt;,
    output:{
        path:__dirname&lt;/span&gt;+&quot;/app&quot;&lt;span&gt;,
        filename:&lt;/span&gt;'bundle.js'&lt;span&gt;
    },
    devServer:{
        contentBase:&lt;/span&gt;&quot;./public&quot;&lt;span&gt;
    },
&lt;/span&gt;&lt;span&gt;    module: {
        loaders: [
            { test: &lt;/span&gt;/\.(js|jsx)$/, exclude: /node_modules/, loader: 'babel'&lt;span&gt; }
        ]
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;照理来说，到了这一步所有该做的事情都已经做完了，通过babel将index.jsx解析成bundle.js，Web服务将启动index.html，而index.html会引入bundle.js，最后在页面上显示hello react！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，事情往往不是那么顺利的，接下里要继续踩坑！首先我们先执行&lt;strong&gt;npm run server&lt;/strong&gt;看看是什么情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817225329838-563605788.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;马上就遇到&lt;span&gt;&lt;strong&gt;坑&lt;/strong&gt;&lt;span&gt;，刺眼的红色错误提示，意思居然是loaders属性无效？！问题出现在webpack版本上，我们安装的版本是4.16.1，此时&lt;span&gt;webpack.config.js中loaders的写法已经过时，应该用&lt;strong&gt;rules&lt;/strong&gt;，同时babel也应该用babel-loader来替代，实际的写法为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module: {
   rules: [
        { test: &lt;/span&gt;/\.(jsx)$/, exclude: /node_modules/, loader: 'babel-loader'&lt;span&gt; }
    ]    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时webpack.config.js的内容为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
module.exports=&lt;span&gt;{
    entry:__dirname&lt;/span&gt;+&quot;/app/index.jsx&quot;&lt;span&gt;,
    output:{
        path:__dirname&lt;/span&gt;+&quot;/app&quot;&lt;span&gt;,
        filename:&lt;/span&gt;'bundle.js'&lt;span&gt;
    },
    devServer:{
        contentBase:&lt;/span&gt;&quot;./public&quot;&lt;span&gt;
    },
    module: {
        rules: [
            { test: &lt;/span&gt;/\.(js|jsx)$/, exclude: /node_modules/, loader: 'babel-loader'&lt;span&gt; }
        ]
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来继续试试&lt;strong&gt;npm run server&lt;/strong&gt;，依然报错：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817225659821-846854482.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处仍然有一&lt;span&gt;&lt;strong&gt;坑&lt;/strong&gt;&lt;span&gt;！由于我们的jsx是用es6语法编写的，因此需要通过label来解析，那么实际上此处还缺少一个文件，就是“&lt;strong&gt;.babelrc&lt;/strong&gt;”，注意这是一个名称很奇葩的文件，只有扩展名而没有文件名，该文件在windows环境下是无法通过资源管理器创建的，需要到命令行下执行&lt;strong&gt;type null&amp;gt;.babelrc&lt;/strong&gt;命令：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
type &lt;span&gt;null&lt;/span&gt;&amp;gt;.babelrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817225917459-377450806.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然提示“系统找不到指定的文件”，但是实际上已经创建了.babelrc文件，随后用文本编辑器将该文件打开，输入内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;&lt;span&gt;],
  &lt;/span&gt;&quot;env&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;dev&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;plugins&quot;: [[&quot;react-transform&quot;&lt;span&gt;, {
           &lt;/span&gt;&quot;transforms&quot;&lt;span&gt;: [{
             &lt;/span&gt;&quot;transform&quot;: &quot;react-transform-hmr&quot;&lt;span&gt;,
             &lt;/span&gt;&quot;imports&quot;: [&quot;react&quot;&lt;span&gt;],
             &lt;/span&gt;&quot;locals&quot;: [&quot;module&quot;&lt;span&gt;]
           }]
        }]]
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，再执行npm run server，终于可以看到页面正常显示了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817230122275-1435310359.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如&lt;span&gt;果此时页面还不能正常显示的话，也许就要清理下缓存，重新生成bundle.js文件。或者在package.json中的scripts中增加“start“命令，其值为“webpack”，即：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;start&quot;: &quot;webpack&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;server&quot;: &quot;webpack-dev-server --open&quot;&lt;span&gt;
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样在命令行中执行“&lt;strong&gt;npm start&lt;/strong&gt;”就可以重新编译jsx为bundle.js了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再总结一下我们遇到的&lt;span&gt;&lt;strong&gt;坑&lt;/strong&gt;&lt;span&gt;：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;npm初始化时的项目名称要合规，特别是不能出现中划线下划线。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;安装webpack-cli。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;loaders已过时，需要替换为rules。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;需要创建.babelrc文件。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;至此我们便搭建了一个最简单的webpack+react环境，当我们修改index.jsx中的内容时，页面刷新后也会发生改变，接下来就可以好好学习react了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，我们可以更改webpack.config.js中的devServer，添加inline:true，这样便可以实现jsx更改后，页面会自动刷新，不用我们每次修改后都去手动刷新去看效果了。另外再增加mode:&quot;development&quot;，这样刷新的速度会大大加快！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终的文件目录结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1131813/201808/1131813-20180817230336719-1068696949.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;各文件的最终内容：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='root'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script  &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='bundle.js'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;index.jsx&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;
import { render } from &lt;/span&gt;'react-dom'&lt;span&gt;

class Home extends React.Component{
    render(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&amp;lt;p&amp;gt;Hello react!&amp;lt;/p&amp;gt; 
&lt;span&gt;    )
    }
}
render(
    &lt;/span&gt;&amp;lt;Hello /&amp;gt;,document.getElementById('root')
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;.babelrc&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;&lt;span&gt;],
  &lt;/span&gt;&quot;env&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;dev&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;plugins&quot;: [[&quot;react-transform&quot;&lt;span&gt;, {
           &lt;/span&gt;&quot;transforms&quot;&lt;span&gt;: [{
             &lt;/span&gt;&quot;transform&quot;: &quot;react-transform-hmr&quot;&lt;span&gt;,
             &lt;/span&gt;&quot;imports&quot;: [&quot;react&quot;&lt;span&gt;],
             &lt;/span&gt;&quot;locals&quot;: [&quot;module&quot;&lt;span&gt;]
           }]
        }]]
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;package.json&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;name&quot;: &quot;test&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;version&quot;: &quot;1.0.0&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;description&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;main&quot;: &quot;index.js&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;start&quot;: &quot;webpack&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;server&quot;: &quot;webpack-dev-server --open&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;author&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;license&quot;: &quot;ISC&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;devDependencies&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;babel-core&quot;: &quot;^6.26.3&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;babel-loader&quot;: &quot;^7.1.5&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;babel-preset-react&quot;: &quot;^6.24.1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;webpack&quot;: &quot;^4.16.1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;webpack-dev-server&quot;: &quot;^3.1.4&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;dependencies&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;react&quot;: &quot;^16.4.1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;react-dom&quot;: &quot;^16.4.1&quot;&lt;span&gt;,
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;webpack.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
module.exports=&lt;span&gt;{&lt;br/&gt;&lt;span&gt;   mode:&quot;development&quot;,&lt;/span&gt;
    entry:__dirname&lt;/span&gt;+&quot;/app/index.jsx&quot;&lt;span&gt;,
    output:{
        path:__dirname&lt;/span&gt;+&quot;/app&quot;&lt;span&gt;,
        filename:&lt;/span&gt;'bundle.js'&lt;span&gt;
    },
    devServer:{
        contentBase:&lt;/span&gt;&quot;./public&quot;,&lt;br/&gt;&lt;span&gt;       inline:true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    },
    module: {
        rules: [
            { test: &lt;/span&gt;/\.(js|jsx)$/, exclude: /node_modules/, loader: 'babel-loader'&lt;span&gt; }
        ]
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 17 Aug 2018 15:38:00 +0000</pubDate>
<dc:creator>我的天空-老潘</dc:creator>
<og:description>从零开始，用最少的配置、最少的代码、最少的依赖来搭建一个最简单的webpack+react环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mysky7511/p/9495924.html</dc:identifier>
</item>
<item>
<title>彻底弄懂字符串常量池等相关问题 - 小勇DW3</title>
<link>http://www.cnblogs.com/gxyandwmm/p/9495923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxyandwmm/p/9495923.html</guid>
<description>&lt;p&gt;　　在平时我们使用字符串一般就是拿来直接搞起，很少有深入的去想过这方面的知识&lt;span&gt;&lt;strong&gt;&lt;span&gt;，导致别人在考我们的时候，会问 String str = new String(&quot;123&quot;); 这个一行代码执行创建了几个对象， String str1= str + new String(&quot;456&quot;);这行代码中str1存储在内存的哪个位置，堆or 字符串常量区（方法区）？ 会把我们问的哑口无言了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;；哈哈哈哈，其实也不是水平问题，是我们平时可以仔细的去总结该类问题，下面就详细的对这类问题进行总结；&lt;/p&gt;


&lt;p&gt;问题1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　 String str1 = &lt;span&gt;new&lt;/span&gt; String(&quot;1&quot;&lt;span&gt;);
    str1.intern();
    String str2 &lt;/span&gt;= &quot;1&quot;&lt;span&gt;;
    System.out.println(str1 &lt;/span&gt;==&lt;span&gt; str2);  //结果是 false or true？

    String str3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;2&quot;) + &lt;span&gt;new&lt;/span&gt; String(&quot;2&quot;&lt;span&gt;);
    t3.intern();
    String str4 &lt;/span&gt;= &quot;22&quot;&lt;span&gt;;
    System.out.println(str3 &lt;/span&gt;== str4); //结果是 false or true？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　String str1 = &quot;aaa&quot;&lt;span&gt;;
  String str2 &lt;/span&gt;= &quot;bbb&quot;&lt;span&gt;;
  String str3 &lt;/span&gt;= &quot;aaabbb&quot;&lt;span&gt;;
  String str4 &lt;/span&gt;= str1 +&lt;span&gt; str2;
  String str5 &lt;/span&gt;= &quot;aaa&quot; + &quot;bbb&quot;&lt;span&gt;;
  System.out.println(str3 &lt;/span&gt;== str4); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false or true&lt;/span&gt;
  System.out.println(str3 == str4.intern()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true or false&lt;/span&gt;
  System.out.println(str3 == str5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true or false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题3：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
String t1 = &lt;span&gt;new&lt;/span&gt; String(&quot;2&quot;&lt;span&gt;);
String t2 &lt;/span&gt;= &quot;2&quot;&lt;span&gt;;
t1.intern();
System.out.println(t1 &lt;/span&gt;==&lt;span&gt; t2); //false or true

String t3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;2&quot;) + &lt;span&gt;new&lt;/span&gt; String(&quot;2&quot;&lt;span&gt;);
String t4 &lt;/span&gt;= &quot;22&quot;&lt;span&gt;;
t3.intern();
System.out.println(t3 &lt;/span&gt;== t4); //false or true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题4：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    Integer a = 1&lt;span&gt;;
    Integer b &lt;/span&gt;= 2&lt;span&gt;;
    Integer c &lt;/span&gt;= 3&lt;span&gt;;
    Integer d &lt;/span&gt;= 3&lt;span&gt;;
    Integer e &lt;/span&gt;= 321&lt;span&gt;;
    Integer f &lt;/span&gt;= 321&lt;span&gt;;
    Long g &lt;/span&gt;= 3L&lt;span&gt;;

    System.out.println(c &lt;/span&gt;==&lt;span&gt; d);
    System.out.Println(e &lt;/span&gt;==&lt;span&gt; f);
    System.out.println(c &lt;/span&gt;== (a +&lt;span&gt; b));
    System.out.println(c.equals(a&lt;/span&gt;+&lt;span&gt;b));
    System.out.println(g &lt;/span&gt;== (a +&lt;span&gt; b));
    System.out.println(g.equals(a &lt;/span&gt;+ b));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在解答这四个问题的过程中，我们首先说一下几个知识，很重要:&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.intern()函数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　intern函数的作用是将对应的符号常量进入特殊处理，在1.6以前 和 1.7以后有不同的处理；&lt;/p&gt;
&lt;p&gt;　　先看1.6：&lt;/p&gt;
&lt;p&gt;　　　　　　在1.6中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，&lt;span&gt;如果没有找到，则将该字符串常量加入到字符串常量区，也就是在字符串常量区建立该常量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;在1.7中：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在1.7中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，&lt;span&gt;如果没有找到，则在堆中建立该字符串常量，然后把堆区该对象的引用加入到字符串常量池中，以后别人拿到的是该字符串常量的引用，实际存在堆中；&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.常量池的分类【理解即可】&lt;/h2&gt;
&lt;h4 id=&quot;1-class-&quot;&gt;2.1 class文件常量池&lt;/h4&gt;
&lt;p&gt;在Class文件中除了有类的版本【高版本可以加载低版本】、字段、方法、接口等描述信息外，还有一项信息是&lt;span&gt;&lt;strong&gt;常量池(Constant Pool Table)【此时没有加载进内存，也就是在文件中】&lt;/strong&gt;，用于存放&lt;strong&gt;编译期生成的各种字面量和符号引用&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;下面对字面量和符号引用进行说明&lt;br/&gt;&lt;strong&gt;字面量&lt;/strong&gt;&lt;br/&gt;字面量类似与我们平常说的常量，主要包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文本字符串：就是我们在代码中能够看到的字符串，例如String a = “aa”。其中”aa”就是字面量。&lt;/li&gt;
&lt;li&gt;被final修饰的变量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;符号引用&lt;/strong&gt;&lt;br/&gt;主要包括以下常量：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类和接口和全限定名：例如对于String这个类，它的全限定名就是java/lang/String。&lt;/li&gt;
&lt;li&gt;字段的名称和描述符：所谓字段就是类或者接口中声明的变量，包括类级别变量（static)和实例级的变量。&lt;/li&gt;
&lt;li&gt;方法的名称和描述符。所谓描述符就相当于方法的&lt;strong&gt;参数类型+返回值类型&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2-&quot;&gt;2.2 运行时常量池&lt;/h4&gt;
&lt;p&gt;我们知道类加载器会加载对应的Class文件，而上面的class文件中的常量池，会在类加载后进入&lt;strong&gt;方法区&lt;/strong&gt;中的运行时常量池【此时存在在内存中】。并且需要的注意的是，运行时常量池是全局共享的，多个类共用一个运行时常量池。&lt;span&gt;并且class文件中常量池多个相同的字符串在运行时常量池只会存在一份。&lt;/span&gt;&lt;br/&gt;注意运行时常量池存在于&lt;strong&gt;方法区&lt;/strong&gt;中。&lt;/p&gt;
&lt;h4 id=&quot;3-&quot;&gt;2.3 字符串常量池&lt;/h4&gt;
&lt;p&gt;　　看名字我们就可以知道字符串常量池会用来存放&lt;strong&gt;字符串&lt;/strong&gt;，也就是说常量池中的文本字符串会在类加载时进入字符串常量池。&lt;br/&gt;那字符串常量池和运行时常量池是什么关系呢？上面我们说常量池中的字面量会在类加载后进入运行时常量池，其中字面量中有包括文本字符串，显然从这段文字我们可以知道字符串常量池存在于运行时常量池中。也就存在于&lt;strong&gt;方法区&lt;/strong&gt;中。&lt;br/&gt;不过在周志明那本深入java虚拟机中有说到，到了JDK1.7时，字符串常量池就被移出了方法区，转移到了&lt;strong&gt;堆&lt;/strong&gt;里了。&lt;br/&gt;那么我们可以推断，&lt;span&gt;到了JDK1.7以及之后的版本中，&lt;/span&gt;&lt;span&gt;运行时常量池并没有包含字符串常量池，运行时常量池存在于方法区中，而字符串常量池存在于&lt;strong&gt;堆&lt;/strong&gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.问题解析【重点】&lt;/h2&gt;
&lt;h2&gt;3.1 问题1解析&lt;/h2&gt;
&lt;pre&gt;
　　tring str1 = new String(&quot;1&quot;&lt;span readability=&quot;4&quot;&gt;);&lt;br/&gt;　　解析：首先此行代码创建了两个对象，在执行前会在常量池中创建一个&quot;1&quot;的对象，然后执行该行代码时new一个&quot;1&quot;的对象存放在堆区中；然后str1指向堆区中的对象；&lt;br/&gt;str1.intern();&lt;br/&gt;　　解析：该行代码首先查看&quot;1&quot;字符串有没有存在在常量池中，此时存在则直接返回该常量，这里返回后没有引用接受他，【假如不存在的话在jdk1.6中会在常量池中建立该常量，在jdk1.7以后会在堆中建立该字符串，然后把他的引用放在常量池中】&lt;br/&gt;String str2 = &quot;1&quot;&lt;span readability=&quot;8&quot;&gt;;&lt;br/&gt;　　解析：此时&quot;1&quot;已经存在在常量池中，str2指向常量池中的对象；&lt;p&gt;System.out.println(str1 ==&lt;span&gt; str2);  //结果是 false or true？&lt;br/&gt;　　解析：str1指向堆区的对象，str2指向常量池中的对象，两个引用指向的地址不同，输入false；

    String str3 = new String(&quot;2&quot;) + new String(&quot;2&quot;&lt;span&gt;);&lt;br/&gt;　　解析：此行代码执行的底层执行过程是 首先使用StringBuffer的append方法将&quot;2&quot;和&quot;2&quot;拼接在一块，然后调用toString方法new出“22”；所以此时的“22”字符串是创建在堆区的；&lt;br/&gt;t3.intern();&lt;br/&gt;　　解析：此行代码执行时字符串常量池中没有&quot;22&quot;,所以此时在jdk1.6中会在字符串常量池中创建&quot;22&quot;,而在jdk1.7中会在堆中创建该字符串，然后将其引用添加到常量池中；&lt;br/&gt;String str4 = &quot;22&quot;&lt;span&gt;;&lt;br/&gt;　　解析：此时的str4在jdk1.6中会指向方法区，而在jdk1,7中会指向堆区；&lt;br/&gt;System.out.println(str3 == str4); //结果是 false or true？&lt;br/&gt;　　解析：很明显了 jdk1.6中为false 在jdk1.7中为true；&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;3.2 问题2解析&lt;/h2&gt;
&lt;pre&gt;
　String str1 = &quot;aaa&quot;&lt;span&gt;;&lt;br/&gt;　解析：str1指向方法区；&lt;br/&gt;String str2 = &quot;bbb&quot;&lt;span&gt;;&lt;br/&gt;　解析： str2 指向方法区&lt;br/&gt;String str3 = &quot;aaabbb&quot;&lt;span&gt;;&lt;br/&gt;解析：str3指向方法区&lt;br/&gt;String str4 = str1 +&lt;span&gt; str2;&lt;br/&gt;解析：此行代码上边已经说过原理。str4指向堆区&lt;br/&gt;String str5 = &quot;aaa&quot; + &quot;bbb&quot;&lt;span&gt;;&lt;br/&gt;解析：该行代码重点说明一下，jvm对其有优化处理，也就是在编译阶段就会将这两个字符串常量进行拼接，也就是&quot;aaabbb&quot;;所以他是在方法区中的；’&lt;br/&gt;System.out.println(str3 == str4); // false or true&lt;br/&gt;　解析：很明显 为false， 一个指向堆 一个指向方法区&lt;br/&gt;System.out.println(str3 == str4.intern()); // true or false&lt;br/&gt;解析：jdk1.6中str4.intern会把“aaabbb”放在方法区，1.7后放在堆区，所以在1.6中会是true 但是在1.7中是false&lt;br/&gt;System.out.println(str3 == str5);// true or false&lt;br/&gt;解析：都指向字符串常量区，字符串长常量区在方法区，相同的字符串只存在一份，其实这个地方在扩展一下，因为方法区的字符串常量是共享的，在两个线程同时共享这个字符串时，如果一个线程改变他会是怎么样的呢，其实这种场景下是线程安全的，jvm会将改变后的字符串常量在&lt;br/&gt;　　字符串常量池中重新创建一个处理，可以保证线程安全&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;3.3 问题3解析&lt;/h2&gt;
&lt;pre&gt;
tring t1 = new String(&quot;2&quot;&lt;span&gt;);&lt;br/&gt;解析：创建了两个对象，t1指向堆区&lt;br/&gt;String t2 = &quot;2&quot;&lt;span&gt;;&lt;br/&gt;解析：t2指向字符串常量池&lt;br/&gt;t1.intern();&lt;br/&gt;解析:字符串常量池已经存在该字符串，直接返回；&lt;br/&gt;System.out.println(t1 ==&lt;span&gt; t2); //false or true
解析：很明显 false&lt;br/&gt;String t3 = new String(&quot;2&quot;) + new String(&quot;2&quot;&lt;span&gt;);&lt;br/&gt;解析：过程同问题1 t3指向堆区&lt;br/&gt;String t4 = &quot;22&quot;&lt;span&gt;;&lt;br/&gt;解析：t4 在1.6 和 1.7中指向不同
t3.intern();&lt;br/&gt;解析： 字符串常量池中已经存在该字符串 直接返回&lt;br/&gt;System.out.println(t3 == t4); //false or true&lt;br/&gt;解析： 很明显为 false 指向不同的内存区&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;3.4 问题4解析&lt;/h2&gt;
&lt;p&gt;这个地方存在一个知识点。可能是个盲区，这次要彻底记住“&lt;/p&gt;
&lt;p&gt;(1). 内存中有一个java基本类型封装类的常量池。这些类包括&lt;em id=&quot;__mceDel&quot;&gt;Byte, Short, Integer, Long, Character, Boolean。需要注意的是，Float和Double这两个类并没有对应的常量池。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;(2).上面5种整型的包装类的对象是存在范围限定的；范围在-128~127存在在常量池，范围以外则在堆区进行分配。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;(3). 在周志明的那本虚拟机中有这样一句话：&lt;span&gt;包装类的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“==”运行符在不遇到算术运算的情况下不会自动&lt;strong&gt;拆箱&lt;/strong&gt;&lt;/span&gt;，以及他们的equals()方法不处理数据类型的关系，通俗的讲也就是 “==”两边如果有算术运算， 那么自动拆箱和进行数据类型转换处理，比较的是数值等不等能。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;(4).Long的equals方法会先判断是否是Long类型。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;(5).无论是Integer还是Long，他们的equals方法比较的是数值。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;System.out.println(c == d)。&lt;br/&gt;解析：由于常量池的作用，c与d指向的是同一个对象(注意此时的==比较的是对象，也就是地址，而不是数值)。因此为true&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;System.out.println(e == f)。&lt;br/&gt;由于321超过了127，因此常量池失去了作用，所以e和f数值虽然相同，但不是同一个对象，以此为false。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;System.out.println(c == (a+b))。&lt;br/&gt;&lt;span&gt;此时==两边有算术运算，会进行拆箱，因此此时比较的是数值，而并非对象&lt;/span&gt;。因此为true。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;System.out.println(c.equals(a+b))&lt;br/&gt;c与a+b的数值相等，为true。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;System.out.pirnln(g == (a + b))&lt;br/&gt;由于==两边有算术运算，所以比较的是数值，因此为true。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;System.out.println(g.equals(a+b))。&lt;br/&gt;Long类型的equal在比较是时候，会先判断a+b是否为Long类型，显然a+b不是，因此false&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Fri, 17 Aug 2018 15:37:00 +0000</pubDate>
<dc:creator>小勇DW3</dc:creator>
<og:description>前言： 在平时我们使用字符串一般就是拿来直接搞起，很少有深入的去想过这方面的知识，导致别人在考我们的时候，会问 String str = new String(&quot;123&quot;); 这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxyandwmm/p/9495923.html</dc:identifier>
</item>
<item>
<title>卷积神经网络（Convolutional Neural Network，CNN） - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/9488045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/9488045.html</guid>
<description>&lt;p&gt;　　全连接神经网络（Fully connected neural network）处理图像最大的问题在于全连接层的参数太多。参数增多除了导致计算速度减慢，还很容易导致过拟合问题。所以需要一个更合理的神经网络结构来有效地减少神经网络中参数的数目。而卷积神经网络（Convolutional Neural Network，CNN）可以做到。&lt;/p&gt;

&lt;h2&gt;1. 卷积神经网络构成&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180816172036251-916919934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 1：卷积神经网络&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个网络的输入，一般代表了一张图片的像素矩阵。图 1中最左侧三维矩阵代表一张输入的图片，三维矩阵的长、宽代表了图像的大小，而三维矩阵的深度代表了图像的色彩通道（channel）。黑白图片的深度为 1，RGB 色彩模式下，图片的深度为 3。&lt;/p&gt;
&lt;p&gt;CNN 中最为重要的部分。与全连接层不同，卷积层中每一个节点的输入只是上一层神经网络中的一小块，这个小块常用的大小有 3×3 或者 5×5。一般来说，通过卷积层处理过的节点矩阵会变的更深。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;池化层（Pooling）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;池化层不改变三维矩阵的深度，但是可以缩小矩阵的大小。池化操作可以认为是将一张分辨率高的图片转化为分辨率较低的图片。通过池化层，可以进一步缩小最后全连接层中节点的个数，从而到达减少整个神经网络参数的目的。池化层本身没有可以训练的参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全连接层，最后一层激活函数使用 softmax。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过多轮卷积层和池化层的处理后，在CNN的最后一般由1到2个全连接层来给出最后的分类结果。经过几轮卷积和池化操作，可以认为图像中的信息已经被抽象成了信息含量更高的特征。我们可以将卷积和池化看成自动图像提取的过程，在特征提取完成后，仍然需要使用全连接层来完成分类任务。&lt;/p&gt;
&lt;p&gt;对于多分类问题，最后一层激活函数可以选择 softmax，这样我们可以得到样本属于各个类别的概率分布情况。&lt;/p&gt;

&lt;h2&gt;2. 卷积层&lt;/h2&gt;
&lt;h3&gt;2.1 filter&lt;/h3&gt;
&lt;p&gt;　　卷积神经网络结构中最重要的部分，过滤器（filter），如图 2中黄色和橙色的 3×3×3 矩阵所示。具体卷积操作如何进行，可以参考 &lt;a href=&quot;http://cs231n.github.io/convolutional-networks/&quot; target=&quot;_blank&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt; 中的 Convolution Demo 或者参考图 3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180817232547621-2130453849.png&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;298&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 2：卷积操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　filter 可以将当前层神经网络上的一个子节点矩阵转化为下一层神经网络上的一个单位节点矩阵。单位节点矩阵制的是长和宽都是 1，但深度不限的节点矩阵。&lt;/p&gt;
&lt;p&gt;　　进行卷积操作，需要注意 filter 的个数 $K$、filter 的尺寸 $F$、卷积步长 stride 的大小 $S$ 以及 padding 的大小 $P$。图 2 中 $K = 2$，$F = 3$，$S = 1$，$P = 0$。&lt;/p&gt;
&lt;p&gt;　　常用的 filter 尺寸有 3×3 或 5×5，即图 2 黄色和橙色矩阵中的前两维，这个是人为设定的；filter 的节点矩阵深度，即图 2 黄色和橙色矩阵中的最后一维（filter 尺寸的最后一维），是由当前层神经网络节点矩阵的深度（RGB 图像节点矩阵深度为 3）决定的；卷积层输出矩阵的深度（也称为 filter 的深度）是由该卷积层中 filter 的个数决定，该参数也是人为设定的，一般随着卷积操作的进行越来越大。&lt;/p&gt;
&lt;p&gt;　　图 2中 filter 的尺寸为 3×3×3，filter 的深度为 2。&lt;/p&gt;
&lt;p&gt;　　卷积操作中，一个 3×3×3 的子节点矩阵和一个 3×3×3 的 filter 对应元素相乘，得到的是一个 3×3×3 的矩阵，此时将该矩阵所有元素求和，得到一个 1×1×1 的矩阵，将其再加上 filter 的 bias，经过激活函数得到最后的结果，将最后的结果填入到对应的输出矩阵中。输出矩阵中第一个元素 $g(0, 0, 0)$ 的计算如下所示：&lt;/p&gt;
&lt;p&gt;\begin{equation} g(0, 0, 0) = f( \sum_{x}^3\sum_{y}^3\sum_{z}^3a_{x,y,z} × w_{x,y,z}^{(0)} + b^{(0)}   ) \end{equation}&lt;/p&gt;
&lt;p&gt;公式(1)中，$a_{x,y,z}$ 表示当前层的一个子节点矩阵，即 6×6×3 矩阵中左上角 3×3×3 部分； $w_{x,y,z}^{(0)}$ 表示第一个 filter 的权重，即第一个 filter 每个位置的值；$b^{(0)}$ 表示第一个 filter 的偏置 bias，是一个实数；$f$ 表示激活函数，如 ReLU 激活函数。&lt;/p&gt;
&lt;p&gt;　　“卷积层结构的前向传播过程就是通过将一个 filter 从神经网络当前层的左上角移动到右下角，并且在移动中计算每一个对应的单位矩阵得到的。”&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180817144903687-737820916.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 3：卷积操作流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（注意：图 2 和 图 3 神经网络当前层输入不一样，图 2 是 6×6×3，而图 3 是5×5×3 再加上 $P = 1$ 的 padding。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图 3 中，卷积步长 $S = 2$，padding的大小 $P = 1$。&lt;/p&gt;

&lt;h3&gt;2.2 padding&lt;/h3&gt;
&lt;p&gt;　　padding，顾名思义，就是在图像周围进行填充，一般常用 zero padding，即用 0 来填充。当 $P = 1$ 时，在图像周围填充一圈；当 $P = 2$ 时，填充两圈。&lt;/p&gt;
&lt;p&gt;　　Q: Why padding?&lt;/p&gt;
&lt;p&gt;　　A: Two reasons: 1) shrinking output: 随着卷积操作的进行，图像会越来越小; 2) throwing away information from the edges of the images: filter 对图片边缘信息和内部信息的重视程度不一样，边缘信息 filter 只经过一次，而内部信息会被经过多次。&lt;/p&gt;
&lt;p&gt;　　Q: Valid and Same convolutions?&lt;/p&gt;
&lt;p&gt;　　A: &quot;valid&quot;: no padding;&lt;/p&gt;
&lt;p&gt;　　    &quot;Same&quot;:  Pad so that output size is the same as the input size.&lt;/p&gt;

&lt;h3&gt;2.3 stride&lt;/h3&gt;
&lt;p&gt;　　卷积步长 stride 就是像在图 3 中 filter 一次移动的步子，图 3 中 stride 的大小 $S = 2$。&lt;/p&gt;
&lt;p&gt;　　卷积层输出矩阵的大小 $\mbox{size}_{output}$ 与输入图片大小 $N$、 filter 的尺寸 $F$、padding 的大小 $P$、卷积步长 $S$ 都有关。（假设输入的图片是方形的）&lt;/p&gt;
&lt;p&gt;\begin{equation} \mbox{size}_{output}=  \lfloor \frac{N + 2P - F}{S} \rfloor + 1\end{equation}&lt;/p&gt;
&lt;p&gt;当 $ S \neq 1$ 时，可能存在 $\frac{N + 2P - F}{S}$ 不是整数的情况，这个时候对 $\frac{N + 2P - F}{S}$ 取下整或者使用整除。&lt;/p&gt;
&lt;p&gt;　　依据《TensorFlow实战Google深度学习框架》，$\mbox{size}_{output}$ 也可以写成如下形势：&lt;/p&gt;
&lt;p&gt;\begin{equation} \mbox{size}_{output}=  \lceil \frac{N + 2P - F + 1 }{S} \rceil \end{equation}&lt;/p&gt;
&lt;p&gt;公式(2)和(3)最后的结果会是一样。&lt;/p&gt;

&lt;h2&gt;3. 池化层&lt;/h2&gt;
&lt;p&gt;　　池化层可以非常有效地缩小矩阵的尺寸（主要减少矩阵的长和宽，一般不会去减少矩阵深度），从而减少最后全连接层中的参数。“使用池化层既可以加快计算速度也有防止过拟合问题的作用。”&lt;/p&gt;
&lt;p&gt;　　与卷积层类似，池化层的前向传播过程也是通过一个类似 filter 的结构完成的。不过池化层 filter 中的计算不是节点的加权和，而是采用更加简单的最大值或者平均值运算。使用最大值操作的池化层被称为最大池化层（max pooling），这是使用最多的池化层结构。使用平均值操作的池化层被称为平均池化层（average pooling）。&lt;/p&gt;
&lt;p&gt;　　与卷积层的 filter 类似，池化层的 filter 也需要人工设定 filter 的尺寸、是否使用全 0 填充 以及 filter 移动的步长等设置，而且这些设置的意义也是一样的。&lt;/p&gt;
&lt;p&gt;　　卷积层和池化层中 filter 的移动方式是相似的，唯一的区别在于卷积层使用的 filter 是横跨整个深度的，而池化层使用的 filter 只影响一个深度上的节点。所以池化层的过滤器除了在长和宽两个维度移动之外，它还需要在深度这个维度移动。也就是说，在进行 max 或者 average 操作时，只会在同一个矩阵深度上进行，而不会跨矩阵深度进行。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180817224155953-1368217601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 4：max pooling&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图 4 中，池化层 filter 的尺寸为 2×2，即 $F = 2$，padding 大小 $P = 0$，filter 移动的步长 $S = 2$。 &lt;/p&gt;
&lt;p&gt;　　池化层一般不改变矩阵的深度，只改变矩阵的长和宽。&lt;/p&gt;
&lt;p&gt;　　池化层没有 trainable 参数，只有一些需要人工设定的超参数。&lt;/p&gt;

&lt;h2&gt;4. 卷积神经网络的特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部连接：&lt;/strong&gt;卷积层输出矩阵上的某个位置只与部分输入矩阵有关，而不是全部的输入矩阵。卷积层输出的某个特征可能只和输入图片的某一部分相关，和其它位置的信息没有任何关联，局部连接可以让特征只关注其应该关注的部分。同时也减少了神经网络的参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数共享：&lt;/strong&gt;同一卷积层中 filter 的参数是共享的，一个 filter 无论在哪个位置进行卷积操作，filter 矩阵中的值都是一样的。（当然同一层不同的 filter 参数不一样，不同层之间 filter 的参数也不一样。）共享 filter 的参数可以使得图像中的内容不受位置的影响。以MNIST手写数字识别为例，无论数字“1”出现在左上角还是右下角，图片的种类的都是不变的。共享卷积层 filter 的参数还可以巨幅减少神经网络上的参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　图 2 中池化层拥有的 trainable 参数数目为 3×3×3×2+2，其中 “3×3×3” 表示 filter 的尺寸， “×2” 表示 filter 的深度/个数，“+2” 表示 2 个 filter 的 bias。卷积层的参数要远远小于同等情况下的全连接层。而且卷积层参数的个数和输入图片的大小无关，这使得卷积神经网络可以很好地扩展到更大的图像数据上。&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;
&lt;p id=&quot;convolutional-neural-networks-cnns--convnets&quot;&gt;&lt;a target=&quot;_blank&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mooc.study.163.com/learn/2001281004?tid=2001392030#/learn/content?type=detail&amp;amp;id=2001728686&quot; target=&quot;_blank&quot;&gt;Course 4 Convolutional Neural Networks by Andrew Ng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《TensorFlow实战Google深度学习框架》&lt;/p&gt;

</description>
<pubDate>Fri, 17 Aug 2018 15:28:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>全连接神经网络（Fully connected neural network）处理图像最大的问题在于全连接层的参数太多。参数增多除了导致计算速度减慢，还很容易导致过拟合问题。所以需要一个更合理的神经网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/9488045.html</dc:identifier>
</item>
<item>
<title>七、线性表的链式存储结构 - 小胖鼠</title>
<link>http://www.cnblogs.com/chenke1731/p/9495573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenke1731/p/9495573.html</guid>
<description>&lt;h3 id=&quot;问题引入&quot;&gt;1、问题引入&lt;/h3&gt;
&lt;p&gt;开发数组类模板的原因在于：在创建基于顺序存储结构的线性表时，发现这样的线性表可能被误用，因为重载了数组访问操作符，使用时跟数组类似，但是线性表和数组有很大的区别，所以激发了新的需求：开发数组类替换C++原生数组类，因为原生数组类也存在着很大缺陷，使用不方便。&lt;/p&gt;
&lt;p&gt;基于顺序存储结构的线性表的另一个缺点：插入或删除元素时，涉及到大量数据元素的移动，对于效率的影响非常大&lt;/p&gt;
&lt;p&gt;一个新的需求：在插入或删除元素时不需要大量移动数据元素的一种数据结构，即基于链式存储结构的线性表&lt;/p&gt;
&lt;h3 id=&quot;链式结构的定义&quot;&gt;2、链式结构的定义&lt;/h3&gt;
&lt;p&gt;为了表示每个数据元素于其直接后继元素之间的逻辑关系；数据元素除了存储本身的信息外，还需要存储其直接后继的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201808/1372866-20180817222745037-1071623465.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(a_{i+1}\)&lt;/span&gt;是线性表中的两个相邻数据元素，在物理内存中无相邻关系。&lt;/p&gt;
&lt;p&gt;一个数据元素包含了两部分：&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;是数据元素本身的数据信息，还有一个地址信息，地址是第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个元素的直接后继，即第&lt;span class=&quot;math inline&quot;&gt;\(i+1\)&lt;/span&gt;个的元素在内存中的地址信息。换句话说就是如果找到了第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个元素，不仅可以得到第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个元素的本身的值之外，还可以得到第&lt;span class=&quot;math inline&quot;&gt;\(i+1\)&lt;/span&gt;个元素在内存中的位置&lt;/p&gt;
&lt;h3 id=&quot;链式存储逻辑结构&quot;&gt;3、链式存储逻辑结构&lt;/h3&gt;
&lt;p&gt;基于链式存储结构的线性表中，每个结点都包含数据域和指针域&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据域：存储数据元素本身&lt;/li&gt;
&lt;li&gt;指针域：存储相邻结点的地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201808/1372866-20180817222801707-1986803877.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两种线性表名称统一：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;顺序表：基于顺序存储结构的线性表&lt;/li&gt;
&lt;li&gt;链表：基于链式存储结构的线性表
&lt;ul&gt;&lt;li&gt;单链表：每个结点只包含直接后继的地址信息&lt;/li&gt;
&lt;li&gt;循环链表：单链表的最后一个结点的直接后继为第一个结点&lt;/li&gt;
&lt;li&gt;双向链表：单链表中的结点包含直接前驱和后继的地址信息&lt;/li&gt;
&lt;li&gt;双向循环链表......&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;链表中的基本概念&quot;&gt;4、链表中的基本概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;头结点：链表中的辅助结点，包含指向第一个数据元素的指针；不包含任何数据信息，是为了简化代码进行辅助&lt;/li&gt;
&lt;li&gt;数据结点：链表中代表数据元素的结点，表现形式为：(数据元素，地址)&lt;/li&gt;
&lt;li&gt;尾结点：链表中的最后一个数据结点。单独放出的原因：尾结点包含的地址信息直接决定了链表的性质，地址信息为空，就是单链表；地址为第0个元素的地址信息，就是循环链表；地址信息为随机值，就是一个非法链表&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单链表&quot;&gt;5、单链表&lt;/h3&gt;
&lt;h4 id=&quot;单链表中的结点定义&quot;&gt;5.1 单链表中的结点定义&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 用struct定义类，默认属性是public
// T是泛指类型，链表可以存储各种类型的数据
struct Node : public Object
{
    T value;
    Node* next; // 指向后继结点的指针
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;单链表的内部结构&quot;&gt;5.2 单链表的内部结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201808/1372866-20180817222810908-1837731497.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;头结点在单链表中的意义是：辅助数据元素的定位，方便插入和删除操作，因此，头结点不存储实际的数据元素。&lt;/p&gt;
&lt;h4 id=&quot;在目标位置处插入数据元素&quot;&gt;5.3 在目标位置处插入数据元素&lt;/h4&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从头结点开始，通过&lt;code&gt;current&lt;/code&gt;指针定位到目标位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从堆空间申请新的Node结点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行操作&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;node-&amp;gt;value = e;
node-&amp;gt;next = current-&amp;gt;next;
current-&amp;gt;next - node;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;在目标位置删除数据元素&quot;&gt;5.4 在目标位置删除数据元素&lt;/h4&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从头结点开始，通过&lt;code&gt;previous&lt;/code&gt;指针定位到目标位置的前一个地址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;toDel&lt;/code&gt;指针指向需要删除的结点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行操作：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;toDel = previous-&amp;gt;next;
previous-&amp;gt;next = toDel-&amp;gt;next;
delete toDel;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结&quot;&gt;6、小结&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;链表中的数据元素在物理内存中无相邻关系&lt;/p&gt;
&lt;p&gt;链表中的结点都包含数据域和指针域&lt;/p&gt;
&lt;p&gt;头结点用于辅助数据元素定位，方便插入和删除操作&lt;/p&gt;
&lt;p&gt;插入和删除操作需要保证链表的完整性&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Aug 2018 14:29:00 +0000</pubDate>
<dc:creator>小胖鼠</dc:creator>
<og:description>1、问题引入 开发数组类模板的原因在于：在创建基于顺序存储结构的线性表时，发现这样的线性表可能被误用，因为重载了数组访问操作符，使用时跟数组类似，但是线性表和数组有很大的区别，所以激发了新的需求：开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenke1731/p/9495573.html</dc:identifier>
</item>
</channel>
</rss>