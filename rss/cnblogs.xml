<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>简述区块链（1）- 也许只有这一篇 - Dexter Di</title>
<link>http://www.cnblogs.com/DexterDi/p/8689095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DexterDi/p/8689095.html</guid>
<description>&lt;p&gt;一、唠叨两句&lt;/p&gt;
&lt;p&gt;最近一直在考虑一个事情，就是怎么给不太了解技术的人讲清楚区块链。我先试着写下来，然后在逐步打磨吧，目标就是能让人能让哪些说看区块链看的云里雾里的同学能对区块链有一些认知。&lt;/p&gt;

&lt;p&gt;二、定义&lt;/p&gt;
&lt;p&gt;简单的给区块链下个定义：基于加密算法的，去中心化的分布式账本技术。这里有三个关键词：加密算法、去中心化、分布式账本，下面我就尝试从三个关键词为线索，介绍一下区块链的概念。&lt;/p&gt;

&lt;p&gt;三、分布式账本&lt;/p&gt;
&lt;p&gt;比特币是一个点对点的电子现金系统，既然是现金系统，那么就得记账呗，这大概就是这个账本的由来，就是流水账嘛，张三给了李四一百块钱，王五给了张三五十块钱，blabla。这种东西，就是一条一条的数据，记录在文件里，数据库里等等。区块链的账本存储，当然就是区块和链了。分布式账本，就是在说不仅存一份数据，每个全节点都存一份数据，只要不是全部节点挂掉，总有节点可提供数据的。&lt;/p&gt;
&lt;p&gt;1. 区块：块分成区块头，和区块体，区块头包含一些前一个区块的Hash啊，当前区块中所有交易的默克尔树根啊，时间戳啊，随机数啊，等等。区块体里就是一笔笔的交易。&lt;/p&gt;
&lt;p&gt;简单说下默克尔树，比如当前区块有4比交易A，B，C，D，AB取hash，CD取hash，两个Hash结果再取hash，就形成了默克尔树，树根可以理解为一个水印，任何一个交易改一点，整棵默克尔树就都变化了，可以保证没有篡改，这个树还可以支持轻钱包SPV验证。&lt;/p&gt;
&lt;p&gt;2. 交易：每一笔交易主要包含了Input和Output，Input记录的是引用到的前一笔未花费交易的索引，Output记录的是将资产转移到那个地址。这里讲地址的时候，还要讲。&lt;/p&gt;
&lt;p&gt;3. 链：刚才讲了区块头包含了前一个区块的Hash，这东西就是为了把区块连接起来，成为一个链，链上的交易顺序不能认为严格的前后关系，但是基本可以认为是有一个追溯的结构。作为程序猿，你会想需要遍历链，怎么整，拿到创世块，它没有前一个区块Hash，取到它的默克尔树根作为key去存储里面找下一个区块，如此往复。&lt;/p&gt;

&lt;p&gt;四、去中心化&lt;/p&gt;
&lt;p&gt;我想把这部分通过和一般NoSql数据库的一些方式做对比，NoSql数据库为了达到读的并发性能和数据的安全，通常都会保存多个副本，ReplicaSet的概念。同时对于写的数据，总要先找个主节点写，写完了再同步给副本集，选主的时候，数据一致的时候，都需要几个节点达成共识，通常会有Paxos，Raft这样的算法来保证。把这部分放大到公网上，就基本可以映射到区块链上了，区块链的各个全节点都保持一个完整账本，全网的ReplicaSet；获得记账权要记账写块了，谁来写，区块链上通过PoW，PoS，DPos等等共识算法来达成共识，又和Paxos，Raft对应上了。&lt;/p&gt;
&lt;p&gt;说到共识了，我们想一下记账权这个事，就是挖矿，首先是个经济问题，我干嘛要挖啊，你得给我奖励，比特币系统中获得了记账权生成了区块，就能获得比特币的奖励，比特币价格高，当然可以激励记账这个事了，那么问题来了，这个经济问题变成了一个博弈问题了，这么赚钱，凭啥你挖啊。这时候就得有个算法来规定好游戏玩法，比特币怎么个玩法PoW，就是来个数学谜题，谁算出来谁记账。这个数学谜题可以简单这么理解，就是你生成的块，加上一个随机数位可以调节，然后基于一种Hash算法，你生成出来的结果必须小于某某数，这个某某数就是难度，可以动态调节的，现在比特币的这个难度很高，所以你也就别跟矿主彪啦。那为什么叫PoW了，就是工作量证明，因为这个Hash之间没有关联型，我上次随机数计算的结果和我这次随机数计算的结果之间没有半分钱关联，这也就是为啥算力规模越来越大了，可以并行计算，算力越大，概率越大。你要非较真说，其实理论上，你可能很少计算就刚好碰到了正确结果，没错，这事就可以类比高考了，你说有没有神蒙，蒙得高分，有，但是大体上这个考分大概其能证明你努力过吧。&lt;/p&gt;

&lt;p&gt;五、加密算法&lt;/p&gt;
&lt;p&gt;非对称加密大伙都明白，不多讲了，利用非对称加密的签名验签可以实现区块链最关键的特点，确权。只有我用我的私钥签名过的数据，你用我的公钥才能验证通过，其他谁想仿造都不行，所以这钱就只能是我来花了。说到确权，这事可大了，区块链为啥火，就是因为确权，数字资产能确权了，这意味着什么？意味着互联网变成了价值互联网了，价值可以传递了。&lt;/p&gt;
&lt;p&gt;那这签名验签的用哪儿了，也没见哪儿使啊，别急，刚才咱介绍交易的时候不是留了一个箭头么，这交易上记的不仅仅是转移到对方的地址，而是一个脚本。如果就一地址搁那，都说是自己的，那不乱套了，这钱谁能用，得确权，这就需要脚本系统了。&lt;/p&gt;
&lt;p&gt;首先说说比特币的地址啊，地址咋生成，下图讲的特清楚，我从网上拷的。你说好好一图，我随便用，不能卖钱，为啥，不就是因为没法确权嘛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/217273/201804/217273-20180401225722109-1877825991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们简单说说这个比特币的脚本系统，它是基于栈的脚本系统。这里我暂时不展开，仅已最常用的比特币锁定脚本P2PKH脚本作为例子讲讲。&lt;/p&gt;
&lt;p&gt;锁定脚本&lt;/p&gt;
&lt;p&gt;DUP HASH160 [Public Key Hash] EqualVerify CheckSig&lt;/p&gt;
&lt;p&gt;花钱的时候你得通过锁定脚本的验证，这个就是一个确权的过程，你要想验证通过你得提供解锁脚本&lt;/p&gt;
&lt;p&gt;[Sig] [Public Key]&lt;/p&gt;
&lt;p&gt;简单说下验证过程吧，下面这堆脚本基于栈执行&lt;/p&gt;
&lt;p&gt;[Sig] [Public Key] DUP HASH160 [Public Key Hash] EqualVerify CheckSig&lt;/p&gt;
&lt;p&gt;1. [Sig]入栈&lt;/p&gt;
&lt;p&gt;2. [Public Key]入栈&lt;/p&gt;
&lt;p&gt;3. DUP复制栈顶[Public Key]再入栈&lt;/p&gt;
&lt;p&gt;4. 拿出栈顶[Public Key]执行HASH160（这个正是Public Key Hash的算法），入栈&lt;/p&gt;
&lt;p&gt;5. 锁定脚本里的常量[Public Key Hash]入栈&lt;/p&gt;
&lt;p&gt;6. 取出栈顶里脚本里的[Public Key Hash]和计算出来的比较，相等就继续&lt;/p&gt;
&lt;p&gt;7. 这下栈里从底到顶分别是[Sig][Public Key]，CheckSig拿出栈里这俩验签，通过钱就是你的，请用。&lt;/p&gt;

&lt;p&gt;比特币的脚本指令很多，你可以自己写脚本出来，就是有点麻烦，写汇编似的，但是这东西也是个好东西，直接就引出了后面的智能合约来了，&lt;/p&gt;

&lt;p&gt;六、小结&lt;/p&gt;
&lt;p&gt;今天主要从加密算法，去中心化和分布式账本三个方面简单介绍了一下区块链，感觉没达到我的预期让没接触过的突然开窍的感觉，后面打磨打磨吧的再。本文里主要以比特币作为实例进行介绍的，我觉得比特币最牛逼的地方就是确权和智能合约，打开了无限遐想。公链上开发，很多选择，我其实不太喜欢比特币，开发起来太麻烦，而且就现在这个币值，搞些大宗交易，跨境大额转账啥的还成，其他的，呵呵吧，但是币王还是币王，这里面的原理还是值得细细琢磨的。&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 15:28:00 +0000</pubDate>
<dc:creator>Dexter Di</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DexterDi/p/8689095.html</dc:identifier>
</item>
<item>
<title>Django--基本篇：项目结构与设计模式（MVC） - gentelman_邵</title>
<link>http://www.cnblogs.com/gentleman-shao/p/8689057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gentleman-shao/p/8689057.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;Django在项目开发中有着结构清晰、层次明显、容易编写理解查阅demo的优点，那么我们来个小案例具体看看。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　 &lt;/strong&gt;  一、项目结构简析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们按照上一篇中的开发流程步骤创建一个新项目myblog，项目下有应用home、存放html文件templates的、运行项目生成的db.sqlite3和manage.py文件。在一个项目下可以创建多个应用，每个应用可以进行一项业务(下图)，我这里用home应用文件来处理前端，myadmin应用文件来处理后端。这里需要注意的是在settings.py文件中INSTALLED_APPS列表内添加‘myadmin.apps.MyadminConfig’。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1337988/201804/1337988-20180401193028522-1016011713.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们现在templates文件夹下面创建index.html文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
你好，这是我的myblog项目中的index页面
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在项目下的url模块中进行路由的适配如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;myadmin应用路由适配&lt;/span&gt;
    url(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,views.index),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在myadmin应用下的views模块下构建index函数如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用 Template 对象 的 render() 方法并传递context来填充模板&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myadmin/index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行项目&lt;img src=&quot;https://images2018.cnblogs.com/blog/1337988/201804/1337988-20180401225624556-741055178.png&quot; alt=&quot;&quot;/&gt;，那我们的案例就是完成了Starting development server at http://127.0.0.1:8000/可以访问啦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1337988/201804/1337988-20180401230038037-149939530.png&quot; alt=&quot;&quot; width=&quot;955&quot; height=&quot;119&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：设计模式MVC（又称‘MVT’）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模型（Model）：提供数据访问接口和模块，我们可以在model中创建表结构，包括数据字段、元数据、数据关系等定义及操作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;视图（View）：Django的视图层封装了http request和response的一系列操作和数据流，主要包括URL映射机制和绑定模板等，对于页面中的事件机制、数据更新、逻辑判断主要是在view层中的函数处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模板（Template）：是一套Django自己的页面渲染模板语言，用于若干内置的tags和filters定义页面的生成方式，编写呈现页面的html文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们从 上面的项目结构中就能看出Django框架利用MVC的设计模式层次清晰、各模块的分工合理，所以是python语言用来进行web最普遍和优秀的框架。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 15:19:00 +0000</pubDate>
<dc:creator>gentelman_邵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gentleman-shao/p/8689057.html</dc:identifier>
</item>
<item>
<title>ABP框架 - 介绍 - lcyhjx</title>
<link>http://www.cnblogs.com/lcyhjx/p/8688880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcyhjx/p/8688880.html</guid>
<description>&lt;p&gt;在14,15年间带领几个不同的团队，交付了几个项目，在这个过程中，虽然几个项目的业务不一样，但是很多应用程序架构基础性的功能却是大同小异，例如认证、授权、请求验证、异常处理、DTO、日志、审计、定时任务、调度、多语言、应用配置管理等等这些功能。但是由于项目受限于进度、资源、团队成员的背景，在当时却难于做到各个项目的统一，只能用拷贝的方式，然后在不通的项目中各自再根据各自的需求去做改进。这促使我下定决心去整理实现一个通用的应用程序级别的框架，来提升项目交付的效率和质量。&lt;/p&gt;
&lt;p&gt;在整理这个框架的过程中，参考了一些开源框架的设计和实现，无意中发现了ABP（ASP.NET Boilerplate）已经实现的正是我想要的，本着不重复造轮子的原则，在对ABP做了POC和评估后，在向整个评审小组展示时，尽管有诸多细节大家意见不尽相同，但对于整体框架却是少有的一致好评，在后来的项目交付中使用ABP也就是顺利成章的事了。当时ABP的版本还是0.5（现在的最新版本是3.5），尽管也踩了一些坑，但是总的来说还是大幅的提高了项目交付效率。&lt;/p&gt;
&lt;p&gt;好了，废话不多说，我们进入正题。&lt;/p&gt;
&lt;h3 id=&quot;什么是abp&quot;&gt;什么是ABP&lt;/h3&gt;
&lt;p&gt;ABP(ASP.NET Boilerplate)是一个开源的应用程序框架，以帮助开发人员快速开发。但它又不仅仅是一个框架，更提供了一套基于DDD的架构模型和最佳实践。&lt;/p&gt;
&lt;h3 id=&quot;快速示例&quot;&gt;快速示例&lt;/h3&gt;
&lt;p&gt;下面我们来研究一个最简单的示例来看看使用ABP好哪些好处&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class TaskAppService : ApplicationService, ITaskAppService
{
    private readonly IRepository&amp;lt;Task&amp;gt; _taskRepository;

    public TaskAppService(IRepository&amp;lt;Task&amp;gt; taskRepository)
    {
        _taskRepository = taskRepository;
    }

    [AbpAuthorize(MyPermissions.UpdateTasks)]
    public async Task UpdateTask(UpdateTaskInput input)
    {
        Logger.Info(&quot;Updating a task for input: &quot; + input);

        var task = await _taskRepository.FirstOrDefaultAsync(input.TaskId);
        if (task == null)
        {
            throw new UserFriendlyException(L(&quot;CouldNotFindTheTaskMessage&quot;));
        }

        input.MapTo(task);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们看到的是一个Application Service类, TaskAppService, 里面定义了一个方法UpdateTask. Application Service在DDD的设计中是直接被展示层所调用的，简单来说，一个前端页面可以直接调用TaskAppService.UpdateTask.&lt;/p&gt;
&lt;p&gt;就这个简单的示例，我们一起来看看使用ABP有哪些好处。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依赖注入&lt;/strong&gt; - ABP提供了一个惯用的DI基础框架，所谓惯用，就是大家平常使用的DI方式一致，保持大家的使用习惯。因为这个示例是在应用服务层，所以注入容器中的实例生命周期都是短时的（每个请求创建一次，生命周期与请求相同）。 它可以简单方便的注入任何依赖，比如在本示例中的IRepository&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仓储&lt;/strong&gt; - ABP可以为每一个实体都创建一个默认仓储，在示例中是IRepository&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;授权&lt;/strong&gt;- ABP可以使用声明式的方式来检查权限。在示例中，如果一个用户没有登录，或者没有“UpdateTasks”的权限，那么他将不能访问UpdateTask方法。 ABP不单单使用声明式的特性来检查权限，它还提供了其他的授权方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求验证&lt;/strong&gt;- ABP自动的检查请求输入(input)是否为null, 并且可以基于标准的数据注解和自定义验证规则来检查输入中的属性是否合法。如果请求不合法，它将会抛出一个验证异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;审计日志&lt;/strong&gt;- ABP会基于惯例和配置，自动为每一个请求记录访问的用户、浏览器、IP地址、调用的服务、方法、参数、调用时间、耗时、和其它一些信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作单元&lt;/strong&gt;- 在ABP中，每个应用服务方法，都被默认视为一个工作单元. 在进入方法时，ABP会自动的打开连接并开启事务，如果方法在执行过程没有任何异常，并且成功完成，那么在退出方法时，ABP会自动提交事务并释放连接。不管方法中使用了一个还是多个仓储，他们都是原子的，在一个事务中，所有的实体改变都会在事务提交时自动保存。正如示例中所示，我们甚至都不用调用显示的 '_repository.Update(task)'方法来保存数据更新。 不过我个人建议尽管可以不显示调用更新，但是从代码的可读性和可维护性还是显示的调用'_repository.Update(task)'方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常处理&lt;/strong&gt;- 在ABP我们几乎不用手动的来处理异常，ABP会默认自动处理所有异常。如果有异常发生，ABP会自动的记录它，并返回合适的结果给客户端。例如，如果这是一个AJAX请求，它会返回一个JSON对象给客户端，并指明有一个错误发生。它会向客户端隐藏真实的异常，除非我们使用UserFriendlyException.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志&lt;/strong&gt;- 我们可以使用基类中定义的Logger对象来写日志。 ABP默认使用Log4Net来写日志，当然我们也可以通过修改配置来使用其他的日志框架。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地化（多语言）&lt;/strong&gt;- 在示例中，当抛出异常时，使用了&quot;L&quot;方法，它会根据用户文化配置自动进行本地化处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动映射&lt;/strong&gt;- 在示例的最后一行，我们使用了ABP的MapTo扩展方法来讲输入对象的属性映射到实体对象的属性。它使用了AutoMapper库来执行映射，我们可以很容易的基于命名约定（简单来讲就是属性名相同，当然也可以指定）来将一个对象的属性来映射到另一个对象的属性。通常不同层都会定义自己的数据对象模型，而在层与层之间进行数据交换时，就设计到不同数据对象的转换，这个时候就是AutoMapper大显身手的好时机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态API层&lt;/strong&gt;- TaskAppService只是一个一般的类，通常我们需要写一个Web API Controller包装器来将TaskAppService的方法以API的形式暴露给客户端调用，但是ABP在运行时已经自动为AppService的方法生成了API接口，所以这样看起来，就像是客户端直接调用了AppService的方法（但实际不是）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态Javascript AJAX代理&lt;/strong&gt;- ABP在前端为应用服务的调用创建了代理方法，这样就可以在前端像调用Javascript方法一样调用应用服务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在示例中，我们可以看到使用ABP的优势，通常如果我们来做这些事情，会花费大量的时间，但是ABP框架都自动的为我们处理了。这里必须点个赞了。&lt;/p&gt;
&lt;p&gt;此外，除了这个示例中展示的ABP的优势以外，ABP还提高了一个健壮的基础架构和应用模型。包括模块化、多租户、缓存、配置管理、调度和后台任务、数据过滤、领域时间、单元测试和集成测试等等。它让我们可以集中关注在业务实现上，而不用重复的去造轮子。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 14:53:00 +0000</pubDate>
<dc:creator>lcyhjx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lcyhjx/p/8688880.html</dc:identifier>
</item>
<item>
<title>Linux进程间通信-共享内存 - //偏执</title>
<link>http://www.cnblogs.com/alvin2010/p/8654758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alvin2010/p/8654758.html</guid>
<description>&lt;p&gt;继前三篇分析了进程间通信机制管道，命名管道（FIFO），消息队列后，本文将介绍最后一种进程间通信机制，也是进程间通信机制效率最高的一种-共享内存&lt;/p&gt;
&lt;h2&gt;1、共享内存&lt;/h2&gt;
&lt;p&gt;考虑前三种进程间通信机制，一个客户-服务器文件复制程序将设计到一下步骤：&lt;/p&gt;
&lt;p&gt;（1）服务器从输入文件读取。该文件的数据由内核读入自己的内存空间，然后从内核复制到服务器进程。&lt;/p&gt;
&lt;p&gt;（2）服务器往管道、FIFO和消息队列以一条消息的形式写入这些数据。这些IPC形式需要把进程中的数据复制到内核。&lt;/p&gt;
&lt;p&gt;（3）客户端从这些IPC通道中读取数据，需要把内核数据复制到进程的地址空间。&lt;/p&gt;
&lt;p&gt;（4）客户端将进程空间内的数据再写入内核，由内核写入文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/596886/201803/596886-20180326230141469-1090286343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这些IPC形式的问题在于，共享数据需要多次经过内核。&lt;/p&gt;

&lt;p&gt;共享内存的方式是让同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制（Linux同步的机制系列文章）。同样是上面的例子，共享内存只需经过如下 流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/596886/201803/596886-20180326230659229-264205030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种形式的通信数据只需复制两次：一次从输入文件到共享内存，另一次是从共享内存到输出文件。&lt;/p&gt;
&lt;h2&gt;2、共享内存基本操作&lt;/h2&gt;
&lt;p&gt;2.1 打开/创建一个共享内存对象&lt;/p&gt;
&lt;p&gt;#include &amp;lt;sys/mman.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int shm_open(const char* name, int oflag, mode_t mode);&lt;/p&gt;
&lt;p&gt;成功返回非负描述符，若失败返回-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/mman.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flag = O_RDWR | O_CREAT |&lt;span&gt; O_EXCL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mode = S_IRUSR | S_IWUSR | S_IRGRP |&lt;span&gt; S_IROTH;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fd = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    fd &lt;/span&gt;= shm_open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/shm_test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, flag, mode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (-&lt;span&gt;1&lt;/span&gt; ==&lt;span&gt; fd)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open shm failed!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    ftruncate(fd, &lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;);

    mmap(NULL,&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;,PROT_READ|PROT_WRITE,MAP_SHARED,fd,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.2 删除一个共享对象的名字&lt;/p&gt;
&lt;p&gt;#include &amp;lt;sys/mman.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int shm_unlink(const char* name);&lt;/p&gt;
&lt;p&gt;成功返回0，失败返回-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/mman.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    shm_unlink(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/shm_test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.3 ftruncate 和 fstat&lt;/p&gt;
&lt;p&gt;处理mmap的时候，普通文件或共享内存对象的大小可以通过ftruncate函数修改：&lt;/p&gt;
&lt;p&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int ftruncate(int fd, off_t length);&lt;/p&gt;
&lt;p&gt;成功返回0，出错返回-1&lt;/p&gt;

&lt;p&gt;当打开一个已存在的共享内存区对象时，我们可调用fstat来获取有关该对象的信息：&lt;/p&gt;
&lt;p&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;sys/stat.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int fstat(int fd, struct stat* stat);&lt;/p&gt;
&lt;p&gt;成功返回0，失败返回-1&lt;/p&gt;
&lt;p align=&quot;left&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont2872.i7.427c6b63MAhvON&quot;&gt;对于普通文件stat结构可以获得12个以上的成员信息，然而当fd指代一个共享内存区对象时，只有四个成员含有信息。&lt;/p&gt;
&lt;p align=&quot;left&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont2872.i3.427c6b63MAhvON&quot;&gt;struct stat{&lt;/p&gt;
&lt;p align=&quot;left&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont2872.i3.427c6b63MAhvON&quot;&gt;...&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;mode_t st_mode;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;uid_t st_uid;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;gid_t st_gid;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;off_t st_size;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;};&lt;/p&gt;
&lt;p&gt; 2.4 共享内存的读写&lt;/p&gt;
&lt;p&gt;read端代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/mman.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flag =&lt;span&gt; O_RDONLY;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mode = S_IRUSR | S_IWUSR | S_IRGRP |&lt;span&gt; S_IROTH;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fd = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; ptr, c;
    fd &lt;/span&gt;= shm_open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/shm_test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, flag, mode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (-&lt;span&gt;1&lt;/span&gt; ==&lt;span&gt; fd)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open shm failed!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; stat stat; 
    fstat(fd,&lt;/span&gt;&amp;amp;&lt;span&gt;stat);
    ptr &lt;/span&gt;= mmap(NULL, stat.st_size, PROT_READ, MAP_SHARED, fd, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    close(fd);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; stat.st_size; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((c = *ptr++) != (i%&lt;span&gt;256&lt;/span&gt;&lt;span&gt;))
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read error!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            exit(&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,c);
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;write端代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/mman.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flag =&lt;span&gt; O_RDWR;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mode = S_IRUSR | S_IWUSR | S_IRGRP |&lt;span&gt; S_IROTH;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fd = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; ptr, c;
    fd &lt;/span&gt;= shm_open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/shm_test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, flag, mode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (-&lt;span&gt;1&lt;/span&gt; ==&lt;span&gt; fd)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open shm failed!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; stat stat; 
    fstat(fd,&lt;/span&gt;&amp;amp;&lt;span&gt;stat);
    ptr &lt;/span&gt;= mmap(NULL, stat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    close(fd);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; stat.st_size; i++&lt;span&gt;)
    {
        &lt;/span&gt;*ptr++ = i % &lt;span&gt;256&lt;/span&gt;&lt;span&gt;;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;这里与mqueue不同的是，read端读取的时候并不会阻塞等待，如果没有提前write内容到共享内存里，read读取到的内容为空。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3、共享内存的起始地址&lt;/h2&gt;
&lt;p&gt;同一共享内存区对象映射到不同进程的地址空间，起始地址可以不一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/mman.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;errno.h&amp;gt;&lt;span&gt; 
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fd1,fd2;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ptr1, *&lt;span&gt;ptr2;
    pid_t pid;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mode = S_IRUSR | S_IWUSR | S_IRGRP |&lt;span&gt; S_IROTH;
    fd1 &lt;/span&gt;= shm_open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/shm_test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,O_RDWR,mode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fd1 == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message : %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strerror(errno)); 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; stat stat;
    fstat(fd1, &lt;/span&gt;&amp;amp;&lt;span&gt;stat);

    fd2 &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/shm/shm_test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,O_RDWR |&lt;span&gt; O_CREAT,mode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fd2 == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message : %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strerror(errno)); 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    
    pid &lt;/span&gt;=&lt;span&gt; fork();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        ptr2 &lt;/span&gt;= mmap(NULL, &lt;span&gt;4&lt;/span&gt;, PROT_READ|PROT_WRITE, MAP_SHARED, fd2,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        ptr1 &lt;/span&gt;= mmap(NULL, &lt;span&gt;1024&lt;/span&gt;, PROT_READ|PROT_WRITE, MAP_SHARED, fd1, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child: shm ptr=%p, mmf ptr=%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ptr1, ptr2);
        sleep(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;share memory integer:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;ptr1);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pid &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        ptr1 &lt;/span&gt;= mmap(NULL, &lt;span&gt;1024&lt;/span&gt;, PROT_READ|PROT_WRITE, MAP_SHARED, fd1, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        ptr2 &lt;/span&gt;= mmap(NULL, &lt;span&gt;4&lt;/span&gt;, PROT_READ|PROT_WRITE, MAP_SHARED, fd2,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parent: shm ptr=%p, mmf ptr=%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ptr1, ptr2);
        &lt;/span&gt;*ptr1 = &lt;span&gt;128&lt;/span&gt;&lt;span&gt;;
        waitpid(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, NULL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 代码运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/596886/201804/596886-20180401224833233-1203485301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，在不同的进程中，相同的共享内存区对象起始地址可以不一样。 &lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 14:50:00 +0000</pubDate>
<dc:creator>//偏执</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alvin2010/p/8654758.html</dc:identifier>
</item>
<item>
<title>麻省理工18年春软件构造课程阅读11“抽象函数与表示不变量” - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/8688759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/8688759.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文内容来自&lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/&quot;&gt;MIT_6.031_sp18: Software Construction&lt;/a&gt;课程的Readings部分，采用&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;CC BY-SA 4.0&lt;/a&gt;协议。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于我们学校（哈工大）大二软件构造课程的大部分素材取自此，也是推荐的阅读材料之一，于是打算做一些翻译工作，自己学习的同时也能帮到一些懒得看英文的朋友。另外，该课程的阅读资料中有的练习题没有标准答案，所给出的“正确答案”为译者所写，有错误的地方还请指出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;（更新：从第10章开始只翻译正确答案）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;译者：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/&quot;&gt;李秋豪&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;审校：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V1.0 Sun Apr 1 22:23:37 CST 2018&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;本次课程的目标&quot;&gt;&lt;span&gt;本次课程的目标&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;今天我们会介绍以下几个思想：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不变量（invariants）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;表示暴露（representation exposure）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;抽象函数（abstraction functions）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;表示不变量（representation invariants）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在这篇阅读中，我们会学习用一种正规的数学思想（抽象函数和表示不变量）去理解抽象数据类型ADT的实现。这些思想在软件设计的实践中非常重要。其中，抽象函数会让我们清晰的定义对两个ADT判断相等的操作（我们会在后面的课程中深入介绍），而表示不变量会让我们更易发现破坏数据结构导致的bug。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;不变量&quot;&gt;&lt;span&gt;不变量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;回想我们之前讨论过的关于ADT的内容，什么设计会产生好的ADT？其中最重要的一点就是&lt;strong&gt;它会保护/保留自己的不变量。&lt;/strong&gt; &lt;em&gt;不变量&lt;/em&gt;是一种属性，它在程序运行的时候总是一种状态，而&lt;em&gt;不变性&lt;/em&gt;就是其中的一种：一旦一个不变类型的对象被创建，它总是代表一个不变的值。当一个ADT能够确保它内部的不变量恒定不变（不受使用者/外部影响），我们就说这个ADT&lt;em&gt;保护/保留自己的不变量&lt;/em&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个ADT保护/保留自己的不变量时，对代码的分析会变得更简单。例如，你能够依赖字符串不变性的特点，在分析的时候跳过那些关于字符串的代码；或者当你尝试基于字符串建立其他的不变量的时候，也会变得更简单。与此相对，对于可变的对象，你将不得不对每一处使用它的代码处进行审查。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;不变性&quot;&gt;&lt;span&gt;不变性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在这篇阅读的后面，我们会看到许多关于不变量的例子，现在我们先看一看不变性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * This immutable data type represents a tweet from Twitter.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Tweet {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String author;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String text;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Date timestamp;

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Make a Tweet.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;   Twitter user who wrote the tweet&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param text &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;     text of the tweet&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param timestamp &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;date/time when the tweet was sent&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(String author, String text, Date timestamp) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;author&lt;/span&gt; = author;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt; = text;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timestamp&lt;/span&gt; = timestamp;
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们应该怎么样做才能确保Tweet对象是不可变的（一旦被创建，author, message, 和 date都不能被改变）？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个威胁就是使用者可以直接访问Tweet内部的数据，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;Tweet t = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;justinbieber&quot;&lt;/span&gt;, 
                    &lt;span class=&quot;st&quot;&gt;&quot;Thanks to all those beliebers out there inspiring me every day&quot;&lt;/span&gt;, 
                    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date());
t.&lt;span class=&quot;fu&quot;&gt;author&lt;/span&gt; = &lt;span class=&quot;st&quot;&gt;&quot;rbmllr&quot;&lt;/span&gt;;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这就是一个&lt;strong&gt;表示暴露（Rep exposure）&lt;/strong&gt;的例子，就是说类外部的代码可以直接修改类内部存储的数据。上面的表示暴露不仅影响到了不变量，也影响到了表示独立性（译者注：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8667447.html&quot;&gt;“抽象数据类型”&lt;/a&gt;），如果我们改变类内部数据的表示方法，使用者也会受到影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;幸运地是，Java给我们提供了处理这样的表示暴露的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Tweet {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String author;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String text;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Date timestamp;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(String author, String text, Date timestamp) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;author&lt;/span&gt; = author;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt; = text;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timestamp&lt;/span&gt; = timestamp;
    }

    &lt;span class=&quot;co&quot;&gt;/** @return Twitter user who wrote the tweet */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getAuthor&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; author;
    }

    &lt;span class=&quot;co&quot;&gt;/** @return text of the tweet */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getText&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; text;
    }

    &lt;span class=&quot;co&quot;&gt;/** @return date/time when the tweet was sent */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Date &lt;span class=&quot;fu&quot;&gt;getTimestamp&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; timestamp;
    }

}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中， &lt;code&gt;private&lt;/code&gt; 表示这个区域只能由同类进行访问；而&lt;code&gt;final&lt;/code&gt;确保了该变量的索引不会被更改，对于不可变的类型来说，就是确保了变量的值不可变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这并没有解决全部问题，表示还是会暴露！思考下面这个代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** @return a tweet that retweets t, one hour later*/&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Tweet &lt;span class=&quot;fu&quot;&gt;retweetLater&lt;/span&gt;(Tweet t) {
    Date d = t.&lt;span class=&quot;fu&quot;&gt;getTimestamp&lt;/span&gt;();
    d.&lt;span class=&quot;fu&quot;&gt;setHours&lt;/span&gt;(d.&lt;span class=&quot;fu&quot;&gt;getHours&lt;/span&gt;()+&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;rbmllr&quot;&lt;/span&gt;, t.&lt;span class=&quot;fu&quot;&gt;getText&lt;/span&gt;(), d);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;retweetLater&lt;/code&gt; 希望接受一个Tweet对象然后修改Date后返回一个新的Tweet对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题出在哪里呢？其中的 &lt;code&gt;getTimestamp&lt;/code&gt; 调用返回一个一样的&lt;code&gt;Date&lt;/code&gt;对象，它会被 &lt;code&gt;t&lt;/code&gt;.&lt;code&gt;t.timestamp&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 同时索引。所以当我们调用 &lt;code&gt;d.setHours()&lt;/code&gt;后，&lt;code&gt;t&lt;/code&gt;也会受到影响，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223130111-1005539181.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，&lt;code&gt;Tweet&lt;/code&gt;的不变性就被破坏了。这里的问题就在于&lt;code&gt;Tweet&lt;/code&gt;将自己内部对于可变对象的索引“泄露”了出来，因此整个对象都变成可变的了，使用者在使用时也容易造成隐秘的bug。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过防御性复制来弥补这个问题：在返回的时候复制一个新的对象而不会返回原对象的索引。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Date &lt;span class=&quot;fu&quot;&gt;getTimestamp&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date(timestamp.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;());
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可变类型通常都有一个专门用来复制的构造者，你可以通过它产生一个一模一样的复制对象。在上面的例子中，&lt;code&gt;Date&lt;/code&gt;的复制构造者就接受了一个timestamp值，然后产生了一个新的对象。另一个复制可变对象的方法是使用&lt;code&gt;clone()&lt;/code&gt; ，但是它没有被很多类支持（译者注：标准库里面只有5%支持），在Java中，使用&lt;code&gt;clone()&lt;/code&gt;可能会带来一些麻烦。你可以在 &lt;a href=&quot;https://books.google.com/books?id=ka2VUBqHiWkC&amp;amp;lpg=PA33&amp;amp;pg=PA54#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;Josh Bloch, &lt;em&gt;Effective Java&lt;/em&gt;, item 11&lt;/a&gt;, 或者 &lt;a href=&quot;http://www.artima.com/intv/bloch13.html&quot;&gt;Copy Constructor vs. Cloning&lt;/a&gt;获得更多有关这方面的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们已经通过防御性复制解决了 &lt;code&gt;getTimestamp&lt;/code&gt;返回值的问题，但是我们还没有完成任务！思考这个使用者的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** @return a list of 24 inspiring tweets, one per hour today */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Tweet&amp;gt; &lt;span class=&quot;fu&quot;&gt;tweetEveryHourToday&lt;/span&gt; () {
    List&amp;lt;Tweet&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Tweet&amp;gt;(); 
    Date date = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date();
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;; i++) {
        date.&lt;span class=&quot;fu&quot;&gt;setHours&lt;/span&gt;(i);
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;rbmllr&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;keep it up! you can do it&quot;&lt;/span&gt;, date));
    } 
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; list;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个代码尝试创建24个Tweet对象，每一个对象代表一个小时，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223142837-1292377669.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，Tweet的不变性再次被打破了，因为每一个Tweet创建时对Date对象的索引都是一样的。所以我们应该对创建者也进行防御性编程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(String author, String text, Date timestamp) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;author&lt;/span&gt; = author;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt; = text;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timestamp&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date(timestamp.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;());
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通常来说，你要特别注意ADT操作中的参数和返回值。如果它们之中有可变类型的对象，确保你的代码没有直接使用索引或者直接返回索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可能会提出异议。这样不会很浪费吗？毕竟你要复制创建这么多新的对象。为什么不直接在规格说明中解决这个问题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Make a Tweet.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;   Twitter user who wrote the tweet&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param text &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;     text of the tweet&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param timestamp &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;date/time when the tweet was sent. Caller must never &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *                   mutate this Date object again!&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(String author, String text, Date timestamp) {&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这种方法一般只在迫不得已的时候使用——例如，这个可变对象的数据量非常大，如果进行防御性复制的话会花费很多资源（当然，这取决于你对程序的判断）。如果不是极端情况，确保ADT会保留/保护自己的不变量总比通过规格说明来限定使用者要好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而更好的解决方案是使用不可变类型。例如上面的例子中，如果我们使用的是 &lt;code&gt;java.time.ZonedDateTime&lt;/code&gt;而非 &lt;code&gt;java.util.Date&lt;/code&gt;, 那么我们只需要添加 &lt;code&gt;private&lt;/code&gt;和&lt;code&gt;final&lt;/code&gt;即可，不用再担心表示保留。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;可变类型的不可变包装&quot;&gt;&lt;span&gt;可变类型的不可变包装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Java的collections类提供了一种有趣的“折中”：不可变包装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Collections.unmodifiableList()&lt;/code&gt; 会接收一个（可变）&lt;code&gt;List&lt;/code&gt;然后将其包装为一个不可变对象——它的 &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt;, &lt;code&gt;remove()&lt;/code&gt;,等操作都会抛出异常。所以你可以将一个&lt;code&gt;List&lt;/code&gt;包装为不可变对象（记得将以前对于&lt;code&gt;List&lt;/code&gt;的索引丢掉），然后将它传入其他地方使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种方法的缺点就是你只能在运行时获得不可变性，而不是编译时。Java不会在编译的时候对你对“不可变”列表的修改提出警告。但是这总比什么都不做好，所以使用不可变的列表、映射、和集合也是减少bug的好方法。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Rep exposure&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考下面这个有问题的数据类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;      &lt;span class=&quot;co&quot;&gt;/** Represents an immutable right triangle. */&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RightTriangle {
&lt;span class=&quot;co&quot;&gt;/*A*/&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;[] sides;

&lt;span class=&quot;co&quot;&gt;/*B*/&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hypotenuse = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;

          &lt;span class=&quot;co&quot;&gt;/** Make a right triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param legA, &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;legB  the two legs of the triangle&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param hypotenuse &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;   the hypotenuse of the triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *C*       *        Requires hypotenuse^2 = legA^2 + legB^2 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           *           (within the error tolerance of double arithmetic)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           */&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RightTriangle&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; legA, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; legB, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; hypotenuse) {
&lt;span class=&quot;co&quot;&gt;/*D*/&lt;/span&gt;         &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;sides&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;[] { legA, legB };
&lt;span class=&quot;co&quot;&gt;/*D*/&lt;/span&gt;         &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;hypotenuse&lt;/span&gt; = hypotenuse;
          }

          &lt;span class=&quot;co&quot;&gt;/** Get the two sides of the right triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;two-element array with the triangle's side lengths&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           */&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;getAllSides&lt;/span&gt;() {
&lt;span class=&quot;co&quot;&gt;/*E*/&lt;/span&gt;         &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sides;
          }

          &lt;span class=&quot;co&quot;&gt;/** @param factor to multiply the sides by&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a triangle made from this triangle by &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           *  multiplying all side lengths by factor.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           */&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; RightTriangle &lt;span class=&quot;fu&quot;&gt;scale&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; factor) {
              &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RightTriangle&lt;/span&gt;(sides[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]*factor, sides[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]*factor, hypotenuse*factor);
          }

          &lt;span class=&quot;co&quot;&gt;/** @return a regular triangle made from this triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           *  A regular right triangle is one in which&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           *  both legs have the same length.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           */&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; RightTriangle &lt;span class=&quot;fu&quot;&gt;regularize&lt;/span&gt;() {
              &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; bigLeg = Math.&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(side[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], side[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
              &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RightTriangle&lt;/span&gt; (bigLeg, bigLeg, hypotenuse);
          }

      }&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以下哪些说法是正确的？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[ ] The line marked &lt;code&gt;/*A*/&lt;/code&gt; is a problem for rep exposure because arrays are mutable.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;/*B*/&lt;/code&gt; 处有问题，因为这种表示方法会让使用者依赖于类型内部的表示。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] The line marked &lt;code&gt;*C*&lt;/code&gt; is a problem because creator operations should not have preconditions.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] The two lines marked &lt;code&gt;/*D*/&lt;/code&gt; are a problem because they put legA, legB, and hypotenuse into the rep without doing a defensive copy first.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;/*E*/&lt;/code&gt; 处有问题，因为这影响到了类的不可变性。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;表示不变量和抽象函数&quot;&gt;&lt;span&gt;表示不变量和抽象函数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们现在深入理解一下抽象数据类型背后的理论，这些理论不仅本身很有趣，它们在ADT的设计与实现中也很有意义。如果你能够很好的理解它们，你将会设计出更好的抽象类型，并且远离那些隐晦的陷阱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在研究抽象类型的时候，先思考一下两个值域之间的关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示域（space of representation values）里面&lt;strong&gt;包含的是值具体的实现实体&lt;/strong&gt;。在简单的情况下，一个抽象类型只需要实现为单个的对象，但是更常见的情况是使用一个很多对象的网络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;抽象域里面包含的则是类型设计时支持使用的值。&lt;strong&gt;这些值是由表示域“抽象/想象”出来的，也是使用者关注的。&lt;/strong&gt;例如，一个无限整数对象的抽象域是整个整数域，但是它的实现域可能是一个由原始整数类型（有限）组成的数组实现的，而使用者只关注抽象域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，实现者是非常“在意”表示域（和抽象域）的，因为实现者的责任就是实现表示域到抽象域的转换（映射）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，我们选择用字符串来表示一个字符集合：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CharSet {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String s;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223157489-441273996.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，表示域R包含的是我们的实现实体（字符串），而抽象域里面是抽象类型表示的字符集合，我们用箭头表示这两个域之间的映射关系。这里要注意几点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;每一个抽象值都是由表示值映射而来&lt;/strong&gt; 。我们之前说过实现抽象类型的意义在于支持对于抽象值的操作，即我们需要能够创建和管理所有的抽象值，因此它们也必须是可表示的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一些抽象值是被多个表示值映射而来的。&lt;/strong&gt;这是因为表示方法并不是固定的，我们可以灵活的表示一个抽象值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;不是所有的表示值都能映射到抽象域中。&lt;/strong&gt;在上面这个例子中，“abbc”就没有被映射。因为我们已经确定了表示值的字符串中不能含有重复的字符——这样我们的 &lt;code&gt;remove&lt;/code&gt; 方法就能在遇到第一个对应字符的时候停止，因为我们知道没有重复的字符。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;由于我们不可能对每一个映射一一解释，为了描述这种对应关系和这两个域，我们再定义两个概念：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;抽象函数abstraction function&lt;/em&gt;是表示值到其对应的抽象值的映射：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;AF : R → A&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;快照图中的箭头表示的就是抽象函数，可以看出，这种映射是满射，但不一定是单射（不一定是双射）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;表示不变量rep invariant&lt;/em&gt;是表示值到布尔值的映射：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;RI : R → boolean&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;对于表示值r，当且仅当r被AF映射到了A，RI(r)为真。换句话说，RI告诉了我们哪些表示值是“良好组织”的（能够去表示A中的抽象值），在下图中，绿色表示的就是RI(r)为真的部分，AF只在这个子集上有定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223215214-880674112.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如上图中，CharSet这种类型的实现禁止有重复字符，所以 &lt;em&gt;RI(“a”)&lt;/em&gt; = true, &lt;em&gt;RI(“ac”)&lt;/em&gt; = true, &lt;em&gt;RI(“acb”)&lt;/em&gt; = true, 但是 &lt;em&gt;RI(“aa”)&lt;/em&gt; = false, &lt;em&gt;RI(“abbc”)&lt;/em&gt; = false.其中为假的集合用红色区域表示，合法的（为真）的字符串集合用绿色表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示不变量和抽象函数都应该在表示声明后注释出来：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CharSet {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String s;
    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   s contains no repeated characters&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(s) = {s[i] | 0 &amp;lt;= i &amp;lt; s.length()}&lt;/span&gt;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一个常见的疑惑就是，抽象函数和表示不变量似乎是被表示域和抽象域决定的，甚至似乎抽象域就可以决定它。如果是这样的话，那么它们的定义似乎没什么用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先证明抽象域并不能独立决定AF和RI：对于同样的抽象类型可以有多种表示方法。例如对于一个字符集合，我们既可以用字符串来表示，也可以用比特向量来表示，每一个比特位对应一个可能的字符。显然我们需要两个不同的抽象函数来表示这两种不同的映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们再来证明表示域和抽象域也不能决定AF和RI。这里的关键点在于，当我们确定表示域（表示值的空间）后，我们并不能决定哪一些表示值是合法的，以及如果它是合法的，它会被怎么解释/映射。例如在上面的例子中，我们也可以允许表示值有重复的字符，但是我们要求表示值中的字符必须是排好序的，因为这样我们就可以对其进行二分查找而非线性的遍历了。&lt;strong&gt;对于同一个表示域，我们得到了不同的表示不变量：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223224525-347402379.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CharSet {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String s;
    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   s[0] &amp;lt;= s[1] &amp;lt;= ... &amp;lt;= s[s.length()-1]&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(s) = {s[i] | 0 &amp;lt;= i &amp;lt; s.length()}&lt;/span&gt;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后，即使是同样的抽象域和表示域以及同样的表示不变量，我们也可能有不同的解释方法/抽象函数。还是上面的例子，我们可以对表示值中相邻的字符做不同的解释： &lt;code&gt;&quot;acgg&quot;&lt;/code&gt; 被解释为[a-c] 和 [g-g]中的字符，即{a,b,c,g}。现在的映射如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223233780-259712568.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CharSet {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String s;
    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   s.length() is even&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   s[0] &amp;lt;= s[1] &amp;lt;= ... &amp;lt;= s[s.length()-1]&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(s) = union of { c | s[2i] &amp;lt;= c &amp;lt;= s[2i+1] } &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//           for all 0 &amp;lt;= i &amp;lt; s.length()/2&lt;/span&gt;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总之，一个ADT的实现不仅是选择表示域（规格说明）和抽象域（具体实现），同时也要决定哪一些表示值是合法的（表示不变量），合法表示会被怎么解释/映射（抽象函数）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，你必须像我们一样在代码中写出这些设计，以便别的程序员（或者未来的你）明白这些表示到底意味着什么。为什么呢？当程序员不明白表示的含义时会发生什么问题呢？请完成下面的阅读小练习。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.6184210526316&quot;&gt;
&lt;p&gt;&lt;span&gt;你可以在Github上找到上面例子中&lt;code&gt;CharSet&lt;/code&gt;的&lt;a href=&quot;https://github.com/6031-sp18/ex11-adt-examples/tree/master/src/charset&quot;&gt;三种实现的代码&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;阅读小练习-1&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Exploring a rep&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请思考上面 &lt;code&gt;CharSet&lt;/code&gt; 的最后一种实现方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CharSet {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String s;
    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   s.length() is even&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   s[0] &amp;lt;= s[1] &amp;lt;= ... &amp;lt;= s[s.length()-1]&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(s) = union of { c | s[2i] &amp;lt;= c &amp;lt;= s[2i+1] } &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//           for all 0 &amp;lt;= i &amp;lt; s.length()/2&lt;/span&gt;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面哪个选项的 &lt;code&gt;s&lt;/code&gt; 满足了表示不变量？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;&quot;abc&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;&quot;eeee&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;&quot;ad&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;&quot;adad&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;AF(&quot;acfg&quot;)&lt;/code&gt; 会映射到哪一个集合？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] {a,b,c,d,e,f,g}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] {a,b,c,f,g}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] {a,c,f,g}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] some other abstract value&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] no abstract value, because &lt;code&gt;&quot;acfg&quot;&lt;/code&gt; does not satisfy the rep invariant&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面哪一个选项会和 &lt;code&gt;&quot;tv&quot;&lt;/code&gt;映射到同一个抽象值？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;&quot;ttv&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;&quot;ttuuvv&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;&quot;ttuv&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;&quot;tuv&quot;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Who knows what?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下哪一些选项是使用者需要了解的？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 抽象域&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 抽象函数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 创建者&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 观察者&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 表示域&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 表示不变量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;以下哪一些选项是开发者需要了解的？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[x] 抽象域&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 抽象函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 创建者&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 观察者&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 表示域&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 表示不变量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Rep invariant pieces&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设 &lt;code&gt;C&lt;/code&gt; 这种抽象数据类型的表示用到了两个字符串：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; C {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String s;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String t;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设你不知道任何关于&lt;code&gt;C&lt;/code&gt;抽象的信息，以下哪一些选项可能是&lt;code&gt;C&lt;/code&gt;的表示不变量？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;s&lt;/code&gt; 只能包含字母&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;s.length() == t.length()&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;s&lt;/code&gt; represents a set of characters&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;C&lt;/code&gt;’s observers&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;s&lt;/code&gt; 是 &lt;code&gt;t&lt;/code&gt;反序过来的结果&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;s+t&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Trying to implement without an AF/RI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设Louis 是这样表示&lt;code&gt;CharSet&lt;/code&gt;的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CharSet {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String s;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不幸的是，Louis忘记写下抽象函数（AF）和表示不变量（RI）了。这里有四中可能的AF/RI对。它们在之前的例子中已经提到过了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SortedRep:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// AF(s) = {s[i] | 0 &amp;lt;= i &amp;lt; s.length()}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// RI: s[0] &amp;lt; s[1] &amp;lt; ... &amp;lt; s[s.length()-1]&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SortedRangeRep:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// AF(s) = union of { c | s[2i] &amp;lt;= c &amp;lt;= s[2i+1] } &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//         for all 0 &amp;lt;= i &amp;lt; s.length()/2&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// RI: s.length() is even, and s[0] &amp;lt;= s[1] &amp;lt;= ... &amp;lt;= s[s.length()-1]&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;NoRepeatsRep:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// AF(s) = {s[i] | 0 &amp;lt;= i &amp;lt; s.length()}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// RI: s contains no character more than once&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;AnyRep:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// AF(s) = {s[i] | 0 &amp;lt;= i &amp;lt; s.length()}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// RI: true&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设Louis有三个不同的朋友在帮助他分别实现该类型的三个操作: &lt;code&gt;add()&lt;/code&gt;, &lt;code&gt;remove()&lt;/code&gt;, and &lt;code&gt;contains()&lt;/code&gt;，&lt;strong&gt;每一个朋友对这种类型的表示都有自己的猜想。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于下面 &lt;code&gt;add()&lt;/code&gt;的实现，哪一种AF/RI是可以对的上的？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Modifies this set by adding c to the set.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param c &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;character to add&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; c) {
    s = s + c;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] SortedRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] SortedRangeRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] NoRepeatsRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] AnyRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Trying to implement without an AF/RI #2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于下面 &lt;code&gt;remove()&lt;/code&gt;的实现，哪一种AF/RI是可以对的上的？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Modifies this set by removing c, if found.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * If c is not found in the set, has no effect.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param c &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;character to remove&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; c) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; position = s.&lt;span class=&quot;fu&quot;&gt;indexOf&lt;/span&gt;(c);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (position &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        s = s.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, position) + s.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(position&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;, s.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;());
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] SortedRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] SortedRangeRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] NoRepeatsRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] AnyRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Trying to implement without an AF/RI #3&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于下面 &lt;code&gt;contains()&lt;/code&gt;的实现，哪一种AF/RI是可以对的上的？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Test for membership.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param c &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a character&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;true iff this set contains c&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; c) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; s.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;(); i += &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) {
        &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; low = s.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(i);
        &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; high = s.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (low &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= high) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] SortedRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] SortedRangeRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] NoRepeatsRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] AnyRep&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;例子有理数&quot;&gt;&lt;span&gt;例子：有理数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里列出了一个表示有理数的例子。仔细观察表示不变量和抽象函数。我们似乎可以允许更多的表示值是合法的，但是这样做会让一些操作的实现变得复杂（假设变了），另一些操作则可能变得简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223243194-95248166.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RatNum {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numerator;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; denominator;

    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   denominator &amp;gt; 0&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   numerator/denominator is in reduced form&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(numerator, denominator) = numerator/denominator&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/** Make a new RatNum == n.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param n &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;value */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RatNum&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n) {
        numerator = n;
        denominator = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;fu&quot;&gt;checkRep&lt;/span&gt;();
    }

    &lt;span class=&quot;co&quot;&gt;/** Make a new RatNum == (n / d).&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param n &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;numerator&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param d &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;denominator&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws ArithmeticException &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;if d == 0 */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RatNum&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; d) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ArithmeticException {
        &lt;span class=&quot;co&quot;&gt;// reduce ratio to lowest terms&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; g = &lt;span class=&quot;fu&quot;&gt;gcd&lt;/span&gt;(n, d);
        n = n / g;
        d = d / g;

        &lt;span class=&quot;co&quot;&gt;// make denominator positive&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (d &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            numerator = -n;
            denominator = -d;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            numerator = n;
            denominator = d;
        }
        &lt;span class=&quot;fu&quot;&gt;checkRep&lt;/span&gt;();
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;阅读小练习-2&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RatNum&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阅读上面的代码和快照图，对于下面的每一种现象/属性，哪一行代码“负有最大的责任”（导致）？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;RatNum(1,-2)&lt;/code&gt; 出现在 R的红色区域：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;private final int numerator;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;private final int denominator;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// Rep invariant:&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;// denominator &amp;gt; 0&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// numerator/denominator is in reduced form&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// Abstraction function:&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// AF(numerator, denominator) = numerator/denominator&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;RatNum(2,4)&lt;/code&gt; 出现在 R的红色区域：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;private final int numerator;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;private final int denominator;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// Rep invariant:&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// denominator &amp;gt; 0&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;// numerator/denominator is in reduced form&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// Abstraction function:&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// AF(numerator, denominator) = numerator/denominator&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;RatNum(-1,2)&lt;/code&gt;到 -1/2 有一个箭头：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;private final int numerator;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;private final int denominator;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// Rep invariant:&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// denominator &amp;gt; 0&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// numerator/denominator is in reduced form&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;// Abstraction function:&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;// AF(numerator, denominator) = numerator/denominator&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;检查表示不变量&quot;&gt;&lt;span&gt;检查表示不变量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;表示不变量不仅是一个简洁的数学概念，你还可以通过断言检查它的不变属性来动态捕捉bug。例如上面的&lt;code&gt;RatNum&lt;/code&gt;，这里就举出了一种检查的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Check that the rep invariant is true&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// *** Warning: this does nothing unless you turn on assertion checking&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// by passing -enableassertions to Java&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;checkRep&lt;/span&gt;() {
    assert denominator &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    assert &lt;span class=&quot;fu&quot;&gt;gcd&lt;/span&gt;(Math.&lt;span class=&quot;fu&quot;&gt;abs&lt;/span&gt;(numerator), denominator) == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你应该在每一个创建或者改变表示数据的操作后调用 &lt;code&gt;checkRep()&lt;/code&gt; 检查不变量，换句话说，就是在使用创建者、生产者以及改造者之后。在上面的&lt;code&gt;RatNum&lt;/code&gt;中，你可以看到我们在两个创建者的最后都使用了 &lt;code&gt;checkRep()&lt;/code&gt; 进行检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然说观察者通常不需要使用 &lt;code&gt;checkRep()&lt;/code&gt; 进行检查，但这也是一个不错的主意。为什么？因为在每一个操作中调用 &lt;code&gt;checkRep()&lt;/code&gt; 检查不变量更能够帮助你捕捉因为表示暴露而带来的bug。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么 &lt;code&gt;checkRep()&lt;/code&gt; 是私有的？谁应该为为表示不变量负责？使用者还是实现者？&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-3&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Checking the rep invariant&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下哪一个选项的说法是正确的？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;checkRep()&lt;/code&gt; is the abstraction function&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;checkRep()&lt;/code&gt; 断言检查了表示不变量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] 对于实现者来说，在每一个类的公共方法返回前调用 &lt;code&gt;checkRep()&lt;/code&gt; 进行检查是一个好主意&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] it’s good for a client to call &lt;code&gt;checkRep()&lt;/code&gt; just after calling a public method of an ADT class&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;不要在表示中使用null&quot;&gt;&lt;span&gt;不要在表示中使用Null&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;回忆一下我们之前说过的使用null的坏处（译者注：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8566500.html&quot;&gt;“规格说明”&lt;/a&gt;），我们应该尽可能在编程中避免它。正因为如此，我们之前说如果没有特殊说明，前置条件和后置条件中都隐式包含不会有null值出现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们将这种闲置扩展到抽象数据类型的表示中。默认情况下，我们不允许表示中的索引出现null值（包括数组或者列表中的元素）。例如，如果你的表示是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CharSet {
    String s;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么表示不变量中默认就会有 &lt;code&gt;s != null&lt;/code&gt; ——你不需要专门在表示不变量的注释中进行说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，当你在实现检查表示不变量的 &lt;code&gt;checkRep()&lt;/code&gt; 时，你应该显式的检查 &lt;code&gt;s != null&lt;/code&gt;，确保当 &lt;code&gt;s&lt;/code&gt; 是 &lt;code&gt;null&lt;/code&gt; 的时候会快速失败。通常来说，这种检查会是自动的，因为很多操作在内容是null时会自动抛出异常，例如:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;checkRep&lt;/span&gt;() {
    assert s.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() % &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个时候你就不需要使用 &lt;code&gt;assert s != null&lt;/code&gt;,因为对 &lt;code&gt;s.length()&lt;/code&gt; 的调用会在&lt;code&gt;s&lt;/code&gt;为null的时候自动失败报错。但是如果没有对null的自动检查，你就需要显式的使用 &lt;code&gt;assert s != null&lt;/code&gt;了。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;友善改动&quot;&gt;&lt;span&gt;友善改动&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;回忆之前我们对于不可变类型的定义：对象一旦被创建其值不会发生更改。现在我们学习了抽象数据类型中的表示域和抽象域，我们可以将这个定义更加细化一下：对象一旦被创建，其抽象值不会发生改变。也就是说，对于使用者来说，其代表的值是不会变的，但是实现者可以在底层对表示域做一些改动，这些不会影响到抽象域的改动就称为&lt;strong&gt;友善改动（beneficent mutation）.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里举出了一个之前提到的&lt;code&gt;RatNum&lt;/code&gt;类型，不过我们将表示不变量的限制放宽了，不再要求分子和分母必须是最简形式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RatNum {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numerator;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; denominator;

    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   denominator != 0&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(numerator, denominator) = numerator/denominator&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Make a new RatNum == (n / d).&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param n &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;numerator&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param d &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;denominator&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws ArithmeticException &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;if d == 0&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RatNum&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; d) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ArithmeticException {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (d == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArithmeticException();
        numerator = n;
        denominator = d;
        &lt;span class=&quot;fu&quot;&gt;checkRep&lt;/span&gt;();
    }

    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样的话，再显示值之前，我们要对其进行简化：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a string representation of this rational number&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;() {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; g = &lt;span class=&quot;fu&quot;&gt;gcd&lt;/span&gt;(numerator, denominator);
        numerator /= g;
        denominator /= g;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (denominator &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            numerator = -numerator;
            denominator = -denominator;
        }
        &lt;span class=&quot;fu&quot;&gt;checkRep&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (denominator &amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) ? (numerator + &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt; + denominator) 
                                 : (numerator + &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
    }&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意到 &lt;code&gt;toString&lt;/code&gt; 实现更改了私有区域 &lt;code&gt;numerator&lt;/code&gt; 和 &lt;code&gt;denominator&lt;/code&gt;, 即它改变了表示域——虽然这还是一个观察者！但是关键点在于，这种改动并没有改变映射到的抽象值。我们对分子分母进行的约分和同乘-1的操作并没有改变&lt;code&gt;AF(numerator, denominator) = numerator/denominator&lt;/code&gt;的行为。也可以这样想，AF是一种多对一函数，即一个表示值可以用多种表示值来实现。所以这种改动是无害的，也就是“友善”的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们会在后面的课程中看到很多使用友善改动的例子。这种实现上的自由通常可以带来性能上的提升，例如缓冲、数据结构再平衡、延迟清除等策略。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;af-ri以及表示暴露安全性的注解&quot;&gt;&lt;span&gt;AF, RI以及表示暴露安全性的注解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;你应该在抽象类型（私有的）表示声明后写上对于抽象函数和表示不变量的注解，这是一个好的实践要求。我们在上面的例子中也是这么做的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你在描述抽象函数和表示不变量的时候，注意要清晰明确：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对于RI（表示不变量），仅仅宽泛的说什么区域是合法的并不够，你还应该说明是什么使得它合法/不合法。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于AF（抽象函数）来说，仅仅宽泛的说抽象域表示了什么并不够。抽象函数的作用是规定合法的表示值会如何被解释到抽象域。作为一个函数，我们应该清晰的知道从一个输入到一个输入是怎么对应的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;本门课程还要求你将&lt;strong&gt;表示暴露的安全性&lt;/strong&gt;注释出来。这种注释应该说明表示的每一部分，它们为什么不会发生表示暴露，特别是处理的表示的参数输入和返回部分（这也是表示暴露发生的位置）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一个&lt;code&gt;Tweet&lt;/code&gt;类的例子，它将表示不变量和抽象函数以及表示暴露的安全性注释了出来：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Immutable type representing a tweet.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Tweet {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String author;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String text;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Date timestamp;

    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   author is a Twitter username (a nonempty string of letters, digits, underscores)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   text.length &amp;lt;= 140&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(author, text, timestamp) = a tweet posted by author, with content text, &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//                                 at time timestamp &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Safety from rep exposure:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   All fields are private;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   author and text are Strings, so are guaranteed immutable;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   timestamp is a mutable Date, so Tweet() constructor and getTimestamp() &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//        make defensive copies to avoid sharing the rep's Date object with clients.&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// Operations (specs and method bodies omitted to save space)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tweet&lt;/span&gt;(String author, String text, Date timestamp) { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getAuthor&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getText&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Date &lt;span class=&quot;fu&quot;&gt;getTimestamp&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意到我们并没有对 &lt;code&gt;timestamp&lt;/code&gt; 的表示不变量进行要求（除了之前说过的默认 &lt;code&gt;timestamp!=null&lt;/code&gt;）。但是我们依然需要对&lt;code&gt;timestamp&lt;/code&gt; 的表示暴露的安全性进行说明，因为整个类型的不变性依赖于所有的成员变量的不变性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是关于 &lt;code&gt;RatNum&lt;/code&gt;的另一个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Immutable type representing a rational number.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RatNum {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numerator;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; denominator;

    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   denominator &amp;gt; 0&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   numerator/denominator is in reduced form, i.e. gcd(|numerator|,denominator) = 1&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   AF(numerator, denominator) = numerator/denominator&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Safety from rep exposure:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//   All fields are private, and all types in the rep are immutable.&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// Operations (specs and method bodies omitted to save space)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RatNum&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n) { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RatNum&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; d) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ArithmeticException { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到，对于不可变类型的表示，表示暴露的安全性说明会简单很多。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;你可以在GitHub&lt;a href=&quot;https://github.com/6031-sp18/ex11-adt-examples/blob/master/src/RatNum.java&quot;&gt;获取&lt;code&gt;RatNum&lt;/code&gt;的所有代码&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;阅读小练习-4&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Arguing against rep exposure&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考这个抽象数据类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Mutable type representing Twitter users' followers.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FollowGraph {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Map&amp;lt;String,Set&amp;lt;String&amp;gt;&amp;gt; followersOf;

    &lt;span class=&quot;co&quot;&gt;// Rep invariant:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//    all Strings in followersOf are Twitter usernames&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//           (i.e., nonempty strings of letters, digits, underscores)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//    no user follows themselves, i.e. x is not in followersOf.get(x)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Abstraction function:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//    AF(followersOf) = the follower graph where Twitter user x is followed by user y&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//                      if and only if followersOf.get(x).contains(y)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Safety from rep exposure:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//    All fields are private, and ..???..&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// Operations (specs and method bodies omitted to save space)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;FollowGraph&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addFollower&lt;/span&gt;(String user, String follower) { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;removeFollower&lt;/span&gt;(String user, String follower) { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt; &lt;span class=&quot;fu&quot;&gt;getFollowers&lt;/span&gt;(String user) { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于上面代码中的注解，下面哪一个选项可以正确的替代 &lt;code&gt;..???..&lt;/code&gt; ，从而使得表示暴露的安全性得到说明？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt; “Strings are immutable.”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;No&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; “&lt;code&gt;followersOf&lt;/code&gt; 是一个可变的 &lt;code&gt;Map&lt;/code&gt;， 其包含着可变的 &lt;code&gt;Set&lt;/code&gt; 对象，但是 &lt;code&gt;getFollowers()&lt;/code&gt; 在返回时会对 &lt;code&gt;Set&lt;/code&gt; 进行防御性复制，并且其他的参数和返回值都是不可变类型的 &lt;code&gt;String&lt;/code&gt; 或者 &lt;code&gt;void&lt;/code&gt; .”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt; “This class is mutable, so rep exposure isn’t an issue.”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;No&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt; “&lt;code&gt;followersOf&lt;/code&gt; is a mutable Map, but it is never passed or returned from an operation.”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;No&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.&lt;/strong&gt; “&lt;code&gt;FollowGraph()&lt;/code&gt; does not expose the rep; &lt;code&gt;addFollower()&lt;/code&gt; does not expose the rep; &lt;code&gt;removeFollower()&lt;/code&gt; does not expose the rep; &lt;code&gt;getFollowers()&lt;/code&gt; does not expose the rep.”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;No&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.&lt;/strong&gt; “&lt;code&gt;String&lt;/code&gt; 是不可变的, 并且表示中的 &lt;code&gt;Set&lt;/code&gt; 对象都使用了不可变包装。虽然&lt;code&gt;Map&lt;/code&gt;类型是可变的，但是没有操作传入或者返回这种类型的对象。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;一个adt的规格说明应该写什么&quot;&gt;&lt;span&gt;一个ADT的规格说明应该写什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于我们已经讲了如何对表示不变量和抽象函数做注解，现在我们就来更新一下我们对于规格说明的理解，即一个ADT的规格说明应该写什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201804/1072319-20180401223252219-235735577.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，规格说明在使用者和实现者之间构建起了一道“防火墙”。抽象类型的&lt;strong&gt;规格说明（包含操作的说明）应该只关注使用者可见的部分，&lt;/strong&gt;这包括参数、返回值、可能抛出的异常。例如规格说明需要引用T的值时，它应该是抽象域的值而非表示域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;规格说明不应该谈论具体的表示/实现细节，例如表示域里面的值。它应该认为表示本身（私有区域）对于使用者是不可见的，就像是方法里面的局部变量对外部不可见。这也是为什么我们在注解表示不变量和抽象函数的时候使用的是&quot;\\&quot;注释而非典型的Javadoc格式。如果我们使用Javadoc注释的话，内部的实现细节会出现在规格说明中，而这会影响表示独立性以及信息隐藏。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;用adt不变量替换前置条件&quot;&gt;&lt;span&gt;用ADT不变量替换前置条件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;良好设计的ADT的一个大优点在于我们&lt;strong&gt;可以使用它将本该写在前置条件中的限制封装起来&lt;/strong&gt;。例如，现在有一个规格说明是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param set1 &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;is a sorted set of characters with no repeats&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param set2 &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;is likewise&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;characters that appear in one set but not the other,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *  in sorted order with no repeats &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;exclusiveOr&lt;/span&gt;(String set1, String set2);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可以利用ADT（&lt;code&gt;SortedSet&lt;/code&gt;）的不变量属性要求这种前置条件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** @return characters that appear in one set but not the other */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; SortedSet&amp;lt;Character&amp;gt; &lt;span class=&quot;fu&quot;&gt;exclusiveOr&lt;/span&gt;(SortedSet&amp;lt;Character&amp;gt;  set1, SortedSet&amp;lt;Character&amp;gt; set2);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这满足了我们所有的要求：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;远离bug：因为要求的条件（排序、无重复）都已经是ADT的不变量了，所以Java可以对其进行静态检查，在编译期阻止所有不满足的操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;易于理解：因为这样写更简单，并且ADT &lt;code&gt;SortedSet&lt;/code&gt; 的名字就已经表明了它该有的属性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可改动：因为我们可以改变 &lt;code&gt;SortedSet&lt;/code&gt; 的内部实现而不影响 &lt;code&gt;exclusiveOr&lt;/code&gt; 或其他的使用者代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们以前很多用前置条件的地方现在都可以用定制的ADT来替换。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-5&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Encapsulating preconditions in ADTs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考下面这个方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Find tweets written by a particular user.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param tweets &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a list of tweets with distinct timestamps, not modified by this method.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param username &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;Twitter username (a nonempty sequence of letters, digits, and underscore)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;all and only the tweets in the list whose author is username,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *         in the same order as in the input list.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Tweet&amp;gt; &lt;span class=&quot;fu&quot;&gt;writtenBy&lt;/span&gt;(List&amp;lt;Tweet&amp;gt; tweets, String username) { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你会创建一个什么ADT来避开这种繁杂的前置要求？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;TweetsAndUsername&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;TweetList&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;Username&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;UsernameCharacter&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何建立不变量&quot;&gt;&lt;span&gt;如何建立不变量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;不变量是一种在程序中一直为真的属性，对于对象而言，就是从对象创建开始一直具有的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了保持一个不变量，我们需要：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;确保在对象创建的时候不变量成立&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;确保对对象在接下来的每一个改变后不变量依然成立&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;译者注：这就是状态机中的不变性 &lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/7810369.html&quot;&gt;状态机：如何构建稳定的婚姻&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;翻译成对于ADT的操作，就是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建者和生产者必须对新的对象就建立不变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;改造者和观察者必须保持/保护这种不变量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;表示暴露会使得情况更加复杂，如果一个表示被暴露出来，那么程序的任何地方都可能对其进行修改，我们也就没法确保不变量一直成立了。所以使用不变量完整的规则应该是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结构归纳法&lt;/strong&gt;. 如果一个抽象数据类型的不变量满足：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;被创建者或生产者创建；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;被改造者和观察者保持；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;没有表示暴露。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;那么这种类型的所有实例的不变量都是成立的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-6&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Structural induction&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recall this data type from the first exercise in this reading:回忆在第一个练习中的数据类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** Represents an immutable right triangle. */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RightTriangle {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;[] sides;
    &lt;span class=&quot;co&quot;&gt;// RI: ???&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// AF: ???&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// sides[0] and sides[1] are the two legs,&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// and sides[2] is the hypotenuse, so declare it to avoid having a&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// magic number in the code:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; HYPOTENUSE = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;/** Make a right triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param legA, &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;legB  the two legs of the triangle&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param hypotenuse &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;   the hypotenuse of the triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *        Requires hypotenuse^2 = legA^2 + legB^2 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *           (within the error tolerance of double arithmetic)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RightTriangle&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; legA, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; legB, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; hypotenuse) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;sides&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;[] { legA, legB, hypotenuse };
    }

    &lt;span class=&quot;co&quot;&gt;/** Get all the sides of the triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;three-element array with the triangle's side lengths&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;getAllSides&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sides;
    }

    &lt;span class=&quot;co&quot;&gt;/** @return length of the triangle's hypotenuse */&lt;/span&gt; 
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getHypotenuse&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sides[HYPOTENUSE];
    }

    &lt;span class=&quot;co&quot;&gt;/** @param factor to multiply the sides by&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a triangle made from this triangle by &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  multiplying all side lengths by factor.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; RightTriangle &lt;span class=&quot;fu&quot;&gt;scale&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; factor) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RightTriangle&lt;/span&gt; (sides[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]*factor, sides[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]*factor, sides[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]*factor);
    }

    &lt;span class=&quot;co&quot;&gt;/** @return a regular triangle made from this triangle.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  A regular right triangle is one in which&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *  both legs have the same length.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; RightTriangle &lt;span class=&quot;fu&quot;&gt;regularize&lt;/span&gt;() {
        &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; bigLeg = Math.&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(sides[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], sides[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RightTriangle&lt;/span&gt; (bigLeg, bigLeg, sides[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]);
    }

}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个数据类型中有一个重要的不变量，那就是直角边和斜边之间的勾股关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设使用者遵守了规格说明，以下哪一个说法是正确的？&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不变量是指对于一个对象，它有一种能够在整个生命周期保证为真的属性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个好的ADT会确保它的不变量为真。不变量是由创建者和生产者创建，被观察者和改造者保持。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;表示不变量明确了什么是合法的表示值，并且这些表示应该在运行时调用&lt;code&gt;checkRep()&lt;/code&gt;检查。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;抽象函数将具体的表示映射到抽象值上。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;表示暴露会威胁到表示独立性和表示不变量。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面将这篇阅读的知识点与我们的三个目标联系起来：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;远离bug.&lt;/strong&gt; 一个好的ADT会确保它的不变量为真，因此它们不会被使用者代码中的bug所影响。同时，通过显式的声明和动态检查不变量，我们可以尽早的发现bug，而不是让错误的行为继续下去。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;易于理解.&lt;/strong&gt; 表示不变量和抽象函数详细的表述了抽象类型中表示的意义，以及它们是如何联系到抽象值的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可改动.&lt;/strong&gt; 抽象数据类型分离了抽象域和表示域，这使得实现者可以改动具体实现而不影响使用者的代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 01 Apr 2018 14:34:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/8688759.html</dc:identifier>
</item>
<item>
<title>Active MQ 实战(一) - 渡劫红尘</title>
<link>http://www.cnblogs.com/sunTin/p/8546954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunTin/p/8546954.html</guid>
<description>&lt;h2&gt;1、什么是JMS&lt;/h2&gt;
&lt;p&gt;　　　　JMS即&lt;a href=&quot;http://baike.baidu.com/view/3292569.htm&quot; target=&quot;_blank&quot;&gt;Java消息服务&lt;/a&gt;（Java Message Service）应用程序接口，是一个&lt;a href=&quot;http://baike.baidu.com/view/209634.htm&quot; target=&quot;_blank&quot;&gt;Java平台&lt;/a&gt;中关于面向&lt;a href=&quot;http://baike.baidu.com/view/3118541.htm&quot; target=&quot;_blank&quot;&gt;消息中间件&lt;/a&gt;（MOM）的&lt;a href=&quot;http://baike.baidu.com/subview/16068/5889234.htm&quot; target=&quot;_blank&quot; data-lemmaid=&quot;10154&quot;&gt;API&lt;/a&gt;，用于在两个应用程序之间，或&lt;a href=&quot;http://baike.baidu.com/view/991489.htm&quot; target=&quot;_blank&quot;&gt;分布式系统&lt;/a&gt;中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持（百度百科给出的概述）。我们可以简单的理解：两个应用程序之间需要进行通信，我们使用一个JMS服务，进行中间的转发，通过JMS 的使用，我们可以解除两个程序之间的耦合。&lt;/p&gt;

&lt;h2&gt;2、JMS的优势　　&lt;/h2&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;h4&gt;Asynchronous（异步）&lt;/h4&gt;
&lt;p&gt;JMS is asynchronous by default. So to receive a message, the client is not required to send the request. The message will arrive automatically to the client as they become available.（JMS 原本就是一个异步的消息服务，客户端获取消息的时候，不需要主动发送请求，消息会自动发送给可用的客户端）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;h4&gt;Reliable（可靠）&lt;/h4&gt;
&lt;p&gt;JMS provides the facility of assurance that the message will delivered once and only once. You know that duplicate messages create problems. JMS helps you avoiding such problems.（JMS保证消息只会递送一次。大家都遇到过重复创建消息问题，而JMS能帮你避免该问题。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3、JMS的消息模型&lt;/h2&gt;
&lt;p&gt;　　　JMS具有两种通信模式：&lt;/p&gt;
&lt;p&gt;　　　　　　1、Point-to-Point Messaging Domain （点对点）&lt;/p&gt;
&lt;p&gt;　　　　　　2、Publish/Subscribe Messaging Domain （发布/订阅模式）&lt;/p&gt;
&lt;p&gt;　　　在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。&lt;/p&gt;

&lt;h3&gt;　　(1)、Point-to-Point Messaging Domain（点对点通信模型）&lt;/h3&gt;
&lt;p&gt;　　　　　　a、模式图：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/1053081/201612/1053081-20161225181832698-485177181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　　　b、涉及到的概念：&lt;/p&gt;
&lt;p&gt;　　　　　　　　在点对点通信模式中，应用程序由消息队列，发送方，接收方组成。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。&lt;/p&gt;
&lt;p&gt;　　　　　　c、特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;每个消息只要一个消费者&lt;/li&gt;
&lt;li&gt;发送者和接收者在时间上是没有时间的约束，也就是说发送者在发送完消息之后，不管接收者有没有接受消息，都不会影响发送方发送消息到消息队列中。&lt;/li&gt;
&lt;li&gt;发送方不管是否在发送消息，接收方都可以从消息队列中去到消息（The receiver can fetch message whether it is running or not when the sender sends the message）&lt;/li&gt;
&lt;li&gt;接收方在接收完消息之后，需要向消息队列应答成功&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　(2)、Publish/Subscribe Messaging Domain（发布/订阅通信模型）&lt;/h3&gt;
&lt;p&gt;　　　　　　a、模式图：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/1053081/201612/1053081-20161225182915667-528305346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　b、涉及到的概念：&lt;/p&gt;
&lt;p&gt;　　　　　　　　在发布/订阅消息模型中，发布者发布一个消息，该消息通过topic传递给所有的客户端。该模式下，发布者与订阅者都是匿名的，即发布者与订阅者都不知道对方是谁。并且可以动态的发布与订阅Topic。Topic主要用于保存和传递消息，且会一直保存消息直到消息被传递给客户端。&lt;/p&gt;
&lt;p&gt;　　　　　　c、特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;一个消息可以传递个多个订阅者（即：一个消息可以有多个接受方）&lt;/li&gt;
&lt;li&gt;发布者与订阅者具有时间约束，针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。&lt;/li&gt;
&lt;li&gt;为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4、JMS接收消息&lt;/h2&gt;
&lt;p&gt;　　　　在JMS中，消息的产生和消息是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。&lt;/p&gt;
&lt;p&gt;　　　　（1）、同步（Synchronous）&lt;/p&gt;
&lt;p&gt;　　　　　　　　在同步消费信息模式模式中，订阅者/接收方通过调用 receive（）方法来接收消息。在receive（）方法中，线程会阻塞直到消息到达或者到指定时间后消息仍未到达。&lt;/p&gt;
&lt;p&gt;　　　　（2）、异步（Asynchronous）&lt;/p&gt;
&lt;p&gt;　　　　　　　　使用异步方式接收消息的话，消息订阅者需注册一个消息监听者，类似于事件监听器，只要消息到达，JMS服务提供者会通过调用监听器的onMessage()递送消息。&lt;/p&gt;


&lt;h2&gt;5、JMS编程模型　&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;管理对象（Administered objects）-连接工厂（Connection Factories）和目的地（Destination）&lt;/li&gt;
&lt;li&gt;连接对象（Connections）&lt;/li&gt;
&lt;li&gt;会话（Sessions）&lt;/li&gt;
&lt;li&gt;消息生产者（Message Producers）&lt;/li&gt;
&lt;li&gt;消息消费者（Message Consumers）&lt;/li&gt;
&lt;li&gt;消息监听者（Message Listeners）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/1053081/201612/1053081-20161225184356526-613434118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　（1）、Connection Factories&lt;/p&gt;
&lt;p&gt;　　　　　　　　创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。客户端使用一个连接工厂对象连接到JMS服务提供者，它创建了JMS服务提供者和客户端之间的连接。JMS客户端（如发送者或接受者）会在JNDI名字空间中搜索并获取该连接。使用该连接，客户端能够与目的地通讯，往队列或话题发送/接收消息。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
QueueConnectionFactory queueConnFactory = (QueueConnectionFactory) initialCtx.lookup (&quot;primaryQCF&quot;);
Queue purchaseQueue = (Queue) initialCtx.lookup (&quot;Purchase_Queue&quot;);
Queue returnQueue = (Queue) initialCtx.lookup (&quot;Return_Queue&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　（2）、Destination&lt;/p&gt;
&lt;p&gt; 　　　　　　　　目的地指明消息被发送的目的地以及客户端接收消息的来源。JMS使用两种目的地，队列和话题。如下代码指定了一个队列和话题：&lt;/p&gt;
&lt;p&gt;　　　　创建一个队列Session：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
QueueSession ses = con.createQueueSession (false, Session.AUTO_ACKNOWLEDGE);  //get the Queue object  
Queue t = (Queue) ctx.lookup (&quot;myQueue&quot;);  //create QueueReceiver  
QueueReceiver receiver = ses.createReceiver(t); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　创建一个Topic Session：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
QueueSession ses = con.createQueueSession (false, Session.AUTO_ACKNOWLEDGE);  //get the Queue object  
Queue t = (Queue) ctx.lookup (&quot;myQueue&quot;);  //create QueueReceiver  
QueueReceiver receiver = ses.createReceiver(t); 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　　　（3）、Connection&lt;/p&gt;
&lt;p&gt;　　　　　　Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。&lt;/p&gt;
&lt;p&gt;　　　　　　连接对象封装了与JMS提供者之间的虚拟连接，如果我们有一个ConnectionFactory对象，可以使用它来创建一个连接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Connection connection = connectionFactory.createConnection();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　（4）、Session&lt;/p&gt;
&lt;p&gt;　　　　　　Session 是我们对消息进行操作的接口，可以通过session创建生产者、消费者、消息等。Session 提供了事务的功能，如果需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。&lt;/p&gt;
&lt;p&gt;　　　　　　我们可以在连接创建完成之后创建session：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　这里面提供了参数两个参数，第一个参数是是否支持事务，第二个是事务的类型&lt;/p&gt;
&lt;p&gt;　　　　（5）、Producter&lt;/p&gt;
&lt;p&gt;　　　　　　消息生产者由Session创建，用于往目的地发送消息。生产者实现MessageProducer接口，我们可以为目的地、队列或话题创建生产者；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MessageProducer producer = session.createProducer(dest);
MessageProducer producer = session.createProducer(queue);
MessageProducer producer = session.createProducer(topic);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　（6）、Consumer&lt;/p&gt;
&lt;p&gt;　　　　　　消息消费者由Session创建，用于接收被发送到Destination的消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MessageConsumer consumer = session.createConsumer(dest);
MessageConsumer consumer = session.createConsumer(queue);
MessageConsumer consumer = session.createConsumer(topic);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　（7）、MessageListener&lt;/p&gt;
&lt;p&gt;　　　　　　消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sun.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.ConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.DeliveryMode;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.Destination;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.JMSException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.MessageProducer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.Session;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.TextMessage;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; sun 点对点模型
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sender {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SEND_NUMBER = 5&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接工厂，JMS 用它创建连接&lt;/span&gt;
        Connection connection = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JMS 客户端到JMS Provider 的连接&lt;/span&gt;
        Session session = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个发送或接收消息的会话&lt;/span&gt;
        Destination destination = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息的目的地;消息发送给谁&lt;/span&gt;
        MessageProducer messageProducer = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息发送者
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造ConnectionFactory实例对象&lt;/span&gt;
        connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为空&lt;/span&gt;
                ActiveMQConnection.DEFAULT_PASSWORD, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为空&lt;/span&gt;
                &quot;tcp://127.0.0.1:61616&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造从工厂得到连接对象&lt;/span&gt;
            connection =&lt;span&gt; connectionFactory.createConnection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动&lt;/span&gt;
&lt;span&gt;            connection.start();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取操作连接&lt;/span&gt;
            session =&lt;span&gt; connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取session注意参数值zhan.huijing.Queue是一个服务器的queue，须在ActiveMq的console配置&lt;/span&gt;
            destination = session.createQueue(&quot;zhan.huijing.Queue&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到消息生成者【发送者】&lt;/span&gt;
            messageProducer =&lt;span&gt; session.createProducer(destination);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置不持久化，此处学习，实际根据项目决定&lt;/span&gt;
&lt;span&gt;            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造消息，此处写死，项目就是参数，或者方法获取&lt;/span&gt;
&lt;span&gt;            sendMessage(session, messageProducer);
            session.commit();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; connection)
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                connection.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                e.printStackTrace();
            }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; session
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; messageProducer
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; JMSException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendMessage(Session session, MessageProducer messageProducer) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; JMSException {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= SEND_NUMBER; i++&lt;span&gt;) {
            TextMessage message &lt;/span&gt;= session.createTextMessage(&lt;span&gt;new&lt;/span&gt; Date() + &quot; 学习ActiveMq&quot;&lt;span&gt;);
            String msg &lt;/span&gt;=&lt;span&gt; message.getText();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送消息到目的地方&lt;/span&gt;
            System.out.println(&quot;发送消息：&quot; + i + &quot;：&quot; +&lt;span&gt; msg);
            messageProducer.send(message);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sun.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.ConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.Destination;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.JMSException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.Message;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.MessageConsumer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.MessageListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.Session;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jms.TextMessage;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; sun
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReceiverListener {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory connectionFactory &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接工厂，JMS 用它创建连接&lt;/span&gt;
        Connection connection = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JMS 客户端到JMS Provider 的连接&lt;/span&gt;
        Session session = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个发送或接收消息的会话&lt;/span&gt;
        Destination destination = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息的目的地;消息发送给谁&lt;/span&gt;
        MessageConsumer consumer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消费者，消息接收者
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造ConnectionFactory实例对象&lt;/span&gt;
        connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为空&lt;/span&gt;
                ActiveMQConnection.DEFAULT_PASSWORD, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为空&lt;/span&gt;
                &quot;tcp://127.0.0.1:61616&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造从工厂得到连接对象&lt;/span&gt;
            connection =&lt;span&gt; connectionFactory.createConnection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动&lt;/span&gt;
&lt;span&gt;            connection.start();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取操作连接&lt;/span&gt;
            session =&lt;span&gt; connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取session注意参数值zhan.huijing.Queue是一个服务器的queue，须在在ActiveMq的console配置&lt;/span&gt;
            destination = session.createQueue(&quot;zhan.huijing.Queue&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从消息队列destination中抓取消息&lt;/span&gt;
            consumer =&lt;span&gt; session.createConsumer(destination);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听器监听&lt;/span&gt;
            consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
                    TextMessage tm &lt;/span&gt;=&lt;span&gt; (TextMessage) message;
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        System.out.println(&lt;/span&gt;&quot;收到消息：&quot; +&lt;span&gt; tm.getText());
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                        e.printStackTrace();
                    }
                }
            });
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;flag) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; connection)
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                    e.printStackTrace();
                }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JMS Topic模型代码实现：&lt;/p&gt;
&lt;p&gt;将上述代码中出现的queueDestination改为topicDestination即可。&lt;/p&gt;

&lt;h2&gt;5、ActiveMQ的特性&lt;/h2&gt;
&lt;hr/&gt;&lt;h3&gt;　5.1 ActiveMq 的特性　&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP&lt;/li&gt;
&lt;li&gt;完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)&lt;/li&gt;
&lt;li&gt;对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性&lt;/li&gt;
&lt;li&gt;通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上&lt;/li&gt;
&lt;li&gt;支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA&lt;/li&gt;
&lt;li&gt;支持通过JDBC和journal提供高速的消息持久化&lt;/li&gt;
&lt;li&gt;从设计上保证了高性能的集群,客户端-服务器,点对点&lt;/li&gt;
&lt;li&gt;支持Ajax&lt;/li&gt;
&lt;li&gt;支持与Axis的整合&lt;/li&gt;
&lt;li&gt;可以很容易得调用内嵌JMS provider,进行测试&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;　&lt;/h3&gt;
&lt;h3&gt;　5.2 什么情况下使用ActiveMQ?&lt;/h3&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;多个项目之间集成 &lt;br/&gt;(1) 跨平台 &lt;br/&gt;(2) 多语言 &lt;br/&gt;(3) 多项目&lt;/li&gt;
&lt;li&gt;降低系统间模块的耦合度，解耦 &lt;br/&gt;(1) 软件扩展性&lt;/li&gt;
&lt;li&gt;系统前后端隔离 &lt;br/&gt;(1) 前后端隔离，屏蔽高安全区&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 01 Apr 2018 14:31:00 +0000</pubDate>
<dc:creator>渡劫红尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunTin/p/8546954.html</dc:identifier>
</item>
<item>
<title>RabbitMQ封装实战 - 少年天团</title>
<link>http://www.cnblogs.com/1024Community/p/8688753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1024Community/p/8688753.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;先说下背景：上周开始给项目添加曾经没有过的消息中间件。虽然说，一路到头非常容易，直接google，万事不愁~可是生活远不仅是眼前的“苟且”。首先是想使用其他项目使用过的一套对mq封装的框架，融合进来。虽然折腾了上周六周日两天，总算吧老框架融进项目中了，可是周一来公司和大数据哥们儿一联调发现，收不到数据！所以没办法，当场使用原生那一套撸了个版本出来~可是，可是，可是，俗话说得好：生命在于折腾！在上周末融合老框架的时候，我把源码读了遍，发现了很多很好的封装思想，Ok，这周末总算闲了下来，我就运用这个思想，封装一个轻量级的呗，说干就干！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;主要思想&quot;&gt;主要思想&lt;/h2&gt;
&lt;p&gt;说到封装，我想，应该主要是要尽可能减小用户使用的复杂度，尽量少的进行配置，书写，甚至能尽量少的引入第三发或是原生类库。所以在这种想法之下，这套框架的精髓主要在以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用注解，减少用户配置&lt;/li&gt;
&lt;li&gt;将不同的生产者消费者的初始化方式统一&lt;/li&gt;
&lt;li&gt;初次注册生产者或者消费者的时候，进行队列的自动注册&lt;/li&gt;
&lt;li&gt;再统一的初始化方式中，使用动态代理的方式，代理到具体的生产者或是消费者的发送接收方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这种模式下，我们不用过多的配置，直接建立一个接口，接口上面使用注解声明队列的名称，然后使用同一的Bean进行初始化，就齐活了！&lt;/p&gt;
&lt;h2 id=&quot;统一初始化bean的实现&quot;&gt;统一初始化Bean的实现&lt;/h2&gt;
&lt;p&gt;不说啥，直接上代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;29&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RabbitMQProducerFactoryBean&amp;lt;T&amp;gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; RabbitMQProducerInterceptor &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; FactoryBean&amp;lt;T&amp;gt; {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Logger logger = LoggerFactory.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;());

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Class&amp;lt;?&amp;gt; serviceInterface;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ConnectionFactory rabbitConnectionFactory;

    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${mq.queue.durable}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String durable;

    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${mq.queue.exclusive}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String exclusive;

    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${mq.queue.autoDelete}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String autoDelete;

    &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    这个方法很特殊，继承自FactoryBean，就是说管理权归属IoC容器。每次注册一个队列的时候，并且注入到具体的service中使用的时候，就会调用这个getObject方法。所以，对于使用本类初始化的bean，其类型并非本类，而是本类的属性serviceInterface类型，因为最终getObject的结果是返回了一个动态代理，代理到了serviceInterface。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    **/&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;fu&quot;&gt;getObject&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {

        &lt;span class=&quot;co&quot;&gt;//初始化&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;getQueueName&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;指定的目标列队名[{}]，覆盖接口定义。&quot;&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;getQueueName&lt;/span&gt;());
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            RPCQueueName name = serviceInterface.&lt;span class=&quot;fu&quot;&gt;getAnnotation&lt;/span&gt;(RPCQueueName.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (name == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;接口&quot;&lt;/span&gt; + serviceInterface.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;没有指定@RPCQueueName&quot;&lt;/span&gt;);
            &lt;span class=&quot;fu&quot;&gt;setQueueName&lt;/span&gt;(name.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;());
        }
        &lt;span class=&quot;co&quot;&gt;//创建队列&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;declareQueue&lt;/span&gt;();
        logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;建立MQ客户端代理接口[{}]，目标队列[{}]。&quot;&lt;/span&gt;, serviceInterface.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;(), &lt;span class=&quot;fu&quot;&gt;getQueueName&lt;/span&gt;());

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (T) Proxy.&lt;span class=&quot;fu&quot;&gt;newProxyInstance&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[]{serviceInterface}, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//动态代理到目标接口&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;declareQueue&lt;/span&gt;() {
        Connection connection = rabbitConnectionFactory.&lt;span class=&quot;fu&quot;&gt;createConnection&lt;/span&gt;();
        Channel channel = connection.&lt;span class=&quot;fu&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            channel.&lt;span class=&quot;fu&quot;&gt;queueDeclare&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getQueueName&lt;/span&gt;(), Boolean.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(durable), Boolean.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(exclusive)
                    , Boolean.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(autoDelete), &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;注册队列成功！&quot;&lt;/span&gt;);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            logger.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;队列注册失败&quot;&lt;/span&gt;, e);
        }
    }
......

}


&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RabbitMQProducerInterceptor &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; InvocationHandler {



    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Logger logger = LoggerFactory.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;());


    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String queueName;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; AmqpTemplate amqpTemplate;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {
        Object sendObj;
        Class&amp;lt;?&amp;gt;[] parameterTypes = method.&lt;span class=&quot;fu&quot;&gt;getParameterTypes&lt;/span&gt;();
        String methodName = method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isSendOneJson = Objects.&lt;span class=&quot;fu&quot;&gt;nonNull&lt;/span&gt;(args) &amp;amp;&amp;amp; args.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; (args[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; String);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isSendOneJson) {
            sendObj = args[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;];
            logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;发送单一json字符串消息：{}&quot;&lt;/span&gt;, (String) sendObj);
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            sendObj = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RemoteInvocation&lt;/span&gt;(methodName, parameterTypes, args);
            logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;发送封装消息体：{}&quot;&lt;/span&gt;, JSONSerializeUtil.&lt;span class=&quot;fu&quot;&gt;jsonSerializerNoType&lt;/span&gt;(sendObj));
        }


        logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;发送异步消息到[{}]，方法名为[{}]&quot;&lt;/span&gt;, queueName, method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
        &lt;span class=&quot;co&quot;&gt;//异步方式使用，同时要告知服务端不要发送响应&lt;/span&gt;
        amqpTemplate.&lt;span class=&quot;fu&quot;&gt;convertAndSend&lt;/span&gt;(queueName, sendObj);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    }

    ......
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是核心的配置文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; default-lazy-init=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:p=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:rabbit=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/rabbit&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:task=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/task&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.1.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;        http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.1.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;rabbit:connection-factory&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rabbitConnectionFactory&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        host=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${mq.host}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; port=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${mq.port}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; virtual-host=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${mq.vhost}&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        username=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${mq.username}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; password=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${mq.password}&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 供自动创建队列 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;rabbit:admin&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; connection-factory=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rabbitConnectionFactory&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;rabbit:template&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;amqpTemplate&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; connection-factory=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rabbitConnectionFactory&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 创建生产者 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;sendMsg&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.example.demo.RabbitMQProducerFactoryBean&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;serviceInterface&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.example.demo.ISendMsg&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：每次要使用mq，直接导入这个基本配置，和基础jar包即可。对于配置文件中的生产者声明，已经直接简化到三行，这一部分可以单独创建一个类似于producer-config.xml专门的配置文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;附属类&quot;&gt;附属类&lt;/h2&gt;
&lt;p&gt;这里主要就是涉及一个注解类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.&lt;span class=&quot;fu&quot;&gt;RUNTIME&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;@Target&lt;/span&gt;(ElementType.&lt;span class=&quot;fu&quot;&gt;TYPE&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;@interface&lt;/span&gt; RPCQueueName {

    String &lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：主要用于队列名称的声明。可以拓展的再建立其他的注解类，并在RabbitMQProducerFactoryBean中进行具体的逻辑实现。对于未来功能添加，起到了非常好的解耦效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的接口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@RPCQueueName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;test.demo.ISendMsg&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; ISendMsg {

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sendMsg&lt;/span&gt;(String msg);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：这样，就声明了个队列名叫test.demo.ISendMsg的生产者，每次讲IsendMsg注入到要发送消息的Service里面，直接调用sendMsg即可向注解声明的队列发送消息了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;恩开源&quot;&gt;恩，开源&lt;/h2&gt;
&lt;p&gt;写了个springboot的小demo：&lt;br/&gt;&lt;a href=&quot;https://github.com/JCAndWHTForPro/RabbitMQWrapper.git&quot;&gt;github地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来我会更新消费者的封装，今天先放一放，出去动动。。哈哈&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 14:31:00 +0000</pubDate>
<dc:creator>少年天团</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1024Community/p/8688753.html</dc:identifier>
</item>
<item>
<title>New UWP Community Toolkit - RadialProgressBar - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/8678690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/8678690.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;UWP Community Toolkit  中有一个圆形的进度条控件 - RadialProgressBar，本篇我们结合代码详细讲解  RadialProgressBar 的实现。&lt;/p&gt;
&lt;p&gt;RadialProgressBar 是一种圆形的进度条控件，进度值用圆形中的填充色的角度来表示，进度增长，填充色按照顺时针方向增加，直到占满整个圆形，则进度条达到最大值。我们来看一下官方的介绍和官网示例中的展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331173907868-931379017.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/Microsoft/UWPCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/RadialProgressBar&quot; target=&quot;_blank&quot;&gt;https://github.com/Microsoft/UWPCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/RadialProgressBar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Doc:&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/uwpcommunitytoolkit/controls/radialprogressbar&quot; target=&quot;_blank&quot;&gt; https://docs.microsoft.com/zh-cn/windows/uwpcommunitytoolkit/controls/radialprogressbar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Namespace: &lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/em&gt;; Nuget: &lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开发过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下 RadialProgressBar 控件的结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RadialProgressBar.cs - RadialProgressBar 控件定义类&lt;/li&gt;
&lt;li&gt;RadialProgressBar.xaml - RadialProgressBar 控件样式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331205309627-1767670811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. RadialProgressBar.xaml&lt;/p&gt;
&lt;p&gt;这是 RadialProgressBar 控件的样式，我们可以看到 Template 部分由 OutlineFigurePart 和 BarFigurePart 组成，分别代表了进度条的灰色底和实际的进度条，因为两个部分的样式基本一致，所以我们省略了一部分。&lt;/p&gt;
&lt;p&gt;可以看到，两个部分的样式组成，都是一个 Path 的几何图形，里面包含了 ParhFigure，它的 segment 属性包含了 ArcSegment：一个弧度区段；这就是样式的基本组成了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:RadialProgressBar&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Foreground&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ThemeResource SystemControlHighlightAccentBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Outline&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ThemeResource SystemControlBackgroundBaseLowBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Background&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Thickness&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:RadialProgressBar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Background}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; OutlineFigurePart of progress bar &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path &lt;/span&gt;&lt;span&gt;Fill&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt; Stroke&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Outline}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; StrokeThickness&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Thickness}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; StrokeDashCap&lt;/span&gt;&lt;span&gt;=&quot;Flat&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path.Data&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathGeometry.Figures&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathFigureCollection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathFigure &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;OutlineFigurePart&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathFigure.Segments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathSegmentCollection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ArcSegment &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;OutlineArcPart&quot;&lt;/span&gt;&lt;span&gt; IsLargeArc&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; SweepDirection&lt;/span&gt;&lt;span&gt;=&quot;Clockwise&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathSegmentCollection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathFigure.Segments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathFigure&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathFigureCollection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathGeometry.Figures&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Path.Data&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; BarFigurePart of Progress Bar &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
                ...
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. RadialProgressBar.cs&lt;/p&gt;
&lt;p&gt;看一下这个类的构成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201804/306530-20180401141212765-1522785062.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;RadialProgressBar 类继承自 ProgressBar 类，表现形式为圆形的进度条，分为 outline 和 bar 两个部分，所以可以看到类中定义了 outlineFigure、barFigure、outlineArc 和 barArc 属性；而依赖属性有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Thickness - 表示圆形进度条的圆环大小，默认为 0，xaml 中定义为 4&lt;/li&gt;
&lt;li&gt;Outline - 表示圆形底的画刷，默认为 transparent，xaml 中定义为 gray&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而继承自 ProgressBar 的 Background 和 Foreground，则分别表示进度条中间空白部分的颜色，和进度条的进度颜色。因为继承自 ProgressBar 类，所以重载了 Progress 类的几个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OnMinimumChanged(old, new) - 进度条最小值变化的处理方法，会触发 RenderSegment() 方法；&lt;/li&gt;
&lt;li&gt;OnMaximumChanged(old, new) - 进度条最大值变化的处理方法，会触发 RenderSegment() 方法；&lt;/li&gt;
&lt;li&gt;OnValueChanged(old, new) - 进度条进度值变化的处理方法，会触发 RenderSegment() 方法；&lt;/li&gt;
&lt;li&gt;OnApplyTemplate() - 应用模板或哦模板改变时，更新控件的视觉显示 ，会触发 RenderAll() 方法；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有两个 Changed 处理方法：ThicknessChangedHandler(d, e) 和 SizeChangedHandler(s, e)，分别处理进度条宽度变化和进度条尺寸变化，也会触发  RenderAll() 方法；&lt;/p&gt;
&lt;p&gt;下面来看看几个主要的方法：&lt;/p&gt;
&lt;p&gt;① ComputeNormalizedRange()&lt;/p&gt;
&lt;p&gt;根据进度条的最大值和最小值计算出的区间，以及当前值，计算出当前值在区间中占的百分比，如果当前值 &amp;gt; 0.999, 则取值 0.999&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; ComputeNormalizedRange()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; range = Maximum -&lt;span&gt; Minimum;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; delta = Value -&lt;span&gt; Minimum;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; output = range == &lt;span&gt;0.0&lt;/span&gt; ? &lt;span&gt;0.0&lt;/span&gt; : delta /&lt;span&gt; range;
    output &lt;/span&gt;= Math.Min(Math.Max(&lt;span&gt;0.0&lt;/span&gt;, output), &lt;span&gt;0.9999&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② ComputeEllipseSize()&lt;/p&gt;
&lt;p&gt;计算圆形的尺寸，根据进度条的实际宽度和高度，去掉安全宽度，计算后值的 1/2 就是 Ellipse 的长短半径；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Size ComputeEllipseSize()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; safeThickness = Math.Max(Thickness, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; width = Math.Max((ActualWidth - safeThickness) / &lt;span&gt;2.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; height = Math.Max((ActualHeight - safeThickness) / &lt;span&gt;2.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(width, height);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ RenderSegment()&lt;/p&gt;
&lt;p&gt;弧形区段的实际渲染，根据当前角度，尺寸和圆环宽度，计算出当前弧形的终点坐标；同时输出一个值：IsLargeArc，角度是否 &amp;gt;= 180 度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RenderSegment()
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;allTemplatePartsDefined)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; normalizedRange =&lt;span&gt; ComputeNormalizedRange();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; angle = &lt;span&gt;2&lt;/span&gt; * Math.PI *&lt;span&gt; normalizedRange;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; size =&lt;span&gt; ComputeEllipseSize();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; translationFactor = Math.Max(Thickness / &lt;span&gt;2.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x = (Math.Sin(angle) * size.Width) + size.Width +&lt;span&gt; translationFactor;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; y = (((Math.Cos(angle) * size.Height) - size.Height) * -&lt;span&gt;1&lt;/span&gt;) +&lt;span&gt; translationFactor;

    barArc.IsLargeArc &lt;/span&gt;= angle &amp;gt;=&lt;span&gt; Math.PI;
    barArc.Point &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point(x, y);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ RenderAll()&lt;/p&gt;
&lt;p&gt;渲染进度条的全部控件部分，计算 outlineFigure 和 barFigure 的起始点，new Point(segmentWidth + translationFactor, translationFactor) 也就是圆形最上方的横向中心点；然后计算 outlineArc 和 barArc 的尺寸，也就是圆形半径；outlineArc 的角度固定，所以只需要给一个初始值，最后是调用 RenderSegment() 方法计算 Bar 的实际渲染部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RenderAll()
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;allTemplatePartsDefined)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; size =&lt;span&gt; ComputeEllipseSize();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; segmentWidth =&lt;span&gt; size.Width;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; translationFactor = Math.Max(Thickness / &lt;span&gt;2.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);

    outlineFigure.StartPoint &lt;/span&gt;= barFigure.StartPoint = &lt;span&gt;new&lt;/span&gt; Point(segmentWidth +&lt;span&gt; translationFactor, translationFactor);
    outlineArc.Size &lt;/span&gt;= barArc.Size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(segmentWidth, size.Height);
    outlineArc.Point &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(segmentWidth + translationFactor - &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;, translationFactor);

    RenderSegment();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;调用示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们定义了一个 RadialProgressBar 控件，底色是浅灰色，进度颜色是绿色，区间是 0~100，当前值是 29，进度条宽度是 20；从示例的运行图中可以印证这些数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:RadialProgressBar
            &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;RadialProgressBarControl&quot;&lt;/span&gt;&lt;span&gt;
            Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
            Value&lt;/span&gt;&lt;span&gt;=&quot;29&quot;&lt;/span&gt;&lt;span&gt;
            Foreground&lt;/span&gt;&lt;span&gt;=&quot;Green&quot;&lt;/span&gt;&lt;span&gt;
            Thickness&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt;
            Minimum&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
            Maximum&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;
            Width&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;
            Height&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;
            Outline&lt;/span&gt;&lt;span&gt;=&quot;LightGray&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331174123294-1818847016.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里我们就把 UWP Community Toolkit 中的 RadialProgressBar 控件的源代码实现过程和简单的调用示例讲解完成了，希望能对大家更好的理解和使用这个控件有所帮助；大家也可以基于简单的圆形进度条，扩展出更多中不同形状的进度条，例如矩形，实心圆形等等，欢迎大家多多交流，谢谢！&lt;/p&gt;
&lt;p&gt;最后，再跟大家安利一下 UWPCommunityToolkit 的官方微博：&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://weibo.com/u/6506046490&quot; target=&quot;_blank&quot;&gt;https://weibo.com/u/6506046490&lt;/a&gt;, &lt;/strong&gt;&lt;/em&gt;大家可以通过微博关注最新动态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衷心感谢 UWPCommunityToolkit 的作者们杰出的工作，Thank you so much, UWPCommunityToolkit authors!!!&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 14:07:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/8678690.html</dc:identifier>
</item>
<item>
<title>Oracle之SQL优化专题01-查看SQL执行计划的方法 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/8688464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/8688464.html</guid>
<description>&lt;p&gt;在我2014年总结的“&lt;a href=&quot;http://www.cnblogs.com/jyzhao/category/581265.html&quot;&gt;SQL Tuning 基础概述&lt;/a&gt;”中，其实已经介绍了一些查看SQL执行计划的方法，但是不够系统和全面，所以本次SQL优化专题，就首先要系统的介绍一下查看SQL执行计划的方法。&lt;br/&gt;本文示例SQL为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--set lines 1000 pages 1000
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;通过explain plan for命令查看SQL的执行计划，这种方法SQL并不真实执行，一般适用于&lt;span&gt;上线前的SQL预审，尤其对DML语句，由于SQL不执行，不用担心对生产数据造成影响&lt;/span&gt;。这种方法查看的执行计划&lt;span&gt;有Predicate Information，无Statistics，查看到的执行计划不一定真实&lt;/span&gt;，第三方工具PL/SQL Developer中F5查看执行计划也是调用的这个方法。&lt;br/&gt;使用explain plan for命令查看SQL的执行计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;explain plan for 
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

select * from table(dbms_xplan.display);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JINGYU@jyzhao1 &amp;gt;explain plan for 
  2  select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

Explained.

Elapsed: 00:00:00.01
JINGYU@jyzhao1 &amp;gt;select * from table(dbms_xplan.display);

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Plan hash value: 1123238657

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |     1 |    74 |     6   (0)| 00:00:01 |
|*  1 |  HASH JOIN         |      |     1 |    74 |     6   (0)| 00:00:01 |
|*  2 |   TABLE ACCESS FULL| EMP  |     1 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    88 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)
   2 - filter(&quot;EMPNO&quot;=7788)

Note
-----
   - dynamic sampling used for this statement (level=2)

20 rows selected.

Elapsed: 00:00:00.03
JINGYU@jyzhao1 &amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;通过set autotrace查看SQL的执行计划，这种方法SQL真实执行（除set autot trace exp针对select语句也不执行，但对DML语句还是会执行的），这种方法查看的执行计划&lt;span&gt;有Predicate Information，有Statistics，查看的执行计划是准确的&lt;/span&gt;。但由于SQL需要真实执行，所以对于有绑定变量值的SQL，还需要输入对应的变量值才可以执行，比较麻烦。&lt;br/&gt;使用set autotrace查看SQL的执行计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set autotrace on
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;
set autotrace off&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JINGYU@jyzhao1 &amp;gt;set autotrace on
JINGYU@jyzhao1 &amp;gt;select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

     EMPNO ENAME      DNAME          JOB              SAL
---------- ---------- -------------- --------- ----------
      7788 SCOTT      RESEARCH       ANALYST         3000

Elapsed: 00:00:00.01

Execution Plan
----------------------------------------------------------
Plan hash value: 1123238657

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |     1 |    74 |     6   (0)| 00:00:01 |
|*  1 |  HASH JOIN         |      |     1 |    74 |     6   (0)| 00:00:01 |
|*  2 |   TABLE ACCESS FULL| EMP  |     1 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    88 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)
   2 - filter(&quot;EMPNO&quot;=7788)

Note
-----
   - dynamic sampling used for this statement (level=2)


Statistics
----------------------------------------------------------
          7  recursive calls
          0  db block gets
         15  consistent gets
          0  physical reads
          0  redo size
        814  bytes sent via SQL*Net to client
        520  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed

JINGYU@jyzhao1 &amp;gt;set autotrace off
JINGYU@jyzhao1 &amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;dbms_xplan下面有很多函数可以调用，其中最常用的是display_cursor和display_awr函数，下面依次介绍。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.1&quot;&gt;3.1 dbms_xplan.display_cursor(null,null,'allstats last')&lt;/h2&gt;
&lt;br/&gt;通过dbms_xplan.display_cursor(null,null,'allstats last')查看SQL的执行计划，SQL会真实执行（对应的缺点不再赘述），这种方法查看的执行计划&lt;span&gt;有Predicate Information，无Statistics，查看的执行计划是准确的，并且有每一步真实处理行数和时间&lt;/span&gt;。&lt;br/&gt;使用dbms_xplan.display_cursor(null,null,'allstats last')查看SQL的执行计划：
&lt;pre&gt;
&lt;code&gt;--需要确认statistics_level设置为ALL，否则SQL语句第一个关键字后就需要加上/*+ gather_plan_statistics */，我习惯用前者
show parameter statistics_level（一般数据库默认是TYPICAL）
alter session set statistics_level = ALL;
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;
select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JINGYU@jyzhao1 &amp;gt;alter session set statistics_level = ALL;

Session altered.

JINGYU@jyzhao1 &amp;gt;select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

     EMPNO ENAME      DNAME          JOB              SAL
---------- ---------- -------------- --------- ----------
      7788 SCOTT      RESEARCH       ANALYST         3000

JINGYU@jyzhao1 &amp;gt;select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL_ID  39dv3d8jkzyuw, child number 1
-------------------------------------
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where
a.deptno = b.deptno and empno = 7788

Plan hash value: 1123238657

----------------------------------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |        |      1 |00:00:00.01 |       7 |       |       |          |
|*  1 |  HASH JOIN         |      |      1 |      1 |      1 |00:00:00.01 |       7 |  1214K|  1214K|  762K (0)|
|*  2 |   TABLE ACCESS FULL| EMP  |      1 |      1 |      1 |00:00:00.01 |       3 |       |       |          |
|   3 |   TABLE ACCESS FULL| DEPT |      1 |      4 |      4 |00:00:00.01 |       4 |       |       |          |
----------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)
   2 - filter(&quot;EMPNO&quot;=7788)

Note
-----
   - dynamic sampling used for this statement (level=2)


26 rows selected.

JINGYU@jyzhao1 &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3.2&quot;&gt;3.2 dbms_xplan.display_cursor('&amp;amp;sql_id',null,'advanced')&lt;/h2&gt;
&lt;p&gt;通过dbms_xplan.display_cursor('&amp;amp;sql_id',null,'advanced')查看SQL的执行计划，这种方法查看的执行计划&lt;span&gt;有Predicate Information，无Statistics，SQL是数据库中之前真实执行过的，对应执行计划是之前SQL真实执行过的执行计划，是准确的。使用这种方法的前提是需要SQL的cursor没有被刷出shared pool，否则查不到结果&lt;/span&gt;。&lt;br/&gt;使用dbms_xplan.display_cursor('&amp;amp;sql_id',null,'advanced')查看SQL的执行计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--查询sql_id
select sql_id, sql_text from v$sql where sql_text like 'select a.empno%';
39dv3d8jkzyuw
--根据查询的sql_id查看执行计划
select * from table(dbms_xplan.display_cursor('&amp;amp;sql_id',null,'advanced'));
--附：函数DISPLAY_CURSOR的参数说明
FUNCTION DISPLAY_CURSOR RETURNS DBMS_XPLAN_TYPE_TABLE
 Argument Name                  Type                    In/Out Default?
 ------------------------------ ----------------------- ------ --------
 SQL_ID                         VARCHAR2                IN     DEFAULT
 CURSOR_CHILD_NO                NUMBER(38)              IN     DEFAULT
 FORMAT                         VARCHAR2                IN     DEFAULT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JINGYU@jyzhao1 &amp;gt;select * from table(dbms_xplan.display_cursor('&amp;amp;sql_id',null,'advanced'));
Enter value for sql_id: 39dv3d8jkzyuw
old   1: select * from table(dbms_xplan.display_cursor('&amp;amp;sql_id',null,'advanced'))
new   1: select * from table(dbms_xplan.display_cursor('39dv3d8jkzyuw',null,'advanced'))

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL_ID  39dv3d8jkzyuw, child number 0
-------------------------------------
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where
a.deptno = b.deptno and empno = 7788

Plan hash value: 1123238657

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |       |       |     6 (100)|          |
|*  1 |  HASH JOIN         |      |     1 |    74 |     6   (0)| 00:00:01 |
|*  2 |   TABLE ACCESS FULL| EMP  |     1 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    88 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

Query Block Name / Object Alias (identified by operation id):
-------------------------------------------------------------

   1 - SEL$1
   2 - SEL$1 / A@SEL$1
   3 - SEL$1 / B@SEL$1

Outline Data
-------------

  /*+
      BEGIN_OUTLINE_DATA
      IGNORE_OPTIM_EMBEDDED_HINTS
      OPTIMIZER_FEATURES_ENABLE('11.2.0.4')
      DB_VERSION('11.2.0.4')
      ALL_ROWS
      OUTLINE_LEAF(@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      LEADING(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      USE_HASH(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      END_OUTLINE_DATA
  */

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)
   2 - filter(&quot;EMPNO&quot;=7788)

Column Projection Information (identified by operation id):
-----------------------------------------------------------

   1 - (#keys=1) &quot;EMPNO&quot;[NUMBER,22], &quot;A&quot;.&quot;ENAME&quot;[VARCHAR2,10],
       &quot;A&quot;.&quot;JOB&quot;[VARCHAR2,9], &quot;A&quot;.&quot;SAL&quot;[NUMBER,22], &quot;B&quot;.&quot;DNAME&quot;[VARCHAR2,14]
   2 - &quot;EMPNO&quot;[NUMBER,22], &quot;A&quot;.&quot;ENAME&quot;[VARCHAR2,10],
       &quot;A&quot;.&quot;JOB&quot;[VARCHAR2,9], &quot;A&quot;.&quot;SAL&quot;[NUMBER,22], &quot;A&quot;.&quot;DEPTNO&quot;[NUMBER,22]
   3 - &quot;B&quot;.&quot;DEPTNO&quot;[NUMBER,22], &quot;B&quot;.&quot;DNAME&quot;[VARCHAR2,14]

Note
-----
   - dynamic sampling used for this statement (level=2)

SQL_ID  39dv3d8jkzyuw, child number 1
-------------------------------------
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where
a.deptno = b.deptno and empno = 7788

Plan hash value: 1123238657

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |       |       |     6 (100)|          |
|*  1 |  HASH JOIN         |      |     1 |    74 |     6   (0)| 00:00:01 |
|*  2 |   TABLE ACCESS FULL| EMP  |     1 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    88 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

Query Block Name / Object Alias (identified by operation id):
-------------------------------------------------------------

   1 - SEL$1
   2 - SEL$1 / A@SEL$1
   3 - SEL$1 / B@SEL$1

Outline Data
-------------

  /*+
      BEGIN_OUTLINE_DATA
      IGNORE_OPTIM_EMBEDDED_HINTS
      OPTIMIZER_FEATURES_ENABLE('11.2.0.4')
      DB_VERSION('11.2.0.4')
      ALL_ROWS
      OUTLINE_LEAF(@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      LEADING(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      USE_HASH(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      END_OUTLINE_DATA
  */

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)
   2 - filter(&quot;EMPNO&quot;=7788)

Column Projection Information (identified by operation id):
-----------------------------------------------------------

   1 - (#keys=1) &quot;EMPNO&quot;[NUMBER,22], &quot;A&quot;.&quot;ENAME&quot;[VARCHAR2,10],
       &quot;A&quot;.&quot;JOB&quot;[VARCHAR2,9], &quot;A&quot;.&quot;SAL&quot;[NUMBER,22], &quot;B&quot;.&quot;DNAME&quot;[VARCHAR2,14]
   2 - &quot;EMPNO&quot;[NUMBER,22], &quot;A&quot;.&quot;ENAME&quot;[VARCHAR2,10],
       &quot;A&quot;.&quot;JOB&quot;[VARCHAR2,9], &quot;A&quot;.&quot;SAL&quot;[NUMBER,22], &quot;A&quot;.&quot;DEPTNO&quot;[NUMBER,22]
   3 - &quot;B&quot;.&quot;DEPTNO&quot;[NUMBER,22], &quot;B&quot;.&quot;DNAME&quot;[VARCHAR2,14]

Note
-----
   - dynamic sampling used for this statement (level=2)

SQL_ID  39dv3d8jkzyuw, child number 2
-------------------------------------
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where
a.deptno = b.deptno and empno = 7788

Plan hash value: 1123238657

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |       |       |     6 (100)|          |
|*  1 |  HASH JOIN         |      |     1 |    74 |     6   (0)| 00:00:01 |
|*  2 |   TABLE ACCESS FULL| EMP  |     1 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    88 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

Query Block Name / Object Alias (identified by operation id):
-------------------------------------------------------------

   1 - SEL$1
   2 - SEL$1 / A@SEL$1
   3 - SEL$1 / B@SEL$1

Outline Data
-------------

  /*+
      BEGIN_OUTLINE_DATA
      IGNORE_OPTIM_EMBEDDED_HINTS
      OPTIMIZER_FEATURES_ENABLE('11.2.0.4')
      DB_VERSION('11.2.0.4')
      ALL_ROWS
      OUTLINE_LEAF(@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      LEADING(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      USE_HASH(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      END_OUTLINE_DATA
  */

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)
   2 - filter(&quot;EMPNO&quot;=7788)

Column Projection Information (identified by operation id):
-----------------------------------------------------------

   1 - (#keys=1) &quot;EMPNO&quot;[NUMBER,22], &quot;A&quot;.&quot;ENAME&quot;[VARCHAR2,10],
       &quot;A&quot;.&quot;JOB&quot;[VARCHAR2,9], &quot;A&quot;.&quot;SAL&quot;[NUMBER,22], &quot;B&quot;.&quot;DNAME&quot;[VARCHAR2,14]
   2 - &quot;EMPNO&quot;[NUMBER,22], &quot;A&quot;.&quot;ENAME&quot;[VARCHAR2,10],
       &quot;A&quot;.&quot;JOB&quot;[VARCHAR2,9], &quot;A&quot;.&quot;SAL&quot;[NUMBER,22], &quot;A&quot;.&quot;DEPTNO&quot;[NUMBER,22]
   3 - &quot;B&quot;.&quot;DEPTNO&quot;[NUMBER,22], &quot;B&quot;.&quot;DNAME&quot;[VARCHAR2,14]

Note
-----
   - dynamic sampling used for this statement (level=2)


177 rows selected.

JINGYU@jyzhao1 &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于上面没有指定CURSOR_CHILD_NO，所以全部都会显示出来，当然也可以指定某个CURSOR_CHILD_NO，比如说：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from table(dbms_xplan.display_cursor('&amp;amp;sql_id',0,'advanced'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样结果就只会显示CURSOR_CHILD_NO=0的执行计划。&lt;/p&gt;
&lt;h2 id=&quot;3.3&quot;&gt;3.3 dbms_xplan.display_awr('&amp;amp;sql_id')&lt;/h2&gt;
&lt;p&gt;通过dbms_xplan.display_awr('&amp;amp;sql_id')查看SQL的执行计划，这种方法查看的执行计划&lt;span&gt;无Predicate Information，无Statistics，查看的执行计划是准确的。如果对应SQL没有被抓取到AWR中，就查不到结果。&lt;/span&gt;&lt;br/&gt;使用dbms_xplan.display_awr('&amp;amp;sql_id')查看SQL的执行计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--查询sql_id
39dv3d8jkzyuw
--根据查询的sql_id查看执行计划
select * from table(dbms_xplan.display_awr('&amp;amp;sql_id'));
--附：函数DISPLAY_AWR的参数说明
FUNCTION DISPLAY_AWR RETURNS DBMS_XPLAN_TYPE_TABLE
 Argument Name                  Type                    In/Out Default?
 ------------------------------ ----------------------- ------ --------
 SQL_ID                         VARCHAR2                IN
 PLAN_HASH_VALUE                NUMBER(38)              IN     DEFAULT
 DB_ID                          NUMBER(38)              IN     DEFAULT
 FORMAT                         VARCHAR2                IN     DEFAULT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JINGYU@jyzhao1 &amp;gt;select * from table(dbms_xplan.display_awr('&amp;amp;sql_id'));
Enter value for sql_id: 39dv3d8jkzyuw

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------
SQL_ID 39dv3d8jkzyuw
--------------------
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where
a.deptno = b.deptno and empno = 7788

Plan hash value: 1123238657

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |       |       |     6 (100)|          |
|   1 |  HASH JOIN         |      |     1 |    74 |     6   (0)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| EMP  |     1 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    88 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

Note
-----
   - dynamic sampling used for this statement (level=2)


20 rows selected.

JINGYU@jyzhao1 &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以加参数显示更多的信息，比如&lt;span&gt;可以显示出Outline Data，但没有Predicate Information，没有Statistics：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JINGYU@jyzhao1 &amp;gt;select * from table(dbms_xplan.display_awr('&amp;amp;sql_id',NULL,NULL,'advanced'));
Enter value for sql_id: 39dv3d8jkzyuw

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------
SQL_ID 39dv3d8jkzyuw
--------------------
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where
a.deptno = b.deptno and empno = 7788

Plan hash value: 1123238657

---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |       |       |     6 (100)|          |
|   1 |  HASH JOIN         |      |     1 |    74 |     6   (0)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| EMP  |     1 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    88 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

Query Block Name / Object Alias (identified by operation id):
-------------------------------------------------------------

   1 - SEL$1
   2 - SEL$1 / A@SEL$1
   3 - SEL$1 / B@SEL$1

Outline Data
-------------

  /*+
      BEGIN_OUTLINE_DATA
      IGNORE_OPTIM_EMBEDDED_HINTS
      OPTIMIZER_FEATURES_ENABLE('11.2.0.4')
      DB_VERSION('11.2.0.4')
      ALL_ROWS
      OUTLINE_LEAF(@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot;)
      FULL(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      LEADING(@&quot;SEL$1&quot; &quot;A&quot;@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      USE_HASH(@&quot;SEL$1&quot; &quot;B&quot;@&quot;SEL$1&quot;)
      END_OUTLINE_DATA
  */

Note
-----
   - dynamic sampling used for this statement (level=2)


44 rows selected.

JINGYU@jyzhao1 &amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;通过awrsqrpt查看SQL的执行计划，这种方式是导出SQL的awr报告，这种方法查看的执行计划&lt;span&gt;无Predicate Information，但有Statistics，并且同时包含SQL单次和整体的统计信息，查看的执行计划是准确的&lt;/span&gt;。&lt;br/&gt;使用awrsqrpt查看SQL的执行计划：&lt;br/&gt;@?/rdbms/admin/awrsqrpt&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Specify the Begin and End Snapshot Ids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Enter value for begin_snap: 240
Begin Snapshot Id specified: 240

Enter value for end_snap: 244
End   Snapshot Id specified: 244



Specify the SQL Id
~~~~~~~~~~~~~~~~~~
Enter value for sql_id: 39dv3d8jkzyuw
SQL ID specified:  39dv3d8jkzyuw
...
Report written to awrsqlrpt_1_240_244.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种执行计划的显示结果如下图：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_awrsqrpt1.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过10046 event的跟踪文件查看SQL的执行计划，这种方法查看的&lt;span&gt;执行计划是准确的，语句中函数，递归调用都会被详细列出，但没有谓词信息&lt;/span&gt;，而且这种方法获取执行计划比较麻烦。&lt;br/&gt;使用10046 event查看SQL的执行计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter session set events '10046 trace name context forever, level 12';
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;
alter session set events '10046 trace name context off';
--使用tkprof美化10046 event的跟踪文件，使其更易读：
tkprof jyzhao1_ora_14139.trc jyzhao1_ora_14139.txt sys=no&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JINGYU@jyzhao1 &amp;gt;alter session set events '10046 trace name context forever, level 12';

Session altered.

JINGYU@jyzhao1 &amp;gt;select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

     EMPNO ENAME      DNAME          JOB              SAL
---------- ---------- -------------- --------- ----------
      7788 SCOTT      RESEARCH       ANALYST         3000

JINGYU@jyzhao1 &amp;gt;alter session set events '10046 trace name context off';

Session altered.

--使用tkprof美化10046 event的跟踪文件相关内容如下：

SQL ID: 39dv3d8jkzyuw Plan Hash: 1123238657

select a.empno, a.ename, b.dname, a.job, a.sal 
from
 emp a, dept b where a.deptno = b.deptno and empno = 7788


call     count       cpu    elapsed       disk      query    current        rows
------- ------  -------- ---------- ---------- ---------- ----------  ----------
Parse        1      0.01       0.02          0          8          0           0
Execute      1      0.00       0.00          0          0          0           0
Fetch        2      0.00       0.00          0          7          0           1
------- ------  -------- ---------- ---------- ---------- ----------  ----------
total        4      0.01       0.02          0         15          0           1

Misses in library cache during parse: 1
Optimizer mode: ALL_ROWS
Parsing user id: 91  
Number of plan statistics captured: 1

Rows (1st) Rows (avg) Rows (max)  Row Source Operation
---------- ---------- ----------  ---------------------------------------------------
         1          1          1  HASH JOIN  (cr=7 pr=0 pw=0 time=274 us cost=6 size=74 card=1)
         1          1          1   TABLE ACCESS FULL EMP (cr=3 pr=0 pw=0 time=67 us cost=3 size=52 card=1)
         4          4          4   TABLE ACCESS FULL DEPT (cr=4 pr=0 pw=0 time=15 us cost=3 size=88 card=4)


Elapsed times include waiting on following events:
  Event waited on                             Times   Max. Wait  Total Waited
  ----------------------------------------   Waited  ----------  ------------
  SQL*Net message to client                       2        0.00          0.00
  SQL*Net message from client                     2        6.55          6.56
********************************************************************************&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于阅读这个tkprof美化后文件的方法可以参考MOS文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TKProf Interpretation (9i and above) (文档 ID 760786.1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这个“Oracle之SQL优化专题”的系列，缘起是听了公司SQL优化专家团队的分享内容，自己想通过实际操作理解并逐渐测试完善，在我个人之前的职业生涯规划中一直都偏重于运维方向的DBA，对SQL优化方面了解的很少，兴趣也不高，是SQL优化专家团队的这次分享让我觉得SQL优化也是很有趣的，所以下决心从今天起单独开一个专题，自己也能逐渐系统的学习相关知识并记录下来。初步考虑该系列后续内容同时还会参考崔华的《基于Oracle的SQL优化》一书。最后感谢SQL优化专家团队的leader勇哥和其团队所有成员，是你们的这次分享让我有了做这个专题的动力。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 14:05:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/8688464.html</dc:identifier>
</item>
<item>
<title>C# 7.0 观察者模式 以及 delegate 和 event - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8688476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8688476.html</guid>
<description>&lt;p&gt;这里面综合了几本书的资料.&lt;/p&gt;
&lt;h2&gt;需求&lt;/h2&gt;
&lt;p&gt;有这么个项目: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401203740004-1203584697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需求是这样的:&lt;/p&gt;
&lt;p&gt;一个气象站, 有三个传感器(温度, 湿度, 气压), 有一个WeatherData对象, 它能从气象站获得这三个数据. 还有三种设备, 可以按要求展示气象站的最新数据.&lt;/p&gt;
&lt;p&gt;WeatherData的结构如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401203930241-1190747844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有3个get方法, 分别获取最新的气温, 湿度和气压. 还有一个measurementsChanged()方法, 当任一传感器有变化的时候, 这个方法都会被调用.&lt;/p&gt;
&lt;p&gt;总结一下项目的需求:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;WeatherData类有三个get方法可以获取温度, 湿度和气压&lt;/li&gt;
&lt;li&gt;如果任何一个数据发生变化, 那么measureChanged()方法就会被调用&lt;/li&gt;
&lt;li&gt;我们需要实现这三种显示设备:
&lt;ul&gt;&lt;li&gt;　　当前天气&lt;/li&gt;
&lt;li&gt;　　数据统计&lt;/li&gt;
&lt;li&gt;　　天气预测&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;系统必须可以扩展, 其他开发者可以创建自定义展示设备.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;初版代码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204146720-1703427220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个地方有个&quot;错误&quot;, xxxDisplay都是具体的实现, 而编程规则要求是应该对接口编程而不是对实现编程.&lt;/p&gt;
&lt;h2&gt;那么什么是观察者模式?&lt;/h2&gt;
&lt;p&gt;举一个例子:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;报社发行报纸&lt;/li&gt;
&lt;li&gt;你订阅报纸, 一旦有新一期的报纸发行, 新报纸就会送到你家里, 只要你一直订阅, 你就一直会收到新报纸&lt;/li&gt;
&lt;li&gt;你不再订阅报纸的时候, 就收不到以后的新报纸了&lt;/li&gt;
&lt;li&gt;报社运营的时候, 一直会有人去订阅或者取消订阅报纸.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;发布者 + 订阅者 = 观察者模式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;Publishers + Subscribers = Observer Pattern&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;在观察者模式里, 我们把报社叫做被观察对象(Subject), 把订阅者叫做观察者(Observers)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204344355-1708319448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察者模式是这样操作的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204426394-1152665935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204434649-1071681196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204441309-762973600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204449326-1312204933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204457505-833520201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204512083-1971829281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察者模式的定义就是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;类图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204542781-45584574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;谈一下松耦合&lt;/h2&gt;
&lt;p&gt;当两个对象是松耦合的时候, 他们可以进行交互, 但是却几乎不了解对方.&lt;br/&gt;观察者模式下的被观察者(Subject)和观察者(Observers)就是松耦合设计的对象. 这是因为:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;被观察者(Subject)只知道观察者实现了某个接口&lt;/li&gt;
&lt;li&gt;可以随时添加观察者&lt;/li&gt;
&lt;li&gt;添加新类型观察者的时候不需要修改被观察者&lt;/li&gt;
&lt;li&gt;可以复用观察者或者被观察者&lt;/li&gt;
&lt;li&gt;如果被观察者或观察者发生变化了, 那么这些变化不会影响到对方.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;一个设计原则:&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;交互的对象之间应尽量设计成松耦合的. Strive for loosely coupled designs between objects that interact.&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;松耦合设计可以让我们设计出这样的系统: 因为对象之间的相互依存减小了, 所以系统可以轻松处理变化&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;重新设计:&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204733386-127167757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204758366-1499844967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204808017-1911225199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401204813485-424992081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK, 上面是书中的内容, C#7.0里面对观察者模式是怎么实现的呢?&lt;/p&gt;
&lt;p&gt;先只谈下面这个:&lt;/p&gt;

&lt;p&gt;谈到Event, 就得把delegate先细说一下&lt;/p&gt;
&lt;h2&gt;Delegate 委托&lt;/h2&gt;
&lt;p&gt;一个委托类型定义了某种类型的方法(方法的返回类型和参数类型), 然后这个委托的实例可以调用这些方法.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Transformer (&lt;span&gt;int&lt;/span&gt; x);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个委托就和返回类型是int, 参数是一个int的方法兼容.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Square (&lt;span&gt;int&lt;/span&gt; x) { &lt;span&gt;return&lt;/span&gt; x *&lt;span&gt; x };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Square (&lt;span&gt;int&lt;/span&gt; x) =&amp;gt; x * x;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;把一个方法赋值给委托变量的时候就创建了一个委托的实例&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Transformer t = Square;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后就可以像方法一样进行调用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; answer = t(&lt;span&gt;3&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以说一个委托的实例就是调用者的委托: 调用者调用委托, 然后委托调用目标方法, 这样就把调用者和目标方法解耦了.&lt;/p&gt;
&lt;p&gt;其中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Transformer t =&lt;span&gt; Square;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是下面的简写&lt;/span&gt;
Transformer t = &lt;span&gt;new&lt;/span&gt; Transformer(Square);
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
t(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是下面的简写&lt;/span&gt;
t.Invoke(&lt;span&gt;3&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;多播委托&lt;/h2&gt;
&lt;p&gt;一个委托实例可以引用多个目标方法. 使用+=操作符.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SomeDelegate d =&lt;span&gt; Method1;
d &lt;/span&gt;+=&lt;span&gt; Method2;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二行相当于:&lt;/span&gt;
d = d + Method2;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用d的时候就会调用Method1和Method2两个方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;委托方法的调用顺序和它们被添加的顺序是一样的&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;使用-=操作符来移除目标方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
d -= Method1;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这时调用d后只会执行Method2了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意: 委托是不可变的 +=/-=实际上是创建了新的委托&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;多播委托返回类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果多播委托有返回值(非void), 那么调用者只会获得最后一个被调用方法的返回值&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;委托也可以使用泛型:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; T Transformer&amp;lt;T&amp;gt; (T arg);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Func 和 Action&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180401212856985-934958521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记住Func有返回值, Action没有就行.&lt;/p&gt;


&lt;p&gt;使用委托的时候, 通常会有两个角色出现: 广播者(被观察者)和订阅者(观察者) [观察者模式]&lt;/p&gt;
&lt;p&gt;广播者包含一个委托field, 广播者决定何时广播, 它通过调用委托进行广播.&lt;/p&gt;
&lt;p&gt;订阅者就是方法的目标接收者.订阅者可以决定何时开始和结束监听, 是通过在广播者的委托上使用+=和-=操作符来实现的.&lt;/p&gt;
&lt;p&gt;订阅者之间互相不了解, 不干扰.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;event就是为上述模型所存在的, 它只把上述模型所必须的功能从委托里暴露出来. 它的主要目的就是防止订阅者之间相互干扰&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;最简单声明event的方法就是在委托成员前面加上event关键字:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SomeChangedHandler(&lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; x);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Broadcaster
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;strong&gt;event&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; SomeChangedHandler handler;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Broadcaster类里面的代码, 可以把handler作为委托一样来用.&lt;/p&gt;
&lt;p&gt;在Broadcaster类外边, 只能对这个event执行+=和-=操作.&lt;/p&gt;

&lt;h2&gt;Event 模式/ 观察者模式&lt;/h2&gt;
&lt;p&gt;这种模式在.net core里首先需要EventArgs.&lt;/p&gt;
&lt;p&gt;EventArgs是一个基类, 它可以为event传递信息.&lt;/p&gt;
&lt;p&gt;可以创造它的子类来传递自定义参数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FallsIllEventArgs : EventArgs
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Address;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FallsIllEventArgs(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; address)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Address =&lt;span&gt; address;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后就需要给这个event定义一个委托了, 这有三条规则:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;返回类型必须是void&lt;/li&gt;
&lt;li&gt;需要有两个参数, 第一个是object, 第二个是EventArgs的子类. 第一个参数代表着广播者, 第二个参数包含额外的需要传递的信息.&lt;/li&gt;
&lt;li&gt;名称必须以EventHandler结束.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.net core定义了System.EventHandler&amp;lt;&amp;gt;, 它满足这些要求.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;FallsIllEventArgs&amp;gt; FallsIll;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后, 需要写一个 protected virtual 方法可以触发event. 方法的名称必须和event匹配: 以On开头, 接受EventArgs类型的参数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnFallsIll()
        {
            FallsIll&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; FallsIllEventArgs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;China Beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意: 预定义的非泛型的EventHandler委托可以在没有数据需要传输的时候使用, 调用的时候可以使用EventArgs.Empty来避免不必要的初始化EventArgs&lt;/strong&gt;.&lt;/p&gt;


&lt;p&gt;Person.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ObserverPattern
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;FallsIllEventArgs&amp;gt;&lt;span&gt; FallsIll;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnFallsIll()
        {
            FallsIll&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; FallsIllEventArgs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;China Beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FallsIllEventArgs.cs:&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ObserverPattern
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FallsIllEventArgs : EventArgs
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Address;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FallsIllEventArgs(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; address)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Address =&lt;span&gt; address;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Program.cs:&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ObserverPattern
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
            person.FallsIll &lt;/span&gt;+=&lt;span&gt; OnFallsIll;
            person.OnFallsIll();
            person.FallsIll &lt;/span&gt;-=&lt;span&gt; OnFallsIll;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnFallsIll(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, FallsIllEventArgs eventArgs)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A doctor has been called to {eventArgs.Address}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Sun, 01 Apr 2018 13:55:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8688476.html</dc:identifier>
</item>
</channel>
</rss>