<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>赢在面试之Java泛型篇(十二) - 小山博客</title>
<link>http://www.cnblogs.com/peke/p/7892785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peke/p/7892785.html</guid>
<description>&lt;p&gt;&lt;strong&gt;139. Java中的泛型是什么 ? 使用泛型的好处是什么?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        1、类型安全，提供编译期间的类型检测&lt;/p&gt;
&lt;p&gt;       2、前后兼容&lt;/p&gt;
&lt;p&gt;        3、泛化代码,代码可以更多的重复利用&lt;/p&gt;
&lt;p&gt;        4、性能较高，用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息，这些信息对java程序做进一步优化提供条件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;140，Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       1、类型检查：在生成字节码之前提供类型检查&lt;/p&gt;
&lt;p&gt;        2、类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）&lt;/p&gt;
&lt;p&gt;        3、如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决&lt;/p&gt;
&lt;p&gt;        4、如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型擦除：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        所有类型参数都用他们的限定类型替换：&lt;/p&gt;
&lt;p&gt;比如T-&amp;gt;Object   ? extends BaseClass-&amp;gt;BaseClass&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List&amp;lt;String&amp;gt;在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;141，你可以把List&amp;lt;String&amp;gt;传递给一个接受List&amp;lt;Object&amp;gt;参数的方法吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以 List&amp;lt;String&amp;gt;应当可以用在需要List&amp;lt;Object&amp;gt;的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List&amp;lt;Object&amp;gt;可以存储任何类型的对象包括String, Integer等等，而List&amp;lt;String&amp;gt;却只能用来存储String s。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;List&amp;lt;Object&amp;gt; objectList;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;List&amp;lt;String&amp;gt; stringList;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;objectList = stringList;&lt;/em&gt;&lt;em&gt; //compilation error incompatible types&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;142，如何阻止Java中的类型未检查的警告?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        如果你把泛型和原始类型混合起来使用，例如下列代码，java 5的javac编译器会产生类型未检查的警告，例如&lt;/p&gt;
&lt;p&gt;List&amp;lt;String&amp;gt; rawList = newArrayList()&lt;/p&gt;
&lt;p&gt;注意: Hello.java使用了未检查或称为不安全的操作;&lt;/p&gt;
&lt;p&gt;这种警告可以使用@SuppressWarnings(“unchecked”)注解来屏蔽。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;143，Java中List&amp;lt;Object&amp;gt;和原始类型List之间的区别?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        原始类型和带参数类型&amp;lt;Object&amp;gt;之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。&lt;/p&gt;
&lt;p&gt;        这道题的考察点在于对泛型中原始类型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List&amp;lt;String&amp;gt;传递给接受 List&amp;lt;Object&amp;gt;的方法，因为会产生编译错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;144，编写一段泛型程序来实现LRU缓存?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。&lt;/p&gt;
&lt;p&gt;        LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put() 和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;145，Array中可以用泛型吗?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;146，如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。最简单的情况下，一个泛型方法可能会像这样：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;   public V put(K key, V value) {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;   return cahe.put(key,value);&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;147，C++模板和java泛型之间有何不同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        java泛型实现根植于“类型消除”这一概念。当源代码被转换为Java虚拟机字节码时，这种技术会消除参数化类型。有了Java泛型，我们可以做的事情也并没有真正改变多少；他只是让代码变得漂亮些。鉴于此，Java泛型有时也被称为“语法糖”。&lt;/p&gt;
&lt;p&gt;        这和 C++模板截然不同。在 C++中，模板本质上就是一套宏指令集，只是换了个名头，编译器会针对每种类型创建一份模板代码的副本。&lt;/p&gt;
&lt;p&gt;由于架构设计上的差异，Java泛型和C++模板有很多不同点：&lt;/p&gt;
&lt;p&gt;   C++模板可以使用int等基本数据类型。Java则不行，必须转而使用Integer。&lt;/p&gt;
&lt;p&gt;    在Java中，可以将模板的参数类型限定为某种特定类型。&lt;/p&gt;
&lt;p&gt;    在C++中，类型参数可以实例化，但java不支持。&lt;/p&gt;
&lt;p&gt;    在Java中，类型参数不能用于静态方法(?)和变量，因为它们会被不同类型参数指定的实例共享。在C++，这些类时不同的，因此类型参数可以用于静态方法和静态变量。&lt;/p&gt;
&lt;p&gt;        在Java中，不管类型参数是什么，所有的实例变量都是同一类型。类型参数会在运行时被抹去。在C++中，类型参数不同，实例变量也不同。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 15:45:00 +0000</pubDate>
<dc:creator>小山博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peke/p/7892785.html</dc:identifier>
</item>
<item>
<title>Java提高十六：TreeMap深入分析 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/7892401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/7892401.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一篇容器元素比较Comparable&amp;amp;Comparator分析的时候，我们提到了TreeMap，但没有去细致分析它，只是说明其在添加元素的时候可以进行比较，从而使得集合有序，但是怎么做的呢?我们下面来进行分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、认识TreeMap&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前的文章讲解了HashMap，它保证了以O(1)的时间复杂度进行增、删、改、查，从存储角度考虑，这两种数据结构是非常优秀的。&lt;/p&gt;
&lt;p&gt;尽管如此，HashMap还是有自己的局限性----它们&lt;strong&gt;不具备统计性能，或者说它们的统计性能时间复杂度并不是很好才更准确，所有的统计必须遍历所有Entry，因此时间复杂度为O(N)&lt;/strong&gt;。比如Map的Key有1、2、3、4、5、6、7，我现在要统计：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有Key比3大的键值对有哪些&lt;/li&gt;
&lt;li&gt;Key最小的和Key最大的是哪两个&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就类似这些操作，HashMap做得比较差，此时我们可以使用TreeMap。TreeMap的Key按照自然顺序进行排序或者根据创建映射时提供的Comparator接口进行排序。&lt;strong&gt;TreeMap为增、删、改、查这些操作提供了log(N)的时间开销&lt;/strong&gt;，从存储角度而言，这比HashMap的O(1)时间复杂度要差些；但是在统计性能上，TreeMap同样可以保证log(N)的时间开销，这又比HashMap的O(N)时间复杂度好不少。&lt;/p&gt;
&lt;p&gt;因此总结而言：如果只需要存储功能，使用HashMap是一种更好的选择；如果还需要保证统计性能或者需要对Key按照一定规则进行排序，那么使用TreeMap是一种更好的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、红黑树介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们知道一颗基本的二叉树他们都需要满足一个基本性质--即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124211523265-768872994.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、每个节点都只能是红色或者黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、根节点是黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、每个叶节点（NIL节点，空节点）是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log &lt;em&gt;n&lt;/em&gt;)。下图为一颗典型的红黑二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124211651984-1917137019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://cmsblogs.qiniudn.com/wp-content/uploads/2014/05/2014051700004.gif&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;241&quot;/&gt;左边旋转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cmsblogs.qiniudn.com/wp-content/uploads/2014/05/2014051700005.gif&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;258&quot;/&gt;右边旋转&lt;/p&gt;
&lt;p&gt;（图片来自：&lt;a title=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&quot; href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&quot;&gt;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：由于本文主要是讲解Java中TreeMap，所以并没有对红黑树进行非常深入的了解和研究，如果想对其进行更加深入的研究提供几篇较好的博文：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;span&gt;、&lt;/span&gt;&lt;a href=&quot;http://blog.csdn.net/v_JULY_v/article/category/774945&quot;&gt;&lt;span&gt;红黑树系列集锦&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&quot;&gt;&lt;span&gt;红黑树数据结构剖析&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a href=&quot;http://blog.csdn.net/eric491179912/article/details/6179908&quot;&gt;&lt;span&gt;红黑树&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、TreeMap的数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; NavigableMap&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html&quot;&gt;更多&lt;/a&gt;）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TreeMap中同时也包含了如下几个重要的属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; comparator;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap红-黑节点，为TreeMap的内部类&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器大小&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap修改次数&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红黑树的节点颜色--红色&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; RED = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红黑树的节点颜色--黑色&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; BLACK = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;键&lt;/span&gt;
&lt;span&gt;        K key;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;
&lt;span&gt;        V value;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左孩子&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右孩子&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父亲&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; color = BLACK;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、核心方法put 分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析put方法的过程，我们采用实例来进行分析，下面我们是我们写的一段代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pony1223;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.TreeMap;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapDemo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) 
    {
        TreeMap&lt;/span&gt;&amp;lt;Integer, String&amp;gt; treeMap = &lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;Integer, String&amp;gt;&lt;span&gt;();
        treeMap.put(&lt;/span&gt;10, &quot;10&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;83, &quot;83&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;15, &quot;15&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;72, &quot;72&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;20, &quot;20&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;60, &quot;60&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;30, &quot;30&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;50, &quot;50&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;Integer, String&amp;gt;&lt;span&gt; entry : treeMap.entrySet()) {
            System.out.println(entry.getKey() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; entry.getValue());
        }
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们打印结果发现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124213205515-1339492964.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;事实再次证明TreeMap是有序的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来的内容会给出插入每条数据之后红黑树的数据结构是什么样子的。首先看一下treeMap的put方法的代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用t表示二叉树的当前节点&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; t =&lt;span&gt; root;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t为null表示一个空树，即TreeMap中没有任何元素，直接插入&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？&lt;/span&gt;
                compare(key, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; type (and possibly null) check
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root&lt;/span&gt;
                root = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器的size = 1，表示TreeMap集合中存在一个元素&lt;/span&gt;
                size = 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改次数 + 1&lt;/span&gt;
                modCount++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cmp;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp表示key排序的返回结果&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; parent;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; split comparator and comparable paths&lt;/span&gt;
            Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; cpr = comparator;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定的排序算法
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (cpr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    parent &lt;/span&gt;= t;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;parent指向上次循环后的t
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较新增节点的key和当前节点key的大小&lt;/span&gt;
                    cmp =&lt;span&gt; cpr.compare(key, t.key);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.left;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.right;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果cpr为空，则采用默认的排序算法进行创建TreeMap集合&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值为空抛出异常&lt;/span&gt;
                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 下面处理过程和上面一样 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                Comparable&lt;/span&gt;&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; k = (Comparable&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt;) key;
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    parent &lt;/span&gt;=&lt;span&gt; t;
                    cmp &lt;/span&gt;=&lt;span&gt; k.compareTo(t.key);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.left;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.right;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新增节点当做parent的子节点&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; e = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(key, value, parent);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果新增节点的key小于parent的key，则当做左子节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                parent.left &lt;/span&gt;=&lt;span&gt; e;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果新增节点的key大于parent的key，则当做右子节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                parent.right &lt;/span&gt;=&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置
             *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            fixAfterInsertion(e);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap元素数量 + 1&lt;/span&gt;
            size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap容器修改次数 + 1&lt;/span&gt;
            modCount++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从这段代码，先总结一下TreeMap添加数据的几个步骤：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.获取根节点，根节点为空，产生一个根节点，将其着色为黑色，退出余下流程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.获取比较器，如果传入的Comparator接口不为空，使用传入的Comparator接口实现类进行比较；如果传入的Comparator接口为空，将Key强转为Comparable接口进行比较&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.从根节点开始逐一依照规定的排序算法进行比较，取比较值cmp，如果cmp=0，表示插入的Key已存在；如果cmp&amp;gt;0，取当前节点的右子节点；如果cmp&amp;lt;0，取当前节点的左子节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.排除插入的Key已存在的情况，第（3）步的比较一直比较到当前节点t的左子节点或右子节点为null，此时t就是我们寻找到的节点，cmp&amp;gt;0则准备往t的右子节点插入新节点，cmp&amp;lt;0则准备往t的左子节点插入新节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.new出一个新节点，默认为黑色，根据cmp的值向t的左边或者右边进行插入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6.插入之后进行修复，包括左旋、右旋、重新着色这些操作，让树保持平衡性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第1~第5步都没有什么问题，红黑树最核心的应当是第6步插入数据之后进行的修复工作，对应的Java代码是TreeMap中的fixAfterInsertion方法，下面看一下put每个数据之后TreeMap都做了什么操作，借此来理清TreeMap的实现原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(10, &quot;10&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是put(10, &quot;10&quot;)，由于此时TreeMap中没有任何节点，因此10为根且根节点为黑色节点，put(10, &quot;10&quot;)之后的数据结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124214618750-62744801.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(83, &quot;83&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着是put(83, &quot;83&quot;)，这一步也不难，83比10大，因此在10的右节点上，即执行上面代码中do{}代码块，它是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，但是由于83不是根节点，我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 新增节点后的修复操作
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * x 表示新增节点
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fixAfterInsertion(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             x.color = RED;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增节点的颜色为红色
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环 直到 x不是根节点，且x的父节点不为红色&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的父节点（P）是其父节点的父节点（G）的左节点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (parentOf(x) ==&lt;span&gt; leftOf(parentOf(parentOf(x)))) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取X的叔节点(U)&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                     Entry&amp;lt;K,V&amp;gt; y =&lt;span&gt; rightOf(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U） 为红色（情况三）&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (colorOf(y) ==&lt;span&gt; RED) {     
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的叔节点（U）设置为黑色&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        setColor(y, BLACK);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         x =&lt;span&gt; parentOf(parentOf(x));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {   
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; rightOf(parentOf(x))) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点作为X&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                             x =&lt;span&gt; parentOf(x);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋转&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                            rotateLeft(x);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（情况五）
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以X的父节点的父节点（G）为中心右旋转&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                        rotateRight(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的父节点（P）是其父节点的父节点（G）的右节点&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取X的叔节点（U）&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                     Entry&amp;lt;K,V&amp;gt; y =&lt;span&gt; leftOf(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U） 为红色（情况三）&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (colorOf(y) ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的叔节点（U）设置为黑色&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                        setColor(y, BLACK);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                         x =&lt;span&gt; parentOf(parentOf(x));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; leftOf(parentOf(x))) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点作为X&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;                             x =&lt;span&gt; parentOf(x);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋转&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                            rotateRight(x);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（情况五）
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以X的父节点的父节点（G）为中心右旋转&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;                        rotateLeft(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将根节点G强制设置为黑色&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;             root.color =&lt;span&gt; BLACK;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们看第6行的代码，它&lt;strong&gt;将默认的插入的那个节点着色成为&lt;/strong&gt;&lt;strong&gt;红色&lt;/strong&gt;，这很好理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据红黑树的性质（3），红黑树要求从根节点到叶子所有叶子节点上经过的黑色节点个数是相同的，因此如果插入的节点着色为黑色，那必然有可能导致某条路径上的黑色节点数量大于其他路径上的黑色节点数量，因此默认插入的节点必须是红色的，以此来维持红黑树的性质（3）.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然插入节点着色为红色节点后，有可能导致的问题是违反性质（2），即出现连续两个红色节点，这就需要通过旋转操作去改变树的结构，解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着看&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
while (x != null &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color ==&lt;span&gt; RED)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;的判断，前两个条件都满足，但是因为83这个节点的父节点是根节点的，根节点是黑色节点，因此这个条件不满足，while循环不进去，直接执行一次&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
root.color =&lt;span&gt; BLACK;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;行的代码给根节点着色为黑色（因为在旋转过程中有可能导致根节点为红色，而红黑树的根节点必须是黑色，因此最后不管根节点是不是黑色，都要重新着色确保根节点是黑色的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么put(83, &quot;83&quot;)之后，整个树的结构变为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124215733156-1716953325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、为根节点&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; 若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、父节点为黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在看put(15, &quot;15&quot;)之前，必须要先过一下fixAfterInsertion方法。第11行～第41行的代码和第43行~第73行的代码是一样的，无非一个是操作左子树另一个是操作右子树而已，因此就看前一半：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (parentOf(x) ==&lt;span&gt; leftOf(parentOf(parentOf(x)))) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; y =&lt;span&gt; rightOf(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (colorOf(y) ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            setColor(y, BLACK);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             x =&lt;span&gt; parentOf(parentOf(x));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; rightOf(parentOf(x))) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 x =&lt;span&gt; parentOf(x);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                rotateLeft(x);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            rotateRight(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    ....
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第2行的判断注意一下，用语言描述出来就是：&lt;strong&gt;判断当前节点的父节点与当前节点的父节点的父节点的左子节点是否同一个节点&lt;/strong&gt;。翻译一下就是：&lt;strong&gt;当前节点是否左子节点插入.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在上面代码中说到的情况三、四、五的意思是；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、若父节点P和P的兄弟节点U都为红色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于这种情况若直接插入肯定会出现不平衡现象（不能出现两个连着的红色）。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124221112015-1041895978.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;四、若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于这种情况我们对新增节点N、P进行一次左旋转。这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124221527140-103726934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;五、父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况先已P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N、G的父节点。但是这棵树并不规范，它违反了规则4，所以我们将P、G节点的颜色进行交换，使之其满足规范。开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124222148078-49067841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：对于第四种情况和第五种情况而言这两种插入方式的处理是不同的，区别是第四种情况插入多一步左旋操作。能看出，&lt;strong&gt;红黑树的插入最多只需要进行两次旋转，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124222927093-651673821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中左边的是左子树外侧插入，右边的是左子树内侧插入&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;put(15, &quot;15&quot;)&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看完fixAfterInsertion方法流程之后，继续添加数据，这次添加的是put(15, &quot;15&quot;)，15比10大且比83小，因此15最终应当是83的左子节点，默认插入的是红色节点，因此首先将15作为红色节点插入83的左子节点后的结构应当是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124222617156-1250942400.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是显然这里违反了红黑树的性质（2），即连续出现了两个红色节点，因此此时必须进行旋转。回看前面fixAfterInsertion的流程，上面演示的是左子树插入流程，右子树一样，可以看到这是右子树内侧插入，需要进行两次旋转操作：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;对新插入节点的父节点进行一次右旋操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;新插入节点的父节点着色为黑色，新插入节点的祖父节点着色为红色&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对新插入节点的祖父节点进行一次左旋操作&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;旋转是红黑树中最难理解也是最核心的操作，右旋和左旋是对称的操作，我个人的理解，以右旋为例，对某个节点x进行右旋，其实质是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;降低左子树的高度，增加右子树的高度&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;将x变为当前位置的右子节点&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;左旋是同样的道理，在旋转的时候一定要记住这两句话，这将会帮助我们清楚地知道在不同的场景下旋转如何进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看一下&quot;对新插入节点的父节点进行一次右旋操作&quot;，源代码为rotateRight方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rotateRight(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将L设置为P的左子树&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; l =&lt;span&gt; p.left;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将L的右子树设置为P的左子树&lt;/span&gt;
            p.left =&lt;span&gt; l.right;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若L的右子树不为空，则将P设置L的右子树的父节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (l.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
                l.right.parent &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P的父节点设置为L的父节点&lt;/span&gt;
            l.parent =&lt;span&gt; p.parent;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果P的父节点为空，则将L设置根节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                root &lt;/span&gt;=&lt;span&gt; l;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若P为其父节点的右子树，则将L设置为P的父节点的右子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.parent.right ==&lt;span&gt; p)
                p.parent.right &lt;/span&gt;=&lt;span&gt; l;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则将L设置为P的父节点的左子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                p.parent.left &lt;/span&gt;=&lt;span&gt; l;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P设置为L的右子树&lt;/span&gt;
            l.right =&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将L设置为P的父节点&lt;/span&gt;
            p.parent =&lt;span&gt; l;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;左旋与右旋是一个对称的操作，大家可以试试看把右图的b节点进行左旋，就变成了左图了。这里多说一句，&lt;strong&gt;旋转一定要说明是对哪个节点进行旋转&lt;/strong&gt;，网上看很多文章讲左旋、右旋都是直接说旋转之后怎么样怎么样，我认为脱离具体的节点讲旋转是没有任何意义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里可能会有的一个问题是：b有左右两个子节点分别为d和e，为什么右旋的时候要将右子节点e拿到a的左子节点而不是b的左子节点d？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个很简单的解释是：&lt;strong&gt;如果将b的左子节点d拿到a的左子节点，那么b右旋后右子节点指向a，b原来的右子节点e就成为了一个游离的节点，游离于整个数据结构之外&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到实际的例子，对83这个节点进行右旋之后还有一次着色操作（2），分别是将x的父节点着色为黑色，将x的祖父节点着色为红色，然后对节点10进行一次左旋操作（3），左旋之后的结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223244078-1457287722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(72, &quot;72&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(72, &quot;72&quot;)就很简单了，72是83的左子节点，由于72的父节点以及叔父节点都是红色节点，因此直接将72的父节点83、将72的叔父节点10着色为黑色即可，72这个节点着色为红色，即满足红黑树的特性，插入72之后的结构图为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223601859-142900299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(20, &quot;20&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(20, &quot;20&quot;)，插入的位置应当是72的左子节点，默认插入红色，插入之后的结构图为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223758109-938030745.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题很明显，出现了连续两个红色节点，20的插入位置是一种左子树外侧插入的场景，因此只需要进行着色+对节点83进行一次右旋即可，着色+右旋之后数据结构变为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223846375-825960498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(60, &quot;60&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面进行put(60, &quot;60&quot;)操作，节点60插入的位置是节点20的右子节点，由于节点60的父节点与叔父节点都是红色节点，因此只需要将节点60的父节点与叔父节点着色为黑色，将节点60的组父节点着色为红色即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么put(60, &quot;60&quot;)之后的结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223952281-1218713418.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(30, &quot;30&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(30, &quot;30&quot;)，节点30应当为节点60的左子节点，因此插入节点30之后应该是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124224221156-298976549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然这里违反了红黑树性质即连续出现了两个红色节点，因此这里要进行旋转。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(30, &quot;30&quot;)的操作和put(15, &quot;15&quot;)的操作类似，同样是右子树内侧插入的场景，那么需要进行两次旋转：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;对节点30的父节点节点60进行一次右旋&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;右旋之后对节点60的祖父节点20进行一次左旋&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;右旋+着色+左旋之后，put(30, &quot;30&quot;)的结果应当为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124224332625-2051209453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(50, &quot;50&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124224542093-1165186117.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rotateLeft(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取P的右子节点，其实这里就相当于新增节点N（情况四而言）&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; r =&lt;span&gt; p.right;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将R的左子树设置为P的右子树&lt;/span&gt;
            p.right =&lt;span&gt; r.left;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若R的左子树不为空，则将P设置为R左子树的父亲&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (r.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                r.left.parent &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P的父亲设置R的父亲&lt;/span&gt;
            r.parent =&lt;span&gt; p.parent;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果P的父亲为空，则将R设置为跟节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                root &lt;/span&gt;=&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.parent.left ==&lt;span&gt; p)
                p.parent.left &lt;/span&gt;=&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则R设置为P的父节点（G）的右子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                p.parent.right &lt;/span&gt;=&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P设置为R的左子树&lt;/span&gt;
            r.left =&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将R设置为P的父节点&lt;/span&gt;
            p.parent =&lt;span&gt; r;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 五、delete方法分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。子节点C的规则是：右分支最左边，或者 左分支最右边的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面就论各种删除情况来进行图例讲解，但是在讲解之前请允许我再次啰嗦一句，请时刻牢记红黑树的5点规定：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、每个节点都只能是红色或者黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、根节点是黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、每个叶节点（NIL节点，空节点）是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 删除元素的过程和普通二叉搜索树的搜索过程大体也比较类似，首先是根据待删除节点的情况进行分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 待删除节点没有子节点， 则直接删除该节点。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230155109-1930464163.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 待删除节点有一个子节点，则用该子节点替换它的父节点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230357265-752652354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. 待删除节点有两个子节点，则取它的后继节点替换它，并删除这个后继节点原来的位置。它可能有种情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230439140-453103889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;删除后的调整&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 删除元素之后的调整和前面的插入元素调整的过程比起来更复杂。它不是一个简单的在原来过程中取反。我们先从一个最基本的点开始入手。首先一个，我们要进行调整的这个点肯定是因为我们要删除的这个点破坏了红黑树的本质特性。而如果我们删除的这个点是红色的，则它肯定不会破坏里面的属性。因为从前面删除的过程来看，我们这个要删除的点是已经在濒临叶节点的附近了，它要么有一个子节点，要么就是一个叶节点。如果它是红色的，删除了，从上面的节点到叶节点所经历的黑色节点没有变化。所以，这里的一个前置条件就是待删除的节点是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在前面的那个前提下，我们要调整红黑树的目的就是要保证，这个原来是黑色的节点被删除后，我们要通过一定的变化，使得他们仍然是合法的红黑树。我们都知道，在一个黑色节点被删除后，从上面的节点到它所在的叶节点路径所经历的黑色节点就少了一个。我们需要做一些调整，使得它少的这个在后面某个地方能够补上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ok，有了这一部分的理解，我们再来看调整节点的几种情况。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 当前节点和它的父节点是黑色的，而它的兄弟节点是红色的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230633937-319334034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这种情况下既然它的兄弟节点是红色的，从红黑树的属性来看，它的兄弟节点必然有两个黑色的子节点。这里就通过节点x的父节点左旋，然后父节点B颜色变成红色，而原来的兄弟节点D变成黑色。这样我们就将树转变成第二种情形中的某一种情况。在做后续变化前，这棵树这么的变化还是保持着原来的平衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. 1） 当前节点的父节点为红色，而它的兄弟节点，包括兄弟节点的所有子节点都是黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230741812-1836079901.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  在这种情况下，我们将它的兄弟节点设置为红色，然后x节点指向它的父节点。这里有个比较难以理解的地方，就是为什么我这么一变之后它就平衡了呢？因为我们假定A节点是要调整的节点一路调整过来的。因为原来那个要调整的节点为黑色，它一旦被删除就路径上的黑色节点少了1.所以这里A所在的路径都是黑色节点少1.这里将A的兄弟节点变成红色后，从它的父节点到下面的所有路径就都统一少了1.保证最后又都平衡了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    当然，大家还会有一个担忧，就是当前调整的毕竟只是一棵树中间的字数，这里头的节点B可能还有父节点，这么一直往上到根节点。你这么一棵字数少了一个黑色节点，要保证整理合格还是不够的。这里在代码里有了一个保证。假设这里B已经是红色的了。那么代码里那个循环块就跳出来了，最后的部分还是会对B节点，也就是x所指向的这个节点置成黑色。这样保证前面亏的那一个黑色节点就补回来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2） 当前节点的父节点为黑色，而它的兄弟节点，包括兄弟节点的所有子节点都是黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这种情况和前面比较类似。如果接着前面的讨论来，在做了那个将兄弟节点置成红色的操作之后，从父节点B开始的所有子节点都少了1.那么这里从代码中间看的话，由于x指向了父节点，仍然是黑色。则这个时候以父节点B作为基准的子树下面都少了黑节点1. 我们就接着以这么一种情况向上面推进。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.  当前节点的父节点为红色，而它的兄弟节点是黑色，同时兄弟节点有一个节点是红色。&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124231113218-303819138.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里所做的操作就是先将兄弟节点做一个右旋操作，转变成第4种情况。当然，前面的前提是B为红色，在B为黑色的情况下也可以同样的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 在当前兄弟节点的右子节点是红色的情况下。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124231156437-937263510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里是一种比较理想的处理情况，我们将父节点做一个左旋操作，同时将父节点B变成黑色，而将原来的兄弟节点D变成红色，并将D的右子节点变成黑色。这样保证了新的子树中间根节点到各叶子节点的路径依然是平衡的。大家看到这里也许会觉得有点奇怪，为什么这一步调整结束后就直接x = T.root了呢？也就是说我们一走完这个就可以把x直接跳到根节点，其他的都不需要看了。这是因为我们前面的一个前提，A节点向上所在的路径都是黑色节点少了一个的，这里我们以调整之后相当于给它增加了一个黑色节点，同时对其他子树的节点没有任何变化。相当于我内部已经给它补偿上来了。所以后续就不需要再往上去调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面讨论的这4种情况是在当前节点是父节点的左子节点的条件下进行的。如果当前节点是父节点的右子节点，则可以对应的做对称的操作处理，过程也是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;TreeMap的红黑树实现当然也包含其他部分的代码实现，如用于查找元素的getEntry方法，取第一个和最后一个元素的getFirstEntry, getLastEntry方法以及求前驱和后继的predecesor, successor方法。这些方法的实现和普通二叉搜索树的实现没什么明显差别。这里就忽略不讨论了。这里还有一个有意思的方法实现，就是buildFromSorted方法。它的实现过程并不复杂，不过经常被作为面试的问题来讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、小节&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇博文确实是有点儿长，在这里非常感谢各位看客能够静下心来读完，我想你通过读完这篇博文一定收获不小。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同时这篇博文我写的过程中，看了、参考了大量的博文。同时不免会有些地方存在借鉴之处，在这里对其表示感谢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;另外，我想说的是，重点要掌握的是put方法即可，其它如果精力足够可以细细品读。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;1、红黑树数据结构剖析：&lt;a title=&quot;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&quot; href=&quot;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&quot;&gt;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、红黑二叉树详解及理论分析 ：&lt;a title=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot; href=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot;&gt;http://blog.csdn.net/kartorz/article/details/8865997&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;http://blog.csdn.net/v_july_v/article/details/6105630&quot;&gt;教你透彻了解红黑树 &lt;/a&gt;：&lt;a href=&quot;http://cmsblogs.com/blog.csdn.net/v_july_v/article/details/6105630&quot;&gt;blog.csdn.net/v_july_v/article/details/6105630&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、经典算法研究系列：五、红黑树算法的实现与剖析 ：&lt;a title=&quot;http://blog.csdn.net/v_JULY_v/article/details/6109153&quot; href=&quot;http://blog.csdn.net/v_JULY_v/article/details/6109153&quot;&gt;http://blog.csdn.net/v_JULY_v/article/details/6109153&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、示例，红黑树插入和删除过程：&lt;a title=&quot;http://saturnman.blog.163.com/blog/static/557611201097221570/&quot; href=&quot;http://saturnman.blog.163.com/blog/static/557611201097221570/&quot;&gt;http://saturnman.blog.163.com/blog/static/557611201097221570/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、红黑二叉树详解及理论分析 ：&lt;a title=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot; href=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot;&gt;http://blog.csdn.net/kartorz/article/details/8865997&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7、红黑树概念、红黑树的插入及旋转操作：&lt;a href=&quot;http://www.cnblogs.com/xrq730/p/6867924.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/xrq730/p/6867924.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、treemap:&lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/26668941&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/chenssy/article/details/26668941&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 15:26:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/7892401.html</dc:identifier>
</item>
<item>
<title>源码剖析Django REST framework的请求生命周期 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/7892719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/7892719.html</guid>
<description>&lt;p&gt;学习Django的时候知道,在Django请求的生命周期中,请求经过WSGI和中间件到达路由,不管是FBV还是CBV都会先执行View视图函数中的dispatch方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REST framework&lt;/code&gt;是基于Django的API框架,REST framework采用的是CBV的请求模式.&lt;/p&gt;
&lt;p&gt;所以在一个项目中,使用了REST framework的时候,&lt;/p&gt;
&lt;p&gt;请求到达&lt;code&gt;REST framework&lt;/code&gt;后,也先执行&lt;code&gt;REST framework&lt;/code&gt;中的&lt;code&gt;dispatch&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;先来看看&lt;code&gt;dispatch&lt;/code&gt;方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def dispatch(self, request, *args, **kwargs):

    self.args = args            # 函数传递过来的参数
    self.kwargs = kwargs        # 函数传递过来的参数
    
    # 封装request
    request = self.initialize_request(request, *args, **kwargs)
    self.request = request
    self.headers = self.default_response_headers  # deprecate?

    try:
        self.initial(request, *args, **kwargs)

        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(),
                              self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed

        response = handler(request, *args, **kwargs)

    except Exception as exc:
        response = self.handle_exception(exc)

    self.response = self.finalize_response(request, response, *args, **kwargs)
    return self.response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看&lt;code&gt;initialize_request&lt;/code&gt;方法,可以知道这个方法接收客户端的request请求,再重新封装成新的request&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def initialize_request(self, request, *args, **kwargs):

    parser_context = self.get_parser_context(request)

    return Request(
        request,
        parsers=self.get_parsers(),
        authenticators=self.get_authenticators(),
        negotiator=self.get_content_negotiator(),
        parser_context=parser_context
    )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再查看Request方法的源码&lt;/p&gt;
&lt;p&gt;可以知道这个&lt;code&gt;Request&lt;/code&gt;类是&lt;code&gt;rest framework&lt;/code&gt;中定义的一个类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Request(object):

    def __init__(self, request, parsers=None, authenticators=None,
                 negotiator=None, parser_context=None):
        self._request = request
        self.parsers = parsers or ()
        self.authenticators = authenticators or ()
        self.negotiator = negotiator or self._default_negotiator()
        self.parser_context = parser_context
        self._data = Empty
        self._files = Empty
        self._full_data = Empty
        self._content_type = Empty
        self._stream = Empty

        if self.parser_context is None:
            self.parser_context = {}
        self.parser_context['request'] = self
        self.parser_context['encoding'] = request.encoding or settings.DEFAULT_CHARSET

        force_user = getattr(request, '_force_auth_user', None)
        force_token = getattr(request, '_force_auth_token', None)
        if force_user is not None or force_token is not None:
            forced_auth = ForcedAuthentication(force_user, force_token)
            self.authenticators = (forced_auth,)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先不看这个&lt;code&gt;Request&lt;/code&gt;到底执行了什么操作&lt;/p&gt;
&lt;p&gt;但是已经知道经过Request处理过的request已经不再是客户端发送过来的那个request了&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;initialize_request&lt;/code&gt;方法中,有一个方法处理过request,来看看&lt;code&gt;get_parser_context&lt;/code&gt;方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def get_parser_context(self, http_request):

    return {
        'view': self,
        'args': getattr(self, 'args', ()),
        'kwargs': getattr(self, 'kwargs', {})
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里,view的值是self,代指的是&lt;code&gt;UsersView&lt;/code&gt;这个对象,所以&lt;code&gt;get_parser_context&lt;/code&gt;方法把UsersView这个类封装进来然后返回&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;get_parser_context&lt;/code&gt;方法最后返回的当前对象以及当前对象所传的参数&lt;/p&gt;
&lt;p&gt;经过&lt;code&gt;initialize_request&lt;/code&gt;函数处理之后的request,现在就变成了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Request(
    request,
    parsers=self.get_parsers(),
    authenticators=self.get_authenticators(),
    negotiator=self.get_content_negotiator(),
    parser_context=parser_context
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再来看看Request的其他参数代指的是什么&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;get_parsers                 根据字面意思,是解析get请求的意思
get_authenticators          认证相关
get_content_negotiator      选择相关
parser_context              封闭self和self的参数

def get_parsers(self):

    return [parser() for parser in self.parser_classes]

def get_authenticators(self):

    return [auth() for auth in self.authentication_classes]

def get_permissions(self):

    return [permission() for permission in self.permission_classes]

def get_throttles(self):

    return [throttle() for throttle in self.throttle_classes]

def get_content_negotiator(self):

    if not getattr(self, '_negotiator', None):
        self._negotiator = self.content_negotiation_class()
    return self._negotiator&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看看&lt;code&gt;UsersView&lt;/code&gt;这个类中的get方法和post方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def get(self,request,*args,**kwargs):
    pass

def post(self,request,*args,**kwargs):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到get方法的参数中有一个request,通过前面可以知道这个request已经不是最开始时到达服务端的request了&lt;/p&gt;
&lt;p&gt;这个request方法中已经被&lt;code&gt;REST framework&lt;/code&gt;封装了解析,认证和选择等相关的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def dispatch(self, request, *args, **kwargs):

    self.args = args
    self.kwargs = kwargs
    request = self.initialize_request(request, *args, **kwargs)
    self.request = request
    self.headers = self.default_response_headers  # deprecate?

    try:
        self.initial(request, *args, **kwargs)

        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(),
                              self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed

        response = handler(request, *args, **kwargs)

    except Exception as exc:
        response = self.handle_exception(exc)

    self.response = self.finalize_response(request, response, *args, **kwargs)
    return self.response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;default_response_headers&lt;/code&gt;这个方法从它的注释可以看出已经被丢弃了.&lt;/p&gt;
&lt;p&gt;再来看&lt;code&gt;initial&lt;/code&gt;这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def initial(self, request, *args, **kwargs):
    &quot;&quot;&quot;
    Runs anything that needs to occur prior to calling the method handler.
    &quot;&quot;&quot;
    self.format_kwarg = self.get_format_suffix(**kwargs)

    # Perform content negotiation and store the accepted info on the request
    neg = self.perform_content_negotiation(request)
    request.accepted_renderer, request.accepted_media_type = neg

    # Determine the API version, if versioning is in use.
    version, scheme = self.determine_version(request, *args, **kwargs)
    request.version, request.versioning_scheme = version, scheme

    # Ensure that the incoming request is permitted
    self.perform_authentication(request)
    self.check_permissions(request)
    self.check_throttles(request)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先执行&lt;code&gt;get_format_suffix&lt;/code&gt;来获取客户端所发送的url的后缀&lt;/p&gt;
&lt;p&gt;然后执行&lt;code&gt;perform_content_negotiation&lt;/code&gt;方法,从它的注释可以知道这个方法的主要作用是执行内容选择,并把服务端接收到的信息保存在request中&lt;/p&gt;
&lt;p&gt;然后再执行&lt;code&gt;determine_version&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def determine_version(self, request, *args, **kwargs):
    &quot;&quot;&quot;
    If versioning is being used, then determine any API version for the
    incoming request. Returns a two-tuple of (version, versioning_scheme)
    &quot;&quot;&quot;
    if self.versioning_class is None:
        return (None, None)
    scheme = self.versioning_class()
    return (scheme.determine_version(request, *args, **kwargs), scheme)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;determine_version&lt;/code&gt;方法的官方注释中可以知道,&lt;code&gt;determine_version&lt;/code&gt;方法的主要作用是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果url中有版本信息,就获取发送到服务端的版本,返回一个元组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完上面的方法,再执行&lt;code&gt;perform_authentication&lt;/code&gt;方法来进行认证操作&lt;/p&gt;
&lt;p&gt;来看下&lt;code&gt;perform_authentication&lt;/code&gt;方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def perform_authentication(self, request):
    &quot;&quot;&quot;
    Perform authentication on the incoming request.

    Note that if you override this and simply 'pass', then authentication
    will instead be performed lazily, the first time either
    `request.user` or `request.auth` is accessed.
    &quot;&quot;&quot;
    request.user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面有代码及注释中可以看出,&lt;code&gt;perform_authentication&lt;/code&gt;方法的作用就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;执行认证功能,确认进行后续操作的用户是被允许的.
perform_authentication方法返回经过认证的用户对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完&lt;code&gt;perform_authentication&lt;/code&gt;方法,就会执行&lt;code&gt;check_permissions&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def check_permissions(self, request):
    &quot;&quot;&quot;
    Check if the request should be permitted.
    Raises an appropriate exception if the request is not permitted.
    &quot;&quot;&quot;
    for permission in self.get_permissions():
        if not permission.has_permission(request, self):
            self.permission_denied(
                request, message=getattr(permission, 'message', None)
            )
            &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;check_permissions&lt;/code&gt;方法的作用是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果用户通过认证,检查用户是否有权限访问url中所传的路径.
如用用户访问的是没有没有权限的路径,则会抛出异常.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;check_permissions&lt;/code&gt;方法执行完成后,就会执行&lt;code&gt;check_throttles&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;check_throttles&lt;/code&gt;方法的作用是检查用户是否被限制了访问主机的次数&lt;br/&gt;如果用户访问服务器的次数超出设定值,则会抛出一个异常&lt;/p&gt;
&lt;p&gt;例如,如果想限制一个ip地址每秒钟只能访问几次,一个小时之内最多可以访问多少次,就可以在&lt;code&gt;settings.py&lt;/code&gt;文件中进行配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def check_throttles(self, request):
    &quot;&quot;&quot;
    Check if request should be throttled.
    Raises an appropriate exception if the request is throttled.
    &quot;&quot;&quot;
    for throttle in self.get_throttles():
        if not throttle.allow_request(request, self):
            self.throttled(request, throttle.wait())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;initial&lt;/code&gt;这个方法执行完成后,&lt;code&gt;request.method.lower&lt;/code&gt;把请求的方法转换成小写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Get the appropriate handler method
if request.method.lower() in self.http_method_names:
    handler = getattr(self, request.method.lower(),
                      self.http_method_not_allowed)
else:
    handler = self.http_method_not_allowed

response = handler(request, *args, **kwargs)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再通过通过反射的方式来执行&lt;code&gt;UsersView&lt;/code&gt;类中的get或post等自定义方法&lt;/p&gt;
&lt;p&gt;需要注意的是,在执行&lt;code&gt;initial&lt;/code&gt;方法之前,使用了&lt;code&gt;try/except&lt;/code&gt;方法来进行异常处理&lt;/p&gt;
&lt;p&gt;如果执行&lt;code&gt;initial&lt;/code&gt;方法的时候出现错误,就调用&lt;code&gt;handle_exception&lt;/code&gt;来处理&lt;code&gt;initial&lt;/code&gt;方法抛出的异常,返回正确的响应信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def handle_exception(self, exc):
    &quot;&quot;&quot;
    Handle any exception that occurs, by returning an appropriate response,
    or re-raising the error.
    &quot;&quot;&quot;
    if isinstance(exc, (exceptions.NotAuthenticated,
                        exceptions.AuthenticationFailed)):
        # WWW-Authenticate header for 401 responses, else coerce to 403
        auth_header = self.get_authenticate_header(self.request)

        if auth_header:
            exc.auth_header = auth_header
        else:
            exc.status_code = status.HTTP_403_FORBIDDEN

    exception_handler = self.get_exception_handler()

    context = self.get_exception_handler_context()
    response = exception_handler(exc, context)

    if response is None:
        self.raise_uncaught_exception(exc)

    response.exception = True
    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面,如果&lt;code&gt;initial&lt;/code&gt;方法执行完成没有抛出异常,则根据反射执行自定义的请求方法,然后返回响应信息&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;initial&lt;/code&gt;方法抛出异常则执行&lt;code&gt;handle_exception&lt;/code&gt;方法处理抛出的异常,也返回响应信息&lt;/p&gt;
&lt;p&gt;等到上面的过程执行完成后,再执行&lt;code&gt;finalize_response&lt;/code&gt;方法把最终的响应信息返回给客户端的浏览器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def finalize_response(self, request, response, *args, **kwargs):
    &quot;&quot;&quot;
    Returns the final response object.
    &quot;&quot;&quot;
    # Make the error obvious if a proper response is not returned
    assert isinstance(response, HttpResponseBase), (
        'Expected a `Response`, `HttpResponse` or `HttpStreamingResponse` '
        'to be returned from the view, but received a `%s`'
        % type(response)
    )

    if isinstance(response, Response):
        if not getattr(request, 'accepted_renderer', None):
            neg = self.perform_content_negotiation(request, force=True)
            request.accepted_renderer, request.accepted_media_type = neg

        response.accepted_renderer = request.accepted_renderer
        response.accepted_media_type = request.accepted_media_type
        response.renderer_context = self.get_renderer_context()

    # Add new vary headers to the response instead of overwriting.
    vary_headers = self.headers.pop('Vary', None)
    if vary_headers is not None:
        patch_vary_headers(response, cc_delim_re.split(vary_headers))

    for key, value in self.headers.items():
        response[key] = value

    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以总结:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REST framework&lt;/code&gt;请求的生命周期为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.请求到达服务端,经过WSGI和中间件到达路由系统
2.路由系统执行配置的CBV或者FBV中的dispatch方法
3.在dispatch方法中,request方法被封装添加了解析器,认证方法及选择器等方法
4.然后执行initial方法
5.再获取版本,进行认证操作,权限操作和节流操作
6.最后执行自定义的get,post,push,delete等自定义方法
7.在执行initial方法之前,通过try来捕获可能出现的异常
8.如果出现异常,就执行handle_exception方法来处理捕获到的异常
9.不管是否出现异常,最后的返回值都通过finalize_response方法来处理响应的内容&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 24 Nov 2017 15:22:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/7892719.html</dc:identifier>
</item>
<item>
<title>RocketMQ快速入门 - 匠心零度</title>
<link>http://www.cnblogs.com/lirenzuo/p/7892593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lirenzuo/p/7892593.html</guid>
<description>&lt;p&gt;前面几篇文章介绍了为什么选择RocketMQ，以及与kafka的一些对比： &lt;a href=&quot;https://mp.weixin.qq.com/s/KfBruI-tOz-eJuM2fgqyew&quot;&gt;阿里 RocketMQ 优势对比&lt;/a&gt;，方便大家对于RocketMQ有一个简单的整体了解，之后介绍了：&lt;a href=&quot;https://mp.weixin.qq.com/s/PhUJoD5y9Fu7CxFSBmf29w&quot;&gt;MQ 应用场景&lt;/a&gt;，让我们知道MQ在什么时候可以使用，可以解决什么问题，之后介绍了：&lt;a href=&quot;http://mp.weixin.qq.com/s/SeN8cKPzjcOR4CRBYfzYGQ&quot;&gt;RocketMQ集群部署配置&lt;/a&gt;；本篇文章接着上篇内容之后，来给大家介绍下RocketMQ快速入门。&lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;h3 id=&quot;引入-rocketmq-client&quot;&gt;1、引入 rocketmq-client&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.&lt;span class=&quot;fu&quot;&gt;apache&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rocketmq&lt;/span&gt;&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;rocketmq-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;4.1.0&lt;/span&gt;-incubating&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;编写producer&quot;&gt;2、编写Producer&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt; DefaultMQProducer producer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DefaultMQProducer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;producer_demo&quot;&lt;/span&gt;);
       &lt;span class=&quot;co&quot;&gt;//指定NameServer地址&lt;/span&gt;
        producer.&lt;span class=&quot;fu&quot;&gt;setNamesrvAddr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;192.168.116.115:9876;192.168.116.116:9876&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//修改为自己的&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * Producer对象在使用之前必须要调用start初始化，初始化一次即可&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 注意：切记不可以在每次发送消息时，都调用start方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        producer.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();

        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;997892&lt;/span&gt;; i++) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//构建消息&lt;/span&gt;
                Message msg = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Message&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;TopicTest&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* Topic */&lt;/span&gt;,
                    &lt;span class=&quot;st&quot;&gt;&quot;TagA&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* Tag */&lt;/span&gt;,
                    (&lt;span class=&quot;st&quot;&gt;&quot;测试RocketMQ&quot;&lt;/span&gt; + i).&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(RemotingHelper.&lt;span class=&quot;fu&quot;&gt;DEFAULT_CHARSET&lt;/span&gt;)
                );

                &lt;span class=&quot;co&quot;&gt;//发送同步消息&lt;/span&gt;
                SendResult sendResult = producer.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(msg);

                System.&lt;span class=&quot;fu&quot;&gt;out.printf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s%n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, sendResult);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;);
            }
        }


producer.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;编写consumer&quot;&gt;3、编写Consumer&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Consumer Group,非常重要的概念，后续会慢慢补充&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
DefaultMQPushConsumer consumer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DefaultMQPushConsumer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;consumer_demo&quot;&lt;/span&gt;);
&lt;span class=&quot;co&quot;&gt;//指定NameServer地址，多个地址以 ; 隔开&lt;/span&gt;
consumer.&lt;span class=&quot;fu&quot;&gt;setNamesrvAddr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;192.168.116.115:9876;192.168.116.116:9876&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//修改为自己的&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 如果非第一次启动，那么按照上次消费的位置继续消费&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
consumer.&lt;span class=&quot;fu&quot;&gt;setConsumeFromWhere&lt;/span&gt;(ConsumeFromWhere.&lt;span class=&quot;fu&quot;&gt;CONSUME_FROM_FIRST_OFFSET&lt;/span&gt;);

consumer.&lt;span class=&quot;fu&quot;&gt;subscribe&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;TopicTest&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;);

consumer.&lt;span class=&quot;fu&quot;&gt;registerMessageListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MessageListenerConcurrently&lt;/span&gt;() {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ConsumeConcurrentlyStatus &lt;span class=&quot;fu&quot;&gt;consumeMessage&lt;/span&gt;(List&amp;lt;MessageExt&amp;gt; msgs,
    ConsumeConcurrentlyContext context) {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(MessageExt msg:msgs){
        String msgbody = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(msg.&lt;span class=&quot;fu&quot;&gt;getBody&lt;/span&gt;(), &lt;span class=&quot;st&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;  MessageBody: &quot;&lt;/span&gt;+ msgbody);&lt;span class=&quot;co&quot;&gt;//输出消息内容&lt;/span&gt;
        }
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ConsumeConcurrentlyStatus.&lt;span class=&quot;fu&quot;&gt;RECONSUME_LATER&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;//稍后再试&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ConsumeConcurrentlyStatus.&lt;span class=&quot;fu&quot;&gt;CONSUME_SUCCESS&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;//消费成功&lt;/span&gt;
    }
});


consumer.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();

System.&lt;span class=&quot;fu&quot;&gt;out.printf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Consumer Started.&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;说明&quot;&gt;4、说明&lt;/h3&gt;
&lt;p&gt;各位根据自己的环境，修改NamesrvAddr的值，我的集群请参考：&lt;a href=&quot;http://mp.weixin.qq.com/s/SeN8cKPzjcOR4CRBYfzYGQ&quot;&gt;RocketMQ集群部署配置&lt;/a&gt;。稍后通过RocketMQ管控台就可以看到之前搭建的多Master多Slave模式，异步复制集群模式。&lt;/p&gt;
&lt;h3 id=&quot;通过rocketmq管控台&quot;&gt;5、通过RocketMQ管控台&lt;/h3&gt;
&lt;p&gt;rocketmq-console-ng获取方式为：&lt;a href=&quot;https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console&quot;&gt;rocketmq-console-ng&lt;/a&gt;，之后通过mavne进行编译获取jar，命令如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mvn clean &lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; -Dmaven.test.skip=true
java -jar target/rocketmq-console-ng&lt;span class=&quot;fl&quot;&gt;-1.0.0&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;jar&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到rocketmq-console-ng-1.0.0.jar之后，找到rocketmq-console-ng-1.0.0.jar\BOOT-INF\classes\application.properties文件，根据自己的NamesrvAddr进行修改rocketmq.config.namesrvAddr的值。&lt;/p&gt;
&lt;p&gt;直接启动：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;java -jar rocketmq-console-ng&lt;span class=&quot;fl&quot;&gt;-1.0.0&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;jar&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-9e31a4c828df89f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;管控台&quot;/&gt;&lt;br/&gt;管控台是基于springboot的，的确springboot非常方便和非常火了，所以有必要去学习下springboot了（其实还是spring系列，所以spring也必要深入学习下），稍后通过管控台进行观察运行。&lt;/p&gt;
&lt;h3 id=&quot;运行观察&quot;&gt;6、运行观察&lt;/h3&gt;
&lt;p&gt;一个好的习惯是先运行Consumer，之后在运行Producer，之后通过rocketmq-console-ng管控台观察&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-53732248cf8e4bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;运行中截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行完成之后，的确broker-a的数据加上broker-b的数据量就等于我们发送的数据量，而且slave的数量也master的数量也是一致的，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-9507e06b57aaf0af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;运行完成&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看发送这些数据，2台机器的磁盘情况如下：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-6f5a9ee73f49ec9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;rocketmq1占用磁盘空间&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-3e99e4c95eacf2fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;rocketmq2占用磁盘空间&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到目前位置，关于RocketMQ快速入门就结束了，未完待续……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果读完觉得有收获的话，欢迎点赞加关注。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;个人公众号，欢迎关注，查阅更多精彩历史！！！&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-5f48f1430e958383.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;匠心零度公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 14:22:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lirenzuo/p/7892593.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core教程【一】关于Razor Page的知识 - liulun</title>
<link>http://www.cnblogs.com/liulun/p/7867452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liulun/p/7867452.html</guid>
<description>&lt;h2 id=&quot;关键文件和目录结构&quot;&gt;关键文件和目录结构&lt;/h2&gt;
&lt;p&gt;按照asp.net core WEB应用程序向导，创建一个工程之后&lt;/p&gt;
&lt;p&gt;你会发现如下几个目录和文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;wwwroot：放置网站的静态文件的目录&lt;/li&gt;
&lt;li&gt;Pages：放置razor页面的目录&lt;/li&gt;
&lt;li&gt;appsettings.json：是应用的配置文件&lt;/li&gt;
&lt;li&gt;bower.json：静态资源包管理的配置文件&lt;/li&gt;
&lt;li&gt;Program.cs：这个程序负责承载ASP.NET Core应用&lt;/li&gt;
&lt;li&gt;Startup.cs：初始化service的配置，初始化请求管道&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们单独说一下Pages目录&lt;/p&gt;
&lt;p&gt;_Layout.cshtml 是整个网站的母板文件，&lt;/p&gt;
&lt;p&gt;除了在这里写布局页面的代码外，&lt;/p&gt;
&lt;p&gt;你还可以把一些基础的样式和脚本放在这里，&lt;/p&gt;
&lt;p&gt;_ViewStart.cshtml 负责设置所有Razor页面都会用到的Layout属性，&lt;/p&gt;
&lt;p&gt;_ViewImports.cshtml 负责设置所有页面都会用到的指令，比如引入什么类库等&lt;/p&gt;
&lt;p&gt;_ValidationScriptsPartial.cshtml 负责引用验证脚本，比如jquery的validation组件&lt;/p&gt;
&lt;h2 id=&quot;数据库链接字符串放在哪儿&quot;&gt;数据库链接字符串放在哪儿&lt;/h2&gt;
&lt;p&gt;在appsettings.json文件中，你可以防止数据库链接字符串，比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; {
  &quot;Logging&quot;: {
    &quot;IncludeScopes&quot;: false,
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Warning&quot;
    }
  },
  &quot;ConnectionStrings&quot;: {
    &quot;MovieContext&quot;: &quot;Server=(localdb)\\mssqllocaldb;Database=Movie-1;Trusted_Connection=True;MultipleActiveResultSets=true&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConnectionStrings就是数据库链接字符串；&lt;/p&gt;
&lt;h2 id=&quot;在startup中依赖注入数据库链接上下文对象&quot;&gt;在Startup中依赖注入数据库链接上下文对象&lt;/h2&gt;
&lt;p&gt;在Startup.cs文件中，有一个ConfigureServices方法，你可以通过依赖注入的方式，加载数据库连接上下文，比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    // 需要引用如下两个类库
    // using RazorPagesMovie.Models;
    // using Microsoft.EntityFrameworkCore;

    services.AddDbContext&amp;lt;MovieContext&amp;gt;(options =&amp;gt;
        options.UseSqlServer(Configuration.GetConnectionString(&quot;MovieContext&quot;)));
    services.AddMvc();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：这里用到了Microsoft.EntityFrameworkCore，要先通过nuget包管理器，引入包，相关内容不作赘述；&lt;/p&gt;
&lt;p&gt;接下来你就可以写实体，完成相应数据的增删改查了；&lt;/p&gt;
&lt;h2 id=&quot;数据库表结构同步工具&quot;&gt;数据库表结构同步工具&lt;/h2&gt;
&lt;p&gt;往往我们写了实体类型，还需要把实体类型做成数据库结构，非常麻烦&lt;/p&gt;
&lt;p&gt;这里你可以用microsoft.visualstudio.web.codegeneration.design，这个包来完成相应的工作，相关的命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Microsoft.VisualStudio.Web.CodeGeneration.Design -Version 2.0.0
Add-Migration Initial
Update-Database&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行是安装这个工具包；&lt;/p&gt;
&lt;p&gt;第二行是根据DbContext所引用的实体类，生成数据库表结构的同步代码；&lt;/p&gt;
&lt;p&gt;第三行是更新数据库；&lt;/p&gt;
&lt;p&gt;这个工具包是不是只支持EF，还有待考察。&lt;/p&gt;
&lt;h2 id=&quot;razor页面的pagemodel类&quot;&gt;Razor页面的PageModel类&lt;/h2&gt;
&lt;p&gt;好，我们现在看看怎么通过数据库上下文把数据从数据库中拿出来&lt;/p&gt;
&lt;p&gt;在Pages目录下，创建一个Razor页面&lt;/p&gt;
&lt;p&gt;在相应的cshtml.cs文件中，撰写如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using System.Threading.Tasks;
using RazorPagesMovie.Models;


namespace RazorPagesMovie.Pages.Movies
{
    public class IndexModel : PageModel
    {
        private readonly RazorPagesMovie.Models.MovieContext _context;

        public IndexModel(RazorPagesMovie.Models.MovieContext context)
        {
            _context = context;
        }

        public IList&amp;lt;Movie&amp;gt; Movie { get;set; }

        public async Task OnGetAsync()
        {
            Movie = await _context.Movie.ToListAsync();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：Movie是与数据库表结构对应的实体类；&lt;/p&gt;
&lt;p&gt;Razor页面继承自PageModel类，按照约定，类名遵从Model这样的命名方式&lt;/p&gt;
&lt;p&gt;构造函数通过依赖注入获得数据库访问上下文实例；&lt;/p&gt;
&lt;h2 id=&quot;关于razor-page的页面代码&quot;&gt;关于Razor Page的页面代码&lt;/h2&gt;
&lt;p&gt;我们再来看看.cshtml文件的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page
@model RazorPagesMovie.Pages.Movies.IndexModel

@{
    ViewData[&quot;Title&quot;] = &quot;Index&quot;;
}

&amp;lt;h2&amp;gt;Index&amp;lt;/h2&amp;gt;

&amp;lt;p&amp;gt;
    &amp;lt;a asp-page=&quot;Create&quot;&amp;gt;Create New&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;table class=&quot;table&quot;&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;
                @Html.DisplayNameFor(model =&amp;gt; model.Movie[0].Title)
            &amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;
                @Html.DisplayNameFor(model =&amp;gt; model.Movie[0].ReleaseDate)
            &amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;
                @Html.DisplayNameFor(model =&amp;gt; model.Movie[0].Genre)
            &amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;
                @Html.DisplayNameFor(model =&amp;gt; model.Movie[0].Price)
            &amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody&amp;gt;
@foreach (var item in Model.Movie) {
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;
                @Html.DisplayFor(modelItem =&amp;gt; item.Title)
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                @Html.DisplayFor(modelItem =&amp;gt; item.ReleaseDate)
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                @Html.DisplayFor(modelItem =&amp;gt; item.Genre)
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                @Html.DisplayFor(modelItem =&amp;gt; item.Price)
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;a asp-page=&quot;./Edit&quot; asp-route-id=&quot;@item.ID&quot;&amp;gt;Edit&amp;lt;/a&amp;gt; |
                &amp;lt;a asp-page=&quot;./Details&quot; asp-route-id=&quot;@item.ID&quot;&amp;gt;Details&amp;lt;/a&amp;gt; |
                &amp;lt;a asp-page=&quot;./Delete&quot; asp-route-id=&quot;@item.ID&quot;&amp;gt;Delete&amp;lt;/a&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
}
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Razor引擎可以把上面这些HTML代码转成C#代码或者转成Razor过度代码；&lt;/p&gt;
&lt;p&gt;当一个 @ 符号后面跟的是Razor保留关键字的话，他会被转义成Razor过度代码，否则会被转义成C#代码；&lt;/p&gt;
&lt;p&gt;这是在编译期完成的工作，所以不会影响运行期的执行效率；&lt;/p&gt;
&lt;h2 id=&quot;关于page指令&quot;&gt;关于page指令&lt;/h2&gt;
&lt;p&gt;@page指令使得这个页面变成了一个ASP.NET MVC的Action&lt;/p&gt;
&lt;p&gt;这个指令必须是在Razor Page的第一个指令&lt;/p&gt;
&lt;h2 id=&quot;关于违法访问的处理&quot;&gt;关于违法访问的处理&lt;/h2&gt;
&lt;p&gt;来看看下面这行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Html.DisplayNameFor(model =&amp;gt; model.Movie[0].Title))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这行代码的特殊之处在于，不会存在违法访问的异常，&lt;/p&gt;
&lt;p&gt;也就是说model, model.Movie 和model.Movie[0] 的值是 null 或者empty时，不会报异常；&lt;/p&gt;
&lt;h2 id=&quot;关于model指令&quot;&gt;关于model指令&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@model RazorPagesMovie.Pages.Movies.IndexModel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个指令使得cshtml.cs文件中的IndexModel类，在这个Razor Page中有效&lt;/p&gt;
&lt;h2 id=&quot;关于viewdata&quot;&gt;关于ViewData&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@page
@model RazorPagesMovie.Pages.Movies.IndexModel

@{
    ViewData[&quot;Title&quot;] = &quot;Index&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以在Razor Page页面中设置ViewData的键值，在_Layout.cshtml模版页面中使用你设置的ViewData&lt;/p&gt;
&lt;h2 id=&quot;关于注释&quot;&gt;关于注释&lt;/h2&gt;
&lt;p&gt;在Razor Page中，用下面的方式写注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@*这里是注释*@&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于全局的模版页设置&quot;&gt;关于全局的模版页设置&lt;/h2&gt;
&lt;p&gt;在_ViewStart.cshtml文件中，我们为所有的页面设置了母板页，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@{
    Layout = &quot;_Layout&quot;;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 24 Nov 2017 13:54:00 +0000</pubDate>
<dc:creator>liulun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liulun/p/7867452.html</dc:identifier>
</item>
<item>
<title>input[type='file']样式美化及实现图片预览 - Shapeying</title>
<link>http://www.cnblogs.com/shapeY/p/7891636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shapeY/p/7891636.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　上传图片是常见的需求，多使用input标签。本文主要介绍 input标签的&lt;strong&gt;样式美化&lt;/strong&gt; 和 实现&lt;strong&gt;图片预览&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　用到的知识点有：&lt;/p&gt;
&lt;p&gt;　　　　1、input标签的使用&lt;/p&gt;
&lt;p&gt;　　　　2、filelist对象 和 file对象&lt;/p&gt;
&lt;p&gt;　　　　3、fileReader对象&lt;/p&gt;
&lt;h2&gt;样式美化&lt;/h2&gt;
&lt;p&gt;　　原生的input标签样式单一，且在不同浏览器下的表现还不一致。所以为了美观和统一，我们需要自定义input标签的样式。&lt;/p&gt;
&lt;p&gt;　　实现的方式有很多中，这里采用的是：用一个div将input标签包裹，然后再将input标签透明度设置为0，再对div设置自己需要的样式。html和css如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;upload-file&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;input-file&quot;&lt;/span&gt;&lt;span&gt; multiple&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;  // mulitiple属性控制是否允许上传多个文件&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tip&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点击上传图片&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_f2bf10a7-22bd-4ca1-9bfe-684d8bca1e3a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f2bf10a7-22bd-4ca1-9bfe-684d8bca1e3a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f2bf10a7-22bd-4ca1-9bfe-684d8bca1e3a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    .upload-file&lt;/span&gt;{&lt;span&gt;
      position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
      width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
      padding&lt;/span&gt;:&lt;span&gt; 10px 15px&lt;/span&gt;;&lt;span&gt;
      border&lt;/span&gt;:&lt;span&gt; 1px solid rgb(119, 154, 80)&lt;/span&gt;;&lt;span&gt;
      border-radius&lt;/span&gt;:&lt;span&gt; 5px&lt;/span&gt;;&lt;span&gt;
      background-color&lt;/span&gt;:&lt;span&gt; rgb(66, 215, 142)&lt;/span&gt;;&lt;span&gt;
      color&lt;/span&gt;:&lt;span&gt; #333333&lt;/span&gt;;&lt;span&gt;
      font-size&lt;/span&gt;:&lt;span&gt; 14px&lt;/span&gt;;&lt;span&gt;
      text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
      overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
    }&lt;span&gt;

    .upload-file span&lt;/span&gt;{&lt;span&gt; //单行显示
      text-overflow&lt;/span&gt;:&lt;span&gt; ellipsis&lt;/span&gt;;&lt;span&gt;
      white-space&lt;/span&gt;:&lt;span&gt; nowrap&lt;/span&gt;;&lt;span&gt;
      overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
    }&lt;span&gt;

    .upload-file:hover&lt;/span&gt;{&lt;span&gt; //简单的hover效果
      font-size&lt;/span&gt;:&lt;span&gt; 15px&lt;/span&gt;;&lt;span&gt;
      border-color&lt;/span&gt;:&lt;span&gt; rgb(39, 226, 81)&lt;/span&gt;;
    }&lt;span&gt;

    .upload-file input[type='file']&lt;/span&gt;{&lt;span&gt;
      height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
      width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
      position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt; //设置为绝对定位，不会影响到其他元素
      top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
      right&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
      opacity&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;   //透明度为0
      filter&lt;/span&gt;:&lt;span&gt; alpha(opacity=0)&lt;/span&gt;;&lt;span&gt;
      cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这样点击div，其实也就点击到了input标签，可已正常触发选择文件的。&lt;/p&gt;
&lt;p&gt;　　效果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201711/1072774-20171124170412109-664910185.png&quot; alt=&quot;&quot;/&gt;             &lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201711/1072774-20171124170654765-90207454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　但是这样就会产生一个问题，如何获取选择文件的文件名称呢？需要用到file对象的name属性&lt;/p&gt;
&lt;h2&gt;filelist和file对象--获取文件名&lt;/h2&gt;
&lt;p&gt;　　input元素选择文件后会返回FileList对象，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;input元素&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; fileInput = document.querySelector('.input-file'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;filelist对象&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; filelist =&lt;span&gt; fileInput.files&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;file对象&lt;/span&gt; &lt;p&gt;&lt;span&gt;var&lt;/span&gt; file = filelist.item(0)
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
或者 var file = filelist[0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们知道，每个input[type='file']都有一个files属性，返回的就是filelist 就和nodelist类似，不是数组。filelist就是由多个file对象组成的，每个file对象都是一个文件。&lt;/p&gt;
&lt;p&gt;　　filelist对象有个length属性，可以获取长度；还有item(index)方法，可以获取到file对象，当然可以通过 filelist[index]来获取。&lt;/p&gt;
&lt;p&gt;　　file对象常用的属性有：&lt;/p&gt;
&lt;p&gt;　　　　lastModified ： 返回当前 File 对象所引用文件最后修改时间， 自 1970年1月1日0:00 以来的毫秒数。&lt;br/&gt;　　　　lastModifiedDate : 返回当前 File 对象所引用文件最后修改时间的 Date 对象。&lt;br/&gt;　　　　name : 文件名。&lt;br/&gt;　　　　size : 文件大小。&lt;br/&gt;　　　　type ：文件类型。&lt;/p&gt;
&lt;p&gt;　　所以我们可以通过file对象的name属性来获取到文件名，在修改到span元素中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; fileInput = document.querySelector('.input-file'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tip = document.querySelector('.tip'&lt;span&gt;);
 
    fileInput.addEventListener(&lt;/span&gt;'change',&lt;span&gt;function&lt;/span&gt;(e){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听change事件，选择文件后触发&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.files.length === 1){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理文件名&lt;/span&gt;
        tip.textContent = &lt;span&gt;this&lt;/span&gt;.files[0&lt;span&gt;].name;
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        tip.textContent &lt;/span&gt;= '已选择 ' + &lt;span&gt;this&lt;/span&gt;.files.length + ' 个文件'&lt;span&gt;;
      }
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果如下：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201711/1072774-20171124204305203-2143366201.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201711/1072774-20171124204321359-1115252993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在已经自定义了input[type='file']的样式，而且实现了原有的功能。那么如何实现图片预览呢？&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;FileReader&lt;/strong&gt; 对象 --实现图片预览&lt;/h2&gt;
&lt;p&gt; 　　FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容。也就是说FIlereader对象可以读取到input选择的文件。filereader对象在读取file对象时，当读取完成时，readystate属性的值会变为DONE，会触发load事件。而且有多种读取方式：&lt;/p&gt;
&lt;p&gt;　　readAsBinaryString()读取完成后，result属性中包含原始数据的二进制数据，readAsDataURL()读取完成后，result属性中包含data:url格式的数据，readAsText()读取完成后，result属性中包含字符串格式的数据，readAsArrayBuffer()result属性中将包含一个ArrayBuffer对象以表示所读取文件的内容。&lt;/p&gt;
&lt;p&gt;　　这里上传的时图片，所以使用readAsDataURL()读取。现在html中加入个预览触发按钮，而预览图片存放的区域。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//简单结构 
     &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;preview&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;预览&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

//样式
    .preview{
      margin-top: 10px;
      width: 150px;
    }

    .preview img{
      margin: 5px 0;
      width: 100%;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现预览功能，注释中已有详细解释，不再重复。注意一定要等filereader读取完成后，再进行赋值，不然图片的src属性会是空的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
   
    &lt;span&gt;var&lt;/span&gt; preview = document.querySelector('.preview'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; previewBtn = preview.children[0&lt;span&gt;];

    previewBtn.addEventListener(&lt;/span&gt;'click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filelist =&lt;span&gt; fileInput.files;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(filelist.length &amp;lt; 1&lt;span&gt;){
        alert(&lt;/span&gt;&quot;未选择图片，无法预览&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      }

      [].slice.call(filelist).forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value,index){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历file对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fileReader = &lt;span&gt;new&lt;/span&gt; FileReader(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个filereader对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt; Image();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个图片对象&lt;/span&gt;
        fileReader.readAsDataURL(value)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取所上传对的文件&lt;/span&gt;
        fileReader.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          img.src &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.result;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取完成后，赋值给img对象&lt;/span&gt;
          preview.appendChild(img)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到预览区域&lt;/span&gt;
&lt;span&gt;        }
      })
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201711/1072774-20171124210109593-1717664342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　总结来说，就是  input[type='file']的files属性 --&amp;gt; filelist对象 --&amp;gt; file对象 --&amp;gt; filereader对象读取file对象。通过它们的一些参数值实现我们想要的功能。由于只是简单demo，不严谨的地方和丑陋的样式就多多包涵了。&lt;/p&gt;
&lt;p&gt;　　再下一步就是要上传图片到服务器了，会在下个随笔中记录。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 13:10:00 +0000</pubDate>
<dc:creator>Shapeying</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shapeY/p/7891636.html</dc:identifier>
</item>
<item>
<title>Ambari Auto Start(进程自动拉起) - luxianghao</title>
<link>http://www.cnblogs.com/luxianghao/p/7886850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luxianghao/p/7886850.html</guid>
<description>&lt;p&gt;   文章作者：luxianghao&lt;/p&gt;
&lt;p&gt;   文章来源：&lt;a href=&quot;http://www.cnblogs.com/luxianghao/p/7886850.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/luxianghao/p/7886850.html&lt;/a&gt;  转载请注明，谢谢合作。&lt;/p&gt;
&lt;p&gt;   免责声明：文章内容仅代表个人观点，如有不当，欢迎指正。&lt;/p&gt;
&lt;p&gt;   --- &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一 引言&lt;/strong&gt;&lt;br/&gt;Ambari作为一个集群管理工具自然不能少了进程自动拉起这个功能，具体的场景就是&lt;/p&gt;
&lt;p&gt;1 当你的进程异常挂掉后，Ambari自动将进程拉起，恢复服务，避免人为介入；&lt;br/&gt;2 当机器启动后你不用再一个一个的点击，拉起服务，避免繁琐的机械劳动；&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;总之它会努力变成你期望的样子^-^&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二 版本迭代&lt;/strong&gt;&lt;br/&gt;Ambari早期就有这个功能，在2.2 2.3 2.4等版本不断的迭代，使其不断的完善易用，早期相关配置在ambari.properties中，由于这种方式相关的配置属性是静态的，修改后需重启Ambari Server和Amabari Agent，后来迁移到了cluster-env.xml中，并录入数据库，在Web端也做了支持，当修改了相关配置也不用重启服务了，相关的修改会随着心跳信息从Ambari Server发送到Ambari agent。支持集群级别的总开关和组件粒度的开关，相关配置属性如下：&lt;br/&gt;recovery_enabled：集群级别自动拉起功能的开关&lt;br/&gt;recovery_type： 恢复功能的类型，不同类型会有不同的执行逻辑，如下表&lt;br/&gt;recovery_lifetime_max_count：自动拉起生命周期的最大次数，如果Ambari Agent重启这个值会被重置&lt;br/&gt;recovery_max_count：在一个时间窗口内，自动拉起动作的最大尝试次数，如果Ambari Agent重启这个值会被重置&lt;br/&gt;recovery_window_in_minutes：自动拉起功能的时间窗口长度&lt;br/&gt;recovery_retry_interval：两次重试之间的时间间隔&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;Attribute: recovery_type&lt;/td&gt;
&lt;td&gt;Commands&lt;/td&gt;
&lt;td&gt;State Transitions&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;AUTO_START&lt;/td&gt;
&lt;td&gt;Start&lt;/td&gt;
&lt;td&gt;INSTALLED → STARTED&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;FULL&lt;/td&gt;
&lt;td&gt;Install, Start, Restart, Stop&lt;/td&gt;
&lt;td&gt;INIT → INSTALLED, INIT → STARTED, INSTALLED → STARTED, STARTED → STARTED, STARTED → INSTALLED&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DEFAULT&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Auto start feature disabled&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;三 功能介绍 &amp;amp;&amp;amp; 代码逻辑&lt;/strong&gt;&lt;br/&gt;从&lt;a href=&quot;http://www.cnblogs.com/luxianghao/p/7886195.html&quot; target=&quot;_blank&quot;&gt;Ambari概览&lt;/a&gt;中的Ambari Server架构图中我们可以看到Ambari Server维护了一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA&quot; target=&quot;_blank&quot;&gt;FSM&lt;/a&gt;（有限状态机），记录了每个组件的desired state（Ambari Server期望的组件状态），Ambari Agent会实时的检测自己的宿主机上的服务的current state（当前状态），当desired state和current state不一致就会触发recovery，状态的迁移如上面的表格中所述，2.4版本中recovery_type我们一般使用AUTO START，最常见的场景就是INSTALLED--&amp;gt;STARTED状态的迁移，该事件的逻辑如下：&lt;/p&gt;&lt;p&gt;                                        &lt;img src=&quot;https://images2018.cnblogs.com/blog/688515/201711/688515-20171124204044078-805249628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 备注：组件正常运行时状态为STARTED，异常宕掉或正常停止后状态为INSTALLED。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上述状态迁移发生的前提是两个开关要打开，如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1 recovery_enabled = True&lt;br/&gt;2 enable components包含Service A&lt;br/&gt;3 当我们不想关上面两个开关但又想某个节点上的组件不启用自启动功能时，我们可以利用Maintenance模式，下面几种情况都会造成组件处于Maintenance模式&lt;br/&gt;a）组件被置为Maintenance模式&lt;br/&gt;b）组件所在主机被置为Maintenance模式&lt;br/&gt;c）组件所属服务被置为Maintenance模式&lt;br/&gt;d）组件所在主机所属的集群被置为Maintenance模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688515/201711/688515-20171123203632390-1748540361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;相关的源代码文件&lt;/span&gt;&lt;br/&gt;1 AmbariManagementControllerImpl.java&lt;br/&gt;2 ServiceComponentDesiredStateEntity.java&lt;br/&gt;3 ServiceComponentRecoveryChangedEvent.java&lt;br/&gt;4 RecoveryConfigHelper.java&lt;br/&gt;5 RecoveryManager.py&lt;br/&gt;6 Controller.py&lt;br/&gt;...&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关的服务log&lt;/span&gt;&lt;br/&gt;INFO 2017-11-21 12:16:24,210 RecoveryManager.py:243 - Service A needs recovery.&lt;br/&gt;INFO 2017-11-21 12:16:24,209 Controller.py:265 - Heartbeat response received (id = 15)&lt;br/&gt;INFO 2017-11-21 12:16:24,210 RecoveryManager.py:243 - Service A needs recovery.&lt;br/&gt;INFO 2017-11-21 12:16:24,210 RecoveryManager.py:798 - START command cannot be computed as details are not received from Server.&lt;br/&gt;INFO 2017-11-21 12:16:34,210 Heartbeat.py:82 - Building Heartbeat: {responseId = 15, timestamp = 1511237794210, commandsInProgress = False, componentsMapped = True,recoveryTimestamp = 1511237693282}&lt;br/&gt;INFO 2017-11-21 12:16:54,588 Controller.py:310 - Adding recovery command START for component Service A&lt;br/&gt;INFO 2017-11-21 12:16:54,589 ActionQueue.py:117 - Adding AUTO_EXECUTION_COMMAND for role Service A for service 360HIVE_THRIFT of cluster DRUID to the queue.&lt;br/&gt;INFO 2017-11-21 12:16:54,603 ActionQueue.py:195 - luxianghao process_command recovery_manager True.&lt;br/&gt;INFO 2017-11-21 12:16:54,604 ActionQueue.py:238 - Executing command with id = 1-0 for role = Service A of cluster DRUID.&lt;br/&gt;INFO 2017-11-21 12:16:54,705 Heartbeat.py:82 - Building Heartbeat: {responseId = 18, timestamp = 1511237814704, commandsInProgress = False, componentsMapped = True,recoveryTimestamp = 1511237693282}&lt;br/&gt;INFO 2017-11-21 12:16:54,854 Controller.py:265 - Heartbeat response received (id = 19)&lt;br/&gt;INFO 2017-11-21 12:16:58,982 ActionQueue.py:341 - After EXECUTION_COMMAND (START), current state of Service A to STARTED&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;相关patch&lt;/span&gt;&lt;br/&gt;AMBARI-15077：Auto-start services: Backend API and DB changes for component auto start&lt;br/&gt;AMBARI-14983：Auto-start services: Show list of Services/Component with status indicator&lt;br/&gt;AMBARI-14023：Agents should not ask for auto-start command details if it has the details (smohanty)&lt;br/&gt;AMBARI-13463：Auto start should allow selection of components that can be auto-started (smohanty)&lt;br/&gt;AMBARI-13434：Expose Alert Grace Period Setting in Agents (aonishuk)&lt;br/&gt;AMBARI-13954：Enable auto-start with alerting for AMS (dsen)&lt;br/&gt;AMBARI-14182: Recovery alerts do not go away&lt;br/&gt;AMBARI-14865: Auto start - Maintenance mode of components should be respected when handling agent registration&lt;br/&gt;AMBARI-15141: Start all services request aborts in the middle and hosts go into heartbeat-lost state&lt;br/&gt;AMBARI-15230: Auto-start services: Move default values in ambari.properties to cluster-env.xml&lt;br/&gt;AMBARI-15474: Listen for changes to auto-start configuration and send them to the agent during heartbeats.&lt;br/&gt;AMBARI-12517: Don't send install_packages command to hosts without versionable components&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四 类似工具&lt;/strong&gt;&lt;br/&gt;进程的自动拉起也可以用进程守护工具比如&lt;a href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot;&gt;Supervisor&lt;/a&gt;， &lt;a href=&quot;http://godrb.com/&quot; target=&quot;_blank&quot;&gt;God&lt;/a&gt;，不同的是这两者是用自己的daemon fork出子进程，通过监控子进程的方式获取进程状态的，而Ambari是通过pid或者端口监控的方式获取进程状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五 相关链接&lt;/strong&gt;&lt;br/&gt;WIKI： &lt;a href=&quot;https://cwiki.apache.org/confluence/display/AMBARI/Recovery%3A+auto+start+components&quot; target=&quot;_blank&quot;&gt;https://cwiki.apache.org/confluence/display/AMBARI/Recovery%3A+auto+start+components&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 12:52:00 +0000</pubDate>
<dc:creator>luxianghao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luxianghao/p/7886850.html</dc:identifier>
</item>
<item>
<title>一步一步搞懂支持向量机——从牧场物语到SVM（上） - oO上官麦兜Oo</title>
<link>http://www.cnblogs.com/liziran/p/7889996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liziran/p/7889996.html</guid>
<description>&lt;p&gt;&lt;span&gt;    之前在数据挖掘课程上写了篇关于SVM的“科普文”，尽量通俗地介绍了SVM的原理和对各公式的理解。最近给正在初学机器学习的小白室友看了一遍，他觉得“很好，看得很舒服”，认为不发到blog上太可惜=  =&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;em&gt;由于word转blog发布好麻烦，特别是图片什么的，所以我直接把文档转图片传上来好了（懒癌晚期）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    里面的许多内容都是参考网上的大牛博客而来的（已列在参考资料中），自己进行了梳理和汇总，并对一些晦涩难懂的地方进行了更进一步的理解和说明，所以写得很长，但对于小白来说仔细读的话说不定会有意外收获哦~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　博文分上下两篇，上篇简单介绍什么是SVM，并学习线性SVM；下篇相对进阶，学习非线性可分时用到的松弛变量和核函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（为了尽量通俗尽量简化，通篇涉及到的数学原理可能不会很严谨，还望见谅！）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124185649671-106475840.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124190804234-1774921813.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124185747218-322481968.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191020281-1688317260.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191041453-996778495.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191107312-1124039995.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191133187-1137543606.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191204375-1899698602.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191231859-39658004.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191244406-465983661.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124191258750-842919817.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202254906-1827950922.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202430250-1785556546.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202526750-389744385.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202545625-377224992.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202632078-1426681129.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202646843-321485259.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202716546-2139462070.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070510/201711/1070510-20171124202744218-184592660.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 Nov 2017 12:39:00 +0000</pubDate>
<dc:creator>oO上官麦兜Oo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liziran/p/7889996.html</dc:identifier>
</item>
<item>
<title>Python多进程编程 - gregory2017</title>
<link>http://www.cnblogs.com/gregoryli/p/7892222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/7892222.html</guid>
<description>&lt;p&gt;&lt;span&gt;一 多进程编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Python实现多进程的方式有两种：一种方法是os模块中的fork方法，另一种是使用multiprocessing模块。&lt;/p&gt;
&lt;p&gt;前者仅适用于LINUX/UNIX操作系统，对Windows不支持，后者则是跨平台的实现方式。&lt;/p&gt;
&lt;p&gt;第一种方式：使用os模块中的fork方式实现多进程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;current Process (%s) start ...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(os.getpid())
    pid &lt;/span&gt;=&lt;span&gt; os.fork()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid &amp;lt;&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error in fork&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; pid ==&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am child process(%s) and my parent process is (%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,(os.getpid(),os.getppid())
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I(%s) created a chlid process (%s).&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(os.getpid(),pid)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230529/201711/1230529-20171124190339296-1669756831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二种方式：multiprocessing&lt;/p&gt;
&lt;p&gt;由于GIL的存在，python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。Python提供了非常好用的多进程包multiprocessing，只需要定义一个函数，Python会完成其他所有事情。借助这个包，可以轻松完成从单进程到&lt;strong&gt;并发执行&lt;/strong&gt;的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。&lt;/li&gt;
&lt;li&gt;multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式 (因为它们占据的不是用户进程的资源)。&lt;/li&gt;
&lt;li&gt;多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Process.PID中保存有PID，如果进程还没有start()，则PID为None。&lt;/p&gt;
&lt;p&gt;window系统下，需要注意的是要想启动一个子进程，必须加上那句if __name__ == &quot;main&quot;，进程相关的要写在这句下面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建进程的类&lt;/strong&gt;：Process([group [, target [, name [, args [, kwargs]]]]])，target表示调用对象，args表示调用对象的位置参数元组。kwargs表示调用对象的字典。name为别名。group实质上不使用。&lt;br/&gt;&lt;strong&gt;方法&lt;/strong&gt;：is_alive()、join([timeout])、run()、start()、terminate()。其中，Process以start()启动某个进程。join()方法实现进程间的同步。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;__author: greg&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;date: 2017/9/19 23:52&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(name):
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name,time.ctime())

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    p_list&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
        p &lt;/span&gt;= Process(target=f, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
        p_list.append(p)
        p.start()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
        i.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;一个主进程，三个子进程&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; output:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello alvin Fri Nov 24 19:10:08 2017&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello alvin Fri Nov 24 19:10:08 2017&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello alvin Fri Nov 24 19:10:08 2017&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类式调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;__author: greg&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;date: 2017/9/21 20:02&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyProcess(Process):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        super(MyProcess, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self.name = name&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.name,time.ctime())&lt;br/&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    p_list&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
        p &lt;/span&gt;=&lt;span&gt; MyProcess()
        p.start()
        p_list.append(p)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
        p.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;output:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello MyProcess-1 Fri Nov 24 19:12:17 2017&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello MyProcess-2 Fri Nov 24 19:12:17 2017&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hello MyProcess-3 Fri Nov 24 19:12:17 2017&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示进程ID号：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;__author: greg&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;date: 2017/9/21 20:16&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; info(title):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(title)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;module name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent process:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, os.getppid())&lt;span&gt;#&lt;/span&gt;&lt;span&gt;父进程号&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;process id:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, os.getpid())&lt;span&gt;#&lt;/span&gt;&lt;span&gt;进程号&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(name):
    info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[31;1mfunction f\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1mmain process line\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    time.sleep(&lt;/span&gt;10&lt;span&gt;)
    p &lt;/span&gt;= Process(target=info, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
    p.start()
    p.join()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;output:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; main process line&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; module name: __main__&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; parent process: 1548 pycharm的进程号&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; process id: 8416  Python进程号&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; bob&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; module name: __mp_main__&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; parent process: 8416  Python进程号&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; process id: 5556  info进程号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;二 Process类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;构造方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Process([group [, target [, name [, args [, kwargs]]]]])&lt;/p&gt;
&lt;p&gt;　　group: 线程组，目前还没有实现，库引用中提示必须是None； &lt;br/&gt;　　target: 要执行的方法； &lt;br/&gt;　　name: 进程名； &lt;br/&gt;　　args/kwargs: 要传入方法的参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　is_alive()：返回进程是否在运行。&lt;/p&gt;
&lt;p&gt;　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。&lt;/p&gt;
&lt;p&gt;　　start()：进程准备就绪，等待CPU调度&lt;/p&gt;
&lt;p&gt;　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。&lt;/p&gt;
&lt;p&gt;　　terminate()：不管任务是否完成，立即停止工作进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　authkey&lt;/p&gt;
&lt;p&gt;　　daemon：和线程的setDeamon功能一样&lt;/p&gt;
&lt;p&gt;　　exitcode(进程在运行时为None、如果为–N，表示被信号N结束）&lt;/p&gt;
&lt;p&gt;　　name：进程名字。&lt;/p&gt;
&lt;p&gt;　　pid：进程号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三 进程间通讯&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同进程间内存是不共享的，要想实现两个进程间的数据交换，可以用以下方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Queues 用来在多个进程间通信&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1. 阻塞模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

q &lt;/span&gt;= queue.Queue(10) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个队列&lt;/span&gt;
start=&lt;span&gt;time.time()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
time.sleep(&lt;/span&gt;0.5&lt;span&gt;)
end&lt;/span&gt;=&lt;span&gt;time.time()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(end-start)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一段极其简单的代码（另有两个线程也在操作队列q），我期望每隔0.5秒写一个'A'到队列中，但总是不能如愿：&lt;br/&gt;间隔时间有时会远远超过0.5秒。&lt;br/&gt;原来，Queue.put（）默认有 block = True 和 timeout两个参数。&lt;br/&gt;源码：def put(self, item, block=True, timeout=None):&lt;br/&gt;当 block = True 时，写入是阻塞式的，阻塞时间由 timeout确定。&lt;br/&gt;当队列q被（其他线程）写满后，这段代码就会阻塞，直至其他线程取走数据。&lt;br/&gt;Queue.put()方法加上 block=False 的参数，即可解决这个隐蔽的问题。&lt;br/&gt;但要注意，非阻塞方式写队列，当队列满时会抛出 exception Queue.Full 的异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;__author: greg&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;date: 2017/9/21 22:27&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Queue

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(q,n):
    q.put([&lt;/span&gt;42, n, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;subprocess id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,id(q))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    q &lt;/span&gt;=&lt;span&gt; Queue()
    p_list&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;process id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,id(q))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
        p &lt;/span&gt;= Process(target=f, args=&lt;span&gt;(q,i))
        p_list.append(p)
        p.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
        i.join()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; output&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; process id 2284856854176&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; subprocess id 2607348001872&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; [42, 0, 'hello']&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; subprocess id 1712786975824&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; [42, 2, 'hello']&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; subprocess id 2254764977120&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; [42, 1, 'hello']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Pipe常用来两个进程间进行通信，两个进程分别位于管道的两端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(conn):
    conn.send([&lt;/span&gt;42, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    conn.close()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    parent_conn, child_conn &lt;/span&gt;=&lt;span&gt; Pipe()
    p &lt;/span&gt;= Process(target=f, args=&lt;span&gt;(child_conn,))
    p.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(parent_conn.recv())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; prints &quot;[42, None, 'hello']&quot;&lt;/span&gt;
    p.join()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。&lt;/p&gt;

&lt;p&gt;send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError。 &lt;/p&gt;
&lt;div readability=&quot;41.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;__author: greg&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;date: 2017/9/21 22:57&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; multiprocessing
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,os

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; proc_send(pipe,urls):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urls:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Process(%s) send: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(os.getpid(),url))
        pipe.send(url)
        time.sleep(random.random())

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; proc_recv(pipe):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Process(%s) rev:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(os.getpid(),pipe.recv()))
        time.sleep(random.random())

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    pipe&lt;/span&gt;=&lt;span&gt;multiprocessing.Pipe()
    p1&lt;/span&gt;=multiprocessing.Process(target=proc_send,args=(pipe[0],[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;str(i)
                                                      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;)]))
    p2&lt;/span&gt;=multiprocessing.Process(target=proc_recv,args=(pipe[1&lt;span&gt;],))
    p1.start()
    p2.start()
    p1.join()
    p2.terminate()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Manager（）返回的管理器对象控制一个服务器进程，该进程持有Python对象，并允许其他进程使用代理来操纵它们。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;__author: greg&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;date: 2017/9/21 23:10&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Manager
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(d, l,n):
    d[n] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    d[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 2&lt;span&gt;
    d[&lt;/span&gt;0.25] =&lt;span&gt; None
    l.append(n)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(l)&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    with Manager() as manager:
        d &lt;/span&gt;=&lt;span&gt; manager.dict()
        l &lt;/span&gt;= manager.list(range(5&lt;span&gt;))
        p_list &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
            p &lt;/span&gt;= Process(target=f, args=&lt;span&gt;(d, l,i))
            p.start()
            p_list.append(p)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; res &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
            res.join()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四 进程同步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;__author: greg&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;date: 2017/9/21 23:25&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Lock

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(l, i):
    l.acquire()
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i)
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        l.release()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    lock &lt;/span&gt;=&lt;span&gt; Lock()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        Process(target&lt;/span&gt;=f, args=(lock, num)).start()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五 进程池 Pool类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pool可以提供指定数量的进程供用户使用，默认大小是CPU的核数。当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程来执行该请求&lt;/p&gt;
&lt;p&gt;但如果池中的进程数已经达到规定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来处理它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2017/11/24 20:15&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os, time, random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run_task(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Task %s (pid = %s) is running...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (name, os.getpid()))
    time.sleep(random.random() &lt;/span&gt;* 3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Task %s end.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Current process %s.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; os.getpid())
    p &lt;/span&gt;= Pool(processes=3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        p.apply_async(run_task, args&lt;/span&gt;=&lt;span&gt;(i,))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Waiting for all subprocesses done...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    p.close()
    p.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;All subprocesses done.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
Current process 9788.
Waiting for all subprocesses done...
Task 0 (pid = 5916) is running...
Task 1 (pid = 3740) is running...
Task 2 (pid = 6964) is running...
Task 2 end.
Task 3 (pid = 6964) is running...
Task 1 end.
Task 4 (pid = 3740) is running...
Task 0 end.
Task 3 end.
Task 4 end.
All subprocesses done.
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;apply_async(func[, args[, kwds[, callback]]]) 它是&lt;strong&gt;非阻塞&lt;/strong&gt;，apply(func[, args[, kwds]])是&lt;strong&gt;阻塞&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;close()    关闭pool，使其不在接受新的任务。&lt;/li&gt;
&lt;li&gt;terminate()    结束工作进程，不在处理未完成的任务。&lt;/li&gt;
&lt;li&gt;join()    主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每次最多运行3个进程，当一个任务结束了，新的任务依次添加进来，任务执行使用的进程依然是原来的进程，这一点通过进程的pid可以看出来。&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Fri, 24 Nov 2017 12:24:00 +0000</pubDate>
<dc:creator>gregory2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/7892222.html</dc:identifier>
</item>
<item>
<title>Linux系列教程（二十四）——Linux的系统管理 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7828393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7828393.html</guid>
<description>&lt;p&gt;　　上篇博客介绍了Linux的服务管理，不管是以RPM包安装的服务，还是通过源码包安装的服务，万能启动服务的方法都可以通过 /绝对路径/启动脚本名 start 。而通过 RPM 包安装的服务还可以通过 service 命令来启动，造成RMP包和源码包启动服务的根本区别就是它们安装服务的位置差异造成的，RPM包安装是有默认的位置的，而源码包安装则需要自己手动指定位置，一般是在/usr/local。那么介绍完Linux的服务管理，本篇博客我们介绍Linux的系统管理。&lt;/p&gt;
&lt;h3&gt;1、进程管理&lt;/h3&gt;
&lt;p&gt;　　进程简单来说就是系统中正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。&lt;/p&gt;
&lt;p&gt;　　通过管理进程，我们做的主要工作是：&lt;/p&gt;
&lt;p&gt;　　①、判断服务器健康状态。&lt;/p&gt;
&lt;p&gt;　　②、查看系统中的所有进程。&lt;/p&gt;
&lt;p&gt;　　③、杀死进程。&lt;/p&gt;
&lt;h3&gt;2、查看系统中的所有进程:ps aux&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115081706640-350908811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115081901171-21739648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　每一列解释如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115081810937-1855772421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115081821999-649266604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、查看系统健康状态：top&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082048781-643479730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082029374-1096930472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082107421-1060684288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082118890-2064743802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082132156-452432056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082148999-817689300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082159421-1648028883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、查看进程数：pstree&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082259702-43887548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082251515-374845869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、终止进程:kill&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;①、查看可用的进程信号：kill -l&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082607718-776168614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082630202-206194203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、根据进程 pid 杀死进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;kill -15 进程号    默认正常结束进程，其中选项 -15 可以省略。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115082652093-1463856193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、根据进程名 杀死进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115083231468-1124058276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115083256421-685756806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115203859093-392665531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;6、将进程放入后台运行&lt;/h3&gt;
&lt;p&gt;　　①、在命令后加 &amp;amp;，使得命令在后台运行&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115204600452-1270690400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②、快捷键 Ctrl+z ，使得命令在后台暂停&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115204637343-1723830405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7、查看后台的工作&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115204716874-1262542761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;8、将后台暂停的工作号恢复到前台执行&lt;/h3&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115204921218-1263836561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;9、将后台暂停的工作号恢复到后台执行&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115204930390-1368972565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;10、监控系统资源：vmstat&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115215851718-1729792589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115215949062-1205398692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;11、查看硬件信息 dmesg&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115220055765-1364205893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115220112312-304472324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　还有个命令也可以查看 CPU 信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
cat /proc/cpuinfo
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;12、查看系统与内核相关信息 uname&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115220802656-187445384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;13、查看当前系统位数 file&lt;/h3&gt;
&lt;p&gt;　　通过 file 命令查看任意一个外部命令的信息，比如 file /bin/ls&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171115221000171-960705926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
</description>
<pubDate>Fri, 24 Nov 2017 12:11:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7828393.html</dc:identifier>
</item>
</channel>
</rss>