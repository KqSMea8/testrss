<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringMVC类型转换，验证（四） - Miya。</title>
<link>http://www.cnblogs.com/SimpleWu/p/9713536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9713536.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;第三章&quot; href=&quot;https://www.cnblogs.com/SimpleWu/p/9702984.html&quot; target=&quot;_blank&quot;&gt;点击阅读上一章&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Spring mvc 数据绑定流程：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;SpringMvc将ServletRequest对象及目标方法的形参实例传给WebDataBinderFactory实例，以创建DataBinder实例对象。DataBinder调用装配在SpringMvc上下文中的ConversionService组件进行类型转换和数据格式化工作，将Servlet请求信息填充到形参对象中。调用Validator主键对已经绑定了请求信息的形参对象精选数据有效性验证，并最终生成数据绑定结果BindingData对象。SpringMVC抽取BindingResult中的形参对象和校验错误对象，将他们赋给处理方法的相应参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们查看源代码可以看到，通过WebDataBinderFactory创建DataBinder对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201809/1462123-20180927152702111-1608734574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;自定义类型转换器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;当我们碰到一些特殊场合，有可能需要我们自己定义类型转换器。下麦呢来讲解一个自定义类型转器，将字符串转换成emp对象，当页面无法完成数据绑定或者类型转换时，springmvc会抛出异常，异常信息可以使用BindingResult来进行获取。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Spring定义了三种类型的转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到ConversionServiceFactoryBean中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Convertre&amp;lt;S,T&amp;gt;:将S类型转换为T类型。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ConverterFactory：将相同系类的多个“同质”Converter封装在一起，如果希望一种类型转换成另一种类型以及子类对象（例如String转换成Number以Number的子类），可以使用该转换器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;GenericConverter：会根据源类对象以及目标类对象所在的宿主类中的上下文信息精选类型转换。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.spring.mvc.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.convert.converter.Converter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserConverter &lt;span&gt;implements&lt;/span&gt; Converter&amp;lt;String, User&amp;gt;&lt;span&gt;{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User convert(String source) {
        System.out.println(source);
        String users [] &lt;/span&gt;= source.split(&quot;-&quot;&lt;span&gt;);
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUno(Integer.valueOf(users[&lt;/span&gt;0&lt;span&gt;]));
        user.setUsername(users[&lt;/span&gt;1&lt;span&gt;]);
        user.setUserpass(users[&lt;/span&gt;2&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ConversionService时SpringMVC中类型转换器的核心接口，要添加自定义类型转换器，需要实现该接口/利用ConversionServiceFactoryBean在Spring的IOC容器中第一一个ConversionService，并在Bean属性配置对于的类型转换器的实现类，SpringMvc处理方法的形参绑定时就会自动调用该类型转换器。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;将非mapping配置下的请求交给默认的Servlet来处理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:default-servlet-handler &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;conversionService&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;converters&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;userConverter&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册类型转换器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven &lt;/span&gt;&lt;span&gt;conversion-service&lt;/span&gt;&lt;span&gt;=&quot;conversionService&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在实际的开发同需要配置：&amp;lt;mvc:annotation-driven /&amp;gt;标签&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据格式化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对属性的输入/输出格式化，其本质来讲依然属于类型转换的范畴。Spring在格式化模块中定义一个实现ConversionService接口的FarmattingConversionService实现类，该实现类扩展了GenericConversionService，因此它既具有类型转换的功能有具有格式化的功能。FormattingConversionService拥有一个FormattingConversionServiceFactoryBean工厂类，后者用于构造前者。我们要注册这个&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven &lt;/span&gt;&lt;span&gt;conversion-service&lt;/span&gt;&lt;span&gt;=&quot;FormattingConversionServiceFactoryBean&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JSR303&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jsr303时java为bean数据合法性校验提供的标准框架，它已经包含在JavaEE6.0中，JSR303通过在Bean属性上标注类似@NotNull，@Max等标准的数据指定验证规则，并通过标注的验证接口对Bean进行验证。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@NotEmpty
    @NotNull
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    @NotNull
    @NotEmpty
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String age;
    
    @NotNull
    @NotEmpty
    @Email
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String email;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;我们在前台使用SpringMVC提供的Form标签使用Form：errors path 绑定属性即可&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@RequestMapping(value=&quot;/student&quot;,method=&lt;span&gt;RequestMethod.POST)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(@Valid()Student student,BindingResult result){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!result.hasErrors()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否有格式转换错误或者其他校验没通过&lt;/span&gt;
&lt;span&gt;            userService.addStudent(student);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;redirect:list&quot;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &quot;addPage&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;SpringMvc提示消息国际化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册国际化信息，必须有id，指定资源文件名称，资源文件在src目录下 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;messageSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;basename&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201809/1462123-20180927155011488-2094275781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 27 Sep 2018 07:51:00 +0000</pubDate>
<dc:creator>Miya。</dc:creator>
<og:description>点击阅读上一章 Spring mvc 数据绑定流程： SpringMvc将ServletRequest对象及目标方法的形参实例传给WebDataBinderFactory实例，以创建DataBinde</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9713536.html</dc:identifier>
</item>
<item>
<title>算法系列教程04 - 算法相关的基础概念 - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/algorithms-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/algorithms-04.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191097/201809/191097-20180927153646535-1327400072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面几篇讲的都是一些背景知识，从这一篇开始我们正式讲算法，从算法的一些基本概念讲起。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;什么是算法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过上一篇对图灵机原理的讲解，我们知道，一个计算问题描述的是输入/输出之间的关系，如果根据给定的输入能设计一个程序计算出期望的输出，就认为这个问题可解。这个程序的计算过程就是用算法来描述的，通过算法这个工具我们就容易设计出这样的一个程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;确切地说，&lt;/span&gt;&lt;span&gt;算法&lt;/span&gt;&lt;span&gt;是有限步骤的计算过程，该过程取某个值或集合作为输入，并产生某个值或集合作为输出。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;算法的正确与错误&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果算法对于每个输入都可以正确的停机，则称该算法是正确的，并称正确的算法解决了给定的计算问题。一个不正确的算法对于某个输入可能根本不停机，也可能以不正确的结果停机，比如一个排序问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：一个长度为n的数组(a1,a2,a3...)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出：输入数组排序后的一个数组(b1,b2,b3....)，满足：b1≤b2≤b3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果根据这个问题设计出来的算法交给图灵机运行输出的结果与人们的期望相反（比如输出：b3,b2,b1…），那么这个算法就是错误的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;随机访问机模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;针对同一计算问题，可以设计出多种算法，其中有好有坏，我们可以通过预测算法需要的资源来筛选出好的算法。虽然有时我们关心内存、带宽这类硬件资源，但通常我们度量的是运行时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;度量算法的运行时间，人们通常用的是&lt;/span&gt;&lt;span&gt;随机访问机模型&lt;/span&gt;&lt;span&gt;（Random-Access Machine, RAM）。在 RAM 模型中：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;指令一条接着一条执行的，没有并发操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;指令包含了真实计算机的常见指令：算数指令（加法，减法，乘法，除法，取余等）、数据移入指令（装入，存储，复制）和控制命令（条件与无条件转移、子程序调用与返回）;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;每条指令所用的时间均为常量。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;RAM 模型假定的观点是，运行每行伪代码所需的时间是一个常量时间，虽然真实计算机执行一行代码与另一行代码需要不同的常量时间。依此，一个算法在特定输入上的运行时间不是指现实意义的时间，而是执行指令的次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如下面这段 foo 函数的代码：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++) {   &lt;span&gt;// 2n+1 次&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;'Hello, World!'&lt;/span&gt;)  &lt;span&gt;// n 次&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;                        &lt;span&gt;// 1 次&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;上面的代码需要执行 2n + 1 + n + 1 = 3n + 2 次指令，也就是说执行时间是 3n + 2，如果用一个时间函数来表示，就是 T(n) = 3n + 2。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;算法的时间复杂度&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据 RAM 模型，一个算法可以在给定的输入规模 n 下分析出一个运行时间的函数 T(n)。研究 T(n) 常用的一种策略是分析输入规模 n 增大的情况下 T(n) 的变化（如线性增长、指数增长等）。如果用 f(n) 来表示 T(n) 的增长速度，那么 f(n) 和 T(n) 的关系我们约定用一个大O来表示，即：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;T(n) = O(f(n))&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这就是&lt;/span&gt;&lt;span&gt;大O表示法&lt;/span&gt;&lt;span&gt;。由于输入规模 n 的增长率与 f(n) 的增长率是正相关的，所以称作&lt;/span&gt;&lt;span&gt;渐近时间复杂度&lt;/span&gt;&lt;span&gt;（Asymptotic Time Complexity），简称&lt;/span&gt;&lt;span&gt;时间复杂度&lt;/span&gt;&lt;span&gt;。相对应的，还有空间复杂度，这里我们不作讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当 n 足够大时或趋于无穷大时，T(n) 的常数部分就变得不重要，我们真正关心的是运行时间的&lt;/span&gt;&lt;span&gt;增长量级&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;增长率&lt;/span&gt;&lt;span&gt;。如果用 f(n) 来表示增长数度，上面 foo 示例代码的增长速度可以表示为 f(n) = n，把它代入到 T(n) = O(f(n)) 就是：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;T(n) = O(n)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这时，我们称 foo 的时间复杂度为 O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见的时间复杂度有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率也越低。大O表示法只是一种估算，当输入规模足够大的时候才有意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，大O表示法考虑的是最坏的情况。比如，从一个长度为 n 的数组中找一个值等于 10 的元素，开始遍历扫描这个数组，有可能第 1 次就扫到了，也有可能是第 n 次才扫到。这里最坏的情况是 n 次，所以时间复杂度就是 O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大部分情况下你用直觉就可以知道一个算法的大O表示。比如，如果用一个循环遍历输入的每个元素，那么这个算法就是 O(n)；如果是用循环套循环，那就是 O(n^2)，以此类推。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：《算法导论，第三版》&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 07:43:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>前面几篇讲的都是一些背景知识，从这一篇开始我们正式讲算法，从算法的一些基本概念讲起。 什么是算法 通过上一篇对图灵机原理的讲解，我们知道，一个计算问题描述的是输入/输出之间的关系，如果根据给定的输入能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/algorithms-04.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离 [ vue + .netcore 补程 ] 三十一║ Nuxt终篇：基于Vuex的权限验证探究 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9713219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9713219.html</guid>
<description>&lt;p&gt;哈喽大家好，今天周四啦，楼主明天要正式放假了，这里先祝大家节日快乐咯，希望在家里能继续研究点儿东西吧，今天呢是 nuxt 的最后一篇，主要是对权限登陆进行研究，这一块咱们之前在说第一个项目的时候已经稍微说到了，具体的逻辑大家可以查看这篇文章《&lt;a id=&quot;post_title_link_9658019&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9658019.html&quot;&gt;二十四║ Vuex + JWT 实现授权验证登陆&lt;/a&gt;》，具体的运行原理和流程，以及什么是 vuex ，在那里已经说的很清楚了，今天咱们就是主要在 nuxt 框架中使用，主要的代码的形式，理论知识比较少了，大家可以歇一歇了。这几天写了这么多，好多人可能都没看，不过没关系，继续回顾：&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9682289&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9682289.html&quot;&gt;二七║ Nuxt 基础：框架初探&lt;/a&gt;》：通过 SSR 来引入 nuxt 框架，第一次接触到该框架；&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9687504&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9687504.html&quot;&gt;二八║ Nuxt 基础：面向源码研究Nuxt.js&lt;/a&gt;》：通过研究 node_modules 中的源码，带领大家一步步了解 nuxt 是如何进行服务端渲染的；&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9697450&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9697450.html&quot;&gt;二九║ Nuxt实战：异步实现数据双端渲染&lt;/a&gt;》：通过首页的数据加载，更加深刻的了解到 nuxt 的双端渲染，异步很重要；&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9702677&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9702677.html&quot;&gt; 三十║ Nuxt实战：动态路由+同构&lt;/a&gt;》：通过首页和详情页的交互，进一步巩固 nuxt 的渲染模式和动态路由效果。&lt;/p&gt;
&lt;p&gt;从上边大家可以看到，几乎每一篇都会说到 nuxt 这个框架的渲染模式，这个很重要，更是对 vue 的巩固。好啦，马上开始今天的讲解~&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180927135056050-1445788915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 今天呢，咱们换一种玩儿法，就是将我们的详情页给增加一个权限，首页的数据大家都可以随便看，但是详情页却不能随便看，必须要登陆，那我们就需要在我们的详情页增加一个权限，&lt;/p&gt;
&lt;p&gt;如果 token 存在，则发送请求验证，如果不存在，直接跳转到登录页，那我们首先要添加一个登录页&lt;/p&gt;
&lt;h3&gt;添加登录页，获取token&lt;/h3&gt;
&lt;p&gt; 在 pages页面文件夹下，新建login 文件夹，然后添加 index.vue 登陆页面，&lt;/p&gt;
&lt;p&gt;这一块逻辑和我们之前的很像，大家可以参考着做对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180927144146408-1769686241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;el-row type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; justify=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;el-card v-&lt;span&gt;if&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isLogin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
      欢迎：admins
      &lt;/span&gt;&amp;lt;br&amp;gt;
      &amp;lt;br&amp;gt;
      &amp;lt;el-button type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;primary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; icon=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el-icon-upload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; @click=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginOut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;退出登录&amp;lt;/el-button&amp;gt;
    &amp;lt;/el-card&amp;gt;
    &amp;lt;el-form v-&lt;span&gt;else&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; :model=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; :rules=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; status-icon label-width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;el-form-item label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;账号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; prop=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;el-input v-model=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/el-input&amp;gt;
      &amp;lt;/el-form-item&amp;gt;
      &amp;lt;el-form-item label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; prop=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;el-input v-model=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.pass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/el-input&amp;gt;
      &amp;lt;/el-form-item&amp;gt;
      &amp;lt;el-form-item&amp;gt;
        &amp;lt;el-button type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;primary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; icon=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el-icon-upload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; @click=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;登录&amp;lt;/el-button&amp;gt;
      &amp;lt;/el-form-item&amp;gt;
    &amp;lt;/el-form&amp;gt;
  &amp;lt;/el-row&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
  import Vue &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
      methods: {
        login: function() {
          let that &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
          that.$store.commit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;saveToken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.loginForm.validate(valid =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (valid) {
&lt;/span&gt;&lt;span&gt;             //&lt;/span&gt;&lt;span&gt;发送请求登陆，这里要注意下返回数据格式，如果有问题，参考 http.js 中的 response 设置&lt;/span&gt;
              Vue.http.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Login/GetTokenNuxt?name=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+that.user.name+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;pass=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+that.user.name+&lt;span&gt;&quot;&quot;&lt;/span&gt;).then(res =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.success) {
                    console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登陆成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token =&lt;span&gt; res.token;
                    that.$store.commit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;saveToken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, token);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$notify({
                      type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                      message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;欢迎你,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.user.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                      duration: &lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;
                    });
                  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$router.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
              }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;点赞失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, err);
              });
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
          });
        },
        loginOut(){
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isLogin=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.commit(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;saveToken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
        }
      },
      data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
          isLogin:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
          user: {},
          rules: {
            name: [{ required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, message: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, trigger: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blur&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }],
            pass: [{ required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, message: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密码不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, trigger: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blur&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }]
          }
        };
      },
      created() {
      }
    }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 自定义 elementUI 插件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180927144016427-1450485543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;提醒：这里我用到了 elementUI ，请安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm i element-ui -S
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功后，作为插件使用，如果你不是很了解，请访问官网《&lt;a class=&quot;Affix__List__Item__Link nuxt-link-exact-active nuxt-link-active nuxt-link-active&quot; href=&quot;https://zh.nuxtjs.org/guide/plugins&quot; data-v-46b63b25=&quot;&quot;&gt;插 件&lt;/a&gt;》一章节，这里说的很清楚，我在之前的文件中也有提到。&lt;/p&gt;
&lt;p&gt; 在 plugins/server_site 文件夹下，新增 ElementUI.js 文件，作为我们的插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ElementUI &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;element-ui&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Vue.use(ElementUI)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后把这个 js 插件导入到 index.js 中，和 http.js一起注入到nuxt.config.js 中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是 server_site 服务端插件全部&lt;/span&gt;
import Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import http &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./http.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./ElementUI.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入 elementUI插件&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt; install = function (VueClass, opts =&lt;span&gt; {}) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http method&lt;/span&gt;
    VueClass.http =&lt;span&gt; http;
    VueClass.prototype.$http &lt;/span&gt;=&lt;span&gt; http;
};
Vue.use(install);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我们是把服务端的插件都打包了 server_site 下的index中，所以我们以后不用每一个都注入到我们的配置文件 nuxt.config.js 中，只需要将 服务端插件 一个放进去即可，但是样式还是需要引用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180927145322669-637212241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;在 strore 文件夹中，添加 index.js 文件，设置我们的store数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180927144032395-2000380218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
import Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import Vuex &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vuex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

Vue.use(Vuex);

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; store = () =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
    state: {
      isLogined: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      token: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里主要是用到了 token&lt;/span&gt;
&lt;span&gt;      userInfo: {
            name: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        },
        loginBoxVisible: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    },
    mutations: {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存 token 到 store和本地中&lt;/span&gt;
&lt;span&gt;      saveToken(state, data) {
        state.token &lt;/span&gt;=&lt;span&gt; data;
        window.localStorage.setItem(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, data);
      },
        changeLoginState (state, isLogined) {
            state.isLogined &lt;/span&gt;=&lt;span&gt; isLogined;
        },
        changeLoginBoxVisible (state, visible) {
            state.loginBoxVisible &lt;/span&gt;=&lt;span&gt; visible;
        },
        updateUserInfo (state, userInfo) {
            state.userInfo &lt;/span&gt;=&lt;span&gt; userInfo;
        }
    },
    actions: {
        initUser ({ state, commit }) {
            &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; user = JSON.parse(localStorage.getItem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (user) {
                state.userInfo &lt;/span&gt;=&lt;span&gt; user;
                commit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;changeLoginState&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
});

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; store;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;在详情页中增加权限验证&lt;/h3&gt;
&lt;p&gt; 大家一定还记得这个图片，这个是我们之前讲到的 nuxt 的执行流程图，这里说下 fetch()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180927144544662-136321657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。&lt;/p&gt;
&lt;p&gt;如果页面组件设置了 &lt;code&gt;fetch&lt;/code&gt; 方法，它会在组件每次加载前被调用（在服务端或切换至目标路由之前）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以利用该方法，获取 状态树 中的 token 信息，并做处理，在昨天的基础上，我们只对 fetch() 方法，简单修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
  import Vue &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    layout: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; asyncData ({ &lt;span&gt;params&lt;/span&gt;&lt;span&gt;, error }) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取文章详情&lt;/span&gt;
      let data =&lt;span&gt; {};
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        data &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; Vue.http.&lt;span&gt;get&lt;/span&gt;(`blog/${&lt;span&gt;params&lt;/span&gt;&lt;span&gt;.id}`);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
          data: data
        };
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;error({ statusCode: 404, message: &quot;出错啦&quot; });&lt;/span&gt;
&lt;span&gt;      }
    },
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里进行判断 token&lt;/span&gt;
&lt;span&gt;    fetch ({ store, redirect  }) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(store.state.token&amp;amp;&amp;amp;store.state.token.length&amp;gt;=&lt;span&gt;128&lt;/span&gt;&lt;span&gt;)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转登录页&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      }

    },
    data () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        comments: []
      };
    },
    head () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        title: `${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.btitle}`,
        meta: [
          {
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            content: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.btitle
          }
        ]
      };
    }
  };
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;最后在 http.js 中，开启 http 拦截器 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http.interceptors.request.use((data, headers) =&amp;gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     return data;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; });

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http request 拦截器&lt;/span&gt;
&lt;span&gt;  http.interceptors.request.use(
    config &lt;/span&gt;=&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，首次服务端渲染的时候，还没有出现 DOM，所以找不到 windows 对象，这里用 try 处理掉了&lt;/span&gt;
      &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (window.localStorage.Token&amp;amp;&amp;amp;window.localStorage.Token.length&amp;gt;=&lt;span&gt;128&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;store.state.token 获取不到值&lt;/span&gt;
          config.headers.Authorization =&lt;span&gt; window.localStorage.Token;
        }
      }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; config;
    },
    err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Promise.reject(err);
    }
  );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 查看页面，体验效果&lt;/h3&gt;
&lt;p&gt;这里我们就已经限制了详情页，需要登陆才能查看，其实这一块逻辑我们可以单拿出来放到中间件 middleware 里来使用，效果会更好，这里举个栗子：&lt;a class=&quot;Affix__List__Item__Link nuxt-link-exact-active nuxt-link-active nuxt-link-active&quot; href=&quot;https://zh.nuxtjs.org/examples/auth-routes&quot; data-v-46b63b25=&quot;&quot;&gt;路由鉴权&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;提醒： 因为我们用的是 store 判断的是否登陆，但是如果刷新页面，我们用的是 服务端渲染，所以 store 会被更新掉，也就是为空了，大家可以用两个办法处理&lt;br/&gt;1、用 localStorage 来判断是否存在token；&lt;/p&gt;
&lt;p&gt;2、每次服务端渲染，需要更新状态树 store 中的 token；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180927150338213-1421020874.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 今天的讲解比较简单，主要是验证逻辑我们之前也已经提到了，在我们系列的 24 篇中，本文只是简单的将其搬到我们的 nuxt 框架中来，只不过中间还是会有一些小问题大家需要注意：&lt;/p&gt;
&lt;p&gt;1、插件 plugins 的使用很重要，2、基于 axios 的 http 封装，我只是写了简单的一个 demo，复杂的大家可以找一些大的项目框架，自行研究研究；3、路由机制也是需要留心的一个小知识点，虽然不需要我们配置了，不过还是要了解内部结构。&lt;/p&gt;
&lt;p&gt;好啦，nuxt 基本教程这里就说这么多吧，祝大家在大长假里开开森森哒~&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/Blog.Vue.Nuxt&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/Blog.Vue.Nuxt&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 07:14:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 哈喽大家好，今天周四啦，楼主明天要正式放假了，这里先祝大家节日快乐咯，希望在家里能继续研究点儿东西吧，今天呢是 nuxt 的最后一篇，主要是对权限登陆进行研究，这一块咱们之前在说第一个项目的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9713219.html</dc:identifier>
</item>
<item>
<title>OpenStack快照分析：（三）从磁盘启动云主机离线(在线)快照分析 - 千夜恋歌</title>
<link>http://www.cnblogs.com/qianyeliange/p/9713146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianyeliange/p/9713146.html</guid>
<description>&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.1.&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;nova-api&lt;/span&gt;&lt;span&gt;处理过程&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;磁盘启动的云主机在做离线快照时，还是首先是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova-api&lt;/span&gt;&lt;span&gt;接收请求，函数入口和前述一样，还是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova/api/openstack/compute/servers.py/ServersController._action_create_image&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;下面一起来看看：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;wsgi.response&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;202&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;extensions.expected_errors&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;((&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;400&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;403&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;404&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;409&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;))&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;定义关联的&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;wsgi.action&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;Charb&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;createImage&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;common.check_snapshots_enabled&lt;br/&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;validation.schema&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(schema_servers.create_image&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'2.0'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'2.0'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;validation.schema&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(schema_servers.create_image&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'2.1'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;_action_create_image&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;req&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;id&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;body):&lt;br/&gt;   &lt;/span&gt; &lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;&quot;&quot;Snapshot a server instance.&quot;&quot;&quot;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;从&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;req&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;中获取请求的上下文，并验证执行权限&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt;&lt;/em&gt; &lt;span lang=&quot;EN-US&quot;&gt;context = req.environ[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'nova.context'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;    context.can(server_policies.SERVERS %&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'create_image'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;从&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;body&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;中解析出传递的参数，快照名称及属性信息&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    entity = body[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;createImage&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;    image_name = common.normalize_name(entity[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;])&lt;br/&gt;    metadata = entity.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'metadata'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;{})&lt;br/&gt;    snapshot_id = entity.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;snapshot_id&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span lang=&quot;EN-US&quot;&gt;# Starting from microversion 2.39 we don't check quotas on createImage&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;api_version_request.is_supported(&lt;br/&gt;            req&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;max_version&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=api_version_request.MAX_IMAGE_META_PROXY_API_VERSION):&lt;br/&gt;      &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;检查快照属性的相关配置信息&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;        common.check_img_metadata_properties_quota(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;metadata)&lt;br/&gt;   &lt;br/&gt;    instance =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._get_server(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;req&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;id)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    snapshot = snapshot_current(context&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.compute_rpcapi)&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot: &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;# if there are snapshots, then create an image with snashots.&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if not&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot_id:&lt;br/&gt;            snapshot_id = snapshot[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;        image = snapshot_create_image(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot_id&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.compute_rpcapi&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;entity)&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;else&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;       &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;从数据库中获取实例对象（&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;InstanceV2&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;）及块设备映射列表&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;        bdms = objects.BlockDeviceMappingList.get_by_instance_uuid(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance.uuid)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;判断实例是镜像启动还是磁盘启动&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;compute_utils.is_volume_backed_instance(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdms):&lt;br/&gt;           &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;校验执行权限&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            context.can(server_policies.SERVERS %&lt;br/&gt;                       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'create_image:allow_volume_backed'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;    &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;       #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;这里执行的是磁盘启动方式的快照，传递的参数包括：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            # 1&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;、关于权限的上下文&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;context&lt;br/&gt;            # 2&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;、虚拟机的实例对象&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;instance&lt;br/&gt;            # 3&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;、快照的名称&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;image_name&lt;br/&gt;            #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;本章节讲的磁盘启动的云主机快照就是进入该分支进行操作。&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            image =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.compute_api.snapshot_volume_backed(&lt;br/&gt;                context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;               &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;               &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;image_name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;               &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;extra_properties&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=metadata)&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;else&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;           &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;这里是镜像启动的云主机快照的入口，即上节内容&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            image =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.compute_api.snapshot(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;image_name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;extra_properties&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=metadata)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;api_version_request.is_supported(req&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'2.45'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'image_id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;: image[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span lang=&quot;EN-US&quot;&gt;# build location of newly-created image entity&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;image_id =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;str&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(image[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;])&lt;br/&gt;    image_ref = glance.generate_image_url(image_id)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    resp = webob.Response(&lt;span lang=&quot;EN-US&quot;&gt;status_int&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;202&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;    resp.headers[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'Location'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;] = image_ref&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;resp&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;可以看到，执行磁盘启动云主机快照时，实际走的是“&lt;/span&gt;&lt;span class=&quot;Charb&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;compute_api.snapshot_volume_backed&lt;/span&gt;&lt;/span&gt;&lt;span&gt;”，下面对这部分代码具体分析，代码位置：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova/compute/api.py/API.snapshot_volume_backed&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;check_instance_state&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;vm_state&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=[vm_states.ACTIVE&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;vm_states.STOPPED&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;vm_states.SUSPENDED])&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot_volume_backed&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;extra_properties=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;   &lt;/span&gt; &lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;&quot;&quot;Snapshot the given volume-backed instance.&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;从实例的&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;system_metadata&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;生成镜像属性（排除不可继承属性），如下：&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;      &lt;/span&gt;&lt;/em&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;# {&lt;br/&gt;       #     u'min_disk': u'20',&lt;br/&gt;       #     'is_public': False,&lt;br/&gt;       #     'min_ram': u'0',&lt;br/&gt;       #     'properties': {&lt;br/&gt;       #         'base_image_ref': u''&lt;br/&gt;       #      },&lt;br/&gt;       #     'name': u'snapshot1'&lt;br/&gt;       # }&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;    :param instance: nova.objects.instance.Instance object&lt;br/&gt;    :param name: name of the backup or snapshot&lt;br/&gt;    :param extra_properties: dict of extra image properties to include&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;code&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;    &lt;strong&gt;:returns&lt;/strong&gt;: the new image metadata&lt;br/&gt;    &quot;&quot;&quot;&lt;br/&gt;    #&lt;/span&gt; &lt;span&gt;获取实例的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;span&gt;属性&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;image_meta =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._initialize_instance_snapshot_metadata(instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;extra_properties)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;image_meta[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'size'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;] =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;0&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;清除镜像&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;span&gt;属性中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;container_format&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;disk_forma&lt;/span&gt;&lt;span&gt;属性&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;for&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;attr&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;in&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'container_format'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'disk_format'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;        image_meta.pop(attr&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;    properties = image_meta[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'properties'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;# clean properties before filling&lt;/span&gt;&lt;span&gt;，清除&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;properties&lt;/span&gt;&lt;span&gt;属性里面的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'block_device_mapping'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'bdm_v2'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'root_device_name'&lt;/span&gt;&lt;span&gt;相关属性值&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;for&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;key&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;in&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'block_device_mapping'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'bdm_v2'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'root_device_name'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;        properties.pop(key&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;   &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;将实例中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;‘root_device_name’&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;属性更新到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;properties&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;属性里，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;image_meta&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;的最终内容如：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    # {&lt;br/&gt;    #     'name': u'snapshot1',&lt;br/&gt;    #     u'min_ram': u'0',&lt;br/&gt;    #     u'min_disk': u'20',&lt;br/&gt;    #     'is_public': False,&lt;br/&gt;    #     'properties': {&lt;br/&gt;    #         u'base_image_ref': u'',&lt;br/&gt;    #         'root_device_name': u'/dev/vda'&lt;br/&gt;    #     },&lt;br/&gt;    #     'size': 0&lt;br/&gt;    # }&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance.root_device_name:&lt;br/&gt;        properties[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'root_device_name'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;] = instance.root_device_name&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;从数据库中获取该云主机所关联的所有块设备，结果会返回一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;BlockDeviceMappingList&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    bdms = objects.BlockDeviceMappingList.get_by_instance_uuid(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance.uuid)&lt;br/&gt;   &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;接下来开始做快照的操作，注意，云主机挂在了多少个卷设备，就要做多少次快照&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    mapping = [] &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;# list of BDM dicts that can go into the image properties&lt;br/&gt;    # Do some up-front filtering of the list of BDMs from&lt;br/&gt;    # which we are going to create snapshots.&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume_bdms = []&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;for&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdm&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;in&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdms:&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdm.no_device:&lt;br/&gt;           &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;映射关系中没有块设备，则忽略此条映射&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;           &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;continue&lt;br/&gt;        if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdm.is_volume:&lt;br/&gt;           &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;# These will be handled below.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;此映射包含块设备，加入到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;volume_bdms&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;，准备做快照&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume_bdms.append(bdm)&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;else&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;            mapping.append(bdm.get_image_mapping())&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span lang=&quot;EN-US&quot;&gt;# Check limits in Cinder before creating snapshots to avoid going over&lt;br/&gt;    # quota in the middle of a list of volumes. This is a best-effort check&lt;br/&gt;    # but concurrently running snapshot requests from the same project&lt;br/&gt;    # could still fail to create volume snapshots if they go over limit.&lt;br/&gt;   &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;在创建快照之前，需要首先在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Cinder&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;中检查配额限制，以避免超过配额限制&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume_bdms:&lt;br/&gt;        limits =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.volume_api.get_absolute_limits(context)&lt;br/&gt;        total_snapshots_used = limits[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'totalSnapshotsUsed'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;        max_snapshots = limits[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'maxTotalSnapshots'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;# -1 means there is unlimited quota for snapshots&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;(max_snapshots &amp;gt; -&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;and&lt;br/&gt;               &lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;len&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(volume_bdms) + total_snapshots_used &amp;gt; max_snapshots):&lt;br/&gt;            LOG.debug(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'Unable to create volume snapshots for instance. '&lt;br/&gt;                      'Currently has %s snapshots, requesting %s new '&lt;br/&gt;                      'snapshots, with a limit of %s.'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;                     &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;total_snapshots_used&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;len&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(volume_bdms)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;                     &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;max_snapshots&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=instance)&lt;br/&gt;           &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;raise&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;exception.OverQuota(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;overs&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'snapshots'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    quiesced = &lt;span lang=&quot;EN-US&quot;&gt;False&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;判断虚拟机的状态，如果虚拟机处于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;active&lt;/span&gt;&lt;span&gt;，则通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;rpc&lt;/span&gt;&lt;span&gt;通知虚拟机进入静默状态（异常处理省略）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance.vm_state == vm_states.ACTIVE:&lt;br/&gt;        LOG.info(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;Attempting to quiesce instance before volume &quot;&lt;br/&gt;                 &quot;snapshot.&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=instance)&lt;br/&gt;       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.compute_rpcapi.quiesce_instance(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance)&lt;br/&gt;        quiesced =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;True&lt;br/&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;定义一个获取云主机上的及具体卷信息的方法，返回云主机的卷映射&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    @&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;wrap_instance_event&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;prefix&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'api'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot_instance&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdms&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;for&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdm&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;in&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume_bdms:&lt;br/&gt;            &lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;# create snapshot based on volume_id&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;span&gt;根据卷的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;volume_id&lt;/span&gt;&lt;span&gt;从数据库获取卷的详细信息&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            &lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;volume = self.volume_api.get(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdm.volume_id)&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;组装出一个貌似是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;desc&lt;/span&gt;&lt;span&gt;的消&lt;/span&gt;&lt;span&gt;息，比如快照名称是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot1&lt;/span&gt;&lt;span&gt;，则这里就是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot for snapshot1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            &lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;name = _(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'snapshot for %s'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;) % image_meta[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'name'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;            LOG.debug(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'Creating snapshot from volume %s.'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=instance)&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;api create_snapshot_force&lt;/span&gt;&lt;span&gt;创建新的卷&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;“create_snapshot_force”&lt;/span&gt;&lt;span&gt;中实际上是通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinderclient&lt;/span&gt;&lt;span&gt;来调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;volume_snapshots.create&lt;br/&gt;            #&lt;/span&gt; &lt;span&gt;来发起创建卷的请求，具体是由&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-volume&lt;/span&gt;&lt;span&gt;来完成卷的快照，返回的内容为卷快照的信息，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            #&lt;/span&gt; &lt;span&gt;格式如：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            #{&lt;br/&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;            #  'status': u'creating',&lt;br/&gt;            #  'display_name': u'snapshot for snapshot1',&lt;br/&gt;            #  'created_at': u'2016-06-24T09:23:00.517279',&lt;br/&gt;            #  'display_description': u'',&lt;br/&gt;            #  'volume_size': 20,&lt;br/&gt;            #  'volume_id': u'60e16af2-0684-433c-a1b6-c1af1c2523fc',&lt;br/&gt;            #  'progress': None,&lt;br/&gt;            #  'project_id': u'25520b29dce346d38bc4b055c5ffbfcb',&lt;br/&gt;            #  'id': u'cede2421-ea68-4a8e-937d-c27074b9024b',&lt;br/&gt;            #  'size': 20&lt;br/&gt;            # }&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            snapshot = self.volume_api.create_snapshot_force(&lt;br/&gt;                context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'display_description'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;])&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;接着会根据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;bdm&lt;/span&gt;&lt;span&gt;信息，来构建快照的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;dict&lt;/span&gt;&lt;span&gt;格式属性信息，返回一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;BlockDeviceDict&lt;/span&gt;&lt;span&gt;对象，属性如下&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;            # {&lt;br/&gt;            #  'guest_format': None,&lt;br/&gt;            #  'boot_index': 0,&lt;br/&gt;            #  'no_device': None,&lt;br/&gt;            #  'connection_info': None,&lt;br/&gt;            #  'snapshot_id': u'cede2421-ea68-4a8e-937d-c27074b9024b',&lt;br/&gt;            #  'volume_size': 20,&lt;br/&gt;            #  'device_name': u'/dev/vda',&lt;br/&gt;            #  'disk_bus': u'virtio',&lt;br/&gt;            #  'image_id': None,&lt;br/&gt;            #  'source_type': 'snapshot',&lt;br/&gt;            #  'device_type': u'disk',&lt;br/&gt;            #  'volume_id': None,&lt;br/&gt;            #  'destination_type': 'volume',&lt;br/&gt;            #  'delete_on_termination': False&lt;br/&gt;            # }&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            mapping_dict = block_device.snapshot_from_bdm(snapshot[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdm)&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;过滤掉已经在数据库中存在的字段&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            mapping_dict = mapping_dict.get_image_mapping()&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;将云主机所有的映射关系都添加到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mapping&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            mapping.append(mapping_dict)&lt;br/&gt;        &lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;mapping&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._record_action_start(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance_actions.CREATE_IMAGE)&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;调用“&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot_instance&lt;/span&gt;&lt;span&gt;”，获取云主机所有的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mapping&lt;/span&gt;&lt;span&gt;关系&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    mapping = snapshot_instance(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;bdms)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;如果此时卷的文件系统已静默，这里则进行解冻处理，实现过程就是通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;rpc.case&lt;/span&gt;&lt;span&gt;发送异步请求给&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova-compute&lt;br/&gt;    # nova-compute&lt;/span&gt;&lt;span&gt;接收到消息后，会等到快照完成后对文件系统进行解冻（需要&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;agent&lt;/span&gt;&lt;span&gt;支持）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;quiesced:&lt;br/&gt;       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.compute_rpcapi.unquiesce_instance(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;instance&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;mapping)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;更新云主机&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;span&gt;信息中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;properties&lt;/span&gt;&lt;span&gt;信息&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;mapping:&lt;br/&gt;        properties[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'block_device_mapping'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;] = mapping&lt;br/&gt;        properties[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'bdm_v2'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;] =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;True&lt;br/&gt;    #&lt;/span&gt; &lt;span&gt;到这一步时，会到添加一条记录到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;glance&lt;/span&gt;&lt;span&gt;快照（镜像）数据库条目&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #&lt;/span&gt;&lt;span&gt;（会在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dashboard&lt;/span&gt;&lt;span&gt;的镜像面板显示一条名为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot1&lt;/span&gt;&lt;span&gt;的快照记录&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #&lt;/span&gt; &lt;span&gt;快照的大部分信息都拷贝至系统盘属性，这是因为卷快照是可以直接用来启动云主机的，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #&lt;/span&gt; &lt;span&gt;另外&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'block_device_mapping'&lt;/span&gt;&lt;span&gt;属性中包含所有的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span&gt;设备快照信息（如果有的话），&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #&lt;/span&gt; &lt;span&gt;每个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span&gt;设备快照信息作为一条记录，记录在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;image_properties&lt;/span&gt;&lt;span&gt;数据表；&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #&lt;br/&gt;      {&lt;br/&gt;         'name': u'snapshot1',&lt;br/&gt;         'min_ram': u'0',&lt;br/&gt;         'min_disk': u'20',&lt;br/&gt;         'is_public': False,&lt;br/&gt;         'properties': {&lt;br/&gt;                 'bdm_v2': True,&lt;br/&gt;                 'block_device_mapping': [{&lt;br/&gt;                          'guest_format': None,&lt;br/&gt;                          'boot_index': 0,&lt;br/&gt;                          'no_device': None,&lt;br/&gt;                          'image_id': None,&lt;br/&gt;                          'volume_id': None,&lt;br/&gt;                          'device_name': u'/dev/vda',&lt;br/&gt;                          'disk_bus': u'virtio',&lt;br/&gt;                          'volume_size': 20,&lt;br/&gt;                          'source_type': 'snapshot',&lt;br/&gt;                          'device_type': u'disk',&lt;br/&gt;                          'snapshot_id': u'cede2421-ea68-4a8e-937d-c27074b9024b',&lt;br/&gt;                          'destination_type': 'volume',&lt;br/&gt;                          'delete_on_termination': False&lt;br/&gt;                 }],&lt;br/&gt;                 'base_image_ref': u'',&lt;br/&gt;                 'root_device_name': u'/dev/vda'&lt;br/&gt;         },&lt;br/&gt;         'size': 0&lt;br/&gt;    }&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.image_api.create(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;image_meta)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;最后一步通过调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;image_api&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;create&lt;/span&gt;&lt;span&gt;来创建&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;image&lt;/span&gt;&lt;span&gt;，跟踪过去实际上就只有一句&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;Charb&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;session.create(context, image_info, data=data)&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;&lt;span&gt;，调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;RESTful API&lt;/span&gt;&lt;span&gt;来创建&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;image&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;至此，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova-api&lt;/span&gt;&lt;span&gt;的工作已经做完，总结一下，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nov-api&lt;/span&gt;&lt;span&gt;主要是&lt;/span&gt; &lt;span&gt;完成了一下工作：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span&gt;如果是在线快照，则冻结&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;&lt;span&gt;解冻结文件系统&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span&gt;创建&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;glance&lt;/span&gt;&lt;span&gt;数据库镜像记录（包含所有卷的快照信息）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.2.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;cinder&lt;/span&gt;&lt;span&gt;创建磁盘快照&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.2.1.&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;cinder-api&lt;/span&gt;&lt;span&gt;处理过程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;上节中讲到在创建卷快照的时候，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova-api&lt;/span&gt;&lt;span&gt;在处理请求时，使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinderclient&lt;/span&gt;&lt;span&gt;调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;volume_api&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-api&lt;/span&gt;&lt;span&gt;）来通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;http&lt;/span&gt;&lt;span&gt;方式发送快照的请求，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-api&lt;/span&gt;&lt;span&gt;会接受该请求，处理代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;code&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;wsgi.response&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(http_client.ACCEPTED)&lt;br/&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;validation.schema&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(snapshot.create)&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;create&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;req&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;body):&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&quot;&quot;&quot;Creates a new snapshot.&quot;&quot;&quot;&lt;br/&gt;    #&lt;/span&gt; &lt;span&gt;根据上下文的分析，当&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova-api&lt;/span&gt;&lt;span&gt;等其他&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;client&lt;/span&gt;&lt;span&gt;在发送创建卷快照的请求之后，本方法会接受到请求&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #&lt;/span&gt; &lt;span&gt;方法接收到的参数有：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    # req&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Request&lt;/span&gt;&lt;span&gt;对象，包含有本次请求的上下内容，包含有用于鉴权的凭证等内容&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    # body&lt;/span&gt;&lt;span&gt;：快照的属性信息，包含有如下内容：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #  {&lt;br/&gt;    #      u'snapshot': {&lt;br/&gt;    #           u'volume_id': u'60e16af2-0684-433c-a1b6-c1af1c2523fc',&lt;br/&gt;    #           u'force': True,&lt;br/&gt;    #           u'description': u'',&lt;br/&gt;    #           u'name': u'snapshot for snapshot1',&lt;br/&gt;    #           u'metadata': {}&lt;br/&gt;    #      }&lt;br/&gt;    #  }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span lang=&quot;EN-US&quot;&gt;kwargs = {}&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;首先还是获取上下文的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span&gt;信息和获取快照属性中的信息&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    context = req.environ[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'cinder.context'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;    snapshot = body[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'snapshot'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;获取快照的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;span&gt;信息，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot_id&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    kwargs[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'metadata'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;] = snapshot.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'metadata'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;    volume_id = snapshot[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'volume_id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;]&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;从数据库中获取卷信息&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    volume =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.volume_api.get(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume_id)&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;这里是获取传递进来的参数中是否使用强制快照，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;force=True&lt;/span&gt;&lt;span&gt;表示采取强制快照&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    force = snapshot.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'force'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;False&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;参数类型转换，如果是非&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;True/False&lt;/span&gt;&lt;span&gt;的值，则抛异常&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    force = strutils.bool_from_string(force&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;strict&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;True&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;    LOG.info(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;Create snapshot from volume %s&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume_id)&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;验证快照名及快照描述是否合法，长度不能超过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;256&lt;/span&gt;&lt;span&gt;个字符&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.validate_name_and_description(snapshot&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;check_length&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;False&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;# NOTE(thingee): v2 API allows name instead of display_name&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;display_name&lt;/span&gt;&lt;span&gt;代替&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;'name'&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;in&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot:&lt;br/&gt;        snapshot[&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'display_name'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;] = snapshot.pop(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'name'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;开始进行快照的操作，根据&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;force&lt;/span&gt;&lt;span&gt;值得不同走不通的分支，其实都是对&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;_create_snapshot&lt;/span&gt;&lt;span&gt;的封装&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;force:&lt;br/&gt;        new_snapshot =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.volume_api.create_snapshot_force(&lt;br/&gt;            context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'display_name'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'description'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;**kwargs)&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;else&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;        new_snapshot =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.volume_api.create_snapshot(&lt;br/&gt;            context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'display_name'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.get(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'description'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;**kwargs)&lt;br/&gt;    req.cache_db_snapshot(new_snapshot)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._view_builder.detail(req&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;new_snapshot)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder\volume\api.py&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;&lt;span&gt;类中，有这两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;create_snapshot&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;description&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;metadata=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;cgsnapshot_id=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;group_snapshot_id=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;    result =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._create_snapshot(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;description&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;False&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;cgsnapshot_id&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;group_snapshot_id)&lt;br/&gt;    LOG.info(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;Snapshot create request issued successfully.&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;resource&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=result)&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;result&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;create_snapshot_force&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;description&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;metadata=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;    result =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._create_snapshot(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;description&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;True&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;metadata)&lt;br/&gt;    LOG.info(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;Snapshot force create request issued successfully.&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;resource&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=result)&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;result&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;可以看到两个方法都是调用了“&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;Charb&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;create_snapshot&lt;/span&gt;&lt;/span&gt;&lt;span&gt;”，只是在传递第&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;&lt;span&gt;个参数&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;force&lt;/span&gt;&lt;span&gt;时不一样，同时&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;force&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;False&lt;/span&gt;&lt;span&gt;时，需要传递其他几个参数（实际上也为空）。下面具体分析&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;_create_snapshot&lt;/span&gt;&lt;span&gt;方法：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;code&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;_create_snapshot&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;description&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;force=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;False&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;metadata=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;                    &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;cgsnapshot_id=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;group_snapshot_id=&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;):&lt;br/&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;根据上文的分析：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;force = True&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span&gt;该方法完成如下功能：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    1.&lt;/span&gt; &lt;span&gt;执行卷状态条件判断，如果卷处于维护状态，迁移过程中，副本卷，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;       force=False&lt;/span&gt;&lt;span&gt;且不是可用状态，则抛异常&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    2.&lt;/span&gt; &lt;span&gt;执行用户快照配额管理，用户可以为不同的卷类型设置不同的配额信息，如：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;       volumes, gigabytes,snapshots,&lt;/span&gt;&lt;span&gt;我这里使用的是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ceph rbd&lt;/span&gt;&lt;span&gt;，例如：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;         {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;code&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;           'gigabytes': 20,&lt;br/&gt;           'snapshots_ceph': 1,&lt;br/&gt;           'gigabytes_ceph': 20,&lt;br/&gt;           'snapshots': 1&lt;br/&gt;         }&lt;br/&gt;     &lt;/span&gt; &lt;span&gt;用户默认配额如下：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;         {&lt;br/&gt;           'gigabytes': 1000,&lt;br/&gt;           'snapshots_ceph': -1,&lt;br/&gt;           'snapshots': 10,&lt;br/&gt;           'gigabytes_ceph': -1&lt;br/&gt;         }&lt;br/&gt;      &lt;/span&gt;&lt;span&gt;如果配额不足则会抛异常&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    3.&lt;/span&gt; &lt;span&gt;创建快照条目，例如（创建卷快照要先在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder&lt;/span&gt;&lt;span&gt;数据库创建&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;span&gt;数据库条目）：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;      {&lt;br/&gt;           'status': u'creating',&lt;br/&gt;           'volume_type_id': 'd494e240-17b3-4d35-a5a1-2923d8677d79',&lt;br/&gt;           'display_name': u'snapshot for snapshot1',&lt;br/&gt;           'user_id': 'b652f9bd65844f739684a20ed77e9a0f',&lt;br/&gt;           'display_description': u'',&lt;br/&gt;           'cgsnapshot_id': None,&lt;br/&gt;           'volume_size': 20,&lt;br/&gt;           'encryption_key_id': None,&lt;br/&gt;           'volume_id': '60e16af2-0684-433c-a1b6-c1af1c2523fc',&lt;br/&gt;           'progress': u'0%',&lt;br/&gt;           'project_id': '25520b29dce346d38bc4b055c5ffbfcb',&lt;br/&gt;           'metadata': {}&lt;br/&gt;      }&lt;br/&gt;      &lt;/span&gt;&lt;span&gt;卷快照完成后，会在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dashboard&lt;/span&gt;&lt;span&gt;的云硬盘快照面板显示一条名为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'snapshot for snapshot1'&lt;/span&gt;&lt;span&gt;的卷快照记录&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    &quot;&quot;&quot;&lt;br/&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;我理解这一步应该是继续保证卷操作处于冻结状态，并且是可进行快照，检查配额是否可用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    volume.assert_not_frozen()&lt;br/&gt; &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;  #&lt;/span&gt; &lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;span&gt;数据表中创建一条快照记录，即会在云硬盘快照面板显示一条名为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;“snapshot for snapshot1”&lt;/span&gt;&lt;span&gt;的记录&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    &lt;span&gt;snapshot&lt;/span&gt; =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.create_snapshot_in_db(&lt;br/&gt;        context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;name&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;description&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;force&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;cgsnapshot_id&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;True&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;group_snapshot_id)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;kwargs = {&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'snapshot_id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;: &lt;span&gt;snapshot&lt;/span&gt;.id&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;             &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'volume_properties'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;: objects.VolumeProperties(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;size&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=volume.size)}&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt; &lt;span&gt;调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;rpc.case&lt;/span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;create_snapshot&lt;/span&gt;&lt;span&gt;的消息投递到消息队列该消息&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.scheduler_rpcapi.create_snapshot(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;                                         &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume.service_topic_queue&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;                                         &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;objects.RequestSpec(**kwargs))&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;至此，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-api&lt;/span&gt;&lt;span&gt;的处理结束！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;小结：卷快照过程中，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-api&lt;/span&gt;&lt;span&gt;的操作总结为如下两个方面：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span&gt;卷状态条件检查及配额检查&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span&gt;创建&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;glance&lt;/span&gt;&lt;span&gt;数据库快照记录（记录的是单个卷快照的信息）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.2.2.&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;Cinder-volume&lt;/span&gt;&lt;span&gt;的处理过程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;当&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-volume&lt;/span&gt;&lt;span&gt;从消息队列接收到来自&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-api&lt;/span&gt;&lt;span&gt;的创建快照的请求消息后，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-volume&lt;/span&gt;&lt;span&gt;就会调用其&lt;/span&gt;&lt;span class=&quot;2Char0&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;VolumeManager.create_snapshot&lt;/span&gt;&lt;/span&gt;&lt;span&gt;方法进行处理，代码位置：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder/volume/manager.py&lt;/span&gt;&lt;span&gt;，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;@&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;objects.Snapshot.set_workers&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;create_snapshot&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot):&lt;br/&gt;   &lt;/span&gt; &lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;&quot;&quot;Creates and exports the snapshot.&quot;&quot;&quot;&lt;br/&gt;   &lt;/span&gt;&lt;/em&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;获取请求上下文&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt;&lt;/em&gt; &lt;span lang=&quot;EN-US&quot;&gt;context = context.elevated()&lt;br/&gt;  &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;通过消息队列，通知&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;ceilometer&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;快照发生变化&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._notify_about_snapshot_usage(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&quot;create.start&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;try&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;异常处理代码，有任何异常则退出并设置快照状态为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;error&quot;&quot;&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;       &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;确保存储驱动已经初始化，否则抛出异常&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;utils.require_driver_initialized(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.driver)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        &lt;span lang=&quot;EN-US&quot;&gt;# Pass context so that drivers that want to use it, can,&lt;br/&gt;        # but it is not a requirement for all drivers.&lt;br/&gt;       &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.context = context&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;调用后端存储驱动执行快照&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;例如使用&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;RBDDriver&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;，下文具体分析&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;        model_update =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.driver.create_snapshot(snapshot)&lt;br/&gt;       &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;完成之后，更新数据库条目，若返回的是&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;，则不执行&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;model_update:&lt;br/&gt;            snapshot.update(model_update)&lt;br/&gt;            snapshot.save()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;except&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;Exception&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;       &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;若之前几步操作出现问题，则将快照的状态置为&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;error&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;with&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;excutils.save_and_reraise_exception():&lt;br/&gt;            snapshot.status = fields.SnapshotStatus.ERROR&lt;br/&gt;            snapshot.save()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;从&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;的数据库中获取卷的信息&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    vol_ref =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.db.volume_get(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.volume_id)&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;    #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;如果该卷的&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;bootable&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;属性为&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;，表示该卷是启动卷，表示云主机是通过卷启动的，即系统盘，&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;如果是非启动卷，则跳过&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;vol_ref.bootable:&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;try&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;br/&gt;           &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;用卷的&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;信息来更新&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;metadata&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;信息，需要保证系统盘的元数据与其快照的元数据一致&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;           &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.db.volume_glance_metadata_copy_to_snapshot(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.id&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.volume_id)&lt;br/&gt;       &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;except&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;exception.GlanceMetadataNotFound:&lt;br/&gt;          &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;更新&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;的元数据如果抛出&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;GlanceMetadataNotFound&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;表示从&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;glance&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;中找不到卷的元数据信息，可以直接跳过&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;           &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;pass&lt;br/&gt;        except&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;exception.CinderException&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;as&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;ex:&lt;br/&gt;            LOG.exception(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;Failed updating snapshot&quot;&lt;br/&gt;                          &quot; metadata using the provided volumes&quot;&lt;br/&gt;                          &quot; %(volume_id)s metadata&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;                         &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;'volume_id'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;: snapshot.volume_id}&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;                         &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;resource&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=snapshot)&lt;br/&gt;           &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;如果抛出&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;方面的异常，则有可能是快照出现问题，则直接将快照的状态置为&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;error&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;            snapshot.status = fields.SnapshotStatus.ERROR&lt;br/&gt;            snapshot.save()&lt;br/&gt;           &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;raise&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;exception.MetadataCopyFailure(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;reason&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=six.text_type(ex))&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;若一路过来没有出现异常，则代表快照完成，将快照状态标记为可用，进度为&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;100%&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;，并保存状态&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;    snapshot.status = fields.SnapshotStatus.AVAILABLE&lt;br/&gt;    snapshot.progress =&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;'100%'&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.encryption_key_id = vol_ref.encryption_key_id&lt;br/&gt;    snapshot.save()&lt;br/&gt;  &lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; #&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;通过消息队列，通知&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;ceilometer&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;codeChar&quot;&gt;&lt;span&gt;快照完成&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;._notify_about_snapshot_usage(context&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&quot;create.end&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;br/&gt;    LOG.info(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;Create snapshot completed successfully&quot;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;br/&gt;            &lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;resource&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;=snapshot)&lt;br/&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;return&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.id&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;从上面的代码中可以找到，执行快照其实是调用底层的后端存储来做的，即“&lt;/span&gt;&lt;span class=&quot;2Char0&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;driver.create_snapshot(snapshot)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;”，针对不同的存储类型，会有不同的处理方式，这也就是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStack&lt;/span&gt;&lt;span&gt;的一个设计理念，只提供一个框架，具体功能的实现则是交给对应的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;provider&lt;/span&gt;&lt;span&gt;来做，只要你提供的功能的调用符合&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenStack&lt;/span&gt;&lt;span&gt;的接口标准便可以。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IDE&lt;/span&gt;&lt;span&gt;中点击进入&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;driver.create_snapshot&lt;/span&gt;&lt;span&gt;方法，会出现以下选择框：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237616/201809/1237616-20180927154120300-1419583300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;可以看出，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-volume&lt;/span&gt;&lt;span&gt;提供有很多的后端存储驱动，比如&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;EMC&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;HPE&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SVC&lt;/span&gt;&lt;span&gt;等，查看整个驱动目录，支持：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237616/201809/1237616-20180927154143410-1618918511.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1237616/201809/1237616-20180927154317599-1403271154.png&quot; alt=&quot;&quot; width=&quot;187&quot; height=&quot;330&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1237616/201809/1237616-20180927154354441-174758185.png&quot; alt=&quot;&quot; width=&quot;225&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;比如，我们使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ceph&lt;/span&gt;&lt;span&gt;作为后端存储，这时候就会使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;RBD&lt;/span&gt;&lt;span&gt;的驱动，快照调用的方法为：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;create_snapshot&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot):&lt;br/&gt;   &lt;/span&gt; &lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;&quot;&quot;&quot;Creates an rbd snapshot.&quot;&quot;&quot;&lt;br/&gt;   &lt;/span&gt;&lt;/em&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;with&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;RBDVolumeProxy(&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;self&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;snapshot.volume_name)&lt;/span&gt; &lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;as&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;volume:&lt;br/&gt;        snap = utils.convert_str(snapshot.name)&lt;br/&gt;        volume.create_snap(snap)&lt;br/&gt;        volume.protect_snap(snap)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;其过程也就是创建一个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Image&lt;/span&gt;&lt;span&gt;对象，然后直接调用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;librbd&lt;/span&gt;&lt;span&gt;相关的方法执行秒级快照，不做具体分析了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;小结：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder-volume&lt;/span&gt;&lt;span&gt;快照功能很简单：调用后端存储执行快照，然后更新&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;glance&lt;/span&gt;&lt;span&gt;数据库快照记录&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;阅读完上面的分析，相信读者会发现上面的快照过程中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;cinder&lt;/span&gt;&lt;span&gt;执行的就是卷的快照，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nova&lt;/span&gt;&lt;span&gt;实现的是云主机信息及其镜像记录的处理。事实确实也如此：快照执行完成后，会在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Dashboard&lt;/span&gt;&lt;span&gt;的镜像面板显示一条镜像记录，在卷快照面板显示一条或者多条（如果有多个卷的话）卷快照记录。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 27 Sep 2018 07:12:00 +0000</pubDate>
<dc:creator>千夜恋歌</dc:creator>
<og:description>1. 磁盘启动云主机，离线(在线)快照 1.1. nova-api处理过程 磁盘启动的云主机在做离线快照时，还是首先是nova-api接收请求，函数入口和前述一样，还是 nova/api/o</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianyeliange/p/9713146.html</dc:identifier>
</item>
<item>
<title>机器学习常用评估指标的前世今生 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9400375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9400375.html</guid>
<description>&lt;p&gt;　　在机器学习中，性能指标（Metrics）是衡量一个模型好坏的关键，通过衡量模型输出y_predict和y_true之间的某种“距离”得出的。&lt;/p&gt;
&lt;p&gt;　　性能指标往往使我们做模型时的最终目标，如准确率，召回率，敏感度等等，但是性能指标常常因为不可微分，无法作为优化的loss函数，因此采用如cross-entropy，rmse等“距离”可微函数作为优化目标，以期待在loss函数降低的时候，能够提高性能指标。而最终目标的性能指标则作为模型训练过程中，作为验证集做决定(early stoping或model selection)的主要依据，与训练结束后评估本次训练出的模型好坏的重要标准。&lt;/p&gt;
&lt;p&gt;　　在机器学习的比赛中，有部分比赛也是用metrics作为排名的依据（当然也有使用loss排名）。&lt;/p&gt;
&lt;p&gt;　　在使用机器学习算法的过程中，针对不同的场景需要不同的评价指标，常用的机器学习算法包括分类，回归，聚类等几大类型，在这里对常用的指标进行一个简单的总结，小编总结了前人的很多博客，知乎等，方便自己学习。当然，需要的同学们也可以看一下。&lt;/p&gt;
&lt;h2&gt;一，分类&lt;/h2&gt;
&lt;p&gt;　　分类是机器学习中的一类重要问题，很多重要的算法都在解决分类问题，例如决策树，支持向量机等，其中二分类问题是分类问题中的一个重要的课题。&lt;/p&gt;
&lt;p&gt;　　常见的分类模型包括：逻辑回归、决策树、朴素贝叶斯、SVM、神经网络等，模型评估指标包括以下几种：&lt;/p&gt;
&lt;h3&gt;1. TPR、FPR&amp;amp;TNR（混淆矩阵）&lt;/h3&gt;
&lt;p&gt;　　在二分类问题中，即将实例分成正类（positive）或负类（negative）。对一个二分问题来说，会出现四种情况。如果一个实例是正类并且也被 预测成正类，即为真正类（True positive）,如果实例是负类被预测成正类，称之为假正类（False positive）。相应地，如果实例是负类被预测成负类，称之为真负类（True negative）,正类被预测成负类则为假负类（false negative）。&lt;/p&gt;
&lt;p&gt;　　TP（True positive）：正确肯定的数目；&lt;/p&gt;
&lt;p&gt;　　FN（False positive）：漏报，没有正确找到的匹配的数目；&lt;/p&gt;
&lt;p&gt;　　FP（True negative）：误报，给出的匹配是不正确的；&lt;/p&gt;
&lt;p&gt;　　TN（false negative）：正确拒绝的非匹配对数；&lt;/p&gt;
&lt;p&gt;在评估一个二分类模型的效果时，我们通常会用一个称为混淆矩阵（confusion matrix）的四格表来表示，即如下表所示，1代表正类，0代表负类：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;预测1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;预测0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;实际1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;True Positive(TP)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;False Negative(FN)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;实际0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;False Positive(FP)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;True Negative(TN)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　从列联表引入两个新名词。其一是&lt;strong&gt;真正类率(true positive rate ,TPR)&lt;/strong&gt;, 计算公式为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TPR = TP / (TP + FN)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　刻画的是分类器所识别出的 正实例占所有正实例的比例。&lt;/p&gt;
&lt;p&gt;　　另外一个是&lt;strong&gt;负正类率(false positive rate, FPR)&lt;/strong&gt;,计算公式为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FPR = FP / (FP + TN)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　计算的是分类器错认为正类的负实例占所有负实例的比例。&lt;/p&gt;
&lt;p&gt;　　还有一个真负类率（True Negative Rate，TNR），也称为specificity，计算公式为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TNR = TN /(FP + TN) = 1 - FPR&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2.常用于二分类问题（监督学习）的度量指标&lt;/h3&gt;
&lt;h4&gt;精确率Precision、召回率Recall和F1值&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　精确率（正确率）&lt;/strong&gt;和&lt;strong&gt;召回率&lt;/strong&gt;是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中精度是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的&lt;strong&gt;查准率&lt;/strong&gt;；召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的&lt;strong&gt;查全率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　一般来说，Precision就是检索出来的条目（比如：文档、网页等）有多少是准确的，Recall就是所有准确的条目有多少被检索出来了，两者的定义分别如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Precision = 提取出的正确信息条数 /  提取出的信息条数     &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Recall = 提取出的正确信息条数 /  样本中的信息条数    &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了能够评价不同算法的优劣，在Precision和Recall的基础上提出了F1值的概念，来对Precision和Recall进行整体评价。F1的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;F1值  = 正确率 * 召回率 * 2 / (正确率 + 召回率) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;不妨举这样一个例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　某池塘有1400条鲤鱼，300只虾，300只鳖。现在以捕鲤鱼为目的。撒一大网，逮着了700条鲤鱼，200只虾，100只鳖。那么，这些指标分别如下：&lt;/p&gt;
&lt;p&gt;　　正确率 = 700 / (700 + 200 + 100) = 70%&lt;/p&gt;
&lt;p&gt;　　召回率 = 700 / 1400 = 50%&lt;/p&gt;
&lt;p&gt;　　F1值 = 70% * 50% * 2 / (70% + 50%) = 58.3%&lt;/p&gt;
&lt;p&gt;　　不妨看看如果把池子里的所有的鲤鱼、虾和鳖都一网打尽，这些指标又有何变化：&lt;/p&gt;
&lt;p&gt;　　正确率 = 1400 / (1400 + 300 + 300) = 70%&lt;/p&gt;
&lt;p&gt;　　召回率 = 1400 / 1400 = 100%&lt;/p&gt;
&lt;p&gt;　　F1值 = 70% * 100% * 2 / (70% + 100%) = 82.35%        &lt;/p&gt;
&lt;p&gt;　　由此可见，正确率是评估捕获的成果中目标成果所占得比例；召回率，顾名思义，就是从关注领域中，召回目标类别的比例；而F值，则是综合这二者指标的评估指标，用于综合反映整体的指标。&lt;/p&gt;
&lt;p&gt;　　当然希望检索结果Precision越高越好，同时Recall也越高越好，但事实上这两者在某些情况下有矛盾的。比如极端情况下，我们只搜索出了一个结果，且是准确的，那么Precision就是100%，但是Recall就很低；而如果我们把所有结果都返回，那么比如Recall是100%，但是Precision就会很低。因此在不同的场合中需要自己判断希望Precision比较高或是Recall比较高。如果是做实验研究，可以绘制&lt;strong&gt;Precision-Recall曲线&lt;/strong&gt;来帮助分析。&lt;/p&gt;
&lt;h3&gt;3. 综合评价指标F-measure&lt;/h3&gt;
&lt;p&gt;　　Precision和Recall指标有时候会出现的矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure（又称为F-Score）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　F-Measure是Precision和Recall加权调和平均&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　当参数α=1时，就是最常见的F1。因此，F1综合了P和R的结果，当F1较高时则能说明试验方法比较有效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922141408912-86498434.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4. 应用场景：&lt;/h3&gt;
&lt;p&gt;　　准确率和召回率是互相影响的，理想情况下肯定是做到两者都高，但是一般情况下准确率高、召回率就低，召回率低、准确率高，当然如果两者都低，那是什么地方出问题了。当精确率和召回率都高时，F1的值也会高。在两者都要求高的情况下，可以用F1来衡量。&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;地震的预测&lt;br/&gt;对于地震的预测，我们希望的是RECALL非常高，也就是说每次地震我们都希望预测出来。这个时候我们可以牺牲PRECISION。情愿发出1000次警报，把10次地震都预测正确了；也不要预测100次对了8次漏了两次。&lt;/li&gt;
&lt;li&gt;嫌疑人定罪&lt;br/&gt;基于不错怪一个好人的原则，对于嫌疑人的定罪我们希望是非常准确的。及时有时候放过了一些罪犯（recall低），但也是值得的。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h3&gt;5. ROC曲线和AUC&lt;/h3&gt;
&lt;p&gt;　　AUC是一种模型分类指标，且仅仅是二分类模型的评价指标。AUC是Area Under Curve的简称，那么Curve就是ROC（Receiver Operating Characteristic），翻译为&quot;接受者操作特性曲线&quot;。也就是说ROC是一条曲线，AUC是一个面积值。&lt;/p&gt;
&lt;p&gt;　　ROC曲线应该尽量偏离参考线，越靠近左上越好&lt;/p&gt;
&lt;p&gt;　　AUC：ROC曲线下面积，参考线面积为0.5，AUC应大于0.5，且偏离越多越好&lt;/p&gt;
&lt;h4 class=&quot;Second&quot;&gt;5.1 为什么引入ROC曲线？&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;Motivation1：&lt;/strong&gt;在一个二分类模型中，对于所得到的连续结果，假设已确定一个阀值，比如说 0.6，大于这个值的实例划归为正类，小于这个值则划到负类中。如果减小阀值，减到0.5，固然能识别出更多的正类，也就是提高了识别出的正例占所有正例 的比类，即TPR,但同时也将更多的负实例当作了正实例，即提高了FPR。为了形象化这一变化，引入ROC，ROC曲线可以用于评价一个分类器。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Motivation2：&lt;/strong&gt;在类不平衡的情况下,如正样本90个,负样本10个,直接把所有样本分类为正样本,得到识别率为90%。但这显然是没有意义的。单纯根据Precision和Recall来衡量算法的优劣已经不能表征这种病态问题。&lt;/p&gt;
&lt;h4 class=&quot;Second&quot;&gt;5.2 什么是ROC曲线？&lt;/h4&gt;
&lt;p&gt;　　ROC（Receiver Operating Characteristic）翻译为&quot;接受者操作特性曲线&quot;。曲线由两个变量1-specificity 和 Sensitivity绘制. 1-specificity=FPR，即负正类率。Sensitivity即是真正类率，TPR(True positive rate),反映了正类覆盖程度。这个组合以1-specificity对sensitivity,即是以代价(costs)对收益(benefits)。显然收益越高，代价越低，模型的性能就越好。&lt;/p&gt;
&lt;p&gt;       此外，ROC曲线还可以用来计算“均值平均精度”（mean average precision），这是当你通过改变阈值来选择最好的结果时所得到的平均精度（PPV）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x 轴为假阳性率（FPR）：在所有的负样本中，分类器预测错误的比例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=FPR+%3D+%5Cfrac+%7BFP%7D%7BFP%2BTN%7D+%5C%5C&quot; alt=&quot;FPR = \frac {FP}{FP+TN} \\&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;y 轴为真阳性率（TPR）：在所有的正样本中，分类器预测正确的比例（等于Recall）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=TPR+%3D+%5Cfrac+%7BTP%7D%7BTP%2BFN%7D+%5C%5C&quot; alt=&quot;TPR = \frac {TP}{TP+FN} \\&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了更好地理解ROC曲线，我们使用具体的实例来说明：&lt;/p&gt;
&lt;p&gt;　　如在医学诊断中,判断有病的样本。那么尽量把有病的揪出来是主要任务,也就是第一个指标TPR,要越高越好。而把没病的样本误诊为有病的,也就是第二个指标FPR,要越低越好。&lt;/p&gt;
&lt;p&gt;　　不难发现,这两个指标之间是相互制约的。如果某个医生对于有病的症状比较敏感,稍微的小症状都判断为有病,那么他的第一个指标应该会很高,但是第二个指标也就相应地变高。最极端的情况下,他把所有的样本都看做有病,那么第一个指标达到1,第二个指标也为1。&lt;/p&gt;
&lt;p&gt;　　我们以FPR为横轴,TPR为纵轴,得到如下ROC空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180118103009521-885299930.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以看出,左上角的点(TPR=1,FPR=0),为完美分类,也就是这个医生医术高明,诊断全对。点A(TPR&amp;gt;FPR),医生A的判断大体是正确的。中线上的点B(TPR=FPR),也就是医生B全都是蒙的,蒙对一半,蒙错一半;下半平面的点C(TPR&amp;lt;FPR),这个医生说你有病,那么你很可能没有病,医生C的话我们要反着听,为真庸医。上图中一个阈值,得到一个点。现在我们需要一个独立于阈值的评价指标来衡量这个医生的医术如何,也就是遍历所有的阈值,得到ROC曲线。&lt;/p&gt;
&lt;p&gt;　　假设下图是某医生的诊断统计图，为未得病人群（上图）和得病人群（下图）的模型输出概率分布图（横坐标表示模型输出概率，纵坐标表示概率对应的人群的数量），显然未得病人群的概率值普遍低于得病人群的输出概率值（即正常人诊断出疾病的概率小于得病人群诊断出疾病的概率）。&lt;/p&gt;
&lt;p&gt;　　竖线代表阈值。显然，图中给出了某个阈值对应的混淆矩阵，通过改变不同的阈值 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1.0+%5Crightarrow+0&quot; alt=&quot;1.0 \rightarrow 0&quot;/&gt; ，得到一系列的混淆矩阵，进而得到一系列的TPR和FPR，绘制出ROC曲线。&lt;/p&gt;
&lt;p&gt;　　阈值为1时，不管你什么症状，医生均未诊断出疾病（预测值都为N），此时绿色和红色区域的面积为 0，因此 &lt;img src=&quot;https://www.zhihu.com/equation?tex=FPR%3DTPR%3D0&quot; alt=&quot;FPR=TPR=0&quot;/&gt; ，位于左下。随着阈值的减小，红色和绿色区域增大，紫色和蓝色区域减小。阈值为 0 时，不管你什么症状，医生都诊断结果都是得病（预测值都为P），此时绿色和红色区域均占整个区域，即紫色和蓝色区域的面积为 0，此时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=FPR%3DTPR%3D1&quot; alt=&quot;FPR=TPR=1&quot;/&gt; ，位于右上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922151953825-1148221293.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;470&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　还是一开始的那幅图,假设如下就是某个医生的诊断统计图,直线代表阈值。我们遍历所有的阈值,能够在ROC平面上得到如下的ROC曲线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201604/764050-20160411174345379-1968591887.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;621&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　曲线距离左上角越近,证明分类器效果越好。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201604/764050-20160411174401488-918162160.png&quot; alt=&quot;&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上,是三条ROC曲线,在0.23处取一条直线。那么,在同样的低FPR=0.23的情况下,红色分类器得到更高的PTR。也就表明,ROC越往上,分类器效果越好。我们用一个标量值AUC来量化它。&lt;/p&gt;
&lt;h4 class=&quot;Second&quot;&gt;5.3 什么是AUC？&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;AUC值为ROC曲线所覆盖的区域面积,显然,AUC越大,分类器分类效果越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。&lt;/p&gt;
&lt;p&gt;　　0.5 &amp;lt; AUC &amp;lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。&lt;/p&gt;
&lt;p&gt;　　AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。&lt;/p&gt;
&lt;p&gt;　　AUC &amp;lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。&lt;/p&gt;
&lt;p&gt;　　以下为ROC曲线和AUC值得实例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922152122753-710329124.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;AUC的物理意义：&lt;/strong&gt;假设分类器的输出是样本属于正类的socre（置信度），则AUC的物理意义为，任取一对（正、负）样本，正样本的score大于负样本的score的概率。&lt;/p&gt;
&lt;p&gt;　　AUC的物理意义正样本的预测结果大于负样本的预测结果的概率。所以AUC反应的是分类器对样本的排序能力。&lt;/p&gt;
&lt;p&gt;　　另外值得注意的是，AUC对样本类别是否均衡并不敏感，这也是不均衡样本通常用AUC评价分类器性能的一个原因。&lt;/p&gt;
&lt;p&gt;　　下面从一个小例子解释AUC的含义：小明一家四口，小明5岁，姐姐10岁，爸爸35岁，妈妈33岁建立一个逻辑回归分类器，来预测小明家人为成年人概率，假设分类器已经对小明的家人做过预测，得到每个人为成人的概率。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AUC更多的是关注对计算概率的排序，关注的是概率值的相对大小，与阈值和概率值的绝对大小没有关系&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　例子中并不关注小明是不是成人，而关注的是，预测为成人的概率的排序。&lt;/p&gt;
&lt;h4 class=&quot;Second&quot;&gt;5.4 怎样计算AUC？&lt;/h4&gt;
&lt;p&gt;　　第一种方法:AUC为ROC曲线下的面积,那我们直接计算面积可得。面积为一个个小的梯形面积之和。计算的精度与阈值的精度有关。&lt;/p&gt;
&lt;p&gt;　　第二种方法:根据AUC的物理意义,我们计算正样本score大于负样本的score的概率。取N*M(N为正样本数,M为负样本数)个二元组,比较score,最后得到AUC。时间复杂度为O(N*M)。&lt;/p&gt;
&lt;p&gt;　　第三种方法:与第二种方法相似,直接计算正样本score大于负样本的概率。我们首先把所有样本按照score排序,依次用rank表示他们,如最大score的样本,rank=n(n=N+M),其次为n-1。那么对于正样本中rank最大的样本,rank_max,有M-1个其他正样本比他score小,那么就有(rank_max-1)-(M-1)个负样本比他score小。其次为(rank_second-1)-(M-2)。最后我们得到正样本大于负样本的概率为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.tuicool.com/Bn26V3.png!web&quot; alt=&quot;&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　时间复杂度为O(N+M)。&lt;/p&gt;
&lt;h2&gt;二，回归&lt;/h2&gt;
&lt;p&gt;　　在回归中，我们想根据连续数据来进行预测。例如，我们有包含不同人员的身高、年龄和性别的列表，并想预测他们的体重。或者，我们可能有一些房屋数据，并想预测某所住宅的价值。手头的问题在很大程度上决定着我们如何评估模型。&lt;/p&gt;
&lt;p&gt;　　以下为一元变量和二元变量的线性回归示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922145405452-522194613.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么怎么来衡量回归模型的好坏呢？&lt;/p&gt;
&lt;p&gt;　　我们首先想到的是采用残差（实际值与预测值的差值）的均值来衡量，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922145916543-1164647625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　那么问题来了：使用残差的均值合理吗？&lt;/h4&gt;
&lt;p&gt;　　当实际值分布在拟合曲线两侧时候，对于不同样本而言&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922150106241-1062843040.png&quot; alt=&quot;&quot;/&gt;有正有负，相互抵消，因此我们想到采用预测值和真实值之间的距离来衡量。&lt;/p&gt;
&lt;h3&gt;2.1 平均绝对误差（MAE）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922110856505-1860268937.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　既然使用了MAE，那他有什么不足？&lt;/h4&gt;
&lt;p&gt;　　MAE虽然较好的衡量回归模型的好坏，但是绝对值的存在导致函数不光滑，在某些点上不能求导，可以考虑将绝对值改为残差的平方，这就是均方误差。&lt;/p&gt;
&lt;h3&gt;2.2 平均平方误差（MSE）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922110921793-1472189262.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;94&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　那么还有没有比MSE更合理一些的指标？&lt;/h4&gt;
&lt;p&gt;　　MSE和方差的性质比较类似，与我们的目标变量的量纲不一致，为了保证量纲一致性，我们需要对MSE进行开方，得到RMSE。&lt;/p&gt;
&lt;h3&gt;2.3 均方根误差（RMSE）&lt;/h3&gt;
&lt;p&gt;　　RMSE虽然广为使用，但是其存在一些缺点，因为它是使用平均误差，而平均值对异常点（outliers）较敏感，如果回归器对某个点的回归值很不理性，那么它的误差则较大，从而会对RMSE的值有较大影响，即平均值是非鲁棒的。&lt;/p&gt;
&lt;p&gt;　　开方之后的MSE称为RMSE，是标准差的表兄弟，如下式所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%7B%5Crm+RMSE%7D%28y%2C+%5Chat%7By%7D%29%3D%5Csqrt+%7B%5Cfrac%7B1%7D%7Bm%7D%5Csum%5Climits_%7Bi%3D1%7D%5E%7Bm%7D%28y_i-%5Chat%7By%7D_i%29%5E2%7D+%5C%5C&quot; alt=&quot;{\rm RMSE}(y, \hat{y})=\sqrt {\frac{1}{m}\sum\limits_{i=1}^{m}(y_i-\hat{y}_i)^2} \\&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　RMSE有没有不足的地方，有没有规范化（无量纲化的指标）？&lt;/h4&gt;
&lt;p&gt;　　上面的几种衡量标准的取值大小与具体的应用场景有关系，很难定义统一的规则来衡量模型的好坏。比如说利用机器学习算法预测上海的房价RMSE在2000元，我们是可以接受的，但是当四五线城市的房价RMSE为2000元，我们还可以接受吗？下面介绍的决定系数就是一个无量纲化的指标。&lt;/p&gt;
&lt;h3&gt;2.4 决定系数&lt;/h3&gt;
&lt;p&gt;　　变量之所以有价值，就是因为变量是变化的。什么意思呢？比如说一组因变量为[0, 0, 0, 0, 0]，显然该因变量的结果是一个常数0，我们也没有必要建模对该因变量进行预测。假如一组的因变量为[1, 3, 7, 10, 12]，该因变量是变化的，也就是有变异，因此需要通过建立回归模型进行预测。这里的变异可以理解为一组数据的方差不为0。&lt;/p&gt;
&lt;p&gt;　　决定系数又称为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R%5E2&quot; alt=&quot;R^2&quot;/&gt; score，反应因变量的全部变异能通过回归关系被自变量解释的比例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7BSST%7D+%3D+%5Csum+%5Climits_i%5Em%28y_i+-+%5Cbar+y%29%5E2+%5Cqquad+%5Ctext%7BSST+%3D+total+sum+of+squares%7D&quot; alt=&quot;\text{SST} = \sum \limits_i^m(y_i - \bar y)^2 \qquad \text{SST = total sum of squares}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7BSSR%7D+%3D+%5Csum+%5Climits_i%5Em%28%5Chat+y_i+-+%5Cbar+y%29%5E2+%5Cqquad+%5Ctext%7BSSR+%3D+sum+of+due+to+regression%7D&quot; alt=&quot;\text{SSR} = \sum \limits_i^m(\hat y_i - \bar y)^2 \qquad \text{SSR = sum of due to regression}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7BSSE%7D+%3D+%5Csum+%5Climits_i%5Em%28%5Chat+y_i+-+y_i%29%5E2+%5Cqquad+%5Ctext%7BSSE+%3D+sum+of+due+to+erros%7D&quot; alt=&quot;\text{SSE} = \sum \limits_i^m(\hat y_i - y_i)^2 \qquad \text{SSE = sum of due to erros}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7BSST+%3D+SSR+%2B+SSE%7D&quot; alt=&quot;\text{SST = SSR + SSE}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=R%5E2%28y%2C%5Chat%7By%7D%29%3D+%5Cfrac%7B%5Crm+SSR%7D%7B%5Crm+SST%7D&quot; alt=&quot;R^2(y,\hat{y})= \frac{\rm SSR}{\rm SST}&quot;/&gt; &lt;br/&gt;　　如果结果是0，就说明模型预测不能预测因变量。 &lt;br/&gt;　　如果结果是1。就说明是函数关系。 &lt;br/&gt;　　如果结果是0-1之间的数，就是我们模型的好坏程度。&lt;/p&gt;
&lt;p&gt;　　化简上面的公式 ,分子就变成了我们的均方误差MSE，下面分母就变成了方差:&lt;br/&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7DR%5E2%28y%2C%5Chat%7By%7D%29+%26%3D+1+-+%5Cfrac%7B%5Crm+SSE%7D%7B%5Crm+SST%7D+%5C%5C%26%3D1-%5Cfrac%7B%5Csum%5Climits_%7Bi%3D1%7D%5E%7Bm%7D%28y_i-%5Chat%7By%7D_i%29%5E2%7D%7B%5Csum%5Climits_%7Bi%3D1%7D%5E%7Bm%7D%28y_i-%5Cbar%7By%7D%29%5E2%7D+%5C%5C%26%3D1-%5Cfrac%7B%5Csum%5Climits_%7Bi%3D1%7D%5E%7Bm%7D%28y_i-%5Chat%7By%7D_i%29%5E2%2Fm%7D%7B%5Csum%5Climits_%7Bi%3D1%7D%5E%7Bm%7D%28y_i-%5Cbar%7By%7D%29%5E2%2Fm%7D+%5C%5C%26%3D+1+-+%5Cfrac%7B%5Crm+MSE%28%5Chat+y%2C+y%29%7D%7B%5Crm+Var%28y%29%7D+%5Cend%7Balign%7D%5C%5C&quot; alt=&quot;\begin{align}R^2(y,\hat{y}) &amp;amp;= 1 - \frac{\rm SSE}{\rm SST} \\&amp;amp;=1-\frac{\sum\limits_{i=1}^{m}(y_i-\hat{y}_i)^2}{\sum\limits_{i=1}^{m}(y_i-\bar{y})^2} \\&amp;amp;=1-\frac{\sum\limits_{i=1}^{m}(y_i-\hat{y}_i)^2/m}{\sum\limits_{i=1}^{m}(y_i-\bar{y})^2/m} \\&amp;amp;= 1 - \frac{\rm MSE(\hat y, y)}{\rm Var(y)} \end{align}\\&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922111009872-133154539.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;161&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 　　以上的评估指标有没有缺陷，如果有，该如何改进呢？&lt;/h4&gt;
&lt;p&gt;　　以上的评估指标是基于误差的均值对进行评估的，均值对异常点（outliers）较敏感，如果样本中有一些异常值出现，会对以上指标的值有较大影响，即均值是非鲁棒的。&lt;/p&gt;
&lt;h3&gt;2.5 解决评估指标鲁棒性问题&lt;/h3&gt;
&lt;p&gt;我们通常用一下两种方法解决评估指标的鲁棒性问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;剔除异常值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设定一个相对误差 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7Cy_i-%5Chat%7By_i%7D%7C%7D%7By_i%7D&quot; alt=&quot;\frac{|y_i-\hat{y_i}|}{y_i}&quot;/&gt; ，当该值超过一定的阈值时，则认为其是一个异常点，剔除这个异常点，将异常点剔除之后。再计算平均误差来对模型进行评价。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用误差的分位数来代替，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如利用中位数来代替平均数。例如 MAPE:&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=MAPE%3Dmedian%28%7Cy_i-%5Chat%7By_i%7D%7C%2Fy_i%29+%5C%5C&quot; alt=&quot;MAPE=median(|y_i-\hat{y_i}|/y_i) \\&quot;/&gt; &lt;br/&gt;　　MAPE是一个相对误差的中位数，当然也可以使用别的分位数。&lt;/p&gt;
&lt;h3&gt;2.6 解释变异&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201809/1226410-20180922110944306-1372758641.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;98&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三，聚类&lt;/h2&gt;
&lt;p&gt;　　常见的聚类模型有KMeans、密度聚类、层次聚类等，主要从簇内的稠密成都和簇间的离散程度来评估聚类的效果，评估指标包括：&lt;/p&gt;
&lt;h2&gt;1 . 兰德指数&lt;/h2&gt;
&lt;p&gt;　　兰德指数（Rand index）需要给定实际类别信息&lt;span id=&quot;MathJax-Element-89-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1651&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1652&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1653&quot; class=&quot;mi&quot;&gt;C&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，假设&lt;span id=&quot;MathJax-Element-90-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;K&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1654&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1655&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1656&quot; class=&quot;mi&quot;&gt;K&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;是聚类结果，&lt;span id=&quot;MathJax-Element-91-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1657&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1658&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1659&quot; class=&quot;mi&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;a表示在&lt;span id=&quot;MathJax-Element-92-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1660&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1661&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1662&quot; class=&quot;mi&quot;&gt;C&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;与&lt;span id=&quot;MathJax-Element-93-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;K&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1663&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1664&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1665&quot; class=&quot;mi&quot;&gt;K&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;中都是同类别的元素对数，&lt;span id=&quot;MathJax-Element-94-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1666&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1667&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1668&quot; class=&quot;mi&quot;&gt;b&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;表示在&lt;span id=&quot;MathJax-Element-95-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1669&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1670&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1671&quot; class=&quot;mi&quot;&gt;C&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;与&lt;span id=&quot;MathJax-Element-96-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;K&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1672&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1673&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1674&quot; class=&quot;mi&quot;&gt;K&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;中都是不同类别的元素对数，则兰德指数为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1180120/201808/1180120-20180806180727337-2040791801.png&quot; alt=&quot;&quot; width=&quot;129&quot; height=&quot;54&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/1180120/201808/1180120-20180806180839468-1245828502.png&quot; alt=&quot;&quot; width=&quot;43&quot; height=&quot;21&quot;/&gt;数据集中可以组成的总元素对数，RI取值范围为&lt;span id=&quot;MathJax-Element-99-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1721&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1722&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1723&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1724&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-1725&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-1726&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-1727&quot; class=&quot;mo&quot;&gt;]&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，值越大意味着聚类结果与真实情况越吻合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对于随机结果，RI并不能保证分数接近零。为了实现“在聚类结果随机产生的情况下，指标应该接近零”，调整兰德系数（Adjusted rand index）被提出，它具有更高的区分度：&lt;/p&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1180120/201808/1180120-20180806180912294-1236260885.png&quot; alt=&quot;&quot; width=&quot;161&quot; height=&quot;43&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体计算方式参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index&quot;&gt;Adjusted Rand index&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　ARI取值范围为&lt;span id=&quot;MathJax-Element-101-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1766&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1767&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1768&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1769&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-1770&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-1771&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-1772&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-1773&quot; class=&quot;mo&quot;&gt;]&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，值越大意味着聚类结果与真实情况越吻合。从广义的角度来讲，ARI衡量的是两个数据分布的吻合程度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. 互信息&lt;/h2&gt;
&lt;p&gt;　　互信息（Mutual Information）也是用来衡量两个数据分布的吻合程度。假设&lt;span id=&quot;MathJax-Element-102-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;U&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1774&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1775&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1776&quot; class=&quot;mi&quot;&gt;U&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;U与&lt;span id=&quot;MathJax-Element-103-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;V&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1777&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1778&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1779&quot; class=&quot;mi&quot;&gt;V&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;V是对&lt;span id=&quot;MathJax-Element-104-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;N&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1780&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1781&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1782&quot; class=&quot;mi&quot;&gt;N&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;N个样本标签的分配情况，则两种分布的熵（熵表示的是不确定程度）分别为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;U&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1180120/201808/1180120-20180806181011578-237575517.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;337&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　利用基于互信息的方法来衡量聚类效果需要实际类别信息，MI与NMI取值范围为&lt;span id=&quot;MathJax-Element-113-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-2080&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2081&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2082&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-2083&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-2084&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-2085&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-2086&quot; class=&quot;mo&quot;&gt;]&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，AMI取值范围为&lt;span id=&quot;MathJax-Element-114-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-2087&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2088&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2089&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-2090&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-2091&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-2092&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-2093&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-2094&quot; class=&quot;mo&quot;&gt;]&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，它们都是值越大意味着聚类结果与真实情况越吻合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. 轮廓系数&lt;/h2&gt;
&lt;p&gt;　　轮廓系数（Silhouette coefficient）适用于实际类别信息未知的情况。对于单个样本，设&lt;span id=&quot;MathJax-Element-115-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-2095&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2096&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2097&quot; class=&quot;mi&quot;&gt;a&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;a是与它同类别中其他样本的平均距离，&lt;span id=&quot;MathJax-Element-116-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-2098&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2099&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2100&quot; class=&quot;mi&quot;&gt;b&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;b是与它距离最近不同类别中样本的平均距离，轮廓系数为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1180120/201808/1180120-20180806181107733-987187523.png&quot; alt=&quot;&quot; width=&quot;114&quot; height=&quot;43&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于一个样本集合，它的轮廓系数是所有样本轮廓系数的平均值。&lt;/p&gt;
&lt;p&gt;　　轮廓系数取值范围是&lt;span id=&quot;MathJax-Element-118-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-2117&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2118&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2119&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-2120&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-2121&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-2122&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-2123&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-2124&quot; class=&quot;mo&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;四，信息检索&lt;/h2&gt;
&lt;p&gt;　　信息检索评价是对信息检索系统性能（主要满足用户信息需求的能力）进行评估，与机器学习也有较大的相关性。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　上面介绍了非常多的指标，实际应用中需要根据具体问题选择合适的衡量指标。那么具体工作中如何快速使用它们呢？优秀的Python机器学习开源项目&lt;a href=&quot;http://scikit-learn.org/stable/modules/model_evaluation.html&quot;&gt;Scikit-learn&lt;/a&gt;实现了上述绝指标的大多数，使用起来非常方便。&lt;/p&gt;

&lt;p&gt;信息检索参考资料（还有一些未补充到）：&lt;br/&gt;&lt;a href=&quot;http://wenku.baidu.com/view/1c6fb7d7b9f3f90f76c61b74.html&quot;&gt;http://wenku.baidu.com/view/1c6fb7d7b9f3f90f76c61b74.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Precision_and_recall&quot;&gt;http://en.wikipedia.org/wiki/Precision_and_recall&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/eyeszjwang/articles/2368087.html&quot;&gt;http://www.cnblogs.com/eyeszjwang/articles/2368087.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot;&gt; https://en.wikipedia.org/wiki/F1_score&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 07:09:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>在机器学习中，性能指标（Metrics）是衡量一个模型好坏的关键，通过衡量模型输出y_predict和y_true之间的某种“距离”得出的。 性能指标往往使我们做模型时的最终目标，如准确率，召回率，敏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/9400375.html</dc:identifier>
</item>
<item>
<title>如何入门大数据 - 大叔据</title>
<link>http://www.cnblogs.com/uncleData/p/9712458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uncleData/p/9712458.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;大数据需要学习什么？很多人问过我这个问题。每一次回答完都觉得自己讲得太片面了，总是没有一个合适的契机去好好总结这些内容，直到开始写这篇东西。大数据是近五年兴起的行业，发展迅速，很多技术经过这些年的迭代也变得比较成熟了，同时新的东西也不断涌现，想要保持自己竞争力的唯一办法就是不断学习。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;java&quot;&gt;Java&lt;/h2&gt;
&lt;p&gt;java可以说是大数据最基础的编程语言，据我这些年的经验，我接触的很大一部分的大数据开发都是从Jave Web开发转岗过来的（当然也不是绝对我甚至见过产品转岗大数据开发的，逆了个天）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是因为大数据的本质无非就是海量数据的计算，查询与存储，后台开发很容易接触到大数据量存取的应用场景&lt;/li&gt;
&lt;li&gt;二就是java语言本事了，天然的优势，因为大数据的组件很多都是用java开发的像HDFS,Yarn,Hbase,MR,Zookeeper等等，想要深入学习，填上生产环境中踩到的各种坑，必须得先学会java然后去啃源码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说到啃源码顺便说一句，开始的时候肯定是会很难，需要对组件本身和开发语言都有比较深入的理解，熟能生巧慢慢来，等你过了这个阶段，习惯了看源码解决问题的时候你会发现源码真香。&lt;/p&gt;
&lt;h2 id=&quot;python和shell&quot;&gt;Python和Shell&lt;/h2&gt;
&lt;p&gt;shell应该不用过多的介绍非常的常用，属于程序猿必备的通用技能。python更多的是用在数据挖掘领域以及写一些复杂的且shell难以实现的日常脚本。&lt;/p&gt;

&lt;p&gt;什么是分布式计算？分布式计算研究的是如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多服务器进行处理，最后把这些计算结果综合起来得到最终的结果。&lt;/p&gt;
&lt;p&gt;举个栗子，就像是组长把一个大项目拆分，让组员每个人开发一部分，最后将所有人代码merge，大项目完成。听起来好像很简单，但是真正参与过大项目开发的人一定知道中间涉及的内容可不少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如这个大项目如何拆分？任务如何分配？每个人手头已有工作怎么办？每个人能力不一样怎么办？每个人开发进度不一样怎么办？开发过程中组员生病要请长假他手头的工作怎么办？指挥督促大家干活的组长请假了怎么办？最后代码合并过程出现问题怎么办？项目延期怎么办？项目最后黄了怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仔细想想上面的夺命十连问，其实每一条都是对应了分布式计算可能会出现的问题，具体怎么对应大家思考吧我就不多说了，其实已经是非常明显了。也许有人觉得这些问题其实在多人开发的时候都不重要不需要特别去考虑怎么办，但是在分布式计算系统中不一样，每一个都是非常严重并且非常基础的问题，需要有很好的解决方案。&lt;/p&gt;
&lt;p&gt;最后提一下，分布式计算目前流行的工具有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;离线工具Spark，MapReduce等&lt;/li&gt;
&lt;li&gt;实时工具Spark Streaming，Storm，Flink等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这几个东西的区别和各自的应用场景我们之后再聊。&lt;/p&gt;

&lt;p&gt;传统的网络存储系统采用的是集中的存储服务器存放所有数据，单台存储服务器的io能力是有限的，这成为了系统性能的瓶颈，同时服务器的可靠性和安全性也不能满足需求，尤其是大规模的存储应用。&lt;/p&gt;
&lt;p&gt;分布式存储系统，是将数据分散存储在多台独立的设备上。采用的是可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491039/201809/1491039-20180923163220973-309243746.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是hdfs的存储架构图，hdfs作为分布式文件系统，兼备了可靠性和扩展性，数据存储3份在不同机器上（两份存在同一机架，一份存在其他机架）保证数据不丢失。由NameNode统一管理元数据，可以任意扩展集群。&lt;/p&gt;
&lt;p&gt;主流的分布式数据库有很多hbase，mongoDB，GreenPlum，redis等等等等，没有孰好孰坏之分，只有合不合适，每个数据库的应用场景都不同，其实直接比较是没有意义的，后续我也会有文章一个个讲解它们的应用场景原理架构等。&lt;/p&gt;

&lt;p&gt;现在人们好像都很热衷于谈&quot;去中心化&quot;，也许是区块链带起的这个潮流。但是&quot;中心化&quot;在大数据领域还是很重要的，至少目前来说是的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式的集群管理需要有个组件去分配调度资源给各个节点，这个东西叫yarn;&lt;/li&gt;
&lt;li&gt;需要有个组件来解决在分布式环境下&quot;锁&quot;的问题，这个东西叫zookeeper；&lt;/li&gt;
&lt;li&gt;需要有个组件来记录任务的依赖关系并定时调度任务，这个东西叫azkaban。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然这些“东西”并不是唯一的，其实都是有很多替代品的，我这里只举了几个比较常用的例子。&lt;/p&gt;

&lt;p&gt;scala和java很相似都是在jvm运行的语言，在开发过程中是可以无缝互相调用的。&lt;/p&gt;
&lt;p&gt;Scala在大数据领域的影响力大部分都是来自社区中的明星Spark和kafka,&lt;br/&gt;这两个东西大家应该都知道（后面我会有文章多维度介绍它们），它们的强势发展直接带动了Scala在这个领域的流行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公众号有一套关于这个的视频，关注后,后台回复1和2即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Scala 入门&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scala的基础语法、编译环境、常用类型、声明等&lt;/p&gt;
&lt;p&gt;Scala的行、字符、二进制与文本文件的读取与写入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Scala 的函数式编程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scala的控制结构（赋值、条件、循环、输入输出）与函数（参数与过程）&lt;/p&gt;
&lt;p&gt;Scala的数组操作（定义、遍历、转换）及常用算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Scala 的面向对象编程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scala的类和对象构造与继承、重写、抽象、转换，&lt;/p&gt;
&lt;p&gt;类与对象中特质的属性与使用，包的使用与引入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Scala的高级基础一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scala的操作符调用与重载，集合的处理，高阶函数与类型函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. Scala的高级基础二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scala解释器的使用，高级类型与类库（actor，akka），对象式模块化编程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spark入门&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spark部署&lt;/li&gt;
&lt;li&gt;Spark编程模型(1)&lt;/li&gt;
&lt;li&gt;Spark运行架构(1)&lt;/li&gt;
&lt;li&gt;Spark SQL原理和实践(4)&lt;/li&gt;
&lt;li&gt;Spark Streaming原理和实践&lt;/li&gt;
&lt;li&gt;Spark 机器学习入门&lt;/li&gt;
&lt;li&gt;GraphX 入门&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/uncleData/p/9704934.html&quot;&gt;聊聊Zookeeper应用场景、架构设计、选主机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/uncleData/p/9689322.html&quot;&gt;redis调优的实战经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491039/201809/1491039-20180926190009947-1064379018.jpg&quot; alt=&quot;欢迎关注大叔据&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 07:09:00 +0000</pubDate>
<dc:creator>大叔据</dc:creator>
<og:description>大数据需要学习什么？很多人问过我这个问题。每一次回答完都觉得自己讲得太片面了，总是没有一个合适的契机去好好总结这些内容，直到开始写这篇东西。大数据是近五年兴起的行业，发展迅速，很多技术经过这些年的迭代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uncleData/p/9712458.html</dc:identifier>
</item>
<item>
<title>在公网上的Linux，我的一些配置分享 - 顺风椰子皮</title>
<link>http://www.cnblogs.com/BenAndWang/p/9713080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BenAndWang/p/9713080.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;去年的时候，有一篇介绍搭建ss服务器的文章，由于某些众所周知的原因，被阿里云删除。&lt;/p&gt;
&lt;p&gt;后来有段时间使用vps，配合《鸟哥私房菜》，学习实操linux。当时我以为只要root密码够复杂，就一切ok，有一两个月没有太关注安全的问题。偶然一次使用&lt;code&gt;lastb&lt;/code&gt;命令，着实下了一跳，我的vps每天都有几万次的失败登陆记录。尝试登陆的IP，有俄罗斯，越南，巴西。。。。基本上地球上所有国家都有来过。&lt;/p&gt;
&lt;p&gt;这个时候我才意识到，如果不做相关的安全方面的措施，在公网的环境下，与裸奔无异。我的vps是CentOS 7，以下所有涉及到的配置文件，相关命令都是在CentOS 7以下并且生效了的。&lt;/p&gt;
&lt;h2 id=&quot;安装-denyhosts&quot;&gt;安装 denyhosts&lt;/h2&gt;
&lt;p&gt;denyhosts 是查询了几万次的失败记录后，立即安装的。维基上面的简介&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DenyHosts是针对SSH服务器的一个基于日志的入侵预防安全工具，是用Python编写的。其通过监测身份验证登录日志中失败的登录尝试，屏蔽这些登录者的IP地址，从而预防对SSH服务器的暴力破解。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件路径&lt;code&gt;/etc/denyhosts.conf&lt;/code&gt;，里面可以配置的项很多，也有详细说明，我只修改了通知的用户。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sed -i &quot;s/root@localhost/{用户名}@localhost/g&quot; /etc/denyhosts.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果还是很明显的，扫描从每天从几万降到了一千左右。但是这一千左右的失败登陆也是不能忍的。&lt;/p&gt;
&lt;p&gt;PS：把失败的记录基本降为0以后，我考虑通过邮件第一时间通知我，有人尝试登陆我的主机。后来再网上在查询，好像是不直接支持的，还需要安装专门发送邮件的postfix，仅仅为了这个发送邮件，好像也没有太大的必要。就放弃了。&lt;/p&gt;
&lt;h2 id=&quot;使用密钥登陆&quot;&gt;使用密钥登陆&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95&quot;&gt;维基：RSA非对称加密算法&lt;/a&gt; 我也就了解到，是大数的质因数分解，也简单做推算过，目前还是很安全的。有兴趣可以去网上找，&lt;a href=&quot;https://weibo.com/tv/v/GfGM6Asg9?fid=1034:b278ef8fda19fe8c5bd3fd1aa30e3ad4&quot;&gt;李永乐老师的讲解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在客户端生成公钥和私钥，然后把公钥上传到服务器，在&lt;code&gt;/home/{你的用户名}/.ssh/authorized_keys&lt;/code&gt;文件下追加一条记录。客户端使用私钥登陆。相关的教程网上很多，不做赘述。需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RSA的版本和SSH版本，现在目前系统都是默认RSA2，SSH2，并且默认禁用低版本的，可以忽略；&lt;/li&gt;
&lt;li&gt;在生成密钥的时候，可以不设置密码，我还是建议可以用一个简单的密码，不用太复杂；&lt;/li&gt;
&lt;li&gt;注意目录(700)和文件(600)的&lt;code&gt;权限&lt;/code&gt;；追加的时候注意&lt;code&gt;换行&lt;/code&gt;和&lt;code&gt;回车&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;目前和未来几年内这个算法是安全的，&lt;strong&gt;但是量子计算机破解就是一两分钟，甚至一秒钟就搞定&lt;/strong&gt;，要有这方面意识。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两天，阿提亚爵士声称证明了黎曼猜想。不过看新闻报道，好像是数学家们认为希望不大。如果黎曼猜想被证明了的话，就意味着&lt;code&gt;以素数为基础的所有加密算法&lt;/code&gt;都是不安全的。&lt;/p&gt;
&lt;h2 id=&quot;禁用root用户&quot;&gt;禁用root用户&lt;/h2&gt;
&lt;p&gt;这个比较简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改配置文件是在：&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;搜索&lt;code&gt;PermitRootLogin yes&lt;/code&gt;，一般是注释的&lt;code&gt;#PermitRootLogin yes&lt;/code&gt;; 去掉注释，改为&lt;code&gt;no&lt;/code&gt;就可以了。&lt;/li&gt;
&lt;li&gt;根据个人需要，普通用户是否可以使用密码登陆，&lt;code&gt;PasswordAuthentication&lt;/code&gt;；我修改的是&lt;code&gt;yes&lt;/code&gt;，我认为我可能会在临时的电脑上用密码登陆。&lt;/li&gt;
&lt;li&gt;重启ssh: &lt;code&gt;systemctl restart sshd&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;更改-ssh-端口&quot;&gt;更改 ssh 端口&lt;/h2&gt;
&lt;p&gt;把系统默认的ssh端口22，改为一个用户自定义的，&lt;code&gt;1024&lt;/code&gt;以下是系统保留的，从&lt;code&gt;1024-65535&lt;/code&gt;是用户使用的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改配置文件是在：&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;在文件中找到&lt;code&gt;#Port 22&lt;/code&gt; 默认是注释掉的，然后去掉注释，改为其他端口号，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;千万一定要注意，记得把自定义的端口，加入到防火墙中，tcp协议&lt;/strong&gt;，否则可能面临无法登陆了。&lt;/li&gt;
&lt;li&gt;重启ssh: &lt;code&gt;systemctl restart sshd&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;禁用-selinuxsecurity-enhanced-linux&quot;&gt;禁用 SELinux(Security-Enhanced Linux)&lt;/h2&gt;
&lt;p&gt;因为这个vps只有我一个人使用，并且也要时不时的折腾折腾，所以为了不必要的困扰，就把这个给禁用了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改配置文件是在：&lt;code&gt;/etc/selinux/config&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;SELINUX=enforcing&lt;/code&gt;修改为&lt;code&gt;SELINUX=disabled&lt;/code&gt;，永久关闭;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setenforce 0&lt;/code&gt; 临时关闭，&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;susudo-免密码&quot;&gt;su，sudo 免密码&lt;/h2&gt;
&lt;p&gt;我的密码是vps厂商自动生成的，非常复杂。为了避免要在使用root权限时，还要再输入密码。并且既然我的账号都登陆了，就不应该再次输入密码了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把用户加入 wheel 组(wheel)，为了免密码 &lt;code&gt;usermod -aG wheel {用户名}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;su 免密码，配置文件&lt;code&gt;/etc/pam.d/su&lt;/code&gt;，加上这句话&lt;code&gt;auth sufficient pam_wheel.so trust use_uid&lt;/code&gt; ，CentOS7是注释掉的。&lt;/li&gt;
&lt;li&gt;sudo 免密码，配置文件&lt;code&gt;/etc/sudoers&lt;/code&gt;，把所在组 wheel 设置&lt;code&gt;%wheel ALL=(ALL) NOPASSWD: ALL&lt;/code&gt;,&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# wheel组 sudo不需要密码
sed -i 's/^%wheel.*/%wheel ALL=(ALL) NOPASSWD: ALL/g' /etc/sudoers
# wheel组 su 不需要密码
sed -i 's/^#auth\s\+sufficient\s\+pam_wheel.so\s\+trust\s\+use_uid/auth sufficient pam_wheel.so trust use_uid/g' /etc/pam.d/su&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;防火墙设置&quot;&gt;防火墙设置&lt;/h2&gt;
&lt;p&gt;一般linux发行版本都是默认开启防火墙的，并且开启了22端口。&lt;br/&gt;使用哪个端口就开哪个，不用了的端口一定要关闭，并且使用了tcp协议，只开tcp协议。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;firewall-cmd --zone=public --permanent --add-port=${my_ssh_port}/tcp
firewall-cmd --reload&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止ping&quot;&gt;禁止Ping&lt;/h2&gt;
&lt;p&gt;我之前禁用过一段时间，因为网络不太稳定，还需要使用ping命令来看看是网络不通，还是延迟过高。所以就放开了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;禁用ICMP协议。&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;，增加&lt;code&gt;net.ipv4.icmp_echo_ignore_all = 1&lt;/code&gt;，1禁用，0启用；&lt;/li&gt;
&lt;li&gt;使配置生效&lt;code&gt;sysctl -p&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;别名设置&quot;&gt;别名设置&lt;/h2&gt;
&lt;p&gt;为了操作自己的linux 更加方便，可以做很多自定义的命令。好处是很方便，坏处就是换台机器可能就不会玩了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;shell文件在&lt;code&gt;/etc/profile.d/&lt;/code&gt;目录下，对所有用户生效，用户登陆执行下面的所有脚本。注意这个目录下的脚本执行&lt;code&gt;顺序&lt;/code&gt;是第一个执行的，也就是说 alias 会被后面的覆盖，&lt;/li&gt;
&lt;li&gt;一些登陆后初始化的脚本，环境变量设置，都建议放在这个目录下面&lt;code&gt;/etc/profile.d/&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PS1&lt;/code&gt;PS(Prompt Sign): 是指命令提示符，当然调整了一下颜色&lt;code&gt;root@myhost:etc#&lt;/code&gt;，&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    cat &amp;gt; /etc/profile.d/alias.sh &amp;lt;&amp;lt;-EOF
PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\W\[\033[00m\]\\$ '
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -i'
alias ls='ls --color=auto'
alias ll='ls -al'
alias lm='ls -al | more'
alias dir='dir --color=auto'
alias vdir='vdir --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias mkcd='function _mkcd(){ mkdir \$@ &amp;amp;&amp;amp; cd \$@; }; _mkcd'
alias cdl='function _cdl() { cd \$@ &amp;amp;&amp;amp; pwd; ls -alF; }; _cdl'
    EOF&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;这些设置大概是半年前做的了，断断续续的；有些遗漏或是不准确的地方欢迎指出；&lt;/li&gt;
&lt;li&gt;再修改配置文件的时候，建议花一些时间看一下里面的&lt;code&gt;注释&lt;/code&gt;。绝大部分配置文件里面，注释非常清楚，并且占了文件的大部分内容；&lt;/li&gt;
&lt;li&gt;我把以上的内容，写成了sh脚本。运行过无误，&lt;a href=&quot;https://github.com/MrBenWang/MyBackUp/blob/master/vps/install_env_vps.sh&quot;&gt;仅供参考&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;一年多的时间博客没有怎么更新，这几天会记录一下这段时间的积累。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 27 Sep 2018 06:57:00 +0000</pubDate>
<dc:creator>顺风椰子皮</dc:creator>
<og:description>前言 去年的时候，有一篇介绍搭建ss服务器的文章，由于某些众所周知的原因，被阿里云删除。 后来有段时间使用vps，配合《鸟哥私房菜》，学习实操linux。当时我以为只要root密码够复杂，就一切ok，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BenAndWang/p/9713080.html</dc:identifier>
</item>
<item>
<title>大战红黑树 - 吴庆龙</title>
<link>http://www.cnblogs.com/wuqinglong/p/9709048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuqinglong/p/9709048.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;红黑树是一种自平衡的二叉查找树,是一种高效的查找树.&lt;/li&gt;
&lt;li&gt;红黑树具有良好的效率, 它可在O(logN)时间内完成查找,增加,删除等操作.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意: 下文中, 非红色节点就是黑色节点, 即NULL节点是黑色节点&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;节点是红色或黑色.&lt;/li&gt;
&lt;li&gt;根节点是黑色.&lt;/li&gt;
&lt;li&gt;每个叶子节点(NULL节点/空节点)是黑色.&lt;/li&gt;
&lt;li&gt;每个红色节点的两个孩子节点必须是黑色. (从叶子到根的所有路径上不能有两个连续的红色节点)&lt;/li&gt;
&lt;li&gt;从任意节点到其叶子节点的所有路径都包含相同数目的黑色节点.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当树的结构发生改变时(添加/删除元素时), 红黑树的五个特征可能会被打破, 需要通过调整结构和颜色使树重新满足红黑树的特征, 调整可以分为两类:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;颜色调整: 改变节点的颜色&lt;/li&gt;
&lt;li&gt;结构调整: 左旋 + 右旋&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;左旋&quot;&gt;左旋&lt;/h2&gt;
&lt;p&gt;左旋就是成为右孩子的左孩子节点.&lt;/p&gt;
&lt;p&gt;左旋有以下三个步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将旋转节点的右节点的左节点关联到旋转节点的右节点上&lt;/li&gt;
&lt;li&gt;将旋转节点的父节点与旋转节点的右节点进行关联&lt;/li&gt;
&lt;li&gt;将旋转节点与旋转节点的右节点进行关联&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;左旋示例图&quot;&gt;左旋示例图&lt;/h3&gt;
&lt;p&gt;对节点30进行左旋的过程如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926144450458-1432721875.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考treemap的左旋代码&quot;&gt;参考TreeMap的左旋代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** From CLR */
private void rotateLeft(Entry&amp;lt;K,V&amp;gt; p) {

    // p为null就没意思了
    if (p != null) {
        
        // 获取p的右节点r, 临时存储
        Entry&amp;lt;K,V&amp;gt; r = p.right;
        
        // 步骤1
        // 1. 将p的右节点的左节点连接到p的右节点上
        p.right = r.left;
        
        // 2. 将p的右节点的左节点的父节点指向为p
        if (r.left != null)
            r.left.parent = p;
            
        // 步骤2
        // 1. 将p的父节点赋值给r, r的父节点指向为p的父节点
        r.parent = p.parent;
        
        // 2-1. 父节点为空, 根节点即为r
        if (p.parent == null)
            root = r;
        // 2-2. 父节点不为空, 判断p是父节点的左节点还是右节点, 然后进行关联
        else if (p.parent.left == p) // p是父节点的左节点
            p.parent.left = r;
        else  // p是父节点的右节点
            p.parent.right = r;
            
        // 步骤3
        r.left = p;
        p.parent = r;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;右旋&quot;&gt;右旋&lt;/h2&gt;
&lt;p&gt;右旋就是成为左孩子的右孩子节点.&lt;/p&gt;
&lt;p&gt;右旋有以下三个步骤(与左旋相反):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将旋转节点的左节点的右节点关联到旋转节点的左节点上&lt;/li&gt;
&lt;li&gt;将旋转节点的父节点与旋转节点的左节点进行关联&lt;/li&gt;
&lt;li&gt;将旋转节点与旋转节点的左节点进行关联&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;右旋示例图&quot;&gt;右旋示例图:&lt;/h3&gt;
&lt;p&gt;对节点35进行右旋的过程如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926144709942-865565516.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考treemap的右旋代码&quot;&gt;参考TreeMap的右旋代码:&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** From CLR */
private void rotateRight(Entry&amp;lt;K,V&amp;gt; p) {

    // p为null就没意思了
    if (p != null) {
    
        // 临时存储p的左节点
        Entry&amp;lt;K,V&amp;gt; l = p.left;
        
        // 步骤1
        p.left = l.right;
        if (l.right != null) 
            l.right.parent = p;
            
        // 步骤2
        l.parent = p.parent;
        if (p.parent == null)
            root = l;
        else if (p.parent.right == p)
            p.parent.right = l;
        else p.parent.left = l;
        
        // 步骤3
        l.right = p;
        p.parent = l;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;当删除一个节点时, 需要找一个后继节点(也可以使用前驱, 这里我们使用后继)接替删除节点的位置, 那么如何寻找后继节点呢?&lt;/p&gt;
&lt;p&gt;参考TreeMap的寻找后继代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Returns the successor of the specified Entry, or null if no such.
 */
static &amp;lt;K,V&amp;gt; TreeMap.Entry&amp;lt;K,V&amp;gt; successor(Entry&amp;lt;K,V&amp;gt; t) {

    if (t == null) // null is null
        return null;
    else if (t.right != null) { // 右节点非空
    
        // 循环寻找右节点的左节点的左节点..., 直到左节点的左节点为空, 返回.
        Entry&amp;lt;K,V&amp;gt; p = t.right;
        while (p.left != null)
            p = p.left;
        return p;
    } else { // 右节点非空
    
        Entry&amp;lt;K,V&amp;gt; p = t.parent; // 父节点
        Entry&amp;lt;K,V&amp;gt; ch = t; // 当前节点
        while (p != null &amp;amp;&amp;amp; ch == p.right) { // 当前节点是否是父节点的右节点
            ch = p; // 获取父节点的引用
            p = p.parent; // 父节点为祖父节点
        }
        
        // 如果当前节点不是父节点的右节点, 返回当前节点
        return p;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然TreeMap中还有寻找节点的前驱的方法: &lt;code&gt;Entry&amp;lt;K,V&amp;gt; predecessor(Entry&amp;lt;K,V&amp;gt; t)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;实际上前驱后继就是二叉树中序遍历时待删除节点的前驱后继.&lt;/p&gt;

&lt;p&gt;这里主要说红黑树是如何进行新元素插入之后的调节, 来重新让树成为一颗红黑树.&lt;/p&gt;
&lt;p&gt;插入的时候会出现以下四种情况:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;情况1: 新节点(当前节点)为根节点&lt;/li&gt;
&lt;li&gt;情况2: 新节点(当前节点)的父节点为黑色&lt;/li&gt;
&lt;li&gt;情况3: 新节点(当前节点)的父节点为红色 &amp;amp; 叔叔节点为红色&lt;/li&gt;
&lt;li&gt;情况4: 新节点(当前节点)的父节点为红色 &amp;amp; 叔叔节点为黑色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面分别说明各个情况时如何进行处理.&lt;/p&gt;
&lt;h2 id=&quot;情况1-新节点当前节点为根节点&quot;&gt;情况1: 新节点(当前节点)为根节点&lt;/h2&gt;
&lt;p&gt;直接将新节点(当前节点)染为黑色即可.&lt;/p&gt;
&lt;h4 id=&quot;示例图&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;在一棵空树中插入节点20.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926153223672-1627241374.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;情况2-新节点当前节点的父节点为黑色&quot;&gt;情况2: 新节点(当前节点)的父节点为黑色&lt;/h2&gt;
&lt;p&gt;父节点是黑色, 添加一个红色孩子节点并不会影响红黑树的性质, 不需要调整.&lt;/p&gt;
&lt;h4 id=&quot;示例图-1&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;在一棵红黑树中插入节点33, 因为父节点是黑色, 所以不需要进行调整即可.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926153342981-901606965.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;情况3-新节点当前节点的父节点为红色-叔叔节点为红色&quot;&gt;情况3: 新节点(当前节点)的父节点为红色 &amp;amp; 叔叔节点为红色&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;祖父节点一定为黑色.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;处理步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将父节点和叔叔节点染为黑色&lt;/li&gt;
&lt;li&gt;将祖父节点染为红色&lt;/li&gt;
&lt;li&gt;将新节点(当前节点)指向为祖父节点&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该情况与当前节点是父节点的左孩子还是右孩子无关, 因为不涉及旋转.&lt;/p&gt;
&lt;p&gt;这时新节点(当前节点)的颜色还是红色, 可能出现四种情况:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;情况1: 新节点(当前节点)为根节点&lt;/li&gt;
&lt;li&gt;情况2: 新节点(当前节点)的父节点为黑色&lt;/li&gt;
&lt;li&gt;情况3: 新节点(当前节点)的叔叔节点为红色&lt;/li&gt;
&lt;li&gt;情况4: 新节点(当前节点)的叔叔节点为黑色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后再进入对应情况的处理方案中处理.&lt;/p&gt;
&lt;h4 id=&quot;示例图-2&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;在红黑树中插入节点8(X), 插入之后的红黑树如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926163124269-379035039.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显违反了红黑树的性质5, 需要进行调整, 按照情况3的处理步骤进行调整, 调整之后的红黑树如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926163212196-805049244.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后将当前节点(X)指向祖父节点, 继续进行其它情况的调整.&lt;/p&gt;
&lt;h2 id=&quot;情况4-新节点当前节点的父节点为红色-叔叔节点为黑色&quot;&gt;情况4: 新节点(当前节点)的父节点为红色 &amp;amp; 叔叔节点为黑色&lt;/h2&gt;
&lt;p&gt;处理步骤(当前节点是父节点的左节点):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断新节点(当前节点)是否是父节点的右孩子节点
&lt;ol&gt;&lt;li&gt;是: 新节点(当前节点)指向父节点, 然后对当前节点进行左旋&lt;/li&gt;
&lt;li&gt;否: 不作处理&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;将父节点染为黑色&lt;/li&gt;
&lt;li&gt;将祖父节点染为红色&lt;/li&gt;
&lt;li&gt;对祖父节点进行右旋&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;处理步骤(当前节点是父节点的右节点):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断新节点(当前节点)是否是父节点的左孩子节点
&lt;ol&gt;&lt;li&gt;是: 新节点(当前节点)指向父节点, 然后对当前节点进行右旋&lt;/li&gt;
&lt;li&gt;否: 不作处理&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;将父节点染为黑色&lt;/li&gt;
&lt;li&gt;将祖父节点染为红色&lt;/li&gt;
&lt;li&gt;对祖父节点进行左旋&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以当前节点是父节点的左节点为例, 步骤1-1完成之后, 就变为当前节点是父节点的左孩子节点, 并且叔叔节点是黑色. 如果当前节点本就是父节点的左孩子节点, 则不进行处理, 直接进入步骤2.&lt;/p&gt;
&lt;p&gt;这时新节点的的颜色还是红色, 兄弟节点的颜色为红色, 父节点为黑色, 可能出现四种情况:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;情况1: 新节点(当前节点)为根节点&lt;/li&gt;
&lt;li&gt;情况2: 新节点(当前节点)的父节点为黑色&lt;/li&gt;
&lt;li&gt;情况3: 新节点(当前节点)的叔叔节点为红色&lt;/li&gt;
&lt;li&gt;情况4: 新节点(当前节点)的叔叔节点为黑色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后再进入对应情况的处理方案中处理.&lt;/p&gt;
&lt;h4 id=&quot;示例图-3&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;继续调整情况3中的红黑树:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926163212196-805049244.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照情况4进行调整之后, 调整之后的红黑树如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180926163311899-77849088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调整完成.&lt;/p&gt;
&lt;h2 id=&quot;插入总结&quot;&gt;插入总结&lt;/h2&gt;
&lt;p&gt;当新插入一个元素时, 先按照二叉排序树的方法进行元素的插入, 之后将新元素的颜色染为红色, 然后对树进行调整, 使其重新成为红黑树.&lt;/p&gt;
&lt;h2 id=&quot;参考treemap的插入调整代码&quot;&gt;参考TreeMap的插入调整代码&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** From CLR */
private void fixAfterInsertion(Entry&amp;lt;K,V&amp;gt; x) {

    // 默认新节点的颜色为红色
    x.color = RED;

    // 父节点为黑色时, 增加一个红色节点并不会影响红黑树
    while (x != null &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color == RED) {
        
        // 父节点为祖父节点的左节点
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            
            // 获取叔叔节点
            Entry&amp;lt;K,V&amp;gt; y = rightOf(parentOf(parentOf(x)));
            
            if (colorOf(y) == RED) { // 叔叔节点为红色时
            
                // 父节点和兄弟节点染为黑色
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                
                // 祖父节点染为红色
                setColor(parentOf(parentOf(x)), RED);
                
                // 当前节点指向为祖父节点
                x = parentOf(parentOf(x));
            } else { // 叔叔节点为黑色时
            
                // 判断当前节点的左右
                // 将当前节点调整为父节点的左节点
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateLeft(x);
                }
                
                // 父节点染为黑色
                setColor(parentOf(x), BLACK);
                
                // 祖父节点染为红色
                setColor(parentOf(parentOf(x)), RED);
                
                // 对祖父节点进行右旋
                rotateRight(parentOf(parentOf(x)));
            }
        } else {
            Entry&amp;lt;K,V&amp;gt; y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    
    // 最后将根节点染为黑色? 为什么需要这段代码, 我觉得你应该知道的.
    root.color = BLACK;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;相对于插入, 红黑树的删除操作要复杂的多, 不过我们拆解分析, 就简单了, 把复杂问题拆解为小问题.&lt;/p&gt;
&lt;p&gt;对于一颗红黑树, 其删除节点的情况可以分为3种:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;情况1: 节点既有左子树又有右子树&lt;/li&gt;
&lt;li&gt;情况2: 节点只有左子树或只有右子树&lt;/li&gt;
&lt;li&gt;情况3: 节点既没有左子树又没有右子树(叶子节点)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于情况1, 我们首先要找到该节点的前驱或后继节点, 使用前驱或后继节点的值覆盖待删除节点的值, 然后将前驱或后继节点按照情况2或情况3进行删除即可. 前驱或者后继节点顶多有一个子节点.&lt;/p&gt;
&lt;p&gt;所以, 对于红黑树来说, 实际删除节点的情况只有两种(情况2和情况3).&lt;/p&gt;
&lt;h2 id=&quot;情况2出现的情况&quot;&gt;情况2出现的情况&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;情况2-1: 待删除节点为红色
&lt;ul&gt;&lt;li&gt;情况2-1-1: 待删除节点的右孩子为黑色(不存在)&lt;/li&gt;
&lt;li&gt;情况2-1-2: 待删除节点的右孩子为红色(不存在)&lt;/li&gt;
&lt;li&gt;情况2-1-3: 待删除节点的左孩子为黑色(不存在)&lt;/li&gt;
&lt;li&gt;情况2-1-4: 待删除节点的左孩子为红色(不存在)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;情况2-2: 待删除节点为黑色
&lt;ul&gt;&lt;li&gt;情况2-2-1: 待删除节点的右孩子为黑色(不存在)&lt;/li&gt;
&lt;li&gt;情况2-2-2: 待删除节点的右孩子为红色&lt;/li&gt;
&lt;li&gt;情况2-2-3: 待删除节点的左子树为黑色(不存在)&lt;/li&gt;
&lt;li&gt;情况2-2-4: 待删除节点的左孩子为红色&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析情况2, 只有情况2-2-2和情况2-2-4成立, 而这两种情况下只需要把红色节点删除即可.&lt;br/&gt;其它情况并不符合红黑树的特性, 所以根本不会存在其它情况的删除.&lt;/p&gt;
&lt;h3 id=&quot;情况2-2-2-待删除节点为黑色-待删除节点的右孩子为红色&quot;&gt;情况2-2-2: 待删除节点为黑色 &amp;amp; 待删除节点的右孩子为红色&lt;/h3&gt;
&lt;p&gt;处理步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将其右孩子链接到其父节点上.&lt;/li&gt;
&lt;li&gt;将右孩子染为黑色即可.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种情况就是普通的节点删除操作&lt;/p&gt;
&lt;h4 id=&quot;示例图-4&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;在下图红黑树中, 要删除节点25&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927105917523-1739943293.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照上述的处理步骤进行调整, 调整之后的红黑树如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927110047876-2139422350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接把孩子节点染为黑色, 然后替换被删除节点的位置即可.&lt;/p&gt;
&lt;h3 id=&quot;情况2-2-2-待删除节点为黑色-待删除节点的左孩子为红色&quot;&gt;情况2-2-2: 待删除节点为黑色 &amp;amp; 待删除节点的左孩子为红色&lt;/h3&gt;
&lt;p&gt;处理步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将其左孩子链接到其父节点上.&lt;/li&gt;
&lt;li&gt;将左孩子染为黑色即可.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种情况就是普通的节点删除操作.&lt;/p&gt;
&lt;h4 id=&quot;示例图-5&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;如同情况2-2-1的示例图, 只不过孩子节点在左边而已.&lt;/p&gt;
&lt;h2 id=&quot;情况3出现的情况&quot;&gt;情况3出现的情况&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;情况3-1: 待删除节点为黑色
&lt;ul&gt;&lt;li&gt;情况3-1-1: 兄弟节点为红色&lt;/li&gt;
&lt;li&gt;情况3-1-2: 兄弟节点为黑色 &amp;amp; 兄弟节点的两个孩子有一个为红色&lt;/li&gt;
&lt;li&gt;情况3-1-3: 兄弟节点为黑色 &amp;amp; 兄弟节点的两个孩子都是黑色(包括NULL节点)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;情况3-2: 待删除节点为红色&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;情况3-1-1-待删除节点为黑色-兄弟节点为红色&quot;&gt;情况3-1-1: 待删除节点为黑色 &amp;amp; 兄弟节点为红色&lt;/h3&gt;
&lt;p&gt;处理步骤(待删除节点是父节点的左孩子):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;父节点染为红色&lt;/li&gt;
&lt;li&gt;兄弟节点染为黑色&lt;/li&gt;
&lt;li&gt;对父节点进行左旋&lt;/li&gt;
&lt;li&gt;重新计算兄弟节点&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;处理步骤(待删除节点是父节点的右孩子):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;父节点染为红色&lt;/li&gt;
&lt;li&gt;兄弟节点染为黑色&lt;/li&gt;
&lt;li&gt;对父节点进行右旋&lt;/li&gt;
&lt;li&gt;重新计算兄弟节点&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这时, 父节点为红色, 兄弟节点为黑色, 进入其它情况.&lt;/p&gt;
&lt;h4 id=&quot;示例图-6&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;在下图红黑树中, 要删除节点5&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927110047876-2139422350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照上述的处理步骤进行调整, 调整之后的红黑树如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927110553271-608254665.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时还是不符合红黑树的性质, 需要进一步调整, 这时进入情况3-1-3.&lt;/p&gt;
&lt;h3 id=&quot;情况3-1-2-待删除节点为黑色-兄弟节点为黑色-兄弟节点的两个孩子有一个为红色&quot;&gt;情况3-1-2: 待删除节点为黑色 &amp;amp; 兄弟节点为黑色 &amp;amp; 兄弟节点的两个孩子有一个为红色&lt;/h3&gt;
&lt;p&gt;处理步骤(待删除节点是父节点的左孩子):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断兄弟节点的右节点是否是黑色(NULL节点为黑色)
&lt;ol&gt;&lt;li&gt;将兄弟节点的左孩子染为黑色&lt;/li&gt;
&lt;li&gt;将兄弟节点染为红色&lt;/li&gt;
&lt;li&gt;对兄弟节点进行右旋&lt;/li&gt;
&lt;li&gt;重新计算兄弟节点&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;将兄弟节点的颜色染为父节点的颜色&lt;/li&gt;
&lt;li&gt;将父节点染为黑色&lt;/li&gt;
&lt;li&gt;将兄弟节点的右孩子染为黑色&lt;/li&gt;
&lt;li&gt;对父节点进行左旋&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;处理步骤(待删除节点是父节点的右孩子):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断兄弟节点的左节点是否是黑色(NULL节点为黑色)
&lt;ol&gt;&lt;li&gt;将兄弟节点的右孩子染为黑色&lt;/li&gt;
&lt;li&gt;将兄弟节点染为红色&lt;/li&gt;
&lt;li&gt;对兄弟节点进行左旋&lt;/li&gt;
&lt;li&gt;重新计算兄弟节点&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;将兄弟节点的颜色染为父节点的颜色&lt;/li&gt;
&lt;li&gt;将父节点染为黑色&lt;/li&gt;
&lt;li&gt;将兄弟节点的右孩子染为黑色&lt;/li&gt;
&lt;li&gt;对父节点进行右旋&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;示例图-7&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;以待删除节点是父节点的左孩子为例, 在下图红黑树中, 要删除节点15&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927111519412-775432785.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照上述的处理步骤进行调整, 调整之后的红黑树如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927114046542-1402031150.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调整完成.&lt;/p&gt;
&lt;p&gt;中间我们省略了步骤1中的处理步骤, 内部的处理步骤同插入时的调整类似, 把兄弟节点的红色孩子节点调整兄弟节点的右孩子(如果兄弟节点是左孩子的话, 那么就是将红色孩子节点调整为左孩子).&lt;/p&gt;
&lt;p&gt;其实这种情况下, 我们不关系待删除节点的父节点的颜色, 因为这种情况的调整是在内部进行调整的.&lt;/p&gt;
&lt;h3 id=&quot;情况3-1-3-待删除节点为黑色-兄弟节点为黑色-兄弟节点的两个孩子都是黑色包括null节点&quot;&gt;情况3-1-3: 待删除节点为黑色 &amp;amp; 兄弟节点为黑色 &amp;amp; 兄弟节点的两个孩子都是黑色(包括NULL节点)&lt;/h3&gt;
&lt;p&gt;注: 这里兄弟的孩子节点包括NULL节点.&lt;/p&gt;
&lt;p&gt;处理步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将兄弟节点染为红色&lt;/li&gt;
&lt;li&gt;将父节点染为黑色&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该情况与当待删除节点是父节点的左孩子还是右孩子无关, 因为不涉及旋转.&lt;br/&gt;当前节点指向父节点之后, 再看符合哪种调整情况, 继续进行调整.&lt;/p&gt;
&lt;h4 id=&quot;示例图-8&quot;&gt;示例图&lt;/h4&gt;
&lt;p&gt;情况3-1-1中调整之后树为:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927110553271-608254665.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照上述的处理步骤进行调整, 调整之后的红黑树如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883454/201809/883454-20180927110950454-595132253.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调整完成.&lt;/p&gt;
&lt;h3 id=&quot;情况3-2-待删除节点为红色&quot;&gt;情况3-2: 待删除节点为红色&lt;/h3&gt;
&lt;p&gt;这时, 父节点为黑色, 兄弟节点一定为红色. 因为此时待删除节点和兄弟节点都没有孩子节点.&lt;/p&gt;
&lt;p&gt;直接删除就好.&lt;/p&gt;
&lt;h2 id=&quot;删除总结&quot;&gt;删除总结&lt;/h2&gt;
&lt;p&gt;删除时, 先看待删除节点的颜色, 然后查看其兄弟节点的颜色, 再查看兄弟节点的孩子节点的颜色, 然后根据具体的情况进行调整.&lt;/p&gt;
&lt;h2 id=&quot;参考treemap的删除调整代码&quot;&gt;参考TreeMap的删除调整代码&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** From CLR */
private void fixAfterDeletion(Entry&amp;lt;K,V&amp;gt; x) {

    // 删除的节点为黑色时, 需要进行调整
    while (x != root &amp;amp;&amp;amp; colorOf(x) == BLACK) {
    
        // 当前节点是左节点
        if (x == leftOf(parentOf(x))) {
        
            // 获取右节点(兄弟节点)
            Entry&amp;lt;K,V&amp;gt; sib = rightOf(parentOf(x));

            // 兄弟节点是红色时
            if (colorOf(sib) == RED) {
            
                // 兄弟节点染为黑色
                setColor(sib, BLACK);
                
                // 父节点染为红色
                setColor(parentOf(x), RED);
                
                // 对父节点进行左旋
                rotateLeft(parentOf(x));
                
                // 重新计算兄弟节点
                sib = rightOf(parentOf(x));
            }

            if (colorOf(leftOf(sib))  == BLACK &amp;amp;&amp;amp;
                colorOf(rightOf(sib)) == BLACK) {  // 兄弟节点的两个孩子都是黑色
                
                // 兄弟节点染为红色
                setColor(sib, RED);
                
                // 将当前节点指向父节点
                x = parentOf(x);
            } else { // 兄弟节点的两个孩子有一个为红色
                
                // 判断兄弟节点红色孩子节点的位置
                // 将兄弟节点的红色孩子节点调整到兄弟节点的右孩子节点位置
                if (colorOf(rightOf(sib)) == BLACK) {
                    setColor(leftOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateRight(sib);
                    sib = rightOf(parentOf(x));
                }
                
                // 将兄弟节点的颜色染为父节点的颜色
                setColor(sib, colorOf(parentOf(x)));
                
                // 父节点染为黑色
                setColor(parentOf(x), BLACK);
                
                // 兄弟节点的右孩子染为黑色
                setColor(rightOf(sib), BLACK);
                
                // 对父节点进行左旋
                rotateLeft(parentOf(x));
                
                // 退出循环
                x = root;
            }
        } else { // symmetric
            Entry&amp;lt;K,V&amp;gt; sib = leftOf(parentOf(x));

            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateRight(parentOf(x));
                sib = leftOf(parentOf(x));
            }

            if (colorOf(rightOf(sib)) == BLACK &amp;amp;&amp;amp;
                colorOf(leftOf(sib)) == BLACK) {
                setColor(sib, RED);
                x = parentOf(x);
            } else {
                if (colorOf(leftOf(sib)) == BLACK) {
                    setColor(rightOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateLeft(sib);
                    sib = leftOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(leftOf(sib), BLACK);
                rotateRight(parentOf(x));
                x = root;
            }
        }
    }

    // 最后将当前节点染为黑色, 为什么需要这段代码? 我觉得你应该知道的.
    setColor(x, BLACK);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;红黑树是一个比较重要的算法, 我觉得作为一个程序员应该需要了解它.&lt;/p&gt;
&lt;p&gt;红黑树的核心在于元素变动之后, 如何进行调整使其重新成为一颗红黑树.&lt;/p&gt;
&lt;p&gt;通过学习红黑树, 深刻体会到大问题并不可怕, 一点点拆分为小问题, 一定会解决的.&lt;/p&gt;
&lt;p&gt;文章不是一气呵成的, 个别地方可能会有问题, 如有发现, 烦请指出.&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 06:35:00 +0000</pubDate>
<dc:creator>吴庆龙</dc:creator>
<og:description>[TOC] 概念 1. 红黑树是一种自平衡的二叉查找树,是一种高效的查找树. 2. 红黑树具有良好的效率, 它可在O(logN)时间内完成查找,增加,删除等操作. 注意: 下文中, 非红色节点就是黑色</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuqinglong/p/9709048.html</dc:identifier>
</item>
<item>
<title>一文让你熟练掌握Linux的ncat(nc)命令 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9712882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9712882.html</guid>
<description>&lt;h2 id=&quot;一文让你熟练掌握linux的ncatnc命令&quot;&gt;一文让你熟练掌握Linux的ncat(nc)命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ncat&lt;/code&gt; 或者说 &lt;code&gt;nc&lt;/code&gt; 是一款功能类似 &lt;code&gt;cat&lt;/code&gt; 的工具，但是是用于网络的。它是一款拥有多种功能的 &lt;code&gt;CLI&lt;/code&gt; 工具，可以用来在网络上读、写以及重定向数据。 它被设计成可以被脚本或其他程序调用的可靠的后端工具。同时由于它能创建任意所需的连接，因此也是一个很好的网络调试工具。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ncat&lt;/code&gt;/&lt;code&gt;nc&lt;/code&gt; 既是一个端口扫描工具，也是一款安全工具，还是一款监测工具，甚至可以做为一个简单的 &lt;code&gt;TCP&lt;/code&gt; 代理。 由于有这么多的功能，它被誉为是网络界的瑞士军刀。 这是每个系统管理员都应该知道并且掌握它。&lt;/p&gt;
&lt;p&gt;在大多数 &lt;code&gt;Debian&lt;/code&gt; 发行版中，&lt;code&gt;nc&lt;/code&gt; 是默认可用的，它会在安装系统的过程中自动被安装。 但是在 &lt;code&gt;CentOS 7/RHEL 7&lt;/code&gt; 的最小化安装中，&lt;code&gt;nc&lt;/code&gt; 并不会默认被安装。 你需要用下列命令手工安装。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum install nmap-ncat -y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统管理员可以用它来审计系统安全，用它来找出开放的端口然后保护这些端口。 管理员还能用它作为客户端来审计 &lt;code&gt;Web&lt;/code&gt; 服务器、&lt;code&gt;telnet&lt;/code&gt; 服务器、邮件服务器等， 通过 &lt;code&gt;nc&lt;/code&gt; 我们可以控制发送的每个字符，也可以查看对方的回应。&lt;/p&gt;
&lt;p&gt;我们还可以用它捕获客户端发送的数据以此来了解这些客户端是做什么的。&lt;/p&gt;
&lt;p&gt;在本文中，我们会通过下面这些例子来学习如何使用 &lt;code&gt;nc&lt;/code&gt; 命令。&lt;/p&gt;
&lt;h3 id=&quot;监听入站连接&quot;&gt;1) 监听入站连接&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;-l&lt;/code&gt; 选项，&lt;code&gt;ncat&lt;/code&gt; 可以进入监听模式，使我们可以在指定端口监听入站连接。 完整的命令是这样的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ncat -l port_number&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ncat -l 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务器就会开始在 &lt;code&gt;8080&lt;/code&gt; 端口监听入站连接。&lt;/p&gt;
&lt;h3 id=&quot;连接远程系统&quot;&gt;2) 连接远程系统&lt;/h3&gt;
&lt;p&gt;使用下面命令可以用 &lt;code&gt;nc&lt;/code&gt; 来连接远程系统&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat IP_address port_number&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat 192.168.1.100 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会创建一个连接，连接到 IP 为 &lt;code&gt;192.168.1.100&lt;/code&gt; 的服务器上的 &lt;code&gt;80&lt;/code&gt; 端口，然后我们就可以向服务器发送指令了。 比如我们可以输入下面内容来获取完整的网页内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET / HTTP/1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者获取页面名称&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET / HTTP/1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者我们可以通过以下方式获得操作系统指纹标识&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HEAD / HTTP/1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会告诉我们使用的是什么软件来运行这个 &lt;code&gt;web&lt;/code&gt; 服务器的&lt;/p&gt;
&lt;h3 id=&quot;连接-udp-端口&quot;&gt;3) 连接 UDP 端口&lt;/h3&gt;
&lt;p&gt;默认情况下，&lt;code&gt;nc&lt;/code&gt; 创建连接时只会连接 &lt;code&gt;TCP&lt;/code&gt; 端口。 不过我们可以使用 &lt;code&gt;-u&lt;/code&gt; 选项来连接到 &lt;code&gt;UDP&lt;/code&gt; 端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -l -u 1234&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们的系统会开始监听 &lt;code&gt;UDP&lt;/code&gt; 的 &lt;code&gt;1234&lt;/code&gt; 端口，我们可以使用下面的 &lt;code&gt;netstat&lt;/code&gt; 命令来验证这一点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;netstat -tunlp | grep 1234
udp           0          0 0.0.0.0:1234                 0.0.0.0:*               17341/nc
udp6          0          0 :::1234                      :::*                    17341/nc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们想发送或者说测试某个远程主机 &lt;code&gt;UDP&lt;/code&gt; 端口的连通性，我们可以使用下面命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -v -u {host-ip} {udp-port}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -v -u 192.168.105.150 53
Ncat: Version 6.40 ( http://nmap.org/ncat )
Ncat: Connected to 192.168.105.150:53&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将-nc-作为聊天工具&quot;&gt;4) 将 &lt;code&gt;nc&lt;/code&gt; 作为聊天工具&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; 也可以作为聊天工具来用，我们可以配置服务器监听某个端口，然后从远程主机上连接到服务器的这个端口，就可以开始发送消息了。 在服务器这端运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -l 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在远程客户端主机上运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat 192.168.1.100 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后开始发送消息，这些消息会在服务器终端上显示出来。&lt;/p&gt;
&lt;h3 id=&quot;将-nc-作为代理&quot;&gt;5) 将 &lt;code&gt;nc&lt;/code&gt; 作为代理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; 也可以用来做代理。比如下面这个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -l 8080 | ncat 192.168.1.200 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有发往我们服务器 &lt;code&gt;8080&lt;/code&gt; 端口的连接都会自动转发到 &lt;code&gt;192.168.1.200&lt;/code&gt; 上的 &lt;code&gt;80&lt;/code&gt; 端口。 不过由于我们使用了管道，数据只能被单向传输。 要同时能够接受返回的数据，我们需要创建一个双向管道。 使用下面命令可以做到这点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkfifo 2way
ncat -l 8080 0&amp;lt;2way | ncat 192.168.1.200 80 1&amp;gt;2way&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在你可以通过 &lt;code&gt;nc&lt;/code&gt; 代理来收发数据了&lt;/p&gt;
&lt;h3 id=&quot;使用-nc-拷贝文件&quot;&gt;6) 使用 &lt;code&gt;nc&lt;/code&gt; 拷贝文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; 还能用来在系统间拷贝文件，虽然这么做并不推荐，因为绝大多数系统默认都安装了 &lt;code&gt;ssh&lt;/code&gt;/&lt;code&gt;scp&lt;/code&gt;。 不过如果你恰好遇见个没有 &lt;code&gt;ssh&lt;/code&gt;/&lt;code&gt;scp&lt;/code&gt; 的系统的话， 你可以用 &lt;code&gt;nc&lt;/code&gt; 来作最后的努力。&lt;/p&gt;
&lt;p&gt;在要接受数据的机器上启动 &lt;code&gt;nc&lt;/code&gt; 并让它进入监听模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -l  8080 &amp;gt; file.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在去要被拷贝数据的机器上运行下面命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat 192.168.1.100 8080 --send-only &amp;lt; data.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;data.txt&lt;/code&gt; 是要发送的文件。 &lt;code&gt;-–send-only&lt;/code&gt; 选项会在文件拷贝完后立即关闭连接。 如果不加该选项， 我们需要手工按下 &lt;code&gt;ctrl+c&lt;/code&gt; 来关闭连接。&lt;/p&gt;
&lt;p&gt;我们也可以用这种方法拷贝整个磁盘分区，不过请一定要小心&lt;/p&gt;
&lt;h3 id=&quot;通过-nc-创建后门&quot;&gt;7) 通过 &lt;code&gt;nc&lt;/code&gt; 创建后门&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; 命令还可以用来在系统中创建后门，并且这种技术也确实被黑客大量使用。 为了保护我们的系统，我们需要知道它是怎么做的。 创建后门的命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -l 10000 -e /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-e&lt;/code&gt; 标志将一个 &lt;code&gt;bash&lt;/code&gt; 与端口 &lt;code&gt;10000&lt;/code&gt; 相连。现在客户端只要连接到服务器上的 &lt;code&gt;10000&lt;/code&gt; 端口就能通过 &lt;code&gt;bash&lt;/code&gt; 获取我们系统的完整访问权限：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat 192.168.1.100 10000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过-nc-进行端口转发&quot;&gt;8) 通过 &lt;code&gt;nc&lt;/code&gt; 进行端口转发&lt;/h3&gt;
&lt;p&gt;我们通过选项 &lt;code&gt;-c&lt;/code&gt; 来用 &lt;code&gt;nc&lt;/code&gt; 进行端口转发，实现端口转发的语法为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -u -l  80 -c  'ncat -u -l 8080'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，所有连接到 &lt;code&gt;80&lt;/code&gt; 端口的连接都会转发到 &lt;code&gt;8080&lt;/code&gt; 端口&lt;/p&gt;
&lt;h3 id=&quot;设置连接超时&quot;&gt;9) 设置连接超时&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; 的监听模式会一直运行，直到手工终止。 不过我们可以通过选项 &lt;code&gt;-w&lt;/code&gt; 设置超时时间:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -w 10 192.168.1.100 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会导致连接 &lt;code&gt;10&lt;/code&gt; 秒后终止，不过这个选项只能用于客户端而不是服务端。&lt;/p&gt;
&lt;h3 id=&quot;使用--k-选项强制-nc-待命&quot;&gt;10) 使用 &lt;code&gt;-k&lt;/code&gt; 选项强制 &lt;code&gt;nc&lt;/code&gt; 待命&lt;/h3&gt;
&lt;p&gt;当客户端从服务端断开连接后，过一段时间服务端也会停止监听。 但通过选项 &lt;code&gt;-k&lt;/code&gt; 我们可以强制服务器保持连接并继续监听端口。 命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ncat -l -k 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在即使来自客户端的连接断了也依然会处于待命状态&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 06:29:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<og:description>一文让你熟练掌握Linux的ncat(nc)命令 或者说 是一款功能类似 的工具，但是是用于网络的。它是一款拥有多种功能的 工具，可以用来在网络上读、写以及重定向数据。 它被设计成可以被脚本或其他程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9712882.html</dc:identifier>
</item>
<item>
<title>Neety的使用及理解 - 筱荣</title>
<link>http://www.cnblogs.com/rrong/p/9712847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rrong/p/9712847.html</guid>
<description>&lt;div readability=&quot;110.84011627907&quot;&gt;
&lt;p&gt;&lt;strong&gt;BIO(&lt;/strong&gt;缺乏弹性伸缩能力，并发量小，容易出现内存溢出，出现宕机 每一个客户端对应一个线程&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258803/201809/1258803-20180927142142476-273497439.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;伪异步IO：&lt;/strong&gt;创建线程池，由线程池里边的线程负责连接处理，M个个请求进来时，会在线程池创建N个线程。容易出现线程池阻塞。由一个线程池来处理客户端的请求。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258803/201809/1258803-20180927142158754-482152764.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;NIO：&lt;/strong&gt;异步非阻塞，服务器实现模式为一个请求一个线程，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。&lt;/p&gt;
&lt;p&gt;对于NIO，有两点需要强调的：&lt;/p&gt;
&lt;p&gt;      （1）关于概念有两种理解，New I/O（相对于之前的I/O库是新增的）和Non-block I/O（非阻塞的）。由于NIO的目标就是让java支持非阻塞I/O，所有更多人喜欢用Non-block I/O。&lt;/p&gt;
&lt;p&gt;      （2）很多人喜欢将NIO称为异步非阻塞I/O，但是，如果按照严格的NUIX网络编程模型和JDK的实现进行区分，实际上它只是非阻塞I/O，不能称之为异步非阻塞I/O。但由于NIO库支持非阻塞读和写，相对于之前的同步阻塞读和写，它是异步的，因此很多人习惯称NIO为异步非阻塞I/O。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AIO：&lt;/strong&gt; JDK1.7升级了NIO库，升级后的NIO库被称为NIO2.0，正式引入了异步通道的概念。NIO2.0的异步套接字通道是真正的异步非阻塞I/O，此即AIO。其服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。&lt;/p&gt;
&lt;p&gt;BIO(一请求以应答模型): 一个独立的acceptor监听客户端的连接，监听到客户端的请求连接之后，为每个客户端创建一个新的线程，进行链路处理。处理完之后，通过输出流返回给应答客户端，此时线程销毁。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Netty服务器的原理：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258803/201809/1258803-20180927142214308-2112949040.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;图中每次请求的读取是通过UpStream来实现，然后激活我们的服务逻辑如EchoServerHandler，而服务器向外写数据，也就是响应是通过DownStream实现的。每个通道Channel包含一对UpStream和DownStream，以及我们的handlers（EchoServerHandler），如下图，这些都是通过channel pipeline封装起来的，数据流在管道里流动，每个Socket对应一个ChannelPipeline。&lt;/p&gt;
&lt;p&gt;channel pipeline是关键：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为每个Channel 保留 ChannelHandlers ，如EchoServerHandler&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有的事件都要通过它&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个Channel对应一个 ChannelPipeline&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;包含协议编码解码 安全验证SSL/TLS和应用逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258803/201809/1258803-20180927142251737-153580205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;非阻塞的IO通信框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Netty概述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、netty是基于Java NIO的网络应用框架，client-server框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Netty的使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1.创建一个服务器端(ServerBootstrap)&lt;/p&gt;
&lt;p&gt;            1.需要创建两个对象， new  NioEventLoopGroup();&lt;/p&gt;
&lt;p&gt;            2.然后创建一个服务器端的对象new ServerBootstrap();&lt;/p&gt;
&lt;p&gt;            3.使用服务器对象调用group方法将第一步创建的两个对象传入到服务器对象中。&lt;/p&gt;
&lt;p&gt;            4.然后再调用channel方法传入NioServerSocketChannel.class&lt;/p&gt;
&lt;p&gt;            5.在接着调用childHandler方法，传入继承了ChannelInitializer&amp;lt;SocketChannel&amp;gt;的类。注：此类用于对刚刚接收的channel进行初始化。(可进行设置接收传输数据的编码和解码与添加自定义处理逻辑的类，需要继承SimpleChannelInboundHandler&amp;lt;String&amp;gt;。然后重写该类的方法进行自己逻辑部分的处理)&lt;/p&gt;
&lt;p&gt;            6.在实现了ChannelInitializer&amp;lt;T&amp;gt;类中实现 了initChaannel方法，然后需要获取ChannelPipeline这个类来进行设置，获取方法是：通过该实现方法的参数.pipeline方法来得到。从而可以进行设置接收到channel进行编码解码的设置与添加自己逻辑部分的类。&lt;/p&gt;
&lt;p&gt;            7.添加自己的逻辑部分的类或代码了。使用上步得到的CHannelPipeline来调用addLast方法添加。设置编码和解码也一样。，附图：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258803/201809/1258803-20180927142317847-3357973.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;       8.开始编写继承了SimpleChannelInboundHandler类的类，然后重写该类的一些方法来完成自己的逻辑代码。&lt;/p&gt;
&lt;p&gt;            channelActive():建立连接的时候触发&lt;/p&gt;
&lt;p&gt;            channelRead0():收到客户端发来的消息的时候触发&lt;/p&gt;
&lt;p&gt;            .....&lt;/p&gt;
&lt;p&gt;       9.绑定端口开始接收进来的连接，使用服务器端对象调用bind方法绑定端口号然后调用sync方法来进行监听并接受连接&lt;/p&gt;
&lt;p&gt;            10.关闭服务器使用 future.channel().closeFuture().sync();来关闭服务器&lt;/p&gt;
&lt;p&gt;并关闭第一步所创建的两个NioEventLoopGroup。调用shutdownGracefully方法&lt;/p&gt;
&lt;p&gt;注：上述为创建了一个服务器端步骤&lt;/p&gt;
&lt;p&gt;如果在继承了SimpleChannelInboundHandler类的上边添加@Sharable注解&lt;/p&gt;
&lt;p&gt;第五步必须为调用childHandler，否则报错childHandler not set&lt;/p&gt;
&lt;p&gt;注解解释：&lt;/p&gt;
&lt;p&gt;@Sharable // 表示它可以被添加到多个ChannelPipeline中。&lt;/p&gt;

&lt;p&gt;    2.创建一个客户端(Bootstrap)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;            1.创建一个NioEventLoopGroup对象，用来传入下班创建的Bootstrap客户端对象。&lt;/p&gt;
&lt;p&gt;            2.创建Bootstrap客户端对象&lt;/p&gt;
&lt;p&gt;            3.使用创建的客户端对象调用group对象窜入创建 NioEventLoopGroup对象。然后下边和创建服务器端对象的步骤一样到第9步。注：这里跟服务器端第五步稍微有点区别，客户端调用的是handler方法，而服务器端调用的是childHandler方法&lt;/p&gt;
&lt;p&gt;            4.开始连接服务器，使用创建的客户端对象调用connect对象将所需要连接的服务器ip及端口号。然后再调用sync方法进行与服务器的连接。&lt;/p&gt;
&lt;p&gt;            5.向服务器端发送数据，需要创建一个Channel对象，使用第四步创建的对象嗲用channel方法得到一个Channel对象。然后使用该对象调用writeAndFlush方法来像服务器端发送数据。&lt;/p&gt;
&lt;p&gt;            6.关闭当前与服务器连接的话将第一步创建的NioEventLoopGroup对象关闭即可，调用shutdownGracefully方法。&lt;/p&gt;


&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;以上为本人自己理解。如有不对，还请指出！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 06:26:00 +0000</pubDate>
<dc:creator>筱荣</dc:creator>
<og:description>BIO(缺乏弹性伸缩能力，并发量小，容易出现内存溢出，出现宕机 每一个客户端对应一个线程 伪异步IO：创建线程池，由线程池里边的线程负责连接处理，M个个请求进来时，会在线程池创建N个线程。容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rrong/p/9712847.html</dc:identifier>
</item>
</channel>
</rss>