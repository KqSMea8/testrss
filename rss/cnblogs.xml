<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Cloud （十五）Stream 入门、主要概念与自定义消息发送与接收 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/9396282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/9396282.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;不写随笔的日子仿佛就是什么都没有产出一般……上节说到要学Spring Cloud Bus，这里发现按照官方文档的顺序反而会更好些，因为不必去后边的章节去为当前章节去打基础，所以我们先学习Spring Cloud Stream，还有一个就是本文有很多官方文档的翻译以及《Spring Cloud 微服务实战》书中的内容和DD博客中的内容，可能会有杂糅的地方，望大家见谅。&lt;/p&gt;
&lt;h2 id=&quot;快速入门&quot;&gt;快速入门&lt;/h2&gt;
&lt;p&gt;五分钟左右为你展示如何创建一个Spring Cloud Stream的应用程序，它是如何从消息中间件中接收并输出接收的信息到console，这里的消息中间件有两种选择：RabbitMQ和Kafka，本文以RabbitMQ为准&lt;/p&gt;
&lt;p&gt;这节主要简化官方文档为两步:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用idea新建项目&lt;/li&gt;
&lt;li&gt;添加 Message Handler , Building 并运行&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一使用idea新建项目&quot;&gt;一、使用idea新建项目&lt;/h3&gt;
&lt;p&gt;打开项目目录，新建一个moudle，名为FirstStream，pom文件如下&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cnblogs.hellxz&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;FirstStream&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;FirstStream&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;Dalston.SR5&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- Spring boot 测试用 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- Stream rabbit 依赖中包含 binder-rabbit,所以只需导入此依赖即可 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rabbit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.0.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二-添加-message-handler-building-并运行&quot;&gt;二、 添加 Message Handler , Building 并运行&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;com.cnblogs.hellxz&lt;/code&gt;包下添加启动类，并添加&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableBinding(Sink.class)
public class FirstStreamApp {

    public static void main(String[] args) {
        SpringApplication.run(FirstStreamApp.class, args);
    }

    @StreamListener(Sink.INPUT)
    public void receive(Object payload) {
        logger.info(&quot;Received: &quot; + payload);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们通过使用&lt;code&gt;@EnableBinding(Sink.class)&lt;/code&gt;开启了&lt;code&gt;Sink&lt;/code&gt;的binding(绑定)，这样做会向框架发出信号，以启动与消息传递中间件的绑定，并自动创建绑定到Sink.INPUT通道的目标（即queue，topic和其他）。&lt;/li&gt;
&lt;li&gt;我们添加了一个处理方法，去监听消息类型为String的消息，这么做是为么向你展示框架的核心特性之一——自动转换入参消息体为指定类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动项目，我们去查看RabbitMQ的网页 http://localhost:15672 点击Connections，发现现在已经有一个连接进来了，我们刚才的项目，在Queues中也有一个队列被创建，我的是&lt;code&gt;input.anonymous.L92bTj6FRTyOC0QE-Pl0HA&lt;/code&gt;，我们点开那个唯一的队列，往下拉点开publish message，payload处输入一个&lt;code&gt;hello world&lt;/code&gt;，点Publlish message发送一个消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201807/1149398-20180731154739185-1476537385.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看控制台，你会看到&lt;code&gt;Received: hello world&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-stream介绍&quot;&gt;Spring Cloud Stream介绍&lt;/h2&gt;
&lt;p&gt;Spring Cloud Stream是一个用于构建消息驱动的微服务应用程序的框架，是一个基于Spring Boot 创建的独立生产级的，使用Spring Integration提供连接到消息代理的Spring应用。介绍&lt;code&gt;持久发布 - 订阅(persistent publish-subscribe)&lt;/code&gt;的语义，&lt;code&gt;消费组(consumer groups)&lt;/code&gt;和&lt;code&gt;分区(partitions)&lt;/code&gt;的概念。&lt;/p&gt;
&lt;p&gt;你可以添加&lt;code&gt;@EnableBinding&lt;/code&gt;注解在你的应用上，从而立即连接到消息代理，在方法上添加&lt;code&gt;@StreamListener&lt;/code&gt;以使其接收流处理事件，下面的例子展示了一个Sink应用接收外部信息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableBinding(Sink.class)
public class VoteRecordingSinkApplication {

  public static void main(String[] args) {
    SpringApplication.run(VoteRecordingSinkApplication.class, args);
  }

  @StreamListener(Sink.INPUT)
  public void processVote(Vote vote) {
      votingService.recordVote(vote);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@EnableBinding&lt;/code&gt;注解会带着一个或多个接口作为参数(举例中使用的是Sink的接口)，一个接口往往声名了输入和输出的渠道，Spring Stream提供了&lt;code&gt;Source&lt;/code&gt;、&lt;code&gt;Sink&lt;/code&gt;、&lt;code&gt;Processor&lt;/code&gt;这三个接口，你也可以自己定义接口。&lt;/p&gt;
&lt;p&gt;下面展示的是Sink的接口内容&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Sink {
  String INPUT = &quot;input&quot;;

  @Input(Sink.INPUT)
  SubscribableChannel input();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Input&lt;/code&gt;注解区分了一个输入channel，通过它接收消息到应用中，使用&lt;code&gt;@Output&lt;/code&gt;注解 区分输出channel，消息通过它离开应用，使用这两个注解可以带一个channel的名字作为参数，&lt;strong&gt;如果未提供channel名称，则使用带注释的方法的名称。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以使用Spring Cloud Stream 现成的接口，也可以使用&lt;code&gt;@Autowired&lt;/code&gt;注入这个接口，下面在测试类中举例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest
public class LoggingConsumerApplicationTests {

    @Autowired
    private Sink sink;

    @Test
    public void contextLoads() {
        assertNotNull(this.sink.input());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;主要概念main-concepts&quot;&gt;主要概念(Main Concepts)&lt;/h2&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;应用模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream 中Binder 交互，通过我们配置来绑定，而 Spring Cloud Stream 的 Binder 负责与中间件交互。所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201807/1149398-20180731154807841-1141535541.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;抽象绑定器（The Binder Abstraction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud Stream实现Kafkat和RabbitMQ的Binder实现，也包括了一个TestSupportBinder，用于测试。你也可以写根据API去写自己的Binder.&lt;/p&gt;
&lt;p&gt;Spring Cloud Stream 同样使用了Spring boot的自动配置，并且抽象的Binder使Spring Cloud Stream的应用获得更好的灵活性，比如：我们可以在application.yml或application.properties中指定参数进行配置使用Kafka或者RabbitMQ，而无需修改我们的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在前面我们测试的项目中并没有修改application.properties，自动配置得益于Spring Boot&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ 通过 Binder ，可以方便地连接中间件，可以通过修改application.yml中的&lt;code&gt;spring.cloud.stream.bindings.input.destination&lt;/code&gt; 来进行改变消息中间件（对应于Kafka的topic，RabbitMQ的exchanges）&lt;/p&gt;
&lt;p&gt;​ 在这两者间的切换甚至不需要修改一行代码。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;发布-订阅(Persistent Publish-Subscribe Support)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图是经典的Spring Cloud Stream的 发布-订阅 模型，生产者 生产消息发布在shared topic（共享主题）上，然后 消费者 通过订阅这个topic来获取消息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201807/1149398-20180731154827761-111530488.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其中topic对应于Spring Cloud Stream中的destinations（Kafka 的topic，RabbitMQ的 exchanges）&lt;/p&gt;
&lt;p&gt;官方文档这块原理说的有点深，就没写，详见官方文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;消费组（Consumer Groups）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管发布-订阅 模型通过共享的topic连接应用变得很容易，但是通过创建特定应用的多个实例的来扩展服务的能力同样重要，但是如果这些实例都去消费这条数据，那么很可能会出现重复消费的问题，我们只需要同一应用中只有一个实例消费该消息，这时我们可以通过消费组来解决这种应用场景， &lt;strong&gt;当一个应用程序不同实例放置在一个具有竞争关系的消费组中，组里面的实例中只有一个能够消费消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置消费组的配置为&lt;code&gt;spring.cloud.stream.bindings.&amp;lt;channelName&amp;gt;.group&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;下面举一个DD博客中的例子：&lt;/p&gt;
&lt;p&gt;下图中，通过网络传递过来的消息通过主题，按照分组名进行传递到消费者组中&lt;/p&gt;
&lt;p&gt;此时可以通过&lt;code&gt;spring.cloud.stream.bindings.input.group=Group-A&lt;/code&gt;或&lt;code&gt;spring.cloud.stream.bindings.input.group=Group-B&lt;/code&gt;进行指定消费组&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201807/1149398-20180731154859044-1037571011.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有订阅指定主题的组都会收到发布消息的一个备份，每个组中只有一个成员会收到该消息；如果没有指定组，那么默认会为该应用分配一个匿名消费者组，与所有其它组处于 订阅-发布 关系中。ps:也就是说如果管道没有指定消费组，那么这个匿名消费组会与其它组一起消费消息，出现了重复消费的问题。&lt;/p&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;16.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;消费者类型（Consumer Types）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）支持有两种消费者类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Message-driven (消息驱动型，有时简称为&lt;code&gt;异步&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Polled (轮询型，有时简称为 &lt;code&gt;同步&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Spring Cloud 2.0版本前只支持 Message-driven这种异步类型的消费者，消息一旦可用就会传递，并且有一个线程可以处理它；当你想控制消息的处理速度时，可能需要用到同步消费者类型。&lt;/p&gt;
&lt;p&gt;2）持久化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般来说所有拥有订阅主题的消费组都是持久化的，除了匿名消费组。&lt;/strong&gt; Binder的实现确保了所有订阅关系的消费订阅是持久的，一个消费组中至少有一个订阅了主题，那么被订阅主题的消息就会进入这个组中，无论组内是否停止。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意： 匿名订阅本身是非持久化的，但是有一些Binder的实现（比如RabbitMQ）则可以创建非持久化的组订阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常情况下，当有一个应用绑定到目的地的时候，最好指定消费消费组。扩展Spring Cloud Stream应用程序时，必须为每个输入绑定指定一个使用者组。这样做可以防止应用程序的实例接收重复的消息（除非需要这种行为，这是不寻常的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;分区支持（Partitioning Support）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在消费组中我们可以保证消息不会被重复消费，但是在同组下有多个实例的时候，我们无法确定每次处理消息的是不是被同一消费者消费，分区的作用就是为了&lt;strong&gt;确保具有共同特征标识的数据由同一个消费者实例进行处理&lt;/strong&gt;，当然前边的例子是狭义的，通信代理（broken topic）也可以被理解为进行了同样的分区划分。Spring Cloud Stream 的分区概念是抽象的，可以为不支持分区Binder实现（例如RabbitMQ）也可以使用分区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201807/1149398-20180731154917031-1208737439.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：要使用分区处理，你必须同时对生产者和消费者进行配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;编程模型programming-model&quot;&gt;编程模型（Programming Model）&lt;/h2&gt;
&lt;p&gt;为了理解编程模型，需要熟悉下列核心概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Destination Binders（目的地绑定器）&lt;/strong&gt;： 负责与外部消息系统集成交互的组件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Destination Bindings（目的地绑定）&lt;/strong&gt;： 在外部消息系统和应用的生产者和消费者之间的桥梁（由Destination Binders创建）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message （消息）&lt;/strong&gt;： 用于生产者、消费者通过Destination Binders沟通的规范数据。&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Destination Binders（目的地绑定器）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Destination Binders是Spring Cloud Stream与外部消息中间件提供了必要的配置和实现促进集成的扩展组件。集成了生产者和消费者的消息的路由、连接和委托、数据类型转换、用户代码调用等。&lt;/p&gt;
&lt;p&gt;尽管Binders帮我们处理了许多事情，我们仍需要对他进行配置。之后会讲&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Destination Bindings （目的地绑定）&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;如前所述，Destination Bindings 提供连接外部消息中间件和应用提供的生产者和消费者中间的桥梁。&lt;/p&gt;
&lt;p&gt;使用@EnableBinding 注解打在一个配置类上来定义一个Destination Binding，这个注解本身包含有@Configuration，会触发Spring Cloud Stream的基本配置。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来的例子展示完全配置且正常运行的Spring Cloud Stream应用，由&lt;code&gt;INPUT&lt;/code&gt;接收消息转换成String 类型并打印在控制台上，然后转换出一个大写的信息返回到&lt;code&gt;OUTPUT&lt;/code&gt;中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableBinding(Processor.class)
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

    @StreamListener(Processor.INPUT)
    @SendTo(Processor.OUTPUT)
    public String handle(String value) {
        System.out.println(&quot;Received: &quot; + value);
        return value.toUpperCase();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过SendTo注解将方法内返回值转发到其他消息通道中&lt;/strong&gt;，这里因为没有定义接收通道，提示消息已丢失，解决方法是新建一个接口，如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface MyPipe{
    //方法1
    @Input(Processor.OUTPUT) //这里使用Processor.OUTPUT是因为要同一个管道，或者名称相同
    SubscribableChannel input();
    //还可以如下这样=====二选一即可==========
    //方法2
    String INPUT = &quot;output&quot;;
    @Input(MyPipe.INPUT)
    SubscribableChannel input();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在在上边的方法下边加一个方法，并在@EnableBinding注解中改成@EnableBinding({Processor.class, MyPipe.class})&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @StreamListener(MyPipe.INPUT)
  public void handleMyPipe(String value) {
      System.out.println(&quot;Received: &quot; + value);
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Spring Cloud Stream已经为我们提供了三个绑定消息通道的默认实现&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sink：通过指定消费消息的目标来标识消息使用者的约定。&lt;/li&gt;
&lt;li&gt;Source：与Sink相反，用于标识消息生产者的约定。&lt;/li&gt;
&lt;li&gt;Processor：集成了Sink和Source的作用，标识消息生产者和使用者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;他们的源码分别为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Sink {
    String INPUT = &quot;input&quot;;

    @Input(&quot;input&quot;)
    SubscribableChannel input();
}

public interface Source {
    String OUTPUT = &quot;output&quot;;

    @Output(&quot;output&quot;)
    MessageChannel output();
}

public interface Processor extends Source, Sink {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sink和Source中分别通过@Input和@Output注解定义了输入通道和输出通道，通过使用这两个接口中的成员变量来定义输入和输出通道的名称，Processor由于继承自这两个接口，所以同时拥有这两个通道。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：拥有多条管道的时候不能有输入输出管道名相同的，否则会出现发送消息被自己接收或报错的情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以根据上述源码的方式来定义我们自己的输入输出通道，定义输入通道需要返回SubscribaleChannel接口对象，这个接口继承自MessageChannel接口，它定义了维护消息通道订阅者的方法；定义输出通道则需要返回MessageChannel接口对象，它定义了向消息通道发送消息的方法。&lt;/p&gt;
&lt;h2 id=&quot;自定义消息通道-发送与接收&quot;&gt;自定义消息通道 发送与接收&lt;/h2&gt;
&lt;p&gt;依照上面的内容，我们也可以创建自己的绑定通道 &lt;em&gt;如果你实现了上边的MyPipe接口，那么直接使用这个接口就好&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;和主类同包下建一个MyPipe接口，实现如下&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.cnblogs.hellxz;

import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.SubscribableChannel;

public interface MyPipe {

    //方法1
//    @Input(Source.OUTPUT) //Source.OUTPUT的值是output，我们自定义也是一样的
//    SubscribableChannel input(); //使用@Input注解标注的输入管道需要使用SubscribableChannel来订阅通道

    //========二选一使用===========

    //方法2
    String INPUT = &quot;output&quot;;

    @Input(MyPipe.INPUT)
    SubscribableChannel input();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里用Source.OUTPUT和第二种方法 是一样的，我们只要将消息发送到名为output的管道中，那么监听output管道的输入流一端就能获得数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;扩展主类，添加监听output管道方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @StreamListener(MyPipe.INPUT)
    public void receiveFromMyPipe(Object payload){
        logger.info(&quot;Received: &quot;+payload);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在主类的头上的@EnableBinding改为&lt;code&gt;@EnableBinding({Sink.class, MyPipe.class})&lt;/code&gt;，加入了Mypipe接口的绑定&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在test/java下创建&lt;code&gt;com.cnblogs.hellxz&lt;/code&gt;，并在包下新建一个测试类，如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.cnblogs.hellxz;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@EnableBinding(value = {Source.class})
@SpringBootTest
public class TestSendMessage {

    @Autowired
    private Source source; //注入接口和注入MessageChannel的区别在于发送时需不需要调用接口内的方法

    @Test
    public void testSender() {
        source.output().send(MessageBuilder.withPayload(&quot;Message from MyPipe&quot;).build());
        //假设注入了MessageChannel messageChannel; 因为绑定的是Source这个接口，
        //所以会使用其中的唯一产生MessageChannel的方法，那么下边的代码会是
        //messageChannel.send(MessageBuilder.withPayload(&quot;Message from MyPipe&quot;).build());
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;启动主类，清空输出，运行测试类，然后你就会得到在主类的控制台的消息以log形式输出&lt;code&gt;Message from MyPipe&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们是通过注入消息通道，并调用他的output方法声明的管道获得的MessageChannel实例，发送的消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;管道注入过程中可能会出现的问题&quot;&gt;管道注入过程中可能会出现的问题&lt;/h3&gt;
&lt;p&gt;通过注入消息通道的方式虽然很直接，但是也容易犯错，当一个接口中有多个通道的时候，他们返回的实例都是MessageChannel，这样通过@Autowired注入的时候往往会出现有多个实例找到无法确定需要注入实例的错误，我们可以通过@Qualifier指定消息通道的名称，下面举例：&lt;/p&gt;
&lt;ol readability=&quot;10&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在主类包内创建一个拥有多个输出流的管道&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 多个输出管道
 */
public interface MutiplePipe {

    @Output(&quot;output1&quot;)
    MessageChannel output1();

    @Output(&quot;output2&quot;)
    MessageChannel output2();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;创建一个测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@EnableBinding(value = {MutiplePipe.class}) //开启绑定功能
@SpringBootTest //测试
public class TestMultipleOutput {

    @Autowired
    private MessageChannel messageChannel;

    @Test
    public void testSender() {
        //向管道发送消息
        messageChannel.send(MessageBuilder.withPayload(&quot;produce by multiple pipe&quot;).build());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动测试类，会出现刚才说的不唯一的bean，无法注入&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'org.springframework.messaging.MessageChannel' available: expected single matching bean but found 6: output1,output2,input,output,nullChannel,errorChannel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;@Autowired&lt;/code&gt;旁边加上&lt;code&gt;@Qualifier(&quot;output1&quot;)&lt;/code&gt;，然后测试就可以正常启动了&lt;/p&gt;
&lt;p&gt;通过上边的错误，我们可以清楚的看到，每个MessageChannel都是使用消息通道的名字做为bean的名称。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我们没有使用监听这个管道，仅为了测试并发现问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;常用配置&quot;&gt;常用配置&lt;/h2&gt;
&lt;h3 id=&quot;消费组和分区的设置&quot;&gt;消费组和分区的设置&lt;/h3&gt;
&lt;p&gt;给消费者设置消费组和主题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置消费组： &lt;code&gt;spring.cloud.stream.bindings.&amp;lt;通道名&amp;gt;.group=&amp;lt;消费组名&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置主题： &lt;code&gt;spring.cloud.stream.bindings.&amp;lt;通道名&amp;gt;.destination=&amp;lt;主题名&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;给生产者指定通道的主题：&lt;code&gt;spring.cloud.stream.bindings.&amp;lt;通道名&amp;gt;.destination=&amp;lt;主题名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;消费者开启分区，指定实例数量与实例索引&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开启消费分区： &lt;code&gt;spring.cloud.stream.bindings.&amp;lt;通道名&amp;gt;.consumer.partitioned=true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消费实例数量： &lt;code&gt;spring.cloud.stream.instanceCount=1&lt;/code&gt; (具体指定)&lt;/li&gt;
&lt;li&gt;实例索引： &lt;code&gt;spring.cloud.stream.instanceIndex=1&lt;/code&gt; #设置当前实例的索引值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生产者指定分区键&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分区键： &lt;code&gt;spring.cloud.stream.bindings.&amp;lt;通道名&amp;gt;.producer.partitionKeyExpress=&amp;lt;分区键&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分区数量： &lt;code&gt;spring.cloud.stream.bindings.&amp;lt;通道名&amp;gt;.producer.partitionCount=&amp;lt;分区数量&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;本文参考与引用&quot;&gt;本文参考与引用&lt;/h4&gt;
&lt;p&gt;《Spring Cloud 微服务实战》以及 作者的&lt;a href=&quot;http://blog.didispace.com/spring-cloud-starter-dalston-7-2/&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fb7d11c7f798&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/fb7d11c7f798&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jack281706/article/details/73743148&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/jack281706/article/details/73743148&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laomn.com/article/item/33322&quot; class=&quot;uri&quot;&gt;http://www.laomn.com/article/item/33322&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/multi/multi__main_concepts.html#Consumer%20Groups&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 07:55:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellxz/p/9396282.html</dc:identifier>
</item>
<item>
<title>Linux内核内存管理架构 - wahaha02</title>
<link>http://www.cnblogs.com/wahaha02/p/9392088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wahaha02/p/9392088.html</guid>
<description>&lt;p&gt;内存管理子系统可能是linux内核中最为复杂的一个子系统，其支持的功能需求众多，如页面映射、页面分配、页面回收、页面交换、冷热页面、紧急页面、页面碎片管理、页面缓存、页面统计等，而且对性能也有很高的要求。本文从内存管理硬件架构、地址空间划分和内存管理软件架构三个方面入手，尝试对内存管理的软硬件架构做一些宏观上的分析总结。&lt;/p&gt;
&lt;h2&gt;内存管理硬件架构&lt;/h2&gt;
&lt;p&gt;因为内存管理是内核最为核心的一个功能，针对内存管理性能优化，除了软件优化，硬件架构也做了很多的优化设计。下图是一个目前主流处理器上的存储器层次结构设计方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/756873/201807/756873-20180730185704128-416645939.png&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，对于读写内存，硬件设计了3条优化路径。&lt;/p&gt;
&lt;p&gt;1）首先L1 cache支持虚拟地址寻址，保证CPU出来的虚拟地址（VA）不需要转换成物理地址（PA）就可以用来直接查找L1 cache，提高cache查找效率。当然用VA查找cache，有安全等缺陷，这需要CPU做一些特别的设计来进行弥补，具体可以阅读《&lt;a href=&quot;https://book.douban.com/subject/1954037/&quot; target=&quot;_blank&quot;&gt;计算机体系结构：量化研究方法&lt;/a&gt;》了解相关细节。&lt;/p&gt;
&lt;p&gt;2）如果L1 cache没有命中，这就需要进行地址转换，把VA转换成PA。linux的内存映射管理是通过页表来实现的，但是页表是放在内存中的，如果每次地址转换过程都需要访问一次内存，其效率是十分低下的。这里CPU通过TLB硬件单元来加速地址转换。&lt;/p&gt;
&lt;p&gt;3）获得PA后，在L2 cache中再查找缓存数据。L2 cache一般比L1 cache大一个数量级，其查找命中率也更高。如果命中获得数据，则可避免去访问内存，提高访问效率。&lt;/p&gt;
&lt;p&gt;可见，为了优化内存访问效率，现代处理器引入多级cache、TLB等硬件模块（如下图是一款8核MIPS处理器硬件框图）。每个硬件模块内部还有大量的设计细节，这里不再深入，如有兴趣可以阅读《&lt;a href=&quot;https://book.douban.com/subject/1954037/&quot; target=&quot;_blank&quot;&gt;计算机体系结构：量化研究方法&lt;/a&gt;》等书籍进一步了解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/756873/201807/756873-20180730192548486-565766143.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;内存映射空间划分&lt;/h2&gt;
&lt;p&gt; 根据不同的内存使用方式和使用场景需要，内核把内存映射地址空间划分成多个部分，每个划分空间都有自己的起止地址、分配接口和使用场景。下图是一个常见的32位地址空间划分结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/756873/201807/756873-20180730193029279-1672142155.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; DMA内存动态分配地址空间：一些DMA设备因为其自身寻址能力的限制，不能访问所有内存空间。如早期的ISA设备只能在24位地址空间执行DMA，即只能访问前16MB内存。所以需要划分出DMA内存动态分配空间，即DMA zone。其分配通过加上GFP_ATOMIC控制符的kmalloc接口来申请。&lt;/li&gt;
&lt;li&gt;直接内存动态分配地址空间：因为访问效率等原因，内核对内存采用简单的线性映射，但是因为32位CPU的寻址能力（4G大小）和内核地址空间起始的设置（3G开始），会导致内核的地址空间资源不足，当内存大于1GB时，就无法直接映射所有内存。无法直接映射的地址空间部分，即highmem zone。在DMA zone和highmem zone中间的区域即normal zone，主要用于内核的动态内存分配。其分配通过kmalloc接口来申请。&lt;/li&gt;
&lt;li&gt;高端内存动态分配地址空间：高端内存分配的内存是虚拟地址连续而物理地址不连续的内存，一般用于内核动态加载的模块和驱动，因为内核可能运行了很久，内存页面碎片情况严重，如果要申请大的连续地址的内存页会比较困难，容易导致分配失败。根据应用需要，高端内存分配提供多个接口：
&lt;ul&gt;&lt;li&gt;vmalloc：指定分配大小，page位置和虚拟地址隐式分配；&lt;/li&gt;
&lt;li&gt;vmap：指定page位置数组，虚拟地址隐式分配；&lt;/li&gt;
&lt;li&gt;ioremap：指定物理地址和大小，虚拟地址隐式分配。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;持久映射地址空间：内核上下文切换会伴随着TLB刷新，这会导致性能下降。但一些使用高端内存的模块对性能也有很高要求。持久映射空间在内核上下文切换时，其TLB不刷新，所以它们映射的高端地址空间寻址效率较高。其分配通过kmap接口来申请。kmap与vmap的区别是：vmap可以映射一组page，即page不连续，但虚拟地址连续，而kmap只能映射一个page到虚拟地址空间。kmap主要用于fs、net等对高端内存访问有较高性能要求的模块中。&lt;/li&gt;
&lt;li&gt;固定映射地址空间：持久映射的问题是可能会休眠，在中断上下文、自旋锁临界区等不能阻塞的场景中不可用。为了解决这个问题，内核又划分出固定映射，其接口不会休眠。固定映射空间通过kmap_atomic接口来映射。kmap_atomic的使用场景与kmap较为相似，主要用于mm、fs、net等对高端内存访问有较高性能要求而且不能休眠的模块中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同的CPU体系架构在地址空间划分上不尽相同，但为了保证CPU体系差异对外部模块不可见，内存地址空间的分配接口的语义是一致的。&lt;/p&gt;
&lt;p&gt;因为64位CPU一般都不需要高端内存（当然也可以支持），在地址空间划分上与32位CPU的差异较大，下图是一个MIPS64 CPU的内核地址空间划分图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/756873/201807/756873-20180730194640637-1552683259.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;内存管理软件架构&lt;/h2&gt;
&lt;p&gt;内核内存管理的核心工作就是内存的分配回收管理，其内部分为2个体系：页管理和对象管理。页管理体系是一个两级的层次结构，对象管理体系是一个三级的层次结构，分配成本和操作对CPU cache和TLB的负面影响，从上而下逐渐升高。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;页管理层次结构：由冷热缓存、伙伴系统组成的两级结构。负责内存页的缓存、分配、回收。&lt;/li&gt;
&lt;li&gt;对象管理层次结构：由per-cpu高速缓存、slab缓存、伙伴系统组成的三级结构。负责对象的缓存、分配、回收。这里的对象指小于一页大小的内存块。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了内存分配，内存释放也是按照此层次结构操作。如释放对象，先释放到per-cpu缓存，再释放到slab缓存，最后再释放到伙伴系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/756873/201807/756873-20180731150803653-119722437.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;框图中有三个主要模块，即伙伴系统、slab分配器和per-cpu（冷热）缓存。他们的对比分析如下。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/756873/201807/756873-20180731155719115-513308568.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;--完--&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 07:54:00 +0000</pubDate>
<dc:creator>wahaha02</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wahaha02/p/9392088.html</dc:identifier>
</item>
<item>
<title>Linux系统管理之硬盘管理 - 胡源</title>
<link>http://www.cnblogs.com/python-and-linux/p/9390378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/python-and-linux/p/9390378.html</guid>
<description>&lt;p&gt;硬盘是计算的重要组成部件之一，硬盘为操作系统提供持久话存储的功能，在Linux硬盘设备的性能和好坏可能关系到生成线的安全和用户体验等等。熟练的掌握硬盘管理相关的信息能让我们处理起这些问题来得心应手。&lt;/p&gt;
&lt;p&gt;Linux中最为重要到的哲学就是一切皆文件，硬盘设备也不例外，在Linux系统中硬盘设备一般存放在/dev/下面SATA、SCSI等接口类型的硬盘使用sd表示，第一块sd的硬盘表示为/dev/sda，第二块sd的硬盘表示为/dev/sdb。IDE硬盘使用hd表示，第一块hd的硬盘表示为/dev/hda，第二块hd的硬盘表示为/dev/hdb。以此类推。&lt;/p&gt;

&lt;p&gt;下面介绍Linux下和硬盘相关的命令（不同发型版命令可能不太相同）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;span&gt;mount      　　　　挂载指定设备&lt;br/&gt;格式：mount &lt;/span&gt;-t 文件系统类型(通常mount命令会自动识别)  设备路径  挂载点&lt;br/&gt;示例：&lt;br/&gt;　　　　mount /dev/sda1  /mnt/             #将/dev/sda1 挂载到/mnt　　&lt;br/&gt;　　　　mount /dev/cdrom /media/　　　　　　 #将cdrom(光盘设备)挂载到/media&lt;br/&gt;　　　　mount -a                           #重读/etc/fstab文件&lt;p&gt;umount            卸载指定设备&lt;br/&gt;　　格式：umount 设备/挂载点&lt;br/&gt;　　示例：&lt;br/&gt;umount /dev/sda1           #卸载/dev/sda1 卸载到整个设备，比如说这个分区一共挂载到了/mnt /test /test1那么这三个挂载点的挂载都将卸掉&lt;br/&gt;umount /media/             #卸载挂在/media目录上面的设备
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
df　　查看当前系统挂载的分区情况&lt;br/&gt;格式&lt;br/&gt;df 参数&lt;br/&gt;常用参数&lt;br/&gt;--help       查看帮助信息&lt;br/&gt;-i           显示inode情况&lt;br/&gt;-h           自动计算显示的文件系统大小单位&lt;br/&gt;-k           以kb方式大小输出文件系统大小&lt;br/&gt;-l           只显示本地文件系统的信息&lt;br/&gt;-T           显示文件系统类型&lt;br/&gt;-t           只显示指定的文件系统
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
tune2fs   调整文件系统属性&lt;br/&gt;格式：&lt;br/&gt;tune2fs 参数 分区&lt;br/&gt;常用参数：
        -j       在不损坏原有数据的情况下升级ext2为ext3
        -L       设定或修改卷标（卷名）
        -m       调整预留给超级用户(root)的百分比，默认为5%
        -c       指定挂载次数达到n次之后进行自检，0或-1表示关闭此功能
        -i       每次挂载使用多少天之后进行自检，0或-1表示关闭此功能
        -l       显示超级块中的信息
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
hdparm：
    hdparm命令提供了一个命令行的接口用于在驱动级别读取和设置IDE或SCSI硬盘参数

    安装：
        yum -y install hdparm

    命令格式:
        hdparm 参数 设备


    常用参数：
        -h                      查看帮助信息
        -I                      获取硬盘的详细信息，如序列号，硬盘转述，接口类型等
        -t                      评估硬盘的读取速度(不经过硬盘cache)
        -T                      评估硬盘快取的读取效率(内存中缓存的频繁使用的数据)
        -a                      设置硬盘的预读取功能，对于读取大文件有显著的性能提升
        -A 0/1                  启动或关闭读取文件时的快取功能
        -f                      将内存缓冲区的数据写入硬盘，并清空缓冲区(类似雨sync命令)
        --direct                通常和-t或-T参数一起使用,通过原始io测试硬盘读取速度，更好地指示原始设备和驱动程序的性能
        --drq-hsm-error         非常危险的命令，仅在测试环境中模拟故障时使用，生成环境中千万不要使用
        -g                      显示硬盘的磁轨，磁头，磁区等参数
        -i                      显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供
        -I                      直接读取硬盘所提供的硬件规格信息(从驱动器读取读取硬盘信息)
        --make-bad-sector       非常危险的命令，仅在测试环境中模拟故障时使用，生成环境中千万不要使用(故意创建一个坏扇区，用于测试raid等设备检查扇区的功能)
        -r                      将硬盘设置为自读模式
        -S                      设定硬盘进入省电模式前的等待时间
        -y                      强制IDE驱动器立即进入待机模式
        -Y                      强制IDE驱动器立即进入休眠模式
        -w                      设置硬盘的写入快取


    示例：
        hdparm -I /dev/sha                #获取硬盘的详细信息
        hdparm -C /dev/sda                #检测硬盘的电源管理模式
        hdparm -t                         #测试硬盘的读取速度(不经过cache)
        hdparm -T                         #测试硬盘快取的读取速度
        hdparm -Tt --direct /dev/sda      #测试硬盘的真实读取速度
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;
&lt;pre readability=&quot;14&quot;&gt;
  其他的一些相关命令：&lt;p&gt;fsck    检查并修复linux中的文件系统&lt;br/&gt;格式：&lt;br/&gt;fsck 参数 文件系统分区&lt;br/&gt;常用参数：
        -t    指定文件系统类型
        -a    自动修复

e2fsck    专用于修复ext系列的文件系统&lt;br/&gt;格式：&lt;br/&gt;e2fsck  参数  文件系统分区
    常用参数：        &lt;br/&gt;-f    强制检查
        -p    自动修复
mke2fs    专门管理ext系列的文件系统&lt;br/&gt;格式：&lt;br/&gt;mke2fs  参数  文件系统分区&lt;br/&gt;常用参数:
        -j    创建ext3类型的文件系统
        -b    指定块大小，默认为4096，可以值有，1024、2048.4096
        -L    指定卷标
        -m    指定预留给超级用户的块数百分比
        -E    指定额外文件系统属性

blkid    查看当前磁盘设备的相关属性
    格式：&lt;br/&gt;blkid 文件系统分区 &lt;br/&gt;字段说明：&lt;br/&gt;UUID：磁盘的唯一标识符  TYPT：文件系统类型     LABEL：卷标

e2label    查看或重新定义卷标
    格式：&lt;br/&gt;e2label 文件系统分区  [卷标名]        &lt;/p&gt;&lt;p&gt;示例：&lt;br/&gt;e2label /dev/sda1          查看卷标名&lt;br/&gt;e2label /dev/sda1 test     设置卷标名&lt;/p&gt;&lt;p&gt;其他命令：
    lscpu    用于查询CPU信息
    lshw     用于显示硬件信息表
    hwinfo   用于查询硬件信息
    lsppci   用于列出PCI总线的信息以及连接到PCI总线上的设备信息
    lsblk    用于列出块设备的信息
    lsscsi   用于列出SCSI的设备信息 
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 31 Jul 2018 07:52:00 +0000</pubDate>
<dc:creator>胡源</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/python-and-linux/p/9390378.html</dc:identifier>
</item>
<item>
<title>python3-开发进阶Django-CBV和FBV及CBV的源码分析 - 天王盖地虎宝塔镇河妖</title>
<link>http://www.cnblogs.com/ManyQian/p/9396063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/9396063.html</guid>
<description>&lt;h2&gt;一、CBV和FBV&lt;/h2&gt;
&lt;p&gt;全称应该是class base views 和function base views&lt;br/&gt;理解起来应该就是基于类的视图函数和基于函数的视图函数&lt;/p&gt;
&lt;h3 id=&quot;实现fbv&quot;&gt;FBV&lt;/h3&gt;
&lt;p&gt;应该是我目前最常用的一种方式了，就是给每一个views里的功能添加自己专用的方法。例如如果要对网页进行get访问，然后通过获得request中post方式传递的form表单获取数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse
  
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login(request):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OK1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method ==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OK2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;br/&gt;　　 。。。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;实现cbv&quot;&gt;CBV&lt;/h3&gt;
&lt;p&gt;但是这种方法，看起来有点臃肿，查看代码的时候不容易看清楚你的post请求get请求是在哪里处理的，所以就有了CBV的处理方法。&lt;/p&gt;
&lt;p&gt;在views文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; View
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginView(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,request):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self,request):
        user&lt;/span&gt;=request.POST.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        pwd&lt;/span&gt;=request.POST.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; Turn:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;假使验证成立&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在CBV的使用中，需要调用父类&lt;code&gt;View&lt;/code&gt;，它会在源码里解释这个CBV的应用范围，以及运作原理。&lt;/p&gt;
&lt;p&gt;在urls文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views
urlpatterns &lt;/span&gt;=&lt;span&gt; [
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),&lt;/span&gt;&lt;span&gt;
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^login/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,views.LoginView.as_view())，&lt;br/&gt;　　# url(r'^login/$',views.login)
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综上所述：&lt;br/&gt;我们可以知道设置一个CBV方法，要做的就是，在views里创建一个类，这个类的父类一定得是&lt;code&gt;View&lt;/code&gt;，而且在urls设置的时候，url指向的不再是一个函数名，而是你定义的类的&lt;code&gt;.as_view()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;运行起来之后，会发现当向login.html这个url发送get请求的时候，成功，发送post请求的时候，也成功，并且有相应的返回值。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;二、原理&lt;/h2&gt;
&lt;p&gt;翻看源码，实现以上功能的核心，其实都在那个被继承的父类&lt;code&gt;View&lt;/code&gt;里：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; View(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Intentionally simple parent class for all views. Only implements
    dispatch-by-method and simple sanity checking.
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    http_method_names &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;patch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;options&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;trace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Constructor. Called in the URLconf; can contain helpful extra
        keyword arguments, and other things.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Go through keyword arguments, and either save their values to our&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance, or raise an error.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; six.iteritems(kwargs):
            setattr(self, key, value)

    @classonlymethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; as_view(cls, **&lt;span&gt;initkwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Main entry point for a request-response process.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; initkwargs:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cls.http_method_names:
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; TypeError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You tried to pass in the %s method name as a &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyword argument to %s(). Don't do that.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                                % (key, cls.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; hasattr(cls, key):
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; TypeError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s() received an invalid keyword %r. as_view &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;only accepts arguments that are already &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attributes of the class.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (cls.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;, key))

        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; view(request, *args, **&lt;span&gt;kwargs):
            self &lt;/span&gt;= cls(**&lt;span&gt;initkwargs)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(self, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; hasattr(self, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
                self.head &lt;/span&gt;=&lt;span&gt; self.get
            self.request &lt;/span&gt;=&lt;span&gt; request
            self.args &lt;/span&gt;=&lt;span&gt; args
            self.kwargs &lt;/span&gt;=&lt;span&gt; kwargs
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.dispatch(request, *args, **&lt;span&gt;kwargs)
        view.view_class &lt;/span&gt;=&lt;span&gt; cls
        view.view_initkwargs &lt;/span&gt;=&lt;span&gt; initkwargs

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; take name and docstring from class&lt;/span&gt;
        update_wrapper(view, cls, updated=&lt;span&gt;())

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; and possible attributes set by decorators&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; like csrf_exempt from dispatch&lt;/span&gt;
        update_wrapper(view, cls.dispatch, assigned=&lt;span&gt;())
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; view

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; dispatch(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Try to dispatch to the right method; if a method doesn't exist,&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; defer to the error handler. Also defer to the error handler if the&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; request method isn't on the approved list.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; request.method.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.http_method_names:
            handler &lt;/span&gt;=&lt;span&gt; getattr(self, request.method.lower(), self.http_method_not_allowed)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            handler &lt;/span&gt;=&lt;span&gt; self.http_method_not_allowed
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; handler(request, *args, **&lt;span&gt;kwargs)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; http_method_not_allowed(self, request, *args, **&lt;span&gt;kwargs):
        logger.warning(
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Method Not Allowed (%s): %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, request.method, request.path,
            extra&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;status_code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 405, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: request}
        )
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; http.HttpResponseNotAllowed(self._allowed_methods())

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; options(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Handles responding to requests for the OPTIONS HTTP verb.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        response &lt;/span&gt;=&lt;span&gt; http.HttpResponse()
        response[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Allow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(self._allowed_methods())
        response[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _allowed_methods(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [m.upper() &lt;span&gt;for&lt;/span&gt; m &lt;span&gt;in&lt;/span&gt; self.http_method_names &lt;span&gt;if&lt;/span&gt; hasattr(self, m)]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从源码中我们可以看到。这个CBV的核心类，是为了处理各种请求服务的。其中有一个list来存放这些请求，并且指向他们应该实现的函数功能。&lt;br/&gt;再补充一点，在CBV创建类方法的时候，一定要携带一个request参数。而这个参数里面就携带了&lt;code&gt;request.method.lower()&lt;/code&gt;，通过反射，CBV函数自然能处理这些method对应的请求。&lt;/p&gt;
&lt;h2&gt;三、逻辑过程&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;看源码的准则就看，看自己看的懂得代码，应为源码的有些高深的设置，我们先阶段还不需要去了解.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先，不管cbv还是fbv，在url中都是用户访问请求，才回去执行相应的视图函数,&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;cbv在启动项目的时候，已经在LoginView中执行一段骚操作的得到一个函数名，我们现在就来看看：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201807/1274477-20180731144744745-741525065.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先我们要明确的一点就是一个类.属性或方法，首先在自己那找，找不到继承的父类找。所以不能直接点。as_view，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;先去类LoginView中找看看有，有没有方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201807/1274477-20180731145338746-1567998082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;点开View，我们找到as_view方法，发现是类方法，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;前面过程做了什么我们不管，返回值只是返回一个view，调用view函数，我们去看view函数，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;view函数最后返回self.dispacth,&lt;span&gt;这里要注意！！！这个self.dispacth，self是谁，self我们看代码发现是LoginView类，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;还是那个准则，调用属性方法，现在自己那边找，没有再找父类。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201807/1274477-20180731145819052-1077790236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因为LoginView中没有dispath这方法，所以还是执行的父类的dispath方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201807/1274477-20180731151005841-1537159044.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意点：&lt;span&gt;还是在调用某个方法时，我们一定要确定是谁去调用这个方法！找方法一定先找自己的，没有再去父类找！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义的dispatch---武基兰的特别操作&quot;&gt;四、思考自定义的dispatch&lt;/h2&gt;
&lt;p&gt;既然在上面我们查看源码的时候已经发现，导向专门的method操作的函数是dispatch，而且每个CBV类的父类都是View，那我能不能在这个dispatch里面做一些定制化操作，&lt;/p&gt;
&lt;p&gt;总的来说，这个只是一个简单的示范处理，如果需要对过来的请求做更多的润色，还需要在这个继承动作前后做更多工作。需要知道的是，他和装饰器略微不懂，那就是他可以共享这个dispatch的request，并且对他进行工作&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 07:23:00 +0000</pubDate>
<dc:creator>天王盖地虎宝塔镇河妖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/9396063.html</dc:identifier>
</item>
<item>
<title>自制操作系统Antz day07——实现内核 (上) - 奶BerBer</title>
<link>http://www.cnblogs.com/LexMoon/p/antz07.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/antz07.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;在前几天的任务中，我们已经简单实现了MBR，直接操作显示器和硬盘操作来加载其他扇区的程序，如今已经可以进入保护模式了，简单引入了C语言，接下来我们编写自己的内核。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　完成实模式到保护模式跳转的这一任务是由loader进行的，而我们不应该用loader做太多的事，loader只需要完成跳转就好了，剩下的工作交给内核。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了加载内核到内存，需要使用ELF格式，如何编译这种格式呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　来看看下面这个例子。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[section .data]

strHello    db    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, Antz !&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 0Ah
STRLEN        equ    $ - strHello


[section .text]    

global _start    

&lt;/span&gt;&lt;span&gt;_start:&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    edx, STRLEN
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ecx, strHello
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    eax, &lt;span&gt;4&lt;/span&gt;        
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    0x80        
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    eax, &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;    0x80    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　global _start定义了程序的入口地址，相当于c/c++中main。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来使用NASM编译。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180731140632096-1026495993.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　-f elf 指定了输出文件的格式为ELF格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编译完成之后要进行链接，链接指令如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180731142036645-1217460005.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　（出现警告，在linux无警告，Windows下会有，可以无视）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　-s是strip的简写，可以去掉符号表等内容，对生成的可执行代码进行减肥。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　我们已经可以生成一个支持载入内存的内核格式文件了，现在我们要学会把汇编程序和c语言程序链接在一起。这是我们编写内核的一大步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先来看看c代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　其中定义了一个choose函数，声明了一个myprint函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; myprint(&lt;span&gt;char&lt;/span&gt;* msg, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; choose(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(a &amp;gt;=&lt;span&gt; b){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         myprint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the 1st one\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         myprint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the 2nd one\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　再来看看汇编代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;extern choose
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; [section .data]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 数据在此&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; num1st        dd    &lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; num2nd        dd    &lt;span&gt;4&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; [section .text]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 代码在此&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;global _start    
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;global myprint    
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;_start:&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    num2nd        
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    num1st        
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    choose        
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    esp, &lt;span&gt;4&lt;/span&gt;        
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    eax, &lt;span&gt;1&lt;/span&gt;        
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    0x80    
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;;&lt;/span&gt;&lt;span&gt; void myprint(char* msg, int len)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;myprint:&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    edx, [esp + &lt;span&gt;8&lt;/span&gt;]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; len&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ecx, [esp + &lt;span&gt;4&lt;/span&gt;]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; msg&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    eax, &lt;span&gt;4&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; sys_write&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    0x80    
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果你懂汇编，这个代码一定没有如何问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一行的extern choose就是指c代码中定义的choose函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后面的global导出了函数入口，_start和在c文件中没有定义的myprint函数，myprint在汇编代码中完成了定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　_start中调用了choose，choose中又调用了myprint函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这样这两个代码文件内容就很清晰了吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在Linux终端下查看结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;nasm -f elf foo.asm -o foo.o
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;gcc -c bar.c -o bar.o
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;ld -s hello.o bar.o -o foobar
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; ./foobar
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　加载内核到内存和引导扇区的工作很相似，只是处理内核时我们要根据ELF文件结构中的值将内核中相应段放入相应位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fat12hdr.inc :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; BS_OEMName    DB &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Antz__Os&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; BPB_BytsPerSec    DW &lt;span&gt;512&lt;/span&gt;    
&lt;span&gt; 4&lt;/span&gt; BPB_SecPerClus    DB &lt;span&gt;1&lt;/span&gt;        
&lt;span&gt; 5&lt;/span&gt; BPB_RsvdSecCnt    DW &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; BPB_NumFATs    DB &lt;span&gt;2&lt;/span&gt;        
&lt;span&gt; 7&lt;/span&gt; BPB_RootEntCnt    DW &lt;span&gt;224&lt;/span&gt;    
&lt;span&gt; 8&lt;/span&gt; BPB_TotSec16    DW &lt;span&gt;2880&lt;/span&gt;        
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;BPB_Media    DB 0xF0        
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; BPB_FATSz16    DW &lt;span&gt;9&lt;/span&gt;        
&lt;span&gt;11&lt;/span&gt; BPB_SecPerTrk    DW &lt;span&gt;18&lt;/span&gt;        
&lt;span&gt;12&lt;/span&gt; BPB_NumHeads    DW &lt;span&gt;2&lt;/span&gt;        
&lt;span&gt;13&lt;/span&gt; BPB_HiddSec    DD &lt;span&gt;0&lt;/span&gt;    
&lt;span&gt;14&lt;/span&gt; BPB_TotSec32    DD &lt;span&gt;0&lt;/span&gt;    
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; BS_DrvNum    DB &lt;span&gt;0&lt;/span&gt;        
&lt;span&gt;18&lt;/span&gt; BS_Reserved1    DB &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;BS_BootSig    DB 29h    
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; BS_VolID    DD &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt; BS_VolLab    DB &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tinix0.01  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; BS_FileSysType    DB &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FAT12   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; FATSz            equ    &lt;span&gt;9&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt; RootDirSectors        equ    &lt;span&gt;14&lt;/span&gt;    
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; SectorNoOfRootDirectory    equ    &lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;28&lt;/span&gt; SectorNoOfFAT1        equ    &lt;span&gt;1&lt;/span&gt;     
&lt;span&gt;29&lt;/span&gt; DeltaSectorNo        equ    &lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt;                      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　boot.asm :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;128&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;org  07c00h        
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;BaseOfStack        equ    07c00h 
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;BaseOfLoader        equ    09000h
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;OffsetOfLoader        equ    0100h
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; short LABEL_START 
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;nop&lt;/span&gt;        
&lt;span&gt;  9&lt;/span&gt;     
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; %include    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fat12hdr.inc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;LABEL_START:&lt;/span&gt;    
&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, cs
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ds, ax
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ss, ax
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    sp, BaseOfStack
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;     
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, 0600h        
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, 0700h     
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cx, &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dx, 0184fh     
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    10h         
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dh, &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    DispStr         
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     
&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    ah, ah     
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    dl, dl 
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    13h    
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    word [wSectorNo], SectorNoOfRootDirectory
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;LABEL_SEARCH_IN_ROOT_DIR_BEGIN:&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    word [wRootDirSizeForLoop], &lt;span&gt;0&lt;/span&gt;    
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_NO_LOADERBIN        
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;dec&lt;/span&gt;&lt;span&gt;    word [wRootDirSizeForLoop]    
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, BaseOfLoader
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax         
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, OffsetOfLoader     
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, [wSectorNo]    
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cl, &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    ReadSector
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    si, LoaderFileName     
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    di, OffsetOfLoader     
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;cld&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dx, 10h
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;LABEL_SEARCH_FOR_LOADERBIN:&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    dx, &lt;span&gt;0&lt;/span&gt;                                     
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR     
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;dec&lt;/span&gt;&lt;span&gt;    dx                                         
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cx, &lt;span&gt;11&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;LABEL_CMP_FILENAME:&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    cx, &lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_FILENAME_FOUND 
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;dec&lt;/span&gt;&lt;span&gt;    cx
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;lodsb&lt;/span&gt;             
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    al, byte [&lt;span&gt;es:&lt;/span&gt;&lt;span&gt;di]
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_GO_ON
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_DIFFERENT         
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;LABEL_GO_ON:&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;inc&lt;/span&gt;&lt;span&gt;    di
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_CMP_FILENAME     
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;LABEL_DIFFERENT:&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;&lt;span&gt;    di, 0FFE0h                     
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    di, 20h                         
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    si, LoaderFileName                     
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_SEARCH_FOR_LOADERBIN
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    word [wSectorNo], &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_SEARCH_IN_ROOT_DIR_BEGIN
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;LABEL_NO_LOADERBIN:&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dh, &lt;span&gt;2&lt;/span&gt;             
&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    DispStr             
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;%ifdef    _BOOT_DEBUG_
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, 4c00h      
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    21h         
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;%else
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    $         
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;%endif
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;LABEL_FILENAME_FOUND:&lt;/span&gt;         
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, RootDirSectors
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;&lt;span&gt;    di, 0FFE0h     
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    di, 01Ah     
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cx, word [&lt;span&gt;es:&lt;/span&gt;&lt;span&gt;di]
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    cx             
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    cx, ax
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    cx, DeltaSectorNo     
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, BaseOfLoader
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax             
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, OffsetOfLoader     
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, cx
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;LABEL_GOON_LOADING_FILE:&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    ax        
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bx             
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ah, 0Eh         
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;            
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bl, 0Fh            
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    10h         
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bx        
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    ax             
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cl, &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    ReadSector
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    ax         
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    GetFATEntry
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;&lt;span&gt;    ax, 0FFFh
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_FILE_LOADED
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    ax         
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dx, RootDirSectors
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, dx
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, DeltaSectorNo
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    bx, [BPB_BytsPerSec]
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_GOON_LOADING_FILE
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;LABEL_FILE_LOADED:&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dh, &lt;span&gt;1&lt;/span&gt;            
&lt;span&gt;126&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    DispStr            
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     
&lt;span&gt;128&lt;/span&gt;     
&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;    &lt;span&gt;BaseOfLoader:&lt;/span&gt;&lt;span&gt;OffsetOfLoader    
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;     
&lt;span&gt;131&lt;/span&gt;     
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;wRootDirSizeForLoop    dw    RootDirSectors     
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; wSectorNo        dw    &lt;span&gt;0&lt;/span&gt;        
&lt;span&gt;134&lt;/span&gt; bOdd            db    &lt;span&gt;0&lt;/span&gt;        
&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt; LoaderFileName        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LOADER  BIN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt; MessageLength        equ    &lt;span&gt;9&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;BootMessage:&lt;/span&gt;        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Booting  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;  
&lt;span&gt;141&lt;/span&gt; Message1        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ready.   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt; Message2        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No LOADER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;  
&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt; &lt;span&gt;DispStr:&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, MessageLength
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;    dh
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, BootMessage
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bp, ax            
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, ds            
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax            
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    cx, MessageLength     
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, 01301h         
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, 0007h         
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dl, &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    10h             
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt;  
&lt;span&gt;160&lt;/span&gt; &lt;span&gt;ReadSector:&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bp
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bp, sp
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;sub&lt;/span&gt;    esp, &lt;span&gt;2&lt;/span&gt;             
&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    byte [bp-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;], cl
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bx         
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bl, [BPB_SecPerTrk]    
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;div&lt;/span&gt;&lt;span&gt;    bl             
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;     &lt;span&gt;inc&lt;/span&gt;&lt;span&gt;    ah             
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    cl, ah     
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dh, al             
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;     &lt;span&gt;shr&lt;/span&gt;    al, &lt;span&gt;1&lt;/span&gt;             
&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ch, al         
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;    dh, &lt;span&gt;1&lt;/span&gt;         
&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bx         
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;     
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dl, [BS_DrvNum]         
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; .&lt;span&gt;GoOnReading:&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ah, &lt;span&gt;2&lt;/span&gt;            
&lt;span&gt;180&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    al, byte [bp-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]        
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    13h
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;     &lt;span&gt;jc&lt;/span&gt;&lt;span&gt;    .GoOnReading        
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     
&lt;span&gt;184&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    esp, &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bp
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt; &lt;span&gt;GetFATEntry:&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    es
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bx
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    ax
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, BaseOfLoader     
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;     &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;    ax, 0100h         
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax             
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    ax
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    byte [bOdd], &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    bx, &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;    bx         
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    bx, &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;     &lt;span&gt;div&lt;/span&gt;&lt;span&gt;    bx             
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    dx, &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_EVEN
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    byte [bOdd], &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt; &lt;span&gt;LABEL_EVEN:&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    dx, dx         
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, [BPB_BytsPerSec]
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;     &lt;span&gt;div&lt;/span&gt;&lt;span&gt;    bx            
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;     
&lt;span&gt;210&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    dx
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    bx, &lt;span&gt;0&lt;/span&gt;             
&lt;span&gt;212&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, SectorNoOfFAT1     
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cl, &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    ReadSector         
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    dx
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    bx, dx
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ax, [&lt;span&gt;es:&lt;/span&gt;&lt;span&gt;bx]
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    byte [bOdd], &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;219&lt;/span&gt;     &lt;span&gt;jnz&lt;/span&gt;&lt;span&gt;    LABEL_EVEN_2
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;     &lt;span&gt;shr&lt;/span&gt;    ax, &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;221&lt;/span&gt; &lt;span&gt;LABEL_EVEN_2:&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;&lt;span&gt;    ax, 0FFFh
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; 
&lt;span&gt;224&lt;/span&gt; &lt;span&gt;LABEL_GET_FAT_ENRY_OK:&lt;/span&gt;
&lt;span&gt;225&lt;/span&gt; 
&lt;span&gt;226&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bx
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    es
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;229&lt;/span&gt;     
&lt;span&gt;230&lt;/span&gt; times     &lt;span&gt;510&lt;/span&gt;-($-$$)    db    &lt;span&gt;0&lt;/span&gt;    
&lt;span&gt;231&lt;/span&gt; dw     0xaa55                
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　loader.asm:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;130&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;org  0100h
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;  
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;BaseOfStack        equ    0100h
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;BaseOfKernelFile    equ     08000h     
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;OffsetOfKernelFile    equ         0h    
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_START        
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; %include    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fat12hdr.inc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;LABEL_START:&lt;/span&gt;             
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, cs
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ds, ax
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ss, ax
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    sp, BaseOfStack
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dh, &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    DispStr             
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;     
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    word [wSectorNo], SectorNoOfRootDirectory    
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    ah, ah 
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    dl, dl 
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    13h    
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;LABEL_SEARCH_IN_ROOT_DIR_BEGIN:&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    word [wRootDirSizeForLoop], &lt;span&gt;0&lt;/span&gt;     
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_NO_KERNELBIN         
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;dec&lt;/span&gt;&lt;span&gt;    word [wRootDirSizeForLoop]    
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, BaseOfKernelFile
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax             
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, OffsetOfKernelFile    
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, [wSectorNo]         
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cl, &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    ReadSector
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    si, KernelFileName     
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    di, OffsetOfKernelFile     
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;cld&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dx, 10h
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;LABEL_SEARCH_FOR_KERNELBIN:&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    dx, &lt;span&gt;0&lt;/span&gt;                     
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR     
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;dec&lt;/span&gt;&lt;span&gt;    dx                     
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cx, &lt;span&gt;11&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;LABEL_CMP_FILENAME:&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    cx, &lt;span&gt;0&lt;/span&gt;             
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_FILENAME_FOUND     
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;dec&lt;/span&gt;&lt;span&gt;    cx             
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;lodsb&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    al, byte [&lt;span&gt;es:&lt;/span&gt;&lt;span&gt;di]     
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_GO_ON
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_DIFFERENT
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;LABEL_GO_ON:&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;inc&lt;/span&gt;&lt;span&gt;    di
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_CMP_FILENAME
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;LABEL_DIFFERENT:&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;&lt;span&gt;    di, 0FFE0h         
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    di, 20h            
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    si, KernelFileName
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_SEARCH_FOR_KERNELBIN
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    word [wSectorNo], &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_SEARCH_IN_ROOT_DIR_BEGIN
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;LABEL_NO_KERNELBIN:&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dh, &lt;span&gt;2&lt;/span&gt;             
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    DispStr         
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;%ifdef    _LOADER_DEBUG_
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, 4c00h    
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    21h            
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;%else
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    $         
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;%endif
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;LABEL_FILENAME_FOUND:&lt;/span&gt;             
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, RootDirSectors
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;&lt;span&gt;    di, 0FFF0h     
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    eax
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, [es : di + 01Ch]         
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dword [dwKernelSize], eax 
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    eax
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    di, 01Ah     
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cx, word [&lt;span&gt;es:&lt;/span&gt;&lt;span&gt;di]
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    cx         
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    cx, ax
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    cx, DeltaSectorNo
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, BaseOfKernelFile
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax        
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, OffsetOfKernelFile    
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, cx         
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;LABEL_GOON_LOADING_FILE:&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    ax         
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bx             
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ah, 0Eh             
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;            
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bl, 0Fh             
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    10h         
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bx        
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    ax         
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cl, &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    ReadSector
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    ax         
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    GetFATEntry
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;&lt;span&gt;    ax, 0FFFh
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_FILE_LOADED
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    ax             
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dx, RootDirSectors
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, dx
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, DeltaSectorNo
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    bx, [BPB_BytsPerSec]
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    LABEL_GOON_LOADING_FILE
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;LABEL_FILE_LOADED:&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    KillMotor         
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dh, &lt;span&gt;1&lt;/span&gt;             
&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    DispStr         
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt;    $
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;     
&lt;span&gt;134&lt;/span&gt; &lt;span&gt;wRootDirSizeForLoop    dw    RootDirSectors
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; wSectorNo        dw    &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;136&lt;/span&gt; bOdd            db    &lt;span&gt;0&lt;/span&gt;     
&lt;span&gt;137&lt;/span&gt; dwKernelSize        dd    &lt;span&gt;0&lt;/span&gt;     
&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt; KernelFileName        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KERNEL  BIN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;      
&lt;span&gt;141&lt;/span&gt; MessageLength        equ    &lt;span&gt;9&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt; &lt;span&gt;LoadMessage:&lt;/span&gt;        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Loading  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; Message1        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ready.   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; Message2        db    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No KERNEL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt; &lt;span&gt;DispStr:&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, MessageLength
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;     &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;    dh
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, LoadMessage
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bp, ax         
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, ds             
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax         
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    cx, MessageLength     
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, 01301h         
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, 0007h     
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dl, &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    dh, &lt;span&gt;3&lt;/span&gt;         
&lt;span&gt;158&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    10h         
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;160&lt;/span&gt;     
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;ReadSector:&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;  
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bp
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bp, sp
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;sub&lt;/span&gt;    esp, &lt;span&gt;2&lt;/span&gt;         
&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    byte [bp-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;], cl
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bx             
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bl, [BPB_SecPerTrk]     
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;     &lt;span&gt;div&lt;/span&gt;&lt;span&gt;    bl             
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;inc&lt;/span&gt;&lt;span&gt;    ah        
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    cl, ah            
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dh, al            
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;     &lt;span&gt;shr&lt;/span&gt;    al, &lt;span&gt;1&lt;/span&gt;             
&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ch, al             
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;    dh, &lt;span&gt;1&lt;/span&gt;             
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bx
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;     
&lt;span&gt;179&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dl, [BS_DrvNum]         
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; .&lt;span&gt;GoOnReading:&lt;/span&gt;
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ah, &lt;span&gt;2&lt;/span&gt;            
&lt;span&gt;182&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    al, byte [bp-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]         
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt;    13h
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;     &lt;span&gt;jc&lt;/span&gt;&lt;span&gt;    .GoOnReading        
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;     
&lt;span&gt;186&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    esp, &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bp
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;     
&lt;span&gt;191&lt;/span&gt; &lt;span&gt;GetFATEntry:&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    es
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    bx
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    ax
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, BaseOfKernelFile 
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;     &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;    ax, 0100h         
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax            
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    ax
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    byte [bOdd], &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;200&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    bx, &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;     &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;    bx         
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    bx, &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt;     &lt;span&gt;div&lt;/span&gt;&lt;span&gt;    bx         
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    dx, &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt;     &lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    LABEL_EVEN
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    byte [bOdd], &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;207&lt;/span&gt; &lt;span&gt;LABEL_EVEN:&lt;/span&gt;
&lt;span&gt;208&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    dx, dx             
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    bx, [BPB_BytsPerSec]
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;     &lt;span&gt;div&lt;/span&gt;&lt;span&gt;    bx            
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;     
&lt;span&gt;212&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    dx
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    bx, &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;214&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    ax, SectorNoOfFAT1     
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    cl, &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    ReadSector         
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    dx
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;&lt;span&gt;    bx, dx
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ax, [&lt;span&gt;es:&lt;/span&gt;&lt;span&gt;bx]
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;     &lt;span&gt;cmp&lt;/span&gt;    byte [bOdd], &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;221&lt;/span&gt;     &lt;span&gt;jnz&lt;/span&gt;&lt;span&gt;    LABEL_EVEN_2
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;     &lt;span&gt;shr&lt;/span&gt;    ax, &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;223&lt;/span&gt; &lt;span&gt;LABEL_EVEN_2:&lt;/span&gt;
&lt;span&gt;224&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;&lt;span&gt;    ax, 0FFFh
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; 
&lt;span&gt;226&lt;/span&gt; &lt;span&gt;LABEL_GET_FAT_ENRY_OK:&lt;/span&gt;
&lt;span&gt;227&lt;/span&gt; 
&lt;span&gt;228&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    bx
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    es
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;231&lt;/span&gt;     
&lt;span&gt;232&lt;/span&gt; &lt;span&gt;KillMotor:&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    dx
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    dx, 03F2h
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;236&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;&lt;span&gt;    dx, al
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;    dx
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　加载功能已经有了，但是还没有内核给以上程序拿来加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来实现一个最简单的内核，以后会基于此扩展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　kernel.asm :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　此处的K不会打印，因为这里只是假设gs指向了显存。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[section .text]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;global _start     
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;_start:&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ah, 0Fh                &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0000: 黑底    1111: 白字&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    [&lt;span&gt;gs:&lt;/span&gt;((&lt;span&gt;80&lt;/span&gt; * &lt;span&gt;1&lt;/span&gt; + &lt;span&gt;39&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;)], ax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 屏幕第 1 行, 第 39 列。&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;    $
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180731151101445-232191245.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出现了Ready，说明我们的kernel内核已经加载成功了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 07:15:00 +0000</pubDate>
<dc:creator>奶BerBer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/antz07.html</dc:identifier>
</item>
<item>
<title>React学习笔记 - 24k-小清新</title>
<link>http://www.cnblogs.com/wuxiaobin/p/9395878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuxiaobin/p/9395878.html</guid>
<description>&lt;h3 id=&quot;一react初探&quot;&gt;一、React初探&lt;/h3&gt;
&lt;h5 id=&quot;es6写法-code&quot;&gt;es6写法 &lt;a href=&quot;https://codepen.io/xiaobinwu/pen/mKagVy&quot;&gt;code&lt;/a&gt;&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  import React from 'react';
  import ReactDOM from 'react-dom';
  import PropTypes from 'prop-types';
  
  class App extends React.Component { 
      state = {
          title: '环球大前端'
      }
      render() {
          const { title } = this.state;
          const { name } = this.props
          return (
            &amp;lt;div&amp;gt;
                &amp;lt;h2&amp;gt;{title}&amp;lt;/h2&amp;gt;
                &amp;lt;p&amp;gt; Hello {name}! &amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
          )
      }
  }
  App.propTypes = {
      name: PropTypes.string
  }
  App.defaultProps = {
      name: '帅气小伙子'
  }
  ReactDOM.render(&amp;lt;App name=&quot;24小清新&quot; /&amp;gt;, document.getElementById('app'));&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;es5写法遗憾的是现在最新版本的react已经不再能使用createclass去创建react组件了-code&quot;&gt;es5写法（遗憾的是现在最新版本的react，已经不再能使用createClass去创建react组件了 &lt;a href=&quot;https://codepen.io/xiaobinwu/pen/gKZygr&quot;&gt;code&lt;/a&gt;）&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var App = React.createClass({
    getDefaultProps: function() {
      return {
        name: '帅气小伙子'  
      }  
    },
    getInitialState: function() {
        return {
            title: '环球大前端'
        }
    },
    render: function() {
      return (
        &amp;lt;div&amp;gt;
            &amp;lt;h2&amp;gt;{this.state.title}&amp;lt;/h2&amp;gt;
            &amp;lt;p&amp;gt; Hello {this.props.name}! &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      )
    }
})
React.render(&amp;lt;App name=&quot;24小清新&quot; /&amp;gt;, document.getElementById('app'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心思想：封装组件，各个组件维护自己的状态(state, prop)和UI,当状态变更，自动重新渲染组件，数据流向是单向的。&lt;/p&gt;
&lt;p&gt;需要明白的几个基础概念：&lt;/p&gt;
&lt;p&gt;1、什么是JSX?&lt;/p&gt;
&lt;p&gt;2、如何修改组件state，从而修改组件UI?&lt;/p&gt;
&lt;p&gt;3、事件处理&lt;/p&gt;
&lt;p&gt;对于上述那些既不是字符串也不是 HTML的的标签语法，被称为JSX，是一种 JavaScript 的语法扩展，用来描述用户界面。&lt;/p&gt;
&lt;p&gt;常用的是在JSX中使用表达式，例如 2 + 2， user.firstName， 以及 formatName(user)，条件判断（三目运算符、&amp;amp;&amp;amp;）, 数组Map函数遍历获取React元素 都是可以使用的。如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    formatName(user) {
        return `${user.firstName}-${user.name}`;
    }
    const user = {
        firstName: 'wu',
        name: 'shaobin'
    }
    const show = true; //我可以是this.state属性哦！！！
    const arr = ['xiaobin', 'kaizi', 'liujun'];
    const element = (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;Hello, {formatName(user)}!&amp;lt;/h1&amp;gt;
        &amp;lt;h1&amp;gt;Hello, {user.name}!&amp;lt;/h1&amp;gt;
        &amp;lt;h1&amp;gt;Hello, { 1 + 1 }!&amp;lt;/h1&amp;gt;
        &amp;lt;h1&amp;gt;Hello, { show ? 'I am show' : null }&amp;lt;/h1&amp;gt;
        &amp;lt;h1&amp;gt;Hello, { arr.length &amp;gt; 0 &amp;amp;&amp;amp; &amp;lt;span&amp;gt;数组长度大于0&amp;lt;/span&amp;gt; }&amp;lt;/h1&amp;gt;
        {
            arr.map((item, index) =&amp;gt; {
                return &amp;lt;span key={item}&amp;gt;item&amp;lt;/span&amp;gt;    
            })
        }
        //记住数组Map函数遍历获取React元素的时候，必须要记得必须➕keys属性
        // 为啥呀？
        //Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。没有唯一值的时候可以使用index，但是官方不建议，会导致渲染变慢。
      &amp;lt;/div&amp;gt;
    );
    ReactDOM.render(
      element,
      document.getElementById('root')
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切记每个组件的render函数返回的JSX结构都需要根元素去包裹着，当然也有例外，如&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/mKvRVG&quot;&gt;React.Fragment&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于JSX,react最终经babel的转换会调用React.createElement相应api转换成react能识别的对象，如上述例子转换后得到：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;React.createElement(
    'div',
    null,
    React.createElement(
        'h2', //可以是一个html标签名称字符串,也可以是也可以是一个 React component 类型
        null,
        title
    ),
    React.createElement(
        'p',
        null,
        ' Hello ',
        name,
        '! '
    )
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://babeljs.io/repl&quot;&gt;babel查看es6-&amp;gt;es5的结果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既然我们可以为组件初始化状态，也必须要能够去改变它，以达到改变视图。&lt;br/&gt;当然&lt;code&gt;this.state.xxx = xxx&lt;/code&gt;不会触发渲染组件的动作，而是使用&lt;code&gt;this.setState({ xxx: xxx })&lt;/code&gt;方法来修改状态，同时多个setState() 调用合并成一个调用能提高性能。&lt;/p&gt;
&lt;p&gt;对于事件处理，需要注意的一点就是this的绑定，其他跟普通Dom绑定监听事件一样，this的绑定有以下几种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在构造函数中使用bind绑定this&lt;/li&gt;
&lt;li&gt;在调用的时候使用bind绑定this&lt;/li&gt;
&lt;li&gt;在调用的时候使用箭头函数绑定this&lt;/li&gt;
&lt;li&gt;使用属性初始化器语法绑定this&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/bKzYZd&quot;&gt;setState与事件处理的例子&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二react进阶&quot;&gt;二、React进阶&lt;/h3&gt;
&lt;p&gt;1、有哪些生命周期，生命周期的执行顺序？&lt;/p&gt;
&lt;p&gt;2、Ref的引用&lt;/p&gt;
&lt;p&gt;3、高阶组件的使用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;生命周期图示(React16)：&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/31/164ee7c89679c44b?w=1138&amp;amp;h=680&amp;amp;f=png&amp;amp;s=69928&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;mounting挂载&quot;&gt;Mounting/挂载&lt;/h4&gt;
&lt;p&gt;constructor()    //React组件的构造函数，用于super(props)，初始化state，bind绑定事件等&lt;/p&gt;
&lt;p&gt;static getDerivedStateFromProps()&lt;/p&gt;
&lt;p&gt;UNSAFE_componentWillMount()    // 组件挂载前(组件渲染到页面前)&lt;/p&gt;
&lt;p&gt;render()    // 渲染函数，不做实际的渲染动作，它只是返回一个JSX描述的结构，生成虚拟Dom树，执行patch，最终由React来操作渲染过程&lt;/p&gt;
&lt;p&gt;componentDidMount()  //组件挂载后(组件渲染到页面上)，可以在这个钩子添加异步请求以及定时器,或是socket连接&lt;/p&gt;
&lt;h4 id=&quot;updating更新&quot;&gt;Updating/更新&lt;/h4&gt;
&lt;p&gt;UNSAFE_componentWillReceiveProps() // 组件接收到属性时触发&lt;/p&gt;
&lt;p&gt;static getDerivedStateFromProps()&lt;/p&gt;
&lt;p&gt;shouldComponentUpdate(prevProps, prevState)  // 当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发，此钩子可做性能优化&lt;/p&gt;
&lt;p&gt;UNSAFE_componentWillUpdate()  //组件即将被更新时触发&lt;/p&gt;
&lt;p&gt;render() // 渲染函数，不做实际的渲染动作，它只是返回一个JSX描述的结构，生成虚拟新Dom树，与旧树进行diff， 执行patch&lt;/p&gt;
&lt;p&gt;getSnapshotBeforeUpdate()&lt;/p&gt;
&lt;p&gt;componentDidUpdate(prevProps, prevState, snapshot) // 组件被更新完成后触发，生命周期中由于state的变化触发请求，在componentDidUpdate中进行&lt;/p&gt;
&lt;h4 id=&quot;unmounting卸载&quot;&gt;Unmounting/卸载&lt;/h4&gt;
&lt;p&gt;componentWillUnmount()  // 卸载组件，注销监听事件或是定时器，socket关闭&lt;/p&gt;
&lt;p&gt;详细看&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/Qxowzq&quot;&gt;生命周期例子&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;补充tip&quot;&gt;&lt;a href=&quot;https://juejin.im/post/5aca20c96fb9a028d700e1ce&quot;&gt;补充Tip&lt;/a&gt;：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.react-china.org/docs/react-component.html#getsnapshotbeforeupdate&quot;&gt;getSnapshotBeforeUpdate()&lt;/a&gt;与&lt;a href=&quot;https://doc.react-china.org/docs/react-component.html#static-getderivedstatefromprops&quot;&gt;static getDerivedStateFromProps()&lt;/a&gt;两个新增生命周期钩子是被用来代替 UNSAFE_componentWillMount() ，UNSAFE_componentWillUpdate()， UNSAFE_componentWillReceiveProps()三个生命周期的，但是这个三个生命周期仍是可以使用。为什么勒？React为了1.7版本实现Async Rendering。&lt;/p&gt;
&lt;p&gt;Refs 提供了一种方式，用于访问在 render 方法中创建的 DOM 节点或 React 元素，官方建议少用。获取Ref有三种场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/31/164eee2ba2bc9294?w=725&amp;amp;h=394&amp;amp;f=png&amp;amp;s=18656&quot;/&gt;&lt;br/&gt;获取Ref的常用方式（通过this.myRef.current来获取Dom节点或实例）：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class MyComponent extends React.Component {
   constructor(props) {
     super(props);
     this.myRef = React.createRef(); // 调用React.createRef API
   }
   render() {
     return &amp;lt;input ref={this.myRef} /&amp;gt;;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return &amp;lt;input ref={(ref) =&amp;gt; { this.myRef = ref; }} /&amp;gt;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/mKoLzy&quot;&gt;Ref获取Dom元素例子&lt;/a&gt;， &lt;a href=&quot;https://codepen.io/xiaobinwu/pen/eKXjxB&quot;&gt;Ref获取React元素（子组件实例）例子&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;补充Tip： &lt;/p&gt;
&lt;p&gt;对于第三种情况，获取子组件的Dom节点，官方有提供Forwarding Refs（转发Ref）的方法，来获取子组件的Dom节点的Ref，此方法返回的是一个React元素，对应方法为&lt;br/&gt;&lt;code&gt;React.forwardRef((props, ref) =&amp;gt; { ... })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/pKYOeR&quot;&gt;Ref获取子组件Dom元素或是React元素的ref例子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.react-china.org/docs/higher-order-components.html&quot;&gt;高阶组件&lt;/a&gt;（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，其实就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。高阶组件在React第三方库中很常见，比如Redux的connect方法和react-router的withRouter()方法。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;1、不要再render函数中使用高阶组件，不然会导致每次重新渲染，都会重新创建高阶组件实例，销毁掉旧的高阶组件，导致所有状态和子组件都被卸载。&lt;/p&gt;
&lt;p&gt;2、必须将静态方法做拷贝，当使用高阶组件包装组件，原始组件被容器组件包裹，得到新组件会丢失原始组件的所有静态方法，假如原始组件有静态方法，可以使用hoist-non-react-statics进行静态方法拷贝。&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/jKJJmo&quot;&gt;例子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、Refs属性不能传递，高阶组件可以传递所有的props属性给包裹的组件，但是不能传递refs引用，但是有时候我们确实需要把ref的引用传给包裹组件，可以传一个非ref命名的props属性给到高阶组件上，由高阶组件绑定到包裹组件的ref上，也可以使用转发Ref。&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/YvgMab&quot;&gt;例子&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;三react第三方库&quot;&gt;三、React第三方库&lt;/h3&gt;
&lt;h4 id=&quot;redux与react-redux&quot;&gt;1、&lt;a href=&quot;https://unpkg.com/redux@4.0.0/lib/redux.js&quot;&gt;Redux&lt;/a&gt;与&lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/react-redux/5.0.7/react-redux.js&quot;&gt;react-redux&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Redux主要分成三部分，分别为Store，Action，Reducer，下面是对三部分的通俗的讲解：&lt;/p&gt;
&lt;p&gt;Store：Redux应用只有一个单一的Store，就是单一数据源，将整个应用共享的状态state储存在一棵对象树上面，注意的是，对象树上面的state是只读的，只能通过纯函数来执行修改，创建store，是通过Redux的 createStore（reducer）方法来创建的，store里面会有getState()、dispatch()、subscribe(listener)的方法。&lt;/p&gt;
&lt;p&gt;Action：一个普通的Javascript对象，描述了应用state发生了什么变化，通过dispatch方法来通知store调用reducer方法。&lt;/p&gt;
&lt;p&gt;Reducer：描述应用如何更新state，本身是一个函数，接受Action参数，返回新的state。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/YvMLrd&quot;&gt;不结合react-redux的Redux使用例子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要明白的一点Redux跟React一点关系都没有，但是React搭配Redux来实现状态管理时最好的实现方案。那么如何搭配呢？本来我们可以subscribe(listener)在react的组件注册redux的监听器，但是这种方式繁琐，而且会导致多次渲染。所以搭配着react-redux来使用。基本使用如下：&lt;/p&gt;
&lt;pre class=&quot;javacript&quot;&gt;
&lt;code&gt;import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import App from './components/App'

const todoApp = (state = {}, action) {
   if (actions.type === 'SHOW') {
       return Object.assign({}, state, {
        show: action.show
       });
   }
   return state;
}

let store = createStore(todoApp)
render(
  // 使用指定的 React Redux 组件 &amp;lt;Provider&amp;gt; 来让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。
  &amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;,
  document.getElementById('root')
)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from 'react'
import { connect } from 'react-redux';
import Child from './components/Child'
class App extends Component {
    render() {
        const { show } = this.props;
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;Child show={show }/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
}
const stateToProps = (state) =&amp;gt; ({
    show: state.show
});

export default connect(stateToProps)(App);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/xiaobinwu/pen/PagXWg&quot;&gt;结合react-redux的例子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;react-redux内容实现原理，使用的&lt;a href=&quot;https://doc.react-china.org/docs/legacy-context.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8context&quot;&gt;Context API&lt;/a&gt;，简单来说，父组件声明需要跨层级组件传递的属性（childContextType）以及监听属性变化的getChildContext()函数，子组件声明可以接收上层组件传递的属性（contextType）。&lt;/p&gt;
&lt;p&gt;如果存在多个reducer的话，可以使用redux中的combineReducers进行合并，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import { createStore, combineReducers } from 'redux';
const todoApp = combineReducers({
  reducer1,
  reducer2
})
const store = createStore(todoApp);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码等价于：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import { createStore} from 'redux';
const todoApp = (state = {}, action) =&amp;gt; {
  return {
    reducer1: state.reducer1,
    reducer2: state.reducer2
  }
}
const store = createStore(todoApp);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;combineReducers最终只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。详细逻辑可以看&lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/4.0.0/redux.js&quot;&gt;redux源码&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;react-router&quot;&gt;2、react-router&lt;/h4&gt;
&lt;p&gt;对于路由规则，我们在项目里面搭配的是react-router v4这个库来完成的，由于我们这之前也没接触过react-router，所以版本v3与v4之间模式和策略的差异不同也没有带来思维模式转换的困难，下面先帖码简单看看v3与v4版本之间的差异性（摘自&lt;a href=&quot;https://juejin.im/post/5995a2506fb9a0249975a1a4&quot;&gt;掘金&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import { Router, Route, IndexRoute } from 'react-router'
const PrimaryLayout = props =&amp;gt; (
    &amp;lt;div className=&quot;primary-layout&quot;&amp;gt;
        &amp;lt;header&amp;gt;
          Our React Router 3 App
        &amp;lt;/header&amp;gt;
        &amp;lt;main&amp;gt;
          {props.children}
        &amp;lt;/main&amp;gt;
  &amp;lt;/div&amp;gt;
)
const HomePage =() =&amp;gt; &amp;lt;div&amp;gt;Home Page&amp;lt;/div&amp;gt;
const UsersPage = () =&amp;gt; &amp;lt;div&amp;gt;Users Page&amp;lt;/div&amp;gt;
const App = () =&amp;gt; (
  &amp;lt;Router history={browserHistory}&amp;gt;
    &amp;lt;Route path=&quot;/&quot; component={PrimaryLayout}&amp;gt;
      &amp;lt;IndexRoute component={HomePage} /&amp;gt;
      &amp;lt;Route path=&quot;/users&quot; component={UsersPage} /&amp;gt;
    &amp;lt;/Route&amp;gt;
  &amp;lt;/Router&amp;gt;
)
render(&amp;lt;App /&amp;gt;, document.getElementById('root'))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import { BrowserRouter, Route } from 'react-router-dom'

const PrimaryLayout = () =&amp;gt; (
    &amp;lt;div className=&quot;primary-layout&quot;&amp;gt;
    &amp;lt;header&amp;gt;
      Our React Router 4 App
    &amp;lt;/header&amp;gt;
    &amp;lt;main&amp;gt;
      &amp;lt;Route path=&quot;/&quot; exact component={HomePage} /&amp;gt;
      &amp;lt;Route path=&quot;/users&quot; component={UsersPage} /&amp;gt;
    &amp;lt;/main&amp;gt;
  &amp;lt;/div&amp;gt;
)

const HomePage =() =&amp;gt; 
&amp;lt;div&amp;gt;Home Page&amp;lt;/div&amp;gt;

const UsersPage = () =&amp;gt; 
&amp;lt;div&amp;gt;Users Page&amp;lt;/div&amp;gt;


const App = () =&amp;gt; (
  &amp;lt;BrowserRouter&amp;gt;
    &amp;lt;PrimaryLayout /&amp;gt;
  &amp;lt;/BrowserRouter&amp;gt;
)

render(&amp;lt;App /&amp;gt;, document.getElementById('root'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;差异性：&lt;/p&gt;
&lt;p&gt;1、v3是集中性路由，所有路由都是集中在一个地方， 而v4则相反。&lt;/p&gt;
&lt;p&gt;2、v3布局和页面嵌套是通过 组件的嵌套而来的，而v4不会互相嵌套&lt;/p&gt;
&lt;p&gt;3、v3布局和页面组件是完全纯粹的，它们是路由的一部分，而v4路由规则位于布局和 UI 本身之间&lt;/p&gt;
&lt;p&gt;4、使用v4需要在我们的组件根部用BrowserRouter组件(用于浏览器)去包装，实现原理与react-redux的Provider组件一样（Context API），以便组件可以去拿到路由信息。&lt;/p&gt;
&lt;p&gt;这里主要介绍包容性路由、排他性路由、嵌套路由，以及withRouter的一些基本用法。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 06:59:00 +0000</pubDate>
<dc:creator>24k-小清新</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuxiaobin/p/9395878.html</dc:identifier>
</item>
<item>
<title>log4j的配置使用 - 梓榕林</title>
<link>http://www.cnblogs.com/xuesm/p/9392654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuesm/p/9392654.html</guid>
<description>&lt;p&gt;一、log4j日志的使用：&lt;/p&gt;
&lt;p&gt;　　1.log4j在Java代码中的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.Log;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.LogFactory;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlogTest {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * 得到log记录器的三种方式：
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     *      1. 通过Log工厂：LogFactory。导包：commons-logging-1.1.3.jar， Log也是该包下的对应的类。
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     *      2. 通过Logger的静态方法，有两种方式：导包：log4j-1.2.15.jar。
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     *          1）参数为配置的输出目的地名称appenderName(见后面配置中)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     *          2）参数类对应为当前类的Class对象。
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Log logger = LogFactory.getLog(BlogTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private static Logger logger = Logger.getLogger(&quot;Console&quot;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private static Logger logger = Logger.getLogger(BlogTest.class);&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; 11; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 sum +=&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             logger.info(&quot;计算得出了从1加到10的和成功，计算的结果为：&quot; +&lt;span&gt; sum);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; dev = sum / 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             logger.error(&quot;此处发生错误&quot;,&lt;span&gt;new&lt;/span&gt; ArithmeticException(&quot;除0异常&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2. 运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731151702179-532454357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3. 为什么使用log4j，不使用system.out:&lt;/p&gt;
&lt;p&gt;　　　　log4j可以将程序运行产生的日志输出到控制台， 文件， 邮件， 数据库等很多不同的地方，不再局限与控制台。 这样， 部署后的程序虽然与IDE分离， 遇到错误同样可以通过从文件等目的地查看日志分析。而且， 这些不同的目的地，可以通过一个配置文件进行配置， 不需要修改源码。使用system.out只能再开发过程中使用控制台看到， 部署代码时， 还需要将不必要的输出语句注释掉。&lt;/p&gt;
&lt;p&gt;　　　　就算只针对控制台，如果发生错误或者是记录日志， log4j可以通过简单的配置准确地记录发生错误的类，位置， 时间。而system.out只是输出的一句话。&lt;/p&gt;
&lt;p&gt;　　4. 只含有以上代码， log4j是无法工作的， 必须有配套的配置文件， 来配置logger.error(&quot;XXX&quot;),logger.info(&quot;XXX&quot;)等往哪输出， 以什么样的格式输出。　&lt;/p&gt;
&lt;p&gt;二、log4j的配置文件　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;###########################根logger配置开始######################################
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 2&lt;/span&gt; log4j.rootLogger=&lt;span&gt;[level], appenderName1,appenderName2......
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4 ### 1. 根logger配置，作用：配置全局logger级别以及输出目的地。即项目中所有日志的级别以及输出目的地， 包括引入的第三方jar包（有些框架或jar包中，也有日志的记录）。
 5 ###     1.1 level：日志级别
 6 ###             日志级别分类:
 7 ###                 ALL：打开所有日志记录开关；是最低等级的，用于打开所有日志记录。
 8 ###                 DEBUG：输出调试信息；指出细粒度信息事件对调试应用程序是非常有帮助的。
 9 ###                 INFO ：输出提示信息；消息在粗粒度级别上突出强调应用程序的运行过程。
10 ###                 WARN ：输出警告信息；表明会出现潜在错误的情形。
11 ###                 ERROR：输出错误信息；指出虽然发生错误事件，但仍然不影响系统的继续运行。
12 ###                 FATAL：输出致命错误；指出每个严重的错误事件将会导致应用程序的退出。
13 ###                 OFF ：关闭所有日志记录开关；是最高等级的，用于关闭所有日志记录。
14 ###             日志级别排序（由高到低）：
15 ###                 OFF &amp;gt; FATAL &amp;gt; ERROR &amp;gt; WARN &amp;gt; INFO &amp;gt; DEBUG &amp;gt; ALL
16 ###             常用日志级别：
17 ###                 ERROR &amp;gt; WARN &amp;gt; INFO &amp;gt; DEBUG
18 ###     1.2 appenderName：输出目的地的命名， 可以指定多个， 可以自定义命名
19 ###########################根logger配置结束#######################################
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;&lt;span&gt; #############################项目logger配置开始#########################################
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;22&lt;/span&gt; log4j.logger.package1=&lt;span&gt;[level], appenderName3,appenderName4......
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;23 log4j.logger.package2=[level], appenderName5,appenderName6......
24 ### 2. 特定包logger配置， 作用：如果自己写的某个包下日志， 不想按照全局配置的log级别或者想单独输出到某个文件， 使用此配置。
25 ###         2.1 level日志级别， 同根logger的取值范围一样（共7个， 常用4个）， 可以和根logger相同， 可以不同。
26 ###         2.2 appenderName：输出目的地的命名， 可以和根logger输出目的地相同， 也可以为每个包单独定义输出目的地。
27 ###         2.3 如果这里配置的级别高于根logger级别， 则按照此处配置的日志级别。 如果低于根logger级别， 则按照根logger级别进行日志开关。
28 #############################项目logger配置结束#########################################
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;&lt;span&gt; ############################项目输出源（appender）标志位配置开始###################################
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;31&lt;/span&gt; log4j.additivity.package1=&lt;span&gt;boolean&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; log4j.additivity.package2=&lt;span&gt;boolean&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;33 ### 3. 特定包的输出源标志位配置， 作用：配置特定包的输出源是否在根logger配置的输出源中输出， 默认是true
34 ###         例如：根logger（rootLogger）配置的输出源（appender）是appenderName1， package1包下的日志输出源是appenderName3。如果log4j.additivity.package1=boolean
35 ###              配置成false， 则package1下产生的日志， 只会在appenderName3配置的目的地输出。如果配置成true，会在appenderName1和appenderName2中输出。
36 ############################项目输出源（appender）标志位配置结束###################################
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#########################输出源（appender）输出方式配置开始########################################
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;39&lt;/span&gt; log4j.appender.appenderName=fully.qualified.name.of.appender.&lt;span&gt;class&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; log4j.appender.appenderName.layout=fully.qualified.name.of.layout.&lt;span&gt;class&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; log4j.appender.appenderName.layout.ConversionPattern=%d [%t] %-5p %c(%L) - %m%&lt;span&gt;n
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; log4j.appender.appenderName.Append=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; log4j.appender.appenderName.bufferSize=10000
&lt;span&gt;44&lt;/span&gt; log4j.appender.appenderName.encoding=UTF-8
&lt;span&gt;45&lt;/span&gt; log4j.appender.appenderName.MaxFileSize=&lt;span&gt;1GB
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; log4j.appender.appenderName.MaxBackupIndex=5
&lt;span&gt;47&lt;/span&gt; log4j.appender.appenderName.Target=&lt;span&gt;System.err
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; log4j.appender.appenderName.Threshold=&lt;span&gt;ERROR
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;### 4. 日志输出方式的配置，作用：配置日志以什么样的方式输出， 输出到哪。
50 ###         4.1 语法：log4j.appender.appenderName1 = fully.qualified.name.of.appender.class， 输出目的地配置，常见取值：
51 ###             1）org.apache.log4j.ConsoleAppender（控制台）
52 ###             2）org.apache.log4j.FileAppender（文件）
53 ###             3）org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
54 ###             4）org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
55 ###             5）org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
56 ###             6）org.apache.log4j.net.SMTPAppender（邮件）
57 ###             7）org.apache.log4j.jdbc.JDBCAppender（数据库）
58 ###         4.2 语法：log4j.appender.appenderName1.layout = fully.qualified.name.of.layout.class， 输出布局配置，常见取值：
59 ###             1）org.apache.log4j.HTMLLayout（以HTML表格形式布局），
60 ###             2）org.apache.log4j.PatternLayout（可以灵活地指定布局模式）
61 ###             3）org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）
62 ###             4）org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
63 ###         4.3 布局为PatternLayout的输出格式：
64 ###             -X号: X信息输出时左对齐；
65 ###             %p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,
66 ###             %d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921
67 ###             %r: 输出自应用启动到输出该log信息耗费的毫秒数
68 ###             %c: 输出日志信息所属的类目，通常就是所在类的全名
69 ###             %t: 输出产生该日志事件的线程名
70 ###             %l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.java:10)
71 ###             %x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。
72 ###             %%: 输出一个&quot;%&quot;字符
73 ###             %F: 输出日志消息产生时所在的文件名称
74 ###             %L: 输出代码中的行号
75 ###             %m: 输出代码中指定的消息,产生的日志具体信息
76 ###             %n: 输出一个回车换行符，Windows平台为&quot;/r/n&quot;，Unix平台为&quot;/n&quot;输出日志信息换行
77 ###
78 ###             可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：
79 ###                 1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。
80 ###                 2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，&quot;-&quot;号指定左对齐。
81 ###                 3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。
82 ###                 4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉。
83 ###         4.4 输出方式参数：
84 ###             1）log4j.appender.appenderName.Append=false：如果日志目的地是文件， 新产生日志是追加还是覆盖
85 ###             2）log4j.appender.appenderName.encoding：日志输出时的编码
86 ###             3）log4j.appender.appenderName.bufferSize=10000，因为产生日志写入到磁盘中的， 为提升性能可以先写入到缓存中，再往磁盘中写。
87 ###             4）log4j.appender.appenderName.MaxFileSize，如果日志目的地是文件， 则文件大小最大是多少。
88 ###             5）log4j.appender.appenderName.MaxBackupIndex，每天产生一个日志文件或者当日志文件达到指定大小时生成新文件这两种情况下备份文件的个数。
89 ###             6）log4j.appender.appenderName.Target：取值system.err（标红）或system.out（正常）.
90 ###             7）log4j.appender.appenderName.Threshold=ERROR：自定义日志级别，自定义包中的日志不想和全局根loggerr日志级别一样时设置。注意根级别要小于自定义的才生效。
91 #########################输出源（appender）输出方式配置结束########################################&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、log4j完整应用实例：&lt;/p&gt;
&lt;p&gt;　　1. 简单应用：&lt;/p&gt;
&lt;p&gt;　　　　a）配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 ### 日志级别：DEBUG，即比DEBUG级别低的处于关闭状态， 输出目的地两个， 名称为Console和File， 可以自定义名称，AAA，bbb都行
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 2&lt;/span&gt; log4j.rootLogger=&lt;span&gt;DEBUG, Console,File
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 3 ### 对于输出源Console的配置，输出到控制台，通过配置输出格式灵活指定布局格式
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 4&lt;/span&gt; log4j.appender.Console=&lt;span&gt;org.apache.log4j.ConsoleAppender
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; log4j.appender.Console.layout=&lt;span&gt;org.apache.log4j.PatternLayout
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p %c(%L) - %m%&lt;span&gt;n
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 7 ### 对于输出源File的配置，输出到文件，通过配置输出格式灵活指定布局格式
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 8&lt;/span&gt; log4j.appender.File=&lt;span&gt;org.apache.log4j.FileAppender
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; log4j.appender.File.File=./mylog4j/logs/&lt;span&gt;file.log
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; log4j.appender.File.layout=&lt;span&gt;org.apache.log4j.PatternLayout
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; log4j.appender.File.layout.ConversionPattern=%d [%t] %-5p %c(%L) - %m%n&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　b）java文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsoleTest {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = Logger.getLogger(ConsoleTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         logger.debug(&quot;调试 this is a debug&lt;/strong&gt; message&quot;&lt;span&gt;);
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 7&lt;/span&gt;         logger.info(&quot;基本 this is an info message!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         logger.warn(&quot;警告 this is a warn message&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         logger.error(&quot;错误 this is an error message!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         logger.fatal(&quot;致命 this is an fatal message!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　c）输出结果：&lt;/p&gt;
&lt;p&gt;　　　　控制台：因为日志级别为DEBUG， 所以常见级别日志处于打开状态， 输出。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731111858167-1238006502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　文件：因为日志级别为DEBUG， 所以常见级别日志处于打开状态， 输出。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731111913715-1451602856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）一般应用：&lt;/p&gt;
&lt;p&gt;　　　　a）配置文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 ### 1.根日志配置 日志级别：DEBUG
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 2&lt;/span&gt; log4j.rootLogger=&lt;span&gt;DEBUG, Console,File
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4 ### 2.自定义包日志配置
 5 ### 2.1 第一个自定义包：com.mylog4j.console 日志级别，INFO, 输出源名称ConsoleTest, 日志界别要比根日志级别高
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 6&lt;/span&gt; log4j.logger.com.mylog4j.console=&lt;span&gt;INFO, ConsoleTest
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 7 ### 2.2 第二个自定义包：com.mylog4j.file 日志级别，ERROR, 输出源名称FileTest，日志界别要比根日志级别高
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 8&lt;/span&gt; log4j.logger.com.mylog4j.file=&lt;span&gt;INFO, FileTest
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10 ### 3.自定义包输出源标志位配置， 默认是true
11 ### 3.1 第一个自定义包：com.mylog4j.console 是否从父类输出源输出：是。
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;12&lt;/span&gt; log4j.additivity.com.mylog4j.console=&lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;13 ### 3.2 第一个自定义包：com.mylog4j.console 是否从父类输出源输出：否。
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;14&lt;/span&gt; log4j.additivity.com.mylog4j.file=&lt;span&gt;false&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16 ### 4. 对于根logger输出源Console的配置，输出到控制台，通过配置输出格式灵活指定布局格式
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;17&lt;/span&gt; log4j.appender.Console=&lt;span&gt;org.apache.log4j.ConsoleAppender
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; log4j.appender.Console.layout=&lt;span&gt;org.apache.log4j.PatternLayout
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p %c(%L) - %m%&lt;span&gt;n
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21 ### 5. 对于根logger输出源File的配置，输出到文件，通过配置输出格式灵活指定布局格式
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;22&lt;/span&gt; log4j.appender.File=&lt;span&gt;org.apache.log4j.FileAppender
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; log4j.appender.File.File=./mylog4j/logs/&lt;span&gt;file.log
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;24 ### 5.1 产生新日志在此基础上追加， 默认是true
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;25&lt;/span&gt; log4j.appender.File.Append=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; log4j.appender.File.layout=&lt;span&gt;org.apache.log4j.PatternLayout
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; log4j.appender.File.layout.ConversionPattern=%d [%t] %-5p %c(%L) - %m%&lt;span&gt;n
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29 ### 6. 对于自定义包com.mylog4j.console 输出源ConsoleTest的配置，输出到控制台，通过配置输出格式灵活指定布局格式
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;30&lt;/span&gt; log4j.appender.ConsoleTest=&lt;span&gt;org.apache.log4j.ConsoleAppender
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; log4j.appender.ConsoleTest.layout=&lt;span&gt;org.apache.log4j.PatternLayout
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; log4j.appender.ConsoleTest.layout.ConversionPattern=%d [%t] %-5p %c(%L) - %m%&lt;span&gt;n
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;33 ### 6.1 输出级别为ERROE， 标红字体输出。
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;34&lt;/span&gt; log4j.appender.ConsoleTest.Target=&lt;span&gt;System.err
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; log4j.appender.ConsoleTest.Threshold=&lt;span&gt;ERROR
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37 ### 7. 对于自定义包com.mylog4j.file 输出源FileTest的配置，输出到文件，通过配置输出格式灵活指定布局格式
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;38&lt;/span&gt; log4j.appender.FileTest=&lt;span&gt;org.apache.log4j.FileAppender
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; log4j.appender.FileTest.File=./mylog4j/logs/&lt;span&gt;fileTest.log
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;40 ### 7.1 产生新日志在此基础上覆盖， 默认是true
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;41&lt;/span&gt; log4j.appender.FileTest.Append=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; log4j.appender.FileTest.layout=&lt;span&gt;org.apache.log4j.PatternLayout
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; log4j.appender.FileTest.layout.ConversionPattern=%d [%t] %-5p %c(%L) - %m%&lt;span&gt;n
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; log4j.appender.FileTest.Threshold=INFO&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　b)）java文件：ConsoleTest在com.mylog4j.console包下，FileTest在com.mylog4j.file包下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个Java文件&lt;/span&gt;
&lt;strong&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mylog4j.console;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsoleTest {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = Logger.getLogger(ConsoleTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         logger.debug(&quot;[ConsoleTest.class] 调试 this is a debug message&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         logger.info(&quot;[ConsoleTest.class] 基本 this is an info message!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         logger.warn(&quot;[ConsoleTest.class] 警告 this is a warn message&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         logger.error(&quot;[ConsoleTest.class] 错误 this is an error message!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         logger.fatal(&quot;[ConsoleTest.class] 致命 this is an fatal message!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个Java文件&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mylog4j.file;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileTest {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = Logger.getLogger(FileTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         logger.debug(&quot;[FileTest.class] this is a debug message&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         logger.info(&quot;[FileTest.class] this is an info message!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         logger.warn(&quot;[FileTest.class] this is a warn message&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         logger.error(&quot;[FileTest.class] this is an error message!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         logger.fatal(&quot;[FileTest.class] this is an fatal message!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　c）运行结果:&lt;/p&gt;
&lt;p&gt; 　　　　第一个java文件运行控制台：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731115927078-1043251465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　第一个Java文件运行日志文件：file.log打印日志， fileTest.log为空。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731120016134-1022968727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731120135619-1012109043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　第二个java文件运行控制台：&lt;/p&gt;
&lt;p&gt;　　　　&lt;em&gt;&lt;span&gt;空&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　第二个java文件运行日志文件：file.log为空， fileTest.log打印日志。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731134523551-1388191046.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445564/201807/1445564-20180731134531728-124019872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　d）结果分析：&lt;/p&gt;
&lt;p&gt;　　对于第一个Java文件运行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虽然， 在根logger配置了日志级别为DEBUG（&lt;span&gt;log4j.rootLogger=&lt;span&gt;DEBUG&lt;/span&gt;, Console,File&lt;/span&gt;）， 但是配置文件中配置了com.mylog4j.console包下的Java文件运行日志级别是INFO（&lt;span&gt;log4j.logger.com.mylog4j.console=&lt;span&gt;INFO&lt;/span&gt;, ConsoleTest&lt;/span&gt;）， 因此无论是控制台，还是文件中，都看不到debug级别的日志。&lt;/li&gt;
&lt;li&gt;在配置文件中， 配置了com.mylog4j.console包下的Java文件输出源标志是true（&lt;span&gt;log4j.additivity.com.mylog4j.console=&lt;span&gt;true&lt;/span&gt;&lt;/span&gt;），也就是说， 这个包下的日志除了本身配置的输出源ConsoleTest（&lt;span&gt;log4j.logger.com.mylog4j.console=INFO&lt;/span&gt;, &lt;span&gt;ConsoleTest&lt;/span&gt;）外， 还会在根logger配置的输出源Console，File（&lt;span&gt;log4j.rootLogger=DEBUG, &lt;span&gt;Console&lt;/span&gt;,&lt;span&gt;File&lt;/span&gt;&lt;/span&gt;）输出 。这就是为什么在控制台输出了两遍日志。但是这两遍日志并不是完全一样的。对于ConsoleTest输出源配置的输出方式， 日志级别重新定义成了ERROR而且标红显示（&lt;span&gt;log4j.appender.ConsoleTest.Threshold=&lt;/span&gt;&lt;span&gt;&lt;span&gt;ERROR， &lt;/span&gt;&lt;/span&gt;&lt;span&gt;log4j.appender.ConsoleTest.Target=&lt;/span&gt;&lt;span&gt;System.err&lt;/span&gt;），所以在控制台看到的日志组成是， 白色的是根logger配置的Console输出源的输出方式，红色的是自定义包配置的ConsoleTest输出源的输出方式。对于文件来说，这个包本身配置了一个输出源ConsoleTest（&lt;span&gt;log4j.logger.com.mylog4j.console=INFO,&lt;/span&gt; &lt;span&gt;ConsoleTest&lt;/span&gt;）， 这个输出源是在控制台输出（&lt;span&gt;log4j.appender.ConsoleTest=&lt;/span&gt;&lt;span&gt;org.apache.log4j.ConsoleAppender&lt;/span&gt;），而不会在文件中输出。所以在日志文件中日志只输出了一遍， 输出的这一遍是由根logger配置的File输出源的输出方式（&lt;span&gt;log4j.appender.File=&lt;/span&gt;&lt;span&gt;org.apache.log4j.FileAppender&lt;/span&gt;）。因为根日志输出源和自定义包的输出源都没有指定输出到fileTest.log中，因此fileTest.log没有记录日志。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　对于第二个Java文件运行：　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同理，虽然， 在根logger配置了日志级别为DEBUG（&lt;span&gt;log4j.rootLogger=&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;, Console,File&lt;/span&gt;）， 但是配置文件中配置了com.mylog4j.file包下的Java文件运行日志级别是INFO（&lt;span&gt;log4j.logger.com.mylog4j.file=&lt;/span&gt;&lt;span&gt;INFO&lt;/span&gt;, &lt;span&gt;ConsoleTest&lt;/span&gt;）， 因此无论是控制台，还是文件中，都看不到debug级别的日志。&lt;/li&gt;
&lt;li&gt;不同的是，配置文件中， 配置了com.mylog4j.file包下的Java文件输出源标志是false（&lt;span&gt;log4j.additivity.com.mylog4j.file=&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;）， 也就是说， 这个包下的日志， 只会在本身配置的输出源中输出，即只会在FileTest中输出（log4j.logger.com.mylog4j.file=INFO, &lt;span&gt;FileTest&lt;/span&gt;）。而FileTest配置的输出目的地是文件格式输出， 输出在fileTest.log文件中（&lt;span&gt;log4j.appender.FileTest.File=./mylog4j/logs/&lt;/span&gt;&lt;span&gt;fileTest.log&lt;/span&gt;）， 因此在控制台和file.log中都看不到打印的日志。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;四、未完待续&lt;/p&gt;
&lt;p&gt;　　时间有限， 只是总结了最最基础的log4j的使用， 还有将日志每天输出一次， 或者是记录日志的文件达到一定程度时产生新文件，将日志输出到邮件， 数据库等没有整理， 再就是对于web项目的log使用。 有时间了在整理吧。　　　　&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 06:38:00 +0000</pubDate>
<dc:creator>梓榕林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuesm/p/9392654.html</dc:identifier>
</item>
<item>
<title>Hystrix是如何工作的 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/9395584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/9395584.html</guid>
<description>&lt;p&gt;&lt;span&gt;接上一篇：《&lt;a href=&quot;https://www.cnblogs.com/cjsblog/p/9391819.html&quot; target=&quot;_blank&quot;&gt;Hystrix介绍&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;流程图&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下面这幅图相当重要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180731133214602-1161901613.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稍微解释一下上面的流程：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Construct a HystrixCommand or HystrixObservableCommand Object&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Execute the Command&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Is the Response Cached?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Is the Circuit Open?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Is the Thread Pool/Queue/Semaphore Full?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HystrixObservableCommand.construct() or HystrixCommand.run()&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Calculate Circuit Health&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Get the Fallback&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Return the Successful Response&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;span&gt;1. 构造一个HystrixCommand或者HystrixObservableCommand对象&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;第一步是构造一个HystrixCommand或HystrixObservableCommand对象来表示对依赖项的请求。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HystrixCommand command = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HystrixCommand(arg1, arg2);
HystrixObservableCommand command &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HystrixObservableCommand(arg1, arg2);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 2. 执行命令&lt;/h3&gt;
&lt;p&gt; &lt;span&gt;你可以用下列四种中的任意一种方式执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;execute() — 阻塞，直到收到响应或者抛出异常.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;queue() — 返回一个Future&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;observe() — 订阅代表响应的Observable&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;toObservable() — 返回一个Observable，当你订阅它以后，将会执行Hystrix命令并且推送它的响应&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180731134344962-1898805493.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;execute()方法是同步执行的，它是调用queue().get()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;queue()方法是异步执行的，它调用的是toObservable().toBlocking().toFuture()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以最终每个HystrixCommand都是一个Observable的实现&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 响应是否已经被缓存？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果请求在缓存中可用，并且该请求对应的响应在缓存中也是可用的，那么缓存的这个响应将立即以一个Observable的形式被返回&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4. 断路器是否打开？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当你执行命令的时候，Hystrix检查断路器是否是开着的。如果是开着的，那么Hystrix不会执行命令，而是路由到第8步执行回退逻辑。如果是关着的，将执行第5步，继续检查容量是否可用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5. 线程池/队列/信号量是否已经满了？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果这个命令所关联的线程池和队列（或者信号量）是否满了，如果是，那么Hystrix不会执行命令，而是立即路由到第8不执行回退逻辑&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;6. HystrixObservableCommand.construct() or HystrixCommand.run()&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们知道对依赖的调用请求都是封装成HystrixCommand或者HystrixObservableCommand执行的，而真正执行的逻辑是写在HystrixObservableCommand.construct()或者HystrixCommand.run()中的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;HystrixCommand.run() — 返回一个响应或者抛出一个异常&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HystrixObservableCommand.construct() — 返回一个Observable，并且推送响应或者发送一个onError通知&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果在执行run()或者construct()方法超时，那么线程将抛出一个TimeoutException。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;7. 计算电路健康&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Hystrix报告成功、失败、拒绝、超时给断路器，断路器维护一组计算统计的计数器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;断路器用这些统计数据来决定什么时候应该“跳闸”，此时后续所有的请求都会被短路，直到一个恢复周期耗尽以后在第一次检查某些健康检查之后才会打开电路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（PS：想象一下生活中的漏电保护器，电压过高时会自动跳闸，跳闸以后就没电了，家用电器都用不了了，之后你可以自己不去合上，当然前提是你不能再用那些大功率电器了，于是来电了）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;8. 回退&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当命令执行失败时，Hystrix试图恢复到您的fallback：当run()或者construct()抛出异常；当由于断路器跳闸导致命令被短路；当命令的线程池或队列容量满了；或者当命令执行超时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在HystrixCommand的情况下，为了提供回退逻辑，你可以实现HystrixCommand.getfallback()，它返回一个单一的回退值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于HystrixObservableCommand()，为了提供回退逻辑，你需要实现hystrixobservablecomman.resumewithfallback()，它会返回一个Observable，这个Observable可能返回一个回退值或者多个值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你没有实现一个fallback方法，或者fallback它自己抛了一个异常，此时Hystrix仍然会返回一个Observable，但是这个Observable什么都不会推送并立即发送一个onError通知。通过这个onError通知，造成命令失败的异常会传回给调用者。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;9. 返回成功响应&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果Hystrix命令成功，它会返回响应给调用者，或者返回一个Observable。这取决于在第2步的时候你是如果调用命令的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Circuit Breaker（断路器）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下图显示了HystrixCommand或HystrixObservableCommand是如何与HystrixCircuitBreaker交互的，以及它的逻辑和决策流程，包括断路器中计数器的行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180731140519034-1436157555.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的流程可以这样描述：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;假设整个电路的体积达到一定的阈值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;假设错误百分比超过设定的错误百分比阈值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;断路器从CLOSED变成OPEN&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当它打开时，经过这个断路器的所有请求被短路&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;过了一段时间以后，下一个单个请求被允许通过（此时是半打开状态）。如果这个请求失败，在接下来的睡眠窗口期间断路器保持OPEN状态；如果这个请求成功，断路器转成CLOSED状态；然后继续执行第1步，如此反复。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;隔离&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Hystrix使用隔板模式来隔离彼此的依赖关系，并限制对其中任何一个的并发访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180731140733359-344576802.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;线程和线程池&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Hystrix使用独立的、每个依赖项的线程池作为约束任何给定依赖项的一种方式，因此底层执行的延迟只会使该池中的可用线程饱和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180731140845415-775187313.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;线程池的好处&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;应用程序被完全保护而不受失控的客户端的影响。给定的依赖项的线程池可以填满，而不会影响应用程序的其余部分。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;应用程序可以接收新的客户端请求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当失败的客户端再次恢复正常时，线程池将被清理，应用程序将立即恢复正常的性能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果一个客户端配置错误，线程池的健康将会很快地证明这一点(通过增加错误、延迟、超时、拒绝等)，并且您可以处理它(通常是通过动态属性进行实时处理)，而不会影响应用程序的功能。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;Semaphores（信号量）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;你可以用信号量（或者计数器）来限制对任意依赖项并发调用的数量，代替用线程池的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HystrixCommand 和 HystrixObservableCommand 在两个地方支持用信号量：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Fallback：当Hystrix恢复fallbacks时它总是调用Tomcat的线程这样做&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Execution：如果设置属性execution.isolation.strategy为SEMAPHORE，那么，Hystrix将使用信号量而不是线程来限制调用该命令的发父线程的并数量。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/Netflix/Hystrix/wiki/How-it-Works&quot; target=&quot;_blank&quot;&gt;https://github.com/Netflix/Hystrix/wiki/How-it-Works&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 06:16:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/9395584.html</dc:identifier>
</item>
<item>
<title>U-Net卷积神经网络 - JieLongZ</title>
<link>http://www.cnblogs.com/jielongAI/p/9395381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jielongAI/p/9395381.html</guid>
<description>&lt;p&gt;由于项目需要，用U-NET跑一个程序来对医学影像进行分割（segmentation），因此跑去看了下这篇论文（paper），下面会介绍一下U-Net的框架及要点，如果哪里有写的不对的，或者好的建议，欢迎提出并纠正。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;论文地址&lt;/strong&gt;&lt;/span&gt;：&lt;a title=&quot;U-Net&quot; href=&quot;https://arxiv.org/abs/1505.04597&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/abs/1505.04597&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　1. &lt;span&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;U-Net通俗来讲也是卷积神经网络的一种变形，主要其结构经论文作者画出来形似字母U（见图 1），因而得名U-Net。整个神经网络主要有两部分组成：收缩路径（contracting path）和扩展路径（expanding path）。搜索路径主要是用来捕捉图片中的上下文信息（context information），而与之相对称的扩展路径则是为了对图片中所需要分割出来的部分进行精准定位（localization）。U-Net诞生的一个主要前提是，很多时候深度学习的结构需要大量的sample和计算资源，但是U-Net基于&lt;a title=&quot;Fully Convolutional Neural Network&quot; href=&quot;https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf&quot; target=&quot;_blank&quot;&gt;FCN&lt;/a&gt;（Fully Convultional Neural Network：全卷积神经网络）进行改进，并且利用数据增强（data augmentation）可以对一些比较少样本的数据进行训练，特别是医学方面相关的数据（医学数据比一般我们所看到的图片及其他文本数据的获取成本更大，不论是时间还是资源的消耗），所以U-Net的出现对于深度学习用于较少样本的医学影像是很有帮助的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441504/201807/1441504-20180731124751968-983262854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2. 网络结构及原理解析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就如前面所说的U-Net是基于FCN进行改进的，比较tricky的地方就是U-Net不是简单地像FCN那样子对图片进行encode和decode，U-Net为了能精准的定位，收缩路径上提取出来的高像素特征会在升采样（upsampling）过程中与新的特征图（feature map）进行结合，以最大程度的保留前面降采样（downsampling）过程一些重要的特征信息。而为了能使网络结构能更高效的运行，结构中是没有全连接层（fully connected layers），这样子可以很大程度上减少需要训练的参数，并得益于特殊的U形结构可以很好的保留图片中的所有信息。&lt;/p&gt;
&lt;p&gt;收缩路径上是每两个 3 * 3 的卷积层（unpadded convolutional layers）后会跟一个2 * 2的最大池化层（Maxpooling layer: 步长为2），并且每个卷积层后面采用relu激活函数来对原始图片进行降采样操作，除此之外，每一次降采样都会增加一杯通道数（double the number of feature channel）。&lt;/p&gt;
&lt;p&gt;在扩展路径的向上采样（deconvolution）中，每一步会有一个 2 * 2 的卷积层（激活函数也是relu）和一个两个 3 * 3 的卷积层，&lt;span&gt;于此同时，每一步的升采样都会加入来自相对应收缩路径的特征图（经裁剪以保持相同的形状shape）&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在网络的最后一层是一个 1 * 1 的卷积层，通过这一操作可以将64通道的特征向量转换为所需要的分类结果的数量（例如2），最终，U-Net的整个网络一共有23层卷积层。U-Net有一个很重要的有点是其基本可以对任意形状大小的图片进行卷积操作，特别是任意大的图片。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 05:33:00 +0000</pubDate>
<dc:creator>JieLongZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jielongAI/p/9395381.html</dc:identifier>
</item>
<item>
<title>vuex源码分析3.0.1(原创) - 陈蒙的技术空间</title>
<link>http://www.cnblogs.com/chenmeng2062/p/9337650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmeng2062/p/9337650.html</guid>
<description>&lt;p&gt;&lt;strong&gt;chapter1 store构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.constructor&lt;/p&gt;
&lt;p&gt;2.get state和set state&lt;/p&gt;
&lt;p&gt;3.commit&lt;/p&gt;
&lt;p&gt;4.dispatch&lt;/p&gt;
&lt;p&gt;5.subscribe和subscribeAction&lt;/p&gt;
&lt;p&gt;6.watch和replaceState&lt;/p&gt;
&lt;p&gt;7.registerModule和unregisterModule&lt;/p&gt;
&lt;p&gt;8.hotUpdate和_withCommit&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;chapter2 export install&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt;Vuex如何实现装载的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;chapter3 辅助函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.registerMutation、registerAction、registerGetter&lt;/p&gt;
&lt;p&gt;2.enableStrictMode、getNestedState&lt;/p&gt;
&lt;p&gt;3.unifyObjectStyle(type, payload, options)&lt;/p&gt;

&lt;p&gt;1.constructor&lt;/p&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
 constructor (options =&lt;span&gt; {}) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;安装Vue对象&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!Vue &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; window !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; window.Vue) {
      console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;window.vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      install(window.Vue)
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发环境对Vue、Promise和Store的判断&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; Promise !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, `vuex requires a Promise polyfill &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt; browser.`)
      assert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; instanceof Store, `store must be called with the &lt;span&gt;new&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&lt;span&gt;.`)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options包括插件选项、严格模式选项&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt;&lt;span&gt; {
      plugins &lt;/span&gt;=&lt;span&gt; [],
      strict &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    } &lt;/span&gt;=&lt;span&gt; options

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储内部的状态&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;._committing = &lt;span&gt;false&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;._actions = Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._actionSubscribers =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._mutations = Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._wrappedGetters = Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._modules = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModuleCollection(options)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._modulesNamespaceMap = Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._subscribers =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._watcherVM = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue()

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定commit和dispatch&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; store = &lt;span&gt;this&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; { dispatch, commit } = &lt;span&gt;this&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.dispatch =&lt;span&gt; function boundDispatch (type, payload) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dispatch.call(store, type, payload)
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.commit =&lt;span&gt; function boundCommit (type, payload, options) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; commit.call(store, type, payload, options)
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 严格模式&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.strict =&lt;span&gt; strict

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; state = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._modules.root.state

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化根模块，或者安装子模块&lt;/span&gt;
    installModule(&lt;span&gt;this&lt;/span&gt;, state, [], &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._modules.root)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化vm&lt;/span&gt;
    resetStoreVM(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, state)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 应用插件&lt;/span&gt;
    plugins.forEach(plugin =&amp;gt; plugin(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;))
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Vue.config.devtools) {
      devtoolPlugin(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.get state和set state&lt;/p&gt;
&lt;p&gt;ES6的get和set是取值和存值的函数，这是是对属性state拦截存取行为。&lt;/p&gt;
&lt;p&gt;示例1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
E:\vuex&amp;gt;&lt;span&gt;node
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类的声明，属性prop进行存取拦截&lt;/span&gt;
&amp;gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass {
...     constructor() {
.....           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;.....   }
...     &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; prop() {
.....           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;getter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
.....   }
...     &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; prop(value) {
.....           console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;setter: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; value);
.....   }
... }
undefined
&lt;/span&gt;&amp;gt; let inst = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyClass();
undefined
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置prop时，根据程序逻辑会console.log&lt;/span&gt;
&amp;gt; inst.prop = &lt;span&gt;123&lt;/span&gt;&lt;span&gt;;
setter: &lt;/span&gt;&lt;span&gt;123&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取prop，根据return返回&quot;getter&quot;字符串&lt;/span&gt;
&amp;gt;&lt;span&gt; inst.prop
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;getter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取值返回的是this属性&lt;/span&gt;
&lt;span&gt;get&lt;/span&gt;&lt;span&gt; state () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._vm._data.$$state
  }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在非生产环境，那么修改state就会使用assert打印错误信息&lt;/span&gt;
  &lt;span&gt;set&lt;/span&gt;&lt;span&gt; state (v) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      assert(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, `use store.replaceState() to &lt;span&gt;explicit&lt;/span&gt;&lt;span&gt; replace store state.`)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.commit&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; commit (_type, _payload, _options) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; check object-style commit检查对象风格提交&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt;&lt;span&gt; {
      type,
      payload,
      options
    } &lt;/span&gt;=&lt;span&gt; unifyObjectStyle(_type, _payload, _options)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mutation的type判断，也就是entry，如果不存在，那么打印错误信息“不存在的mutation type”&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; mutation =&lt;span&gt; { type, payload }
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; entry = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._mutations[type]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;entry) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
        console.error(`[vuex] unknown mutation type: ${type}`)
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理entry并订阅它&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;._withCommit(() =&amp;gt;&lt;span&gt; {
      entry.forEach(function commitIterator (handler) {
        handler(payload)
      })
    })
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._subscribers.forEach(sub =&amp;gt; sub(mutation, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发模式下的silent判断&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (
      process.env.NODE_ENV &lt;/span&gt;!== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
      options &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; options.silent
    ) {
      console.warn(
        `[vuex] mutation type: ${type}. Silent option has been removed. ` &lt;/span&gt;+
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Use the filter functionality in the vue-devtools&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      )
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(1)const { type, payload,options}=unify..........这是ES6的解构赋值。(node环境执行的哦)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;示例2&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
E:\vuex&amp;gt;&lt;span&gt;node
&lt;/span&gt;&amp;gt; &lt;span&gt;const&lt;/span&gt; person =&lt;span&gt; {
...   name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;little bear&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
...   age: &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;,
...   sex: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
... }
undefined
&lt;/span&gt;&amp;gt; let { name,age,sex } =&lt;span&gt; person
undefined
&lt;/span&gt;&amp;gt;&lt;span&gt; name
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;little bear&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)this._withCommit(...)小括号内的部分总体上说是_withCommit的fn参数。&lt;/p&gt;
&lt;p&gt;this._withCommit()中有对this._committing进行设置，首先this._committing = false赋值给中间变量，接下来提交前设为true，fn调用结束后再通过中间变量设为初始值。&lt;/p&gt;
&lt;p&gt;接下来说说entry。entry就是mutations的type也就是某个函数。可是明明forEach方法是数组啊。其实通过this._mutations[type]获取到就是一个数组。那么对数组的元素handler进行调用。entry&lt;/p&gt;
&lt;p&gt;类似如下内容:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028445/201807/1028445-20180720165137415-562685667.png&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(3)this._subscribers.forEach(sub =&amp;gt; sub(mutation, this.state))是_subscribers遍历收集来的actions并执行。我们要注意到actions的使用也有commit提交，不过是异步的。所以这里的actions执行是为了补充刚刚同步提交的方式。&lt;/p&gt;
&lt;p&gt;图示1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028445/201807/1028445-20180720174058090-412385855.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(4)process.env.NODE_ENV !== 'production' &amp;amp;&amp;amp;options &amp;amp;&amp;amp; options.silent&lt;/p&gt;
&lt;p&gt;检查选项，silent是静默选项，如果使用了silent，那么告知&quot;silent已经被移除，请在dev-tool中使用过滤器功能。&lt;/p&gt;
&lt;p&gt;4,dispatch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dispatch (_type, _payload) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查数组风格的分发&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt;&lt;span&gt; {
      type,
      payload
    } &lt;/span&gt;=&lt;span&gt; unifyObjectStyle(_type, _payload)

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; action =&lt;span&gt; { type, payload }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从this._actions拿到type对应的事件类型&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; entry = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._actions[type]
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果entry也就是事件类型不存在，那么打印信息&quot;vuex不知道的action类型&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;entry) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
        console.error(`[vuex] unknown action type: ${type}`)
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_actionSubscribers遍历每个订阅&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;._actionSubscribers.forEach(sub =&amp;gt; sub(action, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果entry.length大于1，那么返回promise&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; entry.length &amp;gt; &lt;span&gt;1&lt;/span&gt;
      ? Promise.all(entry.map(handler =&amp;gt;&lt;span&gt; handler(payload)))
      : entry[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;](payload)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.subscribe和subscribeAction&lt;/p&gt;
&lt;p&gt;subscribe订阅store的mutation。回调函数会在每个mutaion完成时触发。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; myPlugin = store =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当 store 初始化后订阅&lt;/span&gt;
            store.subscribe((mutation, state) =&amp;gt;&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调函数在每次mutation完成之后调用&lt;/span&gt;
                state.count++&lt;span&gt;;
            })
        }
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
            state:{
                count:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
            },
            mutations:{
                increment(state,payload){
                    state.count&lt;/span&gt;=state.count*&lt;span&gt;payload;
                }
            },
            plugins: [myPlugin]
})
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交&quot;increment&quot;事件&lt;/span&gt;
store.commit(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终store.state.count等于5*20+1=101。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;subscribeAction订阅action。回调函数会在每个action完成时触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; myPlugin2 = store =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当 store 初始化后订阅&lt;/span&gt;
            store.subscribeAction((action, state) =&amp;gt;&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次action完成后回调函数都会被触发&lt;/span&gt;
                state.huge--&lt;span&gt;;
            })
        }
 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
            state:{
                huge:&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;
            },
            mutations:{
                REDUCE(state,payload){
                    state.huge&lt;/span&gt;=state.huge-&lt;span&gt;payload
                }
            },
            actions:{
                reduce({commit,state},payload){
                    commit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REDUCE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,payload)
                }
            },
            plugins: [myPlugin2]
        })
store.dispatch(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reduce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;store.state.huge结果2000-500-1等于1499&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subscribe (fn) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fn即刚才说的每次mutation之后的回调函数&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; genericSubscribe(fn, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._subscribers)
  }

  subscribeAction (fn) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; genericSubscribe(fn, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._actionSubscribers)
  }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;subscribe和subscribeAction返回的是一个箭头函数&lt;/span&gt;
&lt;span&gt;function genericSubscribe (fn, subs) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅fn，那么会push到this._subscribers或者this._actionSubscribers数组&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (subs.indexOf(fn) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    subs.push(fn)
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;箭头函数在需要回调的时候再从数组里裁剪出fn元素&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; i =&lt;span&gt; subs.indexOf(fn)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
      subs.splice(i, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看出，genericSubscribe功能是对订阅数组的处理，先存进数组，需要的时候再取出来。&lt;/p&gt;
&lt;p&gt;6.watch和replaceState&lt;/p&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;watch (getter, cb, options) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传入的getter不是function，那么打印信息&quot;store.watch只接受一个函数&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      assert(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; getter === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, `store.watch only accepts a function.`)
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回Vue.$watch方法，响应式监听() =&amp;gt; getter(this.state, this.getters)返回的值
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果发生变化，那么cb回调函数触发
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options包括选项：deep,选项：immediate&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._watcherVM.$watch(() =&amp;gt; getter(&lt;span&gt;this&lt;/span&gt;.state, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getters), cb, options)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Vue API中$watch的用法&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;addOne&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;加一&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
       let vm&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data:{
                a:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            },
           created:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$watch监听第一个函数返回的只，一旦发生变化，那么执行回调函数&lt;/span&gt;
               &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$watch(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a;
               },&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newValue,oldValue){
                   console.log(newValue)
               })
           },
            methods:{
                addOne(){
                   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                }
            }
        })

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;replaceState整体替换state,变化引起回调发生&lt;/span&gt;
const store=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
           state:{
               count:&lt;/span&gt;0&lt;span&gt;
           }
       })

       store.watch(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; store.state;
       },&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           console.log(store.state.count)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
&lt;span&gt;       })
store.replaceState({count:&lt;/span&gt;20})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//通过mutation改变&lt;/span&gt;&lt;span&gt;state，触发watch回调&lt;/span&gt;
const store2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
    state:{
        count:&lt;/span&gt;100&lt;span&gt;
    },
    mutations:{
        ADDONE(state){
            state.count&lt;/span&gt;++&lt;span&gt;;
        }
    }

})
store2.watch(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; store2.state.count
    },&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(store2.state.count) 
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;
&lt;span&gt;    }
)
store2.commit(&lt;/span&gt;&quot;ADDONE&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;replaceState (state) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._withCommit(() =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._vm._data.$$state =&lt;span&gt; state
    })
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过传入一个新state对象，替换旧state。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; store=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
              state:{
                  count:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                  num:&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
              }
 })
 store.replaceState({count:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过替换，旧的state不存在，只有更新后的state&lt;/span&gt;
store.state.count&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等于0&lt;/span&gt;
store.state.num&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.registerModule和unregisterModule&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
registerModule (path, rawModule, options =&lt;span&gt; {}) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入的第一个参数要么是数组，要么是字符串，字符串会转化为字符串为元素的数组&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; path === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) path =&lt;span&gt; [path]
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发环境下的调试信息&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果path不能转为数组或者不是数组，那么打印&quot;模块path必须是字符串或者数组&quot;&lt;/span&gt;
      assert(Array.isArray(path), `module path must be a &lt;span&gt;string&lt;/span&gt;&lt;span&gt; or an Array.`)
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传入的path为[]空数组，那么打印&quot;不能使用registerModule来注册根模块&quot;&lt;/span&gt;
      assert(path.length &amp;gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cannot register the root module by using registerModule.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在store._modules上注册模块&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._modules.register(path, rawModule)
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;安装模块&lt;/span&gt;
    installModule(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.state, path, &lt;span&gt;this&lt;/span&gt;._modules.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(path), options.preserveState)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reset store to update getters...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以当前state更新store.getters&lt;/span&gt;
    resetStoreVM(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function installModule (store, rootState, path, module, hot) {
  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; isRoot = !&lt;span&gt;path.length
  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; =&lt;span&gt; store._modules.getNamespace(path)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册命名空间的映射数组_modulesNamespaceMap&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (module.namespaced) {
    store._modulesNamespaceMap[&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;] =&lt;span&gt; module
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hot,即options 可以包含 preserveState: true 以允许保留之前的 state。用于服务端渲染。&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!isRoot &amp;amp;&amp;amp; !&lt;span&gt;hot) {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; parentState = getNestedState(rootState, path.slice(&lt;span&gt;0&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; moduleName = path[path.length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
    store._withCommit(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      Vue.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(parentState, moduleName, module.state)
    })
  }

  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; local = module.context = makeLocalContext(store, &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;, path)
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历mutation并注册mutation，会因为namespaced而不同&lt;/span&gt;
  module.forEachMutation((mutation, key) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; namespacedType = &lt;span&gt;namespace&lt;/span&gt; +&lt;span&gt; key
    registerMutation(store, namespacedType, mutation, local)
  })
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历action并注册action&lt;/span&gt;
  module.forEachAction((action, key) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果action.root为true，那么type等于key索引值，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;即全局action，无论是子模块还是子模块的子模块都如此
    
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果action.root为false,那么type直接取namespacType&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; type = action.root ? key : &lt;span&gt;namespace&lt;/span&gt; +&lt;span&gt; key
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; handler = action.handler ||&lt;span&gt; action
    registerAction(store, type, handler, local)
  })
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历getter并注册getterts，会因为namespaced而不同&lt;/span&gt;
  module.forEachGetter((getter, key) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; namespacedType = &lt;span&gt;namespace&lt;/span&gt; +&lt;span&gt; key
    registerGetter(store, namespacedType, getter, local)
  })
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历子模块，并递归调用installModule&lt;/span&gt;
  module.forEachChild((child, key) =&amp;gt;&lt;span&gt; {
    installModule(store, rootState, path.concat(key), child, hot)
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; unregisterModule (path) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; path === 'string') path =&lt;span&gt; [path]
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传入参数不能转为数组，那么打印&quot;模块路径必须是字符串或者数组&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
      assert(Array.isArray(path), `module path must be a string or an Array.`)
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消注册，那么store._modules.root._children就不会定义myModule属性了&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._modules.unregister(path)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._withCommit(() =&amp;gt;&lt;span&gt; {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;getNestedState获取到父级state&lt;/span&gt;
      const parentState = getNestedState(&lt;span&gt;this&lt;/span&gt;.state, path.slice(0, -1&lt;span&gt;))
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Vue删除相应的module内容&lt;/span&gt;
      Vue.&lt;span&gt;delete&lt;/span&gt;(parentState, path[path.length - 1&lt;span&gt;])
    })
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以当前的this重置store&lt;/span&gt;
    resetStore(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8.hotUpdate和_withCommit&lt;/p&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;热重载&lt;/span&gt;
&lt;span&gt;hotUpdate (newOptions) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._modules.update(newOptions)
    resetStore(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vuex 支持在开发过程中热重载 mutation、module、action 和 getter。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; _withCommit (fn) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次提交的时候，内部代码都会传进来一个箭头函数&lt;/span&gt;
    const committing = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._committing
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._committing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    fn()
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._committing =&lt;span&gt; committing
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;这行语句安装了window.Vue&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        let Vue;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;Vue &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; window &lt;/span&gt;&lt;span&gt;!==&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; window.Vue) {
            console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;window.vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            install(window.Vue)
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;  install (_Vue) {
            Vue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _Vue
            console.log(Vue);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;applyMixin(Vue)是为了在Vue初始化之前(beforeCreate)来完成vuex的初始化&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为2版本才提供了beforeCreate这个钩子函数&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;applyMixin主要逻辑:if (version &amp;gt;= 2) {Vue.mixin({ beforeCreate: vuexInit })} else {}&lt;/span&gt;
&lt;span&gt;        }
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从中可以看出vuex的初始化过程，以Vue2版本为为例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028445/201807/1028445-20180731123518786-1419519930.png&quot; alt=&quot;&quot; width=&quot;664&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; install (_Vue) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么问题来了，为什么要使用let Vue这个文件一个全局变量呢？主要是为了避免重复安装&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (Vue &amp;amp;&amp;amp; _Vue ===&lt;span&gt; Vue) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经安装过，那么Vue就等于window.Vue为什么呢？&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Vue.use(plugin)方法会调用export的install方法，那么调用中使用Vue=_Vue赋值语句&lt;/span&gt;
&lt;span&gt;      console.error(
        &lt;/span&gt;'[vuex] already installed. Vue.use(Vuex) should be called only once.'&lt;span&gt;
      )
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  }
  Vue &lt;/span&gt;=&lt;span&gt; _Vue
  applyMixin(Vue)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;install调用逻辑分析:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028445/201807/1028445-20180731121642073-1859001044.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.registerMutation、registerAction、registerGetter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function registerMutation (store, type, handler, local) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将type属性添加到_mutations对象，其初始值为空数组[]&lt;/span&gt;
  &lt;span&gt;const&lt;/span&gt; entry = store._mutations[type] || (store._mutations[type] =&lt;span&gt; [])
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们应该记得mutation是一个函数，那么function.call做一个继承，local.state和payload都应用于store对象&lt;/span&gt;
&lt;span&gt;  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload)
  })
}
........
registerMutation(store, namespacedType, mutation, local)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function registerAction (stobre, type, handler, local) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_actions具有type属性，其初始值为一个数组&lt;/span&gt;
  &lt;span&gt;const&lt;/span&gt; entry = store._actions[type] || (store._actions[type] =&lt;span&gt; [])
  entry.push(function wrappedActionHandler (payload, cb) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承于store对象&lt;/span&gt;
    let res =&lt;span&gt; handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果res不是一个promise，那么相当于直接返回含有res内容的promise对象&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isPromise(res)) {
      res &lt;/span&gt;=&lt;span&gt; Promise.resolve(res)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_devtoolHook判断&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (store._devtoolHook) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拦截promise错误&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; res.&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
        store._devtoolHook.emit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vuex:error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, err)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err
      })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回res&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
    }
  })
}
.........
registerAction(store, type, handler, local)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们应该还记得action是可以写异步操作的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function registerGetter (store, type, rawGetter, local) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果对应已getter存在，进入分支，打印说&quot;vuex重复的getter键&quot;&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (store._wrappedGetters[type]) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      console.error(`[vuex] duplicate getter key: ${type}`)
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  }
  store._wrappedGetters[type] &lt;/span&gt;=&lt;span&gt; function wrappedGetter (store) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过当前local和store返回rawGetter对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rawGetter(
      local.state, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; local state&lt;/span&gt;
      local.getters, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; local getters&lt;/span&gt;
      store.state, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; root state&lt;/span&gt;
      store.getters &lt;span&gt;//&lt;/span&gt;&lt;span&gt; root getters&lt;/span&gt;
&lt;span&gt;    )
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.enableStrictMode、getNestedState&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (store.strict) {
    enableStrictMode(store)
  }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;enableStrictMode功能是允许new vm的严格模式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function enableStrictMode (store) {
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;侦听this._data.$$state也就是state&lt;/span&gt;
  store._vm.$watch(function () { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._data.$$state }, () =&amp;gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;state变化，回调函数触发   
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;store._committing为False，那么打印&quot;不要在mutation处理器外部提交state&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      assert(store._committing, `&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; not mutate vuex store state outside mutation handlers.`)
    }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;deep:true，跟踪对象内部属性的变化，sync:true，同步&lt;/span&gt;
  }, { deep: &lt;span&gt;true&lt;/span&gt;, sync: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，getNestedState的功能是父级state对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function getNestedState (state, path) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; path.length
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;state为初始值，接下来遍历path数组，并以state[key]取得state对象&lt;/span&gt;
    ? path.reduce((state, key) =&amp;gt;&lt;span&gt; state[key], state)
    : state
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么为什么这个key比如state[&quot;myModule&quot;]的索引就能拿到对应的state呢？这是因为state对象长这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028445/201807/1028445-20180727172613755-1344903177.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
let vm= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        })
       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; store=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
           state:{
               count:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
           }
       })
       function getNestedState (state, path) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; path.length
               &lt;/span&gt;? path.reduce((state, key) =&amp;gt;&lt;span&gt; state[key], state)
               : state
       }
       let myModule&lt;/span&gt;=&lt;span&gt;{
           state:{
               count:&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
           }
       }
       store.registerModule(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myModule&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,myModule)
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到父级state对象
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;myModule&quot;].slice(0,-1)等于[]&lt;/span&gt;
       let parentState=getNestedState(store.state,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myModule&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].slice(&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
        console.log(parentState)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028445/201807/1028445-20180727172802683-763434710.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.unifyObjectStyle(type, payload, options)&lt;/p&gt;
&lt;p&gt;首先运行一下这个函数，它可以传入3个参数(payload)。由于process是nodejs环境的变量，那么在nodejs环境中运行。&lt;/p&gt;
&lt;p&gt;它的功能是&lt;span&gt;把提交数据对象风格化&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nodejs环境输入function代码&lt;/span&gt;
E:\vuex&amp;gt;&lt;span&gt;node
&lt;/span&gt;&amp;gt;&lt;span&gt; function isObject (obj) {
...   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj !== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; obj === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
... }function unifyObjectStyle (type, payload, options) {
...   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isObject(type) &amp;amp;&amp;amp;&lt;span&gt; type.type) {
.....     options &lt;/span&gt;=&lt;span&gt; payload
.....     payload &lt;/span&gt;=&lt;span&gt; type
.....     type &lt;/span&gt;=&lt;span&gt; type.type
.....   }
...
...  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
...     assert(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; type === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, `expects &lt;span&gt;string&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; the type, but found ${&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; type}.`)
...
...   }
...
...   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { type, payload, options }
... }
undefined
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nodejs环境中调用刚刚定义的unifyObjectStyle。&lt;/span&gt;
&amp;gt; unifyObjectStyle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,{name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vicky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,password:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
{ type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  payload: { name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vicky&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
  options: undefined }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt; unifyObjectStyle({type:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,payload:{name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vicky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,password:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}})
{ type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  payload: { type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, payload: { name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;vicky&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; } },
  options: undefined }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它讨论了两种情况。(1)如果type.type不存在，那么就是以&lt;span&gt;参数风格&lt;/span&gt;的提交，按照最终的对象格式return。(2)如果type.type存在，也就是&lt;span&gt;对象风格&lt;/span&gt;的提交，那么就让对象的type和payload重新赋值。然后return。以最终实现对象风格的统一。&lt;/p&gt;
&lt;p&gt;而process的部分是对type的值进行判断，如果不是string，那么assert一个报错信息。&lt;/p&gt;


&lt;p&gt;写作不易，欢迎打赏！微信哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028445/201807/1028445-20180731132402264-1352853557.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 05:25:00 +0000</pubDate>
<dc:creator>陈蒙的技术空间</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmeng2062/p/9337650.html</dc:identifier>
</item>
</channel>
</rss>