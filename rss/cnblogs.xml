<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>处理ASP.NET Core中的HTML5客户端路由回退 - tianfeng.cc</title>
<link>http://www.cnblogs.com/tianfengcc/p/7851974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianfengcc/p/7851974.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/437b0004415ad9ce36e5&quot; alt=&quot;处理ASP.NET Core中的HTML5客户端路由回退&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在使用由Angular，React，Vue等应用程序框架构建的客户端应用程序时，您总是会处理HTML5客户端路由，它将完全在浏览器中处理到页面和组件的客户端路由。几乎完全在浏览器中...&lt;/p&gt;
&lt;p&gt;HTML5客户端路由在客户端上工作的很好，但是当深入链接到一个站点或在浏览器中按刷新时，客户端路由有一个恶习，变成服务器HTTP请求。请求可能未配置服务器的路由。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将讨论如何使ASP.NET Core（或间接ASP.NET应用程序）通过有效地将客户端应用程序重新连接到其路由来处理这些“假”请求。&lt;/p&gt;
&lt;p&gt;Html 5客户端路由？&lt;/p&gt;
&lt;p&gt;如果您不知道HTML5客户端路由是什么，请快速回顾一下。&lt;/p&gt;
&lt;p&gt;客户端框架实现他们自己的客户端路由机制，以便他们可以 - 就像服务器应用程序 - 在页面或组件之间进行导航。&lt;/p&gt;
&lt;p&gt;Angular支持几种路由类型：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;哈希路线（http：// localhost：4200 /＃！/ albums或http：// localhost：4200 /＃/ albums）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HTML 5路线（http：// localhost：4200 / albums）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;#!/&lt;/code&gt; 哈希邦德路线&lt;/p&gt;
&lt;p&gt;前者是一种较早的方法，它直接与HTTP语义一起工作，指定任何具有a的URL &lt;code&gt;#&lt;/code&gt;在客户端被触发并跳转到页面内的“本地”URL。框架可以拦截导航并检查跟随的URL内容&lt;code&gt;#&lt;/code&gt;以确定路线。散列爆炸&lt;code&gt;#!&lt;/code&gt;用于区分应用程序URL和普通&lt;code&gt;#&lt;/code&gt;锚链接。&lt;/p&gt;
&lt;p&gt;散列爆炸路线的好处是，他们只是工作。没有服务器端出血的路线，如果您书签或刷新客户端页面，它只是如预期的那样工作，因为散列逻辑是作为浏览器中本地URL解析的一部分执行的。很简单，对吧？它只是工作。&lt;/p&gt;
&lt;p&gt;但缺点是，如果您必须手动输入网址，则这些网址非常难看且不直观。对于散列爆炸路线来说，这并不是一个很好的论据，但是不管它们是否对HTML5路由不利。&lt;/p&gt;
&lt;p&gt;哈希在Angular中的Bang路由&lt;/p&gt;
&lt;p&gt;Angular使用默认的HTML5客户端路由，但它是一个简单的开关来启用Hashbang路由，而不是HTML5路由::&lt;/p&gt;
&lt;pre&gt;
// in app.module.tsproviders : [ .. // make sure you use this for Hash Urls rather than HTML 5 routing { provide: LocationStrategy, useClass: HashLocationStrategy },]
&lt;/pre&gt;
&lt;p&gt;只要您&lt;code&gt;routerLink&lt;/code&gt;在HTML模板中使用链接网址，并&lt;code&gt;router.navigate()&lt;/code&gt;在代码链接中使用，Angular交换机就会自动在两种模式之间进行切换。&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在HTML中使用&lt;code&gt;&amp;lt;a routerLink=&quot;/albums&quot; /&amp;gt;&lt;/code&gt;链接&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在代码中使用： &lt;code&gt;router.navigate([&quot;/album&quot;,album.id])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HTML5路由&lt;/p&gt;
&lt;p&gt;HTML5路由使用更复杂的方法 - 它使用HTML5的Pushstate API来控制客户端的路由并管理地址栏显示。&lt;/p&gt;
&lt;p&gt;这种方法的优点是，使用HTML5 API相对容易操作，并且使用标准的无延伸路由约定，使用Web应用程序和API时，URL更加简洁，易于控制。&lt;/p&gt;
&lt;p&gt;但是HTML5路由需要服务器的明确支持来正确理解哪些路由是服务器路由，哪些是客户路由。&lt;/p&gt;
&lt;p&gt;没有服务器处理的HTML5路由问题&lt;/p&gt;
&lt;p&gt;问题在于HTML5客户端路由与服务器路由无法区分。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:4200/albums&lt;/code&gt;可以很容易地将客户端URL作为服务器端URL。在完全在客户端上导航时，HTML5路线工作正常 - 应用程序可以拦截导航并在激活特定路线时路由到相应的客户端页面。&lt;/p&gt;
&lt;p&gt;如果您使用深层链接导航到客户端驱动的应用程序，然后您将该页面书签为书签，然后使用该URL导航回到该页面，或者刷新当前活动页面，则会弹出问题。在这两种情况下，当浏览器请求路由时，客户端应用程序不运行，因此浏览器向服务器请求路由URL。但是，默认情况下不设置处理说&lt;code&gt;/albums&lt;/code&gt;路线，所以你会得到一个错误。&lt;/p&gt;
&lt;p&gt;如果您在ASP.NET Core应用程序中没有对HTML5路由设置进行任何特殊处理，您将在应用程序中打开错误页面，或者从Kestrel中选择此默认显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/437d0002ec7da9b3befd&quot; alt=&quot;处理ASP.NET Core中的HTML5客户端路由回退&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1 - 未处理的客户端路由产生服务器错误&lt;/p&gt;
&lt;p&gt;修复服务器上的客户端路由&lt;/p&gt;
&lt;p&gt;那么你如何解决这个问题呢？&lt;/p&gt;
&lt;p&gt;客户端SPA应用程序通常有一个或几个启动应用程序的静态页面。对于一个典型的Angular应用程序，该页面是&lt;code&gt;index.html&lt;/code&gt;启动应用程序并启动客户端路由。大多数框架都足够聪明，可以在启动时检查当前路由，并移至首次访问请求的路由。&lt;/p&gt;
&lt;p&gt;如果客户端路由从书签，链接或完全刷新被触发到服务器，则需要提供&lt;code&gt;index.html&lt;/code&gt;并保持原始URL不变。&lt;/p&gt;
&lt;p&gt;然后，客户端应用程序将自行引导，并且内部路由启动，以希望将您甩回书签/刷新位置。&lt;/p&gt;
&lt;p&gt;从服务器提供Index.html&lt;/p&gt;
&lt;p&gt;为了这个工作，你需要确保服务器只提供服务器负责的内容。&lt;/p&gt;
&lt;p&gt;有几种方法可以做到这一点：&lt;/p&gt;
&lt;p&gt;主机Web服务器上的URL重写&lt;/p&gt;
&lt;p&gt;如果您在主流Web服务器上运行ASP.NET Core（或ASP.NET）应用程序，最简单且最有效的解决方案是重写客户端URL并为&lt;code&gt;index.html&lt;/code&gt;给定的URL 提供内容。&lt;/p&gt;
&lt;p&gt;在IIS上，您可以使用IIS重写模块来执行此操作。我最近在一篇博文中更详细地介绍了这一点：&lt;/p&gt;
&lt;p&gt;但是这里是相关的IIS重写规则：&lt;/p&gt;
&lt;pre&gt;
&amp;lt;rewrite&amp;gt; &amp;lt;rules&amp;gt; &amp;lt;!-- Make sure you have a &amp;lt;base href=&quot;/&quot; /&amp;gt; tag to fix the root path or all relative links will break on rewrite --&amp;gt;&amp;lt;rule name=&quot;AngularJS-Html5-Routes&quot; stopProcessing=&quot;true&quot;&amp;gt; &amp;lt;match url=&quot;.*&quot; /&amp;gt; &amp;lt;conditions logicalGrouping=&quot;MatchAll&quot;&amp;gt; &amp;lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot; /&amp;gt; &amp;lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot; /&amp;gt; &amp;lt;add input=&quot;{REQUEST_URI}&quot; pattern=&quot;api/&quot; negate=&quot;true&quot; /&amp;gt; &amp;lt;/conditions&amp;gt; &amp;lt;action type=&quot;Rewrite&quot; url=&quot;wwwroot/index.html&quot; /&amp;gt; &amp;lt;/rule&amp;gt; &amp;lt;/rules&amp;gt;&amp;lt;/rewrite&amp;gt;
&lt;/pre&gt;
&lt;p&gt;您可以从以下任何位置安装UrlRewrite模块：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;Microsoft下载网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;choco install urlrewrite&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web平台安装程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你在Linux上运行Docker和nginX或者Apache，那么类似的Rewrite选项就可以在那里使用。&lt;/p&gt;
&lt;p&gt;让ASP.NET Core处理客户端路由&lt;/p&gt;
&lt;p&gt;如前所述，我通常使用像IIS或nginX这样的前端Web服务器来处理重定向，但是通常在测试或内部应用程序时，只需要Kestrel直接为应用程序提供服务即可。如果您直接让Kestrel处理HTTP流量，那么您需要在ASP.NET Core代码中处理客户端路由。&lt;/p&gt;
&lt;p&gt;捕获所有&lt;code&gt;app.Run()&lt;/code&gt;处理程序&lt;/p&gt;
&lt;p&gt;有很多方法可用，但是我发现了在&lt;code&gt;Startup&lt;/code&gt;类的&lt;code&gt;Configure()&lt;/code&gt;方法中使用一个非常简单的后备处理程序来处理客户端路由的最简单的方法：&lt;/p&gt;
&lt;pre&gt;
// set up whatever routes you use with UseMvc()// you may not need to set up any routes here// if you only use attribute routes!app.UseMvc(routes =&amp;gt;{ routes.MapRoute( name: &quot;default&quot;, template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);});//handle client side routesapp.Run( async (context) =&amp;gt;{ context.Response.ContentType = &quot;text/html&quot;; await context.Response.SendFileAsync(Path.Combine(env.WebRootPath,&quot;index.html&quot;));});
&lt;/pre&gt;
&lt;p&gt;关键是&lt;code&gt;app.Run()&lt;/code&gt;位于路由后的管道末端的中间件处理程序。如果服务器端路由不能找到匹配的路由，这个通用处理程序就会启动。&lt;/p&gt;
&lt;p&gt;上面的代码是你可以做的最简单的事情，只是把内容发送&lt;code&gt;index.html&lt;/code&gt;到客户端。如果您有多个静态页面和SPA筒仓，您可以在其中添加额外的逻辑来尝试确定需要加载哪个页面。&lt;/p&gt;
&lt;p&gt;请注意，内容不会重定向到，而是作为内嵌流发送到现有的URL请求，以便用户请求的URL保持不变。这确保了当用户请求&lt;code&gt;http://localhost:4200/albums&lt;/code&gt;你回到那个客户端页面而不是&lt;code&gt;index.html&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;捕获所有路由处理程序&lt;/p&gt;
&lt;p&gt;另一种方法是在路由定义中使用最后定义的全部捕获的 MVC路由处理程序。这基本上拿起你的MVC路由配置无法处理的任何URL，然后路由到你指定的路线。&lt;/p&gt;
&lt;p&gt;使用catch-all处理程序设置您的MVC路线，将此代码放在您的&lt;code&gt;Startup&lt;/code&gt;类的&lt;code&gt;Configure()&lt;/code&gt;方法中：&lt;/p&gt;
&lt;pre&gt;
app.UseMvc(routes =&amp;gt;{ // default routes plus any other custom routesroutes.MapRoute(name: &quot;default&quot;,template: &quot;{controller=Home}/{action=Index}/{id?}&quot;); // Catch all Route - catches anything not caught be other routesroutes.MapRoute(name: &quot;catch-all&quot;,template: &quot;{*url}&quot;,defaults: new {controller = &quot;AlbumViewerApi&quot;, action = &quot;RedirectIndex&quot;});});
&lt;/pre&gt;
&lt;p&gt;然后执行完全相同的事情中间件处理程序使用：&lt;code&gt;index.html&lt;/code&gt;使用以下代码将内容流式传输到客户端：&lt;/p&gt;
&lt;pre&gt;
// we need hosting environment for base pathpublic IHostingEnvironment HostingEnv { get; }public AlbumViewerApiController(IHostingEnvironment env){ HostingEnv = env;}[HttpGet]public IActionResult RedirectIndex(){ return new PhysicalFileResult( Path.Combine(HostingEnv.WebRootPath,&quot;index.html&quot;), new MediaTypeHeaderValue(&quot;text/html&quot;) );}
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Catch-All Route不使用属性路由&lt;/p&gt;
&lt;p&gt;确保您为回退路线指定的路线不具有分配给它的属性路线。当我昨天检查出来的时候，我无法得到一条全面的路线，直到我&lt;code&gt;[Route(&quot;api/RedirectIndex&quot;)]&lt;/code&gt;从控制器的操作中移除 了这个全部工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SpaServices&lt;/p&gt;
&lt;p&gt;SpaServices提供了另一个选项，&lt;code&gt;routes.MapSpaFallbackRoute()&lt;/code&gt;尽管我自己也没有尝试过，但是如果您已经在ASP.NET Core应用程序中使用了Spa服务，那么这可能是一个简单的方法来实现这个功能，包括潜在的支持服务器预渲染。&lt;/p&gt;
&lt;p&gt;概要&lt;/p&gt;
&lt;p&gt;HTML5路由为客户端应用程序提供了干净的URL，但它的价格必须有服务器支持才能使其工作。使用主机Web服务器中的重写规则或直接在Kestrel的中间件管道或自定义路由处理程序中进行设置并不困难，但是您必须确保将此功能显式添加到您创建的每个ASP.NET应用程序中。&lt;/p&gt;
&lt;p&gt;尽管旧的Hash Bang路线看起来不那么干净，但它们工作正常，不需要任何服务器端支持。对于需要支持古代浏览器的非公众应用程序或应用程序，在没有服务器支持的情况下，散列邦线路仍然是提供路由的可行方式。&lt;/p&gt;
&lt;p&gt;最后，如果您正在使用完整的Web服务器，UrlRewriting是处理非ASP.NET内核后端直接处理的非API内容的最干净和最有效的方式。&lt;/p&gt;
&lt;p&gt;选择是好的，你有几个选择提供方便，干净的网址或简单的只是把它放在功能。你的选择...&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 07:45:00 +0000</pubDate>
<dc:creator>tianfeng.cc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianfengcc/p/7851974.html</dc:identifier>
</item>
<item>
<title>盒子端 CSS 动画性能提升研究 - ChokCoco</title>
<link>http://www.cnblogs.com/coco1s/p/7851658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coco1s/p/7851658.html</guid>
<description>&lt;p&gt;&lt;span&gt;不同于传统的 PC Web 或者是移动 WEB，在腾讯视频客厅盒子端，接大屏显示器（电视）下，许多能流畅运行于 PC 端、移动端的 Web 动画，受限于硬件水平，在盒子端的表现的往往不尽如人意。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于此，对于 Web 动画的性能问题，仅仅停留在感觉已经优化的OK之上，是不够的，想要在盒子端跑出高性能接近 60 FPS 的流畅动画，就必须要刨根问底，深挖每一处可以提升的方法。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;h2-u6D41u7545u52A8u753Bu7684u6807u51C6&quot;&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;理论上说，FPS 越高，动画会越流畅，目前大多数设备的屏幕刷新率为 60 次/秒，所以通常来讲 FPS 为 60frame/s 时动画效果最好，也就是每帧的消耗时间为 16.67ms。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3--&quot;&gt;&lt;span/&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;帧率波动很大的动画，亦会使人感觉到卡顿。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;h2-u76D2u5B50u7AEFu52A8u753Bu4F18u5316&quot;&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在腾讯视频客厅盒子端，Web 动画未进行优化之前，一些复杂动画的帧率仅有 10 ~ 30 FPS，卡顿感非常明显，带来很不好的用户体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而进行优化之后，能将 10 ~ 30 FPS的动画优化至 30 ~ 60 FPS，虽然不算优化到最完美，但是当前盒子硬件的条件下，已经算是非常大的进步。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3--web-&quot;&gt;&lt;span/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先先给出在盒子端不同类型的Web 动画的性能比较。经过对比，在盒子端 CSS 动画的性能要优于 Javascript 动画，而在 CSS 动画里，使用 GPU 硬件加速的动画性能要优于不使用硬件加速的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以在盒子端，实现一个 Web 动画，优先级是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;GPU 硬件加速 CSS 动画 &amp;gt; 非硬件加速 CSS 动画 &amp;gt; Javascript 动画&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2-u52A8u753Bu6027u80FDu4E0Au62A5u5206u6790&quot;&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;要有优化，就必须得有数据做为支撑。对比优化前后是否有提升。而对于动画而言，衡量一个动画的标准也就是 FPS 值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以现在的关键是如何计算出每个动画运行时的帧率，这里我使用的是 &lt;code&gt;requestAnimationFrame&lt;/code&gt;这个函数近似的得到动画运行时的帧率。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;考虑到盒子都是安卓系统，且大多版本较低且硬件性能堪忧，导致一是许多高级 API 无法使用，二是这里只是近似得到动画帧率&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;原理是，正常而言 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 这个方法在一秒内会执行 60 次，也就是不掉帧的情况下。假设动画在时间 A 开始执行，在时间 B 结束，耗时 x ms。而中间 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 一共执行了 n 次，则此段动画的帧率大致为：n / (B - A)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核心代码如下，能近似计算每秒页面帧率，以及我们额外记录一个 &lt;code&gt;allFrameCount&lt;/code&gt;，用于记录 rAF 的执行次数，用于计算每次动画的帧率 ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&lt;span&gt;var rAF = function () {
    return (
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        }
    );
}();

var frame = 0;
var allFrameCount = 0;
var lastTime = Date.now();
var lastFameTime = Date.now();

var loop = function () {
    var now = Date.now();
    var fs = (now - lastFameTime);
    var fps = Math.round(1000 / fs);

    lastFameTime = now;
    // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS
    allFrameCount++;
    frame++;

    if (now &amp;gt; 1000 + lastTime) {
        var fps = Math.round((frame * 1000) / (now - lastTime));
        // console.log('fps', fps); 每秒 FPS
        frame = 0;
        lastTime = now;
    };

    rAF(loop);
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2-u7814u7A76u7ED3u8BBA&quot;&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;所以，我们的目标就是在使用 GPU 硬件加速的基础之上，更深入的去优化 CSS 动画，先给出最后的一个优化步骤方案：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;精简 DOM ，合理布局&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 transform 代替 left、top，减少使用耗性能样式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;控制频繁动画的层级关系&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;考虑使用 will-change&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 dev-tool 时间线 timeline 观察，找出导致高耗时、掉帧的关键操作&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下文会有每一步骤的具体分析解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2-web-&quot;&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;要想达到 60 FPS，每帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.67 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要尽量在 10 毫秒内完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而每一帧，如果有必要，我们能控制的部分，也是像素至屏幕管道中的关键步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/608782/201711/608782-20171117152954062-395278860.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;完整的像素管道 JS / CSS &amp;gt; 样式 &amp;gt; 布局 &amp;gt; 绘制 &amp;gt; 合成：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;样式计算。此过程是根据匹配选择器（例如 .headline 或 .nav &amp;gt; .nav__item）计算出哪些元素应用哪些 CSS 3. 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 &amp;lt;body&amp;gt; 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;当然，不一定每帧都总是会经过管道每个部分的处理。我们的目标就是，每一帧的动画，对于上述的管道流程，能避免则避免，不能避免则最大限度优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2-u4F18u5316u52A8u753Bu6B65u9AA4&quot;&gt;&lt;span/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;先给出一个步骤，调优一个动画，有一定的指导原则可以遵循，一步一步深入动画:&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3-1-dom-&quot;&gt;&lt;span/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个没什么好说的，如果可以，精简 DOM 结构在任何时候都是对页面有帮助的。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3-2-transform-left-top-&quot;&gt;&lt;span/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;现代浏览器在完成以下四种属性的动画时，消耗成本较低：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;position（位置）: &lt;code&gt;transform: translate(npx, npx)&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;scale（比例缩放）：&lt;code&gt;transform: scale(n)&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;rotation（旋转） ：&lt;code&gt;transform: rotate(ndeg)&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;opacity（透明度）：&lt;code&gt;opacity： 0...1&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果可以，尽量只使用上述四种属性去控制动画。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同样式在消耗性能方面是不同的，改变一些属性的开销比改变其他属性要多，因此更可能使动画卡顿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，与改变元素的文本颜色相比，改变元素的 &lt;code&gt;box-shadow&lt;/code&gt; 将需要开销大很多的绘图操作。 改变元素的 &lt;code&gt;width&lt;/code&gt; 可能比改变其 &lt;code&gt;transform&lt;/code&gt; 要多一些开销。如 &lt;code&gt;box-shadow&lt;/code&gt; 属性，从渲染角度来讲十分耗性能，原因就是与其他样式相比，它们的绘制代码执行时间过长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是说，如果一个耗性能严重的样式经常需要重绘，那么你就会遇到性能问题。其次你要知道，没有不变的事情，在今天性能很差的样式，可能明天就被优化，并且浏览器之间也存在差异。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;h4--gpu-&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;归根结底，上述四种属性的动画消耗较低的原因是会开启了 GPU 硬件加速。动画元素生成了自己的图形层（GraphicsLayer）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常而言，开启 GPU 加速的方法我们可以使用&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;will-change: transform&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这会使声明了该样式属性的元素生成一个图形层，告诉浏览器接下来该元素将会进行 transform 变换，让浏览器提前做好准备。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;使用 &lt;code&gt;will-change&lt;/code&gt; 并不一定会有性能的提升，因为即使浏览器预料到会有这些更改，依然会为这些属性运行布局和绘制流程，所以提前告诉浏览器，也并不会有太多性能上的提升。这样做的好处是，创建新的图层代价很高，而等到需要时匆忙地创建，不如一开始直接创建好。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;对于 Safari 及一些旧版本浏览器，它们不能识别 &lt;code&gt;will-change&lt;/code&gt;，则需要使用某种 translate 3D 进行 hack，通常会使用&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;transform: translateZ(0)&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;所以，正常而言，在生产环境下，我们可能需要使用如下代码，开启硬件加速：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&lt;span&gt;{
    will-change: transform;
    transform: translateZ(0);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;h3-3-&quot;&gt;&lt;span/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;动画层级的控制的意思是尽量让需要进行 CSS 动画的元素的 &lt;code&gt;z-index&lt;/code&gt; 保持在页面最上方，避免浏览器创建不必要的图形层（GraphicsLayer），能够很好的提升渲染性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK，这里又提到了图形层（GraphicsLayer），这是一个浏览器渲染原理相关的知识（WebKit/blink内核下）。它能对动画进行加速，但同时也存在相应的加速坑！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/608782/201711/608782-20171117153017843-532632462.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单来说，浏览器为了提升动画的性能，为了在动画的每一帧的过程中不必每次都重新绘制整个页面。在特定方式下可以触发生成一个合成层，合成层拥有单独的 GraphicsLayer。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要进行动画的元素包含在这个合成层之下，这样动画的每一帧只需要去重新绘制这个 Graphics Layer 即可，从而达到提升动画性能的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么一个元素什么时候会触发创建一个 Graphics Layer 层？从目前来说，满足以下任意情况便会创建层：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;硬件加速的插件，比如 flash 等等&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用加速视频解码的 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 元素&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3D 或者 硬件加速的 2D Canvas 元素&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3D 或透视变换 (perspective、transform) 的 CSS 属性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对自己的 opacity 做 CSS 动画或使用一个动画变换的元素&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;拥有加速 CSS 过滤器的元素&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;元素有一个 z-index 较低且包含一个复合层的兄弟元素&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;本小点中说到的动画层级的控制，原因就在于上面生成层的最后一条：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;元素有一个 z-index 较低且包含一个复合层的兄弟元素。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这里是存在坑的地方，首先我们要明确两点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;我们希望我们的动画得到 GPU 硬件加速，所以我们会利用类似 &lt;code&gt;transform: translateZ()&lt;/code&gt;这样的方式生成一个 Graphics Layer 层。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Graphics Layer 虽好，但不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的 Graphics Layer ，并计算他们下一帧的重绘区域，所以过量的 Graphics Layer 计算也会给渲染造成性能影响。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;记住这两点之后，回到上面我们说的坑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们有一个轮播图，有一个 ul 列表，结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;
&amp;lt;div class=&quot;swiper&quot;&amp;gt;轮播图&amp;lt;/div&amp;gt;
&amp;lt;ul class=&quot;list&quot;&amp;gt;
&amp;lt;li&amp;gt;列表li&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;列表li&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;列表li&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;列表li&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设给他们定义如下 CSS：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&lt;span&gt;.swiper {
    position: static;
    animation: 10s move infinite;
}

.list {
    position: relative;
}

@keyframes move {
    100% {
        transform: translate3d(10px, 0, 0);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于给 &lt;code&gt;.swiper&lt;/code&gt; 添加了 &lt;code&gt;translate3d(10px, 0, 0)&lt;/code&gt; 动画，所以它会生成一个 Graphics Layer，如下图所示，用开发者工具可以打开层的展示，图形外的黄色边框即代表生成了一个独立的复合层，拥有独立的 Graphics Layer 。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/608782/201711/608782-20171117153026702-1758268698.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是！在上面的图中，我们并没有给下面的 &lt;code&gt;list&lt;/code&gt; 也添加任何能触发生成 Graphics Layer 的属性，但是它也同样也有黄色的边框，生成了一个独立的复合层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因在于上面那条元素有一个 z-index 较低且包含一个复合层的兄弟元素。我们并不希望 &lt;code&gt;list&lt;/code&gt; 元素也生成 Graphics Layer ，但是由于 CSS 层级定义原因，下面的 list 的层级高于上面的 swiper，所以它被动的也生成了一个 Graphics Layer 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 Chrome，我们也可以观察到这种层级关系，可以看到 &lt;code&gt;.list&lt;/code&gt; 的层级高于 &lt;code&gt;.swiper&lt;/code&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/608782/201711/608782-20171117153034546-577395704.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，下面我们修改一下 CSS ，改成：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&lt;span&gt;.swiper {
    position: relative;
    z-index: 100;
}

.list {
    position: relative;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里，我们明确使得 &lt;code&gt;.swiper&lt;/code&gt; 的层级高于 &lt;code&gt;.list&lt;/code&gt; ，再打开开发者工具观察一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/608782/201711/608782-20171117153041202-2103669409.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，这一次，&lt;code&gt;.list&lt;/code&gt; 元素已经没有了黄色外边框，说明此时没有生成 Graphics Layer 。再看看层级图：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/608782/201711/608782-20171117153046734-1682209139.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时，层级关系才是我们希望看到的，&lt;code&gt;.list&lt;/code&gt; 元素没有触发生成 Graphics Layer 。而我们希望需要硬件加速的 &lt;code&gt;.swiper&lt;/code&gt; 保持在最上方，每次动画过程中只会独立重绘这部分的区域。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;h4-u603Bu7ED3&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这个坑最早见于张云龙发布的这篇文章&lt;a href=&quot;https://div.io/topic/1348&quot; target=&quot;_blank&quot;&gt;CSS3硬件加速也有坑&lt;/a&gt;，这里还要总结补充的是：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;GPU 硬件加速也会有坑，当我们希望使用利用类似 &lt;code&gt;transform: translate3d()&lt;/code&gt; 这样的方式开启 GPU 硬件加速，一定要注意元素层级的关系，尽量保持让需要进行 CSS 动画的元素的 &lt;code&gt;z-index&lt;/code&gt; 保持在页面最上方。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Graphics Layer 不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的 Graphics Layer ，并计算他们下一帧的重绘区域，所以过量的 Graphics Layer 计算也会给渲染造成性能影响。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;可以使用 Chrome ，用上面介绍的两个工具对自己的页面生成的 Graphics Layer 和元素层级进行观察然后进行相应修改。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;上面观察页面层级的 chrome 工具非常吃内存？好像还是一个处于实验室的功能，分析稍微大一点的页面容易直接卡死，所以要多学会使用第一种观察黄色边框的方式查看页面生成的 Graphics Layer 这种方式。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h3-4-will-change-&quot;&gt;&lt;span/&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&lt;span&gt;// 示例
.example {
    will-change: transform;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面已经提到过 will-change 了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值得注意的是，用好这个属性并不是很容易：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;在一些低端盒子上，&lt;code&gt;will-change&lt;/code&gt; 会导致很多小问题，譬如会使图片模糊，有的时候很容易适得其反，所以使用的时候还需要多加测试。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;有节制地使用：通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致生成大量图层，进而导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程，这会导致更严重的性能问题。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h3-5-dev-tool-timeline-&quot;&gt;&lt;span/&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h4-1-&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;h4 id=&quot;h4-2-&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;h4 id=&quot;h4-3-&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;对于 timeline 的使用用法，这里有个非常好的教程，通俗易懂，可以看看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://classroom.udacity.com/courses/ud860/lessons/4146058564/concepts/41439886350923&quot; target=&quot;_blank&quot;&gt;浏览器渲染优化 Udacity 课程&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;总结一下&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于盒子端 CSS 动画的性能，很多方面仍处于探索中，本文大量内容在之前文章已经出现过，这里更多的是归纳总结提炼成可参照执行的流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文的优化方案研究同样适用于 PC Web 及移动 Web，文章难免有错误及疏漏，欢迎不吝赐教。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 07:36:00 +0000</pubDate>
<dc:creator>ChokCoco</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coco1s/p/7851658.html</dc:identifier>
</item>
<item>
<title>JavaScript:在JS中截取字符串的方法 - 起帅帅</title>
<link>http://www.cnblogs.com/qishuaishuai/p/7833687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qishuaishuai/p/7833687.html</guid>
<description>&lt;p&gt;　　这篇主要说一说截取字符串的方法，用于帮助自己缕清方法的作用，参数的意义，返回值，是否对于原来的字符串进行了操作等。&lt;/p&gt;
&lt;p&gt;　　在javascript中，常见的截取字符串的方法有slice()、substring()、substr()这三种方法，我主要为了捋清楚这三种方法的相同点与不同点，在什么情况下适用于哪一种。优雅的代码都是从一点一滴开始的。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;slice()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　首先，我在百度上面搜索了一下slice()方法，给出的链接是Javascript Array对象的 slice()方法，是对数组的操作。作用是从已有的数组中返回选定的元素，返回值是一个数组，并且不会对原先的数组产生影响。&lt;/p&gt;
&lt;p&gt;　　　　然后我有上了W3schoole查找slice()方法，找到了Javascript String 对象的slice()方法。用于提取字符串的片段，并在新的字符串中返回被提取的部分。返回值是一个字符串，并且不会对原先的字符串产生影响。&lt;/p&gt;
&lt;p&gt;　　　　虽然作用对像不一样，但是我个人觉得是一个东西。都是从原先对象里面截取出来新的东西，并且不对原先的对象有操作，返回值是根据原先的对象的类型来决定的。&lt;/p&gt;
&lt;p&gt;　　　　slice()有两个参数，第一个参数可以为需要截取的起始点，第二个参数可以为截取结束的点。如果第二个参数不传输的画，默认情况下会截取到当前对象的最后。&lt;/p&gt;
&lt;p&gt;　　　　代码示例：　&lt;/p&gt;
&lt;p&gt;　　　　　　JavaScript Array　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            var zhanShi = [&quot;冲锋&quot;,&quot;断筋&quot;,&quot;巨人打击&quot;,&quot;压制&quot;,&quot;斩杀&quot;&lt;span&gt;];
            console.log(zhanShi);
            console.log(zhanShi.slice(1,2&lt;span&gt;));
            console.log(zhanShi.slice(1&lt;span&gt;));
        &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　下面是这段代码在谷歌浏览器上面显示的结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1117601/201711/1117601-20171117135039062-2047518936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　JavaScript  String&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            var wuqiZhan = &quot;我叫武器战，打架开电扇。CD一分半，转完就完蛋。&quot;&lt;span&gt;;
            console.log(wuqiZhan);
            console.log(wuqiZhan.slice(2,5&lt;span&gt;));
            console.log(wuqiZhan.slice(6&lt;span&gt;));
        &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　下面是这段代码在谷歌浏览器上面显示的结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1117601/201711/1117601-20171117140456249-814353097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　当然，我们现在传输的都是正数，我闲的无聊，然后我就给传了负数当作参数：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            &lt;span&gt;var&lt;/span&gt; str = &quot;所以说很无奈&quot;&lt;span&gt;;
            console.log(str.slice(&lt;/span&gt;-3&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [&quot;你看&quot;,&quot;传了&quot;,&quot;负数&quot;&lt;span&gt;];
            console.log(arr.slice(&lt;/span&gt;-2&lt;span&gt;));
        &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1117601/201711/1117601-20171117144216843-1891360896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;substring()&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;　　　　substring()是用于提取字符串中介于两个指定下标之间的字符，两个参数，其中第一个参数是必须的，第二个参数是可选的。如果不传第二个参数，默认情况下会提取到最后。返回值是一个新的字符串。准确的说，返回的额字符串包含了第一个参数位置的字符串，而不包含第二个参数位置的元素。&lt;/p&gt;
&lt;p&gt;　　　　上代码，其他都是空谈，看了代码就明白了：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            &lt;span&gt;var&lt;/span&gt; bingFa = &quot;寒冰箭呀biubiubiu，五个冰刺一发脑残箭&quot;&lt;span&gt;;
            console.log(bingFa.substring(&lt;/span&gt;4,13&lt;span&gt;));
        &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1117601/201711/1117601-20171117150034156-177993994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　slice可以传负数，substring可不可以呢？不可以！明确的告诉你不可义，但是却不会报错，只会把整个字符串都输出出来。可是，如果你给前面的参数传输的比较大，后面的参数比较小，那样会出现什么情况呢？&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            &lt;span&gt;var&lt;/span&gt; bingFa = &quot;寒冰箭呀biubiubiu，五个冰刺一发脑残箭&quot;&lt;span&gt;;
            console.log(bingFa.substring(&lt;/span&gt;13,4&lt;span&gt;));
        &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1117601/201711/1117601-20171117150430937-604258416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看的出来，即使你把前面的参数传输的比后面的参数大，但是substring会自动的调整两个参数的位置，也就是大的参数总是在后面。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　　substr()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;substr()用于在字符串中从第一个参数位置起，截取到第二个指定的参数。其中第一个参数是必须的，第二个参数是可选的。如果不传输第二个参数的话，默认会截取到字符串最后。返回值是一个新的字符串，这个方法同样不会对原先的字符串进行修改。这个方法并没有被标准话，所以说，使用与否看个人吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　代码：&lt;/span&gt;&lt;span&gt;　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            &lt;span&gt;var&lt;/span&gt; shuShi = &quot;一发脑残箭，天人相隔永不见&quot;&lt;span&gt;;
            console.log(shuShi.substr(&lt;/span&gt;2,3&lt;span&gt;));
            console.log(shuShi.substr(&lt;/span&gt;-3,3&lt;span&gt;));    
        &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1117601/201711/1117601-20171117152829577-1256387655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码包含的第一个参数为负值的情况。&lt;/p&gt;
&lt;p&gt;也许我的这些东西你看着很浅显，但这就像一砖一瓦，慢慢来嘛。我已经尽力写的很详细了，希望对你会有帮助。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 Nov 2017 07:31:00 +0000</pubDate>
<dc:creator>起帅帅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qishuaishuai/p/7833687.html</dc:identifier>
</item>
<item>
<title>Espresso浅析和使用 - 腾讯云技术社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/7851858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/7851858.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//cloud.tencent.com/community&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;腾讯云社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1510886666303_8428_1510886580252.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Espresso是一个Google官方提供的Android应用UI自动化测试框架。Google希望，当Android的开发者利用Espresso写完测试用例后，能一边看着测试用例自动执行，一边享受一杯香醇Espresso(浓咖啡)。&lt;br/&gt;Espress有3个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个收录在Android Testing Supporting Library底下的测试框架&lt;/li&gt;
&lt;li&gt;模拟用户的操作&lt;/li&gt;
&lt;li&gt;自动等待，直到UI线程Idle，才会执行测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，将从配置、写用例、运行一步步介绍Espresso的使用。&lt;/p&gt;
&lt;h2 id=&quot;0-&quot;&gt;0. 项目配置&lt;/h2&gt;
&lt;h3 id=&quot;0-1-app-build-gradle-&quot;&gt;0.1 修改App的&lt;code&gt;build.gradle&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在defaultConfig内增加，testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”，用来运行脚本&lt;/li&gt;
&lt;li&gt;增加packagingOptions，避免编译时候License的冲突&lt;/li&gt;
&lt;li&gt;在dependencies中增加相关的引用（androidTestCompile只有在编译测试用例时候才会运行，普通编译不会）&lt;br/&gt;下面是&lt;code&gt;build.gradle&lt;/code&gt;中涉及到Espresso配置的内容&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;android {
    defaultConfig {
        testInstrumentationRunner &lt;span class=&quot;hljs-string&quot;&gt;&quot;android.support.test.runner.AndroidJUnitRunner&quot;
       }
    }
    packagingOptions {
        exclude &lt;span class=&quot;hljs-string&quot;&gt;'LICENSE.txt'
    }
}
dependencies {
    &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0-2-testrunner&quot;&gt;0.2 添加TestRunner&lt;/h2&gt;
&lt;p&gt;点击顶栏菜单Run-&amp;gt;Edit Configurations，出现如下的窗口后,点击左上角的”+”,选择”Android Tests”；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/3898fa70913f067be60b72af63444842/image.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改新Configuration的名字，选中App Module，输入Runner，选择”Show chooer dialog”，点击”OK”完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/42e400bcdce76f754c45f6fcac1f79af/image.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-&quot;&gt;1. 写测试用例&lt;/h2&gt;
&lt;h3 id=&quot;1-1-&quot;&gt;1.1 三步曲&lt;/h3&gt;
&lt;p&gt;写UI自动化测试用例，归结起来就是3步：&lt;/p&gt;
&lt;p&gt;定位View控件&lt;br/&gt;操作View控件&lt;br/&gt;校验View控件的状态&lt;br/&gt;对应Espresso，就是以下3个方法的调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;onView(&lt;span class=&quot;hljs-selector-tag&quot;&gt;ViewMatcher)
  &lt;span class=&quot;hljs-selector-class&quot;&gt;.perform(&lt;span class=&quot;hljs-selector-tag&quot;&gt;ViewAction)
  &lt;span class=&quot;hljs-selector-class&quot;&gt;.check(&lt;span class=&quot;hljs-selector-tag&quot;&gt;ViewAssertion);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，onView是用来定位View控件的，perform是操作控件的，check是校验View控件的状态。他们各自都需要再传入对应的参数分别如下：&lt;/p&gt;
&lt;p&gt;ViewMatcher，有withId、withText、withClassName等等方法来定位View控件&lt;br/&gt;ViewAction，有click()、longClick()、pressBack()、swipeLeft()等等方法来操作View控件&lt;br/&gt;ViewAssertion，有isEnabled()、isLeftOf()、isChecked()等等方法来校验View控件状态&lt;br/&gt;这里有&lt;code&gt;ViewMatcher&lt;/code&gt;、&lt;code&gt;ViewAction&lt;/code&gt;、&lt;code&gt;ViewAssertion&lt;/code&gt;的Cheat Sheet。&lt;/p&gt;
&lt;h3 id=&quot;1-2-&quot;&gt;1.2 完整测试用例代码&lt;/h3&gt;
&lt;p&gt;这是一个非常简单的测试用例，通过R.id.button定位控件，对它调用了一下click，最后校验控件是不是enabled状态。这里面有一些注解，&lt;code&gt;@Rule&lt;/code&gt;修饰的是被测试的&lt;code&gt;Activity&lt;/code&gt;，&lt;code&gt;@Test&lt;/code&gt;修饰的方法是测试用例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@&lt;span class=&quot;hljs-keyword&quot;&gt;RunWith(&lt;span class=&quot;hljs-keyword&quot;&gt;AndroidJUnit4.&lt;span class=&quot;hljs-keyword&quot;&gt;class)&lt;span class=&quot;hljs-keyword&quot;&gt;public class MainActivityTest {    @&lt;span class=&quot;hljs-keyword&quot;&gt;Rule
    public ActivityTestRule mActivityRule = new ActivityTestRule(MainActivity.class);    @&lt;span class=&quot;hljs-keyword&quot;&gt;Test
    public void testTextViewDisplay() {
        &lt;span class=&quot;hljs-selector-tag&quot;&gt;onView(&lt;span class=&quot;hljs-selector-tag&quot;&gt;withId(&lt;span class=&quot;hljs-selector-tag&quot;&gt;R&lt;span class=&quot;hljs-selector-class&quot;&gt;.id&lt;span class=&quot;hljs-selector-class&quot;&gt;.button))
            &lt;span class=&quot;hljs-selector-class&quot;&gt;.perform(&lt;span class=&quot;hljs-selector-tag&quot;&gt;click())
            &lt;span class=&quot;hljs-selector-class&quot;&gt;.check(&lt;span class=&quot;hljs-selector-tag&quot;&gt;matches(&lt;span class=&quot;hljs-selector-tag&quot;&gt;isEnabled()));
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1-3-&quot;&gt;1.3 注意&lt;/h3&gt;
&lt;p&gt;Getting Started With Espresso 2.0这个视频中提到了2个写测试用例时的注意项：&lt;/p&gt;
&lt;p&gt;避免&lt;code&gt;Activity&lt;/code&gt;的层级跳转，测试用例尽量只在单个&lt;code&gt;Activity&lt;/code&gt;内完成。&lt;code&gt;Activity&lt;/code&gt;层级跳转越多，越容易出错&lt;br/&gt;强烈不推荐，直接获取&lt;code&gt;View&lt;/code&gt;的对象，调用&lt;code&gt;View&lt;/code&gt;的方法来模拟用户操作。应该统一使用Espresso提供的方法&lt;br/&gt;测试用例，特别是UI自动化测试用例，应该尽量保持逻辑简单，覆盖关键路径就足矣。因为UI变动是很频繁的，越复杂，维护成本就越高，投入产出比就会自然降低了。&lt;/p&gt;
&lt;h2 id=&quot;2-&quot;&gt;2. 运行用例&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在运行菜单中选择步骤0.2中设置的&lt;code&gt;TestRunner&lt;/code&gt;，点击执行&lt;/li&gt;
&lt;li&gt;测试用例模拟用户操作自动运行&lt;/li&gt;
&lt;li&gt;测试用例执行完成，在Android Studio的控制台上，能看到如下的结果输出&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/418cf272519121f83b4e53c797a24fc4/image.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，看到”Done 3 of 3”标识，一共3个检查点，都检查通过了。如果有检查不通过的话，右上角的绿色能量条会变成红色。&lt;/p&gt;
&lt;h2 id=&quot;3-&quot;&gt;3. 进阶&lt;/h2&gt;
&lt;h3 id=&quot;3-1-ondata-&quot;&gt;3.1 onData的使用&lt;/h3&gt;
&lt;p&gt;对于&lt;code&gt;ListView&lt;/code&gt;，如果要操作其中的某一个item，特别是不可见状态的item，是不能通过上述的&lt;code&gt;ViewMatch&lt;/code&gt;来定位的。我们都知道&lt;code&gt;ListView&lt;/code&gt;的&lt;code&gt;View&lt;/code&gt;是复用的，不可见状态的item并没有把内容绘制到&lt;code&gt;View&lt;/code&gt;上。Espresso针对&lt;code&gt;AdapterView&lt;/code&gt;（&lt;code&gt;ListView&lt;/code&gt;的父类），提供了&lt;code&gt;onData&lt;/code&gt;来支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;onData(&lt;span class=&quot;hljs-selector-tag&quot;&gt;ObjectMatcher)
  &lt;span class=&quot;hljs-selector-class&quot;&gt;.DataOptions
  &lt;span class=&quot;hljs-selector-class&quot;&gt;.perform(&lt;span class=&quot;hljs-selector-tag&quot;&gt;ViewAction)
  &lt;span class=&quot;hljs-selector-class&quot;&gt;.check(&lt;span class=&quot;hljs-selector-tag&quot;&gt;ViewAssertion);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;onData&lt;/code&gt;传入的是一个&lt;code&gt;ObjectMather&lt;/code&gt;。首先假设ListView的Adapter中的Item的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Item {
    &lt;span class=&quot;hljs-keyword&quot;&gt;private final &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-keyword&quot;&gt;value;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Item(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-keyword&quot;&gt;value) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.&lt;span class=&quot;hljs-keyword&quot;&gt;value = &lt;span class=&quot;hljs-keyword&quot;&gt;value;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;toString(&lt;span class=&quot;hljs-params&quot;&gt;) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return String.valueOf(&lt;span class=&quot;hljs-keyword&quot;&gt;value);
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面定义一个&lt;code&gt;withValue()&lt;/code&gt;的方法，返回一个&lt;code&gt;BoundedMatcher&lt;/code&gt;。而其中的&lt;code&gt;matchesSafely()&lt;/code&gt;方法是用来判断match与否的，判断的逻辑实现都放在这里。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

&lt;span class=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static Matcher&amp;lt;Object&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;withValue(&lt;span class=&quot;hljs-params&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-keyword&quot;&gt;value) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;new BoundedMatcher&amp;lt;Object,
            MainActivity.Item&amp;gt;(MainActivity.Item.class) {
        @&lt;span class=&quot;hljs-function&quot;&gt;Override &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;describeTo(&lt;span class=&quot;hljs-params&quot;&gt;Description description) {
            description.appendText(&lt;span class=&quot;hljs-string&quot;&gt;&quot;has value &quot; + &lt;span class=&quot;hljs-keyword&quot;&gt;value);
        }
        @&lt;span class=&quot;hljs-function&quot;&gt;Override &lt;span class=&quot;hljs-keyword&quot;&gt;public boolean &lt;span class=&quot;hljs-title&quot;&gt;matchesSafely(&lt;span class=&quot;hljs-params&quot;&gt;
                MainActivity.Item item) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return item.toString().&lt;span class=&quot;hljs-keyword&quot;&gt;equals(String.valueOf(&lt;span class=&quot;hljs-keyword&quot;&gt;value));
        }
    };
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了上面的铺垫，测试用例写起来就水到渠成了。在id是&lt;code&gt;R.id.list&lt;/code&gt;的&lt;code&gt;AdapterView&lt;/code&gt;中找到数据项是&lt;code&gt;27&lt;/code&gt;，然后执行&lt;code&gt;click()&lt;/code&gt;操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;clickItem&lt;span class=&quot;hljs-params&quot;&gt;() {
    onData(withValue(&lt;span class=&quot;hljs-number&quot;&gt;27))
            .inAdapterView(withId(R.id.&lt;span class=&quot;hljs-built_in&quot;&gt;list))
            .perform(click());
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后需要注意的是，&lt;code&gt;onData()&lt;/code&gt;并不适用于&lt;code&gt;RecyclerView&lt;/code&gt;，因为它不是继承自&lt;code&gt;AdapterView&lt;/code&gt;。Espresso提供专门给&lt;code&gt;RecyclerView&lt;/code&gt;使用的&lt;code&gt;RecyclerViewActions&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@&lt;span class=&quot;hljs-keyword&quot;&gt;Test 
public void clickItem() {
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;onView(&lt;span class=&quot;hljs-selector-tag&quot;&gt;withId(&lt;span class=&quot;hljs-selector-tag&quot;&gt;R&lt;span class=&quot;hljs-selector-class&quot;&gt;.id&lt;span class=&quot;hljs-selector-class&quot;&gt;.recycler_view))
            &lt;span class=&quot;hljs-selector-class&quot;&gt;.perform(
                    &lt;span class=&quot;hljs-selector-tag&quot;&gt;RecyclerViewActions&lt;span class=&quot;hljs-selector-class&quot;&gt;.actionOnItemAtPosition(27, &lt;span class=&quot;hljs-selector-tag&quot;&gt;click()));
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-2-idling-resource-&quot;&gt;3.2 Idling Resource的使用&lt;/h3&gt;
&lt;p&gt;应用开发中很常见的一个场景是，点击某个按钮，发起网络请求，等请求回来后解析数据，更新界面。Espresso针对这种测试场景，提供了原生的支持。&lt;br/&gt;假设被测Activity初始化后有一个耗时的数据加载过程，activity.isSyncFinished()方法判断数据加载是否已经完成。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;(Bundle savedInstanceState) {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况，Espresso提供了&lt;code&gt;IdlingResource&lt;/code&gt;来保证数据加载完成了才开始执行测试用例代码。首先，需实现&lt;code&gt;IdlingResource&lt;/code&gt;接口：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getName()方法返回的String是作为注册回调的Key，所以要确保唯一性&lt;/li&gt;
&lt;li&gt;registerIdleTransitionCallback()的参数ResourceCallback会用做isIdleNow()时候的回调&lt;/li&gt;
&lt;li&gt;isIdleNow()是否已经处于空闲状态，这里调用activity.isSyncFinished()方法来判断数据加载是否完成&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyIdlingResource &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;IdlingResource {
    &lt;span class=&quot;hljs-keyword&quot;&gt;private ResourceCallback mCallback = &lt;span class=&quot;hljs-keyword&quot;&gt;null;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private MainActivity mActivity;

    MyIdlingResource(MainActivity activity) {
        mActivity = activity;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getName&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyIdlingResource&quot;;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;registerIdleTransitionCallback&lt;span class=&quot;hljs-params&quot;&gt;(ResourceCallback callback) {
        mCallback = callback;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;isIdleNow&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;boolean isIdle = mActivity != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; mActivity.isSyncFinished();
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (isIdle &amp;amp;&amp;amp; mCallback != &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            mCallback.onTransitionToIdle();
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return isIdle;
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MyIdlingResource&lt;/code&gt;需要在恰当的时机注册和反注册。&lt;code&gt;@Before&lt;/code&gt;和&lt;code&gt;@After&lt;/code&gt;是依照JUnit4的惯例，分别在用例执行之前和之后去注册和反注册。那么，如下测试用例执行的过程是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;测试用例启动，注册MyIdlingResource&lt;/li&gt;
&lt;li&gt;启动被测Activity&lt;/li&gt;
&lt;li&gt;Activity初始化，启动数据加载过程&lt;/li&gt;
&lt;li&gt;Activity数据加载完成，执行测试用例方法testTextViewDisplay()&lt;/li&gt;
&lt;li&gt;测试用例结束，反注册MyIdlingResource&lt;br/&gt;可见，IdlingResource能够保证流转到Idle状态，才会执行测试代码：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;testTextViewDisplay&lt;span class=&quot;hljs-params&quot;&gt;() {
    onView(withText(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Show SnackBar&quot;)).check(ViewAssertions.matches(isDisplayed()));
}

&lt;span class=&quot;hljs-meta&quot;&gt;@Before
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;registerIntentServiceIdlingResource&lt;span class=&quot;hljs-params&quot;&gt;() {
    Activity activity = mActivityRule.getActivity();
    idlingResource = &lt;span class=&quot;hljs-keyword&quot;&gt;new MyIdlingResource((MainActivity) activity);
    Espresso.registerIdlingResources(idlingResource);
}

&lt;span class=&quot;hljs-meta&quot;&gt;@After
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;unregisterIntentServiceIdlingResource&lt;span class=&quot;hljs-params&quot;&gt;() {
    Espresso.unregisterIdlingResources(idlingResource);
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-3-&quot;&gt;3.3. 执行原理&lt;/h3&gt;
&lt;p&gt;本文开头提到Espresso其中一个特点，无需主动写Sleep等待UI事件的执行和UI的绘制。原因是，Espresso的用例运行过程是只有当UI线程IDLE和UI队列没有需要执行的事件时，Espresso的测试代码才会被执行。使用方无需写Sleep逻辑等待UI绘制完成。以下是Espresso测试用例执行简易的流程图，帮助理解：&lt;br/&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/796261c08b48d8b88fbb3861eec29a5a/image.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;引用官方介绍的一段话，Espresso的目标受众是开发者。希望更多的团队能够实现Google的期许最大化利用Espresso，把Bug扼杀在摇篮中。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Target Audience&lt;br/&gt;Espresso is targeted at developers, who believe that automated testing is an integral part of the development lifecycle. While it can be used for black-box testing, Espresso’s full power is unlocked by those who are familiar with the codebase under test.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-&quot;&gt;引用&lt;/h2&gt;
&lt;p&gt;Getting Started With Espresso 2.0：&lt;a href=&quot;https://www.youtube.com/watch?v=TGU0B4qRlHY&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=TGU0B4qRlHY&lt;/a&gt;&lt;br/&gt;Advanced Android Espresso：&lt;a href=&quot;https://realm.io/news/chiu-ki-chan-advanced-android-espresso-testing/&quot; target=&quot;_blank&quot;&gt;https://realm.io/news/chiu-ki-chan-advanced-android-espresso-testing/&lt;/a&gt;&lt;br/&gt;Android Espresso 测试框架探究：&lt;a href=&quot;http://blog.csdn.net/weijianfeng1990912/article/details/51540468&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/weijianfeng1990912/article/details/51540468&lt;/a&gt;&lt;br/&gt;Android自动化测试-AdapterView的测试：&lt;a href=&quot;https://segmentfault.com/a/1190000004392396&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000004392396&lt;/a&gt;&lt;br/&gt;Android单元测试研究与实践：&lt;a href=&quot;http://tech.meituan.com/Android_unit_test.html&quot; target=&quot;_blank&quot;&gt;http://tech.meituan.com/Android_unit_test.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文章来自： QQ音乐技术团队 公众号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/992585?utm_source=bky&quot; target=&quot;_blank&quot;&gt;网页加速特技之 AMP&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/846600?utm_source=bky&quot; target=&quot;_blank&quot;&gt;表格行与列边框样式处理的原理分析及实战应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//cloud.tencent.com/community/article/727528?utm_source=bky&quot; target=&quot;_blank&quot;&gt;「腾讯云游戏开发者技术沙龙」11月24 日深圳站报名开启 畅谈游戏加速&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此文已由作者授权腾讯云技术社区发布，转载请注明&lt;a class=&quot; wrap external&quot; href=&quot;https://cloud.tencent.com/community/article/520289?utm_source=bky&quot; target=&quot;_blank&quot;&gt;原文出处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文链接：https://cloud.tencent.com/community/article/520289?utm_source=bky&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//cloud.tencent.com/community&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;腾讯云社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 07:31:00 +0000</pubDate>
<dc:creator>腾讯云技术社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/7851858.html</dc:identifier>
</item>
<item>
<title>掌握numpy(一) - Wanna_Go</title>
<link>http://www.cnblogs.com/wxshi/p/7851701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxshi/p/7851701.html</guid>
<description>[unable to retrieve full-text content]`NumPy 备忘录`供以后查阅。 创建数组 首先我们要先引入numpy，常用的引入方法为 np.zeros 该方法能够创建一个全为0的数组 上面是创建一个1维的数组，创建一个多维的数组也很简单，eg下面是创建一个二维的数组 在上面的例子里面，每一个维度被成为 当定义了一个array的时候，我们可以</description>
<pubDate>Fri, 17 Nov 2017 07:09:00 +0000</pubDate>
<dc:creator>Wanna_Go</dc:creator>
<dc:identifier>http://www.cnblogs.com/wxshi/p/7851701.html</dc:identifier>
</item>
<item>
<title>海思板卡SATA最佳读写块大小测试 - bobojiang2016</title>
<link>http://www.cnblogs.com/bobojiang/p/7851633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobojiang/p/7851633.html</guid>
<description>&lt;p&gt;应需求，在海思板子上测试SATA读写速度，用dd指令，每次分别读/写不同大小的块    (bs)，同时检测运行dd命令CPU占比，记录读/写速度和CPU占比。&lt;/p&gt;
&lt;h2&gt;2    实验过程&lt;/h2&gt;
&lt;p&gt;2.1     用dd指令对SATA分区进行多次文件写入，写入总大小分别为320M, 640M, 1280M, 2560M，单次写入块大小分别为512B, 1K, 2K, 4K, 8k, 16K, 32K, 64K, 128K, 256K, 512K, 1024K, 2M, 4M, 8M, 16M, 32M，每个块大小写入测试n (n=3)次；&lt;/p&gt;
&lt;p&gt;2.2     在写入过程中计算得到该进程占用CPU百分比的平均值，写入结束后记录此次写入平均速度；&lt;/p&gt;
&lt;p&gt;2.3     将实验结果画图展示；&lt;/p&gt;
&lt;p&gt;2.4     将文件写入改为分区读出，重复2.1和2.2过程，得到读出文件速度和CPU占比，画图展示。&lt;/p&gt;
&lt;h2&gt;3    实验结果&lt;/h2&gt;
&lt;p&gt;3.1          文件写入&lt;/p&gt;
&lt;p&gt;图1-4分别为对SATA分区1（sda1）进行文件写入得到的相关数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117145710531-271605390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 1&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117145932796-2050883202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 2&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117145948577-1513689558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 3&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117150009156-746750536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 4&lt;/h3&gt;
&lt;p&gt;结合写入速度和CPU占比，为获得最佳写入块大小，取最大写入速度和较低的CPU占比的共同点。由图1-4可以分别看出，符合条件的块大小分别为32K，16K，32K，16K。&lt;/p&gt;
&lt;p&gt;3.2          文件读出&lt;/p&gt;
&lt;p&gt;图5-8分别为对SATA分区1（sda1）进行文件读出得到的相关数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117150029327-1737407482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 5&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117150043218-617222739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 6&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117150100140-1647021645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 7&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/905894/201711/905894-20171117150116546-199218970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;图 8&lt;/h3&gt;
&lt;p&gt;结合读出速度和CPU占比，为获得最佳读出块大小，取最大读出速度和较低的CPU占比的共同点。由图1-4可以分别看出，符合条件的块大小分别为64K，16K，64K，16K。&lt;/p&gt;
&lt;p&gt;附加实验：测试320M, 640M, 1280M, 2560M下以16K和64K为读取块大小的读出速度和CPU占比，结果如下表所示：&lt;/p&gt;
&lt;h3&gt;表 1 读取块为16K与64K的速度和CPU占比&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; width=&quot;243&quot;&gt;
&lt;p align=&quot;center&quot;&gt;16K&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; width=&quot;244&quot;&gt;
&lt;p align=&quot;center&quot;&gt;64K&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;5&quot; width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Speed&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;(Mb/s)&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;320M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;63.46&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;62.09&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;320M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;58.12&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;62.81&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;640M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;74.07&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;75.56&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;640M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;73.41&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;71.57&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1280M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;79.84&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;79.28&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1280M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;80.62&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;78.55&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2560M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;87.77&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;84.12&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2560M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;83.87&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;84.20&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;平均&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; width=&quot;162&quot;&gt;
&lt;p align=&quot;center&quot;&gt;75.77&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;平均&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; width=&quot;162&quot;&gt;
&lt;p align=&quot;center&quot;&gt;74.14&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;5&quot; width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;CPU&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;(%)&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;320M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;29&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;29&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;320M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;18&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;27&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;640M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;27&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;26&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;640M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;26&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;34&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1280M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;33&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;33&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1280M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;36&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;31&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2560M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;40&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;37&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2560M&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;38&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;36&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;平均&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; width=&quot;162&quot;&gt;
&lt;p align=&quot;center&quot;&gt;32&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;81&quot;&gt;
&lt;p align=&quot;center&quot;&gt;平均&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; width=&quot;162&quot;&gt;
&lt;p align=&quot;center&quot;&gt;31&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;由上表格中16K和64K对应的读取速度和CPU占比平均值对比可看出，在CPU占比相差较小的情况下，较大读取速度的文件读块大小为16K。&lt;/p&gt;


&lt;h2&gt;4    实验结论&lt;/h2&gt;
&lt;p&gt;由3.1得出，比较理想的单次写入块大小为16K和32K，但根据图1中16K的写入速度低于32K的写入速度约20Mb/s，因此最佳的单次写入块大小为16K，其次为32K。&lt;/p&gt;
&lt;p&gt;由3.2中的实验结果可知16K和64K的读取速度均较佳，结合附加实验结果可得出，最佳的单次读取块大小为16K，其次为64K。&lt;/p&gt;
&lt;p&gt;       结合已上两个实验结论，针对该海思板卡的SATA读写，以16K作为单次块读写可获得较快的速度且较低的CPU占比。&lt;/p&gt;


&lt;p&gt;shell笔记&lt;/p&gt;
&lt;p&gt;01. shell 当中#!/bin/sh 后面跟-x可以逐步显示出执行过程和结果，便于调试。&lt;/p&gt;
&lt;p&gt;02.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt; read line;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;  
    eval &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  

done &amp;lt; &lt;/span&gt;&lt;span&gt;$conffile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用类似如上导入文件的方法后，部分指令的&amp;amp;后台运行功能失效。原因未知。&lt;/p&gt;
&lt;p&gt;03. 像dd等指令直接重定向 &quot;&amp;gt;&quot; 到文件中不会将显示在屏幕上的内容写入文件，应写 &quot;2&amp;gt;&quot; 将&quot;2&quot;也就是标准错误定向到文件。&lt;/p&gt;
&lt;p&gt;04.  sed的用法之找到匹配的行，并删除或者整行替换：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法一：&lt;/span&gt;
line=`sed -i '/&lt;span&gt;$str&lt;/span&gt;/=' &lt;span&gt;$filename&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$line&lt;/span&gt; 
&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    sed &lt;/span&gt;-i &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${i}d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;$filename&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
    sed -i &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$i i${str}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;$filename&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在删除的那行加字符串str&lt;/span&gt;
&lt;span&gt;done

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法二：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;匹配到xxxx的行整行替换为str，适用于匹配的字符串不是行首的情况。&lt;/span&gt;
sed -i &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/xxxxx/s/^.*/$str/g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;$filename&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　方法二的效率明显高于一。&lt;/p&gt;

</description>
<pubDate>Fri, 17 Nov 2017 06:58:00 +0000</pubDate>
<dc:creator>bobojiang2016</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobojiang/p/7851633.html</dc:identifier>
</item>
<item>
<title>Katana-CookieAuthenticationMiddleware-源码浅析 - RocketRobin</title>
<link>http://www.cnblogs.com/rocketRobin/p/7851549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rocketRobin/p/7851549.html</guid>
<description>&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;h3 id=&quot;第一步建立一个模板项目&quot;&gt;第一步，建立一个模板项目&lt;/h3&gt;
&lt;p&gt;本文从&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;入手分析，首先我们来看看哪里用到了这个中间件，打开VisualStudio，创建一个Mvc项目，然后身份验证选择个人身份验证。此时我们获得了一个完整的项目，这个项目中登陆注册都已实现且较为完整，可以直接运行，所以我们从模板代码中来学习&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;接下来打开项目下的根目录\App_Start\Startup.Auth.cs这个文件,文件中的部分类&lt;code&gt;Startup&lt;/code&gt;。上一篇文章中写到Owin会加载&lt;code&gt;Startup&lt;/code&gt;类，所以在这个Mvc项目中会有一个位置加载了这个类，在代码中寻找 根目录\Startup.cs，这是&lt;code&gt;Startup&lt;/code&gt;类的另一部分，并且在其命名空间上被打上了&lt;code&gt;[assembly: OwinStartupAttribute(typeof(MyIdentity.Startup))]&lt;/code&gt;特性。&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;Startup.Auth.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureAuth(IAppBuilder app)
{
    // 配置数据库上下文、用户管理器和登录管理器，以便为每个请求使用单个实例
    app.CreatePerOwinContext(ApplicationDbContext.Create);
    app.CreatePerOwinContext&amp;lt;ApplicationUserManager&amp;gt;(ApplicationUserManager.Create);
    app.CreatePerOwinContext&amp;lt;ApplicationSignInManager&amp;gt;(ApplicationSignInManager.Create);

    // 使应用程序可以使用 Cookie 来存储已登录用户的信息
    // 并使用 Cookie 来临时存储有关使用第三方登录提供程序登录的用户的信息
    // 配置登录 Cookie
    app.UseCookieAuthentication(new CookieAuthenticationOptions
    {
        AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,
        LoginPath = new PathString(&quot;/Account/Login&quot;),
        Provider = new CookieAuthenticationProvider
        {
            // 当用户登录时使应用程序可以验证安全戳。
            // 这是一项安全功能，当你更改密码或者向帐户添加外部登录名时，将使用此功能。
            OnValidateIdentity = SecurityStampValidator.OnValidateIdentity&amp;lt;ApplicationUserManager, ApplicationUser&amp;gt;(
                validateInterval: TimeSpan.FromMinutes(30),
                regenerateIdentity: (manager, user) =&amp;gt; user.GenerateUserIdentityAsync(manager))
        }
    });            
    app.UseExternalSignInCookie(DefaultAuthenticationTypes.ExternalCookie);

    // 使应用程序可以在双重身份验证过程中验证第二因素时暂时存储用户信息。
    app.UseTwoFactorSignInCookie(DefaultAuthenticationTypes.TwoFactorCookie, TimeSpan.FromMinutes(5));

    // 使应用程序可以记住第二登录验证因素，例如电话或电子邮件。
    // 选中此选项后，登录过程中执行的第二个验证步骤将保存到你登录时所在的设备上。
    // 此选项类似于在登录时提供的“记住我”选项。
    app.UseTwoFactorRememberBrowserCookie(DefaultAuthenticationTypes.TwoFactorRememberBrowserCookie);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;app.UseCookieAuthentication&lt;/code&gt;Owin管道中添加中间件。进入&lt;code&gt;UseCookieAuthentication&lt;/code&gt;的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using Microsoft.Owin.Security.Cookies;
namespace Owin
{
    public static class CookieAuthenticationExtensions
    {
        public static IAppBuilder UseCookieAuthentication(this IAppBuilder app, CookieAuthenticationOptions options);
        public static IAppBuilder UseCookieAuthentication(this IAppBuilder app, CookieAuthenticationOptions options, PipelineStage stage);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法在&lt;code&gt;Microsoft.Owin.Security.Cookies.dll&lt;/code&gt;程序集中，这个程序集属于Katana项目。&lt;/p&gt;
&lt;h3 id=&quot;第二步下载katana源码&quot;&gt;第二步，下载Katana源码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aspnet/AspNetKatana&quot;&gt;到katana Github仓库地址&lt;/a&gt;下载Katana的源代码。然后打开&lt;code&gt;Katana.sln&lt;/code&gt;打开解决方案，然后在解决方案上点击右键选择还原Nuget包。&lt;/p&gt;
&lt;p&gt;准备工作结束&lt;/p&gt;
&lt;h2 id=&quot;从cookieauthenticationextensions入手&quot;&gt;从CookieAuthenticationExtensions入手&lt;/h2&gt;
&lt;p&gt;找到&lt;code&gt;UseCookieAuthentication&lt;/code&gt;方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static IAppBuilder UseCookieAuthentication(this IAppBuilder app, CookieAuthenticationOptions options, PipelineStage stage)
{
    if (app == null)
    {
        throw new ArgumentNullException(&quot;app&quot;);
    }

    app.Use(typeof(CookieAuthenticationMiddleware), app, options);

    app.UseStageMarker(stage);
    return app;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;app.Use(typeof(CookieAuthenticationMiddleware), app, options);&lt;/strong&gt;是Owin标准中定义的添加中间件的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Owin
{
    public interface IAppBuilder
    {
        IDictionary&amp;lt;string, object&amp;gt; Properties { get; }

        object Build(Type returnType);
        IAppBuilder New();
        IAppBuilder Use(object middleware, params object[] args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来进入&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CookieAuthenticationMiddleware : AuthenticationMiddleware&amp;lt;CookieAuthenticationOptions&amp;gt;
{
    private readonly ILogger _logger;
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再进入&lt;code&gt;AuthenticationMiddleware&amp;lt;CookieAuthenticationOptions&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class AuthenticationMiddleware&amp;lt;TOptions&amp;gt; : OwinMiddleware where TOptions : AuthenticationOptions
{
    protected AuthenticationMiddleware(OwinMiddleware next, TOptions options)
        : base(next)
    {
        if (options == null)
        {
            throw new ArgumentNullException(&quot;options&quot;);
        }

        Options = options;
    }

    public TOptions Options { get; set; }

    public override async Task Invoke(IOwinContext context)
    {
        AuthenticationHandler&amp;lt;TOptions&amp;gt; handler = CreateHandler();
        await handler.Initialize(Options, context);
        if (!await handler.InvokeAsync())
        {
            await Next.Invoke(context);
        }
        await handler.TeardownAsync();
    }

    protected abstract AuthenticationHandler&amp;lt;TOptions&amp;gt; CreateHandler();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到 &lt;code&gt;AuthenticationMiddleware&amp;lt;TOptions&amp;gt;&lt;/code&gt;直接继承了&lt;code&gt;OwinMiddleware&lt;/code&gt;也就是Katana中定义的，上一篇文章中提到了这个类，Katana中Middlware的抽象基类。&lt;br/&gt;重点看下Invoke方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public override async Task Invoke(IOwinContext context)
{
    AuthenticationHandler&amp;lt;TOptions&amp;gt; handler = CreateHandler();
    await handler.Initialize(Options, context);
    if (!await handler.InvokeAsync())
    {
        await Next.Invoke(context);
    }
    await handler.TeardownAsync();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先通过抽象的&lt;code&gt;CreateHandler()&lt;/code&gt;方法获取一个认证委托，然后初始化，然后Invoke。进入InvokeAsync的代码。位于&lt;code&gt;AuthenticationHandler&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Called once by common code after initialization. If an authentication middleware responds directly to
/// specifically known paths it must override this virtual, compare the request path to it's known paths, 
/// provide any response information as appropriate, and true to stop further processing.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;Returning false will cause the common code to call the next middleware in line. Returning true will
/// cause the common code to begin the async completion journey without calling the rest of the middleware
/// pipeline.&amp;lt;/returns&amp;gt;
public virtual Task&amp;lt;bool&amp;gt; InvokeAsync()
{
    return Task.FromResult&amp;lt;bool&amp;gt;(false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很意外，竟然直接返回了false。仔细看下注释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在初始化之后的代码调用一次。如果一个 身份认证中间件直接响应了特定的 中间件知道的路径，那么它必须重写这个虚方法，将请求路径与已知路径进行比较，提供适当的响应信息，并停止进一步的处理。&lt;br/&gt;返回false会调用后面的中间件，返回true不会调用下面的中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;if (!await handler.InvokeAsync())
{
    await Next.Invoke(context);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和注释中描述的一致，最后写在调用 &lt;code&gt;await handler.TeardownAsync();&lt;/code&gt;卸载handler。&lt;br/&gt;暂时跳过&lt;code&gt;TeardownAsync();&lt;/code&gt;方法，回到&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;可以看到其直接继承了&lt;code&gt;AuthenticationMiddleware&lt;/code&gt;它没有重写InvokeAsync，这代表Authentication之后不会停止，这就让人很迷惑，认证失败了也不停止吗？我们就绪探索。&lt;/p&gt;
&lt;p&gt;先看下 重写&lt;code&gt;CreateHandler&lt;/code&gt;抽象方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected override AuthenticationHandler&amp;lt;CookieAuthenticationOptions&amp;gt; CreateHandler()
{
    return new CookieAuthenticationHandler(_logger);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;CookieAuthenticationHandler&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/rocketrobin/MyBlogs/raw/master/Owin/QQ%E6%88%AA%E5%9B%BE20171117110403.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CookieAuthenticationHandler&lt;/code&gt;的父继承关系如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/rocketrobin/MyBlogs/raw/master/Owin/QQ%E6%88%AA%E5%9B%BE20171117110834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CookieAuthenticationHandler&lt;/code&gt;从名字中可以猜测这是真正处理 身份认证的类&lt;/p&gt;
&lt;p&gt;先看下类中的字段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private const string HeaderNameCacheControl = &quot;Cache-Control&quot;;
private const string HeaderNamePragma = &quot;Pragma&quot;;
private const string HeaderNameExpires = &quot;Expires&quot;;
private const string HeaderValueNoCache = &quot;no-cache&quot;;
private const string HeaderValueMinusOne = &quot;-1&quot;;
private const string SessionIdClaim = &quot;Microsoft.Owin.Security.Cookies-SessionId&quot;;

private readonly ILogger _logger;

private bool _shouldRenew;
private DateTimeOffset _renewIssuedUtc;
private DateTimeOffset _renewExpiresUtc;
private string _sessionKey;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的常量多是关于Http头的，还有Session的Claim&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private bool _shouldRenew;
private DateTimeOffset _renewIssuedUtc;
private DateTimeOffset _renewExpiresUtc;
private string _sessionKey;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一组应该是关于cookie过期时间和滑动窗口的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public CookieAuthenticationHandler(ILogger logger)
{
    if (logger == null)
    {
        throw new ArgumentNullException(&quot;logger&quot;);
    }
    _logger = logger;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造函数注入了Logger&lt;/p&gt;
&lt;p&gt;接下来是AuthenticationCore，应该就是人分认证的核心了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected override async Task&amp;lt;AuthenticationTicket&amp;gt; AuthenticateCoreAsync()
{
    AuthenticationTicket ticket = null;
    try
    {
        string cookie = Options.CookieManager.GetRequestCookie(Context, Options.CookieName);
        if (string.IsNullOrWhiteSpace(cookie))
        {
            return null;
        }

        ticket = Options.TicketDataFormat.Unprotect(cookie);

        if (ticket == null)
        {
            _logger.WriteWarning(@&quot;Unprotect ticket failed&quot;);
            return null;
        }

        if (Options.SessionStore != null)
        {
            Claim claim = ticket.Identity.Claims.FirstOrDefault(c =&amp;gt; c.Type.Equals(SessionIdClaim));
            if (claim == null)
            {
                _logger.WriteWarning(@&quot;SessionId missing&quot;);
                return null;
            }
            _sessionKey = claim.Value;
            ticket = await Options.SessionStore.RetrieveAsync(_sessionKey);
            if (ticket == null)
            {
                _logger.WriteWarning(@&quot;Identity missing in session store&quot;);
                return null;
            }
        }

        DateTimeOffset currentUtc = Options.SystemClock.UtcNow;
        DateTimeOffset? issuedUtc = ticket.Properties.IssuedUtc;
        DateTimeOffset? expiresUtc = ticket.Properties.ExpiresUtc;

        if (expiresUtc != null &amp;amp;&amp;amp; expiresUtc.Value &amp;lt; currentUtc)
        {
            if (Options.SessionStore != null)
            {
                await Options.SessionStore.RemoveAsync(_sessionKey);
            }
            return null;
        }

        bool? allowRefresh = ticket.Properties.AllowRefresh;
        if (issuedUtc != null &amp;amp;&amp;amp; expiresUtc != null &amp;amp;&amp;amp; Options.SlidingExpiration
            &amp;amp;&amp;amp; (!allowRefresh.HasValue || allowRefresh.Value))
        {
            TimeSpan timeElapsed = currentUtc.Subtract(issuedUtc.Value);
            TimeSpan timeRemaining = expiresUtc.Value.Subtract(currentUtc);

            if (timeRemaining &amp;lt; timeElapsed)
            {
                _shouldRenew = true;
                _renewIssuedUtc = currentUtc;
                TimeSpan timeSpan = expiresUtc.Value.Subtract(issuedUtc.Value);
                _renewExpiresUtc = currentUtc.Add(timeSpan);
            }
        }

        var context = new CookieValidateIdentityContext(Context, ticket, Options);

        await Options.Provider.ValidateIdentity(context);

        if (context.Identity == null)
        {
            // Rejected
            _shouldRenew = false;
            return null;
        }

        return new AuthenticationTicket(context.Identity, context.Properties);
    }
    catch (Exception exception)
    {
        CookieExceptionContext exceptionContext = new CookieExceptionContext(Context, Options,
            CookieExceptionContext.ExceptionLocation.AuthenticateAsync, exception, ticket);
        Options.Provider.Exception(exceptionContext);
        if (exceptionContext.Rethrow)
        {
            throw;
        }
        return exceptionContext.Ticket;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先进入&lt;code&gt;AuthenticationTicket&lt;/code&gt;看下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AuthenticationTicket
{
    /// &amp;lt;summary&amp;gt;
    /// Initializes a new instance of the &amp;lt;see cref=&quot;AuthenticationTicket&quot;/&amp;gt; class
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;identity&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;properties&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public AuthenticationTicket(ClaimsIdentity identity, AuthenticationProperties properties)
    {
        Identity = identity;
        Properties = properties ?? new AuthenticationProperties();
    }

    /// &amp;lt;summary&amp;gt;
    /// Gets the authenticated user identity.（获取已经过认证的用户Identity）

    /// &amp;lt;/summary&amp;gt;
    public ClaimsIdentity Identity { get; private set; }

    /// &amp;lt;summary&amp;gt;
    /// Additional state values for the authentication session.（认证回话中的额外的值）
    /// &amp;lt;/summary&amp;gt;
    public AuthenticationProperties Properties { get; private set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ClaimsIdentity&lt;/code&gt;位于&lt;code&gt;System.Security.Claims&lt;/code&gt;，属于mscorlib.dll，是.Net freamework的一部分，之前学习Asp.Net Identity框架时经常和这个类打交道。Asp.Net Identity 是基于Owin的实现Katana的，Katana里用了ClaimsIdentity，所以Asp.Net Identity中的&lt;code&gt;IIdentity&lt;/code&gt;类型是&lt;code&gt;ClaimsIdentity&lt;/code&gt;,如果你创建了一个没有身份验证的的mvc项目，那么在controller中User的实际类型就不是ClaimsIdentity。&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;AuthenticationProperties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;internal const string IssuedUtcKey = &quot;.issued&quot;;
internal const string ExpiresUtcKey = &quot;.expires&quot;;
internal const string IsPersistentKey = &quot;.persistent&quot;;
internal const string RedirectUriKey = &quot;.redirect&quot;;
internal const string RefreshKey = &quot;.refresh&quot;;
internal const string UtcDateTimeFormat = &quot;r&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些常量可能是和claims有关（博主并不十分确定）。&lt;/p&gt;
&lt;p&gt;这个类主要内容是认证回话中的额外数据，没有太多的方法所以我把注释信息翻译下，以便理解，然后继续分析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Gets or sets if refreshing the authentication session should be allowed.
/// 获取或者设置值指示是否允许舒心 认证会话
/// &amp;lt;/summary&amp;gt;
public bool? AllowRefresh
{
    get...
    set...
}

/// &amp;lt;summary&amp;gt;
/// State values about the authentication session.
/// 关于认证会话的状态值集合
/// &amp;lt;/summary&amp;gt;
public IDictionary&amp;lt;string, string&amp;gt; Dictionary
{
    get { return _dictionary; }
}

/// &amp;lt;summary&amp;gt;
/// Gets or sets the time at which the authentication ticket expires.
/// 认证票据的过期时间
/// &amp;lt;/summary&amp;gt;
public DateTimeOffset? ExpiresUtc
{
    get...
    set...
}

/// &amp;lt;summary&amp;gt;
/// Gets or sets whether the authentication session is persisted across multiple requests.
/// 指示认证会话是否在在跨越多个请求中持续保持
/// &amp;lt;/summary&amp;gt;
public bool IsPersistent
{
    get...
    set...
}

/// &amp;lt;summary&amp;gt;
/// Gets or sets the time at which the authentication ticket was issued.
/// 指示 认证票据的签发时间
/// &amp;lt;/summary&amp;gt;
public DateTimeOffset? IssuedUtc
{
    get...
    set...
}

/// &amp;lt;summary&amp;gt;
/// Gets or sets the full path or absolute URI to be used as an http redirect response value. 
/// 指示重定向响应所用到的完全路径或者绝对uri路径
/// &amp;lt;/summary&amp;gt;
[SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1056:UriPropertiesShouldNotBeStrings&quot;, Justification = &quot;By design&quot;)]
public string RedirectUri
{
    get...
    set...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在回到&lt;code&gt;CookieAuthenticationHandler.AuthenticateCoreAsync&lt;/code&gt;方法中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string cookie = Options.CookieManager.GetRequestCookie(Context, Options.CookieName);&lt;/code&gt; 获取Cookie。进入&lt;code&gt;GetRequestCookie&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ICookieManager
{
    /// &amp;lt;summary&amp;gt;
    /// Read a cookie with the given name from the request.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    string GetRequestCookie(IOwinContext context, string key);
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是个接口，从请求中获取指定的cookie。&lt;code&gt;Options&lt;/code&gt;是 &lt;code&gt;CookieAuthenticationHandler&lt;/code&gt;的直接父类中定义的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class AuthenticationHandler&amp;lt;TOptions&amp;gt; : AuthenticationHandler where TOptions : AuthenticationOptions
{
    protected TOptions Options { get; private set; }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;internal class CookieAuthenticationHandler : AuthenticationHandler&amp;lt;CookieAuthenticationOptions&amp;gt;&lt;/code&gt;的签名中我们可以知道Options的实际类型，在这里找到上文提到的&lt;code&gt;Options.CookieName&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Determines the cookie name used to persist the identity. The default value is &quot;.AspNet.Cookies&quot;.
/// This value should be changed if you change the name of the AuthenticationType, especially if your
/// system uses the cookie authentication middleware multiple times.
/// &amp;lt;/summary&amp;gt;
public string CookieName
{
    get { return _cookieName; }
    set
    {
        if (value == null)
        {
            throw new ArgumentNullException(&quot;value&quot;);
        }
        _cookieName = value;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;决定存储identity的cookie name，它的默认值是 &lt;strong&gt;.AspNet.Cookies&lt;/strong&gt;，这个值会在你改变AuthenticationType的名称是改变，尤其是你的系统多次使用了身份认证中间件。&lt;/p&gt;
&lt;p&gt;这里至少知道了存储的cookie默认值是.AspNet.Cookies&lt;/p&gt;
&lt;p&gt;运行之前的项目注册并登陆，检查Cookie&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/rocketrobin/MyBlogs/raw/master/Owin/QQ%E6%88%AA%E5%9B%BE20171117133006.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果似乎和预期的不太一致，我们继续探索&lt;br/&gt;打开 Startup类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public partial class Startup
{
    // 有关配置身份验证的详细信息，请访问 http://go.microsoft.com/fwlink/?LinkId=301864
    public void ConfigureAuth(IAppBuilder app)
    {
        // 配置数据库上下文、用户管理器和登录管理器，以便为每个请求使用单个实例
        app.CreatePerOwinContext(ApplicationDbContext.Create);
        app.CreatePerOwinContext&amp;lt;ApplicationUserManager&amp;gt;(ApplicationUserManager.Create);
        app.CreatePerOwinContext&amp;lt;ApplicationSignInManager&amp;gt;(ApplicationSignInManager.Create);

        // 使应用程序可以使用 Cookie 来存储已登录用户的信息
        // 并使用 Cookie 来临时存储有关使用第三方登录提供程序登录的用户的信息
        // 配置登录 Cookie
        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,
            LoginPath = new PathString(&quot;/Account/Login&quot;),
            Provider = new CookieAuthenticationProvider
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie&lt;/code&gt;一行中改变了&lt;code&gt;AuthenticationType&lt;/code&gt;的值，&lt;code&gt;ApplicationCookie&lt;/code&gt;的值是&lt;code&gt;ApplicationCookie&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public const string ApplicationCookie = &quot;ApplicationCookie&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来在源代码中搜索 .AspNet.，找到了&lt;code&gt;Microsoft.Owin.Security.Cookies.CookieAuthenticationDefaults&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class CookieAuthenticationDefaults
{
    ...
    /// &amp;lt;summary&amp;gt;
    /// The prefix used to provide a default CookieAuthenticationOptions.CookieName
    /// &amp;lt;/summary&amp;gt;
    public const string CookiePrefix = &quot;.AspNet.&quot;;
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是&lt;code&gt;CookieAuthenticationOptions.CookieName&lt;/code&gt;默认的Cookie前缀&lt;/p&gt;
&lt;p&gt;查找&lt;code&gt;CookieAuthenticationDefaults&lt;/code&gt;类的引用，我们找到了&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;(前文正在研究的)，其中的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Options.CookieName = CookieAuthenticationDefaults.CookiePrefix + Options.AuthenticationType;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果不言而喻。&lt;/p&gt;
&lt;p&gt;回到之前的&lt;code&gt;AuthenticateCoreAsync&lt;/code&gt;方法中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;string cookie = Options.CookieManager.GetRequestCookie(Context, Options.CookieName);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到了存储Identity的cookie。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ticket = Options.TicketDataFormat.Unprotect(cookie);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步从Cookie中解密数据获得ticket票据，&lt;code&gt;Options.TicketDataFormat&lt;/code&gt;是CookieAuthenticationOptions类型中的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// The TicketDataFormat is used to protect and unprotect the identity and other properties which are stored in the
/// cookie value. If it is not provided a default data handler is created using the data protection service contained
/// in the IAppBuilder.Properties. The default data protection service is based on machine key when running on ASP.NET, 
/// and on DPAPI when running in a different process.
/// &amp;lt;/summary&amp;gt;
public ISecureDataFormat&amp;lt;AuthenticationTicket&amp;gt; TicketDataFormat { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从注释信息中得知，这个属性用来加解密identity，而且在asp.net中基于 machine key。知道这个之后暂时不研究它的具体实现细节，我们回到之前的&lt;code&gt;AuthenticateCoreAsync&lt;/code&gt;方法中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (Options.SessionStore != null)
{
    Claim claim = ticket.Identity.Claims.FirstOrDefault(c =&amp;gt; c.Type.Equals(SessionIdClaim));
    if (claim == null)
    {
        _logger.WriteWarning(@&quot;SessionId missing&quot;);
        return null;
    }
    _sessionKey = claim.Value;
    ticket = await Options.SessionStore.RetrieveAsync(_sessionKey);
    if (ticket == null)
    {
        _logger.WriteWarning(@&quot;Identity missing in session store&quot;);
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些步骤的主要内容是从解析出的ticket中拿到session id 的claim,&lt;code&gt;RetrieveAsync&lt;/code&gt;方法没有注释，不知道这一步对ticket做了什么。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DateTimeOffset currentUtc = Options.SystemClock.UtcNow;
DateTimeOffset? issuedUtc = ticket.Properties.IssuedUtc;
DateTimeOffset? expiresUtc = ticket.Properties.ExpiresUtc;

if (expiresUtc != null &amp;amp;&amp;amp; expiresUtc.Value &amp;lt; currentUtc)
{
    if (Options.SessionStore != null)
    {
        await Options.SessionStore.RemoveAsync(_sessionKey);
    }
    return null;
}

bool? allowRefresh = ticket.Properties.AllowRefresh;
if (issuedUtc != null &amp;amp;&amp;amp; expiresUtc != null &amp;amp;&amp;amp; Options.SlidingExpiration
    &amp;amp;&amp;amp; (!allowRefresh.HasValue || allowRefresh.Value))
{
    TimeSpan timeElapsed = currentUtc.Subtract(issuedUtc.Value);
    TimeSpan timeRemaining = expiresUtc.Value.Subtract(currentUtc);

    if (timeRemaining &amp;lt; timeElapsed)
    {
        _shouldRenew = true;
        _renewIssuedUtc = currentUtc;
        TimeSpan timeSpan = expiresUtc.Value.Subtract(issuedUtc.Value);
        _renewExpiresUtc = currentUtc.Add(timeSpan);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些步骤做了刷新签发时间的一些工作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var context = new CookieValidateIdentityContext(Context, ticket, Options);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;CookieValidateIdentityContext&lt;/code&gt;这个类中的东西不多&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public CookieValidateIdentityContext(IOwinContext context, AuthenticationTicket ticket, CookieAuthenticationOptions options)
        : base(context, options)
    {
        if (ticket == null)
        {
            throw new ArgumentNullException(&quot;ticket&quot;);
        }

        Identity = ticket.Identity;
        Properties = ticket.Properties;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以进入其父类看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Base class used for certain event contexts
/// &amp;lt;/summary&amp;gt;
public abstract class BaseContext&amp;lt;TOptions&amp;gt;
{
    protected BaseContext(IOwinContext context, TOptions options)
    {
        OwinContext = context;
        Options = options;
    }

    public IOwinContext OwinContext { get; private set; }

    public TOptions Options { get; private set; }

    public IOwinRequest Request
    {
        get { return OwinContext.Request; }
    }

    public IOwinResponse Response
    {
        get { return OwinContext.Response; }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于某些事件上下文的基类，这里有 OwinRequest，OwinResponse,OwinContext,加上&lt;code&gt;CookieValidateIdentityContext&lt;/code&gt; Identity 和Properties，共同构成了 cookie 验证身份上下文。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CookieValidateIdentityContext&lt;/code&gt;中还有一个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Called to reject the incoming identity. This may be done if the application has determined the
/// account is no longer active, and the request should be treated as if it was anonymous.
/// &amp;lt;/summary&amp;gt;
public void RejectIdentity()
{
    Identity = null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法可以拒绝输入的Identity，可能在 app发现账户不在活动，并且向对待匿名用户那样对待当前的request&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;await Options.Provider.ValidateIdentity(context);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后验证了这个上下文，继续寻找&lt;code&gt;Options.Provider.ValidateIdentity&lt;/code&gt;直到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ICookieAuthenticationProvider
{
    /// &amp;lt;summary&amp;gt;
    /// Called each time a request identity has been validated by the middleware. By implementing this method the
    /// application may alter or reject the identity which has arrived with the request.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;context&quot;&amp;gt;Contains information about the login session as well as the user &amp;lt;see cref=&quot;System.Security.Claims.ClaimsIdentity&quot;/&amp;gt;.&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;A &amp;lt;see cref=&quot;Task&quot;/&amp;gt; representing the completed operation.&amp;lt;/returns&amp;gt;
    Task ValidateIdentity(CookieValidateIdentityContext context);
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是个接口方法，作用是 每次通过中间件验证请求身份时调用， 通过实现此方法，应用程序可以编辑或拒绝与请求一起到达的Identity。&lt;br/&gt;我们知道它是做什么的了，接下来找下它的实现类 &lt;code&gt;CookieAuthenticationProvider&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Implements the interface method by invoking the related delegate method
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public virtual Task ValidateIdentity(CookieValidateIdentityContext context)
{
    return OnValidateIdentity.Invoke(context);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终调用了&lt;code&gt;OnValidateIdentity&lt;/code&gt;委托。&lt;br/&gt;该委托在构造函数中赋予了默认值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public CookieAuthenticationProvider()
{
    OnValidateIdentity = context =&amp;gt; Task.FromResult&amp;lt;object&amp;gt;(null);
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (context.Identity == null)
{
    // Rejected
    _shouldRenew = false;
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断Identity是否是null，上文中提到&lt;code&gt;RejectIdentity&lt;/code&gt;方法可能为其赋值为null&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;return new AuthenticationTicket(context.Identity, context.Properties);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后 返回一个新的票据。&lt;/p&gt;
&lt;p&gt;捕获异常的部分如下，就不看了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;catch (Exception exception)
{
    CookieExceptionContext exceptionContext = new CookieExceptionContext(Context, Options,
        CookieExceptionContext.ExceptionLocation.AuthenticateAsync, exception, ticket);
    Options.Provider.Exception(exceptionContext);
    if (exceptionContext.Rethrow)
    {
        throw;
    }
    return exceptionContext.Ticket;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 17 Nov 2017 06:44:00 +0000</pubDate>
<dc:creator>RocketRobin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rocketRobin/p/7851549.html</dc:identifier>
</item>
<item>
<title>分享：苹果APP更新上架被拒的另一种理由(Safety - Objectionable Content) - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/7851303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/7851303.html</guid>
<description>
&lt;p&gt;这两个星期，本来想和大伙分享：写IT连创业系列运营篇。&lt;/p&gt;
&lt;p&gt;但时间飞过，仍只是写了开头，一直很忙，没能完往下写。&lt;/p&gt;

&lt;p&gt;今天就动手写点其它内容，哈哈，免的和小伙伴太陌生〜〜〜&lt;/p&gt;

&lt;p&gt;前几天更新了：IT恋和IT连的版本（主要是解决远程APNS通知的问题了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171117142653640-124552053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（截图有晚了，本来IT恋是有个大大感叹、问号的，在我写这篇文章的时候，开发人员重新提交了） &lt;/p&gt;

&lt;p&gt;PS：之前的远程通知一直没生效（听说IOS10以上的APNS消息机制变了，这个为啥开发人员不知道呢？后来是找了个朋友，给他远程指导，才搞定这事！）&lt;/p&gt;

&lt;p&gt;不过上架更新苹果给拒了，当前以前都上了6个版本了，一切都正常，但这次，审核人员不同，主观的理由就不同。&lt;/p&gt;

&lt;p&gt;这次原因是这样的：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2017年11月16日 上午9:42&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发件人 Apple&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Guideline 1.1 - Safety - Objectionable Content&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Your app includes content that many users would find objectionable and offensive. Specifically, the app is objectifying male.&lt;/p&gt;&lt;p&gt;Please see attached screenshots for details.&lt;/p&gt;&lt;p&gt;Next Steps&lt;/p&gt;&lt;p&gt;To resolve this issue, please remove all potentially objectionable content from your app and submit your revised binary for review.&lt;/p&gt;&lt;p&gt;For app design information, check out the following videos: &lt;span&gt;&quot;Best Practices for Great iOS UI Design&quot; and &lt;span&gt;&quot;Designing Intuitive User Experiences,&quot; available on the &lt;span&gt;Apple Developerwebsite.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;You may also want to review the &lt;span&gt;iOS Human Interface Guidelines for more information on how to create a great user experience in your app.&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些附件可能会显示可能令人反感的内容，如裸露、色情和亵渎内容。&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;ngRepeat: token in message.tokens&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;iPhone5.5&quot;(3).jpg （照片下面有）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;end ngRepeat: token in message.tokens&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;iPhone5.5&quot;(2).jpg  （照片下面有）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一开始IOS开发人员就简单回了一下邮箱：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2017年11月16日 上午11:13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发件人 ios@itlinks.cn (Guangzhou SuiTian Technology Co., Ltd.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我很抱歉，这个APP与另外一个APP是成对出现的。这个APP主要针对女性使用，给另外一个APP“IT连”（Apple ID 是 1275964845） 来发送信息聊天的。&lt;br/&gt;I'm sorry, this APP is paired with another APP.Use this APP is aimed at women, to another APP &quot;IT连&quot; (Apple ID is 1275964845) to send the information to chat.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;没明白，为什么回复要用I'm sorry开头。。。&lt;/p&gt;

&lt;p&gt;然后人家今天又回了：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2017年11月17日 上午3:43&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发件人 Apple&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;ngRepeat: rejectionReason in message.qcRejectionReasons&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;1. 1 Safety: Objectionable Content&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;end ngRepeat: rejectionReason in message.qcRejectionReasons&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Thank you for your reply. &lt;/p&gt;&lt;p&gt;We understand that you may not agree with the feedback we have provided. However, to ensure App Store customers a safe and enjoyable experience, all apps must comply with the App Store Review Guidelines. We hope that you will make the appropriate changes to your app to bring it into compliance with the App Store Review Guidelines and resubmit your app for review.&lt;/p&gt;&lt;p&gt;Best regards,&lt;/p&gt;&lt;p&gt;App Store Review&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;看，人家都是Hello，你却在Sorry，唉〜〜这逻辑，也是没谁了。&lt;/p&gt;

&lt;p&gt;然后，我仔细看了一下英文内容，人家告诉你以下两张图片有令人Objectionable。&lt;/p&gt;
&lt;p&gt;你却回复人家消息是和谁通讯。&lt;/p&gt;
&lt;p&gt;英文不好可以可以翻译，理解能力有偏差，这个真.....需要社会多经历：&lt;/p&gt;
&lt;p&gt;就是这两张：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DFojd7Q8q4SkdnkicdBVIXZoBjW3Im9sKibn54172n8dv7bibL1I6uReo2uXR07aIRDCQMH3ZicC3wVygnUX4ibibtHw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DFojd7Q8q4SkdnkicdBVIXZoBjW3Im9sKibn54172n8dv7bibL1I6uReo2uXR07aIRDCQMH3ZicC3wVygnUX4ibibtHw/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.7947368421052632&quot; data-w=&quot;380&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;回头，让UI，把文字改了：喜欢，从这里开始...&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DFojd7Q8q4SkdnkicdBVIXZoBjW3Im9sK6vEZ8Jx7vexia1jWFJcUclWXA8dsnzmr0vQeDbc4WlxH7QcFROX2Jrw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DFojd7Q8q4SkdnkicdBVIXZoBjW3Im9sK6vEZ8Jx7vexia1jWFJcUclWXA8dsnzmr0vQeDbc4WlxH7QcFROX2Jrw/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.3562005277044855&quot; data-w=&quot;379&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这张就直接不要了，换成匿名 新声 （来自一个未知的人）的图片和文字。&lt;/p&gt;

&lt;p&gt;然后，重新上架，啊门〜〜〜〜&lt;/p&gt;

&lt;h2&gt;补充：&lt;/h2&gt;
&lt;p&gt;关于IT连的运营，只能说：目前运营的重点，都还是放在社交，和单身的问题上，包括双十一前组织的七天恋爱活动。&lt;/p&gt;
&lt;p&gt;只是，这些运营的内容，我都是在自己微信上转，并没有来的及和大伙第一时间分享，抱歉啦！&lt;/p&gt;
&lt;p&gt;毕竟写文，是费时费力费脑的事，要及时需要点运气啊。&lt;/p&gt;

&lt;p&gt;自从运营的负责人来了后，我才发现，在单身恋爱这个领域，原来不缺女的，只缺男的。&lt;/p&gt;
&lt;p&gt;真是给上了一课，具体运营篇再和大伙分享了！！！&lt;/p&gt;

&lt;p&gt;欢迎单身的小伙伴Q我，除了技术，有空也可以一起探讨妹子，哈！！！&lt;/p&gt;

</description>
<pubDate>Fri, 17 Nov 2017 06:31:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/7851303.html</dc:identifier>
</item>
<item>
<title>TextView SpannableString 使用之实现可点击超链接效果 - didikee</title>
<link>http://www.cnblogs.com/didikee/p/7851260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/didikee/p/7851260.html</guid>
<description>&lt;h2 id=&quot;textview-spannablestring-使用之实现可点击超链接效果&quot;&gt;TextView SpannableString 使用之实现可点击超链接效果&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果看到这里说明你对 TextView 已经有了一定的了解，至少已经使用过该控件显示文字过。现在来实现一些复杂一点的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现可点击的超链接&quot;&gt;1. 实现可点击的超链接&lt;/h3&gt;
&lt;p&gt;我们在APP开发过程中会遇到这样的需求，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/848094/201711/848094-20171117135706156-1670988896.png&quot; alt=&quot;需求&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中标记为下划线的为可点击，点击后一般是跳转一个网页（这个在这里不做讨论）。面对这样的需求里可能已经知道&lt;code&gt;TextView&lt;/code&gt;是可以添加下划线的，你的实现可能是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;By Login, You agree to our Privicy Policy &amp;amp; Terms of use
[TextView]----[TextView]--[TextView]---[TextView]
[By Login, You agree to our ][Privicy Policy][ &amp;amp; ][Terms of use]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后为可点击的 &lt;code&gt;TextView&lt;/code&gt;添加下划线，然后设置点击事件就ok了。&lt;br/&gt;如果你满足于这，那么你可以继续往后看，看看&lt;strong&gt;只用一个TextView 如何实现。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;可点击的超链接基础&quot;&gt;2. 可点击的超链接（基础）&lt;/h3&gt;
&lt;p&gt;为了介绍 &lt;code&gt;SpannableString&lt;/code&gt;，我们来用它实现一个简单的下划线并设置监听点击事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/848094/201711/848094-20171117135722077-1173166278.png&quot; alt=&quot;简单使用&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        String clickString = &quot;I Love Android!&quot;;
        SpannableString spannableString =new SpannableString(clickString);
        spannableString.setSpan(new ClickableSpan() {
            @Override
            public void onClick(View widget) {
                Toast.makeText(getActivity(),&quot;Love&quot;,Toast.LENGTH_SHORT).show();
            }
        },2,6,Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        tv_tip.setText(spannableString);
        tv_tip.setMovementMethod(LinkMovementMethod.getInstance());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多个可点击的超链接提高&quot;&gt;3. 多个可点击的超链接(提高)&lt;/h3&gt;
&lt;p&gt;这回就要使用一个新的类：&lt;strong&gt;&lt;code&gt;SpannableStringBuilder&lt;/code&gt;&lt;/strong&gt;。看到名字就知道，它的作用类似&lt;code&gt;StringBuilder&lt;/code&gt;就是把多个&lt;code&gt;SpannableString&lt;/code&gt;连接起来。&lt;br/&gt;最后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/848094/201711/848094-20171117135740827-1668678300.png&quot; alt=&quot;进阶使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/848094/201711/848094-20171117135755796-1160169673.png&quot; alt=&quot;点击效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码实现（关键点就是把多个&lt;code&gt;SpannableString&lt;/code&gt;连接起来）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        final String linkWord1 = &quot;Android&quot;;
        final String linkWord2 = &quot;Are you ok?&quot;;
        final String linkWord3 = &quot;think you!&quot;;
        String word = &quot;Hello &quot; + linkWord1 + &quot;,&quot; + linkWord2 + &quot; I'm fine,&quot; + linkWord3;
        SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(word);
        int index1 = word.indexOf(linkWord1);
        int index2 = word.indexOf(linkWord2);
        int index3 = word.indexOf(linkWord3);
        spannableStringBuilder.setSpan(new ClickableSpan() {
            @Override
            public void onClick(View widget) {
                Toast.makeText(getActivity(), linkWord1, Toast.LENGTH_SHORT).show();
            }

            @Override
            public void updateDrawState(TextPaint ds) {
                super.updateDrawState(ds);
                ds.setColor(Color.RED);       //设置文件颜色
                ds.setUnderlineText(true);      //设置下划线
            }
        }, index1, index1 + linkWord1.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

        spannableStringBuilder.setSpan(new ClickableSpan() {
            @Override
            public void onClick(View widget) {
                Toast.makeText(getActivity(), linkWord2, Toast.LENGTH_SHORT).show();
            }

            @Override
            public void updateDrawState(TextPaint ds) {
                super.updateDrawState(ds);
                ds.setColor(Color.GREEN);       //设置文件颜色
                ds.setUnderlineText(true);      //设置下划线
            }
        }, index2, index2 + linkWord2.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

        spannableStringBuilder.setSpan(new ClickableSpan() {
            @Override
            public void onClick(View widget) {
                Toast.makeText(getActivity(), linkWord3, Toast.LENGTH_SHORT).show();
            }

            @Override
            public void updateDrawState(TextPaint ds) {
                super.updateDrawState(ds);
                ds.setColor(Color.BLUE);       //设置文件颜色
                ds.setUnderlineText(false);      //设置下划线
            }
        }, index3, index3 + linkWord3.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        tv_tip.setTextSize(14);
        tv_tip.setText(spannableStringBuilder);
        tv_tip.setMovementMethod(LinkMovementMethod.getInstance());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多个可点击的超链接html&quot;&gt;4. 多个可点击的超链接(html)&lt;/h3&gt;
&lt;p&gt;当然还有另外一种方法，就是使用&lt;code&gt;TextView&lt;/code&gt;显示 &lt;code&gt;html&lt;/code&gt;格式的文本，然后处理其中的&lt;code&gt;url&lt;/code&gt;，过程还是类似我们上面用到的方法，直接上代码吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       String html = &quot;&amp;lt;p&amp;gt;\n&quot; +
                &quot;   Hello &amp;lt;a href=\&quot;/link/click1\&quot;&amp;gt;Android&amp;lt;/a&amp;gt;，&amp;lt;a href=\&quot;/link/click2\&quot;&amp;gt;Are you ok?&amp;lt;/a&amp;gt;I'm fine,&amp;lt;a href=\&quot;/link/click3\&quot;&amp;gt;think you!&amp;lt;/a&amp;gt;\n&quot; +
                &quot; &amp;lt;/p&amp;gt;&quot;;

        tv_tip.setText(Html.fromHtml(html));
        tv_tip.setMovementMethod(LinkMovementMethod.getInstance());
        CharSequence text = tv_tip.getText();
        if (text instanceof Spannable) {
            int end = text.length();
            Spannable sp = (Spannable) tv_tip.getText();
            URLSpan[] urls = sp.getSpans(0, end, URLSpan.class);
            SpannableStringBuilder style = new SpannableStringBuilder(text);
            style.clearSpans(); // should clear old spans
            for (final URLSpan url : urls) {
                // 设置Span
                style.setSpan(new ClickableSpan() {
                    @Override
                    public void onClick(View widget) {
                        Toast.makeText(getActivity(), url.getURL(), Toast.LENGTH_SHORT).show();
                    }

                    @Override
                    public void updateDrawState(TextPaint ds) {
                        super.updateDrawState(ds);
                        ds.setColor(Color.RED);       //设置文件颜色
                        ds.setUnderlineText(true);      //设置下划线
                    }
                }, sp.getSpanStart(url), sp.getSpanEnd(url), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
            tv_tip.setText(style);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;因为我把所有的连接都设置为红色，所以显示的都是红色，实际中可能进行处理，那时对每个&lt;code&gt;url&lt;/code&gt;都进行处理即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/848094/201711/848094-20171117135604499-2224316.png&quot; alt=&quot;html实现&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里我没有讲每个类的细节，因为我觉得，如果你知道类名，那么你可以查到对应的官方文档，官方文档对api的讲解是很详细的，但是官方很少会结合实际需求告诉你如何实现，可能某一个api你不熟悉你就无法和实际需求联想起来，希望看了 这篇文章想深入了解的可以从 CharSequence 接口（与上面的类紧密联系）进行展开。&lt;br/&gt;下一篇讲 TextView ImageSpan 实现文字图片混排。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Nov 2017 05:59:00 +0000</pubDate>
<dc:creator>didikee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/didikee/p/7851260.html</dc:identifier>
</item>
<item>
<title>大龄程序员如何保持自己的职场竞争力 - tuohaibei</title>
<link>http://www.cnblogs.com/cby-love/p/7848444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cby-love/p/7848444.html</guid>
<description>&lt;p&gt;        生活中经常听到或看到抱怨程序员吃青春饭，想转管理或者转行，其实转也无可厚非，只是有时候我们需要静下心,想想我们是被周围的喧嚣影响了导致我们浮躁而产生了一时的想法，还是真的想好了转，我们也不必举例国外的大牛五六十岁了依然敲着代码来安慰自己，毕竟那是别人家的大牛，我们是大龄程序员，在职场中还是有一些劣势的，公司更乐于招年轻的程序员，因为他们做事有冲劲，容易培养，薪水也可以低一些，也有更多的时间输出到工作上，对于公司来说，何乐而不为，有时候我们想转或许我们是想要逃避，而不是热爱或者擅长，即便转了，也可能做的不够称职。其实做职业的另一种选择之前我们要扪心自问，我是真的不热爱我现在从事的吗？还是只是临时遇到槛了，如果这样我们也要问问自己当时为什么选择这一行？其实大龄程序员我们也不用急，我们掌握好自己的姿势就行了。但前提条件是你热爱编程这个行业，否则趁早转行。&lt;/p&gt;
&lt;p&gt;    1、&lt;strong&gt;程序员要时刻跳出自己的技术舒适区，提高自己的竞争力。&lt;/strong&gt;人都是有惰性的，遇到一件问题时，我们更乐于用自己的熟悉的方式去解决，做软件开发时，实现功能我们更乐于用自己熟练的技术，写来写去我们掌握的技术永远就是我们熟练的那几种。其实技术人员要有点私心的，如果工作时间允许，我们为什么不去尝试新技术，用新技术实现，这样对我们而言可以进一步熟悉，对于公司层面来说，其实可以为以后招人找到更优秀的人，因为我们可以自豪地说我们现在的项目用了什么什么新技术，优秀的人才会更感兴趣。说的更长远一点，如果公司倒闭，我们要另谋出路，我们是否为自己准备好了筹码呢？&lt;/p&gt;
&lt;p&gt;   2、&lt;strong&gt;时刻关注新技术。&lt;/strong&gt;软件开发技术层出不穷，两年之前你找工作时热门是大数据，现在的热门是AI，四年之前前端盛行的框架是EasyUI、Extjs,两年之前找工作Vue,react,angular开始盛行，移动互联网开始盛行。在一家公司呆久了难免用的技术就是几乎不变(当然你在一个善于用新技术的公司那就更好了)，我们怎么去拓展自己的视野呢，方法有好多，现在社会上各种技术大会层出不穷，笔者前端时间参加了腾讯直播技术大会，也参加过产品总监大会，前端大会，其实对于我撸码有用吗，说实话，用处不大，但是我去了，我就知道天外有天，不懂的东西还有好多，顺便也可以找一个自己感兴趣的学习一下。或许他们讲的某个框架是不是可以用于到现在工作当中。对于自己的技术选型也很有帮助；当然还有其它的方式，比如关注技术微信公众号，比如InfoQ,StuQ,dotNet跨平台等等。&lt;/p&gt;
&lt;p&gt;  3、&lt;strong&gt;锤炼自己学习新技术的能力，或者说形成自己的方法论。&lt;/strong&gt;技术永远学不完，我们需要去实现一个软件项目时，怎么样去挑选合适的技术方案，以及要当我们要用这门新技术时，怎么去把它快速上手，快速付诸于实际的项目中。挑选好的技术方案一方面来自于自己的知识储备，还有一方面就是需要去拓展自己未接触过的的技术方案，怎么去拓展，个人的经历去搜索引擎搜索，网上会有一些答案，或者请教圈子中的大牛。怎么快速去学习一门新技术，个人的建议就是看官方文档，比较系统性，比较专业性。或者可以去买好的出版社出版的一些书籍。系统的学习。随便一搜的例子只能解决一时的问题，谁知道这是不是旁门左道，会不会带来其它问题呢。个人感觉其实如果想搜一些demo，博客园还是比较好的，搜出一个demo，拷贝下来好多还是可以直接运行的，并且好多案例也讲的比较详细。&lt;/p&gt;
&lt;p&gt; 4、&lt;strong&gt;学会思考。&lt;/strong&gt;这是一个很重要的能力，它可能比你会什么技术更重要，好多人做软件开发多年，多年的习惯造就了思维定势。当我们解决一个棘手的问题的时候换种思维可能就更容易处理，关于这种能力，笔者也在实践摸索中，比如常用的逆向思维、归纳思维，举一反三等等。&lt;/p&gt;
&lt;p&gt; 5.、&lt;strong&gt;良好的英文阅读能力。&lt;/strong&gt;提到这一点其实很多人其实不是很在意，因为资料在搜索引擎一搜一大把，何必去看英文资料呢。但是我们要想想，在搜索引擎能搜索出的一把中文答案，肯定是这门技术已经产生有段时间了，好多技术来源于国外，技术发布最新的资料是用英文去解释的。从英文到中文肯定有一个过程，然后不同的人再去使用，然后再把代码案例放到网上。这中间经历了多长的周期，不太清楚。如果我们去涉猎英文材料，从技术刚发布，我们就能学习到。并且是技术人员原汁原味的传达。而不是别人翻译的，翻译的好多往往词不达意。当然这项能力对于极客来说可能更适合。如果只是实现某项功能，方案还是很多。只是说我们缺少了一项追本溯源的能力。&lt;/p&gt;
&lt;p&gt; 6、&lt;strong&gt;好的身体素质。&lt;/strong&gt;这个是一切的根本，这需要通过合理的休息，合理的锻炼去让自己的身体达到良好的状态，现在的年轻人也都开始注重身体锻炼了，每次去健身房都会看见大批人在锻炼。身体是革命的本钱。&lt;/p&gt;
&lt;p&gt;        以上是个人觉着一个优秀的程序员有持续的生产力需要具备的条件，具备这些条件，即便我是大龄程序员我也不怕，即便不能做到最好，但是也不至于差劲，当然学技术没什么捷径可言，只能多看，多动手练习实践，才真正的能被自己所吸收。遇到问题才能运筹帷幄，举一反三,还有想说的就是生活本来就不是一件不容易的事.如果容易,人人都是成功者.每个个体也就没有差异化,也就没什么优势可言。你想脱颖而出只能比别人更有毅力，韧劲。不断挑战自己的技术壁垒。&lt;/p&gt;

</description>
<pubDate>Fri, 17 Nov 2017 05:03:00 +0000</pubDate>
<dc:creator>tuohaibei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cby-love/p/7848444.html</dc:identifier>
</item>
</channel>
</rss>