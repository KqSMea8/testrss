<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>四则运算题目生成(python版) - LLLaoJI</title>
<link>http://www.cnblogs.com/lcglaoji/p/8679270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcglaoji/p/8679270.html</guid>
<description>&lt;h4 id=&quot;四则运算题目生成基于控制台&quot;&gt;四则运算题目生成—基于控制台&lt;/h4&gt;
&lt;p&gt;项目托管在码云：&lt;a href=&quot;https://gitee.com/HeyGary/calc&quot;&gt;飞机票&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;需求分析&quot;&gt;需求分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;根据控制台提示信息，输入题目生成相关配置参数
&lt;ul&gt;&lt;li&gt;&lt;em&gt;题目生成数量&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数字范围&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;式子中是否有分数&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;程序支持
&lt;ul&gt;&lt;li&gt;10000 题目生成&lt;/li&gt;
&lt;li&gt;题目与答案的本地化存储&lt;/li&gt;
&lt;li&gt;对生成的题目进行查重处理&lt;/li&gt;
&lt;li&gt;api接口生成&lt;/li&gt;
&lt;li&gt;统计对错情况&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;功能实现&quot;&gt;功能实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;由于此项目是针对面向对象课程所开发，所以代码结构力求做到清晰明了。&lt;/strong&gt;&lt;br/&gt;结构图如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340910/201803/1340910-20180330232510585-1755552818.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此项目主要完成3个主要部分&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;表达式生成
&lt;ul&gt;&lt;li&gt;generator.py&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;题目查重
&lt;ul&gt;&lt;li&gt;binary_tree.py&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;计算答案
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;设计到的基本数据结构及表达式有&lt;strong&gt;&lt;em&gt;栈&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;二叉树&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;逆波兰表达式(后缀表达式)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;未完待续&quot;&gt;未完待续。。。。&lt;/h5&gt;
</description>
<pubDate>Fri, 30 Mar 2018 15:25:00 +0000</pubDate>
<dc:creator>LLLaoJI</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lcglaoji/p/8679270.html</dc:identifier>
</item>
<item>
<title>团体程序设计天梯赛 到底是不是太胖了 - 极限之旅</title>
<link>http://www.cnblogs.com/baobao2201128470/p/8679261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baobao2201128470/p/8679261.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;据说一个人的标准体重应该是其身高（单位：厘米）减去100、再乘以0.9所得到的公斤数。真实体重与标准体重误差在10%以内都是完美身材（即 | 真实体重&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;span class=&quot;Apple-converted-space&quot;&gt; 标准体重 |&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 标准体重&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mord&quot;&gt;×&lt;span class=&quot;mord mathrm&quot;&gt;1&lt;span class=&quot;mord mathrm&quot;&gt;0&lt;span class=&quot;mord mathrm&quot;&gt;%）。已知市斤是公斤的两倍。现给定一群人的身高和实际体重，请你告诉他们是否太胖或太瘦了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;&lt;span&gt;输入格式：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;输入第一行给出一个正整数&lt;code&gt;N&lt;/code&gt;（&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;≤&lt;span class=&quot;Apple-converted-space&quot;&gt; 20）。随后&lt;code&gt;N&lt;/code&gt;行，每行给出两个整数，分别是一个人的身高&lt;code&gt;H&lt;/code&gt;（120&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;span class=&quot;Apple-converted-space&quot;&gt; H&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 200；单位：厘米）和真实体重&lt;code&gt;W&lt;/code&gt;（50&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;span class=&quot;Apple-converted-space&quot;&gt; W&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;≤&lt;span class=&quot;Apple-converted-space&quot;&gt; 300；单位：市斤），其间以空格分隔。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;输出格式：&lt;/h3&gt;
&lt;p&gt;为每个人输出一行结论：如果是完美身材，输出&lt;code&gt;You are wan mei!&lt;/code&gt;；如果太胖了，输出&lt;code&gt;You are tai pang le!&lt;/code&gt;；否则输出&lt;code&gt;You are tai shou le!&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;输入样例：&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-in&quot;&gt;3
169 136
150 81
178 155
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;输出样例：&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-out&quot;&gt;You are wan mei!
You are tai shou le!
You are tai pang le!&lt;br/&gt;&lt;span&gt;行了，很有意思的一道题，顺带再求出标准体重，有了目标，要减多少心里就有点逼数了，测试了一下自己，竟然是完美，哈哈哈哈&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cmath&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;  main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m,j;
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;n;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n--&lt;span&gt;)
    {
        cin&lt;/span&gt;&amp;gt;&amp;gt;j&amp;gt;&amp;gt;&lt;span&gt;m;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k=(j-&lt;span&gt;100&lt;/span&gt;)*&lt;span&gt;0.9&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标准体重
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cout&amp;lt;&amp;lt;&quot;你的标准体重是：&quot;&amp;lt;&amp;lt;k&amp;lt;&amp;lt;&quot;斤&quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; h=fabs(m-&lt;span&gt;k);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(h&amp;lt;k*&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)
            cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are wan mei!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(h&amp;gt;=k*&lt;span&gt;0.1&lt;/span&gt;&amp;amp;&amp;amp;k&amp;lt;&lt;span&gt;m)
            cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are tai pang le!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are tai shou le!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    }    
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 30 Mar 2018 15:23:00 +0000</pubDate>
<dc:creator>极限之旅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baobao2201128470/p/8679261.html</dc:identifier>
</item>
<item>
<title>windows+CMake+mingw 搭建c c++开发环境 - herelsp</title>
<link>http://www.cnblogs.com/herelsp/p/8679200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/herelsp/p/8679200.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;layout: post&lt;br/&gt;title: &quot;windows+CMake+mingw 搭建c c++开发环境&quot;&lt;br/&gt;date: 2018-03-30 22:23:06&lt;br/&gt;tags: windows CMake mingw c/c++&lt;br/&gt;key: 201803302223&lt;br/&gt;description: 本文教你如何在windows环境下使用CMake和mingw搭建同linux开发一样体验的c/c++开发环境&lt;br/&gt;---&lt;/p&gt;
&lt;h2 id=&quot;cmake-安装&quot;&gt;CMake 安装&lt;/h2&gt;
&lt;h3 id=&quot;cmake-下载&quot;&gt;CMake 下载&lt;/h3&gt;
&lt;p&gt;官方下载地址: &lt;a href=&quot;https://cmake.org/download/&quot; class=&quot;uri&quot;&gt;https://cmake.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-1f66b219b69a68c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cmake下载页面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择自己系统(&lt;strong&gt;Platform&lt;/strong&gt;)对应的版本并下载&lt;br/&gt;这里我们选择&lt;strong&gt;Windows win64-x64 Installer: Installer tool has changed. Uninstall CMake 3.4 or lower first!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-6c0b1b8cc84e2665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CMake 下载完成&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cmake-安装-1&quot;&gt;CMake 安装&lt;/h3&gt;
&lt;p&gt;安装时根据自己系统的安全设置，可能会出现如下对话框，不用担心，直接点击 &lt;strong&gt;&quot;运行(R)&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-4e1403fa98b8f0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装时安全警告&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-7fe8c54b142d87b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CMake Steup&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-6f36f8cdf38badc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;License&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;必须选择同意，否则不能进入下一步&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-242076ca9dd5c541.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装选项&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否添加环境变量，这里我们选择 &lt;strong&gt;&quot;Add CMake to the system PATH for all users&quot;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;是否创建桌面快捷图标，根据自身情况而定，这个只是创建桌面图标使用方便，并不会对以后的使用造成实质上的影响&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;安装路径&quot;&gt;安装路径&lt;/h3&gt;
&lt;p&gt;这里选择自己习惯存放程序的路径，我们这里采取默认值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-55fcc11c9e84a4aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装路径&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装最后确认&quot;&gt;安装最后确认&lt;/h3&gt;
&lt;p&gt;经过前面的操作终于把需要配置的都配置了，下面该程序自己干活了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-ea54db960ee87f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装最后确认&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;进入安装&quot;&gt;进入安装&lt;/h3&gt;
&lt;p&gt;真正开始安装的阶段，这一阶段比较耗时，完全取决于电脑自身的配置高低，系统主要是解压文件和写磁盘&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-4b14d25d350f6d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装中&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装完成&quot;&gt;安装完成&lt;/h3&gt;
&lt;p&gt;恭喜你，终于将CMake安装完成了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-c9485943428202dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装完成页面&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;确认cmake安装&quot;&gt;确认CMake安装&lt;/h3&gt;
&lt;p&gt;验证CMake是否成功安装，可以调出CMD窗口，输入&lt;code&gt;cmake&lt;/code&gt;，瞧瞧系统会给你说什么，如果出现如下窗口，那么恭喜你没有任何问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-63fc0b883d5d7970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CMake安装好&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么万一出现的是如下内容呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-61e292f409a36952.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CMake没安装好&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们一般有如下处理步骤和处理方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;确认是新调出CMD窗口再进行的操作&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;我们可以手动修改系统的环境变量指定CMake的bin目录位置&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-cd4618df2662ed20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;系统环境变量 Path&quot;/&gt;&lt;br/&gt;确认如图所示内容在Path中配置，如果没有可以手动输入并确定&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;待2操作完成后可以再验证，如果解决那么恭喜，如果问题仍存在，那么需要重启系统（一般都能解决了，除非比较低的系统版本可能需要重启）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mingw&quot;&gt;mingw&lt;/h2&gt;
&lt;h3 id=&quot;mingw-下载&quot;&gt;mingw 下载&lt;/h3&gt;
&lt;p&gt;这里给出64系统使用的mingw, &lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/&quot; class=&quot;uri&quot;&gt;https://sourceforge.net/projects/mingw-w64/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-e1b2e4fb22c7b05b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;mingw下载完成&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里其实是下载的一个安装器，具体的安装是通过运行这个安装器来引导安装的&lt;/p&gt;
&lt;h3 id=&quot;mingw-安装&quot;&gt;mingw 安装&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-c74924e17d0399fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开始运行安装器&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mingw-安装选项&quot;&gt;mingw 安装选项&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-7eabb5f28f9f3b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装选项&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要做出对应的选择，当然完全默认没有任何问题，我们这里采用默认，继续安装&lt;/p&gt;
&lt;h3 id=&quot;mingw-安装位置&quot;&gt;mingw 安装位置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-81c3b5084fc69ae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装位置选择&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里有坑，我们先入坑&lt;/strong&gt;, 继续安装&lt;/p&gt;
&lt;h3 id=&quot;mingw-安装中&quot;&gt;mingw 安装中&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-cd59d5495342b2e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装中&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装器需要从网上下载所需要的文件，这一步耗时较长&lt;/p&gt;
&lt;h3 id=&quot;mingw-安装完成&quot;&gt;mingw 安装完成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-0f09070d12a4069f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装完成&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境变量设置&quot;&gt;环境变量设置&lt;/h3&gt;
&lt;p&gt;同CMake的一样，mingw安装完后自动了设置环境变量，你也可以通过运行其安装目录下的&lt;code&gt;mingw-w64.bat&lt;/code&gt;来进入运行环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-278142c689b098f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;mingw-w64.bat&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证mingw环境是否设置好，同样新调出CMD窗口，输入&lt;code&gt;gcc&lt;/code&gt;命令，出入如下信息则表示安装没有问题，否则请参照CMake配置环境变量的方式来解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-a3fa27ce782fa639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gcc 命令&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cmakemingw-实例&quot;&gt;CMake+mingw 实例&lt;/h2&gt;
&lt;p&gt;我们安装完环境后来个实例运行下吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编写源码文件&lt;br/&gt;来个宇宙最著名的程序吧&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    printf(&quot;hello\n&quot;);
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编写CMake文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cmake_minimum_required(VERSION 3.0)
project(Hello)
set(SOURCE main.cpp)
add_executable(${PROJECT_NAME} ${SOURCE})
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成Make file&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir build
cd build
cmake -G&quot;Unix Makefiles&quot; ../&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很不幸，这一步会出问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CMake Error: CMake was unable to find a build program corresponding to &quot;Unix Makefiles&quot;.  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.
CMake Error: CMAKE_C_COMPILER not set, after EnableLanguage
CMake Error: CMAKE_CXX_COMPILER not set, after EnableLanguage
-- Configuring incomplete, errors occurred!
See also &quot;D:/tmp/build/CMakeFiles/CMakeOutput.log&quot;.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意思就是不能生成Unix Makefiles，这是缺少make程序造成的，&lt;br/&gt;解决方法就是找到mingw安装目录下mingw32-make.exe拷贝一份并重命名为make.exe&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-65e8b10f721b725f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;make&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再运行&lt;code&gt;cmake -G&quot;Unix Makefiles&quot; ../&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cmake -G&quot;Unix Makefiles&quot; ../
-- The C compiler identification is GNU 7.2.0
-- The CXX compiler identification is GNU 7.2.0
-- Check for working C compiler: C:/Program Files (x86)/mingw-w64/i686-7.2.0-posix-dwarf-rt_v5-rev1/mingw32/bin/gcc.exe
-- Check for working C compiler: C:/Program Files (x86)/mingw-w64/i686-7.2.0-posix-dwarf-rt_v5-rev1/mingw32/bin/gcc.exe -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: C:/Program Files (x86)/mingw-w64/i686-7.2.0-posix-dwarf-rt_v5-rev1/mingw32/bin/c++.exe
-- Check for working CXX compiler: C:/Program Files (x86)/mingw-w64/i686-7.2.0-posix-dwarf-rt_v5-rev1/mingw32/bin/c++.exe -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: D:/tmp/build
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就对了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么，又有问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ make
/usr/bin/sh: -c: line 0: syntax error near unexpected token `('
/usr/bin/sh: -c: line 0: `C:/Program Files (x86)/mingw-w64/i686-7.2.0-posix-dwarf-rt_v5-rev1/mingw32/bin/make -f CMakeFiles/Makefile2 all'
make: *** [Makefile:84: all] Error 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还记得前面我们安装mingw时说的坑吗，现在我们需要填坑了，文件就是万恶的&lt;code&gt;C:/Program Files (x86)&lt;/code&gt;，这也好办，将&lt;code&gt;mingw-w64&lt;/code&gt;文件夹复制到一个正常的目录吧，比如直接&lt;code&gt;C:/mingw-w64&lt;/code&gt;，然后需要修改环境变量&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-f694a58c71443330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;修改mingw环境变量&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ make
Scanning dependencies of target Hello
[ 50%] Building CXX object CMakeFiles/Hello.dir/main.cpp.obj
[100%] Linking CXX executable Hello.exe
[100%] Built target Hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;$ ./Hello.exe
hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，终于成功了&lt;/p&gt;
</description>
<pubDate>Fri, 30 Mar 2018 15:03:00 +0000</pubDate>
<dc:creator>herelsp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/herelsp/p/8679200.html</dc:identifier>
</item>
<item>
<title>从高级测试到测试开发 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/8679185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/8679185.html</guid>
<description>&lt;p&gt;最近加入了新的团队，角色发生较大的转变，在这里分享一下自己的感受。&lt;/p&gt;
&lt;h3 id=&quot;测试的划分&quot;&gt;测试的划分&lt;/h3&gt;
&lt;p&gt;如果我们把产品的生产看成一个流水线的话，那么测试就是流水线上的一个重要岗位，把控着产品的质量。&lt;/p&gt;
&lt;p&gt;当然，产品类型的不同，测试人员的能力不同，可做的事情也会有很大不同，比如是Web产品，那么我们会去做性能测试和Web UI自动化测试；比如是App产品，那么我们会去做专项测试和APP UI自动化测试，再比如是后端接口平台，那么我们会去做接口自动化测试。再比如游戏产品，测试方法和手段又不一样了。&lt;/p&gt;
&lt;p&gt;在此过程中，如果你是一名新手，只能测试UI功能，那么定位为测试工程师；如果你可负责一些复杂业务的测试，并且可以做一些自动化工作，那么定位为中级测试工程师；如果你有丰富的测试经验，综合的测试技术，以及深入到产品内部去做类白盒的测试能力，那么定位为高级测试工程师。（注：这里只是一般的划分，不代表任何公司）&lt;/p&gt;
&lt;h3 id=&quot;高级测试&quot;&gt;高级测试&lt;/h3&gt;
&lt;p&gt;接下来聊一聊我做高级测试时的工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201803/311516-20180330225853536-2126165732.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以我负责的接口平台为例，当开发完成接口开发后，我通过阅读接口代码逻辑的方式进行接口自动化用例的编写，过程中发的代码问题，反馈由开发修改；当我的用例编写完成，那么接口测试也基本搞定。当有新的接口更新时，我就可以重跑接口自动化用例来确保接口的质量，每次只需要对更新的接口编写测试用例。&lt;/p&gt;
&lt;p&gt;由于接口先测试，当产品提供可测界面时，问题就少很多了，只是界面样式和兼容性问题。整体上会在缩短整个测试时间。&lt;/p&gt;
&lt;p&gt;当然，产品测试过程中还会有一些零散的测试需求，可以快速的选取测试工具或编写测试脚本的方式来完成工作。&lt;/p&gt;
&lt;p&gt;这是一般高级测试工程师应该具备的能力。&lt;/p&gt;
&lt;h3 id=&quot;测试开发&quot;&gt;测试开发&lt;/h3&gt;
&lt;p&gt;接下来谈一谈测试开发，以及它在项目中的定位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201803/311516-20180330225956988-1553760239.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以我目前所属的团队为例，初创阶段可能是没有测试人员的，随着产品的发展，为了提升产品的质量，另一方面也为了节约人力成本，所以会招一些功能测试人员承担产品的测试工作。开发人员完成功能开发后，由测试人员进行测试。&lt;/p&gt;
&lt;p&gt;当公司进一步发展之后，为了优化团队，提升效率，单纯的功能测试人员就会成为短板，但为了保持团队的运行，不可能把功能测试人员全部替换为高级测试。另一方面功能测试也需要伴随公司成长。另一种办法就是引入测试开发团队。&lt;strong&gt;当然，大公司的测试开发与高级测试是并存的，测试开发只负责工具与平台的开发。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（&lt;strong&gt;注：&lt;/strong&gt; 这里不讨论个体的情况，比如有一位能力很强的测试/Leader推动测试团队转型）&lt;/p&gt;
&lt;p&gt;测试开发不直接参于产品的测试工作。这其实也是与高级测试最大的不同之处。简单将测试开发工作总结为以下几个方面。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;协助开发编写单元测试（并不是所有开发都一定会写单元测试），规范开发输出（比如输出一定标准接口文档）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;帮助功能测试人员提升技术能力，能够独立完成自动化测试工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;开发测试平台：比如，性能测试平台，帮助开发测试进行性能测试。开发接口测试平台，管理与维护接口平台，开发自动化测试平台，方便管理与维护自动化测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;挖掘测试需求，通过技术手段帮助测试团队提升测试效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结下来，就是测试的经验，开发的能力，干着服务于开发与测试的工作。&lt;/p&gt;
&lt;p&gt;最后，测试开发并不是高级测试的下一阶段，只职责不同而已。以上仅个人看法！&lt;/p&gt;
&lt;p&gt;欢迎关注：测试圈TC 公众号&lt;/p&gt;
</description>
<pubDate>Fri, 30 Mar 2018 15:02:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/8679185.html</dc:identifier>
</item>
<item>
<title>drbd(二)：配置和使用 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8678883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8678883.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html#blog1&quot;&gt;&lt;span&gt;1.drbd配置文件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html#blog2&quot;&gt;&lt;span&gt;2.创建metadata区并计算metadata区的大小&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html#blog3&quot;&gt;&lt;span&gt;3.启动drbd&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html#blog4&quot;&gt;&lt;span&gt;4.实现drbd主从同步&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html#blog5&quot;&gt;&lt;span&gt;5.数据同步和主从角色切换&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html#blog6&quot;&gt;&lt;span&gt;6.drbd脑裂后的解决办法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html#blog7&quot;&gt;&lt;span&gt;7.drbd多卷组配置&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;drbd的简介、同步机制和安装见另一篇文章：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8673178.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;drbd(一)：简介、同步机制和安装&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;本文所述为drbd8.4的配置，和8.4版本之前的版本，以及drbd9版本的差别都非常大。&lt;/p&gt;


&lt;p&gt;drbd的主配置文件/etc/drbd.conf，为了管理的便捷性，在此文件中使用了include指令指定了包含的配置文件段，默认的是在/etc/drbd.d/目录下。在此目录有全局配置文件&lt;code&gt;global_common.conf&lt;/code&gt;和其他配置文件&lt;code&gt;*.res&lt;/code&gt;文件。其中在主配置文件中include全局配置文件的指令只能出现一个，且必须出现在最前面。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;两个节点的配置文件应尽量完全一致。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;/usr/share/doc/drbd-版本/&lt;/code&gt;下有drbd.conf的样例配置文件。&lt;/p&gt;
&lt;p&gt;以下是global_common.conf的结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;global&lt;/span&gt; {
usage-count &lt;span class=&quot;hljs-literal&quot;&gt;yes&lt;/span&gt;;  
}

common {      
        handlers {
}
        startup {
        }
        options {
        }
        disk {
}
        net {
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全局配置修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;global&lt;/span&gt; {
        usage-count &lt;span class=&quot;hljs-literal&quot;&gt;no&lt;/span&gt;;
}

common {
handlers{       
          pri-&lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;-incon-degr &lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/lib/drbd/notify-pri-on-incon-degr.sh; /usr/lib/drbd/notify-emergency-reboot.sh; echo b &amp;gt; /proc/sysrq-trigger ; reboot -f&quot;&lt;/span&gt;;
          pri-lost-after-sb &lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/lib/drbd/notify-pri-lost-after-sb.sh; /usr/lib/drbd/notify-emergency-reboot.sh; echo b &amp;gt; /proc/sysrq-trigger ; reboot -f&quot;&lt;/span&gt;;
          local-io-error &lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/lib/drbd/notify-io-error.sh; /usr/lib/drbd/notify-emergency-shutdown.sh; echo o &amp;gt; /proc/sysrq-trigger ; halt -f&quot;&lt;/span&gt;;
          split-brain &lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/lib/drbd/notify-split-brain.sh root&quot;&lt;/span&gt;;
          out-&lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt;-sync &lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/lib/drbd/notify-out-of-sync.sh root&quot;&lt;/span&gt;;
}
        disk {
              &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;-io-error detach; 
              resync-rate &lt;span class=&quot;hljs-number&quot;&gt;600&lt;/span&gt;M;
        }
       
       
       
        }
        protocol C; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再新建一个配置文件data1.res，里面定义资源。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resource data1 {   
  &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd1.longshuai.com {   
    device    /dev/drbd0;    
    disk      /dev/sdb5;     
    address   &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.51:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;; 
    meta-disk /dev/sdb1;  
}
  &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd2.longshuai.com {
    device    /dev/drbd0;
    disk      /dev/sdb5;
    address   &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.52:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
    meta-disk /dev/sdb1;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者简化为如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resource data1 {
    device    /dev/drbd0;
    disk      /dev/sdb5;
    meta-disk /dev/sdb1[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];
    &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd1.longshuai.com {
        address   &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.51:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd2.longshuai.com {
        address   &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.52:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;resource段用于定义drbd资源，每个资源通常定义在一个单独的位于/etc/drbd.d目录中的以.res结尾的文件中。资源在定义时必须为其命名，名字可以由非空白的ASCII字符组成。每一个资源段的定义中至少要包含两个节点，其它参数均可以从common段或drbd的默认中进行继承。&lt;/p&gt;
&lt;p&gt;其中上述配置文件的meta-disk有三种记录方式：internal/device/device[index_num]。其中不管是哪种方式，metadata存放的分区不能格式化，哪怕使用internal时metadata和一般data在同一个分区也不能格式化该分区。&lt;/p&gt;
&lt;p&gt;internal是将元数据也写入到数据分区的尾部，即数据和元数据同分区。如果指定的device没有给定index时，则表示元数据存储到该设备中。如果某节点指定device[index_num]，那么指定几次元数据分区索引就必须大于128M的几倍，例如上述文件中drbd1.longshuai.com节点指定了/dev/sdb1[0]，那么sdb1就必须大于128M，如果此时其他资源的节点也指定了同一台服务器的/dev/sdb1[1]，则指定了两次就必须大于256M。指定为internal和device时，元数据区的大小是drbd自行计算的。&lt;/p&gt;


&lt;pre&gt;
&lt;code&gt;drbdadm &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt;-md [&lt;span class=&quot;hljs-keyword&quot;&gt;all&lt;/span&gt;|resource_names]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两节点都初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@drbd1 drbd.d]# drbdadm &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt;-md data1
initializing activity &lt;span class=&quot;hljs-keyword&quot;&gt;log&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; initializing bitmap
Writing meta &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt;...
New drbd meta &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt; block successfully created.&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化成功后，可以使用下面几个命令来获取drbd的metadata区信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@drbd1 ~]# drbdadm &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;show&lt;/span&gt;-gi data1

       +
       |               +
       |               |                 +
       |               |                 |         +-&amp;lt;  older history  &amp;gt;-
       V               V                 V         V
&lt;span class=&quot;hljs-number&quot;&gt;0000000000000004&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0000000000000000&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0000000000000000&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0000000000000000&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
                                                                    ^ ^ ^ ^ ^ ^ ^
                                      -&amp;lt;  &lt;span class=&quot;hljs-keyword&quot;&gt;Data&lt;/span&gt; consistency flag  &amp;gt;
                             -&amp;lt;  &lt;span class=&quot;hljs-keyword&quot;&gt;Data&lt;/span&gt; was/&lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; currently up-&lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt;-&lt;span class=&quot;hljs-built_in&quot;&gt;date&lt;/span&gt;  &amp;gt;
                                  -&amp;lt;  Node was/&lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; currently &lt;span class=&quot;hljs-keyword&quot;&gt;primary&lt;/span&gt;  &amp;gt;
                                  -&amp;lt;  Node was/&lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; currently connected  &amp;gt;
         -&amp;lt;  Node was &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; the progress &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; setting &lt;span class=&quot;hljs-keyword&quot;&gt;all&lt;/span&gt; bits &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; the bitmap  &amp;gt;
                        -&amp;lt;  The peer&lt;span class=&quot;hljs-string&quot;&gt;'s disk was out-dated or inconsistent  &amp;gt;--+ |
      -&amp;lt;  This node was a crashed primary, and has not seen its peer since   &amp;gt;--+

flags: Secondary, StandAlone, Inconsistent
meta-data: clean
zero size device -- never seen peer yet?&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面命令的结果中，可以看出数据的代数，还能获取一些节点状态信息。&lt;/p&gt;
&lt;p&gt;关于drbd的代数，它在drbd的内部机制中，用于实现：&lt;br/&gt;(1).判断两节点是否是同一个集群的节点。也就是说，对方节点是不是自己的对端节点。因为有可能出现意外连接，却不是自己对端的情况。&lt;br/&gt;(2).判断节点设备是否需要全部重新同步(re-sync)或者部分重新同步。&lt;br/&gt;(3).判断重新同步的方向。即是从节点1重新同步到节点2还是从节点2重新同步到节点1。&lt;br/&gt;(3).标识节点是否处于脑裂(brain split)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]





version &lt;span class=&quot;hljs-string&quot;&gt;&quot;v08&quot;&lt;/span&gt;;






uuid {
    &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000004&lt;/span&gt;; &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000000&lt;/span&gt;; &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000000&lt;/span&gt;; &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000000&lt;/span&gt;;
    flags &lt;span class=&quot;hljs-number&quot;&gt;0x00000000&lt;/span&gt;;
}

la-size-sect &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
bm-byte-per-bit &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt;;
device-uuid &lt;span class=&quot;hljs-number&quot;&gt;0x0A293D126547895D&lt;/span&gt;;
la-peer-max-bio-size &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
al-stripes &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
al-stripe-size-&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;k &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;;

bm {
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从此命令中可以获知不同标记代数的uuid值，以及metadata的元数据信息，例如&lt;code&gt;md_size_sect=1951744&lt;/code&gt;表示元数据所在分区占用了1951744个扇区。注意，该命令不要在drbd设备已启动的情况下执行。&lt;/p&gt;
&lt;p&gt;知道这两个命令可以获取一些信息后，现在我们要做的是计算metadata部分的数据大小。这个大小在&quot;修改drbd设备空间大小&quot;时有用。&lt;/p&gt;
&lt;p&gt;首先获取元数据所在分区的扇区数。即上面结果中的&quot;md_size_sect&quot;。不过也可以使用块设备工具&lt;code&gt;blockdev&lt;/code&gt;来获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-number&quot;&gt;1951744&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了该值，根据计算公式：&lt;code&gt;Size = (md_size_sect/2^18)*8*N+72&lt;/code&gt;进行计算。其中md_size_sect如上计算，N是对端的数量，一般情况下drbd实现的是双节点，因此N=1，可以不用考虑。计算的结果是扇区数。&lt;/p&gt;
&lt;p&gt;因此，此处计算的结果为：&lt;code&gt;1951744/1024/256*8+72=131.5625&lt;/code&gt;共132扇区。如果要转换为KB大小，则再除以2即可(假设扇区大小为512bytes)。&lt;/p&gt;


&lt;p&gt;可使用如下命令来管理资源的启动、停止。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;drbdadm&lt;/span&gt; {up|down} {&lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt;|resource_names}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;drbdadm&lt;/span&gt; up data1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果启动报以下错误，则可能是因为对metadata进行了格式化。解决方法是将其删除再重新创建但不要格式化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;Failure: (119) No valid meta-data signature found.&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时可以查看/proc/drbd文件来查看drbd中配置的资源的状态，也可以使用命令&lt;code&gt;drbd-overview RESOURCE&lt;/code&gt;或&lt;code&gt;drbdadm status RESOURCE&lt;/code&gt;来查看。如果角色ro是从/从，则表明配置成功，若有一端是unknown，则表明和对方不能通信，可能是主机路由的问题，这样会导致脑裂的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;cat&lt;/span&gt; /proc/drbd
version: &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (api:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/proto:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-hash: 9976da086367a2476503ef7f6b13d4567327a280 build by mockbuild&lt;span class=&quot;hljs-variable&quot;&gt;@Build64R6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;38&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: cs:Connected ro:Secondary/Secondary ds:Inconsistent/Inconsistent C r-----
    ns:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; nr:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; dw:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; dr:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; bm:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; lo:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; pe:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ua:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ap:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ep:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; wo:f oos:&lt;span class=&quot;hljs-number&quot;&gt;6297452&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;状态信息极其重要，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cs：connection state，必须是connected状态才表示连接成功。&lt;/li&gt;
&lt;li&gt;ro：roles，各节点是是primary还是secondary。&lt;/li&gt;
&lt;li&gt;ds：disk state，数据的状态，由此判断是否要同步、重新同步、正在同步、同步完成、是否一致等等信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于drbd的状态信息，见另一篇文章。&lt;/p&gt;
&lt;p&gt;实际上，&lt;code&gt;drbdadm up&lt;/code&gt;启动drbd设备时做了很多工作，如果细致划分的话，可以将&quot;drbdadm up&quot;拆分为以下几个动作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将drbd的资源关联到底层设备(metadata和data区)上，使之能通过底层设备存、取数据。该过程调用的是drbdsetup程序。
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;drbdadm&lt;/span&gt; attach data1
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;加载drbd资源的同步参数。
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;drbdadm&lt;/span&gt; syncer data1
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;连接对端。
&lt;pre&gt;
&lt;code&gt;drbdadm &lt;span class=&quot;hljs-keyword&quot;&gt;connect&lt;/span&gt; data1
&lt;/code&gt;
&lt;/pre&gt;
这些命令在drbdadm中部分已失效，放在这里只是为了说明&quot;up&quot;时所执行的几个步骤。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到目前为止，drbd的资源已经关联完成，也已经准备好进行同步，所不知道的仅仅只是谁作为同步的源端，谁做为同步的目标端，也就是primary和secondary的角色。&lt;/p&gt;


&lt;p&gt;在需要设置为主机点的机器上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;drbdadm&lt;/span&gt; primary --force data1  

drbdsetup /dev/drbd0 primary
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&quot;--force&quot;表示强制升级为primary，这会导致本节点的数据强制同步到对端上。&lt;/p&gt;
&lt;p&gt;由于是第一次执行同步，因此该过程会同步整个分区进行初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;8.4&lt;/span&gt;.10-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: a4d5de01fffd7e4cde48a080e2c686f9e8cebf4c build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:SyncSource &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/Inconsistent C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;812136&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;813048&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4069272&lt;/span&gt;
        [=&lt;span class=&quot;hljs-function&quot;&gt;=&amp;gt;&lt;/span&gt;.................] sync&lt;span class=&quot;hljs-string&quot;&gt;'ed: 16.7% (3972/4764)M
        finish: 0:02:24 speed: 28,216 (17,652) K/sec&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到本端已经设置为主节点，且ds的一端是uptodate状态，最后还看到了镜像到对方的进度信息。&lt;/p&gt;
&lt;p&gt;当镜像完成后，再查看资源的信息。可以发现两端的ds都变成uptodate状态了。说明镜像完成了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;8.4&lt;/span&gt;.10-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: a4d5de01fffd7e4cde48a080e2c686f9e8cebf4c build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4881408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4882320&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;现在已经有一端是主节点了。drbd的主从节点中，只有主节点是可以挂载并进行读写的。所以在主节点上挂载drbd设备（可能需要重新格式化data分区，而且如果metadata使用的是internal模式，则需要格式化分区才OK）。&lt;/p&gt;
&lt;p&gt;挂载drbd到mnt，然后向其中拷贝一个文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
inittab  lost+found
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果对端也有这个文件则说明同步成功了，但是对端是从节点，无法读取数据，所以只能切换主从角色再查看。不过在，实验环境下直接把从节点的drbd给down掉，再直接挂载/dev/sdb5也是可以的。&lt;/p&gt;
&lt;p&gt;首先将主节点切换为从节点，必须先卸载挂载点才行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:data1/&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;hljs-constant&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Secondary&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;Secondary&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;UpToDate&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;UpToDate&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再在从节点上将自己设置为主节点，然后挂载drbd设备，再查看是否有文件同步过来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd2&lt;/span&gt; ~]
[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd2&lt;/span&gt; ~]
[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd2&lt;/span&gt; ~]
inittab  lost+found
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这说明实现了数据同步。但是这样手动切换来切换去的很麻烦，一般会将其交给heartbeat或者corosync来管理，实现drbd的自动切换。&lt;/p&gt;


&lt;p&gt;当DRBD的两节点都发现对方后，并都交换了初始化握手协议后，发现双方都是primary角色，就会出现脑裂。出现脑裂后，由于两端节点都可以挂载、写数据，会导致数据的混乱。&lt;/p&gt;
&lt;p&gt;当检测到出现脑裂时，drbd会立即中断双方的连接，并在日志中记录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Split-Brain detected, dropping connection!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在出现脑裂的时候，一定有一端的连接状态处于&lt;code&gt;StandAlone&lt;/code&gt;，另一端的状态可能是&lt;code&gt;StandAlone&lt;/code&gt;(当双方同时检测到脑裂)，也可能是&lt;code&gt;Connecting&lt;/code&gt;(当一端先检测到脑裂立即中断连接后使得另一端无法再检测出脑裂)。&lt;/p&gt;
&lt;p&gt;出现脑裂的时候，如果没有配置drbd自动从脑裂状态恢复，那么必须进行人为的手动干涉。干涉的方法是放弃一端的数据，这一端称为&quot;脑裂的受害者&quot;，另一端保存数据的节点则称为&quot;脑裂的幸存者&quot;。&lt;/p&gt;
&lt;p&gt;处理方法如下：&lt;/p&gt;
&lt;p&gt;(1).在脑裂的受害者节点上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;drbdadm&lt;/span&gt; disconnect {&lt;span class=&quot;hljs-title&quot;&gt;resource&lt;/span&gt; | all}   
drbdadm secondary {&lt;span class=&quot;hljs-title&quot;&gt;resource&lt;/span&gt; | all}    
drbdadm connect --discard-my-data {&lt;span class=&quot;hljs-title&quot;&gt;resource&lt;/span&gt; | all}   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2).如果脑裂的幸存者节点也是&lt;code&gt;StandAlone&lt;/code&gt;状态，则执行下面的命令重新连接，如果仍然保持&lt;code&gt;Connecting&lt;/code&gt;状态，则不需任何操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;drbdadm&lt;/span&gt; disconnect {&lt;span class=&quot;hljs-title&quot;&gt;resource&lt;/span&gt; | all}
drbdadm connect    {&lt;span class=&quot;hljs-title&quot;&gt;resource&lt;/span&gt; | all}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当干涉完两边后，两边重新建立连接，重新握手交换初始化协议信息。此时，脑裂的受害者端的状态将变为&lt;code&gt;SyncTarget&lt;/code&gt;，表示同步的目标端，它将从另一节点上获取数据。&lt;/p&gt;
&lt;p&gt;但注意，&lt;strong&gt;&lt;span&gt;受害者在&lt;code&gt;SyncTarget&lt;/code&gt;状态下同步数据时，并不会从幸存者节点获取所有数据，而是按照自己节点上的事务信息进行回滚，再从幸存者节点上获取回滚后还缺少的数据&lt;/span&gt;。&lt;/strong&gt;因此，drbd脑裂后完成数据同步也是很快的。&lt;/p&gt;


&lt;p&gt;前文实验中使用的配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd2&lt;/span&gt; ~]


resource data1 {
    &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd1.longshuai.com {
        device           /dev/drbd0 minor &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        disk             /dev/sdb5;
        meta-disk        /dev/sdb1;
        address          ipv4 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.51:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd2.longshuai.com {
        device           /dev/drbd0 minor &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        disk             /dev/sdb5;
        meta-disk        /dev/sdb1;
        address          ipv4 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.52:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resource data1 {
        device /dev/drbd0;
        disk /dev/sdb5;
        meta-disk /dev/sdb1;
        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd1.longshuai.com {
                address &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.51:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd2.longshuai.com {
                address &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.52:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实它还等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resource data1 {
        volume &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; {
                device /dev/drbd0;
                disk /dev/sdb5;
                meta-disk /dev/sdb1;
        }
        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd1.longshuai.com {
                address &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.51:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd2.longshuai.com {
                address &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.52:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;drbd会为没有分卷组的资源使用默认卷组&quot;volume 0&quot;。&lt;/p&gt;
&lt;p&gt;如果需要多个底层设备(磁盘、分区、LVM、RAID等)提供drbd的同步功能，可以设置多个卷组。&lt;/p&gt;
&lt;p&gt;例如，除了上面使用的/dev/sdb{5,1}外，添加/dev/sdc1(data区)、/dev/sdc2(metadata区)到另一个卷组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resource data1 {
        volume &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; {
                device /dev/drbd0;
                disk /dev/sdb5;
                meta-disk /dev/sdb1;
        }
        volume &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; {
                device /dev/drbd1;
                disk /dev/sdc1;
                meta-disk /dev/sdc2;
        }
        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd1.longshuai.com {
                address &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.51:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt; drbd2.longshuai.com {
                address &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.52:&lt;span class=&quot;hljs-number&quot;&gt;7788&lt;/span&gt;;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果第二个卷组是在drbd已经运行后再添加的完全的新分区，则需要先创建元数据区、调整配置文件、启动资源等过程。&lt;/p&gt;
&lt;p&gt;两边节点都执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;drbdadm&lt;/span&gt; create-md data1/&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;  
drbdadm adjust data1       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主节点执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;drbdadm 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看两卷组的状态信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;8.4&lt;/span&gt;.10-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: a4d5de01fffd7e4cde48a080e2c686f9e8cebf4c build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3441&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:SyncSource &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/Inconsistent C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;5352&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6264&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4876056&lt;/span&gt;
        [&amp;gt;....................] sync&lt;span class=&quot;hljs-string&quot;&gt;'ed:  0.2% (4760/4764)M
        finish: 0:43:32 speed: 1,784 (1,784) K/sec&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次提醒，两端的配置文件应当尽量保持一致，因此最好不要随意分区。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8678883.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8678883.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Mar 2018 14:09:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8678883.html</dc:identifier>
</item>
<item>
<title>走进webpack（3）-- 小结 - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8673235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8673235.html</guid>
<description>&lt;p&gt;　　写这一系列的文章，本意是想要梳理一下自己凌乱的webpack知识，只是使用过vue-cli，修改过其中的一部分代码，但是对于一个简单项目从0开始搭建webpack的流程和其中的依赖并不是十分清楚。所以写了这样的一系列文章，一方面巩固自己的知识，一方面也可以给小伙伴们一点点入口。但是无奈运气不好，偏偏恰逢webpack4热火朝天的上线了，在webpack3时代的一部分使用方法已经没办法照葫芦画瓢了。所以一边查看文档和github，给大家找到了一些并不是很完美的解决方案。这是这个系列的最后一篇，说一说webpack一些可以优化的地方。也算是给这个系列一个6分的答卷吧。&lt;/p&gt;
&lt;p&gt;　　先给大家介绍一个webpack自带的小插件，&lt;a href=&quot;https://doc.webpack-china.org/plugins/banner-plugin/&quot; target=&quot;_blank&quot;&gt;BannerPlugin&lt;/a&gt;，我们在前面的文章中说过，webpack自带的插件需要引入webpack，前面已经引入过了，这里就不再重复说明，然后我们只需要在plugins中加上一段代码就可以了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; webpack.BannerPlugin('author:zaking')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样在你打包生成的文件中都会带上你的标记，主要的作用就是在工作中找到这么垃圾的代码是谁写的。&lt;/p&gt;
&lt;p&gt;　　下面我们来看看如何将静态资源集中打包在一个文件夹下，这样会方便我们的开发和维护。&lt;strong&gt;想要将静态资源集中，我们需要一个插件&lt;span class=&quot;crayon-v&quot;&gt;copy&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-v&quot;&gt;webpack&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-v&quot;&gt;plugin。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;如何安装和引入就不多说了，直接上代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; copyWebpackPlugin([{
     from:__dirname&lt;/span&gt;+'/src/public'&lt;span&gt;,
      to:&lt;/span&gt;'./public'&lt;span&gt;
 }])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装和引入完成之后，在plugins配置中加入如上代码，也就是说从你的src/public目录下的所有文件都会打包到dist/public目录下，那么你现在如果打包的话会有报错，因为你的src下并没有public目录，所以我们新建一个目录，并且把src/images下的图片改个名字放进去，然后在打包就会发现完全没问题了。&lt;/p&gt;
&lt;p&gt;　　那么下面再说说如何读取json文件，我们偷点懒，直接使用package.json，看看如何读取其中的内容。&lt;/p&gt;
&lt;p&gt;　　首先，我们在index.html中新建一个div，名为jsonDIV：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 读取json数据的容器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;jsonDiv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后再main.js中加入一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取json&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; json =require('../package.json'&lt;span&gt;);
document.getElementById(&lt;/span&gt;&quot;jsonDiv&quot;).innerHTML= json.name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们npm run dev一下，就可以看到页面中已经显示了我们的项目名称，说明读取成功。&lt;/p&gt;
&lt;p&gt;　　回头看了下这篇文章有点短小，但是想来想去实在不知道还有什么可以写在这系列的最后一篇文章中。可能有人会问，怎么webpack这么多的功能你没什么说的了？不是的，而是再说下去也是重复之前说过的，各种loader，各种插件，所以也就不说了。如果大家对webpack更多的功能和用法有兴趣，可以去查看官方文档，那里还是比较详细的。而目前webpack4的发布，使很多小伙伴都迫不及待地想要尝尝鲜，但是webpack3仍旧是当前的主流，而且4的文档并不全面，很多功能如果英文不太好的话还是很难的。所以个人建议大家在工作中没必要使用4。当然，想要课后学习一下是值得肯定的。&lt;/p&gt;
&lt;p&gt;　　那么最后，非常感谢大家阅读！&lt;a href=&quot;https://github.com/ZakingQ/structure-demo&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;代码已经同步更新！&lt;/p&gt;
</description>
<pubDate>Fri, 30 Mar 2018 14:07:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8673235.html</dc:identifier>
</item>
<item>
<title>漫谈Java IO之 Netty与NIO服务器 - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/8678869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/8678869.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;前面介绍了基本的网络模型以及IO与NIO，那么有了NIO来开发非阻塞服务器，大家就满足了吗？有了技术支持，就回去追求效率，因此就产生了很多NIO的框架对NIO进行封装——这就是大名鼎鼎的Netty。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几篇的内容，可以参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/8659436.html&quot;&gt;网络IO的基本知识与概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/8666147.html&quot;&gt;普通IO以及BIO服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/8672418.html&quot;&gt;NIO的使用与服务器Hello world&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/8678869.html&quot;&gt;Netty的使用与服务器Hello world&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;为什么要使用开源框架&quot;&gt;为什么要使用开源框架？&lt;/h3&gt;
&lt;p&gt;这个问题几乎可以当做废话，框架肯定要比一些原生的API封装了更多地功能，重复造轮子在追求效率的情况并不是明智之举。那么先来说说NIO有什么缺点吧：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;NIO的类库和API还是有点复杂，比如Buffer的使用&lt;/li&gt;
&lt;li&gt;Selector编写复杂，如果对某个事件注册后，业务代码过于耦合&lt;/li&gt;
&lt;li&gt;需要了解很多多线程的知识，熟悉网络编程&lt;/li&gt;
&lt;li&gt;面对断连重连、保丢失、粘包等，处理复杂&lt;/li&gt;
&lt;li&gt;NIO存在BUG，根据网上言论说是selector空轮训导致CPU飙升，具体有兴趣的可以看看JDK的官网&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么有了这些问题，就急需一些大牛们开发通用框架来方便劳苦大众了。最致命的NIO框架就是MINA和Netty了，这里不得不说个小插曲：&lt;/p&gt;
&lt;p&gt;先来看看&lt;strong&gt;MINA&lt;/strong&gt;的主要贡献者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-150322.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看看&lt;strong&gt;NETYY&lt;/strong&gt;的主要贡献者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-150316.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结起来，有这么几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MINA和Netty的主要贡献者都是同一个人——Trustin lee，韩国Line公司的。&lt;/li&gt;
&lt;li&gt;MINA于2006年开发，到14、15年左右，基本停止维护&lt;/li&gt;
&lt;li&gt;Nety开始于2009年，目前仍由苹果公司的norman maurer在主要维护。&lt;/li&gt;
&lt;li&gt;Norman Maurer是《Netty in Action》一书的作者&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，如果让你选择你应该知道选择谁了吧。另外，MINA对底层系统要求功底更深，且国内Netty的氛围更好，有李林峰等人在大力宣传（《Netty权威指南》的作者）。&lt;/p&gt;
&lt;p&gt;讲了一大堆的废话之后，总结来说就是——Netty有前途，学它准没错。&lt;/p&gt;
&lt;h3 id=&quot;netty介绍&quot;&gt;Netty介绍&lt;/h3&gt;
&lt;p&gt;按照定义来说，Netty是一个异步、事件驱动的用来做高性能、高可靠性的网络应用框架。主要的优点有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;框架设计优雅，底层模型随意切换适应不同的网络协议要求&lt;/li&gt;
&lt;li&gt;提供很多标准的协议、安全、编码解码的支持&lt;/li&gt;
&lt;li&gt;解决了很多NIO不易用的问题&lt;/li&gt;
&lt;li&gt;社区更为活跃，在很多开源框架中使用，如Dubbo、RocketMQ、Spark等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;主要支持的功能或者特性有：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-151524.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;底层核心有：Zero-Copy-Capable Buffer，非常易用的灵拷贝Buffer（这个内容很有意思，稍后专门来说）；统一的API；标准可扩展的时间模型&lt;/li&gt;
&lt;li&gt;传输方面的支持有：管道通信（具体不知道干啥的，还请老司机指教）；Http隧道；TCP与UDP&lt;/li&gt;
&lt;li&gt;协议方面的支持有：基于原始文本和二进制的协议；解压缩；大文件传输；流媒体传输；protobuf编解码；安全认证；http和websocket&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总之提供了很多现成的功能可以直接供开发者使用。&lt;/p&gt;
&lt;h3 id=&quot;netty服务器小例子&quot;&gt;Netty服务器小例子&lt;/h3&gt;
&lt;p&gt;基于Netty的服务器编程可以看做是Reactor模型：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-152213.jpg&quot;/&gt;&lt;br/&gt;即包含一个接收连接的线程池（也有可能是单个线程，boss线程池）以及一个处理连接的线程池（worker线程池）。boss负责接收连接，并进行IO监听；worker负责后续的处理。为了便于理解Netty，直接看看代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.xingoo.book.netty.chap04;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import java.net.InetSocketAddress;
import java.nio.charset.Charset;

public class NettyNioServer {
    public void serve(int port) throws InterruptedException {
        final ByteBuf buffer = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(&quot;Hi\r\n&quot;, Charset.forName(&quot;UTF-8&quot;)));
        // 第一步，创建线程池
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try{
            // 第二步，创建启动类
            ServerBootstrap b = new ServerBootstrap();
            // 第三步，配置各组件
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .localAddress(new InetSocketAddress(port))
                    .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter(){
                                @Override
                                public void channelActive(ChannelHandlerContext ctx) throws Exception {
                                    ctx.writeAndFlush(buffer.duplicate()).addListener(ChannelFutureListener.CLOSE);
                                }
                            });
                        }
                    });
            // 第四步，开启监听
            ChannelFuture f = b.bind().sync();
            f.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully().sync();
            workerGroup.shutdownGracefully().sync();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        NettyNioServer server = new NettyNioServer();
        server.serve(5555);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码非常少，而且想要换成阻塞IO，只需要替换Channel里面的工厂类即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NettyOioServer {
    public void serve(int port) throws InterruptedException {
        final ByteBuf buf = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(&quot;Hi\r\b&quot;, Charset.forName(&quot;UTF-8&quot;)));

        EventLoopGroup bossGroup = new OioEventLoopGroup(1);
        EventLoopGroup workerGroup = new OioEventLoopGroup();

        try{
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)//配置boss和worker
                    .channel(OioServerSocketChannel.class) // 使用阻塞的SocketChannel
         ....&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;概括来说，在Netty中包含下面几个主要的组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bootstrap：netty的组件容器，用于把其他各个部分连接起来；如果是TCP的Server端，则为ServerBootstrap.&lt;/li&gt;
&lt;li&gt;Channel：代表一个Socket的连接&lt;/li&gt;
&lt;li&gt;EventLoopGroup：一个Group包含多个EventLoop，可以理解为线程池&lt;/li&gt;
&lt;li&gt;EventLoop：处理具体的Channel，一个EventLoop可以处理多个Channel&lt;/li&gt;
&lt;li&gt;ChannelPipeline：每个Channel绑定一个pipeline，在上面注册处理逻辑handler&lt;/li&gt;
&lt;li&gt;Handler：具体的对消息或连接的处理，有两种类型，Inbound和Outbound。分别代表消息接收的处理和消息发送的处理。&lt;/li&gt;
&lt;li&gt;ChannelFuture：注解回调方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解上面的基本组件后，就看一下几个重要的内容。&lt;/p&gt;
&lt;h3 id=&quot;netty的buffer和零拷贝&quot;&gt;Netty的Buffer和零拷贝&lt;/h3&gt;
&lt;p&gt;在Unix操作系统中，系统底层可以基于mmap实现内核空间和用户空间的内存映射。但是在Netty中并不是这个意思，它主要来自于下面几个功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-153650.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过Composite和slice实现逻辑上的Buffer的组合和拆分，重新维护索引，避免内存拷贝过程。&lt;/li&gt;
&lt;li&gt;通过DirectBuffer申请堆外内存，避免用户空间的拷贝。不过堆外内存的申请和释放都很麻烦，推荐小心使用。关于堆外内存的一些研究，还可以参考执勤的分享：&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/5215458.html&quot;&gt;Java堆外内存之突破JVM枷锁&lt;/a&gt; 以及 &lt;a href=&quot;http://www.cnblogs.com/xing901022/p/5243657.html&quot;&gt;Java直接内存与非直接内存性能测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;通过FileRegion包装FileChannel，直接实现channel到channel的传输。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外，Netty自己封装实现了ByteBuf，相比于Nio原生的ByteBuffer，API上更易用了；同时支持容量的动态扩容；另外还支持Buffer的池化，高效复用Buffer。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ByteBufTest {
    public static void main(String[] args) {
        //创建bytebuf
        ByteBuf buf = Unpooled.copiedBuffer(&quot;hello&quot;.getBytes());
        System.out.println(buf);

        // 读取一个字节
        buf.readByte();
        System.out.println(buf);

        // 读取一个字节
        buf.readByte();
        System.out.println(buf);

        // 丢弃无用数据
        buf.discardReadBytes();
        System.out.println(buf);

        // 清空
        buf.clear();
        System.out.println(buf);

        // 写入
        buf.writeBytes(&quot;123&quot;.getBytes());
        System.out.println(buf);

        buf.markReaderIndex();
        System.out.println(&quot;mark:&quot;+buf);

        buf.readByte();
        buf.readByte();
        System.out.println(&quot;read:&quot;+buf);

        buf.resetReaderIndex();
        System.out.println(&quot;reset:&quot;+buf);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UnpooledHeapByteBuf(ridx: 0, widx: 5, cap: 5/5)
UnpooledHeapByteBuf(ridx: 1, widx: 5, cap: 5/5)
UnpooledHeapByteBuf(ridx: 2, widx: 5, cap: 5/5)
UnpooledHeapByteBuf(ridx: 0, widx: 3, cap: 5/5)
UnpooledHeapByteBuf(ridx: 0, widx: 0, cap: 5/5)
UnpooledHeapByteBuf(ridx: 0, widx: 3, cap: 5/5)
mark:UnpooledHeapByteBuf(ridx: 0, widx: 3, cap: 5/5)
read:UnpooledHeapByteBuf(ridx: 2, widx: 3, cap: 5/5)
reset:UnpooledHeapByteBuf(ridx: 0, widx: 3, cap: 5/5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有兴趣的可以看一下上一篇分享的ByteBuffer，对比一下，就能发现在Netty中通过独立的读写索引维护，避免读写模式的切换，更加方便了。&lt;/p&gt;
&lt;h3 id=&quot;handler的使用&quot;&gt;Handler的使用&lt;/h3&gt;
&lt;p&gt;前面介绍了Handler包含了Inbound和Outbound两种，他们统一放在一个双向链表中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-154727.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当接收消息的时候，会从链表的表头开始遍历，如果是inbound就调用对应的方法；如果发送消息则从链表的尾巴开始遍历。那么上面途中的例子，接收消息就会输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InboundA --&amp;gt; InboundB --&amp;gt; InboundC&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出消息，则会输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OutboundC --&amp;gt; OutboundB --&amp;gt; OutboundA&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有段代码，可以直接复制下来，试试看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.xingoo.book.netty.pipeline;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.charset.Charset;

/**
 * 注意：
 *
 * 1 ChannelOutboundHandler要在最后一个Inbound之前
 *
 */
public class NettyNioServerHandlerTest {

    final static ByteBuf buffer = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(&quot;Hi\r\n&quot;, Charset.forName(&quot;UTF-8&quot;)));

    public void serve(int port) throws InterruptedException {


        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try{
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .localAddress(new InetSocketAddress(port))
                    .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            ChannelPipeline pipeline = socketChannel.pipeline();
                            pipeline.addLast(&quot;1&quot;,new InboundA());
                            pipeline.addLast(&quot;2&quot;,new OutboundA());
                            pipeline.addLast(&quot;3&quot;,new InboundB());
                            pipeline.addLast(&quot;4&quot;,new OutboundB());
                            pipeline.addLast(&quot;5&quot;,new OutboundC());
                            pipeline.addLast(&quot;6&quot;,new InboundC());
                        }
                    });
            ChannelFuture f = b.bind().sync();
            f.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully().sync();
            workerGroup.shutdownGracefully().sync();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        NettyNioServerHandlerTest server = new NettyNioServerHandlerTest();
        server.serve(5555);
    }

    private static class InboundA extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            ByteBuf buf = (ByteBuf)msg;
            System.out.println(&quot;InboundA read&quot;+buf.toString(Charset.forName(&quot;UTF-8&quot;)));
            super.channelRead(ctx, msg);
        }
    }

    private static class InboundB extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            ByteBuf buf = (ByteBuf)msg;
            System.out.println(&quot;InboundB read&quot;+buf.toString(Charset.forName(&quot;UTF-8&quot;)));
            super.channelRead(ctx, msg);
            // 从pipeline的尾巴开始找outbound
            ctx.channel().writeAndFlush(buffer);
        }
    }

    private static class InboundC extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            ByteBuf buf = (ByteBuf)msg;
            System.out.println(&quot;InboundC read&quot;+buf.toString(Charset.forName(&quot;UTF-8&quot;)));
            super.channelRead(ctx, msg);
            // 这样会从当前的handler向前找outbound
            //ctx.writeAndFlush(buffer);
        }
    }

    private static class OutboundA extends ChannelOutboundHandlerAdapter {
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            System.out.println(&quot;OutboundA write&quot;);
            super.write(ctx, msg, promise);
        }
    }

    private static class OutboundB extends ChannelOutboundHandlerAdapter {
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            System.out.println(&quot;OutboundB write&quot;);
            super.write(ctx, msg, promise);
        }
    }

    private static class OutboundC extends ChannelOutboundHandlerAdapter {
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            System.out.println(&quot;OutboundC write&quot;);
            super.write(ctx, msg, promise);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后有一个TCP粘包的例子，有兴趣的也可以自己试一下，代码就不贴上来了，可以参考最后面的Github连接。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://item.jd.com/12070975.html&quot;&gt;《Netty实战》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://item.jd.com/11681556.html&quot;&gt;《Netty权威指南》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xinghalo/JDK-Learning/tree/master/src/cn/xingoo/book/netty2/chap5&quot;&gt;github代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 30 Mar 2018 14:06:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/8678869.html</dc:identifier>
</item>
<item>
<title>RabbitMQ 发布订阅持久化及持久化方式 - baidixing</title>
<link>http://www.cnblogs.com/jiagoushi/p/8678871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiagoushi/p/8678871.html</guid>
<description>&lt;p&gt;RabbitMQ是一种重要的消息队列中间件，在生产环境中，稳定是第一考虑。RabbitMQ厂家也深知开发者的声音，稳定、可靠是第一考虑，为了消息传输的可靠性传输，RabbitMQ提供了多种途径的消息持久化保证：Exchange持久化、Queue持久化及Message的持久化等。以保证RabbitMQ在重启或Crash等异常情况下，消息不会丢失。RabbitMQ提供了简单的参数配置来实现持久化操作。&lt;/p&gt;
&lt;p&gt;简单说明一下各种持久化方式：(描述代码采用的是RabbitMQ.Client  SDK,  C#代码)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Queue持久化&lt;/strong&gt;：队列是我们使用RabbitMQ进行数据传输的最多使用的方式，是进行点对点消息传递使用最多的方式。队列的持久化是通过durable=true 来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var connFactory = new ConnectionFactory();
Conn = connFactory.CreateConnection();
Model = Conn.CreateModel();
Model.QueueDeclare(q, false, false, false, null);　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，QueueDeclare的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/// &amp;lt;summary&amp;gt;(Spec method) Declare a queue.&amp;lt;/summary&amp;gt;
        [AmqpMethodDoNotImplement(null)]
        QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive,
            bool autoDelete, IDictionary&amp;lt;string, object&amp;gt; arguments);　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数说明：queue:队列名称。durable：设置是否执行持久化。如果设置为true，即&lt;strong&gt;durable=true，持久化实现的重要参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;exclusive：指示队列是否是排他性。如果一个队列被声明为排他队列，该队列仅对&lt;strong&gt;首次申明它的连接可见，并在连接断开时自动删除&lt;/strong&gt;。需要注意：1. 排他队列是基于连接可见的，同一连接的不同信道Channel是可以同时访问同一连接创建的排他队列；2.“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；3.即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。&lt;/p&gt;
&lt;p&gt;autoDelete:是否自动删除。如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于发布订阅方式创建的临时队列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消息的持久化&lt;/strong&gt;：如果将一个队列设置为持久化，那么会创建一个持久化的队列，但并不意味着队列中的消息也会持久化存储。因此如果要保证消息在RabbitMQ出现异常时不会丢失，需要设定消息的持久化。&lt;/p&gt;
&lt;p&gt;简要说明一下消息持久化和队列持久化的联系：&lt;/p&gt;
&lt;p&gt;队列设置为持久化，那么在RabbitMQ重启之后，持久化的队列也会存在，并会保持和重启前一致的队列参数。&lt;/p&gt;
&lt;p&gt;消息设置为持久化，在RabbitMQ重启之后，持久化的消息也会存在。&lt;/p&gt;
&lt;p&gt;那么就会出现一些矛盾的地方：&lt;/p&gt;
&lt;p&gt;1、因为消息必须依附于队列存在才有意义，那么如果队列设置为非持久化，而消息设置为持久化。在RabbitMQ重启之后，持久化的消息是否还存在呢？因为非持久化的队列可能并不存在。&lt;/p&gt;
&lt;p&gt;2、如果设置消息持久化为true，但队列设置成排他性队列，那么在RabbitMQ重启之后，消息是否仍然存在。请自行查找分析，下次分析该问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;              &lt;span&gt;var&lt;/span&gt; sf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; cf.CreateConnection())
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 IModel ch =&lt;span&gt; conn.CreateModel();&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                   Model = Conn.CreateModel();
                   Model.QueueDeclare(queueName, true, false, false, null);　
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello C# SSL Client World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] msgBytes =&lt;span&gt; System.Text.Encoding.UTF8.GetBytes(message);&lt;br/&gt;//发送消息
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 ch.&lt;span&gt;&lt;strong&gt;BasicPublish&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;queueName&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, msgBytes);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;bool&lt;/span&gt; noAck = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 BasicGetResult result =&lt;span&gt; ch.BasicGet(qName, noAck);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;byte&lt;/span&gt;[] body =&lt;span&gt; result.Body;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; resultMessage =&lt;span&gt; System.Text.Encoding.UTF8.GetString(body);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                Assert.AreEqual(message, resultMessage);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过RabbitMQ SDK发送消息至MQ非常简单，通过BasicPublish即可。&lt;/p&gt;
&lt;p&gt; BasicPublish 的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; (Spec method) Convenience overload of BasicPublish.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; The publication occurs with mandatory=false
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         [AmqpMethodDoNotImplement(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; BasicPublish(&lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;string&lt;/span&gt; routingKey, IBasicProperties basicProperties, &lt;span&gt;byte&lt;/span&gt;[] body);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置消息持久化，需要设置basicProperties的DeliveryMode=2 (Non-persistent (1) or persistent (2)).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置了队列和消息持久化后，当服务重启之后，消息仍然存在。只设置队列持久化，不设置消息持久化，重启之后消息会丢失；只设置消息持久化，不设置队列持久化，在服务重启后，队列会消失，从而依附于队列的消息也会丢失。只设置消息持久化而不设置队列的持久化，毫无意义。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exchange持久化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了实现一对多的消息发送，我们一般会采用发布订阅模式，通过一个发送端、多个订阅端来实现消息的分发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/280403/201803/280403-20180330215520989-779896855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布订阅模式存在一些问题：&lt;/p&gt;
&lt;p&gt;1、如果消费者由于网络或其他原因，与RabbitMQ的连接断开，那么RabbitMQ会自动将与其对应的队列删除，当消息程序重新连接以后，无法获取断开前未来得及消费的消息。&lt;/p&gt;
&lt;p&gt;2、如果RabbitMQ出现故障或Crash，那么在RabbitMQ  服务重启之后，消费端未及时消费的消息也会丢失，并且如果Exchange 不设置成持久化，那么在MQ服务重启之后，Exchange也不会存在。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;(Spec method) Declare an exchange.&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; The exchange is declared non-passive and non-internal.
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; The &quot;nowait&quot; option is not exercised.
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         [AmqpMethodDoNotImplement(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; ExchangeDeclare(&lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;string&lt;/span&gt; type, &lt;span&gt;bool&lt;/span&gt; durable, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; autoDelete,
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：exchange：RabbitMQ中定义的Exchange名称，type：类型，包含fanout、topic、direct、headers，durable：持久化设置。设置成true，就可以设定exchange持久化存储，autodelete：是否自动删除。&lt;/p&gt;
&lt;p&gt;exchange是实现发布订阅的基础，其类型包含fanout、headers、direct、、topic。我们本次仅讨论类型为topic。&lt;/p&gt;
&lt;p&gt;发布订阅模式执行消息发送的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/280403/201803/280403-20180330220614655-870166374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;RabbitMQ要实现发布订阅持久化，按照消息的传输流程，可以分成三类：&lt;/p&gt;
&lt;p&gt;Exchange 持久化：如果不设定Exchange持久化，那么在RabbitMQ由于某些异常等原因重启之后，Exchange会丢失。Exchange丢失， 会影响发送端发送消息到RabbitMQ。&lt;/p&gt;
&lt;p&gt;Queue持久化：发送端将消息发送至Exchange，Exchange将消息转发至关联的Queue。如果Queue不设置持久化，那么在RabbitMQ重启之后，Queue信息会丢失。导致消息发送至Exchange，但Exchange不知道需要将该消息发送至哪些具体的队列。&lt;/p&gt;
&lt;p&gt;Message持久化：发送端将消息发送至Exchange，Exchange将消息转发至关联的Queue，消息存储于具体的Queue中。如果RabbitMQ重启之后，由于Message未设置持久化，那么消息会在重启之后丢失。&lt;/p&gt;
&lt;p&gt;为了保证发布订阅的持久化，必须设置Exchange、Queue、Message的持久化，才可以保证消息最终不会丢失。&lt;/p&gt;
&lt;p&gt;虽然持久化会造成性能损耗，但为了生产环境的数据一致性，这是我们必须做出的选择。但我们可以通过设置消息过期时间、降低发送消息大小等其他方式来尽可能的降低MQ性能的降低。&lt;/p&gt;
&lt;p&gt;扩展阅读：&lt;/p&gt;
&lt;p&gt;1、Exchange type：topic、fanout、direct、headers的不同。&lt;/p&gt;
&lt;p&gt;2、消息的确认机制。&lt;/p&gt;
&lt;p&gt;3、将Exchange、Queue、Message都设置持久化，能保证消息100%会被成功消费吗？&lt;/p&gt;
&lt;p&gt;答案肯定是否，天下没有绝对的事情，尤其是复杂的MQ。&lt;/p&gt;
&lt;p&gt;原因简单介绍，一、如果消息的自动确认为true，那么在消息被接收以后，RabbitMQ就会删除该消息，假如消费端此时宕机，那么消息就会丢失。因此需要将消息设置为手动确认。&lt;/p&gt;
&lt;p&gt;二、设置手动确认会出现另一个问题，如果消息已被成功处理，但在消息确认过程中出现问题，那么在消费端重启后，消息会重新被消费。&lt;/p&gt;
&lt;p&gt;三、发送端为了保证消息会成功投递，一般会设定重试。如果消息发送至RabbitMQ之后，在RabbitMQ回复已成功接收消息过程中出现异常，那么发送端会重新发送该消息，从而造成消息重复发送。&lt;/p&gt;
&lt;p&gt;四、RabbitMQ的消息磁盘写入，如果出现问题，也会造成消息丢失。&lt;/p&gt;
&lt;p&gt;五、。。。。。&lt;/p&gt;

&lt;p&gt;下期热点问题：&lt;/p&gt;
&lt;p&gt;1、Exchange type的不同&lt;/p&gt;
&lt;p&gt;2、消息的确认与拒绝机制&lt;/p&gt;
&lt;p&gt;3、优先级机制&lt;/p&gt;

&lt;p&gt;RabbitMQ发布订阅持久化方式：Exchange、Queue、Message持久化，队列设定手动确认、AutoDelete=false。可以最大程度的保证消息不丢失。&lt;/p&gt;
&lt;p&gt;附RabbitMQ发布订阅持久化具体实现方式，参考代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5a57c987-bbba-460e-b81d-d9eb47a01f19')&quot; readability=&quot;44&quot;&gt;&lt;img id=&quot;code_img_closed_5a57c987-bbba-460e-b81d-d9eb47a01f19&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5a57c987-bbba-460e-b81d-d9eb47a01f19&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5a57c987-bbba-460e-b81d-d9eb47a01f19',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5a57c987-bbba-460e-b81d-d9eb47a01f19&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;MQ SDK新增接口：
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;IMQSession新增方法：
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建消息消费者
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;topicName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;主题名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;customTopicQueueName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;自定义Topic关联队列名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isPersistence&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否持久化&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;消息消费者&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         IMessageConsumer CreateTopicConsumer(&lt;span&gt;string&lt;/span&gt; topicName, &lt;span&gt;string&lt;/span&gt; customTopicQueueName, &lt;span&gt;bool&lt;/span&gt; isPersistence = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;调用方式：消费端需要明确指定需要消费的发布订阅关联队列。例如配置中心热部署，每个配置中心实例都需要指定唯一的关联队列名。
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;这样就可以和正常的MAC队列消费一样，消费指定队列消息。
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;实现方式，四个步骤：
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.创建持久化Topic(即持久化Exchange)：
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; service =&lt;span&gt; MQServiceProvider.GetDefaultMQService();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; messageText = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;///&lt;/span&gt;&lt;span&gt;创建Topic&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; service.CreateConnection())
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; session =&lt;span&gt; connection.CreateSession(MessageAckMode.IndividualAcknowledge);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; messageCreator =&lt;span&gt; service.GetMessageCreator();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; message =&lt;span&gt; messageCreator.CreateMessage(messageText);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 message.IsPersistent = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; producer =&lt;span&gt; session.CreateProducer();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; topic = session.DeclareTopic(topicName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.定义消费者Consumer：
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; queueList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozhiqi9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var service = MQServiceProvider.GetDefaultMQService();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var messageText = &quot;abc&quot; + DateTime.Now.ToShortTimeString();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义消费者&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection1 =&lt;span&gt; service.CreateConnection())
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; session1 =&lt;span&gt; connection1.CreateSession(MessageAckMode.IndividualAcknowledge);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; queueList)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     session1.DeclareQueue(item, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; consumer = session1.CreateTopicConsumer(topicName, item, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.发送消息到Topic
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; service.CreateConnection())
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; session =&lt;span&gt; connection.CreateSession(MessageAckMode.IndividualAcknowledge);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; messageCreator =&lt;span&gt; service.GetMessageCreator();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; message =&lt;span&gt; messageCreator.CreateMessage(messageText);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                     message.IsPersistent = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置持久化&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                    message.TimeToLive = TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置过期时间&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; producer =&lt;span&gt; session.CreateProducer();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; topic = session.DeclareTopic(topicName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                    producer.Send(message, topic);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;.从队列接收消息
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; Parallel.ForEach(queueList, (item) =&amp;gt;
&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收消息&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;                     &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection1 =&lt;span&gt; service.CreateConnection())
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; session1 =&lt;span&gt; connection1.CreateSession(MessageAckMode.IndividualAcknowledge);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt;                         session1.DeclareQueue(item, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; consumer = session1.CreateTopicConsumer(topicName, item, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; topic = session1.DeclareTopic(topicName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; receivedmessage =&lt;span&gt; consumer.Receive(topic);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; textMessage = receivedmessage &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ITextMessage;
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; 
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;                        Assert.AreEqual(messageText, textMessage.Body);
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;                        consumer.Acknowledge(receivedmessage);
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; 
&lt;span&gt;89&lt;/span&gt;             });
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 30 Mar 2018 14:06:00 +0000</pubDate>
<dc:creator>baidixing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiagoushi/p/8678871.html</dc:identifier>
</item>
<item>
<title>漫谈计算机体系 - 木可大大</title>
<link>http://www.cnblogs.com/neal-ke/p/8676288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neal-ke/p/8676288.html</guid>
<description>&lt;p&gt;人类为什么要发明计算机？一直以来，人类都有爱偷懒的习惯，而正是由于这个原因，促使了人类发明了计算机，从而提高生产力，那么人类有了更多空闲时间去娱乐了~~&lt;/p&gt;
&lt;h2&gt;冯.诺依曼结构的工作原理&lt;/h2&gt;
&lt;p&gt;冯诺依曼结构的计算机由五大组成部分，分别是计算器、控制器、存储器（内存）、输入设备和输出设备，而计算机和控制器组成CPU（center process unit，中央处理单元）。冯.诺依曼结构的特点就是数据和指令以二进制形式，不加区别的存放在存储器中。以计算两个数相加为例，首先将相关代码和数据读入到内存中，编译器将相关代码编译成汇编代码。数据200和数据400分别存放在地址为1000、1004的地方，&lt;code&gt;MOVE [1000] EAX&lt;/code&gt; 表示将地址是1000的内容放到寄存器EAX中，&lt;code&gt;MOVE [1004] EBX&lt;/code&gt; 表示将地址是1004的内容放到寄存器EBX中，&lt;code&gt;ADD EAX EBX&lt;/code&gt; 表示将EAX和EBX的内容相加，并将结果存放到EBX寄存器中。我们发现，简单的数据相加在汇编层面却对应着3条指令，如果更加复杂的数据运算就需要更加复杂的指令了。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/deduseclkq.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h2&gt;计算机各个部件的连接方式&lt;/h2&gt;
&lt;p&gt;CPU通过I/O桥和内存相连，I/O桥和IO总线相连，IO总线挂载着USB控制器、图形控制器和磁盘控制器。 总线结构（不是所有的设备都是两两相连，而是通过总线结构）&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;SOA也是总线结构，服务之间并不是两两相连的&lt;/li&gt;
&lt;li&gt;代码存放在磁盘中，如果要运行代码，首先需要将磁盘中的代码放到内存中，然后CPU找到这段程序的第一个地址，例如找到main方法的地址&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/l8jgbs8ihe.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;I/O桥是对南桥和北桥的抽象&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;北桥：连接的是快速设备，例如连接的是内存&lt;/li&gt;
&lt;li&gt;南桥：连接的是慢速设备&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/6hg2ntca1g.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;指令和流水线&lt;/h2&gt;
&lt;p&gt;常见的指令格式有三地址指令、二地址指令、一地址指令和零地址指令，如下图所示，其中，二地址指令所占用的空间比三地址指令要少，x86系列的处理器就是采用二地址形式的；一地址指令通常被用作累加器；零地址指令地址比较紧凑，但是要完成一件事情，一般会比二地址或三地址指令需要更多的指令，例如&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
iconst_1
iconst_2
iadd
istore_0
&lt;/pre&gt;
&lt;p&gt;iadd（表示整形加法）指令并没有任何参数。连源地址都没有指定，零地址指令有什么作用？零地址意味着源和目标都是隐含参数，其实现依赖于一种常见的数据结构--栈。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/d1qfgwplbp.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;指令的执行是分步骤的（取指、译码、执行等），也正是这个原因，它对应着不同的部件，这些部件我们要充分的利用起来，所以才有了流水线这个概念。如果不采用流水线，那么CPU的速度会变得很慢，譬如：当取值部件正在取值时，译码、执行部件是空闲的。所以，当一条指令在译码的时候，另一条指令从内存中取指令，这样做，取值部件和译码部件都可以利用起来了。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/ttxj685su2.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h2&gt;速度不匹配的问题---计算机的核心问题&lt;/h2&gt;
&lt;p&gt;下面这张图描述的是CPU、内存、硬盘和网络之间的速度差异，其中，CPU的速度是1s，主存速度是6min，硬盘速度是1~12个月，而网络速度则达到19年，我们发现这些设备的速度差别巨大，内存比CPU慢几百倍，硬盘比CPU慢几十万倍，网络比CPU慢千万倍，这样一来，CPU能坐等内存或硬盘慢吞吞的干活吗？或者说，有什么方法解决这种局面吗？&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/r7zojolpyg.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h2&gt;如何解决速度不匹配的问题&lt;/h2&gt;
&lt;p&gt;1. 提升硬盘等设备的速度，和CPU匹配（现阶段不可能）&lt;/p&gt;
&lt;p&gt;2. 承认局限，但充分压榨CPU的能力，让CPU&quot;忙死&quot;&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;同步 -&amp;gt; 异步 异步经典的例子就是DMA（Direct Memory Access，直接内存访问），CPU发起一个硬盘读的操作之后，不等待硬盘完成，立刻去干别的事情，由DMA控制器来负责把数据从硬盘读到内存，完成后通知CPU。&lt;/li&gt;
&lt;li&gt;顺序 -&amp;gt; 并发 顺序就是每个程序按序执行；并发就是在单个CPU上通过时间片切换方式实现执行不同指令，由于时间片很短，人类是感觉不出来的，因此我们感觉多个程序是并行执行的；而并行是在多个CPU上实现多个程序同时执行。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/wmx7vwpa02.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/xti937imzy.png?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;增加中间层 局部性原理分为时间局部性原理和空间局部性原理，时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某条数据被访问，则不就之后该数据可能被再次访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。 针对CPU而言，增加中间层就是增加缓存。当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立即读取并送给CPU；没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/oxot48j5x4.jpeg?imageView2//0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;欢迎关注微信公众号：木可大大，所有文章都将同步在公众号上。&lt;/p&gt;
</description>
<pubDate>Fri, 30 Mar 2018 13:29:00 +0000</pubDate>
<dc:creator>木可大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neal-ke/p/8676288.html</dc:identifier>
</item>
<item>
<title>ECEF和大地坐标系的相互转化 - 塔奇克马敲代码</title>
<link>http://www.cnblogs.com/taqikema/p/8678596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taqikema/p/8678596.html</guid>
<description>&lt;p&gt;&lt;span&gt;在阅读 RTKLIB&lt;span&gt;的源码时，发现了&lt;/span&gt;&lt;span&gt;ECEF&lt;/span&gt;&lt;span&gt;和大地坐标系的相互转换的函数，大地坐标系（&lt;/span&gt;φ,λ,h&lt;span&gt;）转成&lt;/span&gt;ECEF&lt;span&gt;（&lt;/span&gt;&lt;span&gt;X,Y,Z&lt;/span&gt;&lt;span&gt;）与所看书籍（&lt;/span&gt;&lt;span&gt;GPS&lt;/span&gt;&lt;span&gt;原理与接收机，谢刚，电子工业出版社）的公式是一样的，而&lt;/span&gt;&lt;span&gt;ECEF&lt;/span&gt;&lt;span&gt;转成大地坐标系的公式则与上述书籍和&lt;/span&gt; &lt;span&gt;RTKLIB&lt;/span&gt;&lt;span&gt;的使用手册（&lt;/span&gt;&lt;span&gt;P135&lt;/span&gt;&lt;span&gt;）中的公式都不一样。简而言之，遇到的问题如下图所示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330205520439-502562113.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一开始想着能不能直接在某个文献中直接找到与程序算法一致的处理流程，但找了很久都没能如愿。最后，只能想着彻底从平面几何上理解这个数学推导过程，从而再尝试理解为什么程序会那么写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在查找介绍大地坐标系的文献中，总能看到酉卯圆曲率半径这个名词。百度百科上给的定义是：过椭球面上一点的法线，可作无限个法截面，其中一个与该点子午面相垂直的法截面同椭球面相截形成的闭合的圈称为卯酉圈，如下图中的&lt;/span&gt;PEE&lt;span&gt;′所示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330205532955-582217993.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;597&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;图&lt;/span&gt; 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;投影到二维平面中，就是下面这幅图。其中，&lt;/span&gt;Pn&lt;span&gt;就称为酉卯圆曲率半径，&lt;/span&gt;&lt;span&gt;PT&lt;/span&gt;&lt;span&gt;则为椭圆的切线，角&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;则是酉卯圆曲率半径与长轴的夹角，称为纬度（&lt;/span&gt;也就是说通常意义上某个点的纬度并不是该点到地心的连线与长轴的夹角！）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330205551991-639945231.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由椭圆切线的斜率公式，可知&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330205924961-12413421.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                                       (1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;联立上面两式，可得&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;                           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210016837-925117103.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                                                    (2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210529819-1607919272.png&quot; alt=&quot;&quot;/&gt;。再将上式带入到椭圆的标准方程&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210553870-1022719656.png&quot; alt=&quot;&quot;/&gt;中，即可解得&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210035138-1417348350.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                    (3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，在△PnA中通过简单的几何关系可知，&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210605984-1531231110.png&quot; alt=&quot;&quot;/&gt;。所以有&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;                         &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210049572-1802743471.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                                             (4)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又因为&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210630488-342695799.png&quot; alt=&quot;&quot;/&gt;，所以有&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;                  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210105848-1313681283.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                                    (5)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，上面这个关于PQ&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Qn&lt;/span&gt;&lt;span&gt;的公式在后面推导&lt;/span&gt;&lt;span&gt;ECEF&lt;/span&gt;&lt;span&gt;和大地坐标系的相互转换公式时，是很重要的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了说明坐标转换的一般性，这里的待转换点&lt;/span&gt;P&lt;span&gt;是在地球外部的，示意图如下。图&lt;/span&gt; 3在理解（φ,λ,h&lt;span&gt;）&lt;/span&gt;→XYZ&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;坐标的变换公式时较为重要。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330205602934-1133867676.png&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;564&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而要想真正简单、清晰地理解大地坐标系（φ,λ,h&lt;span&gt;）与&lt;/span&gt;ECEF&lt;span&gt;（&lt;/span&gt;&lt;span&gt;X,Y,Z&lt;/span&gt;&lt;span&gt;）如何转换，还是要从二维平面图中着手。下图可以看作是椭球体的主视图，&lt;/span&gt;&lt;span&gt;XY&lt;/span&gt;&lt;span&gt;平面压缩成了水平&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;轴。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330205617642-1787792636.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;498&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;大地坐标系（φ,λ,h&lt;span&gt;）转成&lt;/span&gt;ECEF&lt;span&gt;（&lt;/span&gt;&lt;span&gt;X,Y,Z&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;OD&lt;span&gt;是点&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;XY&lt;/span&gt;&lt;span&gt;平面上的投影向量，其长度为&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;             &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210126521-1527199575.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                        (6)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;再结合图&lt;/span&gt;3&lt;span&gt;中&lt;/span&gt;&lt;span&gt;XY&lt;/span&gt;&lt;span&gt;平面中经度角&lt;/span&gt;&lt;em&gt;λ&lt;/em&gt;的示意图，可得&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;                       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210141900-1053672509.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                                       (7)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而关于&lt;em&gt;z&lt;/em&gt;坐标，则有&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210157998-1436939562.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                           (8)&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;ECEF&lt;span&gt;（&lt;/span&gt;&lt;span&gt;X,Y,Z&lt;/span&gt;&lt;span&gt;）转成大地坐标系（&lt;/span&gt;φ,λ,h）。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;首先是经度角&lt;/span&gt;λ，在图&lt;span&gt;3&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;XY&lt;/span&gt;&lt;span&gt;平面中可以很清晰地看到&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;                             &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210214817-1087429078.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                                              (9)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于纬度角φ&lt;span&gt;和高度&lt;/span&gt;h&lt;span&gt;，可以在在图&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;中分析其几何关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;                       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210230518-1672630249.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                             (10)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;            &lt;img src=&quot;https://images2018.cnblogs.com/blog/1000348/201803/1000348-20180330210246991-1458442209.png&quot; alt=&quot;&quot;/&gt;                                                                                                                                                                      (11)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上述公式中可以看到，在计算φ时还是会用到纬度角φ&lt;span&gt;的，所以不能直接用上述公式来计算纬度角。这里给出&lt;/span&gt;RTKLIB&lt;span&gt;中&lt;/span&gt;&lt;span&gt;ecf2pos&lt;/span&gt;&lt;span&gt;函数中的算法步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①　&lt;span&gt;假设&lt;/span&gt;PD=PE&lt;span&gt;，计算出夹角&lt;/span&gt;φ’。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②　&lt;span&gt;根据式&lt;/span&gt;(4)和式(11)再计算N’&lt;span&gt;和&lt;/span&gt;PE’。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③　&lt;span&gt;对比&lt;/span&gt;②中的PE’&lt;span&gt;与&lt;/span&gt;①中的PE之间的差别是否小于截断因子。不符合条件，将②中的PE’&lt;span&gt;代入到&lt;/span&gt;①中，继续循环计算；符合条件，则说明此时φ’=φ，可以跳出循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④　&lt;span&gt;将最终的&lt;/span&gt;PE代入到式(10)中，从而计算出纬度角φ&lt;span&gt;和高度&lt;/span&gt;h&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;至此，关于&lt;/span&gt;RTKLIB&lt;span&gt;的源码中的&lt;/span&gt;&lt;span&gt;pos2ecf&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ecf2pos&lt;/span&gt;&lt;span&gt;函数的计算过程的理论公式推导过程，就证明完了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个事情证明，&lt;span&gt;不会推公式的算法程序员是不合格的。找到的现成理论依据在复杂编程问题时可能会不够高效，或者当算法流程稍作改变时就会看不懂别人写的程序了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Mar 2018 13:08:00 +0000</pubDate>
<dc:creator>塔奇克马敲代码</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taqikema/p/8678596.html</dc:identifier>
</item>
</channel>
</rss>