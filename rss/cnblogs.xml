<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>微信公众号开发（一）微信验证开发者服务器接口 - 听说我很强</title>
<link>http://www.cnblogs.com/tswhq/p/8157795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tswhq/p/8157795.html</guid>
<description>&lt;p&gt;java代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping(&quot;/getToken&quot;)
@ResponseBody
public String getToken(TokenDTO tokenDTO, HttpServletResponse response){
    if ((StringUtils.isBlank(tokenDTO.getSignature()) || StringUtils.isBlank(tokenDTO.getTimestamp()) || StringUtils.isBlank(tokenDTO.getNonce()) || StringUtils.isBlank(tokenDTO.getEchostr()))) {
        return &quot;&quot;;
    }
    String[] arr = new String[]{tokenDTO.getTimestamp(), WeixinConstant.token, tokenDTO.getNonce()};
    Arrays.sort(arr);
    StringBuffer sb = new StringBuffer();
    sb.append(arr[0]).append(arr[1]).append(arr[2]);
    String hash = null;
    try {
        hash = new String(Hex.encodeHex(MessageDigest.getInstance(&quot;SHA-1&quot;).
                digest(sb.toString().getBytes(Constant.charset))));
    } catch (UnsupportedEncodingException | NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return (StringUtils.isNoneBlank(hash) &amp;amp;&amp;amp; hash.equals(tokenDTO.getSignature()))
            ? tokenDTO.getEchostr() : &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 31 Dec 2017 07:31:00 +0000</pubDate>
<dc:creator>听说我很强</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tswhq/p/8157795.html</dc:identifier>
</item>
<item>
<title>Java I/O---类体系总结 - 朱卫恒</title>
<link>http://www.cnblogs.com/zhuweiheng/p/8157788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuweiheng/p/8157788.html</guid>
<description>&lt;h2&gt;1.Java I/O常用&lt;/h2&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;21&quot;&gt;
&lt;h3&gt;&lt;span&gt;(1)&lt;span&gt;File&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;        对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;(2)FileInputStream&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      从文件系统中的某个文件中获得输入字节；用于读取诸如图像数据之类的原始字节流&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(3)FileInputStream&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;       用于将数据写入File或FileDesciptor &lt;span&gt;的输出流。用于写入诸如图像数据之类的原始字节的流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(4)BufferedInputStream&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      字节缓冲区对象，高效读取字节.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(5)BufferedOutputStream&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;     &lt;span&gt;  实现缓冲的输出流,高校写入字节。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(6)FileReader&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;       &lt;span&gt;把 InputStream转换为Reader（字节转化为字符）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(7)FileWriter&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;       把OutputStream转换Writer（字符转化为字节）。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(8)RandomAccessFile&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;       该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来随机操作字符数组中的数据&lt;/span&gt;。&lt;/p&gt;


&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/1307828/201712/1307828-20171231152156382-664620183.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/1307828/201712/1307828-20171231152156695-2096617710.png&quot; alt=&quot;image&quot; width=&quot;630&quot; height=&quot;775&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;right&quot;&gt;2017-12-31内容来自传智播客课程和博客&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/oubo/archive/2012/01/06/2394638.html&quot;&gt;Java IO流学习总结&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 31 Dec 2017 07:25:00 +0000</pubDate>
<dc:creator>朱卫恒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuweiheng/p/8157788.html</dc:identifier>
</item>
<item>
<title>写在2018前 - Nuss</title>
<link>http://www.cnblogs.com/Nuss/p/8157761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Nuss/p/8157761.html</guid>
<description>&lt;p&gt;最后一批90后也要成年了，00后马上就要粉墨登场了。今天是17年的最后一天，17年过的真快啊，园子里好多牛人的帖子还没看完，不知不觉就18年了，新年之际，在此分享这一些今年的一些收获和新一年的规划，希望对观看的人有些借鉴。&lt;/p&gt;
&lt;h4 id=&quot;回顾2017&quot;&gt;回顾2017&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;今年刚注册的博客园，之前都是在园子里看别人写的一些博客，后来想想咱们不能光索取，也得贡献一部分热量啊，所以就干脆注册了个 账号，准备大干一场，不过发现不是那么容易的，想写的一些东西，发现园子里已经有很多了，而且写的还很漂亮；另一方面，主要自己肚子里货太少，这可能是主要原因哈哈哈~。&lt;/p&gt;
&lt;p&gt;言归正传，写了一两篇工作中实际用到demo，其中关于web调用client程序的，在网上和园子里确实也搜到不少文章，好多都是千篇一律，甚至有些干脆就是copy别人的文章（强烈鄙视！），关键我都怀疑他试没试过，有些人写的很赞值得推荐，但是都和我自己想要的有些差别。这些文章基本上都是介绍如何添加一个协议，然后如何调用，很多人觉得这就足够了，但是我传多个参数呢！？参数传入后是什么样子的呢？好多相关文章都没有进行这方便的说明，也可能是我水平比较low，写文章的人可能默认大家都明白吧。最后在一个可能是台湾朋友的帖子里看到一个msdn官方的文章的链接，详细阅读后，豁然开朗，随即自己写了个客户端程序验证了下，所有疑问随之烟消云撒。然后便写了个帖子，记录了相关操作说明，对于传参和客户端接收到参数进行了相关说明，希望可以让看到的朋友少走些弯路。虽然文章不是很长，但从测试程序到整个文章书写，也是花费了大量的时间，终于明白大牛们付出的远远比我们看到的要多很多，就像那句话说的，有的人比我们聪明，还比我们努力，我们又有什么原因不努力呢。另一方面，自己也了解到，对于网上的一些知识，我们也要报有一定的探究精神，自己确实实践了吃透了才能明白人家说的对与错，缺陷存在哪里。&lt;br/&gt;当然后续又水了几篇文章，也确实感觉到自己水平不咋地，还是不卖弄了，还是好好闭门造车吧。最近一段时间都在研究DDD方面的知识，一方面阅读原著，一方面主要阅读园中&lt;a href=&quot;http://www.cnblogs.com/netfocus/&quot;&gt;netfocus汤老师的博客&lt;/a&gt;，在群里也一直在默默关注，学到了很多，想学习的强烈建议加入此群。&lt;br/&gt;总结下最近的学习成果吧。&lt;br/&gt;1.DDD领域驱动设计，是一种软件设计的方法论，是一种指导思想。&lt;br/&gt;2.DDD聚焦领域，强调领域对象是有行为的。&lt;br/&gt;3.设计领域对象时，我们要依据具体的业务场景分析，排除人的影响，关注该业务场景下对象的属性和行为（我认为这里的行为应该就是具体的业务规则），关心核心业务领域，抛弃传统的DBfirst的设计思路，不能去想表结构该如何设计，当然这也是必须要考虑的，至于怎么权衡，我目前水平还不是很清楚，还需要进一步的学习和实践。&lt;br/&gt;4.还有BC的划分，看到很多人说很难，这方便我目前感觉倒不用太执着，业务规则分析清楚了，核心领域对象设计出来了，自然就划分出来BC了，虽然自己目前也是在学习阶段，但有那种感觉应该就是这样的。&lt;/p&gt;
&lt;p&gt;最近工作中，也会不自觉的用DDD的思路有做一些东西，但发现最后还是情不自禁的又回到了db的道路上来，最后搞出了个四不像的东西出来且称之为伪DDD：）。所以目前感觉最难的还是建模，抽象核心领域模型，看原著作者也是在不断地和领域专家共同探讨，最后才创建出核心领域模型的。18年准备更多的实践一些小的项目，来磨练自己的抽象总结能力。&lt;/p&gt;
&lt;p&gt;列一下今年看的书吧，希望对工作2-3年的朋友有帮助：&lt;br/&gt;-《C#本质论》&lt;br/&gt;-《领域驱动设计--软件核心复杂性应对之道》&lt;br/&gt;-《大话设计模式》&lt;/p&gt;
&lt;h4 id=&quot;展望2018&quot;&gt;展望2018&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;1.持续学习和实践DDD争取把原著再读一边，感觉第一遍有的地方明白了，有的地方还是似懂非懂的，争取吃透原著的精神，尽早抵达大牛们所说的“无之用”的境界（意淫一下哈哈）。&lt;br/&gt;2.继续梳理自己的基础短板，俗话说的好地基都打不结实，又怎么建造高楼大厦；&lt;br/&gt;3.跟进.netCore 2.0，2.0版本api也丰富了很多，虽然目前公司内还没有开始，但这应该会是以后.net方向的主流。&lt;br/&gt;4.计划看DCI,重构等相关方面的书。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最后，我们对自己真的要有个小目标，去不断的完善自我，超越自我，18年做最更好的自己！&lt;/p&gt;
</description>
<pubDate>Sun, 31 Dec 2017 07:15:00 +0000</pubDate>
<dc:creator>Nuss</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Nuss/p/8157761.html</dc:identifier>
</item>
<item>
<title>vue使用国际化 - 朱小杰</title>
<link>http://www.cnblogs.com/zhuxiaojie/p/8157720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuxiaojie/p/8157720.html</guid>
<description>&lt;p&gt;转载请注明作者与出处&lt;/p&gt;
&lt;h2 id=&quot;一安装vue-i18n&quot;&gt;一：安装vue-i18n&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;npm install vue&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;i18n &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;save&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;二定义不同语言的json语言包&quot;&gt;二：定义不同语言的json语言包&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一般把它放到npm工程中的src目录下，因为这个目录是要进行编译的，而我们是需要把这些语言包全部编译进去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在src建立一个local文件夹，然后建立两个文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;language-en.js 英文&lt;/li&gt;
&lt;li&gt;language-cn.js 中文&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们不一定非要按照国际语言规范来命令，比如我们直接命名为abc.js也可以，只需要在对应的关系中读取这个js文件即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;er&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;message&lt;/span&gt;  &lt;span class=&quot;er&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;view&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;configList&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;config list&quot;&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
 &lt;span class=&quot;er&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;er&quot;&gt;xx&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;xx&quot;&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;er&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;message&lt;/span&gt;  &lt;span class=&quot;er&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;视图&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;configList&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;配置列表&quot;&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
 &lt;span class=&quot;er&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;er&quot;&gt;xx&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;xx&quot;&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，对应的json结构需要保持一至，因为是要按照key来读取相应的value&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三配置json语言包&quot;&gt;三：配置json语言包&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;main.js&lt;/code&gt;在配置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; VueI18n &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'vue-i18n'&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Vue&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;use&lt;/span&gt;(VueI18n)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; i18n &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;VueI18n&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;locale&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'zh-cn'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//这个配置的是默认的语言包&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;messages&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;'zh-cn'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./local/language-zh.js'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;// 中文语言包&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;'en'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./local/language-en.js'&lt;/span&gt;)    &lt;span class=&quot;co&quot;&gt;// 英文语言包&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Vue&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'#app'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;i18n &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; i18n&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;四使用语言包&quot;&gt;四：使用语言包&lt;/h2&gt;
&lt;p&gt;既然我们配置了语言包，那我们使用的过程中，肯定就不能自己写文本内容了，而是要使用相应的key来定义&lt;/p&gt;
&lt;h3 id=&quot;在html中使用&quot;&gt;在html中使用&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; slot=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;header&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;clearfix&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&amp;gt;&lt;/span&gt;{{$t(&quot;message.global.view&quot;)}}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;在vue表达式中使用&quot;&gt;在vue表达式中使用&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;pie-data&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; :text=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;$t('message.index.configNumber')&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;202&lt;span class=&quot;kw&quot;&gt;&amp;lt;/pie-data&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;在js中使用&quot;&gt;在js中使用&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：这个&lt;code&gt;this&lt;/code&gt;是指vue对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;required &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;message &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;$t&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'message.config.addForm.tips.versionNotNull'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;trigger &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;blur&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 31 Dec 2017 06:58:00 +0000</pubDate>
<dc:creator>朱小杰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuxiaojie/p/8157720.html</dc:identifier>
</item>
<item>
<title>关于被微信屏蔽的说明以及对微信的建议 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8157692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8157692.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/35695/201712/35695-20171231110812007-1401983420.jpg&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于最近有肇事者恶意利用我们的博客在腾讯帝国的领土——微信上发布虚假红包信息，我们的 www 域名被腾讯帝国的微信法院判刑，关押进微信浏览器设立的大牢，造成所有博文在腾讯统领之下拥有绿色上网环境的微信世界无法被访问，由此给您带来很大的麻烦，请您谅解。&lt;/p&gt;
&lt;p&gt;在被关押进大牢之后，我们才知道我们的罪行——纵容肇事者危害微信世界的绿色上网环境。我们深感罪孽深重，进行了深刻的自我检讨，采取了改过自新的行动，处理了已经找出的涉及虚假微信红包的内容（已找出的部分博文标题如下），并向腾讯联邦最高法院提起了上诉，但由于法官大人受理需要3个工作日，正值元旦假期，目前无任何消息。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;元旦佳节，提前献礼！！　&lt;br/&gt;红包领取中&lt;br/&gt;红包啪啪啪&lt;br/&gt;红包加载中&lt;br/&gt;红包大派送&lt;br/&gt;红包大礼包&lt;br/&gt;欢迎领取红包！10亿放送正在进行中...　　　　　　　　　　　　　　　　　　　　　　　　　　...&lt;br/&gt;红包领取中&lt;br/&gt;红包大礼包&lt;br/&gt;红包大派送&lt;br/&gt;红包加载中&lt;br/&gt;恭喜您获得了一个红包&lt;br/&gt;长按识别二维码领取红包！&lt;br/&gt;最新红包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于这次的教训，我们会进一步加强审核，改进系统，尽可能减少给肇事者的可趁之机。&lt;/p&gt;
&lt;p&gt;另外，作为一个手无缚鸡之力的孤岛小站，仰望着万马平川、边疆无际的互联网帝国，心存一丝希望地提出一个建议。建议像 Google 那样提供一个网站管理员工具，当发现违反微信规定的内容时，先屏蔽当前违规内容的网址，并通知网站管理员，这样负责任的网站管理员可以及时处理违规内容并采取防范措施，对于没有及时处理或情节严重的网站才采取屏蔽域名的下策。更进一步的可以提供关键词或工具帮助网站检测违反微信规定的内容，甚至可以推出一个微信盾的云服务。&lt;/p&gt;
&lt;p&gt;本文微信可访问地址：&lt;a href=&quot;https://cmt.cnblogs.com/p/8157692.html&quot; target=&quot;_blank&quot;&gt;https://cmt.cnblogs.com/p/8157692.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 31 Dec 2017 06:55:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8157692.html</dc:identifier>
</item>
<item>
<title>JAVA中的构造函数 - 曾将</title>
<link>http://www.cnblogs.com/GH0522/p/8157702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GH0522/p/8157702.html</guid>
<description>&lt;p&gt;&lt;span&gt;1：构造器是干什么的？？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;构造器最大的用处就是在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2：使用构造器时需要记住：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）&lt;/p&gt;
&lt;p&gt;2.每个类可以有一个以上的构造器；&lt;/p&gt;
&lt;p&gt;3.构造器可以有0个、1个或1个以上的参数；&lt;/p&gt;
&lt;p&gt;4.构造器没有返回值；&lt;/p&gt;
&lt;p&gt;5.构造器总是伴随着new操作一起调用；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3：构造器的调用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;调用无参的构造器：如&lt;/p&gt;
&lt;p&gt;　　我们先创建一个Father类，体提供一个无参的构造器，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Constructor;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Father {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Father() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(&quot;调用了这个构造器&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们去创建测试类，去new这个对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Constructor;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         Father F1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Father();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们直接运行，会发现构造器被调用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171231135517976-679107564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到我们信new一个对象的时候，这个时候就会默认调用空的构造函数，然后初始化这个对象，其实new一个对象就是在堆中给开辟了一个新的内存空间，里面存放的是这个对象的信息，然后栈中存放的是句柄，这个句柄对应着堆中对象所在的位置。&lt;/p&gt;

&lt;p&gt;如果我们自定义了构造函数了，则调用的时候就不会自动调用无参的构造函数了，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171231141208195-1281735788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;调用有参的构造器：如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Constructor;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Father {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Father(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String sex) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;调用了有三个参数的构造函数&quot;+name+&quot;--&quot;+age+&quot;--&quot;+&lt;span&gt;sex);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Father(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;调用了有三个参数的构造函数&quot;+name+&quot;--&quot;+&lt;span&gt;age);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt;     
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Father(String name) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         System.out.println(&quot;调用了有三个参数的构造函数&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这里我们可以看到我们重载的构造的方法，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171231141427601-222816198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Constructor;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         Father F1=&lt;span&gt;new&lt;/span&gt; Father(&quot;GH&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;         Father F2=&lt;span&gt;new&lt;/span&gt; Father(&quot;GH&quot;,12,&quot;男&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         Father F3=&lt;span&gt;new&lt;/span&gt; Father(&quot;GH&quot;,19&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们运行一下看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171231141638273-1186001952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 子类调用父类的构造函数：&lt;/p&gt;
&lt;p&gt;使用super调用父类构造器的语句必须是子类构造器的第一条语句&lt;/p&gt;
&lt;p&gt;如果子类构造器没有显式地调用父类的构造器，则将自动调用父类的默认（没有参数）的构造器。如果父类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用父类的构造器，则java编译器将报告错误&lt;/p&gt;
&lt;p&gt; 如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171231143850163-2098860830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给父类加上空的构造方法，编译就能通过；&lt;/p&gt;

&lt;p&gt;默认调用父类无参的构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Father() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         System.out.println(&quot;子类默认调用父类的无参构造函数&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Father{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         Son s=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Son();    
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171231144153695-1030257957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们能使用super关键字，进行对父类的构造函数进行自定义的调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Constructor;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Father{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Son(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String sex) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name, age, sex);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Constructor;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         Son s=&lt;span&gt;new&lt;/span&gt; Son(&quot;aaa&quot;, 12, &quot;女&quot;&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171231144620617-1642210763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 关于构造器就那么多了；&lt;/p&gt;

</description>
<pubDate>Sun, 31 Dec 2017 06:49:00 +0000</pubDate>
<dc:creator>曾将</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GH0522/p/8157702.html</dc:identifier>
</item>
<item>
<title>laravel and lumen  软删除操作 - 淡定的小孩</title>
<link>http://www.cnblogs.com/jingying/p/8144343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingying/p/8144343.html</guid>
<description>&lt;p&gt;知识都是有联系的，这绝对是真理。作为一名小白，看了一点官方文档，把我自己理解的软删除操作给大家讲讲。有些就是套用官方文档的话。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义&lt;/strong&gt;:&lt;/span&gt;什么是软删除呢，所谓软删除指的是数据表记录并未真的从数据库删除，而是将表记录的标识状态标记为软删除，这样在查询的时候就可以加以过滤，让对应表记录看上去是被”删除“了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通俗易懂说法：&lt;/strong&gt;数据库的表中&lt;strong&gt;，&lt;/strong&gt;使用了一个日期字段作为标识状态，这个日期字段可以自定义，这里我们使用&lt;code&gt;deleted_at&lt;/code&gt;，如果对应模型被软删除，则该条记录的&lt;code&gt;deleted_at&lt;/code&gt;字段的值为删除时间，否则该值为空。&lt;/p&gt;
&lt;p&gt;开始操作：&lt;/p&gt;
&lt;p&gt;我选择使用laravel 做示例，因为lumen的artisan命令太少。主要是原理！！！&lt;/p&gt;
&lt;p&gt;添加model文件，并创建blog_users表.&lt;/p&gt;
&lt;p&gt;运行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
php artisan make:model blogUser --migration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1162660/201712/1162660-20171231141242617-1420932053.png&quot; alt=&quot;&quot; width=&quot;1423&quot; height=&quot;772&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 现在，已经生成了model文件，还有迁移文件。&lt;/p&gt;
&lt;p&gt;我们用命令生成数据表，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
 php artisan migrate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images2017.cnblogs.com/blog/1162660/201712/1162660-20171231141658601-384052179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在还差一个字段，就是deleted_at字段。继续命令，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
php artisan make:migration alter_posts_deleted_at --table=blog_users
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1162660/201712/1162660-20171231142113710-95430555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后编辑生成的PHP文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AlterPostsDeletedAt extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('blog_users', function (Blueprint $table) {
            //我新加部分如下一行
            $table-&amp;gt;softDeletes();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('blog_users', function (Blueprint $table) {
            //
        });
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得在migrations 文件夹中，把生成表的那个文件删掉，在继续执行如下命令，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
php artisan migrate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1162660/201712/1162660-20171231142633663-912136700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你看deleted_at字段出来了吧。&lt;/p&gt;
&lt;p&gt;好了，我要写代码了，不命令行了，哈哈哈。&lt;/p&gt;
&lt;p&gt;在blogUser文件中，引用软删除，并配置。&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php

namespace App;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class blogUser extends Model
{
    //使用软删除
    use SoftDeletes;
    //设置表名
    public $table = 'blog_users';
    //设置主键
    public $primaryKey = 'id';&lt;br/&gt;protected $dates = ['deleted_at'];
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　现在，我们去控制器中吧，看看软删除好了没。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php

namespace App\Http\Controllers;
use App\blogUser;

class BlogUsedController extends Controller
{
    public function softdel(){
        $post = blogUser::find(1);
        $post-&amp;gt;delete();
        if($post-&amp;gt;trashed()){
            echo '软删除成功！';
            dd($post);
        }else{
            echo '软删除失败！';
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1162660/201712/1162660-20171231144425460-701822669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;lumen 也是这个原理，到时候，你数据表就手动创建，别用命令生成。model代码与控制器代码是主要的。&lt;/p&gt;
&lt;p&gt;结束了，大功告成，如有不理解地方，请评论留言。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Sun, 31 Dec 2017 06:48:00 +0000</pubDate>
<dc:creator>淡定的小孩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingying/p/8144343.html</dc:identifier>
</item>
<item>
<title>java中的参数传递是按引用传递还是按值传递 - 衣带渐宽终不悔</title>
<link>http://www.cnblogs.com/yidaijiankuanzhongbuhui/p/8157562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yidaijiankuanzhongbuhui/p/8157562.html</guid>
<description>&lt;p&gt;　　最近去面试，有一个面试官问到java中参数传递的问题，感觉自己对于这一块还是理解的不够深。今天我们就一起来学习一下Java中的接口和抽象类。下面是本文的目录大纲：&lt;/p&gt;
&lt;p&gt;一 . 什么是按值传递，什么是按引用传递&lt;/p&gt;
&lt;p&gt;二 . java中的参数传递是按值传递还是按引用传递&lt;/p&gt;
&lt;p&gt;三．总结&lt;/p&gt;

&lt;p&gt;若有不正之处，请多多谅解并欢迎批评指正，不甚感激。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一 . 什么是按值传递，什么是按引用传递&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;按值调用(call by value) ：&lt;/span&gt; 在参数传递过程中，形参和实参占用了两个完全不同的内存空间。形参所存储的内容是实参存储内容的一份拷贝&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;按值传递在基本数据类型数据传递中比较好理解，测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; age = 0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;before change age=&quot;+&lt;span&gt;age);
        change(age);
        System.out.println(&lt;/span&gt;&quot;after change age=&quot;+&lt;span&gt;age);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; change(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a){
        a&lt;/span&gt;=20&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;before change age=0&lt;br/&gt;after change age=0&lt;/p&gt;
&lt;p&gt;这个结果相信很多朋友已经猜到：因为在main方法中调用change(age)时，真正传递给change方法的参数只是age的一个副本，所以修改这个副本，并不能修改原来age的值。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;按引用调用：在参数传递的过程中，形参和实参完全是同一块内存空间，两者不分彼此。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;main()
{
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
 func(&lt;/span&gt;&amp;amp;&lt;span&gt;a);
 printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a);
}
func(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;b)
{
 &lt;/span&gt;*b=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;咳咳，这貌似是C语言的按引用传递。java的安引用传递写不出来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二. java中的参数传递是按值传递还是按引用传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在下结论之前，我们还是看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PassByValue {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;PassByValue [name=&quot; + name + &quot;]&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        PassByValue myDear &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PassByValue();
        myDear.setName(&lt;/span&gt;&quot;dontKnow&quot;&lt;span&gt;);
        String mylove  &lt;/span&gt;=&quot;dontKnow&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; herAge=0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;myDear name=&quot;+&lt;span&gt;myDear.getName());
        System.out.println(&lt;/span&gt;&quot;myLove =&quot;+&lt;span&gt;mylove);
        System.out.println(herAge);
        stringChange(mylove,myDear,herAge);
        System.out.println(&lt;/span&gt;&quot;============================================================&quot;&lt;span&gt;);
        System.out.println(&quot;myDear name=&quot;+myDear.getName())
        System.out.println(mylove);&lt;br/&gt;　　　　　System.out.println(herAge)&lt;br/&gt;　　　　　
        &lt;/span&gt;&lt;span&gt;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; stringChange(String a,PassByValue b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age){
        a&lt;/span&gt;=&quot;gaoshan&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一句相当于a=new String(&quot;gaoshan&quot;)&lt;/span&gt;
        b.setName(&quot;gaoshan&quot;&lt;span&gt;);&lt;br/&gt;　　　　　age=20;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果如下&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;myDear name=dontKnow&lt;br/&gt;myLove =dontKnow&lt;br/&gt;0&lt;br/&gt;============================================================&lt;br/&gt;myDear name=gaoshan&lt;br/&gt;myLove =dontKnow&lt;br/&gt;0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现，myDear 中的ｎａｍｅ　属性通过&lt;span&gt;stringChange（）方法改变了，ｍｙＬｏｖｅ的值并没有改变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有一个疑问：myDear和mｙｌｏｖｅ　都是引用数据类型，为什么myDear的属性值会改变，而ｍｙｌｏｖｅ　没有改变呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实原因在注释中已经说了：在stringChange方法中，&lt;span&gt;a=&quot;gaoshan&quot;;这一句等价于&lt;/span&gt;a=new String(&quot;gaoshan&quot;)，实际上ａ作为数据引用发生了改变，指向了一个新的内存地址，而myDear作为数据引用，并没有发生改变，仍然指向ｍａｉｎ方法中myDear所指向的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在ｊａｖａ中，不存在按引用调用，因为在参数传递过程中，不管传递的是基本数据类型的变量，还是对象的引用，其实都是传递的一个副本。&lt;/p&gt;
&lt;p&gt;在上面的例子中，myDear 所指向的对象之所以会发生改变，是因为在stringChange方法中，通过myDear 的副本ｂ对myDear 所指向的对象进行操作，改变了对象属性，但是&lt;/p&gt;
&lt;p&gt;myDear 本身作为对象引用并没有发生改变。而myLove 没有发生改变是因为在stringChange方法中直接改变了myLove 副本ａ的值，并没有对myLove 所指向的对象进行修改，所以我们看到　&lt;span&gt;&lt;span&gt;main方法中的&lt;/span&gt;myLove所指向的对象并没有发生改变&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;本文参考&lt;/p&gt;
&lt;p&gt;java参数传递（超经典）：http://blog.sina.com.cn/s/blog_4b622a8e0100c1bo.html&lt;/p&gt;

</description>
<pubDate>Sun, 31 Dec 2017 05:32:00 +0000</pubDate>
<dc:creator>衣带渐宽终不悔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yidaijiankuanzhongbuhui/p/8157562.html</dc:identifier>
</item>
<item>
<title>【博客美化】新年啦，给自己博客加个雪花效果吧~ - YJLAugus</title>
<link>http://www.cnblogs.com/yjlblog/p/8157414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjlblog/p/8157414.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;今天是2017 的最后一天，首先祝福大家新年快乐，能在自己新的一年里开心快乐，幸福~。转眼间，又到了白雪飘飞的冬季，相信好多地方都下雪了吧~，突发奇想，给自己博客加上了雪花飘落效果。当然了，有写的不好的地方，大家打我就好~~&lt;/p&gt;
&lt;h3 id=&quot;效果预览&quot;&gt;效果预览&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yjlblog/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/yjlblog/&lt;/a&gt; (本来想着上传一个gif..好像是太大了...就上传失败了)&lt;/p&gt;
&lt;h3 id=&quot;食用方法&quot;&gt;食用方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;添加js文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）前提是开通了&lt;code&gt;权限&lt;/code&gt;哦，然后把 &lt;code&gt;xue.js&lt;/code&gt;文件上传到自己博客中；&lt;br/&gt;（2）创建画布(放在页尾)；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;Snow&quot;&amp;gt;
    &amp;lt;canvas id=&quot;Snow&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;引入js文件(放在页尾)；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
&amp;lt;script src=&quot;https://files.cnblogs.com/files/yjlblog/xue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(function() {
    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame ||
    function(callback) {
        window.setTimeout(callback, 1000 / 60);
    };
    window.requestAnimationFrame = requestAnimationFrame;
})();

(function() {
    var flakes = [],
        canvas = document.getElementById(&quot;Snow&quot;), //画布ID，与上一步创建的画布对应
        ctx = canvas.getContext(&quot;2d&quot;),
        flakeCount = 200,  //雪花数量，数值越大雪花数量越多
        mX = -100,
        mY = -100;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    function snow() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (var i = 0; i &amp;lt; flakeCount; i++) {
            var flake = flakes[i],
                x = mX,
                y = mY,
                minDist = 150,  //雪花距离鼠标指针的最小值，小于这个距离的雪花将受到鼠标的排斥
                x2 = flake.x,
                y2 = flake.y;

            var dist = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)),
                dx = x2 - x,
                dy = y2 - y;

            if (dist &amp;lt; minDist) {
                var force = minDist / (dist * dist),
                    xcomp = (x - x2) / dist,
                    ycomp = (y - y2) / dist,
                    deltaV = force / 2;

                flake.velX -= deltaV * xcomp;
                flake.velY -= deltaV * ycomp;

            } else {
                flake.velX *= .98;
                if (flake.velY &amp;lt;= flake.speed) {
                    flake.velY = flake.speed
                }
                flake.velX += Math.cos(flake.step += .05) * flake.stepSize;
            }

            ctx.fillStyle = &quot;rgba(255,255,255,&quot; + flake.opacity + &quot;)&quot;;  //雪花颜色
            flake.y += flake.velY;
            flake.x += flake.velX;

            if (flake.y &amp;gt;= canvas.height || flake.y &amp;lt;= 0) {
                reset(flake);
            }

            if (flake.x &amp;gt;= canvas.width || flake.x &amp;lt;= 0) {
                reset(flake);
            }

            ctx.beginPath();
            ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
            ctx.fill();
        }
        requestAnimationFrame(snow);
    };

    function reset(flake) {
        flake.x = Math.floor(Math.random() * canvas.width);
        flake.y = 0;
        flake.size = (Math.random() * 3) + 2;  //加号后面的值，雪花大小，为基准值，数值越大雪花越大
        flake.speed = (Math.random() * 1) + 0.5;  //加号后面的值，雪花速度，为基准值，数值越大雪花速度越快
        flake.velY = flake.speed;
        flake.velX = 0;
        flake.opacity = (Math.random() * 0.5) + 0.3;  //加号后面的值，为基准值，范围0~1
    }

    function init() {
        for (var i = 0; i &amp;lt; flakeCount; i++) {
            var x = Math.floor(Math.random() * canvas.width),
                y = Math.floor(Math.random() * canvas.height),
                size = (Math.random() * 3) + 2,  //加号后面的值，雪花大小，为基准值，数值越大雪花越大
                speed = (Math.random() * 1) + 0.5,  //加号后面的值，雪花速度，为基准值，数值越大雪花速度越快
                opacity = (Math.random() * 0.5) + 0.3;  //加号后面的值，为基准值，范围0~1

            flakes.push({
                speed: speed,
                velY: speed,
                velX: 0,
                x: x,
                y: y,
                size: size,
                stepSize: (Math.random()) / 30 * 1,  //乘号后面的值，雪花横移幅度，为基准值，数值越大雪花横移幅度越大，0为竖直下落
                step: 0,
                angle: 180,
                opacity: opacity
            });
        }

        snow();
    };

    document.addEventListener(&quot;mousemove&quot;, function(e) {
        mX = e.clientX,
        mY = e.clientY
    });
    window.addEventListener(&quot;resize&quot;, function() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    init();
})();

添加样式&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;添加样式（自定义css，背景颜色可以自己改变）；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#Snow{
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 99999;
    background: rgba(125,137,95,0.1);
    pointer-events: none;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;相关文件&quot;&gt;相关文件&lt;/h3&gt;
&lt;h3 id=&quot;声明&quot;&gt;声明&lt;/h3&gt;
&lt;p&gt;部分资源来源网络，如有写的不对之处，欢迎大家指正~~感激不尽~&lt;/p&gt;
</description>
<pubDate>Sun, 31 Dec 2017 04:19:00 +0000</pubDate>
<dc:creator>YJLAugus</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjlblog/p/8157414.html</dc:identifier>
</item>
<item>
<title>SpringMVC 返回json的两种方式 - 东窗白</title>
<link>http://www.cnblogs.com/ct-csu/p/8157418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ct-csu/p/8157418.html</guid>
<description>&lt;p&gt;前后台数据交互使用json是一种很重要的方式.本文主要探讨SpringMVC框架使用json传输的技术.&lt;/p&gt;
&lt;p&gt;请注意,本文所提到的项目使用Spring 版本是4.1.7,其他版本在具体使用上可能有不一样的情况.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、最常见——使用@RequestBody的注解返回一个实体对象;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用方式如下:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1:引入jar包：&lt;/p&gt;
&lt;p&gt;jackson-core、jackson-databind、jackson-annotion;&lt;/p&gt;
&lt;p&gt;Spring4以上的版本这么配置,需要jackson的版本在2以上.&lt;/p&gt;
&lt;p&gt;maven依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;properties&amp;gt;&lt;br/&gt;&amp;lt;jackson.version&amp;gt;2.7.3&amp;lt;/jackson.version&amp;gt;&lt;br/&gt;&amp;lt;/properties&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${jackson.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-databind&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${jackson.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-annotations&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${jackson.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2:Spring配置:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Spring4以上版本使用 &amp;lt;mvc:annotation-driven/&amp;gt;即包含了默认的配置,能够转化json,其他版本可能需要额外配置.&lt;/p&gt;
&lt;p&gt;3:后台:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RequestMapping(&quot;/entity&quot;)
    public &lt;strong&gt;@ResponseBody&lt;/strong&gt; Entity returnJson(){
        return new Entity(&quot;chentao&quot;,&quot;A handsome man&quot;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键就是@ResponseBody注解,否则Spring会去映射与路径匹配的jsp文件&lt;/p&gt;
&lt;p&gt;4:前台&lt;/p&gt;
&lt;p&gt;这个路径是可以直接调用的,结果会直接输出到,但是一般来说,会使用jquery Ajax来获取数据:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Welcome Page&amp;lt;/title&amp;gt;
    &amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&amp;gt;&lt;/span&gt;
    &amp;lt;&lt;span&gt;script
            src&lt;/span&gt;=&quot;https://code.jquery.com/jquery-3.2.1.min.js&quot;&lt;span&gt;
            integrity&lt;/span&gt;=&quot;sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=&quot;&lt;span&gt;
            crossorigin&lt;/span&gt;=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
     &amp;lt;h2&amp;gt;Hello World!&amp;lt;/h2&amp;gt;
&amp;lt;div id=&quot;div1&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;strong&gt;&amp;lt;script&amp;gt;&lt;span&gt;
    $.get(&lt;/span&gt;&quot;/json/entity&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        $(&lt;/span&gt;&quot;#div1&quot;&lt;span&gt;).html(data);
    })
&lt;/span&gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;a:不添加@ResponseBody注解的情况,通过链接注解访问:&lt;/p&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1081672/201712/1081672-20171231111144054-451071888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Spring MVC框架这个时候去找/json/entity.jsp这个文件的.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b:添加@ResponseBody注解后:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1081672/201712/1081672-20171231111647913-420436837.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;json数据能正确返回了.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、更加灵活的方式——将json数据放进Request中交互。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Spring MVC使用@ResponseBody的方式确实很简单，但是我们有时也会遇到这样的场景 ，就是访问一个新页面时，可能既要找到新的页面又要拿到新的数据去绘制页面。&lt;/p&gt;
&lt;p&gt;这种时候如果使用@ResponseBody这种方式，那么就需要使用ajax技术，向后台请求两次，一次请求页面，一次请求数据。&lt;/p&gt;
&lt;p&gt;如果希望通过一次请求就完成这个目标，那么就应该返回一个ModelAndView的对象，这样SpringMVC既可以跳转到一个页面，也能把数据传输到Request中。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;p&gt;1：相关jar包：&lt;/p&gt;
&lt;p&gt;使用对象转化为Json的相关jar包，一般来说使用的时json-lib，实际上类似的框架和技术还有很多，比如上面的jackson就能做，不过笔者习惯于使用json-lib，使用起来会更方便和顺手一点。&lt;/p&gt;
&lt;p&gt;maven:   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/net.sf.json-lib/json-lib &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.sf.json-lib&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;json-lib&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2：Spring 配置：无&lt;/p&gt;
&lt;p&gt;3：后台：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/page&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView returnView(){
        ModelAndView mv &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
        mv.setViewName(&lt;/span&gt;&quot;showJson&quot;&lt;span&gt;);

        Entity entity &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Entity(&quot;chentao&quot;,&quot;a handsome man&quot;&lt;span&gt;);

        &lt;strong&gt;JSONObject entityJson &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; JSONObject.fromObject(entity);&lt;/strong&gt;

        mv.addObject(&lt;/span&gt;&quot;entityJson&quot;&lt;span&gt;,entityJson);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键是JSONObject.fromObject()方法。&lt;/p&gt;
&lt;p&gt;4：前台：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; ${entityJson};
    alert(json);
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里的El表达式写法${entityJson},浏览器在进行渲染之前，tomcat已经将${entityJson}替换为json字符串。这个时候json直接就是一个可以使用的对象而不再需要进行转化&lt;/p&gt;
&lt;p&gt;结果如下；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1081672/201712/1081672-20171231120228992-362770921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意，这种方式只有在jsp页面中才有效果，如果不是jsp页面，只能乖乖使用第一种方式了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;@Response注解的方式&lt;/td&gt;
&lt;td&gt;返回ModelAndView方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;优点&lt;/td&gt;
&lt;td&gt;编写简单；适合当前ajax方式；&lt;/td&gt;
&lt;td&gt;更加灵活，页面和数据一同返回。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;缺点&lt;/td&gt;
&lt;td&gt;灵活性不足&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;需要手动转化json；&lt;/p&gt;
&lt;p&gt;前台接受数据只能用在jsp页面里。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;实现要点&lt;/td&gt;
&lt;td&gt;@ResponseBody;jackson-jar包；ajax；&lt;/td&gt;
&lt;td&gt;JsonObject.fromObject();El表达式：${}.&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文档使用的是SpringMVC框架，实际上第一种方式本质上是使用Response的writer对象来传递数据，而第二种方式使用request传递数据。所以如果使用原生servlet或者其他框架也是能够实现类似的功能的。&lt;/p&gt;

</description>
<pubDate>Sun, 31 Dec 2017 04:17:00 +0000</pubDate>
<dc:creator>东窗白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ct-csu/p/8157418.html</dc:identifier>
</item>
</channel>
</rss>