<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SQL 牛刀小试 1 —— 查询操作 - 落雨心星</title>
<link>http://www.cnblogs.com/52lxl-top/p/9750320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52lxl-top/p/9750320.html</guid>
<description>&lt;p&gt;&lt;span&gt;#创建数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;create database ST CHARACTER set utf8;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#创建用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;create user ST identified by '19980510';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#授权用户操作该数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;grant all on ST.* to ST;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;----------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#创建学生表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;create table Student&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Sno char(9) primary key ,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Sname char(20) not null,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Ssex char(2),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Sage smallint,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Sdept char(20)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#插入信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Student(Sno,Sname,Ssex,Sage,Sdept) values(201215121,'李勇','男',20,'CS');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Student(Sno,Sname,Ssex,Sage,Sdept) values(201215122,'刘晨','女',19,'CS');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Student(Sno,Sname,Ssex,Sage,Sdept) values(201215123,'王敏','女',18,'MA');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Student(Sno,Sname,Ssex,Sage,Sdept) values(201215125,'张立','男',19,'IS');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#创建课程表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;create table Course&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Cno char(4) primary key,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Cname char(40) not null,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Cpno char(4),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Ccredit smallint,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;foreign key(Cpno) references Course(Cno)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#插入信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Cpno,Ccredit) values(1,'数据库',5,4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Cpno,Ccredit) values(2,'数学',,2);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Cpno,Ccredit) values(3,'信息系统',1,4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Cpno,Ccredit) values(4,'操作系统',6,3);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Cpno,Ccredit) values(5,'数据结构',7,4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Cpno,Ccredit) values(6,'数据处理',,2);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Cpno,Ccredit) values(7,'PASCAL语言',6,4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/*&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[SQL]insert into Course(Cno,Cname,Cpno,Ccredit) values(1,'数据库',5,4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[Err] 1452 - Cannot add or update a child row: a foreign key constraint fails (`st`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`Cpno`) REFERENCES `course` (`Cno`))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- 解决方法 先不录入先修课（Cpno）的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Ccredit) values(1,'数据库',4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Ccredit) values(2,'数学',2);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Ccredit) values(3,'信息系统',4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Ccredit) values(4,'操作系统',3);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Ccredit) values(5,'数据结构',4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Ccredit) values(6,'数据处理',2);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into Course(Cno,Cname,Ccredit) values(7,'PASCAL语言',4);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#创建选课表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;create table SC&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Sno char(9),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Cno char(4),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Grade smallint,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;primary key(Sno,Cno),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;foreign key(Sno) references Student(Sno),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;foreign key(Cno) references Course(Cno)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#插入信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into SC(Sno,Cno,Grade) values(201215121,1,92);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into SC(Sno,Cno,Grade) values(201215121,2,85);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into SC(Sno,Cno,Grade) values(201215121,3,88);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into SC(Sno,Cno,Grade) values(201215122,2,90);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into SC(Sno,Cno,Grade) values(201215122,3,80);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;--------------------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询全体学生的学号和姓名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno,Sname from Student ;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询全体学生的姓名、学号、所在系&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sno,Sdept from Student;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询全体学生的详细记录 （查询经过计算的值）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from Student;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询全体学生的姓名及其出生年份&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,2018-Sage from Student;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询全体学生的姓名、出生年份和所在院系，要求用小写字母表示系名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,2018-Sage,lower(Sdept) from Student;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修了课程的学生学号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno from SC; -- select all Sno from SC; -- 有重复&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select distinct Sno from SC; -- 无重复&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询计算机科学系全体学生的名单&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from Student where Sdept = 'CS';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询所有年龄在20岁以下的学生姓名及其年龄&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sage from Student where Sage&amp;lt;20;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询考试成绩不合格的学生的学号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno from SC where Grade&amp;lt;60;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询年龄在20——23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sdept,Sage from Student where Sage&amp;gt;=20 and Sage&amp;lt;=23;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sdept,Sage from Student where Sage between 20 and 23;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询年龄不在20——23岁之间的学生姓名、系别和年龄&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sdept,Sage from Student where Sage not between 20 and 23;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Ssex from Student where Sdept in('CS','MA','IS');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Ssex from Student where Sdept='CS' or Sdept='MA' or Sdept='IS';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询既不是计算机科学系、数学系、也不是信息系的学生的姓名和性别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Ssex from Student where Sdept not in('CS','MA','IS');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询学号为201215121的学生的详细情况&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from Student where Sno like '201215121';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from Student where Sno='201215121';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- 注意：如果like后面的匹配串中不含通配符，则可以用 = （等于）运算符取代 like 谓词，用 != 或 &amp;lt;&amp;gt; （不等于）运算符取代 not like 谓词&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询所有姓刘的学生的姓名、学号和性别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sno,Ssex from Student where Sname like '刘%';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询姓“欧阳”且全名为三个汉字的学生的姓名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname from Student where Sname like '欧阳_';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- 注意：数据库字符集为ASCII时一个汉字需要两个 _ ; 当字符集为GBK是只需要一个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询名字中第二个字为“阳”的学生的姓名和学号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sno from Student where Sname like '%阳%';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询所有不姓刘的学生的姓名、学号和性别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sno,Ssex from Student where Sname not like '刘%';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询DB_Design课程的课程号和学分&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Cno,Ccredit from Course where Cname like 'DB\_Design' escape '\\';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询以“DB_”开头，且倒数第三个字符为i的课程的详细情况&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from Course where Cname like 'DB\_%' escape '\\';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。查询缺少成绩的学生的学号和相应的课程号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno,Cno from SC where Grade is null; -- 注意这里的“IS”不能用 = （等号）代替&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询计算机科学系年龄在20岁以下的学生姓名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname from Student where Sdept = 'CS' and Sage&amp;lt;20;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修了3号课程的学生的学号及其成绩，查询结果按分数的降序排列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno,Grade from SC where Cno='3' order by Grade desc; -- 降序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno,Grade from Sc where Cno='3' order by Grade asc; -- 升序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/*&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询全体学生情况，查询结果按所在系的系号升序排列，同一系中学生按年龄降序排列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from Student where order by Sdept,Sage desc; -- 默认为升序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[SQL]select * from Student where order by Sdept,Sage desc;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'order by Sdept,Sage desc' at line 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询学生总人数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select count(*) from Student;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修了课程的学生人数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select count(distinct Sno) from sc;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#计算选修1号课程的学生平均成绩&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select avg(Grade) from SC where Cno = '1';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修1号课程的学生最高分数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select max(Grade) from SC where Cno = '1';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询学生201215012选修课程的总学分数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select sum(Ccredit) from SC,Course where Sno = '201215122' and SC.Cno = Course.Cno;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#求各个课程号及相应的选课人数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Cno,count(*) from SC group by Cno;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- group by 子句将查询结果按某一列或多列的值分组，值相等的为一组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- 分组后聚集函数将作用于每一个组，即每一组都有一个函数值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修了三门以上课程的学生学号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno from SC group by Sno having count(*)&amp;gt;3;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- having 短语作用于组，从中选择满足条件的组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询平均成绩大于等于90分的学生学号和平均成绩&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno, avg(Grade) from SC where avg(Grade)&amp;gt;=90 group by Sno; -- 此句不正确,where子句中不能用聚集函数作为 条件表达式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno, avg(Grade) from SC group by Sno having avg(Grade)&amp;gt;=90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--------------------------------------------------------------- 连接查询&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询每个学生及其选修课程的情况&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.*,SC.* from Student,SC where Student.Sno = SC.Sno;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade from Student,SC where Student.Sno = SC.Sno; -- 自然连接实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修2号课程且成绩在90分以上的所有学生的学号和姓名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.Sno,Sname from SC,Student where Student.Sno = SC.Sno and SC.Cno='2' and SC.Grade &amp;gt;=90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select student.Sno,Sname from Student inner join SC on(student.Sno = SC.Sno) where Cno= '2' and Grade &amp;gt;=90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询每一门课的间接先修课（即先修课的先修课）.按照Cno降序排列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select first.Cno,second.Cpno from Course as first,Course as second where first.Cpno = second.Cno and Second.Cpno is NOT null order by first.Cno desc -- first,second 是Course表的两个别名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询全体学生的详细信息和所选课程号及成绩&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade from Student left outer join SC on (Student.Sno = SC.Sno);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.*,Cno,Grade from Student left outer join SC on (Student.Sno = SC.Sno);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;#查询每个学生的学号、姓名、选修的课程名及成绩&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.Sno,Student.Sname,Course.Cname,SC.Grade from Student,Course,SC where Student.Sno = SC.Sno and Course.Cno = SC.Cno;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--------------------------------------------------------------- 嵌套查询&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询与“刘晨”在同一个系学习的学生&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.* from Student where Sdept in (select Sdept from Student where Sname = '刘晨');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修了课程名为“信息系统”的学生学号和姓名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno,Sname from Student where Sno in (select Sno from SC where Cno in (select Cno from Course where Cname = '信息系统'));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Student.Sno,Sname from Student,Course,SC where Course.Cname = '信息系统' and Student.Sno = SC.Sno and Course.Cno = SC.Cno;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#找出每个学生超过他自己选修课程平均成绩的课程号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno,Cno from SC x where Grade &amp;gt;= (select avg(Grade) from SC y where y.Sno = x.Sno);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询非计算机科学系中比计算机科学系任意一个学生年龄小于的学生姓名和年龄&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sage from Student where Sage&amp;lt;any(select Sage from Student where Sdept = 'CS')and Sdept&amp;lt;&amp;gt;'CS';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sage from Student where Sage&amp;lt;(select max(Sage) from Student where Sdept = 'CS')and Sdept&amp;lt;&amp;gt;'CS';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名及年龄&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sage from Student where Sage&amp;lt;all(select Sage from Student where Sdept = 'CS')and Sdept&amp;lt;&amp;gt;'CS';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sage from Student where Sage&amp;lt;(select min(Sage) from Student where Sdept = 'CS')and Sdept&amp;lt;&amp;gt;'CS';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询所有选修了1号课程的学生姓名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname from Student where exists (select * from SC where Sno = student.Sno and Cno = '1');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Sno from Student where Sno in (select Sno from SC where Cno = '1');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sname,Student.Sno,Grade from Student,SC where  SC.Cno = '1' and student.Sno = SC.Sno;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询没有选修1号课程的学生姓名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select Sno,Sname from Student where not exists (select * from SC where Sno = student.Sno and Cno = '1');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修了全部课程的学生姓名&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询至少选修了学生201215122选修的全部课程的学生号码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;---------------------------------------------------------------- 集合查询&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- 注意：参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询计算机科学系的学生及年龄不大于19岁的学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询选修了课程1或者选修了课程2的学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#查询计算机科学系的学生与年龄不大于19岁的学生的交集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询既选修了课程1又选修了课2的学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#查询计算机科学系的学生与年龄不大于19岁的学生的差集&lt;/span&gt;&lt;br/&gt;2018-10-07 15:57:06&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 07:58:00 +0000</pubDate>
<dc:creator>落雨心星</dc:creator>
<og:description>#创建数据库create database ST CHARACTER set utf8;#创建用户create user ST identified by '19980510';#授权</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52lxl-top/p/9750320.html</dc:identifier>
</item>
<item>
<title>HashMap 的数据结构 - JavaRecorder</title>
<link>http://www.cnblogs.com/xmsx/p/9750299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmsx/p/9750299.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;HashMap 的数据结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组 + 链表（Java7 之前包括 Java7）&lt;/li&gt;
&lt;li&gt;数组 + 链表 + 红黑树（从 Java8 开始）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：这里的《&lt;a href=&quot;https://www.cnblogs.com/xmsx/p/9749004.html&quot;&gt;红黑树&lt;/a&gt;》与链表都是链式结构。&lt;/p&gt;
&lt;p&gt;HashMap 内部维护了一个数组，数组中存放链表的链首或红黑树的树根。&lt;/p&gt;
&lt;p&gt;当链表长度超过 8 时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能；在红黑树结点数量小于 6 时，红黑树转变为链表。&lt;/p&gt;
&lt;p&gt;下面分别为上面两种数据结构的图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p6586lvnw.bkt.clouddn.com/FvdmvW5dHnXltTWxegPjm3BwxEC7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p6586lvnw.bkt.clouddn.com/FiaNB1uW2gAuMivZWZaOMn3huQAz.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;【定位算法】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加、查找、删除等操作都需要先定位到 table 数组的某个索引处。&lt;/p&gt;
&lt;p&gt;定位算法为三步：取 key 的 hashCode 值、高位运算、取模运算得到索引位置。（代码如下）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final int hash(Object key) {
    int h;
    // h = key.hashCode() 第一步 取 hashCode 值
    // h ^ (h &amp;gt;&amp;gt;&amp;gt; 16)  第二步 高位参与运算 Java8 优化了高位算法，优化原理忽略
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}

// java7 中这是一个单独的方法，java8 没有了这个方法但是原理依旧
static int indexFor(int h, int length) {
    return h &amp;amp; (length-1); // hash(key) &amp;amp; (length-1)  第三步 取模
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取模运算&lt;code&gt;h &amp;amp; (length -1)&lt;/code&gt;的结果最大值为 length -1，不会出现数组下标越界的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;为什么要做高位运算？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 hashCode 值都大于 length，而且这些 hashCode 的低位变化不大，就会出现很多冲突，举个例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设数组的初始化容量为 16（10000），则 length -1 位 15（1111）。&lt;/li&gt;
&lt;li&gt;假设有几个对象的 hashCode 分别为 1100 10010、1110 10010、11101 10010，进行位运算的结果将是一致的，高位没有参与运算。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果所有元素中多数元素属于这种情况，将会导致元素分布不均匀，而对 hashCode 进行高位运算能解决这个问题，使高位对低位造成影响改变低位的值，从而变相地使高位也参与运算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【Q】负载因子与性能的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载因子默认值为&lt;code&gt;0.75&lt;/code&gt;，意味着当数组实际填充量占比达到&lt;code&gt;3/4&lt;/code&gt;时就该扩容了。&lt;/p&gt;
&lt;p&gt;负载因子越大，扩容次数必然越少，数组的长度越小，&lt;strong&gt;减少了空间开销&lt;/strong&gt;。这就会导致 hash 碰撞越多，&lt;strong&gt;增加查询成本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;默认值&lt;code&gt;0.75&lt;/code&gt;在时间和空间成本上寻求一种折衷。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;【Q】为什么要扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为随着元素量的增大，hash 碰撞的概率越来越大，虽然使用链地址法能够解决存储问题，但是长长的链表会让 HashMap 失去快速检索的优势，而扩容能解决这个问题。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 07:54:00 +0000</pubDate>
<dc:creator>JavaRecorder</dc:creator>
<og:description>[TOC] content HashMap 的数据结构： 数组 + 链表（Java7 之前包括 Java7） 数组 + 链表 + 红黑树（从 Java8 开始） PS：这里的《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xmsx/p/9750299.html</dc:identifier>
</item>
<item>
<title>#一些真相# 和自己握手言和,不要期盼另一片荒岛可以让你变成陆地 - 宛如ZZ</title>
<link>http://www.cnblogs.com/zienzir/p/9750276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zienzir/p/9750276.html</guid>
<description>&lt;p&gt;　　你必须知道,不是所有人都拜金,但所有人都看脸的.　　&lt;/p&gt;
&lt;p&gt;　　所以如果你的颜值不能征服对方,不要幻想自己的灵魂可以.&lt;/p&gt;
&lt;p&gt;　　你的灵魂首先也并不多么special,更谈不上高贵,只不过是沉溺在自己的光环内无法自拔.&lt;/p&gt;
&lt;p&gt;　　因为你知道外界看你是一个笑话.&lt;/p&gt;
&lt;p&gt;　　你的封闭不是因为不屑于外界,而是不被外界真正接受.&lt;/p&gt;
&lt;p&gt;　　所以,抛下幻想.不要再幻想现实中有任何悸动.&lt;/p&gt;
&lt;p&gt;　　毕竟连你觉得最自由的灵魂也难免如此.&lt;/p&gt;
&lt;p&gt;　　荷尔蒙,你可以通过器具.没什么羞耻的,不过是一个物种为了延续的一些副作用.&lt;/p&gt;
&lt;p&gt;　　既然不能通过soulmate或者至少body-fetish上的满足,依靠器具来释放有利于缓解压力.&lt;/p&gt;
&lt;p&gt;　　除此之外,你必须健身,保养好.&lt;/p&gt;
&lt;p&gt;　　因为不只是女生看脸,所有人都是.你的脸和身材也会影响自己生活的方方面面.&lt;/p&gt;
&lt;p&gt;　　你骨架已经成型,所以再好也不会好到哪里去.&lt;/p&gt;
&lt;p&gt;　　但至少干净,至少身材不夸张,至少可以让周围的人舒适.&lt;/p&gt;
&lt;p&gt;　　你必须承认,人与人之间的好感就是那么庸俗.基于外表和表面言行.&lt;/p&gt;
&lt;p&gt;　　我知道你不会放弃对soulmate的执念.&lt;/p&gt;
&lt;p&gt;　　但你必须做好这一生不会有的准备.&lt;/p&gt;
&lt;p&gt;　　你无须通过社交网络去矫情地幻想对方能通过你的暗示来感动,&lt;/p&gt;
&lt;p&gt;　　对方只会觉得你恶心.&lt;/p&gt;
&lt;p&gt;　　是的,恶心.&lt;/p&gt;
&lt;p&gt;　　他们甚至不会点赞,你喜欢的对方更会不屑于你的下贱,甚至觉得是骚扰.&lt;/p&gt;
&lt;p&gt;　　所以,适可而止在社交网络上发泄自己的情绪吧.&lt;/p&gt;
&lt;p&gt;　　但是这些空虚,你必须寻一些事情来做.&lt;/p&gt;
&lt;p&gt;　　敲代码,是你所喜欢的.但学习新东西总是无从下手.&lt;/p&gt;
&lt;p&gt;　　你至少还有十年可以有足够的时间精力去学习.&lt;/p&gt;
&lt;p&gt;　　那么技术/乐器/外语都是值得投入的东西.&lt;/p&gt;
&lt;p&gt;　　此外,如果孤独,你还可以通过直播来获取一些交流.&lt;/p&gt;

&lt;p&gt;==========================================&lt;/p&gt;

&lt;p&gt;　　我终于知道你为什么像是缺少一些东西,&lt;/p&gt;
&lt;p&gt;　　因为你花费太多精力去思考你的另一半.&lt;/p&gt;
&lt;p&gt;　　但是你必须要明白,你自己也可以是一个完整的人.&lt;/p&gt;
&lt;p&gt;　　虽然少些温馨,但至少多些坦白.&lt;/p&gt;
&lt;p&gt;　　所以最后,和自己握手言和吧.&lt;/p&gt;

&lt;p&gt;　　兴许,你体会到生活的趣味,便不会觉得那么孤独.&lt;/p&gt;
&lt;p&gt;　　我知道我是在骗你,因为我也无时不刻地认为每个人都是荒岛.&lt;/p&gt;
&lt;p&gt;　　你大概也寄希望于奇迹.觉得另一个人可以缓解你的孤独感.&lt;/p&gt;
&lt;p&gt;　　其实,我觉得两片连在一起的荒岛,&lt;/p&gt;
&lt;p&gt;　　不过依然也是荒岛.&lt;/p&gt;

&lt;p&gt;　　从此,做一个温柔而高冷的人吧.&lt;/p&gt;
&lt;p&gt;　　埋藏你的渴望,认真经营自己的生活.&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 07:44:00 +0000</pubDate>
<dc:creator>宛如ZZ</dc:creator>
<og:description>你必须知道,不是所有人都拜金,但所有人都看脸的. 所以如果你的颜值不能征服对方,不要幻想自己的灵魂可以. 你的灵魂首先也并不多么special,更谈不上高贵,只不过是沉溺在自己的光环内无法自拔. 因为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zienzir/p/9750276.html</dc:identifier>
</item>
<item>
<title>《Effective Java》学习笔记 —— 通用程序设计 - (•̀ω•́)y</title>
<link>http://www.cnblogs.com/laishenghao/p/effective_java_note_general_programming.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laishenghao/p/effective_java_note_general_programming.html</guid>
<description>
&lt;p&gt;　　本章主要讨论局部变量、控制结构、类库、反射、本地方法的用法及代码优化和命名惯例。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第45条 将局部变量的作用域最小化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 在第一次使用的它的地方声明局部变量（就近原则）。&lt;/p&gt;
&lt;p&gt;　　* 几乎每个局部变量的声明都应该包含一个初始化表达式。如果还没有足够的信息进行初始化，就延迟这个声明（例外：try-catch语句块）。&lt;/p&gt;
&lt;p&gt;　　* 如果在循环终止之后不再需要循环变量的内容，for循环优先于while循环。&lt;/p&gt;
&lt;p&gt;　　* 使方法小而集中（职责单一）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第46条 for-each循环优先于传统的for循环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 如果正在编写的类型表示的是一组元素，即使选择不实现Collection，也要实现Iterable接口，以便使用for-each循环。&lt;/p&gt;
&lt;p&gt;　　* for-each循环在简洁性和预防Bug方面有着传统for循环无法比拟的优势，且没有性能损失。但并不是所有的情况都能用for-each循环，如过滤、转换和平行迭代等。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;存在Bug&lt;/strong&gt;的传统for循环代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt; &lt;span&gt;https://www.cnblogs.com/laishenghao/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @date 2018/10/7
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrdinaryFor {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Suit {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        CLUB, DIAMOND, HEART, SPADE,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Rank {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        ACE, DEUCE, THREE, FOUR, FIVE,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        SIX, SEVEN, EIGHT, NINE, TEN,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        JACK, QUEEN, KING,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Card&amp;gt;&lt;span&gt; createDeck() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Collection&amp;lt;Suit&amp;gt; suits =&lt;span&gt; Arrays.asList(Suit.values());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Collection&amp;lt;Rank&amp;gt; ranks =&lt;span&gt; Arrays.asList(Rank.values());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         List&amp;lt;Card&amp;gt; deck = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;Suit&amp;gt; i =&lt;span&gt; suits.iterator(); i.hasNext(); ) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;Rank&amp;gt; j =&lt;span&gt; ranks.iterator(); j.hasNext(); ) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 deck.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Card(&lt;span&gt;i.next()&lt;/span&gt;, j.next()));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; deck;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Card {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Suit suit;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Rank rank;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Card(Suit suit, Rank rank) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.suit =&lt;span&gt; suit;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.rank =&lt;span&gt; rank;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; other codes&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;采用for-each循环的代码（忽略对Collection的优化）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Card&amp;gt;&lt;span&gt; createDeck() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Suit[] suits =&lt;span&gt; Suit.values();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Rank[] ranks =&lt;span&gt; Rank.values();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         List&amp;lt;Card&amp;gt; deck = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Suit suit : suits) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Rank rank : ranks) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 deck.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Card(suit, rank));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; deck;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第47条 了解和使用类库&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 优先使用标准类库，而不是重复造轮子。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第48条 如果需要精确的答案，请避免使用float和double&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* float和double尤其不适合用于货币计算，因为要让一个float或double精确的表示o.1（或10的任何其他负数次方值）是不可能的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
System.out.println(1 - 0.9);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码输出（JDK1.8）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/855030/201810/855030-20181007101857445-2016270501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　* 使用BigDecimal（很慢）、int或者long进行货币计算。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第49条 基本类型优先于装箱基本类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 在性能方面基本类型优于装箱基本类型。当程序装箱了基本类型值时，会导致高开销和不必要的对象创建。&lt;/p&gt;
&lt;p&gt;　　* Java1.5中增加了自动拆装箱，但并没有完全抹去基本类型和装箱基本类型的区别，也没有减少装箱类型的风险。&lt;/p&gt;
&lt;p&gt;　　如下代码在自动拆箱时会报NullPointerException：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  Map&amp;lt;String, Integer&amp;gt; values = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v = values.get(&quot;hello&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　再考虑两个例子：&lt;/p&gt;
&lt;p&gt;例子1：输出true&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Integer num1 = 10;&lt;br/&gt;Integer num2 = 10;&lt;br/&gt;System.out.println(num1 == num2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子2：输出false&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    Integer num1 = 1000&lt;span&gt;;
    Integer num2 &lt;/span&gt;= 1000&lt;span&gt;;
    System.out.println(num1 &lt;/span&gt;== num2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为啥呢？&lt;/p&gt;
&lt;p&gt;　　我们知道 “==” 比较的是内存地址。而Java默认对-128到127的Integer进行了缓存（这个范围可以在运行前通过&lt;em&gt;-XX:AutoBoxCacheMax&lt;/em&gt;参数指定）。所以在此范围内获取的Integer实例，只要数值相同，返回的是同一个Object，自然是相等的；而在此范围之外的则会重新new一个Integer，也就是不同的Object，内存地址是不一样的。&lt;/p&gt;
&lt;p&gt;　　具体可以查看IntegerCache类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_e492f1f4-718f-4f97-bc68-cb854fdea1b4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e492f1f4-718f-4f97-bc68-cb854fdea1b4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e492f1f4-718f-4f97-bc68-cb854fdea1b4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Cache to support the object identity semantics of autoboxing for values between
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * -128 and 127 (inclusive) as required by JLS.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * The cache is initialized on first usage.  The size of the cache
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * may be controlled by the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; -XX:AutoBoxCacheMax=&amp;lt;size&amp;gt;} option.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * During VM initialization, java.lang.Integer.IntegerCache.high property
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * may be set and saved in the private system properties in the
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * sun.misc.VM class.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IntegerCache {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; low = -128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Integer cache[];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; high value may be configured by property&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; h = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             String integerCacheHighPropValue =
&lt;span&gt;21&lt;/span&gt;                 sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (integerCacheHighPropValue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; parseInt(integerCacheHighPropValue);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     i = Math.max(i, 127&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Maximum array size is Integer.MAX_VALUE&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                     h = Math.min(i, Integer.MAX_VALUE - (-low) -1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt;( NumberFormatException nfe) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the property cannot be parsed into an int, ignore it.&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             high =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             cache = &lt;span&gt;new&lt;/span&gt; Integer[(high - low) + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; low;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; cache.length; k++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 cache[k] = &lt;span&gt;new&lt;/span&gt; Integer(j++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; range [-128, 127] must be interned (JLS7 5.1.7)&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;assert&lt;/span&gt; IntegerCache.high &amp;gt;= 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IntegerCache() {}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IntegerCache&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第50条 如果其他类型更适合，则尽量避免使用字符串&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 字符串不适合代替其他的值类型。&lt;/p&gt;
&lt;p&gt;　　* 字符串不适合代替枚举类型。&lt;/p&gt;
&lt;p&gt;　　* 字符串不适合代替聚集类型（一个实体有多个组件）。&lt;/p&gt;
&lt;p&gt;　　* 字符串也不适合代替能力表（capacityies；capacity：能力，一个不可伪造的键被称为能力）。　　&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第51条 当心字符串连接的性能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 构造一个较小的、大小固定的对象，使用连接操作符（+）是非常合适的，但不适合运用在大规模的场景中。&lt;/p&gt;
&lt;p&gt;　　* 如果数量巨大，为了获得可以接受的性能，请使用StringBuilder（非同步），或StringBuffer（线程安全，性能较差，一般不需要用到）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第52条 通过接口引用对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 这条应该与“面向接口编程”原则一致。&lt;/p&gt;
&lt;p&gt;　　* 如果有合适的接口类型存在，则参数、返回值、变量和域，都应该使用接口来进行声明。&lt;/p&gt;
&lt;p&gt;如声明一个类成员应当优先采用这种方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　* 如果没有合适的接口存在，则完全可以采用类而不是接口。&lt;/p&gt;
&lt;p&gt;　　* 优先采用基类（往往是抽象类）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第53条 接口优先于反射机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 反射的代价：&lt;/p&gt;
&lt;p&gt;　　　　（1）丧失了编译时进行类型检查的好处。&lt;/p&gt;
&lt;p&gt;　　　　（2）执行反射访问所需要的代码非常笨拙和冗长（编写乏味，可读性差）。&lt;/p&gt;
&lt;p&gt;　　　　（3）性能差。&lt;/p&gt;
&lt;p&gt; 　　* 当然，对于某些情况下使用反射是合理的甚至是必须的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第54条 谨慎地使用本地方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 本地方法（native method）主要有三种用途：&lt;/p&gt;
&lt;p&gt;　　　　（1）提供“访问特定于平台的机制”的能力，如访问注册表（registry）和文件锁（file lock）等。&lt;/p&gt;
&lt;p&gt;　　　　（2）提供访问遗留代码库的能力，从而可以访问遗留数据（legacy data）。&lt;/p&gt;
&lt;p&gt;　　　　（3）编写代码中注重性能的部分，提高系统性能（不值得提倡，JVM越来越快了）。&lt;/p&gt;
&lt;p&gt;　　* 本地方法的缺点：&lt;/p&gt;
&lt;p&gt;　　　　（1）不安全（C、C++等语言的不安全性）。&lt;/p&gt;
&lt;p&gt;　　　　（2）本地语言与平台相关，可能存在不可移植性。&lt;/p&gt;
&lt;p&gt;　　　　（3）造成调试困难。&lt;/p&gt;
&lt;p&gt;　　　　（4）增加性能开销。在进入和退出本地代码时需要一定的开销。如果本地方法只是做少量的工作，那就有可能反而会降低性能（这点与Java8的并行流操作类似）。&lt;/p&gt;
&lt;p&gt;　　　　（5）可能会牺牲可读性。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第55条 谨慎地进行优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 有三条与优化相关的格言是每个人都应该知道的：&lt;/p&gt;
&lt;p&gt;　　　　（1）More computing sins are committed in the name of efficiency (without necessarily achieving it)than for any other single reason——including blind stupidity.&lt;/p&gt;
&lt;p&gt;　　　　　　 —— William AWulf&lt;/p&gt;
&lt;p&gt;　　　　（2）We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.&lt;/p&gt;
&lt;p&gt;　　　　　　—— Donald E. Knuth&lt;/p&gt;
&lt;p&gt;　　　　（3）We follow two rules in the matter of optimization:&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　　　Rule 1. Don't do it.&lt;br/&gt;　　　　　　Rule 2(for experts only). Don't do it yet——that is, not until you have a perfectly clear and unoptimized solution.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　—— M. J. Jackson&lt;/p&gt;
&lt;p&gt;　　以上格言说明：优化的弊大于利，特别是不成熟的优化。&lt;/p&gt;
&lt;p&gt;　　* 不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。&lt;/p&gt;
&lt;p&gt;　　　　实现上的问题可以通过后期优化，但遍布全局且限制性能的结构缺陷几乎是不可能被改正的。但并不是说在完成程序之前就可以忽略性能问题。&lt;/p&gt;
&lt;p&gt;　　* 努力避免那些限制性能的设计决策，考虑API设计决策的性能后果。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第56条 遵守普遍接受的命名惯例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　* 把标准的命名惯例当作一种内在的机制来看待。&lt;/p&gt;

&lt;p&gt;本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 《Effective Java》学习笔记 —— 通用程序设计&quot; href=&quot;https://www.cnblogs.com/laishenghao/p/effective_java_note_general_programming.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/laishenghao/p/effective_java_note_general_programming.html&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Sun, 07 Oct 2018 07:38:00 +0000</pubDate>
<dc:creator>(•̀ω•́)y</dc:creator>
<og:description>本章主要讨论局部变量、控制结构、类库、反射、本地方法的用法及代码优化和命名惯例。 第45条 将局部变量的作用域最小化 * 在第一次使用的它的地方声明局部变量（就近原则）。 * 几乎每个局部变量的声明都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laishenghao/p/effective_java_note_general_programming.html</dc:identifier>
</item>
<item>
<title>第一次博客作业 - 黄泓翔</title>
<link>http://www.cnblogs.com/H735562363/p/9750242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/H735562363/p/9750242.html</guid>
<description>&lt;p&gt;Q1：学习《C++语言程序设计》课程之前，你知道什么是编程吗？谈谈上这门课之前你对编程的理解，以及你对自己编程能力的评估。&lt;/p&gt;
&lt;p&gt;A1：在学习c++课程以前，其实对编程的理解很模糊，也仅仅局限于“代码”、“数据输入”等相关的词，并没有很深的理解。不过大概能想象出编程是个“赶时髦”的一种计算机手段吧，像c++和java等一些基础也算常常能听人提起到。编程大概就是以类似的计算机语言为基础建立起人与计算机“沟通”的桥梁吧，这算是我对编程的理解。在学习c++这门课程以前觉得自己大概是可以比较好的理解这种与计算机沟通的方式的，然而在上了几堂课以后才觉得自己还是太小看编程这门学科了，暂时来看，我对编程的理解还比较有限，目前的编程能力也是极弱的，还需要长时间的磨练，希望能得到很好的提升。&lt;/p&gt;

&lt;p&gt;Q2：学习《C++语言程序设计》课程两周后，你已经初步认识到了什么是程序设计（编程），请你对第一次编程作业认真进行总结，写出自己的心得体会（请给出较详细的总结）。&lt;/p&gt;
&lt;p&gt;A2：说实话，这两周因为各种事情忙来忙去，并没能很好地预习相应的c++课程，当然也可能是因为自己还不够上心。所以上起课来的时候还是比较发懵的。再一个，可能还没能完全从假期的生活节奏中走出来，早上上课有时会打瞌睡，这也着实严重影响了我对c++语言的学习。以至于现在也仅仅会输入点初始函数之类的，其他的也只是班门弄斧而已。第一次做PTA的编程题时感觉到了自己的创作能力或者说是想象力可能并不是很有天分，很多东西都是照搬题目要求的，比如像用到复制粘贴之类的方式，缺少自己对编程方式的理解，所以在这门课程的学习上还是任重而道远。接下来会尽力打好基础，把漏下的一点基础得不能再基础的皮毛给补回来。&lt;/p&gt;

&lt;p&gt;Q3：根据自己的情况写出你对这门课已经或将要使用的学习方法及时间安排？（请给出较详细的计划）&lt;/p&gt;
&lt;p&gt;A3：从前两周的学习中来看，自己安排给这门课的时间实在是过于不稳定了，得做出一些调整。后续的学习中，因为这门课是学计算机专业的“大头”，所以我会尽可能地每天都安排一段时间给这门课。像预习和复习以及相应操作对上机的一些应用，会做到每天都进行一些练习。我想把时间集中安排在晚上9点后到11点之间。遇到不懂的问题先尽可能通过翻书等方式自己解决，当然也会勤快点问老师以及学长学姐滴（希望老师别介意我愚钝哈）。在后续的学习中，我想，随着对这门课的理解不断发生改变，相关的学习方法以及安排应该也会发生改变，所以目前还是先暂定这样，随后慢慢再调整~&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 07:30:00 +0000</pubDate>
<dc:creator>黄泓翔</dc:creator>
<og:description>Q1：学习《C++语言程序设计》课程之前，你知道什么是编程吗？谈谈上这门课之前你对编程的理解，以及你对自己编程能力的评估。 A1：在学习c++课程以前，其实对编程的理解很模糊，也仅仅局限于“代码”、“</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/H735562363/p/9750242.html</dc:identifier>
</item>
<item>
<title>冯诺依曼存储子系统的改进 - 灰太狼的喜羊羊</title>
<link>http://www.cnblogs.com/uestcman/p/9750230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uestcman/p/9750230.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;冯诺依曼存储子系统的改进&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;      &lt;/span&gt; &lt;strong&gt;&lt;span&gt;摘要&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;由于冯诺依曼体系结构存在串行性特点，成为了其发展的瓶颈，针对其串行性人们提出了若干改进和改变措施，涉及到&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;子系统、存储器子系统和&lt;span lang=&quot;EN-US&quot;&gt;IO&lt;/span&gt;子系统&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;本文讨论涉及到存储子系统&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;strong&gt;&lt;span&gt;关键词&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;冯诺依曼 串行 瓶颈 存储子系统 改进&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;冯&lt;span lang=&quot;EN-US&quot;&gt;·&lt;/span&gt;诺伊曼结构&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;langwithname&quot;&gt;&lt;span lang=&quot;EN&quot;&gt;Von Neumann architecture&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN&quot;&gt;)&lt;/span&gt;&lt;span&gt;是一种将程序指令存储器和数据存储器合并在一起的计算机设计概念结构&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;由于冯诺依曼体系结构存在串行性特点，成为了其发展的瓶颈&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;当今有许多计算机都采用冯诺依曼体系结构，所以对冯诺依曼体系进行改进的研究有很大的现实意义&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;存储子系统存在的问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;．&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;存储器读取的串行性&lt;/span&gt;：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;      &lt;/span&gt; &lt;span&gt;冯诺依曼体系结构具有两个明显的特点，一是计算机以存储程序原理为基础，二是程序顺序执行&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;存储器是现代冯&lt;span lang=&quot;EN-US&quot;&gt;•&lt;/span&gt;诺依曼体系的核心，&lt;/span&gt;&lt;span&gt;指令与数据混合存储，程序执行时， &lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt; 在程序计数器的指引下，线性顺序地读取下一条指令和数据&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img width=&quot;390&quot; height=&quot;180&quot; id=&quot;Picture 2&quot; src=&quot;https://img2018.cnblogs.com/blog/1399886/201810/1399886-20181007153007268-104263760.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Fig. 1.&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Memory of Computer Model&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;所有对内存的读取都是独占性的，每一个瞬间，内存实体只能被一个操作对象通过片选信号占据&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;这就决定了内存的串行读取特性，对内存的操作无法并发进行&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;．&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;内存墙&lt;span lang=&quot;EN-US&quot;&gt;—&lt;/span&gt;存储器和&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;数据流量障碍&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span&gt;由于&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;速度远大于存储器读写速率&lt;sup&gt;&lt;span lang=&quot;EN-US&quot;&gt;[1]&lt;/span&gt;&lt;/sup&gt;，据统计，处理器的性能以每年&lt;span lang=&quot;EN-US&quot;&gt;60%&lt;/span&gt;的速度提高，而存储器芯片的带宽每年却只提高&lt;span lang=&quot;EN-US&quot;&gt;10%&lt;/span&gt;，工艺水平的发展已使两者之间的带宽间隙越来越大&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img width=&quot;358&quot; height=&quot;219&quot; id=&quot;图片 4&quot; src=&quot;https://img2018.cnblogs.com/blog/1399886/201810/1399886-20181007153057880-1943013263.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Fig. 2.&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;Processor-memory performance gap: starting in the 1980 performance, the microprocessor and memory performance over the years&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span&gt;处理器从存储器取一次数的同时，将可以执行数百至数千条指令，这就意味着&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;将会在数据输入或输出存储器时闲置&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;在&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;与存储器之间的流量（数据传输率）与存储器的容量相比起来相当小，在现代计算机中，流量与&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;的工作效率相比之下非常小，在某些情况下（当&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;需要在巨大的数据上运行一些简单指令时），数据流量就成了整体效率非常严重的限制&lt;span lang=&quot;EN-US&quot;&gt;.CPU&lt;/span&gt;将会在数据输入或输出存储器时闲置，无法充分发挥计算机的运算能力&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;因此内存预取是一个关键的瓶颈问题，也被称为“内存墙”（&lt;span lang=&quot;EN-US&quot;&gt;Memory Wall&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;存储子系统的改进&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2. 1&lt;/span&gt;&lt;span&gt;使用并行技术&lt;/span&gt;：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span&gt;改善的出路是使用并行技术，在指令运算处理及数据存储上都巧妙地运用并行技术&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;比如说多端口存储器，它具有多组独立的读写控制线路，可以对存储器进行并行的独立操作&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;又比如：存储器的访问不再用片选控制，而是可以任意地访问单元，在读写数据时用原子操作或事务处理的思想保证数据的一致性，这就取决于所采取的仲裁策略&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;哈佛体系则从另一个角度改善冯诺依曼存储器串行读写效率低下的瓶颈&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;哈佛结构是一种将指令储存和数据储存分开的存储器结构&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;指令储存和数据储存分开，数据和指令的储存可以同时进行，执行时可以预先读取下一条指令&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img width=&quot;309&quot; height=&quot;217&quot; id=&quot;图片 1&quot; src=&quot;https://img2018.cnblogs.com/blog/1399886/201810/1399886-20181007153135245-1936684956.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Fig. 3.&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;Harvard architecture&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;．&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;分层结构&lt;/span&gt;：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;      &lt;/span&gt; &lt;span&gt;现代高性能计算机系统要求存储器速度快、容量大，并且价格合理&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;现代计算机常把各种不同存储容量、存取速度、价格的存储器按照一定的体系结构形成多层结构，以解决存取速度、容量和价格之间的矛盾&lt;strong&gt;&lt;sup&gt;&lt;span lang=&quot;EN-US&quot;&gt;[2]&lt;/span&gt;&lt;/sup&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;这纾解了内存墙问题&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;大多数现代计算机采用三级存储系统：&lt;span lang=&quot;EN-US&quot;&gt;cache+&lt;/span&gt;主存&lt;span lang=&quot;EN-US&quot;&gt;+&lt;/span&gt;辅存&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;这种结构主要由以下两个主要的部分组成：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;、 &lt;span lang=&quot;EN-US&quot;&gt;cache&lt;/span&gt;存储器系统：&lt;span lang=&quot;EN-US&quot;&gt;cache-&lt;/span&gt;主存层次&lt;span lang=&quot;EN-US&quot;&gt;.cache&lt;/span&gt;一般由少量快速昂贵的&lt;span lang=&quot;EN-US&quot;&gt;SRAM&lt;/span&gt;构成，用来加速大容量但速度慢的&lt;span lang=&quot;EN-US&quot;&gt;DRAM.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;、 虚拟存储器系统：主存&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;辅存层次&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img width=&quot;586&quot; height=&quot;359&quot; id=&quot;图片 3&quot; src=&quot;https://img2018.cnblogs.com/blog/1399886/201810/1399886-20181007153157896-1025192454.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Fig. 4.&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Memory hierarchy&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span&gt;多层存储体系结构设计想要达成一个目标，速度快、容量大、又便宜&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt; 根据大量典型程序的运行情况的分析结果表明，在一个较短时间间隔内，程序对存储器访问往往集中在一个很小的地址空间范围内&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;这种对局部范围内存储器地址访问频繁，对范围以外的存储器地址较少访问的现象称为存储器访问的局部性&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;所以可以把近期使用的指令和数据尽可能的放在靠近&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;的上层存储器中，这样与&lt;span lang=&quot;EN-US&quot;&gt;CPU&lt;/span&gt;交互的数据程序就放在更快的存储器内，暂时不用的数据程序就放在下层存储器&lt;span lang=&quot;EN-US&quot;&gt;.CPU&lt;/span&gt;等待时间减少了，整机性能就提上来了&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span&gt;把下级存储器调过来的新的页放在本级存储器的什么地方，确定需要的数据、指令是否在本级，本级存储器满了以后先把哪些页给替换掉，在给上层存储器进行写操作的时候如何保证上下层存储器数据一致等映像、查找、替换、更新操作，这些操作需要合理、高效的算法策略才能保证这种多层结构的有效性&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;智能存储器&lt;sup&gt;&lt;span lang=&quot;EN-US&quot;&gt;[3]&lt;/span&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;      &lt;/span&gt; &lt;span&gt;一些研究者预测记忆行为将会优化计算系统的全局性能&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;他们建议将存储组件与处理核心融合在一个芯片，创造&lt;strong&gt;具有处理能力的存储器&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/strong&gt;这个策略包含&lt;span lang=&quot;EN-US&quot;&gt;intelligent RAM (IRAM)&lt;/span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;Merged DRAM/Logic (MDL)&lt;/span&gt; 、&lt;span lang=&quot;EN-US&quot;&gt;Process in Memory (PIM)&lt;/span&gt; 等等&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span&gt;最早的智能存储器是&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;C-RAM&lt;/span&gt;&lt;/strong&gt;，一款由多伦多大学在&lt;span lang=&quot;EN-US&quot;&gt;1992&lt;/span&gt;年制造的&lt;span lang=&quot;EN-US&quot;&gt;PIM.&lt;/span&gt;这些处理元件通常集成在读出放大器的输出端，由单个控制单元控制，作为&lt;span lang=&quot;EN-US&quot;&gt;SIMD&lt;/span&gt;处理器&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;因为计算元件直接集成到&lt;span lang=&quot;EN-US&quot;&gt;DRAM&lt;/span&gt;输出，这种设计策略可以大量提高&lt;span lang=&quot;EN-US&quot;&gt;DRAM&lt;/span&gt;的片上带宽&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;从结构上讲，这是一种简单的方法，理论上能够实现最高性能&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt; 然而，这也有一些严重的缺点：虽然在结构上简单，但在实际设计和生产中出现了严重的复杂性，因为大多数&lt;span lang=&quot;EN-US&quot;&gt;DRAM&lt;/span&gt;核心都是高度优化的，并且很难修改， 这些类型的大规模并行&lt;span lang=&quot;EN-US&quot;&gt;SIMD&lt;/span&gt;设计在串行计算中很不成功&lt;span lang=&quot;EN-US&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;   &lt;/span&gt; &lt;span&gt;传统的&lt;span lang=&quot;EN-US&quot;&gt;cache&lt;/span&gt;组织&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;解决的只是处理器的时间延迟问题&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;并不能用来解决处理器的存储带宽问题&lt;span lang=&quot;EN-US&quot;&gt;.PIM&lt;/span&gt;技术在&lt;span lang=&quot;EN-US&quot;&gt;DRAM&lt;/span&gt;芯片上集成了处理器&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;从而降低了存储延迟&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;增加了处理器与存储器之间的数据带宽&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img width=&quot;553&quot; height=&quot;257&quot; id=&quot;Picture 5&quot; src=&quot;https://img2018.cnblogs.com/blog/1399886/201810/1399886-20181007153220894-332750342.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Fig. 5.&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;System Architecture of PIM&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;基于&lt;span lang=&quot;EN-US&quot;&gt;PIM&lt;/span&gt;技术的体系结构的优点在于处理逻辑能以内部存储器带宽&lt;span lang=&quot;EN-US&quot;&gt;(100GB/s&lt;/span&gt;甚至更高&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;直接存取访问片上存储块，从而获取高性能&lt;span lang=&quot;EN-US&quot;&gt;;&lt;/span&gt;功耗方面，比与具有相同功能的传统处理器相低一个数量级&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;[1]Carlos, Carvalho. The Gap between Processor and Memory Speeds[J]. icca, 2010, (2): 27-34&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;[2]&lt;/span&gt;&lt;span&gt;李广军，阎波等&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;微处理器系统结构与嵌入式系统设计&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;北京&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;电子工业出版社，&lt;span lang=&quot;EN-US&quot;&gt;2009&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;[3]&lt;/span&gt;&lt;span&gt;师小丽&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;基于&lt;span lang=&quot;EN-US&quot;&gt;PIM&lt;/span&gt;技术的数据并行计算研究&lt;span lang=&quot;EN-US&quot;&gt;[D].&lt;/span&gt;西安理工大学&lt;span lang=&quot;EN-US&quot;&gt;,2009.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 07:27:00 +0000</pubDate>
<dc:creator>灰太狼的喜羊羊</dc:creator>
<og:description>&lt;! / Font Definitions / @font face {font family:宋体; panose 1:2 1 6 0 3 1 1 1 1 1;} @font face {font</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uestcman/p/9750230.html</dc:identifier>
</item>
<item>
<title>ELF文件格式 - 活在未来的人</title>
<link>http://www.cnblogs.com/gatsby123/p/9750187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gatsby123/p/9750187.html</guid>
<description>&lt;p&gt;ELF文件（Executable Linkable Format）是一种文件存储格式。Linux下的目标文件和可执行文件都按照该格式进行存储，有必要做个总结。&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;
&lt;p&gt;本文主要记录总结32位的Intel x86平台下的ELF文件结构。ELF文件以Section的形式进行存储。代码编译后的指令放在代码段（Code Section），全局变量和局部静态变量放到数据段（Data Section）。文件以一个“文件头”开始，记录了整个文件的属性信息。&lt;/p&gt;
&lt;h2 id=&quot;未链接的目标文件结构&quot;&gt;未链接的目标文件结构&lt;/h2&gt;
&lt;p&gt;SimpleSection.c&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int printf(const char* format, ...);

int global_init_var = 84;
int global_uniit_var;

void func1(int i)
{
        printf(&quot;%d\n&quot;, i);
}

int main(void)
{
        static int static_var = 85;
        static int static_var2;
        int a = 1;
        int b;
        func1(static_var + static_var2 + a + b);
        return a;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上面的一段c代码将其编译但是不链接。&lt;code&gt;gcc -c -m32 SimpleSection.c&lt;/code&gt;（ -c表示只编译不链接，-m32表示生成32位的汇编）得到SimpleSection.o。可以用objdump或readelf命令查看目标文件的结构和内容。&lt;/p&gt;
&lt;h3 id=&quot;elf文件头&quot;&gt;ELF文件头&lt;/h3&gt;
&lt;p&gt;可以用&lt;code&gt;readelf -h&lt;/code&gt;查看文件头信息。执行&lt;code&gt;readelf -h SimpleSection.o&lt;/code&gt;后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@DESKTOP-2A432QS:~/c# readelf -h SimpleSection.o 
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          832 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           40 (bytes)
  Number of section headers:         13
  Section header string table index: 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序头包含了很多重要的信息，每个字段的含义可参考&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf&quot;&gt;ELF结构文档&lt;/a&gt;。主要看下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Entry point address：程序的入口地址，这是没有链接的目标文件所以值是0x00&lt;/li&gt;
&lt;li&gt;Start of section headers：段表开始位置的首字节&lt;/li&gt;
&lt;li&gt;Size of section headers：段表的长度（字节为单位）&lt;/li&gt;
&lt;li&gt;Number of section headers：段表中项数，也就是有多少段&lt;/li&gt;
&lt;li&gt;Start of program headers：程序头的其实位置（对于可执行文件重要，现在为0）&lt;/li&gt;
&lt;li&gt;Size of program headers：程序头大小（对于可执行文件重要，现在为0）&lt;/li&gt;
&lt;li&gt;Number of program headers：程序头中的项数，也就是多少Segment（和Section有区别，后面介绍）&lt;/li&gt;
&lt;li&gt;Size of this header：当前ELF文件头的大小，这里是52字节&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;段表及段section&quot;&gt;段表及段（Section）&lt;/h3&gt;
&lt;h4 id=&quot;段表&quot;&gt;段表&lt;/h4&gt;
&lt;p&gt;ELF文件由各种各样的段组成，段表就是保存各个段信息的结构，以数组形式存放。段表的起始位置，长度，项数分别由ELF文件头中的Start of section headers，Size of section headers，Number of section headers指出。使用&lt;code&gt;readelf -S SimpleSection.o&lt;/code&gt;查看SimpleSection.o的段表如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;There are 13 section headers, starting at offset 0x340:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 000062 00  AX  0   0  1
  [ 2] .rel.text         REL             00000000 0002a8 000028 08   I 11   1  4
  [ 3] .data             PROGBITS        00000000 000098 000008 00  WA  0   0  4
  [ 4] .bss              NOBITS          00000000 0000a0 000004 00  WA  0   0  4
  [ 5] .rodata           PROGBITS        00000000 0000a0 000004 00   A  0   0  1
  [ 6] .comment          PROGBITS        00000000 0000a4 000036 01  MS  0   0  1
  [ 7] .note.GNU-stack   PROGBITS        00000000 0000da 000000 00      0   0  1
  [ 8] .eh_frame         PROGBITS        00000000 0000dc 000064 00   A  0   0  4
  [ 9] .rel.eh_frame     REL             00000000 0002d0 000010 08   I 11   8  4
  [10] .shstrtab         STRTAB          00000000 0002e0 00005f 00      0   0  1
  [11] .symtab           SYMTAB          00000000 000140 000100 10     12  11  4
  [12] .strtab           STRTAB          00000000 000240 000065 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共有13个Section，重点关注.text, .data, .rodata, .symtab, .rel.text段。&lt;/p&gt;
&lt;h4 id=&quot;代码段&quot;&gt;代码段&lt;/h4&gt;
&lt;p&gt;.text段保存代码编译后的指令，可以用&lt;code&gt;objdump -s -d SimpleSection.o&lt;/code&gt;查看SimpleSection.o代码段的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SimpleSection.o:     file format elf32-i386

Contents of section .text:
 0000 5589e583 ec0883ec 08ff7508 68000000  U.........u.h...
 0010 00e8fcff ffff83c4 1090c9c3 8d4c2404  .............L$.
 0020 83e4f0ff 71fc5589 e55183ec 14c745f0  ....q.U..Q....E.
 0030 01000000 8b150400 0000a100 00000001  ................
 0040 c28b45f0 01c28b45 f401d083 ec0c50e8  ..E....E......P.
 0050 fcffffff 83c4108b 45f08b4d fcc98d61  ........E..M...a
 0060 fcc3                                 ..              
...省略          

Disassembly of section .text:

00000000 &amp;lt;func1&amp;gt;:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 ec 08                sub    $0x8,%esp
   6:   83 ec 08                sub    $0x8,%esp
   9:   ff 75 08                pushl  0x8(%ebp)
   c:   68 00 00 00 00          push   $0x0
  11:   e8 fc ff ff ff          call   12 &amp;lt;func1+0x12&amp;gt;
  16:   83 c4 10                add    $0x10,%esp
  19:   90                      nop
  1a:   c9                      leave  
  1b:   c3                      ret    

0000001c &amp;lt;main&amp;gt;:
  1c:   8d 4c 24 04             lea    0x4(%esp),%ecx
  20:   83 e4 f0                and    $0xfffffff0,%esp
  23:   ff 71 fc                pushl  -0x4(%ecx)
  26:   55                      push   %ebp
  27:   89 e5                   mov    %esp,%ebp
  29:   51                      push   %ecx
  2a:   83 ec 14                sub    $0x14,%esp
  2d:   c7 45 f0 01 00 00 00    movl   $0x1,-0x10(%ebp)
  34:   8b 15 04 00 00 00       mov    0x4,%edx
  3a:   a1 00 00 00 00          mov    0x0,%eax
  3f:   01 c2                   add    %eax,%edx
  41:   8b 45 f0                mov    -0x10(%ebp),%eax
  44:   01 c2                   add    %eax,%edx
  46:   8b 45 f4                mov    -0xc(%ebp),%eax
  49:   01 d0                   add    %edx,%eax
  4b:   83 ec 0c                sub    $0xc,%esp
  4e:   50                      push   %eax
  4f:   e8 fc ff ff ff          call   50 &amp;lt;main+0x34&amp;gt;
  54:   83 c4 10                add    $0x10,%esp
  57:   8b 45 f0                mov    -0x10(%ebp),%eax
  5a:   8b 4d fc                mov    -0x4(%ebp),%ecx
  5d:   c9                      leave  
  5e:   8d 61 fc                lea    -0x4(%ecx),%esp
  61:   c3                      ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到.text段里保存的正是func1()和main()的指令。&lt;/p&gt;
&lt;h4 id=&quot;数据段和只读数据段&quot;&gt;数据段和只读数据段&lt;/h4&gt;
&lt;p&gt;.data段保存的是&lt;strong&gt;已经初始化&lt;/strong&gt;了的全局静态变量和局部静态变量。前面SimpleSection.c中的global_init_varabal和static_var正是这样的变量。使用&lt;code&gt;objdump -x -s -d SimpleSection.o&lt;/code&gt;查看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Contents of section .data:
 0000 54000000 55000000                    T...U...        
Contents of section .rodata:
 0000 25640a00                             %d..            &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最左边的0000是偏移，不用看，后面跟着的0x00000054和0x00000055正是global_init_varabal和static_var的初始值。&lt;br/&gt;.rodata段存放的是只读数据，包括只读变量（const修饰的变量和字符串常量），这个例子中保存了&quot;%d\n&quot;正是调用printf的时候使用的字符常量。&lt;/p&gt;
&lt;h4 id=&quot;符号表段&quot;&gt;符号表段&lt;/h4&gt;
&lt;p&gt;符号表段一般叫做.symtab，以数组结构保存符号信息（函数和变量），对于函数和变量符号值就是它们的地址。主要关注两类符号：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义在目标文件中的全局符号，可以被其他目标文件引用，比如SimpleSction.o里面的func1, main和global_init_var。&lt;/li&gt;
&lt;li&gt;在本目标文件中引用的全局符号，却没有定义在本目标文件，比如pritnf。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以用&lt;code&gt;readelf -s SimpleSection.o&lt;/code&gt;查看SimpleSection.o的符号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Symbol table '.symtab' contains 16 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS SimpleSection.c
     2: 00000000     0 SECTION LOCAL  DEFAULT    1 
     3: 00000000     0 SECTION LOCAL  DEFAULT    3 
     4: 00000000     0 SECTION LOCAL  DEFAULT    4 
     5: 00000000     0 SECTION LOCAL  DEFAULT    5 
     6: 00000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1488
     7: 00000000     4 OBJECT  LOCAL  DEFAULT    4 static_var2.1489
     8: 00000000     0 SECTION LOCAL  DEFAULT    7 
     9: 00000000     0 SECTION LOCAL  DEFAULT    8 
    10: 00000000     0 SECTION LOCAL  DEFAULT    6 
    11: 00000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var
    12: 00000004     4 OBJECT  GLOBAL DEFAULT  COM global_uniit_var
    13: 00000000    28 FUNC    GLOBAL DEFAULT    1 func1
    14: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
    15: 0000001c    70 FUNC    GLOBAL DEFAULT    1 main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;func1和main的Ndx对应的值是1，表示在.text段（.text段在段表中的索引是1），类型是FUNC，value分别是0x00000000和0x0000001c，表明这两个函数指令字节码的首字节分别在.text段的0x00000000和0x0000001c偏移处。&lt;/li&gt;
&lt;li&gt;printf的Ndx是UND，表明这个符号没有在SimpleSection.o中定义，仅仅是被引用。&lt;/li&gt;
&lt;li&gt;global_init_var和static_var.1488两个符号的Ndx都是3，说明他们被定义在数据段，value分别是0x00000000和0x00000004，表示这个符号的位置在数据段的0x00000000和0x00000004偏移处，翻看上一节&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Contents of section .data:
 0000 54000000 55000000                    T...U... &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据段0x00000000和0x00000004偏移处保存的正是global_init_var和static_var这两个变量。&lt;/p&gt;
&lt;h4 id=&quot;重定位表段&quot;&gt;重定位表段&lt;/h4&gt;
&lt;p&gt;重定位表也是一个段，用于描述在重定位时链接器如何修改相应段里的内容。对于.text段，对应的重定位表是.rel.text表。使用&lt;code&gt;objdump -r SimpleSection.o&lt;/code&gt;查看重定位表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SimpleSection.o:     file format elf32-i386

RELOCATION RECORDS FOR [.text]:
OFFSET   TYPE              VALUE 
0000000d R_386_32          .rodata
00000012 R_386_PC32        printf
00000036 R_386_32          .data
0000003b R_386_32          .bss
00000050 R_386_PC32        func1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;printf对应的那行的OFFSET为0x00000012，表明.text段的0x00000012偏移处需要修改。我们&lt;code&gt;objdump -s -d SimpleSection.o&lt;/code&gt;查看代码段的0x00000012偏移，发现是”fc ff ff ff“是call指令的操作数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;00000000 &amp;lt;func1&amp;gt;:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 ec 08                sub    $0x8,%esp
   6:   83 ec 08                sub    $0x8,%esp
   9:   ff 75 08                pushl  0x8(%ebp)
   c:   68 00 00 00 00          push   $0x0
  11:   e8 fc ff ff ff          call   12 &amp;lt;func1+0x12&amp;gt;
  16:   83 c4 10                add    $0x10,%esp
  19:   90                      nop
  1a:   c9                      leave  
  1b:   c3                      ret &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，在没有重定位前call指令的操作”fc ff ff ff“是无效的，需要在重定位过程中进行修正。func1那行也同理。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;ELF文件结构可以用下面的图表示：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499627/201810/1499627-20181007151005993-911509519.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;可执行程序结构&quot;&gt;可执行程序结构&lt;/h2&gt;
&lt;p&gt;和未链接的ELF文件结构一样，只不过引入了Segment的概念（注意和Section进行区分）。Segment本质上是从装载的角度重新划分了ELF的各个段。目标文件链接成可执行文件时，链接器会尽可能把相同权限属性的段（Section）分配到同一Segment。Segment结构的起始位置，项数，大小分别由ELF头中的Size of program headers，Number of program headers， Size of this header字段指定。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《程序员的自我修养》第3，6章&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf&quot;&gt;ELF结构文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 07 Oct 2018 07:12:00 +0000</pubDate>
<dc:creator>活在未来的人</dc:creator>
<og:description>ELF文件（Executable Linkable Format）是一种文件存储格式。Linux下的目标文件和可执行文件都按照该格式进行存储，有必要做个总结。 概要 本文主要记录总结32位的Intel</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gatsby123/p/9750187.html</dc:identifier>
</item>
<item>
<title>数据分析实战之豆瓣小说知多少？ - balabalaeight</title>
<link>http://www.cnblogs.com/balabalaeight/p/9750191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/balabalaeight/p/9750191.html</guid>
<description>&lt;p&gt;    最近学习了python爬虫，于是，小试身手。&lt;/p&gt;
&lt;p&gt;    得到豆瓣上图书标签为“小说”（&lt;span&gt;&lt;a href=&quot;https://book.douban.com/tag/%E5%B0%8F%E8%AF%B4&quot;&gt;https://book.douban.com/tag/小说&lt;/a&gt;&lt;/span&gt; ）的图书信息，简单整理后，得到998条记录，包含书名、作者、作者国籍、译者、出版社、出版时间、价格、评分、评价人数9个字段。下面就让我们来看看小说的世界。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;小说越火，水准越高？&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    评价人数不等于实际阅读人数，但也可以从其中看出一本书的火爆程度。若以评价人数超过10万、评分超过8.4的书定义为高质量的热门小说，那998本小说中有14本这样的小说。&lt;/p&gt;
&lt;p&gt;    其中，《追风筝的人》的评价人数遥遥领先（34万），无疑是最火的小说，其评分8.9。《解忧杂货铺》紧随其后（31万），评分8.6。两者的评价人数狂甩第三名《白夜行》8万，但评分略微落后于《白夜行》的9.1。&lt;/p&gt;
&lt;p&gt;    从前三名来看，追求大多数人在看的小说不会错。但也要小心，《挪威的森林》评价人数20万，评分8；《梦里花落知多少》评价人数15万，评分7.1。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438522/201810/1438522-20181007150757983-1138827043.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1：书的评分和评价人数（评分的平均值和中位数均为8.4）&lt;/p&gt;
&lt;div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;越来越贵的小说&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    小说是越来越贵了。尽管同年出版的小说的价格波动幅度较大，但总体而言，小说价格逐步上升。1998年之前，每年出版的小说数量较少，大部分小说的价格10元之下，1991年出版的《jin瓶梅》以268元一枝独秀。在1998年之后，每年出版的小说均价从18.9元上升至71.5元。&lt;/p&gt;
&lt;p&gt;    另外，小说的价格率创新高。2008年的《大秦帝国》高达369元，2013年《太平广记（全十册）》创新高（398元），仅在3年后，这一价格再次被刷新，《契诃夫小说全集》达到了630元。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438522/201810/1438522-20181007150807848-979508781.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2：书在不同出版年份的平均价格&lt;/p&gt;
&lt;div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;忙碌的小说生产者&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;生产者之一：作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    998条记录中共有640个作者，但从平均数来看，平均一个作者出版1.6本小说，但实际上，仅有167个作者的出书数量超过了2。并且，只有16个作者的出书数量超过了5。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438522/201810/1438522-20181007150831749-1352533106.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3：不同作者的出书数量&lt;/p&gt;
&lt;p&gt;    在16个出书数量超过5的作者中，村上春树以14本小说位居榜首，然而令我吃惊的是，其评分在8.4以上的作品只有1本。要知道，仅以一本之差位居第二的加西亚·马尔克斯，有9本小说的评分在8.4以上。&lt;/p&gt;
&lt;p&gt;    似乎日本作家都有这种产量颇高，但是质量有待提升的状况，且作品越多，高评分作品的占比越小。三岛由纪夫：8个作品中5个作品评分在8.4以上；东野圭吾：9个作品中3个作品评分在8.4以上；伊坂幸太郎：11个作品中3个作品评分在8.4以上。&lt;/p&gt;
&lt;p&gt;    国内作家中，余华、张爱玲各有7个作品，且各有4本评分在8.4之上。但同有7个作品的亦舒，评分在8.4以上的仅有1本（早期作品《流金岁月》）。此外，金庸、鲁迅、刘慈欣各有6个作品，且评分均在8.4之上。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438522/201810/1438522-20181007150847580-544467369.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4：前16个高产作者的出书数量、评分情况&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;生产者之二：出版社&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    998条记录中共有160个出版社，但从平均数来看，平均一个出版社出版6.2本小说，但实际上，仅有27个出版社的出书数量超过了6。并且，只有10个出版社的出书数量超过了20。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438522/201810/1438522-20181007150901844-1891538498.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5：不同出版社的出书数量&lt;/p&gt;
&lt;p&gt;    在出书数量超过了20的10个出版社中，人民文学出版社（118）、上海译文出版社（116）占据第一梯队，遥遥领先。译林出版社（73）、南海出版社（72）位于第二梯队，两个出版社不相上下。&lt;/p&gt;
&lt;p&gt;    这10个出版社均会涉及不同国家作者的书，但不同出版社的主攻方向有略微差别。人民文学出版社、上海文艺出版社比较全能，涉猎的国家较多。上海译文出版社主攻外国文学，尤其是英国、日本和美国。译林出版社、重庆出版社集中于美国，南海出版公司集中于于日本，上海人民出版社则集中于英国。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438522/201810/1438522-20181007150909909-1547226349.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图6：不同出版社的出书数量、涉及的国家&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 07:11:00 +0000</pubDate>
<dc:creator>balabalaeight</dc:creator>
<og:description>最近学习了python爬虫，于是，小试身手。 得到豆瓣上图书标签为“小说”（https://book.douban.com/tag/小说 ）的图书信息，简单整理后，得到998条记录，包含书名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/balabalaeight/p/9750191.html</dc:identifier>
</item>
<item>
<title>SpringCloud请求响应数据转换（二） - 水木竹水</title>
<link>http://www.cnblogs.com/shuimuzhushui/p/9732526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuimuzhushui/p/9732526.html</guid>
<description>&lt;p&gt;上篇文章记录了从后端接口返回数据经过切面和消息转换器处理后返回给前端的过程。接下来，记录从请求发出后到后端接口调用过的过程。&lt;/p&gt;
&lt;h2&gt;web请求处理流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007113036236-415006039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;源码分析&lt;/h2&gt;
&lt;p&gt; ApplicationFilterChain会调DispatcherServlet类的doService()（HttpServlet类），类继承关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007131758312-569043601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终会调DispatcherServlet类的doDispatch方法，并由该方法控制web请求的全过程，包括确定请求方法、确定请求处理适配器和请求实际调用和数据处理，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Process the actual dispatching to the handler.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;The handler will be obtained by applying the servlet's HandlerMappings in order.  按序遍历并确定HadlerMapping
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * to find the first that supports the handler class.  找到第一个支持处理类的HandlerAdapters
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * themselves to decide which methods are acceptable.  所有HTTP请求都由该方法处理，然后由具体的HandlerAdapter和处理类确定调用方法
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request current HTTP request
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response current HTTP response
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception in case of any kind of processing failure
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doDispatch(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         HttpServletRequest processedRequest =&lt;span&gt; request;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         HandlerExecutionChain mappedHandler = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; multipartRequestParsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         WebAsyncManager asyncManager =&lt;span&gt; WebAsyncUtils.getAsyncManager(request);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             ModelAndView mv = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Exception dispatchException = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 processedRequest =&lt;span&gt; checkMultipart(request);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 multipartRequestParsed = (processedRequest !=&lt;span&gt; request);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                  &lt;span&gt;//1、&lt;/span&gt;&lt;span&gt;获取HandlerMethod
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine handler for the current request.&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                 mappedHandler =&lt;span&gt; getHandler(processedRequest);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (mappedHandler == &lt;span&gt;null&lt;/span&gt; || mappedHandler.getHandler() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    noHandlerFound(processedRequest, response);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                  &lt;span&gt;//2、&lt;/span&gt;&lt;span&gt;确定适配器
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine handler adapter for the current request.&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 HandlerAdapter ha =&lt;span&gt; getHandlerAdapter(mappedHandler.getHandler());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process last-modified header, if supported by the handler.判断是否支持If-Modified-Since&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                 String method =&lt;span&gt; request.getMethod();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;boolean&lt;/span&gt; isGet = &quot;GET&quot;&lt;span&gt;.equals(method);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (isGet || &quot;HEAD&quot;&lt;span&gt;.equals(method)) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; lastModified =&lt;span&gt; ha.getLastModified(request, mappedHandler.getHandler());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                         logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; +&lt;span&gt; lastModified);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp;&lt;span&gt; isGet) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mappedHandler.applyPreHandle(processedRequest, response)) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                  &lt;span&gt;//3、&lt;/span&gt;&lt;span&gt;请求实际处理，包括请求参数的处理、后台接口的调用和返回数据的处理
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Actually invoke the handler.&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;                 mv =&lt;span&gt; ha.handle(processedRequest, response, mappedHandler.getHandler());
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (asyncManager.isConcurrentHandlingStarted()) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                applyDefaultViewName(processedRequest, mv);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                mappedHandler.applyPostHandle(processedRequest, response, mv);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                 dispatchException =&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable err) {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; As of 4.3, we're processing Errors thrown from handler methods as well,
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; making them available for @ExceptionHandler methods and other scenarios.&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;                 dispatchException = &lt;span&gt;new&lt;/span&gt; NestedServletException(&quot;Handler dispatch failed&quot;&lt;span&gt;, err);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable err) {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;            triggerAfterCompletion(processedRequest, response, mappedHandler,
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt; NestedServletException(&quot;Handler processing failed&quot;&lt;span&gt;, err));
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (asyncManager.isConcurrentHandlingStarted()) {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instead of postHandle and afterCompletion&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (mappedHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Clean up any resources used by a multipart request.&lt;/span&gt;
&lt;span&gt;90&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (multipartRequestParsed) {
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;                    cleanupMultipart(processedRequest);
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 1、获取HandlerMethod&lt;/h3&gt;
&lt;p&gt;首先是DispatcherServlet的 &lt;span lang=&quot;EN-US&quot;&gt;getHandler方法，&lt;/span&gt;获取处理器链，所有处理器（HandlerMapping）都注册在handlerMappings中，如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Return the HandlerExecutionChain for this request.返回处理器链，处理该请求
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Tries all handler mappings in order.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request current HTTP request
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the HandlerExecutionChain, or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} if no handler could be found
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; HandlerExecutionChain getHandler(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历所有处理器，如下图&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (HandlerMapping hm : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlerMappings) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                logger.trace(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         &quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             HandlerExecutionChain handler =&lt;span&gt; hm.getHandler(request);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (handler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; handler;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007114807214-141148863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，从前往后遍历所有HandlerMapping，直到handler不为空（14-17行）。&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对GET请求，确定HandlerMapping为RequestMappingHandlerMapping（继承自AbstractHandlerMapping），其&lt;span lang=&quot;EN-US&quot;&gt;getHandler方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Look up a handler for the given request, falling back to the default
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * handler if no specific one is found.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request current HTTP request
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the corresponding handler instance, or the default handler
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #getHandlerInternal
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HandlerExecutionChain getHandler(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取实际处理方法，如public java.util.List&amp;lt;com.service.entity.TaskVO&amp;gt; com.service.controller.TaskController.getTaskListById(java.lang.String)，具体获取方式，见下边 &lt;strong&gt;获取HandlerMethod&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Object handler =&lt;span&gt; getHandlerInternal(request);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             handler =&lt;span&gt; getDefaultHandler();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bean name or resolved handler?&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (handler &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             String handlerName =&lt;span&gt; (String) handler;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             handler =&lt;span&gt; getApplicationContext().getBean(handlerName);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取处理器执行链条，包含拦截器等，如下图&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         HandlerExecutionChain executionChain =&lt;span&gt; getHandlerExecutionChain(handler, request);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CorsUtils.isCorsRequest(request)) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             CorsConfiguration globalConfig = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.corsConfigSource.getCorsConfiguration(request);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             CorsConfiguration handlerConfig =&lt;span&gt; getCorsConfiguration(handler, request);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             CorsConfiguration config = (globalConfig != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; globalConfig.combine(handlerConfig) : handlerConfig);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             executionChain =&lt;span&gt; getCorsHandlerExecutionChain(request, executionChain, config);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; executionChain;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007120221105-868075360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;strong&gt;HandlerMethod&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;上边getHandlerInternal方法会调AbstractHandlerMethodMapping类的getHandlerInternal，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Look up a handler method for the given request.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; HandlerMethod getHandlerInternal(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求路径，如/tasks&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         String lookupPath =&lt;span&gt; getUrlPathHelper().getLookupPathForRequest(request);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             logger.debug(&quot;Looking up handler method for path &quot; +&lt;span&gt; lookupPath);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappingRegistry.acquireReadLock();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①获取请求处理方法HandlerMethod&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             HandlerMethod handlerMethod =&lt;span&gt; lookupHandlerMethod(lookupPath, request);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (handlerMethod != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②根据HandlerMethod解析容器中对应的bean（控制层bean）&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (handlerMethod != &lt;span&gt;null&lt;/span&gt; ? handlerMethod.createWithResolvedBean() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappingRegistry.releaseReadLock();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;①获取请求处理方法HandlerMethod&lt;/h4&gt;
&lt;p&gt;HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request)方法，根据uri寻找与之匹配的HandlerMethod&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Look up the best-matching handler method for the current request.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * If multiple matches are found, the best match is selected.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lookupPath mapping lookup path within the current servlet mapping
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request the current request
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the best-matching handler method, or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} if no match
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #handleMatch(Object, String, HttpServletRequest)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #handleNoMatch(Set, String, HttpServletRequest)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         List&amp;lt;Match&amp;gt; matches = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Match&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lookupPath=/tasks，获取与请求uri匹配的接口信息，如 [{[/tasks],methods=[POST],produces=[application/json;charset=UTF-8]}, {[/tasks],methods=[GET],produces=[application/json;charset=UTF-8]}]，其中MappingRegistry mappingRegistry包含了系统所有uri和接口信息。&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         List&amp;lt;T&amp;gt; directPathMatches = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappingRegistry.getMappingsByUrl(lookupPath);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历得到的uri，根据请求信息，如GET方法等，选择匹配的uri（{[/tasks],methods=[GET],produces=[application/json;charset=UTF-8]}），在mappingRegistry中获取匹配的HandlerMethod，包含后台接口详细信息，如下图。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (directPathMatches != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            addMatchingMappings(directPathMatches, matches, request);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (matches.isEmpty()) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No choice but to go through all mappings...&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             addMatchingMappings(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappingRegistry.getMappings().keySet(), matches, request);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;matches.isEmpty()) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对所有匹配的接口进行排序，并使用第一个（排序规则后续再研究）&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             Comparator&amp;lt;Match&amp;gt; comparator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MatchComparator(getMappingComparator(request));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            Collections.sort(matches, comparator);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 logger.trace(&quot;Found &quot; + matches.size() + &quot; matching mapping(s) for [&quot; +
&lt;span&gt;29&lt;/span&gt;                         lookupPath + &quot;] : &quot; +&lt;span&gt; matches);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             Match bestMatch = matches.get(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (matches.size() &amp;gt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CorsUtils.isPreFlightRequest(request)) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; PREFLIGHT_AMBIGUOUS_MATCH;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 Match secondBestMatch = matches.get(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (comparator.compare(bestMatch, secondBestMatch) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     Method m1 =&lt;span&gt; bestMatch.handlerMethod.getMethod();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     Method m2 =&lt;span&gt; secondBestMatch.handlerMethod.getMethod();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Ambiguous handler methods mapped for HTTP path '&quot; +
&lt;span&gt;41&lt;/span&gt;                             request.getRequestURL() + &quot;': {&quot; + m1 + &quot;, &quot; + m2 + &quot;}&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            handleMatch(bestMatch.mapping, lookupPath, request);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bestMatch.handlerMethod;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; handleNoMatch(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappingRegistry.getMappings().keySet(), lookupPath, request);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007122725600-1632880181.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;其中，第13行为根据lookupPath（/tasks）获取接口信息，第16行根据接口信息获取后台接口和bean等信息，所有这些信息都存储在内部类MappingRegistry对象中。并且中间会构建一个Match对象，包含所有匹配的接口，并选择第一个作为实际处理接口。MappingRegistry内部类如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * A registry that maintains all mappings to handler methods, exposing methods
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * to perform lookups and providing concurrent access.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Package-private for testing purposes.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MappingRegistry {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制层uri接口信息注册&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;T, MappingRegistration&amp;lt;T&amp;gt;&amp;gt; registry = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;T, MappingRegistration&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储uri接口信息和HandlerMethod，如{{[/tasks],methods=[POST],produces=[application/json;charset=UTF-8]}=public com.service.entity.TaskVO com.service.controller.TaskController.addTask(java.lang.String) throws com.service.exception.BizException, {[/tasks],methods=[GET],produces=[application/json;charset=UTF-8]}=public java.util.List&amp;lt;com.service.entity.TaskVO&amp;gt; com.service.controller.TaskController.getTaskListById(java.lang.String)}&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;T, HandlerMethod&amp;gt; mappingLookup = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;T, HandlerMethod&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储uri和uri接口信息（一对多关系），如：{/tasks=[{[/tasks],methods=[POST],produces=[application/json;charset=UTF-8]}, {[/tasks],methods=[GET],produces=[application/json;charset=UTF-8]}]}        private final MultiValueMap&amp;lt;String, T&amp;gt; urlLookup = new LinkedMultiValueMap&amp;lt;String, T&amp;gt;();&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, List&amp;lt;HandlerMethod&amp;gt;&amp;gt; nameLookup =
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, List&amp;lt;HandlerMethod&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;HandlerMethod, CorsConfiguration&amp;gt; corsLookup =
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;HandlerMethod, CorsConfiguration&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantReadWriteLock readWriteLock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;         * Return all mappings and handler methods. Not thread-safe.
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #acquireReadLock()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Map&amp;lt;T, HandlerMethod&amp;gt;&lt;span&gt; getMappings() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappingLookup;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;         * Return matches for the given URL path. Not thread-safe.
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #acquireReadLock()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; getMappingsByUrl(String urlPath) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.urlLookup.get(urlPath);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;...........
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;②根据HandlerMethod解析容器中对应的bean（控制层bean）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;根据上一步得到HandlerMethod，其中bean为bean的名字，将其替换成容器中的bean（控制层对应的bean），调HandlerMethod的&lt;span lang=&quot;EN-US&quot;&gt;createWithResolvedBean方法，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * If the provided instance contains a bean name rather than an object instance,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * the bean name is resolved before a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HandlerMethod} is created and returned.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HandlerMethod createWithResolvedBean() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Object handler = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bean;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.bean &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             String beanName = (String) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bean;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             handler = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.getBean(beanName);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HandlerMethod(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, handler);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中handler为控制层对应的bean，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007125150229-1759630548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，重新构建HandlerMethod，用真实的bean替换掉原来的bean名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007125416375-1909230328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，上边涉及的HandlerMapping的类结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007125513644-1769110958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、确定适配器&lt;/h3&gt;
&lt;p&gt;存在3种适配器，存储在handlerAdapters中，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007130205191-1342230068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DispatcherServlet方法getHandlerAdapter，根据上一步获取到的处理器HandlerMethod，确定匹配的适配器，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Return the HandlerAdapter for this handler object.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler the handler object to find an adapter for 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; HandlerAdapter getHandlerAdapter(Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历所有适配器，如下图。其中handler值为public java.util.List&amp;lt;com.service.entity.TaskVO&amp;gt; com.service.controller.TaskController.getTaskListById(java.lang.String) ，判断适配器是否支持该接口，在本例中RequestMappingHandlerAdapter支持&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (HandlerAdapter ha : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlerAdapters) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
                logger.trace(&lt;/span&gt;&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;&lt;span&gt;);
            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否支持，代码见下边&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ha.supports(handler)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ha;
            }
        }
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;No adapter for handler [&quot; + handler +
                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在GET请求中，由于使用注解@RequestMapping，获取到适配器为：org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter（继承自AbstractHandlerMethodAdapter），support方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;AbstractHandlerMethodAdapter&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;     * This implementation expects the handler to be an {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HandlerMethod}.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler the handler instance to check
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; whether or not this adapter can adapt the given handler
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supports(Object handler) {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (handler &lt;span&gt;instanceof&lt;/span&gt; HandlerMethod &amp;amp;&amp;amp;&lt;span&gt; supportsInternal((HandlerMethod) handler));
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; RequestMappingHandlerAdapter的supportsInternal方法总返回true，因为接口方法参数和返回值可能存在其他的处理，参数可由HandlerMethodArgumentResolver处理（见后续文章），返回值可由HandlerMethodReturnValueHandler处理（见上篇）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Always return {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} since any method argument and return value
     * type will be processed in some way. A method argument not recognized
     * by any HandlerMethodArgumentResolver is interpreted as a request parameter
     * if it is a simple type, or as a model attribute otherwise. A return value
     * not recognized by any HandlerMethodReturnValueHandler will be interpreted
     * as a model attribute.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supportsInternal(HandlerMethod handlerMethod) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最终适配器返回结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007130638027-84854967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3、请求实际处理，包括请求参数的处理、后台接口的调用和返回数据的处理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;调RequestMappingHandlerAdapter的handle方法，对请求进行处理，会调&lt;/span&gt;ServletInvocableHandlerMethod的invokeAndHandle方法，其控制整个请求和响应返回的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Invokes the method and handles the return value through one of the
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * configured {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HandlerMethodReturnValueHandler}s.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; webRequest the current request
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mavContainer the ModelAndViewContainer for this request
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; providedArgs &quot;given&quot; arguments matched by type (not resolved)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeAndHandle(ServletWebRequest webRequest,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             ModelAndViewContainer mavContainer, Object... providedArgs) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①请求对应的方法，底层采用反射的方式(通过HandleMethod获取控制层的方法和bean，实现反射。第一步已获取到HandleMethod)&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Object returnValue =&lt;span&gt; invokeForRequest(webRequest, mavContainer, providedArgs);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        setResponseStatus(webRequest);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (returnValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (isRequestNotModified(webRequest) || hasResponseStatus() ||&lt;span&gt; mavContainer.isRequestHandled()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 mavContainer.setRequestHandled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (StringUtils.hasText(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.responseReason)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             mavContainer.setRequestHandled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         mavContainer.setRequestHandled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②对方法返回的数据，进行处理，包括切面处理和数据转换（如json）&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returnValueHandlers.handleReturnValue(
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                    returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;&lt;span&gt;, returnValue), ex);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;①请求对应的方法，底层采用反射的方式&lt;/h4&gt;
&lt;p&gt;解析请求参数，调后台接口，返回结果数据，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Invoke the method after resolving its argument values in the context of the given request.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Argument values are commonly resolved through {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HandlerMethodArgumentResolver}s.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * The {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; providedArgs} parameter however may supply argument values to be used directly,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * i.e. without argument resolution. Examples of provided argument values include a
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; WebDataBinder}, a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SessionStatus}, or a thrown exception instance.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * Provided argument values are checked before argument resolvers.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request the current request
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mavContainer the ModelAndViewContainer for this request
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; providedArgs &quot;given&quot; arguments matched by type, not resolved
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the raw value returned by the invoked method
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@exception&lt;/span&gt;&lt;span&gt; Exception raised if no suitable argument resolver can be found,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * or if the method raised an exception
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             Object... providedArgs) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取并处理请求参数&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Object[] args =&lt;span&gt; getMethodArgumentValues(request, mavContainer, providedArgs);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             StringBuilder sb = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;Invoking [&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            sb.append(Arrays.asList(args));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            logger.trace(sb.toString());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射调用HandlerMethod中bean对应的接口&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         Object returnValue =&lt;span&gt; doInvoke(args);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnValue;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;②对方法返回的数据，进行处理，包括切面处理和数据转换&lt;/h4&gt;
&lt;p&gt;参见上篇文章&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/shuimuzhushui/p/9724583.html&quot;&gt;SpringCloud请求响应数据转换（一）&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;请求过程涉及的类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201810/1012728-20181007132015083-1569686139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 07 Oct 2018 05:22:00 +0000</pubDate>
<dc:creator>水木竹水</dc:creator>
<og:description>上篇文章记录了从后端接口返回数据经过切面和消息转换器处理后返回给前端的过程。接下来，记录从请求发出后到后端接口调用过的过程。 web请求处理流程 源码分析 ApplicationFilterChain</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuimuzhushui/p/9732526.html</dc:identifier>
</item>
<item>
<title>Linux tee的花式用法和pee - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9749882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9749882.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;tee [options] FILE1 FILE2 FILE3...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tee的作用是将一份标准输入多重定向，一份重定向到标准输出/dev/stdout，然后还将标准输入重定向到每个文件FILE中。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat alpha.log | tee file1 file2 file3 | cat
$ cat alpha.log | tee file1 file2 file3 &amp;gt;/dev/null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面第一个命令将alpha.log的文件内容重定向给file{1..3}和标准输出通过管道传递给cat；&lt;br/&gt;上面第二个命令将alpha.log的文件内容重定向给file{1..3}和/dev/null。&lt;/p&gt;
&lt;h2 id=&quot;tee重定向给多个命令&quot;&gt;tee重定向给多个命令&lt;/h2&gt;
&lt;p&gt;写多了脚本的人可能遇到过这样一种需求：将一份标准输入，重定向到多个命令中去。大概是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                      | CMD1
                    ↗
        INPUT | tee 
                    ↘
                      | CMD2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实bash自身的特性就能实现这样的需求，通过重定向到子shell中，就能模拟一个文件重定向行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat alpha.txt | tee &amp;gt;(grep -E &quot;a|b&quot;) &amp;gt;(grep -E &quot;d|b|c&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的命令将alpha.txt文件内容重定向为3份：一份给第一个grep命令，一份给第二个grep命令，一份给标准输出。假如alpha.txt的内容是&lt;code&gt;a b c d e&lt;/code&gt;5个字母分别占用5行(每行一个字母)，上面的输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a
b
c
d
e  # 前5行是重定向到/dev/stdout的
a
b  # 这2行是重定向给第一个grep后的执行结果
b
c
d  # 这3行是重定向给第二个grep后的执行结果&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不想要给标准输出的那份重定向，加上&lt;code&gt;&amp;gt;/dev/null&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat alpha.txt | tee &amp;gt;(grep -E &quot;a|b&quot;) &amp;gt;(grep -E &quot;d|b|c&quot;) &amp;gt;/dev/null&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tee重定向给多个命令时的问题&quot;&gt;tee重定向给多个命令时的问题&lt;/h2&gt;
&lt;p&gt;但是必须注意，&lt;strong&gt;tee将数据重定向给不同命令时，这些命令是独立执行的，它们都会各自打开一个属于自己的STDOUT&lt;/strong&gt;，如果它们都重定向到标准输出，由于涉及到多个不同的/dev/stdout，它们的结果将出现两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;不保证有序性&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;因为跨了命令，交互式模式下(默认标准输出为屏幕)可能会出现命令行隔断的问题(非交互式下不会有问题)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat alpha.txt | tee &amp;gt;(grep -E &quot;a|b&quot;) &amp;gt;(grep -E &quot;d|b|c&quot;) &amp;gt;/dev/null
$ a     # 结果直接出现在提示符所在行
b
b
c
d

$ cat alpha.txt | tee &amp;gt;(grep -E &quot;a|b&quot;) &amp;gt;(grep -E &quot;d|b|c&quot;) &amp;gt;/dev/null
b
c      # 这次的结果和上次的顺序不一样
d
a
b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个问题，在写脚本过程中必须解决。&lt;/p&gt;
&lt;p&gt;对于第二个问题：不同/dev/stdout同时输出时在屏幕上交叉输出的问题，只需将它们再次重定向走即可，这样两份不同的/dev/stdout都再次同时作为一份标准输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat alpha.txt | tee &amp;gt;(grep -E &quot;a|b&quot;) &amp;gt;(grep -E &quot;d|b|c&quot;) &amp;gt;/dev/null | cat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第一个问题：不同/dev/stdout同时输出时，输出顺序的随机性，这个没有好方法，只能在各命令行中将各自的结果保存到文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat alpha.txt | tee &amp;gt;(grep -E &quot;a|b&quot; &amp;gt;file1) &amp;gt;(grep -E &quot;d|b|c&quot; &amp;gt;file2) &amp;gt;/dev/null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，tee在重定向到多个命令中是有缺陷的，或者说用起来非常不方便，只要将各命令的结果各自保存时，才能一切按照自己的预期进行。那么，pee登场了，多重定向非常好用的一个命令。&lt;/p&gt;

&lt;p&gt;pee是moreutils包中的一个小工具，先安装它(epel源中有)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install moreutils&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在man pee中，pee的作用是将标准输入tee给管道。语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pee [&quot;cmds&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不是很好理解，可以通过几个示例直接感受它的用法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat alpha.txt | pee 'grep -E &quot;a|b&quot;' 'grep -E &quot;d|b|c&quot;'
a
b
b
c
d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，它的基本用法是&lt;code&gt;pee &quot;CMD1&quot; &quot;CMD2&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果想将结果保存到文件，只需加一个命令即可，例如下面的&lt;code&gt;cat &amp;gt;myfile&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat alpha.txt | pee 'grep -E &quot;a|b&quot;' 'grep -E &quot;d|b|c&quot;' 'cat &amp;gt;myfile'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和tee有同样的问题，如果各命令都没有指定自己的标准输出重定向，它们将各自打开一个属于自己的/dev/stdout，&lt;strong&gt;同样会有多个/dev/stdout同时输出时结果数据顺序随机性的问题&lt;/strong&gt;，但是不会有多个/dev/stdout同时输出时交互式的隔断性问题，因为&lt;strong&gt;pee会收集各个命令的标准输出，然后将收集的结果作为自己的标准输出&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;pee和tee最大的不同，在于pee将来自多个不同命令的结果作为pee自己的标准输出，所以下面的命令是可以像普通命令一样进行重定向的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INPUT | pee CMD1 CMD2 &amp;gt;/FILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而tee则不同，是将cmd1和cmd2的结果放进标准输出(假设各命令自身没有使用重定向)，保存到FILE中的是tee读取的标准输入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INPUT | tee &amp;gt;(cmd1) &amp;gt;(cmd2) &amp;gt;/FILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，想要重定向tee中cmd1和cmd2的总结果，必须使用额外的管道，或者将整个tee放进子shell。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INPUT | tee &amp;gt;(cmd1) &amp;gt;(cmd2) &amp;gt;/dev/null | cat &amp;gt;FILE1
INPUT | ( tee &amp;gt;(cmd1) &amp;gt;(cmd2) &amp;gt;/dev/null ) &amp;gt;/FILE1&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 07 Oct 2018 04:58:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>1.tee多重定向 tee的作用是将一份标准输入多重定向，一份重定向到标准输出/dev/stdout，然后还将标准输入重定向到每个文件FILE中。 例如： 上面第一个命令将alpha.log的文件内容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9749882.html</dc:identifier>
</item>
</channel>
</rss>