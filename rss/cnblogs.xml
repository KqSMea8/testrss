<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 HTML5 Canvas 的 3D 压力器反序列化 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8055953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8055953.html</guid>
<description>&lt;p&gt;在实际应用中，我觉得能够通过操作 JSON 文件来操作 3D 上的场景变化是非常方便的一件事，尤其是在做编辑器进行拖拽图元并且在图元上产生的一系列变化的时候，都能将数据很直观地反应给我们，这边我们简单地做了个基础的例子，给大家参考看看。&lt;/p&gt;
&lt;p&gt;本例地址： &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/serialization/examples/example_exportimport.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/guide/guide/core/serialization/examples/example_exportimport.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实践场景再现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171217215355749-1731031449.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们搭建一下这个例子的场景，熟悉的朋友可能已经看出来了，这个场景分为三个部分：左、右上以及右下。HT 通过 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/splitview/ht-splitview-guide.html&quot; target=&quot;_blank&quot;&gt;ht.widget.SplitView&lt;/a&gt; 可以很轻松地将场景分割，实现良好的页面布局，最后将这个分割组件添加进 html 的 body 体中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;场景搭建&lt;/span&gt;
dataModel = &lt;span&gt;new&lt;/span&gt; ht.DataModel();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据容器&lt;/span&gt;
&lt;span&gt;                
g3d &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.graph3d.Graph3dView(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3D 组件&lt;/span&gt;
propertyView = &lt;span&gt;new&lt;/span&gt; ht.widget.PropertyView(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性组件&lt;/span&gt;
formPane = &lt;span&gt;new&lt;/span&gt; ht.widget.FormPane();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表单组件&lt;/span&gt;
rightSplit = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(propertyView, formPane, 'v', 100);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割组件&lt;/span&gt;
                        
&lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(g3d, rightSplit, 'h', 0.65).addToDOM();  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就是向场景中添加图元，并把图元添加到 3D 场景中，这时我们可以向图元中添加各种属性和样式以及标签作为标记，本例中用到的图元是 3D 模型，利用 &lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/obj/ht-obj-guide.html#ref_parseobj&quot; target=&quot;_blank&quot;&gt;ht.Default.parseObj&lt;/a&gt; 函数对 obj 和 mtl 文件进行解析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加模型&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; params = {center: &lt;span&gt;true&lt;/span&gt;};&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JSON格式控制参数 传入 ht.Default.parseObj 函数中&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; modelMap = ht.Default.parseObj(meter_obj, meter_mtl, params);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析obj和mtl文件， 解析后返回的map结构json对象中，每个材质名对应一个模型信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，前提是要已经声明了 meter_obj 以及 meter_mtl 两个文件，这里我们是将这两个部分分别放到 js 文件中，并在头部调用。&lt;/p&gt;
&lt;p&gt;从上面的动图中我们可以看到，这个例子中需要变化的模型部分只有“指针”以及下面的“开关”两个部分，所以我们通过遍历的方式获取这两个 obj 模型的部分，并注册 3D 模型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; modelMap){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model = modelMap[name];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;modelMap 中的模型&lt;/span&gt;
&lt;span&gt;    array.push(model);
                    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(name === 'pointer'){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj 文件中的一个模型 名称为 pointer&lt;/span&gt;
        model.mat = {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;矩阵变化参数，可对模型进行矩阵变化后导入 &lt;/span&gt;
            func: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; start = Math.PI * 0.736&lt;span&gt;,
                range &lt;/span&gt;= Math.PI * 1.49&lt;span&gt;,   
                angle &lt;/span&gt;= start - range * data.a('meter.value') / 4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态获取了 meter.value 的值&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; ht.Default.createMatrix([&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一组JSON描述的缩放、移动和旋转等操作转换成对应的变化矩阵&lt;/span&gt;
                    { t3: [0, -82.5, 0&lt;span&gt;] },
                    { r3: [&lt;/span&gt;0, 0&lt;span&gt;, angle] },
                    { t3: [&lt;/span&gt;0, 82.5, 0&lt;span&gt;]  }
                ]);
            }
        };                         
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(name === 'switch'){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj 文件中的一个模型 名称为 switch&lt;/span&gt;
        model.mat =&lt;span&gt; {
            func: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ht.Default.createMatrix([
                    { t3: [&lt;/span&gt;0, 48.5, 0&lt;span&gt;] },
                    { r3: [&lt;/span&gt;0, 0, data.a('meter.angle'&lt;span&gt;)] },
                    { t3: [&lt;/span&gt;0, -48.5, 0&lt;span&gt;]  }
                ]);
            }
        }; 
        model.color &lt;/span&gt;=&lt;span&gt; {
            func: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.a('meter.angle'&lt;span&gt;)){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'rgb(186, 0, 0)'&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'black'&lt;span&gt;;
                }
            }
        };
    }
}
ht.Default.setShape3dModel(&lt;/span&gt;'meter', array);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册3D模型，请参考modeling建模手册 第一参数为模型名称，第二参数为 JSON 类型对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后用户可以在需要用到的地方直接设置属性 shape3d 为这边注册过的 3D 模型名称，我们下面就创建 3 个节点，并将节点设置为此 3D 模型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;3; i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建3个节点 meter&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
    node.setTag(i);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 tag 标签&lt;/span&gt;
    node.setName('Meter - 00' + (i+1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图元名称一般显示在图元的下方&lt;/span&gt;
&lt;span&gt;    node.s({
        &lt;/span&gt;'label.color': 'white'&lt;span&gt;,
        &lt;/span&gt;'label.background': '#5271B8'&lt;span&gt;,
        &lt;/span&gt;'label.face': 'center'&lt;span&gt;,
        &lt;/span&gt;'label.position': 23&lt;span&gt;,
        &lt;/span&gt;'label.scale': 2&lt;span&gt;,
        &lt;/span&gt;'label.reverse.flip': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, 
                        
        &lt;/span&gt;'note.scale': 1.5,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体大小，这种方式不会碰到浏览器最小字体的问题&lt;/span&gt;
        'note.t3': [-30, -5, -90&lt;span&gt;], 
                        
        &lt;/span&gt;'note2.scale': 1.2&lt;span&gt;,
        &lt;/span&gt;'note2.position': 17&lt;span&gt;,
        &lt;/span&gt;'note2.t3': [0, -20, -30&lt;span&gt;],
        &lt;/span&gt;'note2.color': 'black'&lt;span&gt;,
        &lt;/span&gt;'note2.background': 'yellow'&lt;span&gt;, 
                        
        &lt;/span&gt;'shape3d': 'meter',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为前面注册的 meter 3D 模型&lt;/span&gt;
        'shape3d.scaleable': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;'wf.visible': 'selected',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选中图元时显示线框&lt;/span&gt;
        'select.brightness': 1&lt;span&gt;
    });
    node.a({&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义属性 下面会利用这些自定义属性进行数据绑定&lt;/span&gt;
        'meter.value': i+1&lt;span&gt;,
        &lt;/span&gt;'meter.angle': i * Math.PI / 3&lt;span&gt;
    });
    node.p3(i&lt;/span&gt;*200-200, params.rawS3[1]/2, i===1?100:-100);                    
    node.r3(0, -Math.PI/6*(i-1), 0);
    node.s3(params.rawS3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图元的大小为 rawS3 模型的原始尺寸&lt;/span&gt;
    dataModel.add(node); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向数据模型中添加节点           &lt;/span&gt;
&lt;span&gt;}
dataModel.sm().ss(dataModel.getDataByTag(&lt;/span&gt;1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置默认选中 tag 标签为1的图元&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在这边为节点添加两个标注，作为文字提示，可以通过重载 getNote/getNote2（HT 中一个节点支持双标注，所以提供了 note2 第二个标注） 函数重载 note 的命名方法，当然 HT 中其他类似的文字提示也可以通过这种途径来改变文字的显示信息，这里我们通过数据绑定获取 meter.value 以及 meter.angle 两个属性的动态数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
g3d.getNote = &lt;span&gt;function&lt;/span&gt;(data){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重载 getNote 方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; 'Value:' + data.a('meter.value').toFixed(2&lt;span&gt;);
};
g3d.getNote2 &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = Math.round(data.a('meter.angle') / Math.PI * 180);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取了 meter.angle 属性，数据实时变化                 &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; value ? 'Angle:' + value : 'Switch is off'&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还在场景的显示部分使了一点小心机~通过改变实现 eye 和 center 的值来实现视线由远及近的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; oldEye = g3d.getEye().slice(0&lt;span&gt;),
oldCenter &lt;/span&gt;= g3d.getCenter().slice(0&lt;span&gt;),
newEye &lt;/span&gt;= [200, 300, 650&lt;span&gt;],
newCenter &lt;/span&gt;= [0, params.rawS3[1]/2, 0];
&lt;span&gt;
ht.Default.startAnim({&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动画              &lt;/span&gt;
    duration: 1000,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持续时间&lt;/span&gt;
    easing: &lt;span&gt;function&lt;/span&gt;(t){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动画缓动函数，默认采用 ht.Default.animEasing&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (t *= 2) &amp;lt; 1 ? 0.5 * t * t : 0.5 * (1 - (--t) * (t - 2&lt;span&gt;));                      
    },
    action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(k){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;action 函数必须提供，实现动画过程中的属性变化 参数 k 代表通过 &lt;code&gt;easing(t) &lt;/code&gt;函数运算后的值&lt;/span&gt;
&lt;span&gt;        g3d.setEye(
            oldEye[&lt;/span&gt;0] + (newEye[0] - oldEye[0]) *&lt;span&gt; k,
            oldEye[&lt;/span&gt;1] + (newEye[1] - oldEye[1]) *&lt;span&gt; k,
            oldEye[&lt;/span&gt;2] + (newEye[2] - oldEye[2]) *&lt;span&gt; k
        );
        g3d.setCenter(
            oldCenter[&lt;/span&gt;0] + (newCenter[0] - oldCenter[0]) *&lt;span&gt; k,
            oldCenter[&lt;/span&gt;1] + (newCenter[1] - oldCenter[1]) *&lt;span&gt; k,
            oldCenter[&lt;/span&gt;2] + (newCenter[2] - oldCenter[2]) *&lt;span&gt; k
        );    
    }                  
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个左边实现完成~接着该实现右上部分，属性值的显示以及控制，我们总共添加了四个属性：名称、meter.value、meter.angle以及旋转 rotation，通过数据绑定操作属性栏中的值来改变 3D 模型中的显示状态，数据绑定我们通过获取 accessType 以及 name 中的值来配合调用到这个属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
propertyView.addProperties([&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用 json 的数组参数方式批量添加属性信息&lt;/span&gt;
&lt;span&gt;    {
        name: &lt;/span&gt;'name',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性名 这里不用设置 accessType，因为 accessType 默认的值为 setName/getName 这种格式 &lt;/span&gt;
        editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为可编辑状态&lt;/span&gt;
&lt;span&gt;    },
    {
        name: &lt;/span&gt;'meter.value',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于存取name属性，该属性结合accessType属性最终实现对Data属性的存取&lt;/span&gt;
        accessType: 'attr',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 getAttr/setAttr 获取或设置属性值&lt;/span&gt;
        editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        slider: {
            min: &lt;/span&gt;0&lt;span&gt;,
            max: &lt;/span&gt;4&lt;span&gt;
        }
    },
    {
        name: &lt;/span&gt;'meter.angle'&lt;span&gt;,
        accessType: &lt;/span&gt;'attr'&lt;span&gt;,
        editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        formatValue: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般用于将数字转换更易读的文本格式&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Math.round(value / Math.PI * 180&lt;span&gt;);
        },
        slider: {
            min: &lt;/span&gt;0&lt;span&gt;,
            max: Math.PI,
            step: Math.PI&lt;/span&gt;/180*5,//每移动一下滑动的步进
            getToolTip: &lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置鼠标放在图元上的文字提示&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; Math.round(&lt;span&gt;this&lt;/span&gt;.getValue() / Math.PI * 180&lt;span&gt;);
            }
        }
    },
    {
        name: &lt;/span&gt;'rotation'&lt;span&gt;,
        editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        formatValue: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.round(value / Math.PI * 180&lt;span&gt;);
        },
        slider: {
            min: &lt;/span&gt;-&lt;span&gt;Math.PI,
            max: Math.PI,
            step: Math.PI&lt;/span&gt;/180*5,
            getToolTip: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.round(&lt;span&gt;this&lt;/span&gt;.getValue() / Math.PI * 180&lt;span&gt;);
            }
        }
    }                    
]); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后进行右下部分 formPane 表单面板的解析，formPane 通过 addRow 函数向表单中添加行，这个表单中总共两行，其中第一行有两个部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
formPane.addRow([&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向表单组件中添加行&lt;/span&gt;
&lt;span&gt;    {
        id: &lt;/span&gt;'export'&lt;span&gt;,
        button: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按钮                              &lt;/span&gt;
            label: 'Export JSON'&lt;span&gt;,
            onClicked: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击时触发的函数&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; dataModel.serialize();
                formPane.v(&lt;/span&gt;'textArea'&lt;span&gt;, json);
            }
        }
    },
    {
        button: {                            
            label: &lt;/span&gt;'Import JSON'&lt;span&gt;,
            onClicked: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                dataModel.clear();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空数据模型&lt;/span&gt;
                dataModel.deserialize(formPane.v('textArea'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将获取到的 textArea 中的数据反序列化，是下面一行的 id 值&lt;/span&gt;
&lt;span&gt;            }
        }
    }
],
[&lt;/span&gt;0.1, 0.1]);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后的参数是这行的宽度分配比例 小于1的值为比例，大于1为实际值                             &lt;/span&gt;
&lt;span&gt;formPane.addRow([
    {
        id: &lt;/span&gt;'textArea'&lt;span&gt;,
        textArea: {
        }
    }
],
[&lt;/span&gt;0.1], 0.1);  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们就可以根据修改属性栏中或者 JSON 文件，直接看到 3D 中我们修改的效果啦~怎么样？是不是很酷很快？&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 23:45:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8055953.html</dc:identifier>
</item>
<item>
<title>写在2017年末微清单汇总 - Avenstar</title>
<link>http://www.cnblogs.com/zjf-1992/p/8055948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjf-1992/p/8055948.html</guid>
<description>&lt;p&gt;这个时候仿佛又到写年终总结的时候了，磕磕绊绊，细细思索，感觉目前学的东西还是挺碎片化的，记得有前辈说，&quot;先有了深度，再有广度你的知识才有价值&quot;。&lt;/p&gt;
&lt;p&gt;前端开发难免会遇到诸多困境， 一边面临知识深度不足窘迫同时又要追求广度，如学习新的框架Vue.js;   在面对深度与广度2种情况下，学习难免就会陷入困境。&lt;/p&gt;
&lt;p&gt;就同挖渠一样，这边挖下下......，那边挖下下......，最终什么也没有......好的状态就是渠挖成了，将水流引入开垦荒地，旁边种上果园，劳动、睡觉的同时又能获得丰收.......&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(图片 源自 蔡垒磊 分享  如有版权问题， 可立即删除)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819169/201712/819169-20171217134342374-310664753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;一、技能、工作方面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前端开发技能方面仍然采用传统的开发模式即 以jQuery为核心&lt;strong&gt;&quot;万金油&quot;&lt;/strong&gt;（如下图所示）技术全栈开发模式&lt;span&gt;（标注: 这种模式不包括Electron）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819169/201712/819169-20171217201631030-1720111741.jpg&quot; alt=&quot;&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要出于以下优点考虑&lt;/p&gt;
&lt;p&gt;a.代码模块化,便于维护&lt;/p&gt;
&lt;p&gt;b. 兼容性良好，能够很好的兼容低版本浏览器，&lt;/p&gt;
&lt;p&gt;c.对没有使用过Angular/Vue项目开发经验的前端开发者，更容易上手，研发成本低&lt;/p&gt;
&lt;p&gt;添加Electron楼主主要出于总结, Electron主要用于构建桌面应用程序浏览器环境是&lt;strong&gt;Chromium&lt;/strong&gt;即Google，无需考虑兼容性，这里不再赘述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819169/201712/819169-20171217142919405-492092673.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目应用场景： 构建桌面应用程序类似于桌面微信程序， 具体技术实现细节附相关链接，项目业务不便于透露&lt;/p&gt;
&lt;p&gt;01、构建桌面应用程序实现软件程序打包packager、安装、在线升级&lt;span&gt;更新功能&lt;span&gt;【&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zjf-1992/p/7354931.html&quot;&gt;&lt;span&gt;&lt;span&gt;构建桌面应用程序&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;02、IM(InstantMessaging) 即时通讯/实时传讯  【&lt;span&gt; &lt;a href=&quot;http://www.cnblogs.com/zjf-1992/p/8003740.html&quot;&gt;&lt;span&gt;IM及时通讯&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;03、桌面程序来电未读消息通知  【&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zjf-1992/p/7795786.html&quot;&gt;&lt;span&gt;桌面消息通知：HTML5 Notification&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;】&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;04、桌面应用程序最小化系统托盘 【&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zjf-1992/p/7534944.html&quot;&gt;&lt;span&gt;使用electron将应用程序加入到系统托盘&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;】&lt;/p&gt;
&lt;p&gt;05、关于js代码模块化思维 &lt;span&gt;【&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zjf-1992/p/6403111.html&quot;&gt;&lt;span&gt;require.js模块化&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;06、性能卓越的 js 模板引擎【&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://www.awesomes.cn/repo/aui/arttemplate&quot;&gt;&lt;span&gt;artTemplate前端模板&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;】&lt;/p&gt;
&lt;p&gt;07、实现各种业务逻辑，像通讯/会议管理/待办/公告/申请等..........&lt;/p&gt;
&lt;p&gt;以上比较有深度系统前端知识汇总，下面是比较碎片化、零碎知识点&lt;/p&gt;
&lt;p&gt;01、three.js 三维视图的渲染  &lt;span&gt;【&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zjf-1992/p/6053349.html&quot;&gt;&lt;span&gt;3D视图渲染&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;02、前端流行MVVM框架AngularJS学习 【&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zjf-1992/p/6443897.html&quot;&gt;&lt;span&gt;&lt;span&gt;前端框架AngularJS&lt;/span&gt;】&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;03、Vue.js 前端清新框架学习  【&lt;/span&gt;&lt;span&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zjf-1992/p/7841156.html&quot;&gt;&lt;span&gt;Vue.js优雅的实现列表清单&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;】&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;04、JavaScript拖拽知识学习 【&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zjf-1992/p/6832941.html&quot;&gt;&lt;span&gt;拖拽系列系列知识&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 二、个人知识管理模块 （进行贴标签、整理、归类）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;喜欢从生活中提取素材整理归类；致力于做一个干练、利落、帅气、阳光的程序员、喜欢跑步、阅读与写作，乐于知识的积累与分享~.&lt;/p&gt;
&lt;p&gt;楼主分享一下对心智认知、精力管理、知识管理、时间管理、财务管理产生较深影响的一些书籍......希望对你有帮助哦......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819169/201712/819169-20171210101732622-1034757529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 三、正确的事，天天做&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很多时候，我们通常把自己知道要做的事（感觉懂得道理）却没有践行起来，往往归咎于自己没有时间或没有毅力，其实是在自己内心深处就不想做。&lt;/p&gt;
&lt;p&gt;内心深处没有真正意义上的领悟或把自己说服，获得好的反馈，正确的事——天天做。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819169/201712/819169-20171217163505014-1953176458.png&quot; alt=&quot;&quot; height=&quot;160px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、坚持阅读，每天写记录&lt;/p&gt;
&lt;p&gt;2、坚持看TED （technology, entertainment, design）&lt;/p&gt;
&lt;p class=&quot;f-c3 mname&quot;&gt;&lt;span class=&quot;f-fl f-thide sname&quot;&gt;       如何掌握你的自由时间  http://open.163.com/movie/2016/12/I/B/MC82BCQAN_MC8U8L3IB.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       学会向没有借东西  http://open.163.com/movie/2015/7/M/5/MATL76APV_MATLED6M5.html&lt;/p&gt;
&lt;p&gt;       黄金圈法则  http://open.163.com/movie/2011/7/0/A/M78065A8E_M7806OF0A.html&lt;/p&gt;
&lt;p&gt;       手绘-津巴多心理学-时间的秘密力量 https://link.jianshu.com?t=https://v.qq.com/x/page/a01671n6j17.html&lt;/p&gt;
&lt;p&gt;       TED-时间管理-luare·vanderkam https://link.jianshu.com?t=https://v.qq.com/x/page/r03764zba19.html&lt;/p&gt;
&lt;p&gt;       霸王课-一张图讲完时间管理-纪元 https://link.jianshu.com?t=https://v.qq.com/x/page/d03813dc9wl.html&lt;/p&gt;
&lt;p&gt;       霸王课-时间管理一日看人生-叶武滨 https://link.jianshu.com?t=http://v.youku.com/v_show/id_XMTQzOTMyMjUwNA==.html#paction&lt;/p&gt;
&lt;p&gt;       TED-你有拖延症吗？ http://open.163.com/movie/2016/3/Q/E/MBHQSM52F_MBI15O7QE.html&lt;/p&gt;
&lt;p&gt;       TED-你有拖延症吗？-续篇  http://open.163.com/movie/2016/4/9/7/MBKJF3H00_MBKJGU197.html?recomend=2&lt;/p&gt;
&lt;p&gt;3、坚持践行GTD,  将自己知识模块化、组块放置在框架中;  推荐GTD践行博客 &lt;span&gt;【&lt;span&gt;&lt;span&gt;&lt;a href=&quot;%20http://www.gtdlife.com/service-and-products/contact-for-share/&quot;&gt;&lt;span&gt;时间管理博客&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、不断更新知识管理PKM中 临界知识（四两拨千斤知识）、乔哈里窗格、黄金圈法则、复利效应&lt;/p&gt;
&lt;p&gt;5、坚持运动跑步&lt;/p&gt;

</description>
<pubDate>Sun, 17 Dec 2017 23:41:00 +0000</pubDate>
<dc:creator>Avenstar</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjf-1992/p/8055948.html</dc:identifier>
</item>
<item>
<title>lodash源码分析之compact中的遍历 - 对角另一面</title>
<link>http://www.cnblogs.com/hefty/p/8055931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hefty/p/8055931.html</guid>
<description>&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;小时候，&lt;/p&gt;
&lt;p&gt;乡愁是一枚小小的邮票，&lt;/p&gt;
&lt;p&gt;我在这头，&lt;/p&gt;
&lt;p&gt;母亲在那头。&lt;/p&gt;
&lt;p&gt;长大后，乡愁是一张窄窄的船票，&lt;/p&gt;
&lt;p&gt;我在这头，&lt;/p&gt;
&lt;p&gt;新娘在那头。&lt;/p&gt;
&lt;p&gt;后来啊，&lt;/p&gt;
&lt;p&gt;乡愁是一方矮矮的坟墓，&lt;/p&gt;
&lt;p&gt;我在外头，&lt;/p&gt;
&lt;p&gt;母亲在里头。&lt;/p&gt;
&lt;p&gt;而现在，&lt;/p&gt;
&lt;p&gt;乡愁是一湾浅浅的海峡，&lt;/p&gt;
&lt;p&gt;我在这头，&lt;/p&gt;
&lt;p&gt;大陆在那头。&lt;/p&gt;
&lt;p&gt;——余光中《乡愁》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文为读 lodash 源码的第三篇，后续文章会更新到这个仓库中，欢迎 star：&lt;a href=&quot;https://github.com/yeyuqiudeng/pocket-lodash&quot;&gt;pocket-lodash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gitbook也会同步仓库的更新，gitbook地址：&lt;a href=&quot;https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details&quot;&gt;pocket-lodash&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;作用与用法&quot;&gt;作用与用法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;compact&lt;/code&gt; 函数用来去除数组中的假值，并返回由不为假值元素组成的新数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;false&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt;、 &lt;code&gt;&quot;&quot;&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 都为假值。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;NaN&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;]
&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;compact&lt;/span&gt;(arr) &lt;span class=&quot;co&quot;&gt;// 返回 [1，2，3，4，5]&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;compact&lt;/span&gt;(array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; resIndex &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (array &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; result
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; value of array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      result[resIndex&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; value
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; result
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;compact&lt;/code&gt; 的源码只有寥寥几行，相当简单。&lt;/p&gt;
&lt;p&gt;首先判断传入的数组是否为 &lt;code&gt;null&lt;/code&gt; 或者 &lt;code&gt;undefined&lt;/code&gt;，如果是，则返回空数组。&lt;/p&gt;
&lt;p&gt;然后用 &lt;code&gt;for...of&lt;/code&gt; 来取得数组中每项的值，如果不为假值，则存入新数组 &lt;code&gt;result&lt;/code&gt; 中，最后将新数组返回。&lt;/p&gt;
&lt;p&gt;到这里，源码分析完了。&lt;/p&gt;
&lt;p&gt;但是在看源码的时候，发现这里用了 &lt;code&gt;for...of&lt;/code&gt; 来做遍历，其实除了 &lt;code&gt;for...of&lt;/code&gt; 外，也可以用 &lt;code&gt;for&lt;/code&gt; 或者 &lt;code&gt;for...in&lt;/code&gt; 来做遍历，那为什么最后选了 &lt;code&gt;for...of&lt;/code&gt; 呢？&lt;/p&gt;
&lt;h2 id=&quot;数组中的for循环&quot;&gt;数组中的for循环&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;for&lt;/code&gt; 循环，很容易就将 &lt;code&gt;compact&lt;/code&gt; 中关于循环部分的源码改写成以下形式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; array[i]
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      result[resIndex&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; value
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写，肯定是没有问题的，但是数组不总是密集的，也有可能是稀疏数组，假如：&lt;code&gt;var arr = [1,2,3,,4,,5]&lt;/code&gt; 这样的稀疏数组，会出现2次无效的循环。&lt;/p&gt;
&lt;p&gt;关于稀疏数组，可以看本系列的第一篇文章《&lt;a href=&quot;https://github.com/yeyuqiudeng/pocket-lodash/blob/master/slice.md&quot;&gt;读lodash源码之从slice看稀疏数组与密集数组&lt;/a&gt;》。&lt;/p&gt;
&lt;h2 id=&quot;forin&quot;&gt;for…in&lt;/h2&gt;
&lt;p&gt;再来看 &lt;code&gt;for...in&lt;/code&gt; 循环，先来将源码改写一下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; index &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; array[i]
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    result[resIndex&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; value
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看看MDN上关于 &lt;code&gt;for...in&lt;/code&gt; 的用法：&lt;/p&gt;
&lt;blockquote readability=&quot;3.8970588235294&quot;&gt;
&lt;p&gt;&lt;strong&gt;for...in语句&lt;/strong&gt;以任意顺序遍历一个对象的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;可枚举属性&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于可枚举属性，可以点击上面的链接到MDN上了解一下，这里不做太多的解释。&lt;/p&gt;
&lt;p&gt;在数组中，数组的索引是可枚举属性，可以用 &lt;code&gt;for...in&lt;/code&gt; 来遍历数组的索引，数组中的稀疏部分不存在索引，可以避免用 &lt;code&gt;for&lt;/code&gt; 循环造成无效遍历的弊端。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;for...in&lt;/code&gt; 有两个致命的特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;for...in&lt;/code&gt; 的遍历不能保证顺序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for...in&lt;/code&gt; 会遍历所有可枚举属性，包括继承的属性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;for...in&lt;/code&gt; 的遍历顺序依赖于执行环境，不同执行环境的实现方式可能会不一样。单凭这一点，就断然不能在数组遍历中使用 &lt;code&gt;for...in&lt;/code&gt;，大多数情况下，顺序对于数组的遍历都相当重要。&lt;/p&gt;
&lt;p&gt;关于第二点，先看个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'foo'&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; index &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; arr) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(index)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，你期望输出的是 &lt;code&gt;0,1,2&lt;/code&gt;，但是最后输出的可能是 &lt;code&gt;0,1,2,foo&lt;/code&gt; （&lt;code&gt;for...in&lt;/code&gt; 不能保证顺序）。因为 &lt;code&gt;foo&lt;/code&gt; 也是可枚举属性，在 &lt;code&gt;for..in&lt;/code&gt; 会被遍历出来。&lt;/p&gt;
&lt;h2 id=&quot;forof&quot;&gt;for…of&lt;/h2&gt;
&lt;p&gt;最后来看看 &lt;code&gt;for...of&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当我们在控制台中打印一个数组，并将它展开来查看时，会在数组的原型链上发现一个很特别的属性 &lt;code&gt;Symbol.iterator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其实 &lt;code&gt;for...of&lt;/code&gt; 循环内部调用的就是数组原型链上的 &lt;code&gt;Symbol.iterator&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt; 在调用的时候会返回一个遍历器对象，这个遍历器对象中包含 &lt;code&gt;next&lt;/code&gt; 方法，&lt;code&gt;for...of&lt;/code&gt; 在每次循环的时候都会调用 &lt;code&gt;next&lt;/code&gt; 方法来获取值，直到 &lt;code&gt;next&lt;/code&gt; 返回的对象中的 &lt;code&gt;done&lt;/code&gt;属性值为 &lt;code&gt;true&lt;/code&gt; 时停止。&lt;/p&gt;
&lt;p&gt;其实我们也可以手动调用来模拟遍历的过程：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; iterator &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a[&lt;span class=&quot;va&quot;&gt;Symbol&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;iterator&lt;/span&gt;]()
&lt;span class=&quot;va&quot;&gt;iterator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;next&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// {value: 1, done: false}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;iterator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;next&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// {value: 2, done: false}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;iterator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;next&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// {value: 3, done: false}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;iterator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;next&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// {value: undefined, done: true}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;知道这些原理后，完全可以改写数组中的 &lt;code&gt;Symbol.iterator&lt;/code&gt; 方法，例如遍历时将数组中的值都乘2：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;[&lt;span class=&quot;va&quot;&gt;Symbol&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;iterator&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; index &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; _self &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (index &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;_self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; _self[index&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code&gt;Generator&lt;/code&gt; 函数可以写成以下的形式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;[&lt;span class=&quot;va&quot;&gt;Symbol&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;iterator&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; index &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; (index &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[index&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;   
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此在不改写 &lt;code&gt;Symbol.iterator&lt;/code&gt; 的情况下，使用 &lt;code&gt;for...of&lt;/code&gt; 来遍历数组是安全的，因为这个方法是数组的原生方法，而且使用 &lt;code&gt;for...of&lt;/code&gt; 来遍历同样不会遍历数组中稀疏数部分。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;Iterator&lt;/code&gt; 和 &lt;code&gt;Generator&lt;/code&gt; 可以点击&lt;a href=&quot;http://www.cnblogs.com/hefty/p/8055931.html#参考&quot;&gt;参考&lt;/a&gt;中的链接详细查看。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterables&quot;&gt;MDN:迭代器和生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/iterator&quot;&gt;Iterator 和 for...of 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/generator&quot;&gt;Generator 函数的语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dreamapple.me/2017/08/18/lodash%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3-3/&quot;&gt;Lodash源码讲解(3)-compact函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;MDN:for...of&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN:for…in&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见： &lt;img src=&quot;https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：对角另一面&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 23:31:00 +0000</pubDate>
<dc:creator>对角另一面</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hefty/p/8055931.html</dc:identifier>
</item>
<item>
<title>分布式系统中的必备良药 —— RPC - Zachary_Fan</title>
<link>http://www.cnblogs.com/Zachary-Fan/p/rpc_overview.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zachary-Fan/p/rpc_overview.html</guid>
<description>

&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　在上一篇分布式系统系列中《&lt;a href=&quot;http://www.cnblogs.com/Zachary-Fan/p/service_manage_discovery.html&quot; target=&quot;_blank&quot;&gt;分布式系统中的必备良药 —— 服务治理&lt;/a&gt;》中阐述了服务治理的一些概念，那么与服务治理配套的必然会涉及到RPC框架。在当前互联网的大背景下，RPC的运用应该大家或多或少都有涉及，国内外的RPC框架也是百花齐放。那么各个RPC框架各自有什么特点，另外RPC的核心点又是哪些，我们该如何去选择是本文需要讲述的内容。本文会围绕.Net技术栈来展开，暂不讨论诸如dubbo之类对.Net 不太友好的框架。&lt;/p&gt;


&lt;h2&gt;二、成熟的解决方案&lt;/h2&gt;
&lt;p&gt;　　1.Google.gRpc（&lt;a href=&quot;https://github.com/grpc/grpc&quot; target=&quot;_blank&quot;&gt;https://github.com/grpc/grpc&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　　　大名鼎鼎的Google出品的RPC框架，基于Http2设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。使用的时候需要通过定义proto文件生成客户端和服务端代码，可以跨平台（客户端和服务端生成代码时使用不同的语言）。如果大家已经被微软宠惯了，那么是不太习惯以一个纯txt方式编辑这个proto文件的，毕竟全部需要手打 ╮(╯_╰)╭&lt;/p&gt;
&lt;p&gt;　　2.Facebook.Thrift（&lt;a href=&quot;https://github.com/apache/thrift&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/thrift&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　　　同样是大厂Facebook出品的RPC框架，使用方式和gRpc类似，需要通过定义.thrift文件生成客户端和服务端代码，可以跨平台（客户端和服务端生成代码时使用不同的语言）。Thrift的缺点是无法生成async，await，Task&amp;lt;T&amp;gt;之类的泛型代码，这个对于当下大背景来说有一定的局限性（如果有小伙伴知道如何解决此问题，感谢赐教）。Thrift最大的特点是5种适用不同场景的服务模型，一图胜千言，直接上图，见图1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/397048/201712/397048-20171213170959207-1740385710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　【图1】&lt;/p&gt;
&lt;p&gt; 　　　　但是遗憾的是Apache在.Net下提供的实现并不是上面的5种模式，仅仅3种（TSimpleServer、TThreadPoolServer、TThreadedServer），特别是在Java下大规模宣传的NIO模式没有提供实现。&lt;/p&gt;
&lt;p&gt;　　3.Orleans（&lt;a href=&quot;http://dotnet.github.io/orleans/&quot; target=&quot;_blank&quot;&gt;http://dotnet.github.io/orleans/&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　　　这是微软在2015开源的构建分布式应用的框架。（什么意思？那它是RPC框架么？）我想这是大部分对Orleans不熟悉的同学的疑问，实际上Orleans的层次比RPC框架更高，它不仅仅解决了远程调用问题，其内部还包含了服务发现、负载均衡、高可用等一些处理机制。一般用Akka（有.net版本 Akka.net）和它对标，都是基于Actor模型设计的分布式框架，顺手附上一篇经典的对比文章：&lt;a href=&quot;https://github.com/akka/akka-meta/blob/master/ComparisonWithOrleans.md&quot; target=&quot;_blank&quot;&gt;https://github.com/akka/akka-meta/blob/master/ComparisonWithOrleans.md&lt;/a&gt; 。Orleans最大的特点就是微软一向的风格，高度封装，提高生产力。面向OOP的设计，便于使用，大家可以在文末下载Demo感受一下，手感和WCF比较类似。&lt;/p&gt;
&lt;p&gt;　　4.WCF&lt;/p&gt;
&lt;p&gt;　　　　这应该是.net系下做分布式系统开发中的RPC标配了，随着.net framework3.5在2007年推出，可谓功能丰富，而且支持的协议相比其它框架也是最多（没有之一）。&lt;/p&gt;
&lt;p&gt;　　5.WebApi&lt;/p&gt;
&lt;p&gt;　　　　这是随着VS2012一起推出的REST化API的一项web服务。近几年随着整个大环境的变化，逐渐有代替WCF的趋势。跨平台（特别是针对移动端有很大优势）、便于开放共享和测试是他相对WCF的最大优势。&lt;/p&gt;


&lt;h2&gt;三、剖析&lt;/h2&gt;
&lt;p&gt; 　　上面的这些框架说不上孰优孰劣，都有各自适用的场景。那么我们来刨析一下如果要选择哪个RPC框架更适合的话从何处入手。一个RPC框架核心的概念是下面几个：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;网络协议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这是RPC框架的核心，面向什么协议去设计，基本上也已经决定了框架最理想的适用场景了。协议又分为2个大类，分别对应OSI七层模型的应用层（http协议、ftp协议等）和传输层（tcp协议、udp协议）。这其中的协议又有各自的特点，这里就不展开说了。当然有些框架将协议这层做成可适配的，比如WCF（不同协议）、thrift（同协议不同实现），那么他们的覆盖场景肯定就更多，但是相应的框架的实现复杂度肯定也是相应增加，需要考虑是否能接收这带来的额外成本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;7.4093097913323&quot;&gt;
&lt;p&gt;&lt;strong&gt; 序列化方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　序列化一般从3个维度去考虑，数据大小、可读性、传输效率（序列化反序列所消耗的时间）。属于可读性较好的序列化比如Json；属于数据压缩比比较好的序列化比如Protobuf；属于传输效率高的序列化比如MessageShark、MessagePack、Protobuf等。对于对性能十分执着的小伙伴们，这里有一份转载的基准测试报告，连接附上：&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/3294201.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/shanyou/p/3294201.html&lt;/a&gt; 。大部分的框架都会序列化这层做成可适配的，相对网络协议，对序列化的个性化迫求是更强烈的。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;四、性能测试&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;测试环境如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CPU：I5-4300U 1.90GHz  2.50GHz&lt;/p&gt;
&lt;p&gt;　　内存：8G&lt;/p&gt;
&lt;p&gt;　　策略：10000次调用发送封装world字符串的对象HelloRequest，并等待接收返回封装Hello world字符串的HelloReply对象。&lt;/p&gt;
&lt;p&gt;　　网络：数据较小+本地调用，网络不是问题。想进一步测试局域网和大数据的可以基于文末的Demo项目自行改造。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这里需要提一下，WCF的测试使用了http和tcp2种常见的模式，针对webapi的访问使用了HttpClient和HttpWebRequest2种方式。另外值得注意的是，由于Thrift和HttpWebRequest不支持多线程复用同一个实例，故在测试中都是使用每次实例化的方式进行（包括线程数1的时候）。&lt;/p&gt;
&lt;p&gt;　　由于数据比较多，直接付上2个动图，想进一步分析的可以在文末下载excel自行解决~。见图2，图3：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/397048/201712/397048-20171214163817373-1860914723.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　【图2】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/397048/201712/397048-20171214165124732-1117519097.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　【图3】&lt;/p&gt;


&lt;h2&gt;五、结语&lt;/h2&gt;
&lt;p&gt;　　这个是我网上找到的一篇性能相关的文章，大家可以参考一下：&lt;a href=&quot;http://blog.csdn.net/jek123456/article/details/53395206&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/jek123456/article/details/53395206&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　归根到底，大家在使用之前还是需要结合自己的实际情况，放到实际的场景去测一把，看看效果。下面奉上替大家迈出第一步的Demo，大家可以进行进一步的深入研究。&lt;/p&gt;


&lt;p&gt;本文相关的测试数据excel在此：&lt;a href=&quot;https://github.com/ZacharyFan/RpcTest/raw/master/PerfTest.xlsx&quot; target=&quot;_blank&quot;&gt;https://github.com/ZacharyFan/RpcTest/raw/master/PerfTest.xlsx&lt;/a&gt;&lt;a href=&quot;https://files.cnblogs.com/files/Zachary-Fan/RPCTest.rar&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文相关的Demo地址在此：&lt;a href=&quot;https://github.com/ZacharyFan/RpcTest&quot; target=&quot;_blank&quot;&gt;https://github.com/ZacharyFan/RpcTest&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;作者：&lt;a href=&quot;http://www.cnblogs.com/Zachary-Fan&quot; target=&quot;_blank&quot;&gt;Zachary_Fan&lt;/a&gt;&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/Zachary-Fan/p/rpc_overview&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/Zachary-Fan/p/rpc_overview&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;如果你想及时得到个人自写文章的消息推送，欢迎扫描下面的二维码~。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/397048/201706/397048-20170620064950210-569784315.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 22:55:00 +0000</pubDate>
<dc:creator>Zachary_Fan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Zachary-Fan/p/rpc_overview.html</dc:identifier>
</item>
<item>
<title>Python的集合 - 晴天云</title>
<link>http://www.cnblogs.com/qtyun/p/8052079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qtyun/p/8052079.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1. Python的集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 集合的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，&lt;strong&gt; &lt;/strong&gt;集合set是基本数据类型的一种集合类型，它有可变集合(set())和不可变集合(frozenset)两种。Python中的集合set类似列表，但每个元素都必须时独一无二的，无序的。&lt;/p&gt;
&lt;p&gt;　　集合set是无序的、不重复的，是可变的，有add()，remove()等方法。由于集合set是可变的，所以它不存在哈希值。基本功能包括关系测试和消除重复元素。集合对象还支持union(联合)、 intersection(交集)、 difference(差集)和sysmmetric difference(对称差集)等数学运算。&lt;/p&gt;
&lt;p&gt;　　集合set支持 N in set, len(set),和 for N in set。作为一个无序的集合，集合set不记录元素位置或者插入点。因此，集合set不支持 indexing, 或其它类序列的操作。&lt;/p&gt;
&lt;p&gt;　　集合frozenset()是冻结的集合，它是不可变的，存在哈希值，优点是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add()，remove()方法。&lt;/p&gt;
&lt;p&gt;　　因此，Python中集合的作用主要是：去重，把一个列表变成集合，就自动去重；关系测试，测试两组数据之间的交集、差集、并集等关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 集合的操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，集合set的常用操作包括：创建集合set、集合set增加、集合set删除、集合的交集、集合的并集、集合的差集等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2.1 集合的创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，集合的创建可以使用集合的工厂函数set()和frozenset()，但是，set()创建的集合时可变的，frozenset()创建的集合时不可变的，其语法格式分别如下：&lt;/p&gt;
&lt;p&gt;　　集合名 = set(集合值)&lt;/p&gt;
&lt;p&gt;       集合名 = frozenset(集合值)　　&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;（1）创建空集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，当不指定集合的值时，使用工厂函数set()和frozenset()即可创建一个空集合。&lt;/p&gt;
&lt;p&gt;　　例如，创建空集合。　　&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a =&lt;span&gt;set()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; b =&lt;span&gt; frozenset()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;set()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; frozenset()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;（2）用set()方法创建集合&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　　例如，用set()方法创建一个0到10之间的奇数的集合，并打印出来。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_odd =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    number_odd.append(number)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; number_opp_set =&lt;span&gt;set(number_odd)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_opp_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第1行，创建一个空列表。&lt;/p&gt;
&lt;p&gt;　　第2~3行，用函数range()循环生成0到10之间的奇数，然后增加到空列表中。&lt;/p&gt;
&lt;p&gt;　　第4行，将列表中的值传给方法set()，生成一个集合。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 3, 5, 7, 9}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上的代码可以通过列表解析的方式优化为：&lt;/p&gt;
&lt;p&gt;　　代码1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_opp_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　因为Python是解释性语言，代码越少，解释花费的时间也少。&lt;/p&gt;

&lt;p&gt;　　运行结果1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
1 {1, 3, 5, 7, 9} 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;（3）用frozenset()方法创建集合&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　　例如，用frozenset()方法创建一个0到10之间的奇数的集合，并打印出来。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_opp_set_0 =frozenset(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_opp_set_0)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; frozenset({1, 3, 5, 7, 9})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.2.2  集合的增加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　在python中，集合的增加有两种常用方法：add()方法和update()方法。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　(1) add()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　集合的add()方法是把要传入的元素做为一个整体增加到集合中，即实现单元素增加。&lt;/p&gt;
&lt;p&gt;　　例如，定义一个0到10的奇数的集合，然后再用add()方法往里面增加一个偶数2和18，然后再打印出来。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set.add(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; number_opp_set.add(18&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_opp_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第3、4行，都是时使用add()方法分别向集合中增加偶数2和18。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 2, 3, 5, 7, 9, 18}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;（2）update()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　集合update()方法是把要传入的元素拆分，做为单个个体增加到集合中，即多元素增加。&lt;/p&gt;
&lt;p&gt;　　例如，定义一个0到10的奇数的集合，然后再用update()方法往里面增加一个偶数2和18，然后再打印出来。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set.update(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; number_opp_set.update(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_opp_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第3、4行，分别调用update()方法分别向集团中增加偶数2和18.&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, 9, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从以上的运行结果中可知，偶数18倍拆分为1和8分别增加到集合中，并且增加的值都被单引号引起来，这表示增加的是字符窜。这并不是我们需要的结果。&lt;/p&gt;
&lt;p&gt;　　在Python中，如果调用update()方法向集合中增加两个或多个字符组成的值时，该值需要使用中括号或者花括号括起来，即表示为字典或列表的形式。&lt;/p&gt;
&lt;p&gt;　　例如，定义一个0到10的奇数的集合，然后再用update()方法往里面增加一个偶数2和18，即奇数19，然后再打印出来。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set.update(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; number_opp_set.update([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; number_opp_set.update({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_opp_set)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, 9, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.2.3 集合的删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，集合的删除分为两种，一种是删除集合中的值；一种是删除整个集合。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）删除整个集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，当我们需要删除整个集合中时，可使用del 语句直接删除。&lt;/p&gt;
&lt;p&gt;　　例如，将1.2.2 中创建的集合删除。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;集合删除前：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,number_opp_set)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;del&lt;/span&gt;&lt;span&gt;  number_opp_set
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;集合删除后：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,number_opp_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第2行，使用del语句删除集合number_opp_set。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 集合删除前： {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Traceback (most recent call last):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   File &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/PyProject/s14/day2/test_set.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 6, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;集合删除后：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,number_opp_set)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; NameError: name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;number_opp_set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从以上的运行结果可知，使用del语句删除集合时一种永久性的，删除后就集合就不能再被使用。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;（2）删除集合中的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，当我们需要删除集合中的值时，可使用remove()方法。&lt;/p&gt;
&lt;p&gt;　　例如，将1.2.2 中增加到集合中的值删除。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; number_opp_set.update(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; number_opp_set.update([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; number_opp_set.update({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; number_opp_set.remove(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; number_opp_set.remove(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; number_opp_set.remove(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_opp_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第7、8、9行，分别调用remove()方法分别从集合中删除前面增加到集合中的值，并且remove中的参数必须用引号引起来，否则Python解释器无法解析，会提示错误。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 9, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; {1, 3, 5, 7, 9}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.2.3 集合的访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，集合的访问主要有两种，一种是访问整个集合，一种的集合的遍历。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）访问整个集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，访问整个集合，可以直接使用。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到10之间的数字组成的偶数的集合，并访问整个集合。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_even_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(2,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_even_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第1行，使用range()函数和for循环，从2开始，依次遍历到10，且步长为2，再用set()方法，将所有遍历过程中满足步长为2的数字创建为一个集合。&lt;/p&gt;
&lt;p&gt;　　第2行，直接用print打印整个集合。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {2, 4, 6, 8, 10}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　（2）访问集合中的每个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，我们可以使用for循环来遍历访问集合中的每个值。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到10之间的数字组成的偶数的集合，并遍历访问集合中的每个值。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_even_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(2,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_even_set)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; number_evven &lt;span&gt;in&lt;/span&gt;&lt;span&gt; number_even_set:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(number_evven)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {2, 4, 6, 8, 10&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 2
&lt;span&gt;3&lt;/span&gt; 4
&lt;span&gt;4&lt;/span&gt; 6
&lt;span&gt;5&lt;/span&gt; 8
&lt;span&gt;6&lt;/span&gt; 10
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3 集合的关系测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Python中，集合的关系测试包括：并集、交集、差集等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3.1 并集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　集合中，并集也叫合集，即将一个集合和另一个集合合并为一个集合的过程。求并集使用函数union()。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到10之间的数字组成的偶数的集合和奇数集合，然后求其并集。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_even_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(2,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_even_set)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; number_set =&lt;span&gt; number_opp_set.union(number_even_set)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第5行，用函数union()将集合number_opp_set和集合number_even_set合并后赋值给变量number_set。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {2, 4, 6, 8, 10&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从以上的运行结果可知，通过函数union()将两个集合合并为一个集合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.2 交集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　交集就是两个集合中都有的部分，用函数intersection()求两个集合的交集。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到5的数字组成的集合，再创建一个0到10的奇数组成的集合，然后求其交集。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_set_a =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set_a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; number_set =&lt;span&gt; number_set_a.intersection(number_opp_set)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(number_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第5行，使用函数intersection()求集合number_set_a和集合number_opp_set的交集。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 2, 3, 4, 5&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; {1, 3, 5}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从以上的运行结果可知，通过函数intersection()已经把两个集合的公共部分求出来了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.3 差集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　差集就是在两个集合中，在集合a中有，但集合b中没有的部分，或者集合b中有，但集合a中没有的部分。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到5的数字组成的集合，再创建一个0到10的奇数组成的集合，然后求其差集。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_set_a =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set_a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; number_set =&lt;span&gt; number_set_a.difference(number_opp_set)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; _number_set =&lt;span&gt; number_opp_set.difference(number_set_a)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(_number_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第5行，使用函数difference()求集合number_set_a中有，但集合number_opp_set中没有的部分，并赋值给变量number_set。&lt;/p&gt;
&lt;p&gt;　　第7行，使用函数difference()求集合number_opp_set中有，但集合number_set_a中没有的部分，并赋值给变量_number_set。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 2, 3, 4, 5&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; {2, 4&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; {9, 7}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3.4 子集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　判断集合a是否是集合b的子集，使用函数issubset()。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到10的数字组成的集合，再创建一个0到10的奇数组成的集合，然后求其子集。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_set_a =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set_a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; number_set =&lt;span&gt; number_set_a.issubset(number_opp_set)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; _number_set =&lt;span&gt; number_opp_set.issubset(number_set_a)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(_number_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第5行，判断集合number_set_a是否是集合number_opp_set的子集，判断结果赋值给变量number_set。&lt;/p&gt;
&lt;p&gt;　　第7行，判断集合number_opp_set是否是集合number_set_a的子集，判断结果赋值给变量_number_set。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9, 10&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;False
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3.5 父集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　判断集合a是否是集合b的父集，使用函数issuperset()。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到10的数字组成的集合，再创建一个0到10的奇数组成的集合，然后求其父集。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_set_a =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set_a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; number_set =&lt;span&gt; number_set_a.issuperset(number_opp_set)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; _number_set =&lt;span&gt; number_opp_set.issuperset(number_set_a)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(_number_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;p&gt;　　第5行，判断集合number_set_a是否是集合number_opp_set的父集，判断结果赋值给变量number_set。&lt;/p&gt;
&lt;p&gt;　　第7行，判断集合number_opp_set是否是集合number_set_a的父集，判断结果赋值给变量_number_set。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9, 10&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;True
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1.3.5 对称差集&lt;/p&gt;
&lt;p&gt;　　对称差集就是求两个集合中的剔除公共的部分的集合。&lt;/p&gt;
&lt;p&gt;　　例如，创建一个1到5的数字组成的集合，再创建一个0到10的奇数组成的集合，然后求其对称差集。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; number_set_a =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set_a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; number_opp_set =set(number &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; range(1,11,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_opp_set)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; number_set =&lt;span&gt; number_set_a.symmetric_difference(number_opp_set)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(number_set)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; _number_set =&lt;span&gt; number_opp_set.symmetric_difference(number_set_a)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(_number_set)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：&lt;/p&gt;

&lt;p&gt;　　第5行，使用函数symmetric_difference()求集合number_set_a和集合number_opp_set的对称差集，并赋值给变量number_set。&lt;/p&gt;
&lt;p&gt;　　第7行，使用函数symmetric_difference()求集合number_opp_set和集合number_set_a的对称差集，并赋值给变量_number_set。&lt;/p&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1, 2, 3, 4, 5&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1, 3, 5, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; {2, 4, 7, 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; {2, 4, 7, 9}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从以上的运行结果可知，求两个集合的对称差集时，哪个集合写在函数中都行，其结果都一样。&lt;/p&gt;

</description>
<pubDate>Sun, 17 Dec 2017 17:12:00 +0000</pubDate>
<dc:creator>晴天云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qtyun/p/8052079.html</dc:identifier>
</item>
<item>
<title>记录一次参加D2前端技术论坛的杭州之行 - 闰土少年</title>
<link>http://www.cnblogs.com/running-runtu/p/8054061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8054061.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171218005000874-1715042547.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在这里，闰土首先要感谢以下两位大佬提供的门票，分别是来自新浪微博部门的H同学，以及来自小米科技的D同学。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我周六晚上在青旅写完这篇文章过后，第二天上网发现，已经有大佬提前一步在掘金上发布了高质量的观后感文章。同时，我在知乎上也发现了相关的话题讨论，并且不乏或高谈阔论或推心置腹的回答。相比于专业度，闰土可能逊色不少。但是，这篇文章将以一个D2粉丝的角度，来带领大家走进真实的D2现场，一起来感受下闰土此次关于D2的心路历程。（D2手稿）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来，为期两天的“以D2之名”的杭州行，从这儿正式开始~&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;杭州行Day0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;周五下班后，当时base太原的我，拉着我女票立马订了一趟最近的直达航班，从太原武宿机场飞往杭州萧山机场（一张经济舱的飞机票1480RMB，好吧，为了看D2我忍）。&lt;/p&gt;

&lt;p&gt;飞机落地时，已经21点多了，眼瞅着时间已晚，我们决定叫个滴滴打车（全程大约1小时10分钟左右,花了150多RMB软妹币，心疼，继续忍）。我们坐在车的后排，望着窗外一路上忽闪而过的风景，感慨颇多。最后，我们来到了提前预定好的、今晚的住宿地——杭州旅行者漫步主题酒店。&lt;/p&gt;

&lt;p&gt;这家青旅（民宿）位于杭州西湖区曙光路，405元一个床位，拍张照片晒晒今晚我们住哪儿（为了体验高逼格，800多软妹币没了，接着忍）。这次来杭我们准备呆两天，说实话，闰土小编也是头一次住这么有情调的旅馆，心疼我的银子啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171218005112702-580779235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;杭州行Day1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;今早8点半，我们早早地坐车来到了本次D2大会的主办地——阿里巴巴西溪园区5号楼访客中心。这是我第一次踏入阿里巴巴园区，心里莫名的激动。进之前，先拍照膜拜下阿里园区的巍峨雄壮（拍照时正好有一辆黑色的保时捷抢戏，进入镜头，难道阿里的员工已经土豪到这种程度了，令人错愕～）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171218005135061-797215992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在签名布上签了名，接着各自领了参会证，赶紧拍照留念一下。&lt;/p&gt;

&lt;p&gt;进入主会场后，各自落座。然后静静地等待大会的开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171218005159952-2139216546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;先一本正经的打打官腔，还有童鞋不知道什么叫D2吗？&lt;/p&gt;

&lt;p&gt;口答：D2前端技术论坛（Designer &amp;amp; Developer Frontend Technology Forum),简称 D2。当然，你也可以看成是一场前端圈老司机的飙车演出。&lt;/p&gt;

&lt;p&gt;今年第十二届D2的主题为“匠心”，我猜大意估计是，截取了“独具匠心”之意，期待各位同行能发掘更多前端技术领域的工匠精神。&lt;/p&gt;

&lt;p&gt;先贴上本次会议主会场的内容：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;09:30 - 10:15 App 开发解决方案 轻舟 星弛 / 前端专家 / 淘宝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10:30 - 11:15 打造高可靠与高性能的React同构解决方案 六猴 / 前端专家 / 国际UED&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11:30 - 12:15 Microbenchmark for JavaScript 贺师俊 / 前端架构师 / 百姓网&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;13:30 - 14:15 从Web渲染到Web计算 江成 / 前端专家 / 天猫&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;14:30 - 15:15 PWA 带来极速离线Web 田淮仁 / 腾讯&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;15:30 - 16:15 天猫超市Mobile Web的极致体验优化 由校 / 前端专家 / 天猫&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:30 - 17:15 支付宝无线效率工具建设 加里 / 前端专家 / 支付宝&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其实，我这次来参加D2的动机基本上是面基（女票别打我脸～）。在我写了几年代码，却还没有真正入行的时候，我是非常向往能跟和我一样做技术的人在一起的，不管我有没有听懂台上的人在说什么。&lt;/p&gt;

&lt;p&gt;当我慢慢接触到这个圈子之后，我发现，越是接近圈子，就越感觉迷茫不知所措。就像大学从选课到上课一样：&lt;/p&gt;

&lt;p&gt;1、看议程的演讲主题和简介，感觉要学到很多东西了。&lt;/p&gt;
&lt;p&gt;2、在台下听讲师讲，屏幕上是框和线，描述的是业务上的架构流程。事实上我根本看不明白。&lt;/p&gt;
&lt;p&gt;3、如无意外，下一张 slide 就是性能打点，表示用某某某技术之后性能提升了多少。&lt;/p&gt;
&lt;p&gt;4、QA 环节，台下必问生产环境性能。&lt;/p&gt;

&lt;p&gt;套路归套路，但我这次身临现场，还是感受到了技术人的热情，类似于执着追求马赛克般模糊处理的影片一样，丝毫必究，一个像素点也不能多。&lt;/p&gt;

&lt;p&gt;在众多演讲中，能一把抓住G点让我高潮迭起的讲师为数不多，六猴老师算一个。他讲的react同构就很有代入感。比如“随着react的兴起，同构的概念开始流行。JavaScript本身就是门同构的语言，因为它既可以跑在客户端，又可以跑在服务端。在业务路径上，需要从点到线......” 等等，满满的面基气息扑面而来。&lt;/p&gt;

&lt;p&gt;其实，关于这次D2，我为什么想要来现场参与下，有以下几方面原因：一方面我是想看看在我熟悉的领域，其他团队或者童鞋是怎么做的，也希望看到更多新的东西，因为最近两年前端发展变化实在太快。另一方面也是能和业界的童鞋多多交流，互相看看，当下在做的事情和关注的点。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;午餐时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;不知不觉已到中午，我带着女票去了访客食堂吃饭，人好多，外面还有各式饭后甜点。赶紧给小伙伴们送上照片，证明我是一名合格的好司机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171218005222561-1157811695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;午后休息片刻，D2下半场开始了。&lt;/p&gt;

&lt;p&gt;贺师俊大佬的演讲总是那么诙谐幽默，却又引人入胜。超大字号的PPT让人欲罢不能，真是应了那句话，简单粗暴到让你怀疑，彪悍的人生是否还需要解释。而且贺老的分享总是基于一个很小的点深入挖掘，以点带面铺展开来，浅尝辄止那不是贺老的风格。&lt;/p&gt;

&lt;p&gt;还有一位讲师，我清晰地记得他在阿里的花名叫双扬，他讲的用两行代码实现前端监控系统还是挺屌的。中途还不忘打趣说，在现场的童鞋，等你们回去了可以跟别人吹牛逼说“周六我去听了D2，然后帮公司做了一个前端监控系统......”，噗嗤，现场一片哄笑。&lt;/p&gt;

&lt;p&gt;还有天猫的由校大佬，他讲的话题是天猫超市的技术选型的变迁，最后回归了web - 为什么不是Weex or RN？&lt;/p&gt;

&lt;p&gt;以下是PPT解释部分：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、WK + U4后，操作体验上接近Native&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于Web的PWA：AliExpress、饿了么......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于Web的小程序：支付宝小程序、微信小程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、端外投放场景越来越多，需要高性能且体验优异的跨端方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天猫海外、LAZADA等面向海外的业务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支付宝、什么值得买等淘系外APP（超市端外流量约10%）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、未来方向的判断，两条腿走路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iOS正在支持正在支持Service Worker，离线访问、预加载、消息推送等能力补全，和Native的核心能力差异正在被抹平&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着硬件、内核性能的提升、性能问题越来越小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Web作为统一标准，发展更快，且越来越快&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;天猫超市Mobile Web的极致体验优化，从跨平台到混合到回归web，中途在码字，没怎么注意听，表示膜拜，讲师提到阿里内部大多数移动项目都直接上weex了，个人挺看好weex的发展的，谁让fb非要搞个协议搞得大家都不敢用rn，希望weex文档越来越完善，框架越来越稳定，生态体系越来越丰富!&lt;/p&gt;

&lt;p&gt;总得来说，这次大会亮点和干货少了，KPI 驱动的轮子也消停了。作为听众，不要对期待参加某场技术会议，提升自我技术修养的效果会立竿见影。不要急于从一次分享中贴标签，试着站在分享者的角度理解当前技术解决什么场景的问题。像D2会场的各位前辈总结的那样：如果想深入到技术使用场景和细节，那就花一万小时阅读源码动手实践吧；如果想背后的设计思想和妥协，那就带着问题找作者一对一交流吧；如果你想通过会议增长见识，拓宽视野，那就带着一颗虔诚的心面基吧！好押韵~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总之，勿忘初心，独具匠心，来过，爱过，足矣。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下午5点多，本届D2正式落下帷幕，我们恋恋不舍地走出了会场，离开了阿里园区，此时的杭州已经天黑了，拍照留念一张。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171218005244968-150005882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我走出阿里园区的时候，我还在想，对于前端初级选手，参加类似于这样的D2技术交流大会，意义究竟有多大？我问过大厂的Emo，他告诉我，感觉范围很广，还要不断涉猎，明年再约！我的看法是，对于前端萌新，在家看直播就好，至于想亲身感受现场气氛，或者是面基的童鞋，明年再说吧，但是切记一定要量力而行，不要盲目追捧，否则既浪费了你的时间，也浪费了你的来回机票钱。这样的结果就是，整场大会听的持续懵逼，东西没学到，反而因为看到了太多高深的东西，感觉到自己与大佬们差距悬殊，导致自己迷茫不知所措，打击了自己的自信心就不好了。&lt;/p&gt;

&lt;p&gt;当然，我以一个亲历者的身份，设身处地地来说说这次大会在现场给我的感受，第一个，就是人多，氛围很浓，有很多童鞋也是从外地赶过来的，不止我和我女票。第二个，就是干货满满，但是感觉自己可以在工作中用上的东西不太多，与自己想要研究的东西差距甚远，也可能是自己技术觉悟不够。不过整体下来，收获还是有的。&lt;/p&gt;

&lt;p&gt;最后，感谢每一届辛苦组织 D2 的童鞋，帮助更多同行受益。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;杭州行Day2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们在杭州总共呆两天（周六和周日），周六看了一天的演讲，周日自然要陪我女票逛了逛杭州这个有故事的城市（毕竟女票第一次来杭）。&lt;/p&gt;

&lt;p&gt;湖滨路上的“外婆家”，人真的好多，午餐人均55元，推荐大家来尝尝。&lt;/p&gt;

&lt;p&gt;酒足饭饱，就去逛了逛西湖。俗话说，上有天堂，下有苏杭。西湖十景就不用我说了吧，什么苏堤春晓、曲苑风荷、平湖秋月、断桥残雪、柳浪闻莺、花港观鱼、雷峰夕照、双峰插云、南屏晚钟、三潭印月。就这些景点名字，我张嘴就来，好比报菜名，聊胜于无嘛。&lt;/p&gt;

&lt;p&gt;都说杭州是个有文化底蕴的城市，除了西湖，你不可不逛的景点还有南宋御街——清河坊——吴山广场——杭州博物馆等等，我就不摊开来讲了，毕竟篇幅有限。如果有时间，我可以单独整理出一段来，专门讲讲杭州行Day2关于我们的故事。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;由于本次以D2之名的杭州行，经费有限（几乎耗光了我一个月的工资~）。关于返程，我们打算坐火车回去，从杭州到太原的K1806列车，硬座198/位，耗时将近24个小时（请容我哭泣一会儿~）。如果有时光列车，请带我们快点回太原吧，离开才两天，我女票已经开始想念家乡的刀削面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171218005313764-745805564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当你们看到这篇文章的时候，应该是在周一上班路上。而此刻，我和我女票应该已经坐上了从杭州返回太原的火车（硬座），奔波劳碌了两天，估计此时我们已经互相靠着肩膀，依偎着睡着了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;祝你们工作顺利无BUG，祝我们晚安好梦不颠簸。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如有留言，我可能会晚些时候回复，敬请见谅。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 17:01:00 +0000</pubDate>
<dc:creator>闰土少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8054061.html</dc:identifier>
</item>
<item>
<title>C/C++进制转换超详细 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/8054172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/8054172.html</guid>
<description>&lt;h2 id=&quot;转10&quot;&gt;16转10&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;用竖式计算：&lt;br/&gt;16进制数的第0位的权值为16的0次方，第1位的权值为16的1次方，第2位的权值为16的2次方&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;第0位： 5 * 16^0 = 5
第1位： F * 16^1 = 240
第2位： A * 16^2= 2560
第3位： 2 * 16^3 = 8192&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;
int main() {
    string s;
    while(cin&amp;gt;&amp;gt;s){
        int length=s.length();
        long long sum=0;
        for(int x=0;x&amp;lt;length;x++){
            if(s[x]&amp;gt;='0'&amp;amp;&amp;amp;s[x]&amp;lt;='9'){
                sum=(s[x]-'0')+16*sum;
            }else{
                sum=(s[x]-'A'+10)+16*sum;
            }
        }
        cout&amp;lt;&amp;lt;sum;
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转2&quot;&gt;16转2&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;由于在二进制的表示方法中，每四位所表示的数的最大值对应16进制的15，即16进制每一位上最大值，所以，我们可以得出简便的转换方法，将16进制上每一位分别对应二进制上四位进行转换&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;
int main() {
    string s;
    while(cin&amp;gt;&amp;gt;s){
        int length=s.length();
        long long sum=0;
        int answer[40];
        int cot=0;
        for(int x=0;x&amp;lt;length;x++){
                int y=2;
            if(s[x]&amp;gt;='0'&amp;amp;&amp;amp;s[x]&amp;lt;='9'){
               y=(s[x]-'0');
            }else{
               y=(s[x]-'A'+10);
            }
            do{
                answer[cot++]=y%2;
                 y/=2;
            }while(y!=0);
        }
       for(int i=0;i&amp;lt;cot;i++){
            cout&amp;lt;&amp;lt;answer[cot-1-i];
       }

    }
    return 0;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转16进制&quot;&gt;2转16进制&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;16进制就有16个数，0~15，用二进制表示15的方法就是1111，从而可以推断出，16进制用2进制可以表现成0000~1111，顾名思义，也就是每四个为一位&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
0 0 1 1| 1 1 0 1
左半边=2+1=3 右半边=8+4+1=13=D&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int main() {
    string s;
    while(cin&amp;gt;&amp;gt;s){
        int length=s.length();
        string s2;
        int pro=1,sum=0,cot=0;
        for(int x=length-1;x&amp;gt;=0;x--){
             sum+=(s[x]-'0')*pro;
             pro=pro*2;
            if(x%4==0){
               if(sum&amp;gt;=10){
                  s2+=sum-10+'A';
               }else{
                  s2+=sum+'0';
               }
                pro=1;
                sum=0;
             }
        }
       reverse(s2.begin(),s2.end());
       cout&amp;lt;&amp;lt;s2;

    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进制转16进制&quot;&gt;10进制转16进制&lt;/h2&gt;
&lt;p&gt;-代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int main() {
    long long s;
    while(cin&amp;gt;&amp;gt;s){
        char ans[20]={0};
        int cot=0;
       do{
        if(s%16&amp;gt;=10){
            ans[cot++]=s%16-10+'A';
        }else{
            ans[cot++]=s%16+'0';
        }
        s/=16;
       }while(s);

        for(int i=0;i&amp;lt;cot;i++){
            cout&amp;lt;&amp;lt;ans[cot-1-i];
        }
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;十六进制转八进制&quot;&gt;十六进制转八进制&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一开始想的是把16进制先转化为10进制，因为从10进制转化为8进制很容易。但是题目中输入的16进制位数规模大，不超过100000位，肯定不能化为10进制数。解法是先把16进制化为四个2进制数，然后三个二进制数一组再化为8进制。 注意 39（16进制）--〉0011 1001 （2进制） --〉111 001（8进制），是从二进制的低位开始三个一组来计算。&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 17 Dec 2017 16:50:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/8054172.html</dc:identifier>
</item>
<item>
<title>使用TensorFlow实现DNN - Wanna_Go</title>
<link>http://www.cnblogs.com/wxshi/p/8053973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxshi/p/8053973.html</guid>
<description>&lt;p&gt;这一节使用TF实现一个多层神经网络模型来对&lt;code&gt;MNIST&lt;/code&gt;数据集进行分类，这里我们设计一个含有两个隐藏层的神经网络，在输出部分使用softmax对结果进行预测。&lt;/p&gt;
&lt;h3 id=&quot;使用高级api实现多层神经网络&quot;&gt;使用高级API实现多层神经网络&lt;/h3&gt;
&lt;p&gt;这里我们使用&lt;code&gt;tensorflow.contrib&lt;/code&gt;包，这是一个高度封装的包，里面包含了许多类似&lt;code&gt;seq2seq、keras&lt;/code&gt;一些实用的方法。&lt;br/&gt;先引入数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from tensorflow.examples.tutorials.mnist import input_data
mnist = input_data.read_data_sets(&quot;./&quot;) #自动下载数据到这个目录
X_train = mnist.train.images
X_test = mnist.test.images
y_train = mnist.train.labels.astype(&quot;int&quot;)
y_test = mnist.test.labels.astype(&quot;int&quot;)
&amp;gt;&amp;gt;X_train
array([[ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       ..., 
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.]], dtype=float32)
&amp;gt;&amp;gt;len(X_train)
55000
&amp;gt;&amp;gt;len(X_train[0])
784
&amp;gt;&amp;gt;X_train[0]
array([ 0.,  0.,  0., ...,  0.,  0.,  0.], dtype=float32)
&amp;gt;&amp;gt;y_test
array([7, 2, 1, ..., 4, 5, 6])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型的主要代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;features_cols = tf.contrib.learn.infer_real_valued_columns_from_input(X_train)
dnn_clf = tf.contrib.learn.DNNClassifier(hidden_units=[300,100], n_classes=10, feature_columns=features_cols)
dnn_clf.fit(X_train, y_train, batch_size=50, steps=10000)
from sklearn.metrics import accuracy_score
y_pred = dnn_clf.predict(X_test)
print(accuracy_score(y_test, list(y_pred)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;infer_real_valued_columns_from_input&lt;/code&gt;这个方法根据名字可以看出，它是根据输入的数据来推算出数据的类型，该例子中&lt;code&gt;features_cols&lt;/code&gt;的值为&lt;br/&gt;&lt;code&gt;[_RealValuedColumn(column_name='', dimension=784, default_value=None, dtype=tf.float32, normalizer=None)]&lt;/code&gt;，短短几行代码就实现了一个多层神经网络模型。并且可能会发现上面这些与&lt;a href=&quot;http://www.cnblogs.com/wxshi/p/7956026.html&quot;&gt;之前介绍的&lt;/a&gt;有些不同，不需要对变量进行初始化，不需要创建&lt;code&gt;session&lt;/code&gt;，使用起来十分的简单。&lt;/p&gt;
&lt;h3 id=&quot;使用tf实现多层神经网络&quot;&gt;使用TF实现多层神经网络&lt;/h3&gt;
&lt;p&gt;高度封装的API调用起来固然很爽，但是自己不了解内部的原理使用起来就不是那么的踏实，下面就使用TF实现同样的模型，代码主要分为两部分，构建TF计算流图和执行计算图。希望读者能够对比上面的代码来看接下来的部分。&lt;/p&gt;
&lt;h4 id=&quot;构建tf计算流图&quot;&gt;构建TF计算流图&lt;/h4&gt;
&lt;p&gt;首先我们需要根据输入的数据来设定输入的参数，使用的数据集MNIST为28*28的矩阵，整个神经网络包含两个隐藏层&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;n_inputs = 28 * 28
n_hidden1 = 300
n_hidden2 = 100
n_output = 10
X = tf.placeholder(tf.float32,shape=(None,n_inputs),name='X')
y = tf.placeholder(tf.int64,shape=(None),name='y')#注意数据类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面使用占位符的方法来声明模型的输入X和y，需要注意的是占位符的&lt;code&gt;数据类型&lt;/code&gt;，在执行阶段，占位符会被输入的数据所替代。接下来我们需要创建模型的两个隐藏层和输出层，两个隐藏使用&lt;code&gt;Relu&lt;/code&gt;作为激活函数，输出层使用softmax。每一层需要指定节点的个数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def neuron_layer(X,n_neurons,name,activation=None):
    with tf.name_scope(name):
        n_inputs = int(X.get_shape()[1]) #特征个数
        stddev = 2 / np.sqrt(n_inputs)
        init = tf.truncated_normal((n_inputs,n_neurons),stddev=stddev)
        W = tf.Variable(init,name='weight')
        b = tf.Variable(tf.zeros([n_neurons]),name='baise')
        z = tf.matmul(X,W) + b
        if activation == &quot;relu&quot;:
            return tf.nn.relu(z)
        else:
            return z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我将逐行的对上面代码进行解释：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li&gt;1.为了方便在TensorBoard上面查看，每一层的神经网络都创建一个&lt;code&gt;name_scope&lt;/code&gt;。这一步是可选操作，如果不需要在TensorBoard查看那就可以忽略掉。&lt;/li&gt;
&lt;li&gt;2.根据输入的数据的形状来获取数据的特征个数(第二个维度)&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;3.接下来的代码是创建权重矩阵&lt;code&gt;W&lt;/code&gt;和偏置&lt;code&gt;b&lt;/code&gt;，权重&lt;code&gt;W&lt;/code&gt;不能使用0进行初始化，这样会导致所有的神经元的输出为0，出现对称失效问题，这里使用truncated normal分布(Gaussian)来初始化权重，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tf.truncated_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)&lt;/code&gt;
&lt;/pre&gt;
通过指定均值和标准方差来生成正态分布，抛弃那些大于2倍stddev的值。这样将有助于加快训练速度。在初始化&lt;code&gt;b&lt;/code&gt;的时候，每一层只有一个偏置，我们全部设置为0，这样并不会出现对称失效问题。&lt;/li&gt;
&lt;li&gt;4.下面的是在每一个神经元中的操作&lt;span class=&quot;math inline&quot;&gt;\(y=X·W+b\)&lt;/span&gt;，使用向量化运算计算输入与权重的和运算&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;5.最后就是激活函数的选择了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就开始像搭建积木一样创建我们的神经网络了，每一层的输入为上一层的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with tf.name_scope(&quot;dnn&quot;):
    hidden1 = neuron_layer(X,n_hidden1,&quot;hidden1&quot;,activation=&quot;relu&quot;)
    hidden2 = neuron_layer(hidden1,n_hidden2,&quot;hidden2&quot;,activation=&quot;relu&quot;)
    logits = neuron_layer(hidden2,n_output,&quot;output&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这一段代码的输出层并没有经过&lt;code&gt;softmax&lt;/code&gt;激活函数，这是考虑到后续优化求解原因，在后续工作中单独做处理。上面这段代码就是一个神经网络全连接的简化版本，当然TF的contrib模块也提供了全连接的函数&lt;code&gt;fully_connected&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from tensorflow.contrib.layers import fully_connected
with tf.name_scope(&quot;dnn&quot;):
    hidden1 = fully_connected(X, n_hidden1, scope=&quot;hidden1&quot;)#激活函数默认为relu
    hidden2 = fully_connected(hidden1, n_hidden2, scope=&quot;hidden2&quot;)
    logits = fully_connected(hidden2, n_outputs, scope=&quot;outputs&quot;,activation_fn=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，模型已经有了。接下来套路就是设计损失函数，优化损失函数求解参数。输出层softmax输出的为在各个类别上面的得分，损失函数使用交叉熵&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(-\sum{y'}log(y')\)&lt;/span&gt;。在这里我们使用TF提供的&lt;code&gt;tf.nn.sparse_softmax_cross_entropy_with_logits(_sentinel=None, labels=None, logits=None, name=None)&lt;/code&gt;来计算损失函数，该方法&lt;strong&gt;先计算softmax再计算cross entropy&lt;/strong&gt;，主要有两个参数需要考虑&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.labels:输入的为标签的index，例如本例子有10个类别，取值范围为0-9&lt;/li&gt;
&lt;li&gt;2.logits:为输入到softmax激活函数之前的模型的输出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后再使用&lt;code&gt;reduce_mean()&lt;/code&gt;计算loss。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with tf.name_scope(&quot;loss&quot;):
    xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y,logits=logits)#labels允许的数据类型有int32, int64
    loss = tf.reduce_mean(xentropy,name=&quot;loss&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;note：&lt;/strong&gt;TF还提供了&lt;code&gt;softmax_cross_entropy_with_logits()&lt;/code&gt;，和上面方法的区别该方法输入的label为一个one-hot向量。&lt;br/&gt;到这里我们的&lt;strong&gt;模型&lt;/strong&gt;和&lt;strong&gt;损失函数&lt;/strong&gt;已经都有了，就到了优化阶段，本文使用梯度下降方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;learning_rate = 0.01
with tf.name_scope(&quot;train&quot;):
    optimizer = tf.train.GradientDescentOptimizer(learning_rate)
    training_op = optimizer.minimize(loss)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型有了结果，就需要对得到的模型进行衡量。简单起见，这里使用&lt;code&gt;accuracy&lt;/code&gt;作为评估指标，判断模型输出结果的最高值的index是否和label的index相等&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with tf.name_scope(&quot;eval&quot;):
    correct = tf.nn.in_top_k(logits,y,1) #取值最高的一位
    accuracy = tf.reduce_mean(tf.cast(correct,tf.float32)) #结果boolean转为0，1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型构建阶段最后一个工作就是初始化里面的变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;init = tf.global_variables_initializer()
saver = tf.train.Saver()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;执行计算流图&quot;&gt;执行计算流图&lt;/h4&gt;
&lt;p&gt;这一部分相对前面工作要简单很多，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;n_epoch = 400 
batch_size = 50
with tf.Session() as sess:
    init.run()
    for epoch in range(n_epoch):
        for iteration in range(mnist.train.num_examples // batch_size):#需要迭代的轮数
            X_batch,y_batch = mnist.train.next_batch(batch_size)
            sess.run(training_op,feed_dict={X:X_batch,y:y_batch})
        acc_train = accuracy.eval(feed_dict={X:X_batch,y:y_batch})
        acc_test = accuracy.eval(feed_dict={X:mnist.test.images,mnist.test.labels})
        print (epoch,&quot;Train accuracy&quot;, acc_train,&quot;Test accuracy&quot;,acc_test)
    saver.save(sess, &quot;./my_model.pk&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码使用的是mini-batch方法训练神经网络，最后将模型持久化到本地。后续的使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with tf.Session() as sess:
    saver.restore(sess, &quot;./my_model.pk&quot;) #加载
    X_new_scaled = mnist.test.images[:20]
    Z = logits.eval(feed_dict={X: X_new_scaled}) #模型
    y_pred = np.argmax(Z, axis=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文介绍了TF在实际数据集MNIST上面的使用，为input和target创建占位符，创建神经网络的layer，得到一个DNN，并为整个模型设置损失函数，对损失函数进行优化求解，最后对模型进行评估。&lt;br/&gt;又是一个凌晨12点，晚安~&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 16:22:00 +0000</pubDate>
<dc:creator>Wanna_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxshi/p/8053973.html</dc:identifier>
</item>
<item>
<title>面向对象的设计原则 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8050983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8050983.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　面向对象的设计原则，可以说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的， 它们本身已经融入了设计模式之中，给面向对象编程指明了方向。适合javascript开发的设计原则包括是单一职责原则、最少知识原则和开放封闭原则。本文将详细介绍面向对象的设计原则&lt;/p&gt;

&lt;h3&gt;单一职责原则&lt;/h3&gt;
&lt;p&gt;　　就一个类而言，应该仅有一个引起它变化的原因。在javascript中，需要用到类的场景并不太多，单一职责原则更多地是被运用在对象或者方法级别上&lt;/p&gt;
&lt;p&gt;　　单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。因此，SRP原则体现为：一个对象（方法）只做一件事情&lt;/p&gt;
&lt;p&gt;　　SRP原则在很多设计模式中都有着广泛的运用，例如代理模式、迭代器模式、单例模式和装饰者模式&lt;/p&gt;
&lt;p&gt;【代理模式】&lt;/p&gt;
&lt;p&gt;　　通过增加虚拟代理的方式，把预加载图片的职责放到代理对象中，而本体仅仅负责往页面中添加img标签，这也是它最原始的职责&lt;/p&gt;
&lt;p&gt;　　myImage负责往页面中添加img标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; myImage =&lt;span&gt; (function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imgNode = document.createElement( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    document.body.appendChild( imgNode );
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        setSrc: function( src ){

            imgNode.src &lt;/span&gt;=&lt;span&gt; src;
        }
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　proxyImage负责预加载图片，并在预加载完成之后把请求交给本体 myImage：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; proxyImage =&lt;span&gt; (function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Image;
    img.onload &lt;/span&gt;=&lt;span&gt; function(){
        myImage.setSrc( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.src );
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        setSrc: function( src ){
            myImage.setSrc( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file://loading.gif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
            img.src &lt;/span&gt;=&lt;span&gt; src;
        }
    }
})();
proxyImage.setSrc( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://test.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　把添加img标签的功能和预加载图片的职责分开放到两个对象中，这两个对象各自都只有一个被修改的动机。在它们各自发生改变的时候，也不会影响另外的对象&lt;/p&gt;
&lt;p&gt;【迭代器模式】&lt;/p&gt;
&lt;p&gt;　　有这样一段代码，先遍历一个集合，然后往页面中添加一些div，这些div的innerHTML分别对应集合里的元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; appendDiv =&lt;span&gt; function( data ){
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, l = data.length; i &amp;lt; l; i++&lt;span&gt; ){ 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.createElement( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ); 
    div.innerHTML &lt;/span&gt;=&lt;span&gt; data[ i ]; 
    document.body.appendChild( div );
  }
};
appendDiv( [ &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt; ] );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这其实是一段很常见的代码，经常用于ajax请求之后，在回调函数中遍历ajax请求返回的数据，然后在页面中渲染节点。appendDiv函数本来只是负责渲染数据，但是在这里它还承担了遍历聚合对象data的职责。如果有一天cgi返回的data数据格式从array变成了object，那遍历data的代码就会出现问题，必须改成for in的方式，这时候必须去修改appendDiv里的代码，否则因为遍历方式的改变，导致不能顺利往页面中添加div节点&lt;/p&gt;
&lt;p&gt;　　有必要把遍历data的职责提取出来，这正是迭代器模式的意义，迭代器模式提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示。&lt;/p&gt;
&lt;p&gt;　　当把迭代聚合对象的职责单独封装在each函数中后，即使以后还要增加新的迭代方式，只需要修改each函数即可，appendDiv函数不会受到牵连，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; each =&lt;span&gt; function( obj, callback ) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; value,
    i &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    length &lt;/span&gt;=&lt;span&gt; obj.length,
    isArray &lt;/span&gt;= isArraylike( obj ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; isArraylike 函数未实现&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ( isArray ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代类数组&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; length; i++&lt;span&gt; ) {
            callback.call( obj[ i ], i, obj[ i ] );
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i &lt;span&gt;in&lt;/span&gt; obj ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代object 对象&lt;/span&gt;
            value =&lt;span&gt; callback.call( obj[ i ], i, obj[ i ] );
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; appendDiv =&lt;span&gt; function( data ){
    each( data, function( i, n ){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.createElement( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        div.innerHTML &lt;/span&gt;=&lt;span&gt; n;
        document.body.appendChild( div );
    });
};

appendDiv( [ &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt; ] );
appendDiv({a:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,b:&lt;span&gt;2&lt;/span&gt;,c:&lt;span&gt;3&lt;/span&gt;,d:&lt;span&gt;4&lt;/span&gt;} );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【单例模式】&lt;/p&gt;
&lt;p&gt;　　下面是一段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; createLoginLayer =&lt;span&gt; (function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; div;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;div ){
            div &lt;/span&gt;= document.createElement( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
            div.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是登录浮窗&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            div.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            document.body.appendChild( div );
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; div;
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一登录浮窗的功能，下面的代码显然是更好的做法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getSingle = function( fn ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取单例&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; result;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; result || ( result = fn .apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments ) );
    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; createLoginLayer = function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建登录浮窗&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; div = document.createElement( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    div.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是登录浮窗&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    document.body.appendChild( div );
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; div;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; createSingleLoginLayer =&lt;span&gt; getSingle( createLoginLayer );
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loginLayer1 =&lt;span&gt; createSingleLoginLayer();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loginLayer2 =&lt;span&gt; createSingleLoginLayer();
alert ( loginLayer1 &lt;/span&gt;=== loginLayer2 ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【装饰者模式】&lt;/p&gt;
&lt;p&gt;　　使用装饰者模式时，通常让类或者对象一开始只具有一些基础的职责，更多的职责在代码运行时被动态装饰到对象上面。装饰者模式可以为对象动态增加职责，从另一个角度来看， 这也是分离职责的一种方式&lt;/p&gt;
&lt;p&gt;　　下面把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;button tag=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;点击打开登录浮层&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    Function.prototype.after &lt;/span&gt;=&lt;span&gt; function( afterfn ){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; __self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = __self.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
            afterfn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
        }
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; showLogin =&lt;span&gt; function(){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;打开登录浮层&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log =&lt;span&gt; function(){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上报标签为: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.getAttribute( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) );

    };
    document.getElementById( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ).onclick =&lt;span&gt; showLogin.after( log );
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开登录浮层之后上报数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　SRP原则是所有原则中最简单也是最难正确运用的原则之一。要明确的是，并不是所有的职责都应该一一分离。一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在ajax请求的时候，创建xhr对象和发送xhr请求几乎总是在一起的，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟&lt;/p&gt;
&lt;p&gt;　　在人的常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确地分离职责不是一件容易的事情。在实际开发中，因为种种原因违反SRP的情况并不少见。比如jQuery的attr等方法，就是明显违反SRP原则的做法。jQuery的attr是个非常庞大的方法，既负责赋值，又负责取值，这对于jQuery的维护者来说，会带来一些困难，但对于jQuery的用户来说，却简化了用户的使用。在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境&lt;/p&gt;
&lt;p&gt;　　SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。但SRP原则也有一些缺点，最明显的是会增加编写代码的复杂度。当按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度&lt;/p&gt;

&lt;h3&gt;最少知识原则&lt;/h3&gt;
&lt;p&gt;　　最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等&lt;/p&gt;
&lt;p&gt;　　某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式：将军可以通知上校让他叫来少校，然后让少校找来上尉，并让上尉通知一个军士，最后军士唤来一个士兵，然后命令士兵挖掘一些散兵坑。这种方式十分荒谬，不是吗？不过，还是先来看一下这个过程的等价代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
gerneral.getColonel(c).getMajor(m).getCaptain(c).getSergeant(s).getPrivate(p).digFoxhole();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　让代码通过这么长的消息链才能完成一个任务，这就像让将军通过那么多繁琐的步骤才能命令别人挖掘散兵坑一样荒谬！而且，这条链中任何一个对象的改动都会影响整条链的结果。最有可能的是，将军自己根本就不会考虑挖散兵坑这样的细节信息。但是如果将军真的考虑了这个问题的话，他一定会通知某个军官：“我不关心这个工作如何完成，但是你得命令人去挖散兵坑。”&lt;/p&gt;
&lt;p&gt;　　单一职责原则指导我们把对象划分成较小的粒度，这可以提高对象的可复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。&lt;/p&gt;
&lt;p&gt;　　最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求&lt;/p&gt;
&lt;p&gt;　　最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式&lt;/p&gt;
&lt;p&gt;【中介者模式】&lt;/p&gt;
&lt;p&gt;　　在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能的事情。博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就赔给博彩公司。中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可&lt;/p&gt;
&lt;p&gt;【外观模式】&lt;/p&gt;
&lt;p&gt;　　外观模式主要是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使子系统更加容易使用&lt;/p&gt;
&lt;p&gt;　　外观模式的作用是对客户屏蔽一组子系统的复杂性。外观模式对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。大多数客户都可以通过请求外观接口来达到访问子系统的目的。但在一段使用了外观模式的程序中，请求外观并不是强制的。如果外观不能满足客户的个性化需求，那么客户也可以选择越过外观来直接访问子系统&lt;/p&gt;
&lt;p&gt;　　拿全自动洗衣机的一键洗衣按钮举例，这个一键洗衣按钮就是一个外观。如果是老式洗衣机，客户要手动选择浸泡、洗衣、漂洗、脱水这4个步骤。如果这种洗衣机被淘汰了，新式洗衣机的漂洗方式发生了改变，那还得学习新的漂洗方式。而全自动洗衣机的好处很明显，不管洗衣机内部如何进化，客户要操作的，始终只是一个一键洗衣的按钮。这个按钮就是为一组子系统所创建的外观。但如果一键洗衣程序设定的默认漂洗时间是20分钟，而客户希望这个漂洗时间是30分钟，那么客户自然可以选择越过一键洗衣程序，自己手动来控制这些“子系统”运转。外观模式容易跟普通的封装实现混淆。这两者都封装了一些事物，但外观模式的关键是定义一个高层接口去封装一组“子系统”。子系统在C++或者Java中指的是一组类的集合，这些类相互协作可以组成系统中一个相对独立的部分。在javascript中通常不会过多地考虑“类”，如果将外观模式映射到javascript中，这个子系统至少应该指的是一组函数的集合&lt;/p&gt;
&lt;p&gt;　　最简单的外观模式应该是类似下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; A =&lt;span&gt; function(){
  a1();
  a2();
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; B =&lt;span&gt; function(){
  b1();
  b2();
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; facade =&lt;span&gt;function(){
  A();
  B();
}
facade();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　许多javascript设计模式的图书或者文章喜欢把jQuery的$.ajax函数当作外观模式的实现，这是不合适的。如果$.ajax函数属于外观模式，那几乎所有的函数都可以被称为“外观模式”。问题是根本没有办法越过$.ajax“外观”去直接使用该函数中的某一段语句&lt;/p&gt;
&lt;p&gt;　　现在再来看看外观模式和最少知识原则之间的关系。外观模式的作用主要有两点&lt;/p&gt;
&lt;p&gt;　　1、为一组子系统提供一个简单便利的访问入口&lt;/p&gt;
&lt;p&gt;　　2、隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。从第二点来，外观模式是符合最少知识原则的&lt;/p&gt;
&lt;p&gt;　　封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口API供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。同时，封装也用来限制变量的作用域。在javascript中对变量作用域的规定是：&lt;/p&gt;
&lt;p&gt;　　1、变量在全局声明，或者在代码的任何位置隐式申明（不用var），则该变量在全局可见；&lt;/p&gt;
&lt;p&gt;　　2、变量在函数内显式申明（使用var），则在函数内可见。把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现&lt;/p&gt;
&lt;p&gt;　　假设要编写一个具有缓存效果的计算乘积的函数function mult(){}，需要一个对象var cache = {}来保存已经计算过的结果。cache对象显然只对mult有用，把cache对象放在mult形成的闭包中，显然比把它放在全局作用域更加合适，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mult =&lt;span&gt; (function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args = Array.prototype.join.call( arguments, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( cache[ args ] ){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[ args ];
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, l = arguments.length; i &amp;lt; l; i++&lt;span&gt; ){

            a &lt;/span&gt;= a *&lt;span&gt; arguments[i];
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cache[ args ] =&lt;span&gt; a;
    }
})();
mult( &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，要根据具体的环境来定&lt;/p&gt;

&lt;h3&gt;开放封闭原则&lt;/h3&gt;
&lt;p&gt;　　在面向对象的程序设计中，开放——封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放——封闭原则的。开放——封闭原则的定义如下：软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改&lt;/p&gt;
&lt;p&gt;　　假设我们是一个大型Web项目的维护人员，在接手这个项目时，发现它已经拥有10万行以上的javascript代码和数百个JS文件。不久后接到了一个新的需求，即在window.onload函数中打印出页面中的所有节点数量。打开文本编辑器，搜索出window.onload函数在文件中的位置，在函数内部添加以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原有代码略&lt;/span&gt;
  console.log(document.getElementsByTagName(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).length);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在项目需求变迁的过程中，经常会找到相关代码，然后改写它们。这似乎是理所当然的事情，不改动代码怎么满足新的需求呢？想要扩展一个模块，最常用的方式当然是修改它的源代码。如果一个模块不允许修改，那么它的行为常常是固定的。然而，改动代码是一种危险的行为，也许都遇到过bug越改越多的场景。刚刚改好了一个bug，但是又在不知不觉中引发了其他的bug&lt;/p&gt;
&lt;p&gt;　　如果目前的window.onload函数是一个拥有500行代码的巨型函数，里面密布着各种变量和交叉的业务逻辑，而需求又不仅仅是打印一个log这么简单。那么“改好一个bug，引发其他bug”这样的事情就很可能会发生。永远不知道刚刚的改动会有什么副作用，很可能会引发一系列的连锁反应&lt;/p&gt;
&lt;p&gt;　　那么，有没有办法在不修改代码的情况下，就能满足新需求呢？通过增加代码，而不是修改代码的方式，来给window.onload函数添加新的功能，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Function.prototype.after =&lt;span&gt; function( afterfn ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; __self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = __self.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
        afterfn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }
};
window.onload &lt;/span&gt;= ( window.onload ||&lt;span&gt; function(){} ).after(function(){
    console.log( document.getElementsByTagName( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ).length );
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过动态装饰函数的方式，完全不用理会从前window.onload函数的内部实现，无论它的实现优雅或是丑陋。就算作为维护者，拿到的是一份混淆压缩过的代码也没有关系。只要它从前是个稳定运行的函数，那么以后也不会因为我们的新增需求而产生错误。新增的代码和原有的代码可以井水不犯河水&lt;/p&gt;
&lt;p&gt;　　现在引出开放——封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码&lt;/p&gt;
&lt;p&gt;　　过多的条件分支语句是造成程序违反开放——封闭原则的一个常见原因。每当需要增加一个新的if语句时，都要被迫改动原函数。把if换成switch-case是没有用的，这是一种换汤不换药的做法。实际上，每当看到一大片的if或者swtich-case语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们&lt;/p&gt;
&lt;p&gt;　　利用对象的多态性来让程序遵守开放——封闭原则，是一个常用的技巧。下面先提供一段不符合开放——封闭原则的代码。每当增加一种新的动物时，都需要改动makeSound函数的内部实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; makeSound =&lt;span&gt; function( animal ){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( animal instanceof Duck ){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;嘎嘎嘎&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( animal instanceof Chicken ){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;咯咯咯&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Duck =&lt;span&gt; function(){};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Chicken =&lt;span&gt; function(){};
makeSound( &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck() ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：嘎嘎嘎&lt;/span&gt;
makeSound( &lt;span&gt;new&lt;/span&gt; Chicken() ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：咯咯咯&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　动物世界里增加一只狗之后，makeSound函数必须改成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; makeSound =&lt;span&gt; function( animal ){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( animal instanceof Duck ){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;嘎嘎嘎&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( animal instanceof Chicken ){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;咯咯咯&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( animal instanceof Dog ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加跟狗叫声相关的代码&lt;/span&gt;
        console.log(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;汪汪汪&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Dog =&lt;span&gt; function(){};
makeSound( &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Dog() ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加一只狗&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　利用多态的思想，把程序中不变的部分隔离出来（动物都会叫），然后把可变的部分封装起来（不同类型的动物发出不同的叫声），这样一来程序就具有了可扩展性。想让一只狗发出叫声时，只需增加一段代码即可，而不用去改动原有的makeSound函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; makeSound =&lt;span&gt; function( animal ){
    animal.sound();
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Duck =&lt;span&gt; function(){};
Duck.prototype.sound &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;嘎嘎嘎&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Chicken =&lt;span&gt; function(){};
Chicken.prototype.sound &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;咯咯咯&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};
makeSound( &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck() ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 嘎嘎嘎&lt;/span&gt;
makeSound( &lt;span&gt;new&lt;/span&gt; Chicken() ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 咯咯咯&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;******** 增加动物狗，不用改动原有的makeSound 函数 ***************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Dog =&lt;span&gt; function(){};
Dog.prototype.sound &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;汪汪汪&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};
makeSound( &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Dog() ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 汪汪汪&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　遵守开放——封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的&lt;/p&gt;
&lt;p&gt;　　由于每种动物的叫声都不同，所以动物具体怎么叫是可变的，于是把动物具体怎么叫的逻辑从makeSound函数中分离出来。而动物都会叫这是不变的，makeSound函数里的实现逻辑只跟动物都会叫有关，这样一来，makeSound就成了一个稳定和封闭的函数。除了利用对象的多态性之外，还有其他方式可以帮助编写遵守开放——封闭原则的代码&lt;/p&gt;
&lt;p&gt;【放置挂钩】&lt;/p&gt;
&lt;p&gt;　　放置挂钩（hook）也是分离变化的一种方式。在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。&lt;/p&gt;
&lt;p&gt;　　由于子类的数量是无限制的，总会有一些“个性化”的子类迫使不得不去改变已经封装好的算法骨架。于是可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体子类决定。这样一来，程序就拥有了变化的可能&lt;/p&gt;
&lt;p&gt;【使用回调函数】&lt;/p&gt;
&lt;p&gt;　　在javascript中，函数可以作为参数传递给另外一个函数，这是高阶函数的意义之一。在这种情况下，通常会把这个函数称为回调函数。在javascript版本的设计模式中，策略模式和命令模式等都可以用回调函数轻松实现&lt;/p&gt;
&lt;p&gt;　　回调函数是一种特殊的挂钩。可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果&lt;/p&gt;
&lt;p&gt;　　比如，通过ajax异步请求用户信息之后要做一些事情，请求用户信息的过程是不变的，而获取到用户信息之后要做什么事情，则是可能变化的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getUserInfo =&lt;span&gt; function( callback ){
    $.ajax( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http:// xxx.com/getUserInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, callback );
};
getUserInfo( function( data ){
    console.log( data.userName );
});
getUserInfo( function( data ){
    console.log( data.userId );
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外一个例子是关于Array.prototype.map的。在不支持Array.prototype.map的浏览器中，可以简单地模拟实现一个map函数&lt;/p&gt;
&lt;p&gt;　　arrayMap函数的作用是把一个数组“映射”为另外一个数组。映射的步骤是不变的，而映射的规则是可变的，于是把这部分规则放在回调函数中，传入arrayMap函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arrayMap =&lt;span&gt; function( ary, callback ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    length &lt;/span&gt;=&lt;span&gt; ary.length,
    value,
    ret &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; length; i++&lt;span&gt; ){
        value &lt;/span&gt;=&lt;span&gt; callback( i, ary[ i ] );
        ret.push( value );
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = arrayMap( [ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ], function( i, n ){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = arrayMap( [ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ], function( i, n ){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
});

console.log( a ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：[ 2, 4, 6 ]&lt;/span&gt;
console.log( b ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：[ 3, 6, 9 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有一种说法是，设计模式就是给做的好的设计取个名字。几乎所有的设计模式都是遵守开放——封闭原则的。不管是具体的各种设计模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等，都是为了让程序遵守开放——封闭原则而出现的。可以这样说，开放——封闭原则是编写一个好程序的目标，其他设计原则都是达到这个目标的过程&lt;/p&gt;
&lt;p&gt;【发布——订阅模式】&lt;/p&gt;
&lt;p&gt;　　发布——订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者&lt;/p&gt;
&lt;p&gt;【模板方法模式】&lt;/p&gt;
&lt;p&gt;　　模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放——封闭原则的&lt;/p&gt;
&lt;p&gt;【策略模式】&lt;/p&gt;
&lt;p&gt;　　策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。增加一个新的策略类也非常方便，完全不用修改之前的代码&lt;/p&gt;
&lt;p&gt;【代理模式】&lt;/p&gt;
&lt;p&gt;　　拿预加载图片举例，现在已有一个给图片设置src的函数myImage，想为它增加图片预加载功能时，一种做法是改动myImage函数内部的代码，更好的做法是提供一个代理函数proxyMyImage，代理函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的myImage函数，myImage在这个过程中不需要任何改动。预加载图片的功能和给图片设置src的功能被隔离在两个函数里，它们可以单独改变而互不影响。myImage不知晓代理的存在，它可以继续专注于自己的职责——给图片设置src&lt;/p&gt;
&lt;p&gt;【职责链模式】&lt;/p&gt;
&lt;p&gt;　　把一个巨大的订单函数分别拆成了500元订单、200元订单以及普通订单的3个函数。这3个函数通过职责链连接在一起，客户的请求会在这条链条里面依次传递：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; order500yuan = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chain(function( orderType, pay, stock ){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体代码略&lt;/span&gt;
&lt;span&gt;});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; order200yuan = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chain(function( orderType, pay, stock ){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体代码略&lt;/span&gt;
&lt;span&gt;});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; orderNormal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chain(function( orderType, pay, stock ){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体代码略&lt;/span&gt;
&lt;span&gt;});

order500yuan.setNextSuccessor( order200yuan ).setNextSuccessor( orderNormal ); 
order500yuan.passRequest( &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt; );    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 500 元定金预购，得到 100 优惠券&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，当增加一个新类型的订单函数时，不需要改动原有的订单函数代码，只需要在链条中增加一个新的节点&lt;/p&gt;
&lt;p&gt;　　在职责链模式代码中，开放——封闭原则要求只能通过增加源代码的方式扩展程序的功能，而不允许修改源代码。那往职责链中增加一个新的100元订单函数节点时，不也必须改动设置链条的代码吗？代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(orderNormal);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　变为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(order100yuan).setNextSuccessor(orderNormal);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间和精力。而且让程序符合开放——封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。更何况，有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化&lt;/p&gt;
&lt;p&gt;　　作为程序员，可以做到的有下面两点&lt;/p&gt;
&lt;p&gt;　　1、挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化&lt;/p&gt;
&lt;p&gt;　　2、在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单&lt;/p&gt;

</description>
<pubDate>Sun, 17 Dec 2017 16:21:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8050983.html</dc:identifier>
</item>
<item>
<title>信协第一学期考核 - 20175207冷南</title>
<link>http://www.cnblogs.com/ln-0407/p/8053878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ln-0407/p/8053878.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;（普通题一题&lt;/span&gt;20&lt;span&gt;分） 共七道题 选做&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目一：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数组（&lt;/span&gt;array&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从键盘输入一个长度为&lt;/span&gt;N&lt;span&gt;（比如&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;）的整型数组，第一行输出小于零的数，第二行输出零的个数，第三行输出大于零的数，维持原数组顺序，不进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;输入描述&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：第一行键盘输入&lt;/span&gt; &lt;span&gt;n&lt;/span&gt;&lt;span&gt;，第二行输入&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出描述：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一行输出小于零的数，第二行输出零的个数，第三行输出大于零的数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;2  -5  -89  75  0  -89  0  93  48  0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-5  -89  -89&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;2  75  93  48&lt;/p&gt;
&lt;p&gt; &lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define N 15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int n,a[N],i,count=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    char c;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    scanf(&quot;%d&quot;,&amp;amp;n);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        scanf(&quot;%d&quot;,&amp;amp;a[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(a[i]&amp;lt;0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            printf(&quot;%4d&quot;,a[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    printf(&quot;\n&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(a[i]==0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            count++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    printf(&quot;%4d\n&quot;,count);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(a[i]&amp;gt;0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            printf(&quot;%4d&quot;,a[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目二：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;计算两个整数的最大公约数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按如下函数原型，采用欧几里德算法编写计算两个整数的最大公约数的函数&lt;/span&gt;Gcd()&lt;span&gt;。欧几里德算法，也称辗转相除法。其基本思想是：对正整数&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;，连续进行求余运算，直到余数为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;为止，此时非&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;的除数就是最大公约数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/* &lt;span&gt;函数功能：计算&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;的最大公约数，输入负数时返回&lt;/span&gt;&lt;span&gt;-1 */&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;int Gcd(int a, int b)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）从键盘任意输入的两整数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;主函数调用&lt;/span&gt;&lt;span&gt;Gcd()&lt;/span&gt;&lt;span&gt;函数，并输出两整数的最大公约数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;Gcd&lt;/span&gt;&lt;span&gt;函数原型为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     int Gcd(int a, int b);&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;如果输入的数不是正整数，则返回&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;否则，返回两个数的最大公约数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;&lt;span&gt;输入提示信息格式要求：&lt;/span&gt;&lt;span&gt;&quot;Input a,b:\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;输入两个整数时用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;号分隔&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     **&lt;span&gt;输出提示信息要求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;如果输入的数不是正整数，则输出&lt;/span&gt;&lt;span&gt;&quot;Input error!\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则按如下格式输出&lt;/span&gt;&quot;Gcd=%d\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;void main()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int a,b,c;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int gcd(int,int);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;printf(&quot;input two integers:&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scanf(&quot;%d%d&quot;,&amp;amp;a,&amp;amp;b);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if(a,b&amp;lt;=0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        printf(&quot;Input error!\n&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c=gcd(a,b);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;printf(&quot;Greatest commondivisor is %d\n&quot;,c);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int gcd(int x,int y)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int t;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;while(y)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t=x%y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x=y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y=t;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return x;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目三：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;计算圆的面积。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）圆的半径&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;（包括&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;）之间的正整数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）用符号常量定义&lt;/span&gt;&lt;span&gt;PI&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）当圆的面积小于&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;时输出圆的面积并对圆的面积求累加和，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;大于等于&lt;/span&gt;50&lt;span&gt;时结束循环；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）输出累加和的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）不用数组编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;要求输入提示信息为：无输入提示信息和输入数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;要求输出格式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;&quot;area=%.2f\n&quot;                &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;&quot;sum=%.2f\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void main ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int r;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  float s;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  float PI=3.14;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  float sum=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  for(r=1;r&amp;lt;11;r++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       s=PI*r*r;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  if(s&amp;lt;50)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      printf(&quot;%f&quot;,s);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      sum+=s;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      printf(&quot;%f&quot;,sum);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;break;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  return 0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目四：汉语数字&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入一个整形数，按汉语习惯输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入提示信息为：&lt;/span&gt;&lt;span&gt;请输入数字：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输&lt;/span&gt;&lt;span&gt;出&lt;/span&gt;&lt;span&gt;提示信息为：&lt;/span&gt;&lt;span&gt;汉语为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请输入数字：&lt;/span&gt;1052&lt;/p&gt;
&lt;p&gt;&lt;span&gt;汉语为：&lt;/span&gt;&lt;span&gt;一千零五十二&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;void ChangeType1(char * px, char * pn, char * pw, int len);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;int main(void)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char x[100];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char num[10][] = {'零','一','二','三','四','五','六','七','八','九'};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char wei[4][] = {'\0','十','百','千'};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char danwei[3][] = {'\0','万','亿'};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int len;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int lx;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char * pn = num, * pn2 = num2, * px = x, * pw = wei, * pw2 = wei2, * pdw = danwei&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;printf(&quot;请输入数字：&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lx=strlen(x);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for(i=0;i&amp;lt;lx;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;x[i]=x[i]-'0';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for(i=0;i&amp;lt;lx;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;d=lx-i;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(num2[x[i]]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==2||d==6||d==10)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(wei[0]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==3||d==7||d==11)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(wei[1]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==4||d==8||d==12)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(wei[2]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==5)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(danwei[0]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==9)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(danwei[1])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;span&gt;？？？？？？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目五：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;统计师的难题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一天统计师小明收到上司的一大串文字，让小明找出其中的数字，英文和其他&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内容（空格与其他字符）的个数，请你写程序帮助小明解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入可能有多组测试用例，每个用例包含一行字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个用例包括&lt;/span&gt; 3 &lt;span&gt;个整数，分别代表英文个数、 数字个数、其他内容个数，整数间以空格分隔。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;adfawef12345 *&amp;amp;&lt;/p&gt;
&lt;p&gt;AFSAF587&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7 5 3&lt;/p&gt;
&lt;p&gt;5 3 0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main(int argc, char *argv[])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt; int n=0,i;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; printf(&quot;请输入行数:&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; scanf(&quot;%d&quot;,&amp;amp;n);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; char** s;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; s=(char**)malloc(sizeof(char*)*n);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  s[i]=(char*)malloc(sizeof(char)*128);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt; for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  scanf(&quot;%s&quot;,s[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt; for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  int len=strlen(s[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  int j,alpha=0,digit=0,other=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  for(j=0;j&amp;lt;len;j++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   if(s[i][j]&amp;gt;='0' &amp;amp;&amp;amp; s[i][j]&amp;lt;='9')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    digit++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   else if((s[i][j]&amp;gt;='A' &amp;amp;&amp;amp; s[i][j]&amp;lt;='Z') || (s[i][j]&amp;gt;='a' &amp;amp;&amp;amp; s[i][j]&amp;lt;='z'))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    alpha++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    other++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  printf(&quot;%d %d %d\n&quot;,alpha,digit,other);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt; return 0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目六：人民币&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用&lt;/span&gt;100&lt;span&gt;元人民币兑换&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;span&gt;,5&lt;/span&gt;&lt;span&gt;元和&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;元的纸币&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;每一种都要有&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;共&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;张&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;请用穷举法编程计算共有几种兑换方案&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;每种方案各兑换多少张纸币&lt;/span&gt;&lt;span&gt;.     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;****&lt;span&gt;输入提示信息要求为：无&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;****&lt;span&gt;输出格式要求为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;x = %d, y = %d, z = %d\n&quot;&lt;/p&gt;
&lt;p&gt;&quot;count = %d\n&quot;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int main ()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   int x,y,z,count=0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   for(x=0;x&amp;lt;=5;x++)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       for(y=1;y&amp;lt;11;y++)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           z=50-x-y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           if(10*x+5*y+z==100);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               count++;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               printf(&quot;x=%d,y=%d,z=%d\n&quot;,x,y,z);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目七：素性检测&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从键盘任意输入一个整数&lt;/span&gt;m，若m不是素数，则对m进行质因数分解，并将m表示为质因数从小到大顺序排列的乘积形式输出，否则输出&quot;It is a prime number&quot;。例如，用户输入90时，程序输出90 = 2 * 3 * 3 * 5；用户输入17时，程序输出&quot;It is a prime number&quot;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入提示信息：&lt;/span&gt;&quot;Input m:&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入格式：&lt;/span&gt;&quot;%d&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是素数时输出&lt;/span&gt;&quot;It is a prime number\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则输出用&lt;/span&gt;&quot;%d = &quot;，&quot;%d * &quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行示例&lt;/span&gt;1：&lt;/p&gt;
&lt;p&gt;Input m:90↙&lt;/p&gt;
&lt;p&gt;90 = 2 * 3 * 3 * 5&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行示例&lt;/span&gt;2：&lt;/p&gt;
&lt;p&gt;Input m:13↙&lt;/p&gt;
&lt;p&gt;It is a prime number&lt;/p&gt;
&lt;p&gt; &lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;void main()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int a,b,i,f[10]={0},t=0,flag=1;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    scanf(&quot;%d&quot;,&amp;amp;a);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    b=a;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=2;i&amp;lt;a;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(b%i==0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            f[t]=i;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            b/=i;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            t++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            flag=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            i++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    if(flag)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        printf(&quot;It is a prime number&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        printf(&quot;%d = &quot;,a);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        for(t=1;f[t]!=0;t++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            printf(&quot;%2d *&quot;,f[t-1]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        printf(&quot;%2d&quot;,f[t-1]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目八：正弦&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;已知求正弦&lt;/span&gt;sin(x)&lt;span&gt;的近似值的多项式公式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sin(x)=x−x 3  3!  +x 5  5!  −x 7  7!  +⋯+(−1) n x 2n+1  (2n+1)!  +…&lt;/p&gt;

&lt;p&gt;&lt;span&gt;要求输入&lt;/span&gt;x&lt;span&gt;和&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;，按上述公式计算&lt;/span&gt;&lt;span&gt;sin(x)&lt;/span&gt;&lt;span&gt;的近似值，要求计算的误差小于给定的&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;输入格式要求：&lt;/span&gt;&lt;span&gt;&quot;%f%f&quot;&lt;/span&gt; &lt;span&gt;提示信息：&lt;/span&gt;&lt;span&gt;&quot;Enter x &amp;amp; eps:&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;输出格式要求：&lt;/span&gt;&lt;span&gt;&quot;sin(%f)=%f\n&quot;  &quot;%d,sin(%f)=%f\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序运行示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Enter x &amp;amp; eps:5 0.000001&lt;/p&gt;
&lt;p&gt;sin(5.000000)=-0.958924&lt;/p&gt;
&lt;p&gt;13,sin(5.000000)=-0.958924&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（提高题部分一题&lt;/span&gt;40&lt;span&gt;分）共&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;题 选做&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;提高题一：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;堆栈&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;堆栈是数据结构中的重要线性结构，最先进入栈中的元素最后才能出栈，现在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给出三种操作指令（进栈，出栈，查询栈中中位数），请你根据指令输出当前&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作的是哪个值，其中如果栈中数量为偶数，中位数定义为其中较小的元素，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如栈中元素自底向上为&lt;/span&gt; 3 1 4 2&lt;span&gt;，那么中位数为&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一行输入给出所输入指令的总条数&lt;/span&gt; N&lt;span&gt;（&lt;/span&gt; &lt;span&gt;&amp;lt;1000&lt;/span&gt;&lt;span&gt;）&lt;/span&gt; &lt;span&gt;,&lt;/span&gt;&lt;span&gt;随后&lt;/span&gt; &lt;span&gt;N&lt;/span&gt; &lt;span&gt;行给出每个指令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Push k &lt;span&gt;代表将&lt;/span&gt; &lt;span&gt;k&lt;/span&gt; &lt;span&gt;入栈，&lt;/span&gt; &lt;span&gt;k&lt;/span&gt; &lt;span&gt;为小于&lt;/span&gt; &lt;span&gt;500&lt;/span&gt; &lt;span&gt;的正整数，&lt;/span&gt; &lt;span&gt;Pop&lt;/span&gt; &lt;span&gt;代表出栈，&lt;/span&gt; &lt;span&gt;Find&lt;/span&gt; &lt;span&gt;代表查&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;询栈中中位数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对每个输入的指令，如果是&lt;/span&gt; Pop &lt;span&gt;或&lt;/span&gt; &lt;span&gt;Find&lt;/span&gt; &lt;span&gt;操作则输出相应操作的元素。指令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非法则输出&lt;/span&gt;“Error”&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Push 3&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Push 2&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Push 1&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Error&lt;/p&gt;
&lt;p&gt;Error&lt;/p&gt;
&lt;p&gt;3 2 2 1 2 3&lt;/p&gt;
&lt;p&gt;Error&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;提高题二：结构体&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;定义存放一个学生信息的结构体类型，学生信息包括：姓名，学号，性别，院系，要求在随意输入&lt;/span&gt;5&lt;span&gt;个学生的相关信息后，按照学号从小到大顺序输出这些学生的信息。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;输入&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;先输入&lt;/span&gt;5&lt;span&gt;名学生的信息，按学号顺序排序输出后在输入要统计的院系名称&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;先按学号从小到大的顺序输出学生信息&lt;/span&gt; &lt;br/&gt;&lt;span&gt;样例输入&lt;/span&gt;&lt;br/&gt;zhang3 20149003 M &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang5 20149005 F &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang10 20149010 F &lt;span&gt;管理系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang1 20149001 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang9 20149009 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;样例输出&lt;/span&gt;&lt;br/&gt;zhang1 20149001 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang3 20149003 M &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang5 20149005 F &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang9 20149009 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang10 20149010 F &lt;span&gt;管理系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;提高题三：字符串插入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过指针&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;字符串插入&lt;/span&gt;&lt;span&gt;的功能&lt;/span&gt;,&lt;span&gt;将&lt;/span&gt;&lt;span&gt;一个&lt;/span&gt;&lt;span&gt;字符串&lt;/span&gt;&lt;span&gt;插入到另一个字符串的任意位置要求&lt;/span&gt;&lt;span&gt;将源字符串&lt;/span&gt;srcStr&lt;span&gt;连接到目的字符串&lt;/span&gt;&lt;span&gt;dstStr&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;任意位置&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串&lt;/span&gt;srcStr&lt;span&gt;：&lt;/span&gt;abc&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串&lt;/span&gt;dstStr&lt;span&gt;：&lt;/span&gt;hahaha&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入&lt;/span&gt;dstStr&lt;span&gt;的第几位：&lt;/span&gt;3&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果为：&lt;/span&gt;hahabcaha&lt;/p&gt;

</description>
<pubDate>Sun, 17 Dec 2017 15:29:00 +0000</pubDate>
<dc:creator>20175207冷南</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ln-0407/p/8053878.html</dc:identifier>
</item>
</channel>
</rss>