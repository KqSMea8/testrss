<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>zabbix - (|^_^|||)</title>
<link>http://www.cnblogs.com/L-dongf/p/9589243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/L-dongf/p/9589243.html</guid>
<description>&lt;h3 id=&quot;一部署zabbix&quot;&gt;一、部署zabbix&lt;/h3&gt;
&lt;h4 id=&quot;配置master节点&quot;&gt;1、配置master节点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;准备LAMP环境和zabbix的yum源&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# yum install httpd php mariadb-server -y
# vim /etc/my.cnf
[mysqld]
log-bin=master-log
innodb_file_per_table=ON
skip_name_resolve=ON
# systemctl start mariadb
# systemctl enable mariadb
# vim /etc/yum.repos.d/zabbix.repo
[zabbix]
name=zabbix
baseurl=https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/3.4/rhel/7/x86_64/
gpgcheck=0
[non-supported]
name=non-supported
baseurl=https://mirrors.tuna.tsinghua.edu.cn/zabbix/non-supported/rhel/7/x86_64/
gpgcheck=0&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;安装并配置zabbix&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# yum install zabbix-server-mysql zabbix-web-mysql zabbix-agent -y
# mysql
MariaDB [(none)]&amp;gt; create database zabbix character set utf8 collate utf8_bin;
MariaDB [(none)]&amp;gt; grant all privileges on zabbix.* to zabbix@localhost identified by 'zbxpass';
MariaDB [(none)]&amp;gt; grant all privileges on zabbix.* to zabbix@127.0.0.1 identified by 'zbxpass';
MariaDB [(none)]&amp;gt; grant all privileges on zabbix.* to zabbix@'192.168.0.%' identified by 'zbxpass';
MariaDB [(none)]&amp;gt; quit
# zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -h192.168.0.8 -pzbxpass zabbix
# vim /etc/zabbix/zabbix_server.conf
DBHost=192.168.0.8
DBPassword=zbxpass
# systemctl start zabbix-server
# systemctl enable zabbix-server
# vim /etc/httpd/conf.d/zabbix.conf
php_value date.timezone Asia/Shanghai
# systemctl start httpd
# systemctl enable httpd&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;浏览器访问：http://192.168.0.8/zabbix/，默认用户名密码：Admin/zabbix&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;配置被监控节点&quot;&gt;2、配置被监控节点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;配置zabbix的yum源，和master节点一致&lt;/li&gt;
&lt;li&gt;安装zabbix-agent&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# yum install zabbix-agent zabbix-sender&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置agent参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# vim /etc/zabbix/zabbix_agentd.conf
Server=192.168.0.8  #zabbix_master的IP地址，建议使用主机名
ServerActive=192.168.0.8
Hostname=node01.zabbix.com&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动agent&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# systemctl start zabbix-agent
# systemctl enable zabbix-agent&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二监控系统&quot;&gt;二、监控系统&lt;/h3&gt;
&lt;h4 id=&quot;基本具有的功能&quot;&gt;1、基本具有的功能&lt;/h4&gt;
&lt;p&gt;数据采集功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ssh/telnet&lt;/li&gt;
&lt;li&gt;SNMP&lt;/li&gt;
&lt;li&gt;IPMI&lt;/li&gt;
&lt;li&gt;JMX&lt;/li&gt;
&lt;li&gt;agent&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据存储：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SQL&lt;/li&gt;
&lt;li&gt;NoSQL&lt;/li&gt;
&lt;li&gt;rrd&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可视化：&lt;/p&gt;
&lt;p&gt;告警：&lt;/p&gt;
&lt;h4 id=&quot;zabbix&quot;&gt;2、zabbix&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;zabbix server&lt;/li&gt;
&lt;li&gt;zabbix database(MySQL)&lt;/li&gt;
&lt;li&gt;zabbix web gui(LAMP)&lt;/li&gt;
&lt;li&gt;zabbix proxy&lt;/li&gt;
&lt;li&gt;zabbix agent&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;监控基本术语&quot;&gt;3、监控基本术语&lt;/h4&gt;
&lt;p&gt;主机（host） -- 主机组（host group）&lt;/p&gt;
&lt;p&gt;监控项（item） -- 应用（application）&lt;/p&gt;
&lt;p&gt;触发器（trigger）：阈值，trigger event&lt;/p&gt;
&lt;p&gt;动作（action）：conditions（条件），operations（操作）&lt;/p&gt;
&lt;h3 id=&quot;三zabbix基本监控流程以下为webgui操作&quot;&gt;三、zabbix基本监控流程(以下为webGUI操作)&lt;/h3&gt;
&lt;h4 id=&quot;添加主机及主机组&quot;&gt;1、添加主机及主机组&lt;/h4&gt;
&lt;p&gt;Configuration -- Hosts -- Create host -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Host name: node01.zabbix.com
Visible name: node01
New group: MyServers
Agent interfaces: 
    IP address: 192.168.0.9
    Port: 10050&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建item&quot;&gt;2、创建Item&lt;/h4&gt;
&lt;p&gt;Configuration -- Hosts -- Items -- Create item -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Item:
    Name: inbound packets
    Type: Zabbix agent
    Key: net.if.in[eth0,packets]
    Host interface: 192.168.0.9:10050
    Type of information: Numeric(unsigned) #无符号整数
    Units: packets/second
    Update interval: 5s
    History storage period: 90d  #历史数据保存90天
    Trend storage period: 365d  #趋势数据
    Show value: As is  #数据状态转换(不转换)
    New application: net traffic
    Populates host inventory field: None  #是否加入资产清单
Preprocessing:  #数据预处理
    Preprocessing steps:
        Name: Change per second  #计算每秒钟的变化量&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;克隆item&quot;&gt;3、克隆Item&lt;/h4&gt;
&lt;p&gt;Configuration -- Hosts -- Items -- inbound packets -- Clone -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: inbound bytes
Key: net.if.in[eth0,bytes]
Units: Bps&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Name: outbound packets
Key: net.if.out[eth0,packets]
Units: packets/second&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Name: outbound bytes
Key: net.if.out[eth0,bytes]
Units: Bps&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建trigger&quot;&gt;4、创建Trigger&lt;/h4&gt;
&lt;p&gt;Configuration -- Hosts -- Triggers -- Create trigger -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: inbound packets too fast
Expression: {node01.zabbix.com:net.if.in[eth0,packets].last(#1)}&amp;gt;100
    Add:
        item: node01: inbound packets
        Function: last()-Last(most recent) T value
        Last of(T): 1 Count
        Result &amp;gt; 100
OK event generation: Expression  #事件恢复处理
PROBLEM event generation mode: Single  #事件报告触发一次
OK event closes: All problems  #恢复后关闭事件&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建action&quot;&gt;5、创建Action&lt;/h4&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;action: event dirven 事件驱动，触发动作&lt;/p&gt;
&lt;p&gt;​ conditions 条件&lt;/p&gt;
&lt;p&gt;​ operations 操作&lt;/p&gt;
&lt;p&gt;​ OK - PROBLEM operations&lt;/p&gt;
&lt;p&gt;​ PROBLEM - OK recovery operations&lt;/p&gt;
&lt;p&gt;​ ackownlegement operations&lt;/p&gt;
&lt;p&gt;remote command 远程命令&lt;/p&gt;
&lt;p&gt;send message 发送消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、在node01上安装nginx&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# yum install nginx -y
# systemctl start nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、将nginx加入item&lt;/p&gt;
&lt;p&gt;Configuration -- Hosts -- Items -- Create item -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: nginx service state
Key: net.tcp.port[192.168.0.9,80]
Update interval: 5s
Show value: Service state
New application: nginx status&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、定义一个Trigger&lt;/p&gt;
&lt;p&gt;Configuration -- Hosts -- Triggers -- Create trigger -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: nginx down
Severity: High
Expression: {node01.zabbix.com:net.tcp.port[192.168.0.9,80].last(#3)}=0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、定义一个Action，Event source：Triggers&lt;/p&gt;
&lt;p&gt;Configuration -- Actions -- Create action(注意：事件源选择Triggers event) -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Action: 动作
    Name: nginx service
    Type of calculation: And  #满足以下俩个条件触发操作
    Conditions: 条件
        Trigger = node01: nginx down
        Maintenance status not in maintenance  #非维护期间
Operations: 操作
    New:
        Steps: 1-1
        Operation type: Remote command
Recovery operations: 恢复操作
    Target list: Current host
    Type: Custom script
    Execute on: Zabbix agent
    Commands: sudo /usr/bin/systemctl restart nginx.service
Acknowledgement operations: 确认操作&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、利用agent来执行远程命令时需要授予zabbix用户sudo权限，并且修改agent的配置文件，在node01做以下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node01 ~]# visudo
root    ALL=(ALL)   ALL
zabbix  ALL=(ALL)   NOPASSWD: ALL
[root@node01 ~]# vim /etc/zabbix/zabbix_agentd.conf
EnableRemoteCommands=1
[root@node01 ~]# systemctl restart zabbix-agent&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建媒介实现通过邮件发送报警信息&quot;&gt;6、创建媒介，实现通过邮件发送报警信息&lt;/h4&gt;
&lt;p&gt;1、在master节点安装mailx，利用脚本发送邮件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@master ~]# yum install mailx -y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、添加媒介&lt;/p&gt;
&lt;p&gt;Administration -- Media types -- Create media type -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Media type:
    Name: local email
    Type: Email
    SMTP server: localhost
    SMTP server port: 25
    SMTP helo: localhost
    SMTP email: zabbix@localhost
    Connection security: None
    Authentication: None
Options:
    Concurrent sessions: Unlimited&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、为admin用户添加端点&lt;/p&gt;
&lt;p&gt;Administration -- Admin -- Media -- Add -- Update&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Type: local email
Send to: dongfei@localhost&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、继nginx service的Action添加报警升级操作&lt;/p&gt;
&lt;p&gt;Configuration -- Actions -- nginx service -- Operations -- New -- Add -- Update&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Steps: 2-2
Operation type: Send message
Send to Users: Admin (Zabbix Administrator)
Send only to: local email&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Recovery operations:  #恢复后发送邮件
    Send to Users: Admin (Zabbix Administrator)
    Send only to: local email&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、测试验证：可以将nginx的端口改成8080，然后将nginx进程杀掉，查看监控信息，到master节点切换到dongfei用户使用mail命令接受邮件查看报警&lt;/p&gt;
&lt;h3 id=&quot;四macro宏----预设的文本替换模式&quot;&gt;四、macro宏 -- 预设的文本替换模式&lt;/h3&gt;
&lt;p&gt;zabbix中宏有三个级别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局级别&lt;/li&gt;
&lt;li&gt;模板级别&lt;/li&gt;
&lt;li&gt;主机级别&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;内建宏&quot;&gt;1、内建宏&lt;/h4&gt;
&lt;p&gt;引用方法：{MACRO_NAME}&lt;/p&gt;
&lt;p&gt;参考：https://www.zabbix.com/documentation/3.4/manual/appendix/macros/supported_by_location&lt;/p&gt;
&lt;h4 id=&quot;自定义宏&quot;&gt;2、自定义宏&lt;/h4&gt;
&lt;p&gt;引用方法：{$MACRO_NAME}&lt;/p&gt;
&lt;p&gt;全局宏定义：Administration -- General -- Macros(右侧下拉列表) -- Add -- Update&lt;/p&gt;
&lt;p&gt;主机宏定义：Configuration -- Hosts -- node01 -- Macros -- Add -- Update&lt;/p&gt;
&lt;p&gt;模板宏定义：Configuration -- Templates -- Template OS Linux -- Macros -- Add -- Update&lt;/p&gt;
&lt;h3 id=&quot;五template-模板&quot;&gt;五、Template 模板&lt;/h3&gt;
&lt;p&gt;1、将模板连接至主机：Configuration -- Hosts -- node01 -- Templates&lt;/p&gt;
&lt;p&gt;2、自定义模板：Configuration -- Templates -- Create template&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Template name: my template
Visible name: template for os linux
New group: my template&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、导入模板：Configuration -- Templates -- Import&lt;/p&gt;
&lt;p&gt;4、到https://share.zabbix.com/下载模板，找到项目所在的GitHub站点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# yum install git -y
# git clone https://github.com/cuimingkun/zbx_tem_redis.git
# sz zbx_tem_redis/redis_templates_for_zbx_3.4.xml  #导出到windows(本地)，web导入到zabbix的模板
# scp zbx_tem_redis/userparameter_redis_lld_plus.conf node01:/etc/zabbix/zabbix_agentd.d/  #需要将自定义key的配置文件放到agent上&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六自定义key&quot;&gt;六、自定义key&lt;/h3&gt;
&lt;h4 id=&quot;直接定义key&quot;&gt;1、直接定义key&lt;/h4&gt;
&lt;p&gt;1、在agent端定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node01 ~]# vim /etc/zabbix/zabbix_agentd.d/test.conf
UserParameter=memory.used,/usr/bin/free | /usr/bin/awk '/^Mem/{print $3}'
UserParameter=memory.shm,/usr/bin/free | /usr/bin/awk '/^Mem/{print $5}'
[root@node01 ~]# systemctl restart zabbix-agent.service&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在master端测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@master ~]# yum install zabbix-get -y
[root@master ~]# zabbix_get -s node01 -p 10050 -k &quot;memory.used&quot;
181076  #获取到的数据
[root@master ~]# zabbix_get -s node01 -p 10050 -k &quot;memory.shm&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;key的参数传递&quot;&gt;2、key的参数传递&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@node01 ~]# vim /etc/zabbix/zabbix_agentd.d/memory.conf
UserParameter=memory.usage[*],/usr/bin/awk '/^$1/{print $$2}' /proc/meminfo  #此处awk中的$2需要做逃逸
[root@node01 ~]# systemctl restart zabbix-agent.service
[root@master ~]# zabbix_get -s node01 -p 10050 -k &quot;memory.usage[MemFree]&quot;
[root@master ~]# zabbix_get -s node01 -p 10050 -k &quot;memory.usage[Shmem]&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在host上创建item&quot;&gt;3、在host上创建item&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Name: memory MemFree
Key: memory.usage[MemFree]  #将参数MemFree传递给Key来获取空闲内存值
New application: memory stats&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Name: memory Buffers
Key: memory.usage[Buffers]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七discovery-自动发现&quot;&gt;七、Discovery 自动发现&lt;/h3&gt;
&lt;p&gt;1、创建自动发现扫描规则&lt;/p&gt;
&lt;p&gt;Configuration -- Discovery -- Create discovery rule -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: My Net 1
IP range: 192.168.0.1-20
Update interval: 30s  #做测试用，30s扫描一次
Checks: Zabbix agent &quot;system.uname&quot;
Device uniqueness criteria: Zabbix agent &quot;system.uname&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在node02上安装agent&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node02 ~]# yum install zabbix-agent zabbix-sender -y
[root@node02 ~]# vim /etc/zabbix/zabbix_agentd.conf
Server=master.zabbix.com
ServerActive=Server=master.zabbix.com
Hostname=node02.zabbix.com
[root@node02 ~]# systemctl start zabbix-agent.service 
[root@node02 ~]# systemctl enable zabbix-agent.service&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、添加发现行为&lt;/p&gt;
&lt;p&gt;Configuration -- Actions -- Event source(Discovery) -- Create action -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Action:
    Name: Add My Net Hosts
    Type of calculation: And
    Conditions:
        A   Discovery rule = My Net 1
        B   Discovery status = Discovered
Operations:
    Operations:
        Send message to users: Admin (Zabbix Administrator) via local email
        Add host
        Link to templates: Template OS Linux&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八主动监控方式默认是被动方式&quot;&gt;八、主动监控方式（默认是被动方式）&lt;/h3&gt;
&lt;p&gt;在agent的基本配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ServerActive=master.zabbix.com&lt;/li&gt;
&lt;li&gt;Hostname=node02.zabbix.com&lt;/li&gt;
&lt;li&gt;HostnameItem=system.hostname&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;主动检测的数据发送方式&quot;&gt;1、主动检测的数据发送方式&lt;/h4&gt;
&lt;p&gt;Configuration -- Hosts -- Items -- Create item -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Item:
    Name: net traffic in bytes
    Type: Zabbix agent (active)  #agent主动向zabbix_server发送数据
    Units: bps
    Applications: net traffic
Preprocessing:
    Preprocessing steps:
        Change per second&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zabbix_sender的数据发送方式&quot;&gt;2、zabbix_sender的数据发送方式&lt;/h4&gt;
&lt;p&gt;Configuration -- Hosts -- Items -- Create item -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: test sender metric
Type: Zabbix trapper
Key: test.sender.metric
New application: sender data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在node02端定义发送的数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node02 ~]# zabbix_sender -z master.zabbix.com -s &quot;node02.zabbix.com&quot; -k &quot;test.sender.metric&quot; -o &quot;875&quot;
[root@node02 ~]# zabbix_sender -z master.zabbix.com -s &quot;node02.zabbix.com&quot; -k &quot;test.sender.metric&quot; -o &quot;`free -m |awk '/^Mem/{print $3}'`&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;九web监控&quot;&gt;九、web监控&lt;/h3&gt;
&lt;p&gt;监控指定的站点的资源下载速度，及页面响应时间，还有响应代码&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;web.test.in[Scenario,Step,bps]：传输速率&lt;br/&gt;web.test.time[Scenario,Step]：响应时长&lt;br/&gt;web.test.rspcode[Scenario,Step]：响应码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建web监控：Configuration -- Hosts -- Web -- Create web scenario&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Scenario:
    Name: node02 web ui
    New application: node02 web ui performance
    Update interval: 10s
    Agent: Chrome 38.0(Linux)
Steps: 1:   home page   15s http://192.168.0.10/index.html      200
    Add:
        Name: home page
        URL: http://192.168.0.10/index.html
        Retrieve only headers: √
        Required status codes: 200&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;十snmp监控&quot;&gt;十、SNMP监控&lt;/h3&gt;
&lt;p&gt;Simple Network Management Protocol：简单网络管理协议&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;agent/manager&lt;/li&gt;
&lt;li&gt;Net-SNMP&lt;/li&gt;
&lt;li&gt;net-snmp-utils&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SNMP的三个版本&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v1&lt;/li&gt;
&lt;li&gt;v2c：community name is the password , public&lt;/li&gt;
&lt;li&gt;v3：支持认证和加密传输&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MIB：管理信息库，OID == Object Id&lt;/p&gt;
&lt;h4 id=&quot;配置zabbix支持snmp&quot;&gt;1、配置zabbix支持SNMP&lt;/h4&gt;
&lt;p&gt;在被监控主机中安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# yum install net-snmp net-snmp-utils -y  #net-snmp-utils用来测试用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置启动服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# vim /etc/snmp/snmpd.conf
#view    systemview    included   .1.3.6.1.2.1.1
#view    systemview    included   .1.3.6.1.2.1.25.1.1
view    systemview    included   .1.3.6.1
# systemctl start snmpd
# systemctl enable snmpd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本机测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# snmptranslate -Tp .1.3.6.1.2.1 |more
# snmpget -v 2c -c public 192.168.0.10 .1.3.6.1.2.1.1.1.0  #获取系统描述信息
# snmpwalk -v 2c -c public 192.168.0.10 .1.3.6.1.2.1.25.4.2.1.2  #获取进程列表&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在zabbix配置监控&quot;&gt;2、在zabbix配置监控&lt;/h4&gt;
&lt;p&gt;Configuration -- Hosts -- Create Host -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Host name: node02
Visible name: node02
New group: my linux servers
SNMP interfaces: 192.168.0.10 DNS 161&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-- Item -- Create Item -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Item:
    Name: net traffic in bytes
    Type: SNMPv2 agent
    Key: net.if.in.bytes
    SNMP OID: .1.3.6.1.2.1.2.2.1.10.2
    SNMP community: public
    Units: bps
    Update interval: 5s
    New application: net traffic
Preprocessing:
    Preprocessing steps: Change per second&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;十一jmx监控&quot;&gt;十一、JMX监控&lt;/h3&gt;
&lt;p&gt;JMX：java管理扩展&lt;/p&gt;
&lt;p&gt;1、在node02上安装配置Tomcat&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node02 ~]# yum install java-1.8.0-openjdk-devel tomcat tomcat-admin-webapps tomcat-webapps tomcat-docs-webapps -y
[root@node02 ~]# vim /etc/tomcat/tomcat.conf  #加入以下配置
CATALINA_OPTS=&quot;-Djava.rmi.server.hostname=192.168.0.10 -Djavax.management.bui
lder.initial= -Dcom.sun.management.jmxremote=true   -Dcom.sun.management.jmxr
emote.port=12345  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.managem
ent.jmxremote.authenticate=false&quot;
[root@node02 ~]# systemctl start tomcat
[root@node02 ~]# ss -tnl |grep 12345
LISTEN     0      50          :::12345
[root@node02 ~]# systemctl enable tomcat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在zabbix-server上安装配置zabbix-java-gateway（如果有大量的jvm需要被监控，那么java-gateway需要独立安装到一台服务器中）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@master ~]# yum install zabbix-java-gateway -y
[root@master ~]# vim /etc/zabbix/zabbix_java_gateway.conf
LISTEN_PORT=10052
START_POLLERS=5
[root@master ~]# systemctl start zabbix-java-gateway
[root@master ~]# ss -tnl |grep 10052
LISTEN     0      50          :::10052
[root@master ~]# vim /etc/zabbix/zabbix_server.conf
JavaGateway=192.168.0.8
JavaGatewayPort=10052
StartJavaPollers=5
[root@master ~]# systemctl restart zabbix-server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、在zabbix的webGUI中配置监控&lt;/p&gt;
&lt;p&gt;Configuration -- Hosts -- Create Host -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JMX interfaces: 192.168.0.10 12345
Linked templates: Template App Apache Tomcat JMX&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;十二zabbix的分布式监控&quot;&gt;十二、zabbix的分布式监控&lt;/h3&gt;
&lt;p&gt;1、配置zabbix_proxy，192.168.0.11&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@zabbix_proxy ~]# yum install mariadb-server zabbix-proxy-mysql zabbix-get zabbix-agent zabbix-sender -y
[root@zabbix_proxy ~]# vim /etc/my.cnf
[mysqld]
skip_name_resolve=0
[root@zabbix_proxy ~]# systemctl start mariadb
[root@zabbix_proxy ~]# systemctl enable mariadb
[root@zabbix_proxy ~]# mysql
MariaDB [(none)]&amp;gt; CREATE DATABASE zbxproxy character set utf8 collate utf8_bin;
MariaDB [(none)]&amp;gt; GRANT ALL PRIVILEGES ON zbxproxy.* TO zabbix@localhost IDENTIFIED BY 'zbxpass';
[root@zabbix_proxy ~]# zcat /usr/share/doc/zabbix-proxy-mysql-3.4.13/schema.sql.gz |mysql -uzabbix -pzbxpass zbxproxy
[root@zabbix_proxy ~]# vim /etc/zabbix/zabbix_proxy.conf
Server=192.168.0.8
Hostname=zabbix_proxy  #注意此处的主机名必须可以被解析
ListenPort=10051
DBName=zbxproxy
DBUser=zabbix
DBPassword=zbxpass
HeartbeatFrequency=20
ConfigFrequency=10
DataSenderFrequency=1
[root@zabbix_proxy ~]# systemctl start zabbix-proxy.service 
[root@zabbix_proxy ~]# systemctl enable zabbix-proxy.service&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在zabbix的webGUI中配置proxy&lt;/p&gt;
&lt;p&gt;Administration -- Proxies -- Create proxy -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Proxy name: zabbix_proxy  #此处的主机名一定需要被解析&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、加入被proxy代理的被监控端，注意：被监控的agent需要配置允许proxy监控&lt;/p&gt;
&lt;p&gt;Configuration -- Hosts -- Create host -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Host:
    Host name: master.dongfei.tech
    Visible name: k8s_master
    New group: my linux servers
    Agent interfaces: 192.168.0.12 10050
    Monitored by proxy: zabbix_proxy
Templates:
    Linked templates: Template OS Linux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、由proxy的自动发现&lt;/p&gt;
&lt;p&gt;Configuration -- Create discovery rule -- Add&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: My Net 2
Discovery by proxy: zabbix_proxy
IP range: 192.168.0.1-20
Update interval: 1h
Checks: Zabbix agent &quot;system.uname&quot;
Device uniqueness criteria: Zabbix agent &quot;system.uname&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感谢阅读，未完待续。。。&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 15:28:00 +0000</pubDate>
<dc:creator>(|^_^|||)</dc:creator>
<og:description>一、部署zabbix 1、配置master节点 准备LAMP环境和zabbix的yum源 安装并配置zabbix 浏览器访问：http://192.168.0.8/zabbix/，默认用户名密码：Ad</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/L-dongf/p/9589243.html</dc:identifier>
</item>
<item>
<title>Nginx（二）------nginx.conf 配置文件 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9384880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9384880.html</guid>
<description>&lt;p&gt;　　上一篇博客我们将 nginx 安装在 /usr/local/nginx 目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改，所以本篇博客我们先大致介绍一下该配置文件的结构。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729225520207-404971432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1、nginx.conf 的主体结构&lt;/h3&gt;
&lt;p&gt;　　打开此文件，内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7dd7e6d1-a0ea-47da-b307-714f0cb8b116')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7dd7e6d1-a0ea-47da-b307-714f0cb8b116&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7dd7e6d1-a0ea-47da-b307-714f0cb8b116&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7dd7e6d1-a0ea-47da-b307-714f0cb8b116',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7dd7e6d1-a0ea-47da-b307-714f0cb8b116&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#user  nobody;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; worker_processes  1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; #error_log  logs/&lt;span&gt;error.log;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; #error_log  logs/&lt;span&gt;error.log  notice;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; #error_log  logs/&lt;span&gt;error.log  info;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; #pid        logs/&lt;span&gt;nginx.pid;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;events {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     worker_connections  1024&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;http {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;    include       mime.types;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     default_type  application/octet-&lt;span&gt;stream;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;     #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
&lt;span&gt; 21&lt;/span&gt;     #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
&lt;span&gt; 22&lt;/span&gt;     #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;     #access_log  logs/&lt;span&gt;access.log  main;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    sendfile        on;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    #tcp_nopush     on;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     #keepalive_timeout  0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     keepalive_timeout  65&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;    #gzip  on;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;         #charset koi8-&lt;span&gt;r;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;         #access_log  logs/&lt;span&gt;host.access.log  main;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            root   html;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            index  index.html index.htm;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;         #error_page  404              /404&lt;span&gt;.html;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;         # redirect server error pages to the &lt;span&gt;static&lt;/span&gt; page /&lt;span&gt;50x.html
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         error_page   500 502 503 504  /&lt;span&gt;50x.html;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         location = /&lt;span&gt;50x.html {
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;            root   html;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt;         # proxy the PHP scripts to Apache listening on 127.0.0.1:80
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         #location ~&lt;span&gt; \.php$ {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         #    proxy_pass   http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        #}
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;         # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         #location ~&lt;span&gt; \.php$ {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        #    root           html;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         #    fastcgi_pass   127.0.0.1:9000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        #    fastcgi_index  index.php;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         #    fastcgi_param  SCRIPT_FILENAME  /&lt;span&gt;scripts$fastcgi_script_name;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        #    include        fastcgi_params;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        #}
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;         # deny access to .htaccess files, &lt;span&gt;if&lt;/span&gt; Apache's document root
&lt;span&gt; 73&lt;/span&gt;         # concurs with nginx's one
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         #location ~ /&lt;span&gt;\.ht {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        #    deny  all;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        #}
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     # another virtual host using mix of IP-, name-, and port-&lt;span&gt;based configuration
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    #
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    #server {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     #    listen       8000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     #    listen       somename:8080&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    #    server_name  somename  alias  another.alias;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     #    location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    #        root   html;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    #        index  index.html index.htm;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    #    }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    #}
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    # HTTPS server
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;    #
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    #server {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     #    listen       443&lt;span&gt; ssl;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    #    server_name  localhost;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;    #    ssl_certificate      cert.pem;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;    #    ssl_certificate_key  cert.key;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    #    ssl_session_cache    shared:SSL:1m;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    #    ssl_session_timeout  5m;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     #    ssl_ciphers  HIGH:!aNULL:!&lt;span&gt;MD5;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    #    ssl_prefer_server_ciphers  on;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;     #    location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;    #        root   html;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;    #        index  index.html index.htm;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    #    }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;    #}
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　# 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; worker_processes  1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;events {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     worker_connections  1024&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;http {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    include       mime.types;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     default_type  application/octet-&lt;span&gt;stream;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    sendfile        on;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     keepalive_timeout  65&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            root   html;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            index  index.html index.htm;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         error_page   500 502 503 504  /&lt;span&gt;50x.html;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         location = /&lt;span&gt;50x.html {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            root   html;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分：&lt;/p&gt;
&lt;h3&gt;2、全局块&lt;/h3&gt;
&lt;p&gt;　　从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。&lt;/p&gt;
&lt;p&gt;　　比如上面第一行配置的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
worker_processes  1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约，这个后面会详细介绍。&lt;/p&gt;
&lt;h3&gt;3、events 块&lt;/h3&gt;
&lt;p&gt;　　比如上面的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;events {
    worker_connections  &lt;/span&gt;1024&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。&lt;/p&gt;
&lt;p&gt;　　上述例子就表示每个 work process 支持的最大连接数为 1024.&lt;/p&gt;
&lt;p&gt;　　这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。&lt;/p&gt;
&lt;h3&gt;4、http 块&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;http {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    include       mime.types;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     default_type  application/octet-&lt;span&gt;stream;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    sendfile        on;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     keepalive_timeout  65&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            root   html;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            index  index.html index.htm;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         error_page   500 502 503 504  /&lt;span&gt;50x.html;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         location = /&lt;span&gt;50x.html {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            root   html;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。&lt;/p&gt;
&lt;p&gt;　　需要注意的是：http 块也可以包括 &lt;strong&gt;http全局块&lt;/strong&gt;、&lt;strong&gt;server 块&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;①、http 全局块&lt;/h4&gt;
&lt;p&gt;　　http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。&lt;/p&gt;
&lt;h4&gt;②、server 块&lt;/h4&gt;
&lt;p&gt;　　这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。后面会详细介绍虚拟主机的概念。&lt;/p&gt;
&lt;p&gt;　　每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。&lt;/p&gt;
&lt;p&gt;　　而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、全局 server 块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、location 块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个 server 块可以配置多个 location 块。&lt;/p&gt;
&lt;p&gt;　　这块的主要作用是基于 Nginx  服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。&lt;/p&gt;

</description>
<pubDate>Tue, 04 Sep 2018 14:50:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Nginx（二）------nginx.conf 配置文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9384880.html</dc:identifier>
</item>
<item>
<title>scala成长之路（6）函数入门 - 王亚楼</title>
<link>http://www.cnblogs.com/wangyalou/p/9588941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangyalou/p/9588941.html</guid>
<description>&lt;p&gt;众所周知，scala作为一门极客型的函数式编程语言，支持的特性包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数拥有“一等公民”身份；&lt;/li&gt;
&lt;li&gt;支持匿名函数(函数字面量) &lt;/li&gt;
&lt;li&gt;支持高阶函数 &lt;/li&gt;
&lt;li&gt;支持闭包 &lt;/li&gt;
&lt;li&gt;部分应用函数 &lt;/li&gt;
&lt;li&gt;柯里化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先需要指出，在scala中有&lt;strong&gt;方法&lt;/strong&gt;和&lt;strong&gt;函数对象&lt;/strong&gt;两种形态，方法即是通过def关键字定义的函数，而函数对象则是通过将方法转换而来，或lambda赋值而来。&lt;/p&gt;
&lt;p&gt;1. 从“一等公民”说起&lt;/p&gt;
&lt;p&gt;很多稍微了解过函数式编程的人可能都听说过“一等公民”这种说法，但却很少有人能明明白白地说出究竟什么是“一等公民”。这里我做个类比你马上就明白了：现实中，什么样的人能被当做一等公民？首先，他必须是个&lt;strong&gt;独立的个体&lt;/strong&gt;——依赖父母或朋友才能生存的人肯定不能被当做公民，更不用说一等了；其次，这个人必须拥有&lt;strong&gt;足够的自由&lt;/strong&gt;——既能上九天揽月，又可下五洋捉鳖，方才能是一等公民。对应到我们的函数式编程，我们可以总结出几个点：&lt;/p&gt;
&lt;p&gt;（1） 函数的定义和调用不依赖其他结构，例如C、python、js、scala，而反面典型就是java，因为java的任何函数（方法）都必须定义在类、接口、枚举（其实也是类）中，而且任何的方法调用都要通过对象、类的静态方法或接口（jdk 1.8），方法不可能直接调用，必须依附于其他结构而存在。所以这种情况下函数肯定不是“一等公民”。&lt;/p&gt;
&lt;p&gt;（2）函数可以作为函数的参数、返回值，并可以对函数进行变量赋值，而且函数的定义位置极度自由，任何代码块里又能定义函数。&lt;/p&gt;
&lt;p&gt;现在我们再来看scala，它完美地契合上边所有的需求（但是注意，除了脚本形式的scala之外，其他的scala程序也只能包含在class或object中），scala中函数支持在函数内部定义，而且使用lambda表达式定义的函数可以赋值给任何变量、常量，所有函数均可作为返回值、参数。&lt;/p&gt;
&lt;p&gt;2. lambda表达式的学问&lt;/p&gt;
&lt;p&gt;很多scala初学者都倒在了scala的lambda上，因为scala lambda的灵活多样，导致很多时候你可能都看不懂。下面我们从最基本的讲起：&lt;/p&gt;
&lt;p&gt;最基本的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
val fun = (a:Int) =&amp;gt; {a &amp;lt; 100 &amp;amp;&amp;amp; a &amp;gt; 0}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当r定义的参数为函数时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def fun1(f:String =&amp;gt; Unit) = f(&quot;wangyalou&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以方便地使用lambda传入需要的函数：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fun1((s:String)=&amp;gt;{println(s)})
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;注意了，一般人都不这么写，因为作为参数的lambda可~以~简~写~~~~~准备好我要开始啰！首先，省略掉可以推断出来的类型参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
fun1((s)=&amp;gt;{println(s)})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当只有一个参数时，=&amp;gt;前的()可省：&lt;/p&gt;
&lt;div readability=&quot;51.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
fun1(s=&amp;gt;{println(s)})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可再简化，scala中可以用_代替只出现一次的参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fun1(println(_))  或 fun1(println _)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，我们甚至连下划线都可以不要了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
fun1(println)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，最后的情况我们是利用了编译器支持lambda的&lt;strong&gt;“eta转换”&lt;/strong&gt;，即在表达式只有一个参数，且整个执行部分就是一个函数调用时，可以直接写函数名&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;插一句：eta扩展（eta-expression）是另一个东西，指的是将一个普通方法转换为函数对象的过程：&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span&gt;val b=&lt;span&gt; too(_,_,_)
val b&lt;/span&gt;=&lt;span&gt; too _    //这也可以？是的
val b : (Int,Int,Int) &lt;/span&gt;=&amp;gt;Int = foo&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;其中too为一个参数为3个Int的方法&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;但是，too(_,_,1)一定不是eta扩展！&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下划线的用法博大精深，这里再给出一些例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
例1：lambda作为参数，_可代替只用一次的参数，且省掉“=&amp;gt;”&lt;br/&gt;val nums = Array(1,2,3,4&lt;span&gt;)
nums.filter(_&lt;/span&gt;&amp;gt;2&lt;span&gt;)&lt;br/&gt;运行结果：
res31: Array[Int] &lt;/span&gt;= Array(3, 4)&lt;/pre&gt;
&lt;pre&gt;
例2：lambda作为参数，_可代替只用一次的参数，且省掉“=&amp;gt;”
&lt;/pre&gt;
&lt;p&gt;scala&amp;gt; def foo(f:(Int,Int)=&amp;gt;Int)(a:Int,b:Int) = f(a,b)&lt;br/&gt;foo: (f: (Int, Int) =&amp;gt; Int)(a: Int, b: Int)Int&lt;/p&gt;
&lt;p&gt;scala&amp;gt; foo(_+_)(3,4)&lt;br/&gt;res33: Int = 7&lt;/p&gt;

&lt;pre&gt;
例3：lambda作为函数定义，_可代替只用一次的参数，且省掉“=&amp;gt;”，但这时要加上类型，因为这里无法推断出“_”的类型
&lt;/pre&gt;
&lt;p&gt;val b = (_:Int) + (_:Int)&lt;/p&gt;
&lt;p&gt;b(1,2)&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;res32: Int = 3&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;3. 部分应用函数（偏函数）&lt;/p&gt;
&lt;p&gt;一个例子足以说清楚：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
scala&amp;gt; def foo(a&lt;span&gt;:Int&lt;/span&gt;, b&lt;span&gt;:Int&lt;/span&gt;, c&lt;span&gt;:Boolean&lt;/span&gt;) = &lt;span&gt;if&lt;/span&gt;(c) a+b &lt;span&gt;else&lt;/span&gt;&lt;span&gt; a-b
foo: &lt;/span&gt;(a: Int, b: Int, c: Boolean)&lt;span&gt;Int&lt;br/&gt;scala&lt;/span&gt;&amp;gt; val foom = foo(_&lt;span&gt;:Int&lt;/span&gt;,_&lt;span&gt;:Int&lt;/span&gt;,false)&lt;span&gt;
foom: &lt;/span&gt;(Int, Int) =&amp;gt; Int = &amp;lt;function2&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似于python中的偏函数，这里将某个参数确定，其他参数用&quot;_&quot;代替并指明其类型，注意一定要指明类型啊！！！不然就成了eta扩展失败的案例了！！&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 04 Sep 2018 14:27:00 +0000</pubDate>
<dc:creator>王亚楼</dc:creator>
<og:description>scala函数式编程入门</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangyalou/p/9588941.html</dc:identifier>
</item>
<item>
<title>Python制作回合制手游外挂简单教程（中） - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/9588829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/9588829.html</guid>
<description>&lt;p&gt;接着上篇的&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Java-Starter/p/9571919.html&quot; target=&quot;_blank&quot;&gt;博文&lt;/a&gt;&lt;/strong&gt;，今天我们讲如何实现自动组队刷道&lt;/p&gt;

&lt;h2&gt;引入：&lt;/h2&gt;
&lt;p&gt;自动组队刷道的流程是先点击刷道按钮、再点击前往按钮、再点击便捷组队······&lt;/p&gt;
&lt;p&gt;这些操作上篇博文已经告诉我们怎么做了，利用picpick丈量坐标，再用autopy模拟鼠标点击&lt;/p&gt;
&lt;p&gt;但是点击过便捷组队后如何实现自动创建队伍并匹配队友呢？&lt;/p&gt;
&lt;p&gt;这里要用到文字识别&lt;/p&gt;
&lt;p&gt;玩过问道的都知道，没有队友或者队友数量没到4的时候，队伍会存在守护,如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904175745013-1114057296.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且守护的位置是固定的，守护的优先级是从左到右，例如，匹配到一个队友，斗阙长老就会消失（不会参战）；再匹配一个队友，白骨长老就会消失（不会参战）&lt;/p&gt;
&lt;p&gt;我的思路是，隔一段时间对夜神模拟器截图，再对这张截图文字识别，判断“斗阙长老”和“白骨长老”是否存在于识别出的字符串中。当然，也可以判断长老数量是否小于等于2&lt;/p&gt;
&lt;p&gt;因为玩过回合制的知道，队伍达到三个人就可以发车了，做任务的过程中系统会自动匹配队友，直到匹配满为止&lt;/p&gt;

&lt;h2&gt;前期准备：&lt;/h2&gt;
&lt;h3&gt;利用PIL的ImageGrab截图&lt;/h3&gt;
&lt;p&gt;安装PIL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install pillow
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(pillow包里包含了pil，pil目前已经停止维护了)&lt;/p&gt;
&lt;p&gt;我这里是用PyCharm直接安装的依赖包&lt;/p&gt;

&lt;p&gt;复制代码，直接运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
import time
import win32api

import win32con
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; PIL import ImageGrab&lt;/span&gt;&lt;span&gt;

time.sleep(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
# 参数说明
# 第一个参数 开始截图的x坐标
# 第二个参数 开始截图的y坐标
# 第三个参数 结束截图的x坐标
# 第四个参数 结束截图的y坐标
bbox &lt;/span&gt;= (&lt;span&gt;391&lt;/span&gt;, &lt;span&gt;156&lt;/span&gt;, &lt;span&gt;1582&lt;/span&gt;, &lt;span&gt;853&lt;/span&gt;&lt;span&gt;)
im &lt;/span&gt;=&lt;span&gt; ImageGrab.grab(bbox)

# 参数 保存截图文件的路径
im.save(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;as.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;直接运行，会发现在当前目录下有一个as.png的截图文件&lt;/p&gt;
&lt;p&gt;官方文档对grab方法给出的解释&lt;/p&gt;
&lt;p&gt;这里bbox = (x1,y1,x2,y2)，意思是从屏幕坐标(x1,y1)到(x2,y2)的一段区域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ImageGrab.grab(bbox) ⇒ image

(New &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;) Take a snapshot of the screen, and &lt;span&gt;return&lt;/span&gt; an “RGB” image. The bounding box argument can be used to copy only a part of the screen.
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;利用baidu-aip进行文字识别&lt;/h3&gt;
&lt;p&gt;我尝试过pytesseract和pytesser的文字识别，经常会出现识别失败，对中文的支持也不够友好&lt;/p&gt;
&lt;p&gt;所以我这里选用baidu-aip进行文字识别&lt;/p&gt;
&lt;p&gt;PyCharm打开File-&amp;gt;Settings-&amp;gt;加号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904183317352-838357996.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;411&quot;/&gt;&lt;/p&gt;

&lt;p&gt;搜索baidu-aip，再点击左下角Install Package&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904183352548-495485256.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们需要APPP_ID、API_KEY、SECRET_KEY，我们去百度云申请&lt;/p&gt;
&lt;p&gt;登录&lt;strong&gt;&lt;a href=&quot;https://cloud.baidu.com/&quot; target=&quot;_blank&quot;&gt;百度云&lt;/a&gt;&lt;/strong&gt;，百度云盘和百度贴吧账号可以直接使用，没有的话申请一个百度账号&lt;/p&gt;
&lt;p&gt;找到文字识别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904185617981-496820262.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 点击创建应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904190032458-610748415.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完成创建，个人用户一天可以免费识别600次&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904190131441-47556454.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt;需要识别文字的图片用下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904190317384-1819436685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;复制代码，运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; aip import AipOcr

import re

#百度文字识别
APPP_ID &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;APP_ID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
API_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;APP_KEY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SECRET_KEY &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SECRET_KEY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

client &lt;/span&gt;=&lt;span&gt; AipOcr(APPP_ID,API_KEY,SECRET_KEY)

i &lt;/span&gt;= open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\python_project\test\imageIdentification\helpedName1.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

img &lt;/span&gt;=&lt;span&gt; i.read()

message &lt;/span&gt;=&lt;span&gt; client.basicGeneral(img);&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; message.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;words_result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):

    print(i.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;words&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904190353566-1834898532.png&quot; alt=&quot;&quot; width=&quot;677&quot; height=&quot;87&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;开始制作外挂：&lt;/h2&gt;
&lt;p&gt;和上篇博客一样，先丈量坐标，坐标根据分辨率不同而不同，我这里是1920*1080&lt;/p&gt;
&lt;p&gt; 刷道按钮的坐标是(809,222)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904212539386-1903909304.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 前往按钮的坐标是(1101,646)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904212718781-1274638548.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt;便捷组队的坐标是(1449,730)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904212822923-1886791594.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 创建队伍按钮(998,799)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904213000139-1193261943.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 开始匹配(1232,794)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904213114789-1180482109.png&quot; alt=&quot;&quot; width=&quot;595&quot;/&gt;&lt;/p&gt;

&lt;p&gt;丈量坐标完毕后，调用文字识别，判断“斗阙长老”和“白骨长老”是否存在于识别的字符串中&lt;/p&gt;
&lt;p&gt;如果两位长老都不存在，说明队伍里已经有三人。此时关闭刷道窗口，点击陆压真人，对话，开始刷道&lt;/p&gt;
&lt;p&gt;设置十轮刷道时间，十轮刷道任务结束后开始新的一轮刷道&lt;/p&gt;

&lt;p&gt;详细代码如下：&lt;/p&gt;
&lt;p&gt;imageGrabUtil.py（截图工具）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt;&lt;span&gt; PIL import ImageGrab
# 参数说明
# 第一个参数 开始截图的x坐标
# 第二个参数 开始截图的y坐标
# 第三个参数 结束截图的x坐标
# 第四个参数 结束截图的y坐标
def screenshot(x1,y1,x2,y2,filename):
    bbox &lt;/span&gt;=&lt;span&gt; (x1, y1, x2, y2)
    im &lt;/span&gt;=&lt;span&gt; ImageGrab.grab(bbox)

    # 参数 保存截图文件的路径
    im.save(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\python_project\\Asktao_Automation\\resource\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+filename+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;baiduAipUtil.py（文字识别工具）&lt;/p&gt;
&lt;p&gt;我这里百度云的APPP_ID、API_KEY、SECRET_KEY保存在config.ini&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; aip import AipOcr

import re

#百度文字识别
# &lt;/span&gt;!/usr/bin/&lt;span&gt;env python
# &lt;/span&gt;-*- coding:utf-&lt;span&gt;8&lt;/span&gt; -*-&lt;span&gt;

import ConfigParser
import os

os.chdir(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:\python_project\Asktao_Automation\util&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

cf &lt;/span&gt;=&lt;span&gt; ConfigParser.ConfigParser()
&lt;/span&gt;&lt;span&gt;
cf.read(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config.ini&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;
secs &lt;/span&gt;=&lt;span&gt; cf.sections()

APPP_ID &lt;/span&gt;= cf.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baiduAip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;APPP_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
API_KEY &lt;/span&gt;= cf.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baiduAip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API_KEY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
SECRET_KEY &lt;/span&gt;= cf.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baiduAip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SECRET_KEY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;
client &lt;/span&gt;=&lt;span&gt; AipOcr(APPP_ID,API_KEY,SECRET_KEY)

def characterRecognition(filePath):
    i &lt;/span&gt;= open(filePath,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    img &lt;/span&gt;=&lt;span&gt; i.read()

    message &lt;/span&gt;=&lt;span&gt; client.basicGeneral(img);

    #print(message.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;words_result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; message.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;words_result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):

        print(i.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;words&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; += i.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;words&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;config.ini&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[baiduAip]
APPP_ID &lt;/span&gt;= &lt;span&gt;APPP_ID &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;API_KEY &lt;/span&gt;=&lt;span&gt; &lt;span&gt;API_KEY &lt;/span&gt; &lt;p&gt;SECRET_KEY &lt;/p&gt;&lt;/span&gt;= &lt;span&gt;SECRET_KEY &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;shuaDao.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
import autopy
import time
import win32api
import win32con
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; imageGrabUtil import screenshot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; baiduAipUtil import characterRecognition
import sys
defaultencoding &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; sys.getdefaultencoding() !=&lt;span&gt; defaultencoding:
    reload(sys)
    sys.setdefaultencoding(defaultencoding)


#刷道（队长模式）
#time.sleep(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #alt键位码是18
win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #tab键位码是9
time.sleep(&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)
win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #enter键位码是13

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) #释放按键
win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
time.sleep(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)

def mousemove_click(x,y):
    autopy.mouse.smooth_move(x, y)
    autopy.mouse.click()

mousemove_click(&lt;/span&gt;&lt;span&gt;809&lt;/span&gt;,&lt;span&gt;222&lt;/span&gt;&lt;span&gt;)#移动到刷道按钮

mousemove_click(&lt;/span&gt;&lt;span&gt;1101&lt;/span&gt;,&lt;span&gt;646&lt;/span&gt;&lt;span&gt;)#点击前往

time.sleep(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)#从其他地图走到轩辕庙陆压真人处花费10s

mousemove_click(&lt;/span&gt;&lt;span&gt;1449&lt;/span&gt;,&lt;span&gt;730&lt;/span&gt;&lt;span&gt;)#点击便捷组队

mousemove_click(&lt;/span&gt;&lt;span&gt;998&lt;/span&gt;,&lt;span&gt;799&lt;/span&gt;&lt;span&gt;)#点击创建队伍

mousemove_click(&lt;/span&gt;&lt;span&gt;1121&lt;/span&gt;,&lt;span&gt;781&lt;/span&gt;&lt;span&gt;)#点击开始匹配

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;):
    teamFileName &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;judgeTeamCount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    time.sleep(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    screenshot(&lt;/span&gt;&lt;span&gt;391&lt;/span&gt;, &lt;span&gt;156&lt;/span&gt;, &lt;span&gt;1582&lt;/span&gt;, &lt;span&gt;853&lt;/span&gt;&lt;span&gt;,teamFileName)#截图

    judgeTeamStr &lt;/span&gt;= characterRecognition(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\python_project\\Asktao_Automation\\resource\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+teamFileName+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)#文字识别
    #每个人守护顺序不一样，按需修改
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;斗阙长老&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; not &lt;span&gt;in&lt;/span&gt; judgeTeamStr and &lt;span&gt;'&lt;/span&gt;&lt;span&gt;白骨长老&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; not &lt;span&gt;in&lt;/span&gt;&lt;span&gt; judgeTeamStr: #这两个守护不在，说明队伍已有三人，开始刷道
        mousemove_click(&lt;/span&gt;&lt;span&gt;1524&lt;/span&gt;,&lt;span&gt;234&lt;/span&gt;&lt;span&gt;) #点击关闭按钮
        mousemove_click(&lt;/span&gt;&lt;span&gt;809&lt;/span&gt;, &lt;span&gt;222&lt;/span&gt;&lt;span&gt;)  # 移动到刷道按钮
        mousemove_click(&lt;/span&gt;&lt;span&gt;1101&lt;/span&gt;, &lt;span&gt;646&lt;/span&gt;&lt;span&gt;)  # 点击前往
        mousemove_click(&lt;/span&gt;&lt;span&gt;1446&lt;/span&gt;, &lt;span&gt;661&lt;/span&gt;&lt;span&gt;)#点击【伏魔】我这就去
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

    time.sleep(&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;)#休息十分钟后再次查看是否组到人

#刷道十轮之后的操作
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;):
    time.sleep(&lt;/span&gt;&lt;span&gt;780&lt;/span&gt;&lt;span&gt;)#平民伏魔一般780s之内，土豪伏魔有300s的，按需修改
    taskFileName &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;judgeTaskAccomplish&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    time.sleep(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    screenshot(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;, &lt;span&gt;164&lt;/span&gt;, &lt;span&gt;1701&lt;/span&gt;, &lt;span&gt;866&lt;/span&gt;&lt;span&gt;,taskFileName)
    judgeTaskStr &lt;/span&gt;= characterRecognition(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\python_project\\Asktao_Automation\\resource\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+taskFileName+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;【伏魔】我这就去&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; judgeTaskStr:
        mousemove_click(&lt;/span&gt;&lt;span&gt;1446&lt;/span&gt;, &lt;span&gt;661&lt;/span&gt;&lt;span&gt;)  # 点击【伏魔】我这就去
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        time.sleep(&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;) #防止780s内还没有完成伏魔操作，再等60s，以防万一
        mousemove_click(&lt;/span&gt;&lt;span&gt;1446&lt;/span&gt;, &lt;span&gt;661&lt;/span&gt;)  # 点击【伏魔】我这就去
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;鉴于博客园只能上传10MB以下的GIF，所以我没有上传完整的效果图&lt;/p&gt;
&lt;p&gt;亲测可用，大概十分钟左右可以匹配到三个人，就开始刷道&lt;/p&gt;
&lt;p&gt;10轮刷道为一组，组数可以自己将循环数设大一点，我这里设的是10&lt;/p&gt;
&lt;p&gt;有的时候匹配不到人，比如像白天就比较难匹配到人。可以把截图判断长老是否存在的那部分，多循环几次&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再次强调，我的代码不一定在你的电脑上可以运行，我的电脑分辨率是1920*1080,模拟器的位置是默认的放在中央，模拟器移动的话丈量的坐标都不一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;制作外挂最重要的是思想方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201809/1201453-20180904215603872-1656702801.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 14:08:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>Python制作回合制游戏外挂的简单教程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java-Starter/p/9588829.html</dc:identifier>
</item>
<item>
<title>表单数据验证方法（二）——ASP.NET后台验证 - CherishTheYouth</title>
<link>http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_904.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　昨天写了一下关于如何在前台快捷实现表单数据验证的方法，今天接着昨天的，把后台实现数据验证的方法记录一下。先说明一下哈，我用的是asp.net，所以后台验证方法也是基于.net mvc来做的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了，闲言少叙，我回到正题上来啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后台实现表单数据验证的方法也是相当简单的，下面看我一步一步的来做哈。（为了单纯的说明表单验证的方法，减少其他不必要的内容的说明，这里我就不涉及数据库了。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.新建一个.net mvc应用程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一步今天就不详细讲了，有时间的话再写一篇关于如何新建项目和实现简单增删改查功能的博客，巩固自己，顺便帮帮和我一样入地无门的菜鸡们。建好的应用程序如图所示，我的名字起为FormCheck：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454180/201809/1454180-20180904210518546-426120786.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2.新建用户信息字段实体数据类User816.cs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（这个命名各位不要去纠结他哈，因为我这里用的不是刚写的热乎代码，而是8月16日写的冷代码，因为晚上时间有限，就不重新写了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如下图所示，我在Models文件夹中新建一个User816.cs的实体类，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FormCheck.Models
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User816
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; userName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; passWord { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; eMail { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;              
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们写了三个属性，分别为用户名、密码和邮箱，下面将依次为这几个数据添加校验方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要添加[Required] ，[ StringLength] ，[RegularExpression] 三个吧，因为这三个是最常用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）Required&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先看看这个方法的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454180/201809/1454180-20180904211756100-1724066508.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这段代码只需要看到能看懂的汉字就可以了，没错，就是那个 【指定的数据字段的值是必须的】，好了现在我们知道这个是什么意思了，那么问题来了，这个东西怎么用呢？看下面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   [Required(ErrorMessage =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必填项&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; userName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在需要验证的属性上面用中括号将Required包起来，然后可以添加上错误提示信息。怎么样，是不是很简单，哈哈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）StringLength&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这个也是一样的，直接看看这个东东的意思和用法，就一笔带过了吧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454180/201809/1454180-20180904212833024-1661814647.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 用法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; [StringLength(&lt;span&gt;5&lt;/span&gt;,ErrorMessage =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*超过长度了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) ]
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; userName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的第一个参数【5】指的是字符串的最大长度 ，当然这里并不是只能设置最大长度，也可以设置最小长度，不止如此，还有很多其他的用法，这里我就不细说了，具体的需要用到的同学可以在网上搜索资料。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）RegularExpression&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个就比较牛逼了，验证正则表达式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454180/201809/1454180-20180904213857068-1920019790.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; [RegularExpression(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z0-9]{2,6}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ErrorMessage = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*邮箱格式错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正则表达式&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; eMail { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 关于这几个验证方法就说到这啦，下面我们看看实际怎么用咯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.验证数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）在相应属性上添加想要的验证：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FormCheck.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User816
    {
        [StringLength(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,ErrorMessage =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*超过长度了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) ]
        [Required]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; userName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

       
        [Required(ErrorMessage &lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必填项&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [Range(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;1000000&lt;/span&gt;,ErrorMessage =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*数字大小超出范围了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; passWord { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [RegularExpression(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z0-9]{2,6}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ErrorMessage = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*邮箱格式错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正则表达式&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; eMail { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
             
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;（2）在前台页面引用User816.cs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，在HomeController中新建一个方法，取名为GetInfo(),然后添加对应的视图，然后引用User816：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454180/201809/1454180-20180904214536578-1439142607.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1454180/201809/1454180-20180904214647899-1905324416.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; (3)新建表单&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div&amp;gt;&lt;span&gt;
    @using (Html.BeginForm(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetInfoFunc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FormMethod.Post))
    {
        @Html.ValidationSummary(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;姓名&amp;lt;/label&amp;gt;&lt;span&gt;
        @Html.TextBoxFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.userName);
        @Html.ValidationMessageFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.userName)
        &lt;/span&gt;&amp;lt;br&amp;gt;
        &amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;密码&amp;lt;/label&amp;gt;&lt;span&gt;
        @Html.TextBoxFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.passWord);
        @Html.ValidationMessageFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.passWord)
        &lt;/span&gt;&amp;lt;br&amp;gt;
        &amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;邮箱&amp;lt;/label&amp;gt;&lt;span&gt;
        @Html.TextBoxFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.eMail);
        @Html.ValidationMessageFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.eMail)
        &lt;/span&gt;&amp;lt;button &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;提交&amp;lt;/button&amp;gt;&lt;span&gt;

    }
&lt;/span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 上面的代码中，实现后台校验功能的主要是这一句哦，用的时候千万记得不要搞漏了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Html.ValidationMessageFor(model =&amp;gt;&lt;span&gt; model.userName)

 @Html.ValidationMessageFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.passWord)


 @Html.ValidationMessageFor(model &lt;/span&gt;=&amp;gt; model.eMail)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 其实只需要这三步已经可以看到效果了，但是为了保证一个表单提交demo的完整性，我就再补上第四步啦，哈哈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（4）前台提交数据，后台接收&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ajax方式提交表单：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    $(function () {
        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(function () {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userName = $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; passWord = $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#passWord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eMail = $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#eMail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val();
            $.ajax({
                url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Url.Action(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;GetInfoFunc&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Home&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: {
                    userName: userName,
                    passWord: passWord,
                    eMail: eMail
                },
                success: function (data) {
                    alert(data);
                }
            });
        });
    });

&lt;/span&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后台创建控制器 GetInfoFunc()接收数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[HttpPost]
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult GetInfoFunc()
 {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; userName = Request[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; passWord = Request[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passWord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; eMail = Request[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eMail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Content(userName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + passWord + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; eMail);
 }        &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.查看结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454180/201809/1454180-20180904215503288-142782037.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里实现的效果跟我昨天写的前端js校验的方法差不多哦，而且也非常的简单呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 好了，今天就写到这里啦，好好学习，天天向上，啊哈哈哈哈哈！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我的eMail:3074596466@qq.com&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 14:03:00 +0000</pubDate>
<dc:creator>CherishTheYouth</dc:creator>
<og:description>.net 后台实现表单数据验证的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_904.html</dc:identifier>
</item>
<item>
<title>.NetCore实践爬虫系统（二）自定义规则 - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9588629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9588629.html</guid>
<description>&lt;div class=&quot;postBody&quot; readability=&quot;40.240286298569&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;52.860411899313&quot;&gt;
&lt;h3 data-source-line=&quot;1&quot; id=&quot;回顾&quot;&gt;回顾&lt;/h3&gt;

&lt;p data-source-line=&quot;2&quot;&gt;上篇文章&lt;a href=&quot;https://www.cnblogs.com/fancunwei/p/9581168.html&quot; target=&quot;_blank&quot;&gt;NetCore实践爬虫系统（一）解析网页内容&lt;/a&gt; 我们讲了利用HtmlAgilityPack，输入XPath路径，识别网页节点，获取我们需要的内容。评论中也得到了大家的一些支持与建议。下面继续我们的爬虫系统实践之路。本篇文章不包含依赖注入/数据访问/UI界面等，只包含核心的爬虫相关知识，只能作为Demo使用，抛砖引玉，共同交流。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 data-source-line=&quot;6&quot; id=&quot;抽象规则&quot;&gt;抽象规则&lt;/h3&gt;

&lt;p data-source-line=&quot;7&quot;&gt;爬虫系统之所以重要，正是他能支持各种各样的数据。要支持识别数据，第一步就是要将规则剥离出来，支持用户自定义。&lt;/p&gt;
&lt;p data-source-line=&quot;9&quot;&gt;爬虫规则，实际上是跟商品有点类似，如动态属性，但也有它特殊的地方，如规则可以循环嵌套，递归，相互引用，链接可以无限下去抓取。更复杂的，就需要自然语言识别，语义分析等领域了。&lt;/p&gt;
&lt;p data-source-line=&quot;11&quot;&gt;我用PPT画了个演示图。用于演示支持分析文章，活动，天气等各种类型的规则。&lt;/p&gt;
&lt;p data-source-line=&quot;13&quot;&gt;&lt;img data-src=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2FE7D72C75996A47DA8C9CF268225A7106%2F22991&quot; alt=&quot;PPT示意图&quot; src=&quot;https://note.youdao.com/yws/public/resource/1d2b37a48cba11c0ef16eccccfbdaaa2/xmlnote/E7D72C75996A47DA8C9CF268225A7106/22991?ynotemdtimestamp=1536068215724&quot; data-processed=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2FE7D72C75996A47DA8C9CF268225A7106%2F22991&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3 data-source-line=&quot;15&quot; id=&quot;编码实现&quot;&gt;编码实现&lt;/h3&gt;

&lt;p data-source-line=&quot;17&quot;&gt;先来定义个采集规则接口，根据规则获取单个或一批内容。&lt;/p&gt;
&lt;pre data-source-line=&quot;19&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    /// &amp;lt;summary&amp;gt;
    /// &lt;span class=&quot;zh-hans&quot;&gt;采集规则接口&lt;/span&gt;
    /// &amp;lt;/summary&amp;gt;
    public interface IDataSplider
    {
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;得到内容&lt;/span&gt;
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;rule&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        List&amp;lt;SpliderContent&amp;gt; GetByRule(SpliderRule rule);

        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;得到属性信息&lt;/span&gt;
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;node&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;rule&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        List&amp;lt;Field&amp;gt; GetFields(HtmlNode node, SpliderRule rule);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;42&quot;&gt;必不可少的规则类,用来配置XPath根路径。&lt;/p&gt;
&lt;pre data-source-line=&quot;43&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; /// &amp;lt;summary&amp;gt;
    /// &lt;span class=&quot;zh-hans&quot;&gt;采集规则&lt;/span&gt;-&lt;span class=&quot;zh-hans&quot;&gt;能满足列表页&lt;/span&gt;/&lt;span class=&quot;zh-hans&quot;&gt;详情页。&lt;/span&gt;
    /// &amp;lt;/summary&amp;gt;
    public class SpliderRule
    {
        public string Id { get; set; }

        public string Url { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;网页块&lt;/span&gt;
        /// &amp;lt;/summary&amp;gt;
        public string ContentXPath { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;支持列表式&lt;/span&gt;
        /// &amp;lt;/summary&amp;gt;
        public string EachXPath { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 
        /// &amp;lt;/summary&amp;gt;
        public List&amp;lt;RuleField&amp;gt; RuleFields { get; set; }
    }
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;67&quot;&gt;然后就是属性字段的自定义设置,这里根据内容特性，加入了正则支持。例如评论数是数字，可用正则筛选出数字。还有Attribute字段，用来获取node的Attribute信息。&lt;/p&gt;
&lt;pre data-source-line=&quot;68&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;/// &amp;lt;summary&amp;gt;
    /// &lt;span class=&quot;zh-hans&quot;&gt;自定义属性字段&lt;/span&gt;
    /// &amp;lt;/summary&amp;gt;
    public class RuleField
    {
        public string Id { get; set; }

        public string DisplayName { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;用于存储的别名&lt;/span&gt;
        /// &amp;lt;/summary&amp;gt;
        public string FieldName { get; set; }
        public string XPath { get; set; }
        public string Attribute { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;针对获取的&lt;/span&gt;HTml&lt;span class=&quot;zh-hans&quot;&gt;正则过滤&lt;/span&gt;
        /// &amp;lt;/summary&amp;gt;
        public string InnerHtmlRegex { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;针对获取的&lt;/span&gt;Text&lt;span class=&quot;zh-hans&quot;&gt;正则过滤&lt;/span&gt;
        /// &amp;lt;/summary&amp;gt;
        public string InnerTextRegex { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;是否优先取&lt;/span&gt;InnerText
        /// &amp;lt;/summary&amp;gt;
        public bool IsFirstInnerText { get; set; }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;98&quot;&gt;下面是根据文章爬虫规则的解析步骤,实现接口IDataSplider&lt;/p&gt;
&lt;pre data-source-line=&quot;99&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;/// &amp;lt;summary&amp;gt;
    /// &lt;span class=&quot;zh-hans&quot;&gt;支持列表和详情页&lt;/span&gt;
    /// &amp;lt;/summary&amp;gt;
    public class ArticleSplider : IDataSplider
    {
        /// &amp;lt;summary&amp;gt;
        /// &lt;span class=&quot;zh-hans&quot;&gt;根据&lt;/span&gt;Rule
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;rule&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public List&amp;lt;SpliderContent&amp;gt; GetByRule(SpliderRule rule)
        {
            var url = rule.Url;
            HtmlWeb web = new HtmlWeb();
            //1.&lt;span class=&quot;zh-hans&quot;&gt;支持从&lt;/span&gt;web&lt;span class=&quot;zh-hans&quot;&gt;或本地&lt;/span&gt;path&lt;span class=&quot;zh-hans&quot;&gt;加载&lt;/span&gt;html
            var htmlDoc = web.Load(url);
            var contentnode = htmlDoc.DocumentNode.SelectSingleNode(rule.ContentXPath);

            var list = new List&amp;lt;SpliderContent&amp;gt;();
            //&lt;span class=&quot;zh-hans&quot;&gt;列表页&lt;/span&gt;
            if (!string.IsNullOrWhiteSpace(rule.EachXPath))
            {
                var itemsNodes = contentnode.SelectNodes(rule.EachXPath);
                foreach (var item in itemsNodes)
                {
                    var fields = GetFields(item, rule);
                    list.Add(new SpliderContent()
                    {
                        Fields = fields,
                        SpliderRuleId = rule.Id
                    });
                }
                return list;
            }
            //&lt;span class=&quot;zh-hans&quot;&gt;详情页&lt;/span&gt;
            var cfields = GetFields(contentnode, rule);
            list.Add(new SpliderContent()
            {
                Fields = cfields,
                SpliderRuleId = rule.Id
            });
            return list;
        }

        public List&amp;lt;Field&amp;gt; GetFields(HtmlNode item, SpliderRule rule)
        {
            var fields = new List&amp;lt;Field&amp;gt;();

            foreach (var rulefield in rule.RuleFields)
            {
                var field = new Field() { DisplayName = rulefield.DisplayName, FieldName = &quot;&quot; };

                var fieldnode = item.SelectSingleNode(rulefield.XPath);
                if (fieldnode != null)
                {

                    field.InnerHtml = fieldnode.InnerHtml;
                    field.InnerText = fieldnode.InnerText;
                    field.AfterRegexHtml = !string.IsNullOrWhiteSpace(rulefield.InnerHtmlRegex) ? Regex.Replace(fieldnode.InnerHtml, rulefield.InnerHtmlRegex, &quot;&quot;) : fieldnode.InnerHtml;
                    field.AfterRegexText = !string.IsNullOrWhiteSpace(rulefield.InnerTextRegex) ? Regex.Replace(fieldnode.InnerText, rulefield.InnerTextRegex, &quot;&quot;) : fieldnode.InnerText;

                    //field.AfterRegexHtml = Regex.Replace(fieldnode.InnerHtml, rulefield.InnerHtmlRegex, &quot;&quot;);
                    //field.AfterRegexText = Regex.Replace(fieldnode.InnerText, rulefield.InnerTextRegex, &quot;&quot;);
                    if (!string.IsNullOrWhiteSpace(rulefield.Attribute))
                    {
                        field.Value = fieldnode.Attributes[rulefield.Attribute].Value;
                    }
                    else
                    {
                        field.Value = rulefield.IsFirstInnerText ? field.AfterRegexText : field.AfterRegexHtml;
                    }
                    }
                fields.Add(field);
            }
            return fields;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;178&quot;&gt;还是以博客园为例，配置内容和属性的自定义规则&lt;/p&gt;
&lt;pre data-source-line=&quot;179&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        /// &amp;lt;summary&amp;gt;
        /// 
        /// &amp;lt;/summary&amp;gt;
        public void RunArticleRule()
        {
            var postitembodyXPath = &quot;div[@class='post_item_body']//&quot;;
            var postitembodyFootXPath = postitembodyXPath+ &quot;div[@class='post_item_foot']//&quot;;
            var rule = new SpliderRule()
            {
                ContentXPath = &quot;//div[@id='post_list']&quot;,
                EachXPath = &quot;div[@class='post_item']&quot;,
                Url = &quot;https://www.cnblogs.com&quot;,
                RuleFields = new List&amp;lt;RuleField&amp;gt;() {
                         new RuleField(){ DisplayName=&quot;&lt;span class=&quot;zh-hans&quot;&gt;推荐&lt;/span&gt;&quot;, XPath=&quot;*//span[@class='diggnum']&quot;, IsFirstInnerText=true },
                         new RuleField(){ DisplayName=&quot;&lt;span class=&quot;zh-hans&quot;&gt;标题&lt;/span&gt;&quot;,XPath=postitembodyXPath+&quot;a[@class='titlelnk']&quot;, IsFirstInnerText=true },
                         new RuleField(){ DisplayName=&quot;URL&quot;,XPath=postitembodyXPath+&quot;a[@class='titlelnk']&quot;,Attribute=&quot;href&quot;, IsFirstInnerText=true },
                         new RuleField(){ DisplayName=&quot;&lt;span class=&quot;zh-hans&quot;&gt;简要&lt;/span&gt;&quot;,XPath=postitembodyXPath+&quot;p[@class='post_item_summary']&quot;, IsFirstInnerText=true },
                         new RuleField(){ DisplayName=&quot;&lt;span class=&quot;zh-hans&quot;&gt;作者&lt;/span&gt;&quot;,XPath=postitembodyFootXPath+&quot;a[@class='lightblue']&quot;, IsFirstInnerText=true },
                         new RuleField(){ DisplayName=&quot;&lt;span class=&quot;zh-hans&quot;&gt;作者&lt;/span&gt;URL&quot;,XPath=postitembodyFootXPath+&quot;a[@class='lightblue']&quot;,Attribute=&quot;href&quot;, IsFirstInnerText=true },
                         new RuleField(){ DisplayName=&quot;&lt;span class=&quot;zh-hans&quot;&gt;讨论数&lt;/span&gt;&quot;, XPath=&quot;span[@class='article_comment']&quot;,IsFirstInnerText=true, InnerTextRegex=@&quot;[^0-9]+&quot;  },
                         new RuleField(){ DisplayName=&quot;&lt;span class=&quot;zh-hans&quot;&gt;阅读数&lt;/span&gt;&quot;, XPath=postitembodyFootXPath+&quot;span[@class='article_view']&quot;,IsFirstInnerText=true, InnerTextRegex=@&quot;[^0-9]+&quot;  },
                    }
            };
            var splider = new ArticleSplider();
            var list = splider.GetByRule(rule);
            foreach (var item in list)
            {
                var msg = string.Empty;
                item.Fields.ForEach(M =&amp;gt;
                {
                    if (M.DisplayName != &quot;&lt;span class=&quot;zh-hans&quot;&gt;简要&lt;/span&gt;&quot; &amp;amp;&amp;amp; !M.DisplayName.Contains(&quot;URL&quot;))
                    {
                        msg += $&quot;{M.DisplayName}:{M.Value}&quot;;
                    }
                });
                Console.WriteLine(msg);
            }
        }
        
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 04 Sep 2018 13:35:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>回顾 上篇文章NetCore实践爬虫系统（一）解析网页内容 我们讲了利用HtmlAgilityPack，输入XPath路径，识别网页节点，获取我们需要的内容。评论中也得到了大家的一些支持与建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9588629.html</dc:identifier>
</item>
<item>
<title>设计模式六: 模板方法(Template Method) - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9588618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9588618.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;模板方法属于行为型模式的一种.&lt;/p&gt;
&lt;p&gt;实现层面上, 在抽象类中定义了算法或流程的骨架, 将其中易变的部分延迟到子类实现, 也就是允许它的子类实现其中的某些步骤.&lt;/p&gt;
&lt;p&gt;模板方法适用于算法不变, 但算法中某些步骤有变化的场景, 例如Spring中JDBC事务操作,打开连接--&amp;gt;开启事务--&amp;gt;执行sql--&amp;gt;提交事务--&amp;gt;关闭连接, 每次操作均按照这个步骤进行, 变化的是执行的sql不一样.&lt;/p&gt;
&lt;h2 id=&quot;意图&quot;&gt;意图&lt;/h2&gt;
&lt;p&gt;定义算法框架，并将一些步骤的实现延迟到子类实现。&lt;/p&gt;
&lt;h2 id=&quot;类图&quot;&gt;类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201809/794700-20180904213226413-1591044640.png&quot; alt=&quot;模板方法&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;一. 定义抽象类, 并将算法的骨架定义封装到方法,&lt;strong&gt;注意方法用final修饰,防止有人继承该类后对算法做恶意修改&lt;/strong&gt;, 不变的步骤可以实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 磨坊
 */
public abstract class MillTemplate {

    /**
     * 模板方法,定义步骤
     */
    public final void produce(){
        //准备(可能是小麦,也可能是玉米)
        prepare();
        //开机器
        start();
        //包装
        packaging();
        //运输(可能水路也可能火车)
        transport();
    }

    //准备(可能是小麦,也可能是玉米)
    protected abstract void prepare();

    private void start(){
        System.out.println(&quot;启动机器, 开始研磨...&quot;);
    }

    private void packaging(){
        System.out.println(&quot;包装...&quot;);
    }

    //运输(可能水路也可能火车)
    protected abstract void transport(); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二. 定义子类继承抽象类, 并实现抽象方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 玉米磨坊
 */
public class CoreMill extends MillTemplate {
    protected void prepare() {
        System.out.println(&quot;准备好玉米&quot;);
    }

    protected void transport() {
        System.out.println(&quot;火车运输&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 小麦磨坊
 */
public class WheatMill extends MillTemplate {

    protected void prepare() {
        System.out.println(&quot;准备好小麦&quot;);
    }

    protected void transport() {
        System.out.println(&quot;船运&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三. 调用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TemplateTest {
    public static void main(String[] args) {
        MillTemplate millTemplate = new WheatMill();
        millTemplate.produce();

        millTemplate = new CoreMill();
        millTemplate.produce();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;四. 钩子方法, 钩子方法为模板的算法提供了更大灵活性, 子类可以根据钩子方法的结果控制一些步骤执行或不执行&lt;/p&gt;
&lt;p&gt;我们在模板方法中增加钩子方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;...
/**
* 模板方法,定义步骤
*/
public final void produce(){
    //准备(可能是小麦,也可能是玉米)
    prepare();
    //开机器
    start();
    //包装
    packaging();

    //检查的钩子方法
    if(needRecheck()){
        recheck();
    }

    //运输(可能水路也可能火车)
    transport();
}
...
//钩子方法
protected boolean needRecheck(){
    return true;
}
//检查
private void recheck(){
    System.out.println(&quot;检查...&quot;);
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子类重载钩子方法已达到控制算法某一步骤是否执行的目的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//WheatMill 中增加
@Override
protected boolean needRecheck(){
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;优点: 1. 封装了不变部分, 可变部分易于扩展;2. 便于代码重用,便于维护&lt;/p&gt;
&lt;p&gt;缺点: 每个不同的实现都需要一个子类, 导致类数量增加, 系统过于庞大&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 13:33:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>简介 模板方法属于行为型模式的一种. 实现层面上, 在抽象类中定义了算法或流程的骨架, 将其中易变的部分延迟到子类实现, 也就是允许它的子类实现其中的某些步骤. 模板方法适用于算法不变, 但算法中某些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9588618.html</dc:identifier>
</item>
<item>
<title>说说前端工程与前端工程师 - kidney</title>
<link>http://www.cnblogs.com/kidney/p/9588579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kidney/p/9588579.html</guid>
<description>&lt;h3 id=&quot;id-为什么需要前端工程&quot;&gt;为什么需要前端工程&lt;/h3&gt;
&lt;p&gt;因为大规模工业化生产的需要&lt;/p&gt;

&lt;h3 id=&quot;id-前端工程的定义&quot;&gt;前端工程的定义&lt;/h3&gt;
&lt;p&gt;前端工程是一套关于如何保障开发质量与开发效率的系统方法论及其配套的技术方案体系&lt;/p&gt;

&lt;h3 id=&quot;id-前端工程的范畴&quot;&gt;前端工程的范畴&lt;/h3&gt;
&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;前端工程的核心内容是针对特定业务创造最优的技术方案组合，有的方案是用现成的，有的方案是自己造的&lt;/p&gt;
&lt;p&gt;前端工程专注于解决前端开发的质量与效率问题，但并非所有实现质量与效率的方法都属于前端工程的范畴，前端工程能解决的问题是有限的&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不应该考虑上游决策、需求与节奏是否合理，这个属于业务策略和管理的范畴，无法靠前端工程消化解决&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;影响效率的因素有很多，比如公司网速、沟通问题、工作方法、精神状态...这些也不属于前端工程的范畴&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/925891/201809/925891-20180904212454536-1388489829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;id-二、前端工程保障效率和质量的整体思路&quot;&gt;前端工程保障效率和质量的整体思路&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;质量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;人肉测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动化测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灰度测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;专项测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监控&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准化&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;技术架构标准化（核心目标是：控制复杂度）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;流程标准化（核心目标是：风控）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;供应链标准化（UI/UX 设计、接口、容器、CDN...）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;p&gt;效率&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;复用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并行&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前后端分离&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动化&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;基建/工具链&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;id-为什么需要前端工程&quot;&gt;为什么需要前端工程师&lt;/h3&gt;
&lt;p&gt;前端是终端研发精细化分工的产物。是在什么情况下分出了前端这么一个工种呢？或者说分工在什么情况下会发生？当分工能够产生帕累托改进时，分工就必然会发生。前端赖以独立的帕累托改进是什么呢？是并行。前后端并行开发总体上看是可以提高效率的，因此这种分工是合理的，也因此前端是有存在依据的，不会朝不保夕、关停并转。而且随着前端业务复杂度的增加，前端本身的知识容量足够支撑起一个专业工种。所以在可预见的未来，前端不会消失。不仅不会消失，大前端工程师会越来越受欢迎。&lt;/p&gt;

&lt;h3 id=&quot;id-标准化&quot;&gt;标准化&lt;/h3&gt;
&lt;p&gt;前端是一种中度标准化的事务。在工业开发中，由于受框架约束，一百个人产出的代码大体上套路都是一致的，但仍有上中下之分。&lt;/p&gt;
&lt;p&gt;前端有可能演变为高度标准化的事务吗？其实这不是前端的问题，而是所有职业的问题，所有干活型的职业基本的演变方向就是标准化，只有成为可随时替换的标准零件，从公司大局上看，质量才是可控的，组织才是有保障的。所以在前端工业化比较先进的公司，低阶的、面向常规业务的前端标准化程度会越来越高。&lt;/p&gt;

&lt;h3 id=&quot;id-职能&quot;&gt;职能&lt;/h3&gt;
&lt;p&gt;前端的核心职能是高效、高质量的实现业务需求。这里面有两件事：实现业务需求 &amp;amp; 质量与效率&lt;/p&gt;
&lt;p&gt;如何评价前端的职能/价值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;面向业务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向质量与效率&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;仅就前端而言最重要的是什么？就是掌握/创造前端领域所有问题的解决方案，尤其是关乎核心功能、质量与效率的解决方案，同时有所专长&lt;/p&gt;
&lt;p&gt;前端的副业是创造技术影响力，为公司吸引人才，包括写博客、技术分享以及通过开源技术方案解决更多人的问题&lt;/p&gt;
&lt;p&gt;前端需要驱动业务增长吗？绝大多数业务是没办法靠前端驱动的。所以前端是一种类职能部门，是资源消耗型的，主要负责提供服务&lt;/p&gt;

&lt;h3 id=&quot;id-什么是“好”前端&quot;&gt;什么是“好”前端&lt;/h3&gt;
&lt;p&gt;当我们说一个前端很优秀或很厉害，到底是在夸什么呢？&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;活儿全，什么都会干，不管多难，不管多变态的问题，都能解决&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;提供了一种解决普遍痛点需求（通常都是关于效率和质量的）的方案并得到广泛的认可与采纳，有较大的影响力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;除了前端，很多别的技术也操得六&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码写得好，活儿好，业界标杆&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有独立的、深度的思考，有成体系的思想，对关键问题把握得很清楚，善于发现别人看不到、想不到的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;技术视野广，对历史和现状都了解，总是能跟进各种新的解决方案，对技术的发展方向有一定判断和洞察力&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;id-局限&quot;&gt;局限&lt;/h3&gt;
&lt;p&gt;We are not responsible for profit.&lt;/p&gt;
&lt;p&gt;We are not responsible for GMV.&lt;/p&gt;
&lt;p&gt;We are not responsible for DAU.&lt;/p&gt;
&lt;p&gt;We are not responsible for anything directly related to money.&lt;/p&gt;

</description>
<pubDate>Tue, 04 Sep 2018 13:23:00 +0000</pubDate>
<dc:creator>kidney</dc:creator>
<og:description>为什么需要前端工程 因为大规模工业化生产的需要 前端工程的定义 前端工程是一套关于如何保障开发质量与开发效率的系统方法论及其配套的技术方案体系 质量：持续的满足一系列指标，能够确保整个生命周期内质量是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kidney/p/9588579.html</dc:identifier>
</item>
<item>
<title>反爬虫：利用ASP.NET MVC的Filter和缓存（入坑出坑） - 自由飞</title>
<link>http://www.cnblogs.com/freeflying/p/9588549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeflying/p/9588549.html</guid>
<description>&lt;div readability=&quot;66.915021665864&quot;&gt;
&lt;p&gt;&lt;strong&gt;背景介绍&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;为了平衡社区成员的贡献和索取，&lt;a href=&quot;http://17bang.ren/&quot; target=&quot;_blank&quot;&gt;一起帮&lt;/a&gt;引入了&lt;a href=&quot;http://17bang.ren/FAQ/Money&quot; target=&quot;_blank&quot;&gt;帮帮币&lt;/a&gt;。当用户积分（帮帮点）达到一定数额之后，就会“掉落”一定数量的“帮帮币”。为了增加趣味性，帮帮币“掉落”之后所有用户都可以“捡取”，谁先捡到归谁。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;http://17bang.ren/Images/Summary/2018/9/3/1/%E6%8D%A1%E8%B5%B7%E5%B8%AE%E5%B8%AE%E5%B8%81.png&quot; alt=&quot;&quot; data-original-title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这样就产生了一个问题，因为这个“帮帮币”是可以买卖有价值的，所以难免会有恶意用户用爬虫不断的扫描，导致这样的情况出现：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;http://17bang.ren/Images/Summary/2018/9/3/1/%E5%B8%AE%E5%B8%AE%E5%B8%81%E8%A2%AB%E7%94%A8%E6%88%B7%E6%8D%A1%E8%B5%B0.png&quot; alt=&quot;&quot; data-original-title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：经核实，&lt;a href=&quot;http://17bang.ren/User/3374&quot; target=&quot;_blank&quot;&gt;乔布斯的同学&lt;/a&gt; 其实没有用爬虫，就是手工点，点出来的！还能说什么呢？只能表示佩服啊佩服……&lt;/p&gt;
&lt;p&gt;所以我们需要一种机制，阻止这种爬虫的行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大致思路&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;这个问题我们有一个很便利的前提：只有注册用户才能够“捡起”帮帮币。所以，我们不需要通过“封IP”（需获取真实IP）这种方式来阻断爬虫爬行，而是直接封注册用户，非常方便。&lt;/p&gt;
&lt;p&gt;那么如何判断一个请求是真实用户，还是爬虫呢？我们决定使用最简单的方法：记录访问频次。当某一个用户的访问频次高于设定值时（比如：5分钟10次），就判定该用户“有爬虫嫌疑”。&lt;/p&gt;
&lt;p&gt;此外，为了防止误判（确实有用户手快），我们还应该给用户一个“解锁”的功能：通过输入验证码来确定不是爬虫。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;http://17bang.ren/Images/Summary/2018/9/4/1/%E8%A2%AB%E9%94%81%E5%AE%9A.png&quot; alt=&quot;&quot; data-original-title=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;细节设计&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;一个最核心的问题是：用什么来&lt;strong&gt;记录用户的访问频次&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;数据库？感觉没必要，这个数据又不需要长期保留，访问一次就做一次I/O操作在性能上接受不了，所以我们决定使用内存。&lt;/p&gt;
&lt;p&gt;但是，具体需要记录那些数据，又用什么样的数据结构呢？&lt;/p&gt;
&lt;p&gt;最后我们选择使用缓存，记录最简单的“用户ID -&amp;gt; 访问次数”键值对，来解决这个问题，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用缓存的自动清除（expire）特性，清除过期数据，保证记录的访问次数始终是在一定时间内的。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;缓存的读写速度很快，性能上没有压力&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，这里其实还是有那么点问题的。比如，假设缓存时间是5分钟，最多访问次数是10次。0:10，开始缓存访问次数，一直累加，到0:14，共记录访问次数7次，没有问题；然而，一过0:15，缓存被清空，0:16的时候，缓存里只有0:15到0:16这一分钟的数据，没有过去5分钟（从0:11到0:16）的数据。所以用户可以控制一直爬虫，访问9次，然后就歇着，5分钟过后，再继续访问9次，然后再歇5分钟……&lt;/p&gt;
&lt;p&gt;唉~~真这么拼，我还真没什么办法？但如果这么一个频次他能接受的话，我其实也无所谓，你就慢慢爬呗。或者，我们后台做更大的监控，把每个用户的每次访问都记录下来，进行统计，找出异常。那时候可能就真的需要数据库了（为了提高性能可以内存里放一个DataTable，定时同步到Database）。但暂时来说，没有这个必要。&lt;/p&gt;

&lt;p&gt;此外，还有一个问题，是不是只需要记录用户访问频次？&lt;/p&gt;
&lt;p&gt;如果按上述方案，在缓存里记录访问频次，通过缓存数据来判断是否允许继续访问，会有一个问题：缓存到期失效之后，这个用户就又可以自由访问目标页面了！相当于到期自动解锁。&lt;/p&gt;
&lt;p&gt;我觉得这还是不科学，如果认定是爬虫，只能是人工解锁（识别码验证）。所以在数据库用户表里添加一个“已锁定”（Locked）字段，如果用户被锁定，Update其为当前时间；未锁定时（解锁后）为NULL。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体实现&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;为了重用，我们需要利用 Authorize Fitler，在它的OnAuthorization()方法里面进行检查和记录。&lt;/p&gt;
&lt;p&gt;代码本身应该比较简单，if...else...的逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;1. 先根据数据库捡查当前用户是否被锁定
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;2. 如果被锁定，直接拦截。否则：
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;3. 在缓存中检查有无当前用户的访问次数记录
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     3.1 没有，新建一条他的缓存。否则：
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     3.2 检查该用户已访问次数
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;         3.2.1 如果已到达访问次数限制，拦截并在数据库中锁定该用户。否则
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;         3.2.2 累加用户的访问次数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

精简注释代码如下：&lt;/div&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NeedLogOn : AuthorizeAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationContext filterContext)
        {
            HttpContextBase context &lt;/span&gt;=&lt;span&gt; filterContext.HttpContext;

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;Autofac相关操作，获取正取的ISharedService实例&lt;/span&gt;
            ISharedService service = AutofacConfig.Container.Resolve&amp;lt;ISharedService&amp;gt;&lt;span&gt;();
            _NavigatorModel model &lt;/span&gt;= service.Get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从数据库获取当前User的信息&lt;/span&gt;

            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;截断式编程，减少if...else的{}嵌套&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (model.Locked.HasValue)
            {
                &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;model.Locked 来自数据库，用户已经被锁定，拦截&lt;/span&gt;
&lt;span&gt;                visitTooMuch(filterContext);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; cacheKey = CacheKey.MAX_VISIT +&lt;span&gt; model.Id;

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;非常有意思，不能直接使用int值类型，必须使用引用类型的&lt;/span&gt;
&lt;span&gt;            VisitCounter amount;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.Cache[cacheKey] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                amount &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; VisitCounter { Value = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;新建立一条Cache&lt;/span&gt;
                context.Cache.Add(cacheKey, amount, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                    DateTime.Now.AddSeconds(Config.Seconds),
                    Cache.NoSlidingExpiration, CacheItemPriority.Normal, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                amount &lt;/span&gt;= context.Cache[cacheKey] &lt;span&gt;as&lt;/span&gt;&lt;span&gt; VisitCounter;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (amount.Value &amp;gt;=&lt;span&gt; Config.MaxVisit)
                {
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;在数据库中锁定该用户&lt;/span&gt;
&lt;span&gt;                    service.LockCurrentUser();
                    BaseService.Commit();

                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;立即清除Cache&lt;/span&gt;
&lt;span&gt;                    context.Cache.Remove(cacheKey);

                    visitTooMuch(filterContext);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;不能使用：currentVisitAmount++;
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;context.Cache[cacheKey] = currentVisitAmount;
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;见：&lt;/span&gt;&lt;span&gt;https://stackoverflow.com/questions/2118067/cached-item-never-expiring&lt;/span&gt;
                    amount.Value++&lt;span&gt;;
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VisitCounter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 仔细观察代码，你会发现两个问题。这就是飞哥我曾经掉的坑啊！o(╥﹏╥)o&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;68.678085199824&quot;&gt;
&lt;p&gt;&lt;strong&gt;1、为什么要引入&lt;/strong&gt;&lt;strong&gt;VisitCounter类？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存里就存放着这个类的实例，而这个类其实就包裹一个int Value；干嘛呢，这是？为什么不直接用int呢？直接把int存到Cache里不行吗？&lt;/p&gt;
&lt;p&gt;不行啊！艹。&lt;/p&gt;
&lt;p&gt;存进去，没问题；取出来，也没问题；但更新（累加）的时候有问题啊。你怎么更新？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出缓存&lt;/span&gt;
            currentVisitAmount =&lt;span&gt; Convert.ToInt32(context.Cache[cacheKey]);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;累加&lt;/span&gt;
            currentVisitAmount++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再存进去&lt;/span&gt;
            context.Cache[cacheKey] = currentVisitAmount;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样不行的，具体的解释看这里：&lt;a href=&quot;https://stackoverflow.com/questions/2118067/cached-item-never-expiring&quot; rel=&quot;nofollow&quot;&gt;Cached item never expiring&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简单的说，context.Cache[cacheKey] = currentVisitAmount; 这一句，等于重新插入了一条永不过期的缓存。万万没想到啊！这个bug把飞哥都差点搞疯了，本来cache的调试都非常麻烦，还搞个这种幺蛾子。&lt;/p&gt;
&lt;p&gt;所以解决的办法是什么呢？在Cache里存一个引用类型值，然后不改Cache，只改引用类实例里的值就OK了。代码就不重复了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、在锁定用户的同时，清除该用户的cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里啊，曾经走了点弯路。&lt;/p&gt;
&lt;p&gt;我最开始是在解锁用户的时候清除该用户的Cache。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [NeedLogOn]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Unlock()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; userId =&lt;span&gt; getCurrentUserId();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; cacheKey = CacheKey.MAX_VISIT +&lt;span&gt; userId;
            HttpContext.Cache.Remove(cacheKey);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImageCodeModel());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

结果不知道咋回事，时灵时不灵。我把本地代码，连接服务器数据库，开着Debug模式，一步一会的进去看，OK，没问题；但把本地代码发布到服务器，duang，不行了？！没法调试，只有写log啥的，坑得我不要不要的……
&lt;p&gt;后来突然发现，这里有“坏代码的味道”：重复。你看这个cacheKey的构建，是不是在 NeedLogOn.OnAuthorization()里构建过一次？重复使用的代码是不是就应该封装？所以呢，开始呢，是想弄一个方法出来获得cacheKey，比如striing GetVisitLimitCacheKey()啥的，但这个方法要让Controller里的UnLock()和Filter里的OnAuthorization()都能调用，放在哪里呢？&lt;/p&gt;
&lt;p&gt;突然灵光一闪：为什么 Cache.Remove 要写在UnLock()里面呢？&lt;/p&gt;
&lt;p&gt;其实只要用户被锁定，他的缓存信息就没用了。因为我们已经在数据库中标明了他被Locked，所以NeedLogOn.OnAuthorization()拦截住他，不需要Cache呀！尽早的清除这个Cache，还能提高那么一点点的性能。&lt;/p&gt;
&lt;p&gt;最关键的是，这样代码更紧凑了：cacheKe在同一个方法里被使用，cache操作在同一个方法类完成，避免了代码分散耦合，优雅多了！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后的总结&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;最近“老码农”的话题比较热，至少我是这么感觉的（我这都是开第三个“老码农”的QQ群了，群号拿去：834748431）。&lt;/p&gt;
&lt;p&gt;我个人认为，老码农“没用了”“干不动了”“没公司要了”……，这些东西肯定是YY出来的。代码的质量在于它的逻辑它的内核，你怎么定义问题怎么解决问题，先有了思路然后才有实现。思路清晰了，实现才有可能优雅。至于什么“喜欢学习新技术”“没有女朋友能加班”，就有些外行了。年轻人真“喜欢”学习新技术吗？哈哈，虽然我大叔了，但也年轻过，你别骗我。问题是年轻人要想往上爬，只能学习新技术。一些需要经验积累的东西，他没法学，难道他来学管理学架构学带团队？至于加班，其实是一种陋习，我这么多QQ群，一到上班时间就热闹起来，一到周末就冷冷清清，你说他们的工作强度有多大，需要天天加班才能完成？而且稍有经验的开发人员都知道，项目的进度，一定程度之后，加人加班都是无效的。每天996，人家究竟是在写代码，还是在写bug，鬼大爷才知道！&lt;/p&gt;
当然，即使是老码农，好的代码也都是改出来的，“如切如磋，如琢如磨”，需要一个不断打磨的过程。
&lt;p&gt;“一起帮”的代码，需要打磨的地方，其实还有很多很多。但是呢，这里面有一个成本的问题。群里经常有网友吐槽他们公司的代码烂，要是早些年呢，我也会和他们一起吐槽，吐吐更健康。但现在，还是有点兔死狐悲的感觉。我就在想：哪一天，可能我的代码也会被人这样吐槽吧，哈哈……&lt;/p&gt;

&lt;p&gt;++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;最后的最后，请大家帮个小忙，我做的一个小&lt;a href=&quot;http://17bang.ren/Suggest/94?filter=&quot; target=&quot;_blank&quot;&gt;调查：你愿不愿意成为“好心人”？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;忘了给注册人和邀请码：叶飞，1786。或者&lt;a href=&quot;http://17bang.ren/Register/Home?name=%E5%8F%B6%E9%A3%9E&amp;amp;code=1786&quot; target=&quot;_blank&quot;&gt;直接点击&lt;/a&gt;注册。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/49387/201809/49387-20180904211504464-124217962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 04 Sep 2018 13:16:00 +0000</pubDate>
<dc:creator>自由飞</dc:creator>
<og:description>背景介绍： 为了平衡社区成员的贡献和索取，一起帮引入了帮帮币。当用户积分（帮帮点）达到一定数额之后，就会“掉落”一定数量的“帮帮币”。为了增加趣味性，帮帮币“掉落”之后所有用户都可以“捡取”，谁先捡到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeflying/p/9588549.html</dc:identifier>
</item>
<item>
<title>Linux编程 4 (创建文件touch，复制文件cp，tab补全，链接文件ln) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/9588242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/9588242.html</guid>
<description>&lt;h3&gt;一.创建文件&lt;/h3&gt;
&lt;p&gt;　　使用touch 可以创建空文件,例如opt目录下创建test2.txt文件。这种一般是有些程序必须要先创建文件，才能使用。&lt;br/&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904201943904-1547380384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二. 复制文件&lt;/h3&gt;
&lt;p&gt;　　2.1 使用cp命令来复制文件，需要两个参数-----源对象和目标对象。例如在opt目录下将test2.txt复制一份为test3.txt。&lt;br/&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904201855040-1845283084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.2 使用cp –R参数，可以一条命令将整个目录内容递归复制，例如将/opt目录及目录下所有文件复制到/usr下, 查看 /usr/opt 内容已全部复制过来。&lt;br/&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904201908833-415067055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　下面是删除/usr/opt目录及目录下所有文件&lt;/p&gt;
&lt;p&gt; 　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904201921184-1371544499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　2.3 也可以在cp命令中使用通配符，例如将opt目录下的以.txt结尾的文件全部复制到/usr目录下。&lt;br/&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904202023429-1564610488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　三.  制表键自动补全&lt;span&gt;　　&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　当命令字符太长，很容易输错命令。可以使用tab键自动补全。例如关机命令shutdown。可以按下shut按tab来补全,文件目录太长用法也是一样。自动补全在于要给shell足够的信息，使其与其他名字区别。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果按下tab无法补全，可以再按一下tab，将显示以输入命令开头的文件名，例如输入sh, 按一下tab没有作用，再按一下tab,将显示sh开头的所有信息。&lt;br/&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904202220605-1887266628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　四.链接文件 ln（共享文件）　　&lt;span&gt;　&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　链接文件是linux文件系统的一个优势，如需要在系统上维护同一个文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。虚拟副本叫链接。链接是目录中指向文件真实位置的点位符。分二种类型文件链接类型： 一是符号链接又叫软链接， 二是硬链接。&lt;br/&gt;　　　　4.1 符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件，这两个通过符号链接在一起的文件，彼此的内容并不相同。&lt;/p&gt;
&lt;p&gt;　　　　　　使用ln命令以及-s选项来创建符号链接，下面是在etc目录下，给my.cnf创建符号链接在本目录。&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904202337599-685889755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　如下所示：ls_my.cnf只有6字节，它只是指向my.cnf而已。&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904202434263-1955488495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　尝试随意使用vim修改某个配置个文件，都会在另一文件中修改,因为是符号链接。&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904202511642-1215577242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　链接文件为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。&lt;/p&gt;
&lt;p&gt;　　　　4.2 硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置，引用硬链接文件等同于引用了源文件。ln命令不需要加额外参数。&lt;/p&gt;
&lt;p&gt;　　　　　　使用ln命令来创建硬链接,还是使用etc下的my.cnf来演示:&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904204711376-1455044424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　上图使用了ls –li 命令显示了inode编号，列表第一列（文件的唯一标识，它用来区别同一个文件而非是文件名来区别）以及长列表。带有硬链接的文件共享inode编号。因为它们终归是同一个文件，链接计数显示2(列表中第三项),显示两个文件都有两个链接，另外它们文件大小也一模一样。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180904204957131-2027809950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　尝试随意某个配置文件，都会在另一文件中修改,因为是一个完全相同的副本. 是一个 inode 号对应多个文件名, &lt;strong&gt;硬链接就是同一个文件使用了多个别名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;p&gt;　　硬链接以下几点特性：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　文件有相同的 inode；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　只能对已存在的文件进行创建；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　不能交叉文件系统进行硬链接的创建；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　不能对目录进行创建，只可对文件创建；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　删除一个硬链接文件并不影响其他有相同 inode 号的文件；&lt;/p&gt;
&lt;p&gt;　　软链接以下几点特性：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　软链接有自己的文件属性及权限等；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　可对不存在的文件或目录创建软链接；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　软链接可交叉文件系统；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　软链接可对文件或目录创建；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　创建软链接时，链接计数 i_nlink 不会增加；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）&lt;/p&gt;

</description>
<pubDate>Tue, 04 Sep 2018 13:10:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.创建文件 使用touch 可以创建空文件,例如opt目录下创建test2.txt文件。这种一般是有些程序必须要先创建文件，才能使用。 二. 复制文件 2.1 使用cp命令来复制文件，需要两个参数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/9588242.html</dc:identifier>
</item>
</channel>
</rss>