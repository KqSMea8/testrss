<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>salesforce lightning零基础学习(八) Aura Js 浅谈一: Component篇 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/9892767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/9892767.html</guid>
<description>&lt;p&gt;我们在开发lightning的时候，常常会在controller.js中写 component.get('v.label'), component.set('v.label','xxValue');&lt;/p&gt;
&lt;p&gt;小伙伴肯定有疑问这些方法是怎么定义的，lightning到底有多少已经声明的方法可供我们使用，此篇主要讲述aura framework为我们提供的 component的js的主要方法。&lt;/p&gt;
&lt;p&gt;本人salesforce环境切换到lightning，URL为：https://zero-zhang-dev-ed.lightning.force.com。&lt;/p&gt;
&lt;p&gt;每个人的URL不同，URL 保留到force.com，然后添加一下URL: /auradocs/reference.app 即可看到aura的文档，aura文档里面给我们提供了aura framework 所有的支持的标签的描述以及使用，js的描述以及使用等等。此篇我们只是对 component的js进行说明，其他感兴趣的可以自行查看。&lt;/p&gt;
&lt;p&gt; 点击JavaScript API, 切换到 Component，可以查看到 Aura提供的所有的方法，常用的部分方法描述如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201811/910966-20181104232855614-963060668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. set (String key, Object value)：&lt;/strong&gt;此方法最为常见了，对 attribute 设置值的引用。&lt;/p&gt;
&lt;p&gt;eg: component.set(&quot;v.testAttribute&quot;,&quot;hello lightning&quot;) : 此赋值逻辑代表 对 testAttribute 这个attribute 赋值，内容为“hello lightning”; 此方法通常用于对attribute赋值，这里不多做举例；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.get(String key)：&lt;/strong&gt;此方法也是最为常见的，使用属性语法返回引用的值。通常有两种用法：&lt;/p&gt;
&lt;p&gt;　　1)component.get(&quot;v.testAttribute&quot;): 此逻辑代表获取当前component中attribute名称为testAttribute的值；&lt;/p&gt;
&lt;p&gt;　　2)componnet.get(&quot;c.testAction&quot;): 此逻辑代表获取后台apex controller中的 testAction方法，用于和后台交互操作；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.find(&lt;small class=&quot;params&quot; data-aura-rendered-by=&quot;631:1713;a&quot;&gt;&lt;span class=&quot;paramType&quot; data-aura-rendered-by=&quot;637:1713;a&quot;&gt;String &lt;span class=&quot;paramType&quot; data-aura-rendered-by=&quot;641:1713;a&quot;&gt;| &lt;span class=&quot;paramType&quot; data-aura-rendered-by=&quot;645:1713;a&quot;&gt;Object name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/small&gt;)：&lt;/strong&gt;此方法用于通过local id 获取到指定的 component。我们知道lightning每个元素都默认有一个属性:aura:id， 此属性用来标记这个组件元素的local id，理论上local id是唯一的，但是实际操作中可以不唯一，所以find这个方法返回值可以有多种形式，如果 component中针对所查的local id有不止一个，则返回一个数组来盛接，如果有一个，则直接返回当前元素，如果不存在，则直接返回undefined；&lt;/p&gt;
&lt;p&gt; eg: component.find(&quot;helloWorld&quot;): 此逻辑代表获取 component 中local id为helloWorld的组件元素，如果不存在则返回undefined；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.getLocalId():&lt;/strong&gt; 此方法用于获取组件元素的local id, 此方法通常用于通过事件获取事件的元素组件以后，获取元素组件的local id;&lt;/p&gt;
&lt;p&gt;eg: TestComponent.cmp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Global_Id&quot;&lt;/span&gt;&lt;span&gt; aura:id&lt;/span&gt;&lt;span&gt;=&quot;Local_Id&quot;&lt;/span&gt;&lt;span&gt; label&lt;/span&gt;&lt;span&gt;=&quot;Get Local Id&quot;&lt;/span&gt;&lt;span&gt; 
                      onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.getLocalId}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller.js 端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    getLocalId : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button =&lt;span&gt; event.getSource();
        console.log(button.getLocalId());
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5. getGlobalId():&lt;/strong&gt; 此方法用于获取组件元素的global id, 此方法通常用于事件获取事件元素组件以后，获取元素组件的global id;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;p&gt;将上面的方法改成 getGlobalId即可；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    getGlobalId : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button =&lt;span&gt; event.getSource();
        console.log(button.getGlobalId());
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;6.getName()：&lt;/strong&gt;此方法用来获取当前的组件元素的名称。例如上面的TestComponent.cmp， 当我们在getGlobalId 增加 console.log(component.getName());时会打印出TestComponent；&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;7.getEvent(String eventName)：&lt;/strong&gt;通过component中注册的事件名称获取事件的实例化对象；&lt;small class=&quot;params&quot; data-aura-rendered-by=&quot;810:1721;a&quot;&gt;&lt;br/&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;我们假设 component 中注册了一个事件 testEvent , 它对应了一个handler名字为 testHandler,当我们点击某个button时，会触发后台的方法,此方法用于获取到事件对象并触发此事件，执行此事件对应的handler；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
testButtonHandler : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component,event,helper) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testEvent = component.getEvent('testEvent'&lt;span&gt;);
    testEvent.setParam(&lt;/span&gt;'testEventParam','testValue'&lt;span&gt;);
    testEvent.fire();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;&lt;strong&gt;8.getReference(String key)：&lt;/strong&gt;此方法通常用于动态创建component时使用，通过属性语法返回这个值的一个实体引用。比如动态创建 button时，我们想让他的handler为controller.js中已有的一个方法testHandler作为handler，我们就可以使用 getReference('testHandler')获取到这个方法的实体引用，在$A.createComponent我们在对这个进行demo。除了可以经常用于动态创建component，我们也可以在addEventHandler进行使用，下面的函数会有此种方式的demo；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;&lt;strong&gt;9.addEventHandler (String event, function handler, String phase, Boolean includeFacets)：&lt;/strong&gt;动态的创建事件的handler，此方法有几个参数：&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;event: event的名字，这个名字需要和 aura:registerEvent名字保持一致；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;handler：针对这个事件想要动态处理的handler，此handler可以有两种方式，一种是通过 component.getReference方法使用现有的handler，另外一种是通过异步方法块去执行handler部分；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;phase：Bubble / Capture, 对这部分不了解的可以参看：&lt;a href=&quot;https://www.cnblogs.com/zero-zyq/p/9313371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zero-zyq/p/9313371.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;includeFacets：如果设置为true，则尝试捕捉通过facet生成的元素的事件；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt; 我们在&lt;a href=&quot;https://www.cnblogs.com/zero-zyq/p/9313371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zero-zyq/p/9313371.html&lt;/a&gt;有过demo测试过多层元素套用情况下事件阶段的展示，我们将eventBubblingEmitterController.js进行代码修改：使用动态创建事件handler方式进行创建，当按照事件执行排序执行到eventBubblingEmitter.component时，会执行testEventHandler方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    fireEvent : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cmp) {
        cmp.addEventHandler(&lt;/span&gt;'bubblingEvent', cmp.getReference('c.testEventHandler'&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cmpEvent = cmp.getEvent(&quot;bubblingEvent&quot;&lt;span&gt;);
        cmpEvent.fire();
    },
    testEventHandler : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cmp) {
        console.log(&lt;/span&gt;'test event handler'&lt;span&gt;);
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;执行效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201811/910966-20181114230919824-1288402218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;总结：&lt;/strong&gt;此篇只是简单的描述了Aura Framework中的Component对象常用的方法，其他的方法感兴趣的自行查看，篇中有错误的内容欢迎指出，不懂得欢迎留言。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 15:57:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>我们在开发lightning的时候，常常会在controller.js中写 component.get('v.label'), component.set('v.label</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/9892767.html</dc:identifier>
</item>
<item>
<title>muduo网络库学习笔记(四) 通过eventfd实现的事件通知机制 - 艾露米婭娜</title>
<link>http://www.cnblogs.com/ailumiyana/p/9961125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ailumiyana/p/9961125.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;上篇文章为EventLoop添加了一个定时器Fd,为EventLoop增加了3个接口：runAfter()、runAt()、runEvery()、这三个接口用于处理定时任务和周期任务. 底层通过封装TimerFd实现。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;    TimerId runAt(const TimeStamp&amp;amp; time, const NetCallBacks::TimerCallBack&amp;amp; cb);
    TimerId runAfter(double delay, const NetCallBacks::TimerCallBack&amp;amp; cb);
    TimerId runEvery(double interval, const NetCallBacks::TimerCallBack&amp;amp; cb);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;今天为EventLoop添加另一个Fd：EventFd, 用于实现线程间的事件通知机制.本文会先介绍eventfd的使用，然后给出muduo中EventLoop对eventfd的封装.&lt;/p&gt;
&lt;h2 id=&quot;eventfd的使用&quot;&gt;eventfd的使用&lt;/h2&gt;
&lt;h3 id=&quot;eventfd系统函数&quot;&gt;eventfd系统函数&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;eventfd  - 事件通知文件描述符&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;#include &amp;lt;sys/eventfd.h&amp;gt;&lt;br/&gt;int eventfd（unsigned int initval ，int flags ）;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建一个能被用户应用程序用于时间等待唤醒机制的eventfd对象.&lt;br/&gt;&lt;code&gt;initval&lt;/code&gt; :&lt;br/&gt;eventfd（）创建一个可用作事件的“eventfd对象”用户空间应用程序和内核等待/通知机制通知用户空间应用程序的事件。该对象包含一个由内核维护的无符号64位整型（uint64_t）计数器。此计数器的初始值通过initval指定。一般设0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flags&lt;/code&gt; ：&lt;br/&gt;以下标志中按位OR运算以更改eventfd()的行为，(文件中常用的这两个flags肯定都懂意思吧，就不翻译了,第三个信号量的不管它.)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   EFD_CLOEXEC (since Linux 2.6.27)
          Set the close-on-exec (FD_CLOEXEC) flag on the new file
          descriptor.  See the description of the O_CLOEXEC flag in
          open(2) for reasons why this may be useful.

   EFD_NONBLOCK (since Linux 2.6.27)
          Set the O_NONBLOCK file status flag on the new open file
          description.  Using this flag saves extra calls to fcntl(2) to
          achieve the same result.

   EFD_SEMAPHORE (since Linux 2.6.30)
          Provide semaphore-like semantics for reads from the new file
          descriptor.  See below.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;read（2）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;成功读取返回一个8byte的整数。read（2）如果提供的缓冲区的大小小于8个字节返回错误EINVAL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;write (2）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将缓冲区写入的8字节整形值加到内核计数器上。可以写入的最大值&lt;br/&gt;是计数器中是最大的无符号64位值减1（即0xfffffffffffffffe）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;On success, eventfd() returns a new eventfd file descriptor. On error, -1 is returned and errno is set to indicate the error.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用示例&quot;&gt;使用示例&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;sys/eventfd.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;thread&amp;gt;

static int s_efd = 0;

int createEventfd()
{
  int evtfd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);

  std::cout &amp;lt;&amp;lt; &quot;createEventfd() fd : &quot; &amp;lt;&amp;lt; evtfd &amp;lt;&amp;lt; std::endl;

  if (evtfd &amp;lt; 0)
  {
    std::cout &amp;lt;&amp;lt; &quot;Failed in eventfd\n&quot;;
    abort();
  }

  return evtfd;
}

void testThread()
{
  int timeout = 0;
  while(timeout &amp;lt; 3) {
    sleep(1);
    timeout++;
  }

  uint64_t one = 1;
  ssize_t n = write(s_efd, &amp;amp;one, sizeof one);
  if(n != sizeof one)
  {
    std::cout &amp;lt;&amp;lt; &quot; writes &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; bytes instead of 8\n&quot;;
  }
}

int main()
{
  s_efd = createEventfd();

  fd_set rdset;
  FD_ZERO(&amp;amp;rdset);
  FD_SET(s_efd, &amp;amp;rdset);

  struct timeval timeout;
  timeout.tv_sec = 1;
  timeout.tv_usec = 0;

  std::thread t(testThread);

  while(1)
  {
    if(select(s_efd + 1, &amp;amp;rdset, NULL, NULL, &amp;amp;timeout) == 0)
    {
      std::cout &amp;lt;&amp;lt; &quot;timeout\n&quot;;
      timeout.tv_sec = 1;
      timeout.tv_usec = 0;
      FD_SET(s_efd, &amp;amp;rdset);
        continue;
    }

    uint64_t one = 0;

    ssize_t n = read(s_efd, &amp;amp;one, sizeof one);
    if(n != sizeof one)
    {
      std::cout &amp;lt;&amp;lt; &quot; read &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; bytes instead of 8\n&quot;;
    }

    std::cout &amp;lt;&amp;lt; &quot; wakeup ！\n&quot;;

    break;
  }

  t.join();
  close(s_efd);

  return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;./test.out
createEventfd() fd : 3
timeout
timeout
timeout
 wakeup ！&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;eventfd 单纯的使用文件描述符实现的线程间的通知机制，可以很好的融入select、poll、epoll的I/O复用机制中.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;eventloop对eventfd的封装&quot;&gt;EventLoop对eventfd的封装&lt;/h2&gt;
&lt;p&gt;所增加的接口及成员:&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;    typedef std::function&amp;lt;void()&amp;gt; Functor;
    void runInLoop(const Functor&amp;amp; cb);
    void wakeup(); //是写m_wakeupFd 通知poll 处理读事件.
    void queueInLoop(const Functor&amp;amp; cb);
private:
    //used to waked up
    void handleRead();
    void doPendingFunctors();
    
    int m_wakeupFd;
    std::unique_ptr&amp;lt;Channel&amp;gt; p_wakeupChannel;
    mutable MutexLock m_mutex;
    bool m_callingPendingFunctors; /* atomic */
    std::vector&amp;lt;Functor&amp;gt; m_pendingFunctors; // @GuardedBy mutex_&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;工作时序&quot;&gt;工作时序&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(runInLoop() -&amp;gt; quueInLoop())/queueInLoop() -&amp;gt; wakeup() -&amp;gt; poll() -&amp;gt; handleRead() -&amp;gt; doPendingFunctors()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;runinloop&quot;&gt;&lt;code&gt;runInLoop()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果用户在当前IO线程调用这个函数， 回调会同步进行； 如果用户在其他线程调用runInLoop()，cb会被加入队列， IO线程会被唤醒来调用这个Functor.&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void EventLoop::runInLoop(const Functor&amp;amp;  cb)
{
  if(isInloopThread())
    cb();
  else
    queueInLoop(cb);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;queueinloop&quot;&gt;&lt;code&gt;queueInLoop()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;会将回调添加到容器，同时通过wakeup()唤醒poll()调用容器内的回调.&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void EventLoop::queueInLoop(const Functor&amp;amp; cb)
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;EventLoop::queueInLoop()&quot;;
  {
    MutexLockGuard lock(m_mutex);
    m_pendingFunctors.push_back(std::move(cb));
  }

  if(!isInloopThread())
  {
    wakeup();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部实现，&lt;/p&gt;
&lt;h3 id=&quot;wakeup&quot;&gt;&lt;code&gt;wakeup()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;写已注册到poll的eventfd 通知poll 处理读事件.&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//  m_wakeupFd(createEventfd()),
//  p_wakeupChannel(new Channel(this, m_wakeupFd)),
void EventLoop::wakeup()
{
  uint64_t one = 1;
  ssize_t n = sockets::write(m_wakeupFd, &amp;amp;one, sizeof one);
  if(n != sizeof one)
  {
    LOG_ERROR &amp;lt;&amp;lt; &quot;EventLoop::wakeup() writes &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; bytes instead of 8&quot;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;handleread&quot;&gt;&lt;code&gt;handleRead()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;poll回调读事件,处理eventfd.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void EventLoop::handleRead() //handle wakeup Fd
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;EventLoop::handleRead() handle wakeup Fd&quot;;
  uint64_t one = 1;
  ssize_t n = sockets::read(m_wakeupFd, &amp;amp;one, sizeof one);
  if(n != sizeof one)
  {
    LOG_ERROR &amp;lt;&amp;lt; &quot;EventLoop::handleRead() reads &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot;bytes instead of 8&quot;;
  }
  doPendingFunctors();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dopendingfunctors&quot;&gt;&lt;code&gt;doPendingFunctors()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;处理挂起的事件.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void EventLoop::doPendingFunctors()
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;EventLoop::doPendingFunctors()&quot;;
  std::vector&amp;lt;Functor&amp;gt; functors;
  m_callingPendingFunctors = true;

  {
    MutexLockGuard lock(m_mutex);
    functors.swap(m_pendingFunctors);
  }

  for(size_t i = 0; i &amp;lt; functors.size(); ++i)
  {
    functors[i]();
  }

  m_callingPendingFunctors = false;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了muduo中EventLoop通过 通过封装一层eventfd实现的runInLoop()函数，使得其他线程想往EventLoop所在的I/O线程注册任务成为可能.&lt;/p&gt;
&lt;p&gt;下篇文章会写Connector和Acceptor，链接器和监听器 实现第一条链接。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 15:31:00 +0000</pubDate>
<dc:creator>艾露米婭娜</dc:creator>
<og:description>muduo网络库学习笔记(四) 通过eventfd实现的事件通知机制 [TOC] 上篇文章为EventLoop添加了一个定时器Fd,为EventLoop增加了3个接口：runAfter()、runAt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ailumiyana/p/9961125.html</dc:identifier>
</item>
<item>
<title>如何通过 Scrapyd + ScrapydWeb 简单高效地部署和监控分布式爬虫项目 - my8100</title>
<link>http://www.cnblogs.com/my8100/p/scrapydweb.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/my8100/p/scrapydweb.html</guid>
<description>&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;需求分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;初级用户：
&lt;ul&gt;&lt;li&gt;只有一台开发主机&lt;/li&gt;
&lt;li&gt;能够通过 Scrapyd-client 打包和部署 Scrapy 爬虫项目，以及通过 Scrapyd JSON API 来控制爬虫，感觉&lt;strong&gt;命令行操作太麻烦&lt;/strong&gt;，希望能够通过浏览器直接部署和运行项目&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;专业用户：
&lt;ul&gt;&lt;li&gt;有 N 台云主机，通过 Scrapy-Redis 构建分布式爬虫&lt;/li&gt;
&lt;li&gt;希望集成身份认证&lt;/li&gt;
&lt;li&gt;希望在页面上直观地查看所有云主机的运行状态&lt;/li&gt;
&lt;li&gt;希望能够自由选择部分云主机，&lt;strong&gt;一键部署和运行爬虫项目，实现集群管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;希望自动执行日志分析，以及爬虫进度可视化&lt;/li&gt;
&lt;li&gt;希望在出现特定类型的异常日志时能够及时通知用户，包括自动停止当前爬虫任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;安装和配置&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;所有主机都已经安装和启动 Scrapyd&lt;/li&gt;
&lt;li&gt;开发主机或任一台主机安装 ScrapydWeb：  &lt;span class=&quot;cnblogs_code&quot;&gt;pip &lt;span&gt;install&lt;/span&gt; scrapydweb&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;运行命令  &lt;span class=&quot;cnblogs_code&quot;&gt;scrapydweb -h&lt;/span&gt; ，将在当前工作目录生成 &lt;a href=&quot;https://github.com/my8100/scrapydweb/blob/master/scrapydweb/default_settings.py&quot; target=&quot;_blank&quot;&gt;scrapydweb_settings.py&lt;/a&gt; 配置文件&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;启用 HTTP 基本认证
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ENABLE_AUTH =&lt;span&gt; True
USERNAME &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
PASSWORD &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;添加 Scrapyd server，支持字符串和元组两种配置格式，支持添加认证信息和分组/标签
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
SCRAPYD_SERVERS =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'username:password@localhost:6801#group',&lt;/span&gt;
    (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6801&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;通过运行命令  &lt;span class=&quot;cnblogs_code&quot;&gt;scrapydweb&lt;/span&gt;  启动 ScrapydWeb&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;访问 Web UI&lt;/h2&gt;
&lt;p&gt;通过浏览器访问 &lt;a href=&quot;http://127.0.0.1:5000/&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:5000&lt;/a&gt;，输入认证信息登录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Overview 页面自动输出所有 Scrapyd server 的运行状态&lt;/li&gt;
&lt;li&gt;通过分组和过滤可以自由选择若干台 Scrapyd server，调用 Scrapyd 提供的所有 JSON API，&lt;strong&gt;实现一次点击，批量执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231107879-1504449511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;部署项目&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;支持指定若干台 Scrapyd server 部署项目&lt;/li&gt;
&lt;li&gt;通过配置  &lt;span class=&quot;cnblogs_code&quot;&gt;SCRAPY_PROJECTS_DIR&lt;/span&gt;  指定 Scrapy 项目开发目录，&lt;em&gt;ScrapydWeb&lt;/em&gt; 将自动列出该路径下的所有项目，自动打包和部署指定项目&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231243157-50215385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 &lt;em&gt;ScrapydWeb&lt;/em&gt; 并非运行于当前开发主机，除了支持上传常规的 egg 文件，也可以将单个项目文件夹添加到 zip/tar/tar.gz 压缩文件后直接上传即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231322068-56497660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;运行爬虫&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过下拉框直接选择 project，version 和 spider&lt;/li&gt;
&lt;li&gt;支持传入 Scrapy settings 和 spider arguments&lt;/li&gt;
&lt;li&gt;同样支持指定若干台 Scrapyd server 运行爬虫&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231535163-575321436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;日志分析和可视化&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;ScrapydWeb&lt;/em&gt; &lt;strong&gt;默认在后台定时自动读取和分析 Scrapy log 文件并生成 Stats 页面&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231643789-1289704513.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;爬虫进度可视化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231724110-694327864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;邮件通知&lt;/h2&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;配置邮箱认证信息
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SMTP_SERVER = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SMTP_PORT &lt;/span&gt;= 465&lt;span&gt;
SMTP_OVER_SSL &lt;/span&gt;=&lt;span&gt; True
SMTP_CONNECTION_TIMEOUT &lt;/span&gt;= 10&lt;span&gt;

FROM_ADDR &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;username@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
EMAIL_PASSWORD &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TO_ADDRS &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;设置邮件工作时间和定时通知间隔，以下示例为：每隔1小时或某一任务完成时，并且当前时间是工作日的9点，12点和17点，ScrapydWeb &lt;strong&gt;&lt;strong&gt;将会发送邮件告知当前运行任务的统计信息&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
EMAIL_WORKING_DAYS = [1, 2, 3, 4, 5&lt;span&gt;]
EMAIL_WORKING_HOURS &lt;/span&gt;= [9, 12, 17&lt;span&gt;]
ON_JOB_RUNNING_INTERVAL &lt;/span&gt;= 3600&lt;span&gt;
ON_JOB_FINISHED &lt;/span&gt;= True
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;基于后台定时执行日志分析，ScrapydWeb &lt;strong&gt;提供多种 log 类型触发器及其阈值设置&lt;/strong&gt;，包括 'CRITICAL', 'ERROR', 'WARNING', 'REDIRECT', 'RETRY', 'IGNORE'等。以下示例为：当发现3条或3条以上的 critical 级别的 log 时自动停止当前任务，如果当前时间在邮件工作时间内，则同时发送通知邮件。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
LOG_CRITICAL_THRESHOLD = 3&lt;span&gt;
LOG_CRITICAL_TRIGGER_STOP &lt;/span&gt;=&lt;span&gt; True
LOG_CRITICAL_TRIGGER_FORCESTOP &lt;/span&gt;=&lt;span&gt; False
...
LOG_IGNORE_TRIGGER_FORCESTOP &lt;/span&gt;= False
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;Github 开源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/my8100/scrapydweb&quot; target=&quot;_blank&quot;&gt;my8100 / scrapydweb&lt;/a&gt; 更多实用功能正在开发中，欢迎 Star 和提交 Issue&lt;/p&gt;

</description>
<pubDate>Wed, 14 Nov 2018 15:26:00 +0000</pubDate>
<dc:creator>my8100</dc:creator>
<og:description>需求分析 初级用户： 只有一台开发主机 能够通过 Scrapyd-client 打包和部署 Scrapy 爬虫项目，以及通过 Scrapyd JSON API 来控制爬虫，感觉命令行操作太麻烦，希望能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/my8100/p/scrapydweb.html</dc:identifier>
</item>
<item>
<title>MongoDB添加仲裁节点报错replica set IDs do not match办法 - 洲渚皓月掩映</title>
<link>http://www.cnblogs.com/chou1214/p/9961094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chou1214/p/9961094.html</guid>
<description>&lt;p&gt;背景:由于历史原因，某个MongoDB副本集只有一主一从双节点，无法满足自动故障转移要求，需要配置一个仲裁节点。&lt;/p&gt;
&lt;p&gt;原有节点192.168.10.20:27017,192.168.10.21:27017，现在准备在20上配置一个新节点27018当做仲裁&lt;/p&gt;

&lt;p&gt;在当前主节点上执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
repset:PRIMARY&amp;gt; cfg={_id:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;repset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, members:[{_id:&lt;span&gt;0&lt;/span&gt;, host:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.10.20:27017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, priority:&lt;span&gt;1&lt;/span&gt;},{_id:&lt;span&gt;2&lt;/span&gt;, host:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.10.21:27017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, priority:&lt;span&gt;2&lt;/span&gt;}, {_id:&lt;span&gt;3&lt;/span&gt;, host:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.10.20:27018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, arbiterOnly:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;}]};

repset:PRIMARY&lt;/span&gt;&amp;gt; rs.reconfig(cfg)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1287962/201811/1287962-20181114230932472-798112339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示配置是成功的，接着用命令查看副本集状态时，发现仲裁节点不可用，报错信息replica set IDs do not match。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
repset:PRIMARY&amp;gt; rs.status()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1287962/201811/1287962-20181114230655757-1329131161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网上的各种文档都是说①查看副本集的名称是否一致 ②把节点上的数据全都删掉。&lt;/p&gt;
&lt;p&gt;我在确认副本集配置名称一致后，删除仲裁节点的数据时发现：1、通过客户端是无法删除副本集配置集合；2、删除底层物理文件会导致Mongod进程启动失败。&lt;/p&gt;
&lt;p&gt;在仔细回想initiate一次性副本集配置的操作时，发现配置后，只启动了一个客户端。我的猜想是会不会是因为我启动了仲裁节点的客户端，仲裁节点生成了单独的副本集ID。&lt;/p&gt;
&lt;p&gt;于是我将副本集的配置文件db、log、Mongodb.conf全都删除，并重新命令启动MongoD进程后，直接在当前Primary节点按之前的操作添加仲裁节点后，发现仲裁节点已正常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1287962/201811/1287962-20181114231923585-2138158830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;结论：目前只是证实了我的猜想，还没找到官方的说法。&lt;/p&gt;
&lt;p&gt;在添加副本集节点的时候，新增的节点在启动服务后，&lt;span&gt;一定不要连接客户端，否则新增节点会生成另外的副本集ID，虽然副本集名称一致，但是IDs不一致会报错。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Nov 2018 15:25:00 +0000</pubDate>
<dc:creator>洲渚皓月掩映</dc:creator>
<og:description>背景:由于历史原因，某个MongoDB副本集只有一主一从双节点，无法满足自动故障转移要求，需要配置一个仲裁节点。 原有节点192.168.10.20:27017,192.168.10.21:27017</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chou1214/p/9961094.html</dc:identifier>
</item>
<item>
<title>分布式电商项目（04）--商品列表查询及分页 - Cryptonym</title>
<link>http://www.cnblogs.com/Cryptonym/p/9961059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cryptonym/p/9961059.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;&lt;em&gt;前言：前面写了后天管理系统工程搭建以及框架的整合测试，今天写一下商品列表的分页查询&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;前台使用easyui的分页工具，后台则使用mybatis分页插件pagehelper&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464660/201811/1464660-20181114222350641-905453133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，打开后台首页，点击查询商品，按下F12,可以看到easyui的分页界面会向controller发送两个数据page:1,rows:30&lt;/p&gt;
&lt;p&gt;controller通过service层以及dao层查询到数据之后也需要将数据封装成easyui需要的格式，而easyui需要的数据格式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    total:&quot;2&quot;,
    rows:[
            {&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;username1&quot;},
            {&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;username2&quot;}
         ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应现在的场景就是将数据封装成total:商品总数，rows:商品信息列表的格式&lt;/p&gt;

&lt;h2&gt;2.1 封装通用的分页工具类&lt;/h2&gt;
&lt;p&gt;由于分页在后面肯定还会用到，现在在common工程下写一个easyui分页的工具类，具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EUDataGridResult {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; total;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;?&amp;gt;&lt;span&gt; rows;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getTotal() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTotal(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; total) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.total =&lt;span&gt; total;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;?&amp;gt;&lt;span&gt; getRows() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rows;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRows(List&amp;lt;?&amp;gt;&lt;span&gt; rows) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rows =&lt;span&gt; rows;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 编写接口及其实现类&lt;/h2&gt;
&lt;p&gt;在service工程下编写service类及其实现类&lt;/p&gt;
&lt;p&gt;ItemService的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ItemService {

    EUDataGridResult getItemList(Integer page, Integer rows);
   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ItemServiceImpl的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ItemServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ItemService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TbItemMapper itemMapper;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 商品列表查询
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; page
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; rows
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EUDataGridResult getItemList(Integer page, Integer rows) {
        TbItemExample example &lt;/span&gt;=  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TbItemExample();
        PageHelper.startPage(page,rows);
        List&lt;/span&gt;&amp;lt;TbItem&amp;gt; list =&lt;span&gt; itemMapper.selectByExample(example);
        EUDataGridResult result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EUDataGridResult();
        result.setRows(list);
        PageInfo&lt;/span&gt;&amp;lt;TbItem&amp;gt; info = &lt;span&gt;new&lt;/span&gt; PageInfo&amp;lt;&amp;gt;&lt;span&gt;(list);
        result.setTotal(info.getTotal());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

   

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3 编写Controller&lt;/h2&gt;
&lt;p&gt;ItemController的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.taotao.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.taotao.pojo.EUDataGridResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.taotao.pojo.TaotaoResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.taotao.pojo.TbItem;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.taotao.service.ItemService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.web.bind.annotation.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ItemController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ItemService itemService;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 商品列表查询
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; page
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; rows
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/item/list&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EUDataGridResult getItemList(Integer page, Integer rows ){
        EUDataGridResult result &lt;/span&gt;=&lt;span&gt; itemService.getItemList(page, rows);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处要注意，RequestMapping中的值一定要与jsp页面中的请求的值是一致的&lt;/p&gt;

&lt;p&gt;运行项目，点击查询商品可以查询出商品列表即为成功，即出现如下图所示的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464660/201811/1464660-20181114230510732-781033125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4 相关文件&lt;/h2&gt;
&lt;p&gt;下面提供一些相关的资源下载，包括后台管理系统的静态资源，博主使用的本地仓库等&lt;/p&gt;
&lt;p&gt;链接：https://pan.baidu.com/s/1mWDQznk0N5um_YMB7Greiw&lt;/p&gt;
&lt;p&gt;提取码：1gh3&lt;/p&gt;

</description>
<pubDate>Wed, 14 Nov 2018 15:16:00 +0000</pubDate>
<dc:creator>Cryptonym</dc:creator>
<og:description>前言：前面写了后天管理系统工程搭建以及框架的整合测试，今天写一下商品列表的分页查询 1 需求分析 前台使用easyui的分页工具，后台则使用mybatis分页插件pagehelper 如上图所示，打开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cryptonym/p/9961059.html</dc:identifier>
</item>
<item>
<title>CentOS 7 安装并配置 MySQL 5.6 - 蜗牛丨</title>
<link>http://www.cnblogs.com/alan-lin/p/9950389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alan-lin/p/9950389.html</guid>
<description>&lt;p&gt;Linux使用MySQL Yum存储库上安装MySQL 5.6，适用于Oracle Linux，Red Hat Enterprise Linux和CentOS系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、全新安装MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、添加MySQL Yum存储库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将MySQL Yum存储库添加到系统的存储库列表中。&lt;/span&gt;&lt;span&gt;这是一次性操作，可以通过安装MySQL提供的RPM来执行。&lt;/span&gt;&lt;span&gt;跟着这些步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.1、到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;MySQL官网下载MySQL Yum存储库（&lt;a class=&quot;ulink&quot; href=&quot;https://dev.mysql.com/downloads/repo/yum/&quot; target=&quot;_top&quot;&gt;https://dev.mysql.com/downloads/repo/yum/&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181114111524243-258043390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2、选择并下载适用于您的平台的发行包。将下载完成的 rpm 包上传到CentOS的机器上&lt;/p&gt;
&lt;p&gt;1.3、进入到 rpm 包所在的目录，&lt;span&gt;&lt;span&gt;使用以下命令安装下载的发行包，替换 &lt;/span&gt;&lt;/span&gt;&lt;em class=&quot;replaceable&quot;&gt;&lt;code&gt;platform-and-version-specific-package-name&lt;/code&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt; 为下载的RPM包的名称：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;token prompt&quot;&gt;&lt;span class=&quot;token command&quot;&gt;sudo yum localinstall &lt;em class=&quot;replaceable&quot;&gt;platform-and-version-specific-package-name&lt;/em&gt;&lt;span class=&quot;token punctuation&quot;&gt;.rpm&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于CentOS 6 系统，命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;token command&quot;&gt;sudo yum localinstall mysql57-community-release-el6-&lt;span class=&quot;token punctuation&quot;&gt;&lt;em class=&quot;replaceable&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{version-number&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;.noarch&lt;span class=&quot;token punctuation&quot;&gt;.rpm&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于CentOS 7 系统，命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;token command&quot;&gt;sudo yum localinstall mysql57-community-release-el7-&lt;span class=&quot;token punctuation&quot;&gt;&lt;em class=&quot;replaceable&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{version-number&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;.noarch&lt;span class=&quot;token punctuation&quot;&gt;.rpm&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装命令将MySQL Yum存储库添加到系统的存储库列表中，可以通过以下命令检查是否已成功添加MySQL Yum存储库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;token command&quot;&gt;yum repolist enabled | grep &lt;span class=&quot;token atrule&quot;&gt;&quot;mysql.*-community.*&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、选择发布版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用MySQL Yum存储库时，默认情况下会选择安装最新的GA系列（当前为MySQL 8.0）。如果这是您想要的，您可以跳到下一步，安装MySQL。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在MySQL Yum存储库中，MySQL社区服务器的不同发行版托管在不同的子存储库中。&lt;/span&gt;&lt;span&gt;默认情况下启用最新GA系列（当前为MySQL 8.0）的子存储库，默认情况下禁用所有其他系列（例如，MySQL 5.6系列）的子存储库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使下面命令查看MySQL Yum存储库中的所有子存储库，并查看启用或禁用了哪些子存储库：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;token command&quot;&gt;yum repolist all | grep mysql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果从最新的GA系列安装最新版本，无需进行配置。如果从旧的GA系列安装旧版MySQL，请先禁用新的GA系列并启用旧的GA系列子存储库。通过以下命令禁用8.0、5.7系列启用5.6系列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;token command&quot;&gt;sudo yum-config-manager &lt;span class=&quot;token property&quot;&gt;--disable mysql80-community&lt;br/&gt;&lt;span class=&quot;token command&quot;&gt;sudo yum-config-manager &lt;span class=&quot;token property&quot;&gt;--&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token command&quot;&gt;disable &lt;/span&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token property&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token property&quot;&gt;mysql57-community&lt;br/&gt;&lt;span class=&quot;token command&quot;&gt;sudo yum-config-manager &lt;span class=&quot;token property&quot;&gt;--enable mysql56-community&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再使用 &lt;span class=&quot;token command&quot;&gt;yum repolist all | grep mysql &lt;span&gt;命令查看子存储库情况&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181114114336794-1289607967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、安装MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过以下命令安装MySQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;token command&quot;&gt;sudo yum install mysql-community-server&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;这将安装MySQL server（&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;filename&quot;&gt;mysql-community-server&lt;/code&gt;&lt;span&gt;&lt;span&gt;）的包以及运行服务器所需组件的包，包括client（&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;filename&quot;&gt;mysql-community-client&lt;/code&gt;&lt;span&gt;&lt;span&gt;）的&lt;/span&gt;&lt;span&gt;包，客户&lt;/span&gt;&lt;span&gt;端和服务器的常见错误消息和字符集（&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;filename&quot;&gt;mysql-community-common&lt;/code&gt;&lt;span&gt;&lt;span&gt;）以及共享客户端库（&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;filename&quot;&gt;mysql-community-libs&lt;/code&gt;&lt;span&gt;&lt;span&gt;） 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、启动MySQL服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过以下命令安装MySQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service mysqld start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;start 启动，stop 停止，restart 重启&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、本地连接MySQL服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过以下命令安装MySQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mysql -u root -p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现 &lt;span&gt;Enter passwore: &lt;span&gt;，输入密码。由于刚安装，没有设置密码，直接回车 Enter 进入 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181114122301079-1322715150.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;span&gt;show databases &lt;span&gt;命令查看默认安装数据库&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181114122625236-1611035749.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、设置root密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依次通过以下命令修改root用户名密码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;use mysql; 
mysql&amp;gt;update user set password=password('your password') where user='root'; &lt;br/&gt;mysql&amp;gt;flush privileges;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;your password&lt;/span&gt; 为你要修改的密码&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181114145312788-1944040075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;span&gt;quit&lt;/span&gt; 命令退出当前登录，用新的密码重新登录mysql&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、设置远程登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql默认只能本机登录，通过以下命令，设置允许远程登录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;GRANT ALL PRIVILEGES ON *.* TO 'your username'@'%' IDENTIFIED BY 'your password' WITH GRANT OPTION;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;your username 和 your password 改成 mysql 数据库的用户和密码&lt;/p&gt;
&lt;p&gt;到此，在 CentOS 7上安装 MySQL 5.6 完成，CentOS 6 也是类似操作。&lt;/p&gt;
&lt;p&gt;mysql 默认3306，确保 3306 端口是通的，在要远程的电脑上安装一个mysql管理工具（sqlyog或navicat），通过 CentOS 系统的IP、端口，mysql的用户名、密码 远程连接数据库，管理数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181114152625181-526012423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181114152837374-1920368863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;远程连接成功。&lt;/p&gt;

</description>
<pubDate>Wed, 14 Nov 2018 15:05:00 +0000</pubDate>
<dc:creator>蜗牛丨</dc:creator>
<og:description>Linux使用MySQL Yum存储库上安装MySQL 5.6，适用于Oracle Linux，Red Hat Enterprise Linux和CentOS系统。 一、全新安装MySQL 1、添加M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alan-lin/p/9950389.html</dc:identifier>
</item>
<item>
<title>Linux Ubuntu系统之PPP拨号经验分享 - 文刚技术博客</title>
<link>http://www.cnblogs.com/xifarm/p/9961015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xifarm/p/9961015.html</guid>
<description>&lt;p&gt;近期，工作需要，我负责开发PPP拨号模块。&lt;br/&gt;说起拨号，算算时间，我已经做过2次了, 暴露年龄了，呵呵。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第一次是刚毕业做的PPOE拨号，给电信做拨号软件，在河北石家庄工作过一段时间，基于windows xp。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第二次是在移动网优，3G手机路测，即著名的TD-SCDMA，基于AT指令控制手机驱动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次，是用的PPPD拨号，在Linux系统下。&lt;br/&gt;pppd 拨号模块，Linux系统是自带的, 就像windows下自带的RAS拨号一样，打印机等很多应用需要通过拨号方式进行通信的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-161-generic x86_64)&lt;br/&gt;pppd 2.4.5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档，配置4个文件：&lt;/p&gt;
&lt;p&gt;/etc/ppp/peers/myvpn 账号信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;remotename myvpn
linkname myvpn 
ipparam myvpn
pty &quot;pptp *** --nolaunchpppd --loglevel 0&quot;
lock
nodeflate
name ***
usepeerdns
require-mppe
noauth
require-mppe-128
defaultroute
mtu 1416 #特别关键！！！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/etc/ppp/chap-secrets VPN用户名密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/etc/ppp/options 默认设置项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lcp-echo-failure 10 # (from /etc/ppp/options)
lcp-echo-interval 10 # (from /etc/ppp/options)
lock
crtscts
nodeflate
persist
asyncmap 0
noauth
hide-password
noipx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/etc/ppp/options.pptp 设置项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lock
noauth
refuse-pap
refuse-eap
refuse-chap
refuse-mschap
nobsdcomp
nodeflate
require-mppe-128
ipparam myvpn
defaultroute&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;个人总结的技巧：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一定要升级python3.4 --&amp;gt; python3.7?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我开始很纠结Python版本，代码开发是Python3.7最新版，而Ubuntu自带的是Python 3.4, 故想办法升级python3.7，如果在本地网速很快，这个不是什么难事，1小时工作量。&lt;/p&gt;
&lt;p&gt;但是，远程链接SSH，VPS服务器在国外，网速卡的厉害，本来1小时工作，忙乎了一个上午才搞定，升级到python3.6 + pip3 。 但是一想，我还有n个服务器呢，故晚上加班把代码降级为pyhon 3.4，这样部署就方便多了 -- 非原则问题，不要在环境上折腾太久，条条大路通罗马嘛。&lt;/p&gt;
&lt;p&gt;这个事情，给我很大的启示：不要做战略的矮子，再勤劳的执行力, 团队的效率也上不来的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平衡、成本、决策！&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;部署python程序，background job running&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;windows开发C#很多年，除了前几年做Unity3D开发的游戏APP（含VR、AR），这些都是有GUI界面的，而在Linux下，第一个门槛就是无UI界面。&lt;br/&gt;调试程序通过，部署后，我关闭ssh下班了，吃完饭，远程ssh，怎么我的python程序不见了，惊讶不已，才***行代码，而且我写的是 while true 循环，不可能自己退出啊。&lt;br/&gt;nohup python3 main.py &amp;amp;&lt;br/&gt;ps ax | grep py&lt;/p&gt;
&lt;p&gt;上网搜索，多亏google，很快就明白了，SSH通过22端口，开启了一个“session”，一般，如你执行 python3 main.py，随着SSH Session结束，Linux会kill这个process的。 而这个PPP拨号程序需要作为一个长时间运行的，故需要用 nohup 和 &amp;amp; 关键字，这样当你退出ssh，这个程序会驻留系统。&lt;/p&gt;
&lt;p&gt;那么问题来了，查询运行的process，常用的 ps all就是不灵了。&lt;/p&gt;
&lt;p&gt;要用 ps ax | grep py 才可以。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;linux常用工具工具&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[ ] vi 编辑器，linux运维必备神器！&lt;/li&gt;
&lt;li&gt;[ ] cat /var/log/syslog | grep pppd #输出mylog.log, search pppd&lt;/li&gt;
&lt;li&gt;[ ] cat /var/log/syslog | tail -n 100 #输出mylog.log 文件最后100行&lt;/li&gt;
&lt;li&gt;[ ] egrep -v '#|^ *$' /etc/ppp/options #正则，列出配置文件起作用的&lt;/li&gt;
&lt;li&gt;[ ] * &quot;&amp;gt;&quot; /var/log/syslog #clear syslog&lt;/li&gt;
&lt;li&gt;[ ] * dhclient -v -4 : refresh network #重新获得IP.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;参考文档：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/949520/wvdial-ppp0-and-setting-default-route-automatically&quot; class=&quot;uri&quot;&gt;https://superuser.com/questions/949520/wvdial-ppp0-and-setting-default-route-automatically&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/891393/vpn-pptp-in-ubuntu-16-04-not-working&quot; class=&quot;uri&quot;&gt;https://askubuntu.com/questions/891393/vpn-pptp-in-ubuntu-16-04-not-working&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/simonshi/archive/2010/04/23/1718984.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/simonshi/archive/2010/04/23/1718984.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 14 Nov 2018 15:04:00 +0000</pubDate>
<dc:creator>文刚技术博客</dc:creator>
<og:description>Linux Ubuntu系统之PPP拨号经验分享</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xifarm/p/9961015.html</dc:identifier>
</item>
<item>
<title>T-SQL基础（二）之关联查询 - 雪飞鸿</title>
<link>http://www.cnblogs.com/Cwj-XFH/p/9960822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cwj-XFH/p/9960822.html</guid>
<description>&lt;p&gt;在上篇博文中介绍了&lt;a href=&quot;https://www.cnblogs.com/Cwj-XFH/p/9898835.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;T-SQL查询的基础知识&lt;/a&gt;，本篇主要介绍稍微复杂的查询形式。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;表运算符&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;表运算符的作用是把为其提供的表作为输入，经过逻辑查询处理，返回一个表结果。SQL Server支持四个表运算符：JOIN、APPLY、PIVOT、UNPIVOT，其中JOIN是标准SQL中的运算符，APPLY、PIVOT和UNPIVOT是T-SQL的扩展。&lt;/p&gt;
&lt;p&gt;JOIN：联接查询时使用&lt;/p&gt;
&lt;p&gt;APPLY：用于FROM子句中，分为&lt;code&gt;CROSS APPLY&lt;/code&gt;和&lt;code&gt;OUTER APPLY&lt;/code&gt;两种形式&lt;/p&gt;
&lt;p&gt;PIVOT：用于行转列&lt;/p&gt;
&lt;p&gt;UNPIVOT：用于列传行&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;联接查询&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;联接查询分为外联接、内联接、交叉联接，三者的区别在于如何应用逻辑查询处理阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;交叉联接仅应用一个阶段——笛卡尔乘积；&lt;/li&gt;
&lt;li&gt;内联接应用两个阶段——笛卡尔乘积和基于谓词&lt;code&gt;ON&lt;/code&gt;的筛选；&lt;/li&gt;
&lt;li&gt;外联结应用三个极端——笛卡尔乘积，基于谓词&lt;code&gt;ON&lt;/code&gt;的筛选，添加外部行；&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;内部行 &amp;amp; 外部行&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;内部行指的是基于谓词ON与另一侧匹配的行，外部行则是未匹配的行，外部行用NULL进行填充。内联接结果集仅保留内部行，外联接结果集返回内部行和外部行。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;笛卡尔乘积&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;将一个输入表的每一行与另一个表的所有行匹配，即，&lt;em&gt;&lt;em&gt;如果一张表有m行a列，另一张表n行b列，笛卡尔乘积后得到的表有m&lt;/em&gt;n行，a+b列&lt;/em&gt;*。由此可以看出，对于数据量较大的表进行关联的话，会得到一张数据量更大的表，会有可能造成内存溢出的。&lt;/p&gt;
&lt;p&gt;以下是网络上关于笛卡尔乘积的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;21.674876847291&quot;&gt;
&lt;p&gt;在数学中，两个集合X和Y的&lt;a href=&quot;http://www.baike.com/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;笛卡儿&lt;/a&gt;积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。假设集合A=a, b，集合B=0, 1, 2，则两个集合的笛卡尔积为(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)。类似的例子有，如果A表示某学校学生的集合，B表示该学校所有课程的集合，则A与B的笛卡尔积表示所有可能的选课情况。A表示所有声母的集合，B表示所有韵母的集合，那么A和B的笛卡尔积就为所有可能的汉字全拼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UserInfo;
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;得到结果集如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1687&quot; data-height=&quot;577&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222338003-365389404.jpg&quot; alt=&quot;&quot; width=&quot;1541&quot; height=&quot;527&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;交叉联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中使用&lt;code&gt;CROSS JOIN&lt;/code&gt;语句进行交叉联接查询，在逻辑处理上，交叉联接是最为简单的联接类型，它只获取表的笛卡尔乘积。&lt;/p&gt;
&lt;p&gt;交叉联接两种写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用CROSS JOIN，推荐使用这种方式&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UAddress;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 不使用CROSS JOIN&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo,dbo.UAddress;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;内联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中使用&lt;code&gt;INNER JOIN...ON...&lt;/code&gt;语句进行内联接查询，&lt;code&gt;INNER&lt;/code&gt;关键字可选。内联接的逻辑处理分为两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成笛卡尔乘积&lt;/li&gt;
&lt;li&gt;根据谓词&lt;code&gt;ON&lt;/code&gt;对笛卡尔乘积进行筛选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与交叉联接一样，内联接有两种写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用JOIN，推荐使用这种方式&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UAddress.Id;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 不使用JOIN，与交叉联接类似，但比交叉联接多了WHERE条件&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress,dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;外联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;外联接分为左外联接：&lt;code&gt;LEFT OUT JOIN&lt;/code&gt;、右外联接：&lt;code&gt;RIGHT OUT JOIN&lt;/code&gt;和全联接：&lt;code&gt;FULL OUT JOIN&lt;/code&gt;，其中，&lt;code&gt;OUT&lt;/code&gt;关键字是可选的。相比于交叉联接和内联接，外联接则最为复杂。外联接逻辑处理分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取表的笛卡尔乘积&lt;/li&gt;
&lt;li&gt;根据谓词&lt;code&gt;ON&lt;/code&gt;对笛卡尔乘积进行筛选&lt;/li&gt;
&lt;li&gt;添加外部行数据到结果集中&lt;/li&gt;
&lt;/ol&gt;&lt;h6&gt;&lt;span&gt;&lt;strong&gt;LEFT JOIN &amp;amp; RIGHT JOIN&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;LEFT JOIN&lt;/code&gt;获取的结果集中保留了左表（LEFT JOIN左侧的表）中的所有数据，及右表中满足筛选条件的数据。右表中不满足筛选条件的空行（外部行）则用NULL值填充。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RIGHT JOIN&lt;/code&gt;与&lt;code&gt;LEFT JOIN&lt;/code&gt;作用相反。&lt;/p&gt;
&lt;p&gt;示例代码如下，表UserInfo中有4条数据，表UAddress中有三条数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UAddress.Id;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;RIGHT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查询结果如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1704&quot; data-height=&quot;317&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222428538-1396316484.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;&lt;strong&gt;FULL JOIN&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;FULL JOIN&lt;/code&gt;的结果是取&lt;code&gt;LEFT JOIN&lt;/code&gt;和&lt;code&gt;RIGHT JOIN&lt;/code&gt;查询结果集的并集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;FULL&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查询结果如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1680&quot; data-height=&quot;189&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222446651-362619890.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;ON &amp;amp; WHERE&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;前面说到：内联接结果集仅保留内部行，外联接结果集返回内部行和外部行。换句话说，外联接中&lt;code&gt;ON&lt;/code&gt;子句的作用是进行表之间关联，如果外联接需要对结果集做进一步的筛选的话不能使用&lt;code&gt;ON...AND...&lt;/code&gt;语句，而要使用&lt;code&gt;WHERE&lt;/code&gt;条件。示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 内联接使用ON...AND...筛选数据&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UI
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UA
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UA.Id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UI.UAddressId 
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取Name为xfh的数据&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; UI.Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 外联接使用ON...AND...筛选数据&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UI
&lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UA
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UA.Id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UI.UAddressId 
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取Name为xfh的数据，无效&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; UI.Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 外联接使用WHERE对结果集进行筛选&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UI
&lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UA
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UA.Id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UI.UAddressId 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; UI.Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1674&quot; data-height=&quot;479&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222501427-1054588470.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;复合联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;复合联接是指谓词涉及表中多个字段的联接，即，关联条件使用&lt;code&gt;ON...AND...&lt;/code&gt;的形式。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;自联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;同一张表的多个实例之间相互联接，称为自联接。所有基本联接类型（内联接、外联接、交叉联接）支持。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; U1 
&lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt; U2;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;自联接中要为表名指定别名，否则结果集中的列名都将不明确。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;相等联接 &amp;amp; 不等联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;当联接条件使用相等运算符时称为相等联接，否则称为不等联接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 相等联接&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;FULL&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UAddress.Id;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 不等联接&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;FULL&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;多联接查询&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;超过两张表进行关联查询即为多联接查询。通常，当SQL中出现多个表运算符时，从左到右进行逻辑处理，前一个联接的结果会作为下一个联接的左侧输入。SQL Server也常常出于优化查询的目的，在实际处理查询过程中对联接进行重新排序，但这不会影响到处理结果集的正确性。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不建议超过三张表进行关联，过多的表关联会使SQL变得复杂，难以维护且影响性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;过多的表联接会让SQL逻辑变得复杂，对查询性能产生负面影响，且难以维护。&lt;/p&gt;
&lt;p&gt;SQL（任何代码）的书写应将语义清晰作为第一追求，而不是为了“炫技”写一些别人难以理解的代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;StackOverflow&lt;/a&gt;中扣出的一张图片，可以概述外联接和内联接查询：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;600&quot; data-height=&quot;472&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222517893-698130486.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Cwj-XFH/p/9898835.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;T-SQL基础（一）之简单查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;What is the difference between “INNER JOIN” and “OUTER JOIN”?&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 14:25:00 +0000</pubDate>
<dc:creator>雪飞鸿</dc:creator>
<og:description>在上篇博文中介绍了T-SQL查询的基础知识，本篇主要介绍稍微复杂的查询形式。 表运算符 表运算符的作用是把为其提供的表作为输入，经过逻辑查询处理，返回一个表结果。SQL Server支持四个表运算符：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cwj-XFH/p/9960822.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第五章 网关篇-自定义缓存Redis - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/9960788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/9960788.html</guid>
<description>&lt;blockquote readability=&quot;6.8396946564885&quot;&gt;
&lt;p&gt;上篇文章我们介绍了2种网关配置信息更新的方法和扩展Mysql存储，本篇我们将介绍如何使用Redis来实现网关的所有缓存功能，用到的文档及源码将会在GitHub上开源，每篇的源代码我将用分支的方式管理，本篇使用的分支为&lt;code&gt;course3&lt;/code&gt;。&lt;br/&gt;附文档及源码下载地址：[&lt;strong&gt;&lt;a href=&quot;https://github.com/jinyancao/CtrAuthPlatform/tree/course3&quot; class=&quot;uri&quot;&gt;https://github.com/jinyancao/CtrAuthPlatform/tree/course3&lt;/a&gt;&lt;/strong&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网关的一个重要的功能就是缓存，可以对一些不常更新的数据进行缓存，减少后端服务开销，默认&lt;code&gt;Ocelot&lt;/code&gt;实现的缓存为本地文件进行缓存，无法达到生产环境大型应用的需求，而且不支持分布式环境部署，所以我们需要一个满足大型应用和分布式环境部署的缓存方案。&lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt;应该是当前应用最广泛的缓存数据库，支持5种存储类型，满足不同应用的实现，且支持分布式部署等特性，所以缓存我们决定使用Redis作为缓存实现。&lt;/p&gt;
&lt;p&gt;本文将介绍使用&lt;code&gt;CSRedisCore&lt;/code&gt;来实现&lt;code&gt;Redis&lt;/code&gt;相关操作，至于为什么选择&lt;code&gt;CSRedisCore&lt;/code&gt;，可参考文章&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9947905.html&quot;&gt;[.NET Core开发者的福音之玩转Redis的又一傻瓜式神器推荐]&lt;/a&gt;,里面详细的介绍了各种Redis组件比较及高级应用，并列出了不同组件的压力测试对比，另外也附&lt;code&gt;CSRedisCore作者交流QQ群：8578575&lt;/code&gt;，使用中有什么问题可以直接咨询作者本人。&lt;/p&gt;

&lt;p&gt;首先本地安装&lt;code&gt;Redis&lt;/code&gt;和管理工具&lt;a href=&quot;https://redisdesktop.com/download&quot;&gt;Redis Desktop Manager&lt;/a&gt;,本文不介绍安装过程，然后&lt;code&gt;NuGet&lt;/code&gt;安装 &lt;code&gt;CSRedisCore&lt;/code&gt;,现在开始我们重写&lt;code&gt;IOcelotCache&amp;lt;T&amp;gt;&lt;/code&gt;的实现，新建&lt;code&gt;InRedisCache.cs&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ctr.AhphOcelot.Configuration;
using Ocelot.Cache;
using System;
using System.Collections.Generic;
using System.Text;

namespace Ctr.AhphOcelot.Cache
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-14
    /// 使用Redis重写缓存
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
    public class InRedisCache&amp;lt;T&amp;gt; : IOcelotCache&amp;lt;T&amp;gt;
    {
        private readonly AhphOcelotConfiguration _options;
        public InRedisCache(AhphOcelotConfiguration options)
        {
            _options = options;
            CSRedis.CSRedisClient csredis;
            if (options.RedisConnectionStrings.Count == 1)
            {
                //普通模式
                csredis = new CSRedis.CSRedisClient(options.RedisConnectionStrings[0]);
            }
            else
            {
                //集群模式
                //实现思路：根据key.GetHashCode() % 节点总数量，确定连向的节点
                //也可以自定义规则(第一个参数设置)
                csredis = new CSRedis.CSRedisClient(null, options.RedisConnectionStrings.ToArray());
            }
            //初始化 RedisHelper
            RedisHelper.Initialization(csredis);
        }

        /// &amp;lt;summary&amp;gt;
        /// 添加缓存信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;缓存的key&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;value&quot;&amp;gt;缓存的实体&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;ttl&quot;&amp;gt;过期时间&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;缓存所属分类，可以指定分类缓存过期&amp;lt;/param&amp;gt;
        public void Add(string key, T value, TimeSpan ttl, string region)
        {
            key = GetKey(region, key);
            if (ttl.TotalMilliseconds &amp;lt;= 0)
            {
                return;
            }
            RedisHelper.Set(key, value.ToJson(), (int)ttl.TotalSeconds); 
        }

        
        public void AddAndDelete(string key, T value, TimeSpan ttl, string region)
        {
            Add(key, value, ttl, region);
        }

        /// &amp;lt;summary&amp;gt;
        /// 批量移除regin开头的所有缓存记录
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;缓存分类&amp;lt;/param&amp;gt;
        public void ClearRegion(string region)
        {
            //获取所有满足条件的key
            var data= RedisHelper.Keys(_options.RedisKeyPrefix + &quot;-&quot; + region + &quot;-*&quot;);
            //批量删除
            RedisHelper.Del(data);
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取执行的缓存信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;缓存key&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;缓存分类&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public T Get(string key, string region)
        {
            key= GetKey(region, key);
            var result = RedisHelper.Get(key);
            if (!String.IsNullOrEmpty(result))
            {
                return result.ToObject&amp;lt;T&amp;gt;();
            }
            return default(T);
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取格式化后的key
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;分类标识&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;key&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private string GetKey(string region,string key)
        {
            return _options.RedisKeyPrefix + &quot;-&quot; + region + &quot;-&quot; + key;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现所有缓存相关接口，是不是很优雅呢？实现好缓存后，我们需要把我们现实的注入到网关里，在&lt;code&gt;ServiceCollectionExtensions&lt;/code&gt;类中，修改注入方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 添加默认的注入方式，所有需要传入的参数都是用默认值
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;builder&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IOcelotBuilder AddAhphOcelot(this IOcelotBuilder builder, Action&amp;lt;AhphOcelotConfiguration&amp;gt; option)
{
    builder.Services.Configure(option);
    //配置信息
    builder.Services.AddSingleton(
        resolver =&amp;gt; resolver.GetRequiredService&amp;lt;IOptions&amp;lt;AhphOcelotConfiguration&amp;gt;&amp;gt;().Value);
    //配置文件仓储注入
    builder.Services.AddSingleton&amp;lt;IFileConfigurationRepository, SqlServerFileConfigurationRepository&amp;gt;();
    //注册后端服务
    builder.Services.AddHostedService&amp;lt;DbConfigurationPoller&amp;gt;();
    //使用Redis重写缓存
    builder.Services.AddSingleton&amp;lt;IOcelotCache&amp;lt;FileConfiguration&amp;gt;, InRedisCache&amp;lt;FileConfiguration&amp;gt;&amp;gt;();
            builder.Services.AddSingleton&amp;lt;IOcelotCache&amp;lt;CachedResponse&amp;gt;, InRedisCache&amp;lt;CachedResponse&amp;gt;&amp;gt;();
    return builder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;奈斯，我们使用&lt;code&gt;Redis&lt;/code&gt;实现缓存已经全部完成，现在开始我们在网关配置信息增加缓存来测试下，看缓存是否生效，并查看是否存储在&lt;code&gt;Redis&lt;/code&gt;里。&lt;/p&gt;
&lt;p&gt;为了验证缓存是否生效，修改测试服务&lt;code&gt;api/values/{id}&lt;/code&gt;代码，增加服务器时间输出。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpGet(&quot;{id}&quot;)]
public ActionResult&amp;lt;string&amp;gt; Get(int id)
{
    return id+&quot;-&quot;+DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加新的测试路由脚本，然后增加缓存策略,缓存60秒，缓存分类&lt;code&gt;test_ahphocelot&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;--插入路由测试信息 
insert into AhphReRoute values(1,'/ctr/values/{id}','[ &quot;GET&quot; ]','','http','/api/Values/{id}','[{&quot;Host&quot;: &quot;localhost&quot;,&quot;Port&quot;: 9000 }]',
'','','{ &quot;TtlSeconds&quot;: 60, &quot;Region&quot;: &quot;test_ahphocelot&quot; }','','','','',0,1);
--插入网关关联表
insert into dbo.AhphConfigReRoutes values(1,2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们测试访问网关地址&lt;code&gt;http://localhost:7777/api/values/1&lt;/code&gt;,过几十秒后继续访问，结果如下。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181114221938006-875126809.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出来，缓存已经生效，1分钟内请求都不会路由到服务端，再查询下redis缓存数据，发现缓存信息已经存在，然后使用&lt;code&gt;Redis Desktop Manager&lt;/code&gt;查看Redis缓存信息是否存在，奈斯，已经存在，说明已经达到我们预期目的。&lt;/p&gt;

&lt;p&gt;前面几篇已经介绍了网关的数据库存储，并介绍了网关的2种更新方式，但是如果网关集群部署时，采用接口更新方式，无法直接更新所有集群端配置数据，那如何实现集群配置信息一致呢？前面介绍了redis缓存，可以解决当前遇到的问题，我们需要重写内部配置文件提取仓储类，使用redis存储。&lt;/p&gt;
&lt;p&gt;我们首先使用&lt;code&gt;redis&lt;/code&gt;实现&lt;code&gt;IInternalConfigurationRepository&lt;/code&gt;接口，每次请求配置信息时直接从redis存储，避免单机缓存出现数据无法更新的情况。&lt;code&gt;RedisInternalConfigurationRepository&lt;/code&gt;代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ctr.AhphOcelot.Configuration;
using Ocelot.Configuration;
using Ocelot.Configuration.Repository;
using Ocelot.Responses;
using System;
using System.Collections.Generic;
using System.Text;

namespace Ctr.AhphOcelot.Cache
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-14
    /// 使用redis存储内部配置信息
    /// &amp;lt;/summary&amp;gt;
    public class RedisInternalConfigurationRepository : IInternalConfigurationRepository
    {
        private readonly AhphOcelotConfiguration _options;
        private IInternalConfiguration _internalConfiguration;
        public RedisInternalConfigurationRepository(AhphOcelotConfiguration options)
        {
            _options = options;
            CSRedis.CSRedisClient csredis;
            if (options.RedisConnectionStrings.Count == 1)
            {
                //普通模式
                csredis = new CSRedis.CSRedisClient(options.RedisConnectionStrings[0]);
            }
            else
            {
                //集群模式
                //实现思路：根据key.GetHashCode() % 节点总数量，确定连向的节点
                //也可以自定义规则(第一个参数设置)
                csredis = new CSRedis.CSRedisClient(null, options.RedisConnectionStrings.ToArray());
            }
            //初始化 RedisHelper
            RedisHelper.Initialization(csredis);
        }

        /// &amp;lt;summary&amp;gt;
        /// 设置配置信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;internalConfiguration&quot;&amp;gt;配置信息&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Response AddOrReplace(IInternalConfiguration internalConfiguration)
        {
            var key = _options.RedisKeyPrefix + &quot;-internalConfiguration&quot;;
            RedisHelper.Set(key, internalConfiguration.ToJson());
            return new OkResponse();
        }

        /// &amp;lt;summary&amp;gt;
        /// 从缓存中获取配置信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Response&amp;lt;IInternalConfiguration&amp;gt; Get()
        {
            var key = _options.RedisKeyPrefix + &quot;-internalConfiguration&quot;;
            var result = RedisHelper.Get&amp;lt;InternalConfiguration&amp;gt;(key);
            if (result!=null)
            {
                return new OkResponse&amp;lt;IInternalConfiguration&amp;gt;(result);
            }
            return new OkResponse&amp;lt;IInternalConfiguration&amp;gt;(default(InternalConfiguration));
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;redis实现后，然后在&lt;code&gt;ServiceCollectionExtensions&lt;/code&gt;里增加接口实现注入。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;builder.Services.AddSingleton&amp;lt;IInternalConfigurationRepository, RedisInternalConfigurationRepository&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后启动网关测试，可以发现网关配置信息已经使用redis缓存了，可以解决集群部署后无法同步更新问题。&lt;/p&gt;

&lt;p&gt;实际项目使用过程中，可能会遇到需要立即清除缓存数据，那如何实现从网关清除缓存数据呢？在上篇中我们介绍了接口更新网关配置的说明，缓存的更新也是使用接口的方式进行删除，详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace Ocelot.Cache
{
    [Authorize]
    [Route(&quot;outputcache&quot;)]
    public class OutputCacheController : Controller
    {
        private readonly IOcelotCache&amp;lt;CachedResponse&amp;gt; _cache;

        public OutputCacheController(IOcelotCache&amp;lt;CachedResponse&amp;gt; cache)
        {
            _cache = cache;
        }

        [HttpDelete]
        [Route(&quot;{region}&quot;)]
        public IActionResult Delete(string region)
        {
            _cache.ClearRegion(region);
            return new NoContentResult();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以先拉去授权，获取授权方式请参考上一篇，然后使用&lt;code&gt;HTTP DELETE&lt;/code&gt;方式，请求删除地址，比如删除前面的测试缓存接口，可以请求&lt;code&gt;http://localhost:7777/CtrOcelot/outputcache/test_ahphocelot&lt;/code&gt;地址进行删除，可以使用&lt;code&gt;PostMan&lt;/code&gt;进行测试，测试结果如下。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181114222005940-876664921.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行成功后可以删除指定的缓存记录，且立即生效，完美的解决了我们问题。&lt;/p&gt;

&lt;p&gt;本篇我们介绍了使用redis缓存来重写网关的所有缓存模块，并把网关配置信息也存储到redis里，来解决集群部署的问题，如果想清理缓存数据，通过网关指定的授权接口即可完成，完全具备了网关的缓存的相关模块的需求。&lt;/p&gt;
&lt;p&gt;下一篇开始我们开始介绍针对不同客户端设置不同的权限来实现自定义认证，敬请期待，后面的课程会越来越精彩，也希望大家多多支持。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 14:20:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/9960788.html</dc:identifier>
</item>
<item>
<title>Iterator和for...of - noobakong</title>
<link>http://www.cnblogs.com/noobakong/p/9960685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noobakong/p/9960685.html</guid>
<description>&lt;h2 id=&quot;什么是iterator&quot;&gt;什么是Iterator&lt;/h2&gt;
&lt;p&gt;ES6中的Map 和 Set ，再加上之前的数组和对象，这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构。这时，我们就需要一个统一的机制，来处理这几种不同的和数据结构。&lt;/p&gt;
&lt;p&gt;Iterator 遍历器就是这样一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制。&lt;/p&gt;
&lt;p&gt;其作用有下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为各种数据结构提供统一简便的访问接口&lt;/li&gt;
&lt;li&gt;使得数据结构成员能够按照某种次序排列&lt;/li&gt;
&lt;li&gt;为es6中新的遍历方法 for...of 服务&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;iterator的遍历过程&quot;&gt;Iterator的遍历过程&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建一个指针对象，指向当前数据结构的起始位置。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;遍历器的本质，就是一个指针对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一次调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，可以将指针指向数据结构的第一个成员&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二次调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，指针就指向数据结构的第二个成员&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如上不停的调用&lt;code&gt;next&lt;/code&gt; 方法，直到它指向数据结构的结束位置&lt;/p&gt;
&lt;p&gt;&lt;em&gt;学到这里突然想到了链表，哈哈哈 ~ ~&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;每一次调用&lt;code&gt;next&lt;/code&gt;方法，都会返回数据结构的当前成员的信息&lt;/strong&gt;。具体来说，就是返回一个包含&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;两个属性的对象。其中，&lt;code&gt;value&lt;/code&gt;属性是当前成员的值，&lt;code&gt;done&lt;/code&gt;属性是一个布尔值，表示遍历是否结束。&lt;/p&gt;
&lt;h2 id=&quot;手写一个-iterator接口&quot;&gt;手写一个 Iterator接口&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; const arr = [1, 2, 3]
    function iterator(arr) {
      let index = 0
      return {
        next: function () {
          return index &amp;lt; arr.length ? 
          {
            value: arr[index++], 
            done: false
          } : 
          {
            value: undefined,
            done: true
          }
        }
      }
    }
    const it = iterator(arr)
    console.log(it.next())
    console.log(it.next())
    console.log(it.next())
    console.log(it.next())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1257919906.cos.ap-guangzhou.myqcloud.com/image/notes/es6/iterator1.png&quot; alt=&quot;iterator&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;symbol.iterator属性&quot;&gt;Symbol.iterator属性&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;凡是具有Symbol.iterator属性的数据结构都自带具有Iterator 接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;原生具备 Iterator 接口的数据结构如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;Map&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;TypedArray&lt;/li&gt;
&lt;li&gt;函数的 arguments 对象&lt;/li&gt;
&lt;li&gt;NodeList 对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;拿数组为例：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1257919906.cos.ap-guangzhou.myqcloud.com/image/notes/es6/iterator1.png&quot; alt=&quot;iterator&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;给对象添加symbol.iterator属性&quot;&gt;给对象添加Symbol.iterator属性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;另外一些数据结构没有（比如对象）&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;使用for of作用于对象时：&lt;/p&gt;
&lt;p&gt;// Uncaught TypeError: obj is not iterable&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const obj = {}
console.log(obj[Symbol.iterator]) // undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;凡是具有Symbol.iterator属性的数据结构都可以被for...of 循环调用，我们可以手动的给对象添加&lt;code&gt;Symbol.iterator&lt;/code&gt; 属性&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个对象如果要具备可被&lt;code&gt;for...of&lt;/code&gt;循环调用的 Iterator 接口，就必须在&lt;code&gt;Symbol.iterator&lt;/code&gt;的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是通过遍历器实现指针结构的例子:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Obj(value) {
    this.value = value
    this.next = null
}

Obj.prototype[Symbol.iterator] = function() {
    var iterator = {next: next}
    var current = this

    function next() {
        if (current) {
            var value = current.value
            current = current.next
            return {
                value: value,
                done: false
            }
        } else {
            return {done: true}
        }
    }
    return iterator
}
var one = new Obj(1);
var two = new Obj(2);
var three = new Obj(3);

one.next = two;
two.next = three;

for (var i of one) {
    console.log(i); // 1, 2, 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;简单一点，我们可以这样实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var obj = {
    a: 1,
    b: 2,
    'me': 'akong',
    'lover': 'xwr'
}

obj[Symbol.iterator] = function () {
    let keys = Object.keys(obj)
    let len = keys.length
    let n = 0

    return {
        next: function() {
            if (n &amp;lt; len) {
                return {
                    value: keys[n++],
                    done: false
                }
            } else {
                return {
                    done: true
                }
            }
        }
    }
}

for (var attr of obj) {
    console.log(attr)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以遍历obj对象啦~！&lt;/p&gt;
&lt;h2 id=&quot;调用-iterator-接口的场合&quot;&gt;调用 Iterator 接口的场合&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数组和 Set 结构进行解构赋值时，会默认调用&lt;code&gt;Symbol.iterator&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let set = new Set().add('a').add('b').add('c');

let [x,y] = set;
// x='a'; y='b'

let [first, ...rest] = set;
// first='a'; rest=['b','c'];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）扩展运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩展运算符（...）也会调用默认的 Iterator 接口。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 例一
var str = 'hello';
[...str] //  ['h','e','l','l','o']

// 例二
let arr = ['b', 'c'];
['a', ...arr, 'd']
// ['a', 'b', 'c', 'd']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）其他场合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;for...of&lt;/li&gt;
&lt;li&gt;Array.from()&lt;/li&gt;
&lt;li&gt;Map(), Set(), WeakMap(), WeakSet()（比如&lt;code&gt;new Map([['a',1],['b',2]])&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;Promise.all()&lt;/li&gt;
&lt;li&gt;Promise.race()&lt;/li&gt;
&lt;li&gt;yield*&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 14 Nov 2018 14:00:00 +0000</pubDate>
<dc:creator>noobakong</dc:creator>
<og:description>Iterator和for...of 什么是Iterator ES6中的Map 和 Set ，再加上之前的数组和对象，这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构。这时，我们就需要一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noobakong/p/9960685.html</dc:identifier>
</item>
</channel>
</rss>