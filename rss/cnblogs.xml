<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>chrome调试工具高级不完整使用指南（基础篇） - 谢灿勇</title>
<link>http://www.cnblogs.com/st-leslie/p/8196493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/st-leslie/p/8196493.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;本文记录的是作者在工作上面对chrome的一些使用和情况的分析分享，内容仅代表个人的观点。转发请注明出处&lt;span&gt;(http://www.cnblogs.com/st-leslie/)&lt;/span&gt;,谢谢合作&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt; 由于chrome浏览器一直在不断的进行更新迭代，会不断的新增功能，有一些老的功能会被摒弃掉，所以我们介绍这个功能的时候是以这个系列文章发布时候的最新版为主（2018-01-05 ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180105234113940-907436990.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 用来选择所需要的HTML元素，通过HTML元素定位到Elements中的对应代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 用来在手机模式和电脑模式之间做切换的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3-11分别代表的就是chrome中的主要功能模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3- Elements主要用来查看最终渲染情况，CSS样式的修改和绑定事件的定位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4- Console调试台，主要是用来打印输出内容，获取报错信息，页面调试内容（仅用于对在window对象中存在的对象或者变量，函数才可以使用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5- Source源码界面，里面呈现的代码都是原文件的代码，主要的用途是用来对代码进行断点调试和代码测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6- netWork 主要是查看网络环境包括报头和返回数据等参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7- Performance 主要是用来查看JS计算性能相关的，一般如果是单纯的页面不包含canvas，大数据渲染等等的，一般是不需要使用到的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8- Memory 记录内存的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9- Application 记录本地存储的相关信息（cookie,sessionStorage,LocalStorage等）的存储信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10- 页面安全方面的信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11- 由于“中国特殊国情的问题”，需要使用FQ才可以使用，具体是用来做手机web app优化的&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 2.1 基础模块介绍说明&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里面我们会一一的讲解每个模块的大致用法，至于怎样在项目中实际使用会在最后一篇系列文章中说明。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.1.1 Elements模块&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180107011130815-376386294.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个模块中主要可以分成A,B两部分，A部分显示的是渲染出来页面的最终代码，包括JS渲染在内，B部分就是对审查节点元素的CSS，或者绑定的JS进行查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B部分各个功能分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1- 添加样式和添加类，模拟元素的hover等属性的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2- 模型最后的计算情况与应用到的样式，在上面可以很容易直观修改盒子模型的参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3- 获取选择元素的对应绑定事件的执行为之和触发的事件情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4- 断点审查情况,这个属性不常用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5- 对应选中的元素调用到JS底层的对象情况，这个属性基本没有使用&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 2.1.2 Console模块&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;下面我们对Console中常见的命令进行分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;常用的打印命令：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Console.log 用于打印普通信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Console.error 用于打印错误信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Console.warn 用于打印警示信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Console.info 同于打印提示信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180107160932190-788046627.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Console.log还有其他的一些用法，可以给console.log添加多个参数，类似的格式是这样的。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;console.log(string,CSS style string,append string,append string,…………)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 其中我们必须在console.log中的第一个参数里面加上%c，这个插入的符号表示的是第二个参数的样式作用在%c的后面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 console.log(&quot;%c这是一个测试&quot;,&quot;font-size:18px;color:red;&quot;,&quot;english &quot;,&quot;this is a test&quot;,&quot;this is param2&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180107212220628-195035237.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;其他常用的console命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;console.dir 用户输出节点对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180107213122143-1267743138.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;console.time&amp;amp;console.timeEnd 用于计算两端代码段计算的时间，主要是在用于性能计算方面的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多的console的用法&lt;a href=&quot;https://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html&quot; target=&quot;_blank&quot;&gt;详见&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt; 2.1.3 Source模块&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180107214359940-715713076.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;source模块中主要可以分成三个部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A部分主要的作用就是用来选择查看文件和添加一些测试脚本功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B部分，相当于是一个视图的功能，用来审查代码用的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C部分就是用来打印和跟踪元素&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;A-1 查看当前域名下面的文件情况，top表示的就是最顶层，下面的文件夹依次代表的是主域相同，域名不同的各个站点，再下面就是各个站点的详细的目录结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A-2 Content Scripts主要是用来查看本地浏览器上面安装的chrome插件的目录结构等情况与断点调试的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A-3 用来插入调试脚本的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C-1 表示的是运行到下一个断点，如果就只有一个断点或者不存在下一个断点的情况，那么程序直接运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C-2 运行下一句，不运行到函数的内部，相当于是F10的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C-3 运行到函数里面 相当于是F11 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C-4 跳出函数运行，相当于是F11+Ctrl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C-5 用户取消和开启全部的断点功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C-6 功能不明确，但是很少使用&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2.1.4 Application模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180107225258534-811604163.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 主要是用来通过查看存储的内容的，里面比较常用的localStorage，sessionStorage，cookies&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;具体的使用可以参照我写的文章：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/5617130.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;localStorage使用总结&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/5720460.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;cookie学习指南&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其他的内容就请自行百度，这里就不多做介绍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;基础的模块内容已经讲解完成了，因为这是一个系列的文章，所以接下来的文章如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8196493.html%20&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（优化篇）&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战一）&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战二）&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战三）&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 15:31:00 +0000</pubDate>
<dc:creator>谢灿勇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8196493.html</dc:identifier>
</item>
<item>
<title>可参考的才是有价值的：中小型研发团队架构落地实践18篇，含案例、代码 - arch-system</title>
<link>http://www.cnblogs.com/dotnet-arch-system/p/8232744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-arch-system/p/8232744.html</guid>
<description>[unable to retrieve full-text content]社区里不是缺少架构图，而是缺少确实可参考的架构落地实践。大公司的架构看上去总是不明觉厉，但真要借鉴时却往往无从下手。也许，中小型研发团队的架构实践才是可供复制的？本文是张辉清专栏——《中小研发团队架构实践》的开篇之作，本系列将有 18 篇诚意之作，以飨读者。 一、写在前面 中小型研发团队很多，而社区</description>
<pubDate>Sun, 07 Jan 2018 15:01:00 +0000</pubDate>
<dc:creator>arch-system</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8196493.html</dc:identifier>
</item>
<item>
<title>K：二叉树的非递归遍历 - 林学徒</title>
<link>http://www.cnblogs.com/MyStringIsNotNull/p/8232728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MyStringIsNotNull/p/8232728.html</guid>
<description>&lt;h3 id=&quot;相关介绍&quot;&gt;&lt;strong&gt;&lt;em&gt;相关介绍:&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 二叉树的三种遍历方式(先序遍历，中序遍历，后序遍历)的非递归实现，虽然递归方式的实现较为简单且易于理解，但是由于递归方式的实现受其递归调用栈的深度的限制，当递归调用的深度超过限制的时候，会出现抛出异常的情况。为此，通过显示的使用栈的方式来实现二叉树遍历的非递归方式，其在使用上会更加的灵活。&lt;/p&gt;
&lt;p&gt;运用下图对二叉树的三种遍历方式进行介绍:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180107224816378-1151879066.png&quot; alt=&quot;二叉树的例子&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;后序遍历&quot;&gt;&lt;strong&gt;&lt;em&gt;后序遍历:&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 所谓的后序遍历是指对一棵二叉树按照左子树，右子树，根节点的顺序递归的在一棵二叉树的左右子树中访问相关节点的方式。如图1.1所示的一棵二叉树，其后序遍历的结果为DEBCA&lt;/p&gt;
&lt;p&gt; 实现非递归方式的后序遍历，有两种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;第一种:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 使用两个栈来进行实现。注意到，后序遍历可以看做以下遍历过程的逆过程：先遍历某个节点，然后遍历其右孩子节点，再遍历其左孩子节点，该过程的逆过程，即为后序遍历的遍历过程。如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180107224939221-324750467.png&quot; alt=&quot;后序遍历逆过程示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为此，我们可以按照如下的算法得到二叉树的后序遍历结果:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化两个栈，一个用于保存中间遍历过程称为栈s，一个用于保存最终的结果称为栈output&lt;/li&gt;
&lt;li&gt;push根节点到第一个栈s中&lt;/li&gt;
&lt;li&gt;从第一个栈s中pop出一节点，并将其push到第二个栈output中&lt;/li&gt;
&lt;li&gt;将第一个栈s中pop出的节点的孩子节点，按左孩子，右孩子的顺序push到第一个栈s中&lt;/li&gt;
&lt;li&gt;重复步骤3和4直到栈s为空&lt;/li&gt;
&lt;li&gt;栈s为空时，所有节点都已push到栈output中，且按后序遍历顺序存放，依次将栈output的节点pop出并进行访问，即为二叉树后序遍历的结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以图1.1为例，其过程如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180107224904596-1771703354.png&quot; alt=&quot;两个栈的后序遍历过程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;示例代码如下：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于实现二叉树的非递归方式的后序遍历，方式1
 * @param root 二叉树的根节点
 */
public void PostRootTraverse(BinaryTreeNode root)
{
    BinaryTreeNode T=root;
    Stack s=new Stack();
    Stack output=new Stack();
    s.push(root);
    //用于执行压入栈的过程
    while(!s.isEmpty())
    {
        T=s.pop();
        output.push(T);
        if(T.leftChild!=null)
            s.push(T.leftChild);
        if(T.rightChild!=null)
            s.push(T.rightChild);
    }
    //用于执行对遍历结果的每个节点的访问过程
    while(!output.isEmpty())
    {
        System.out.println(((BinaryTreeNode)output.pop()).data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;第二种:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 使用一个栈来进行实现，在搜索遍历的过程中，从二叉树的根节点出发，沿着该节点的左子树向下搜索，在搜索的过程中每遇到一个节点判断该节点是否是第一次经过，若是，则不立即访问，而是将该节点入栈保存，遍历该节点的左子树。当左子树遍历完毕后再返回该节点，这时还不能立即访问该节点，而是应当继续进入该节点的右子树进行遍历，当左右子树均遍历完毕后，才能从栈顶弹出该节点并访问它。由于在决定栈顶节点是否能访问时，需要知道该节点的右子树是否已经被遍历完毕。因此，为解决这个问题，在算法中还应当引入一个布尔型的访问标志变量flag和一个节点指针p。其中flag用来标志当前栈顶节点是否被访问过，当值为true的时候，表示栈顶节点已被访问过，当值为false的时候，表示当前栈顶节点未被访问过，指针p指向当前遍历过程中最后一个访问的节点。若当前栈顶节点的右孩子节点是空，或者就是p指向的节点，则表明当前节点的右子树已遍历完毕，此时就可以访问当前栈顶节点。其操作的实现过程描述如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个栈对象，根节点进栈，p赋初始化值为null&lt;/li&gt;
&lt;li&gt;若栈非空，则栈顶节点的非空左孩子相继进栈&lt;/li&gt;
&lt;li&gt;若栈非空，查看栈顶节点，若栈顶节点的右孩子为空，或者与p相等，则将栈顶节点弹出栈并访问它，同时使p指向该节点，并置flag为true，否则，将栈顶节点的右孩子压入栈，并置flag的值为false&lt;/li&gt;
&lt;li&gt;若flag值为true，则重复执行步骤3。否则，重复执行步骤2和3，直到栈为空为止。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;示例代码如下:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package queueandstack;
import java.util.Stack;
/**
 * 用于演示二叉树的遍历的三种方式的代码
 * @author 学徒
 *
 */
public class AroundTree
{
    /**
     * 用于实现二叉树的非递归方式的后序遍历，方式2
     * @param root 二叉树的根节点
     */
    public void PostRootTraverse(BinaryTreeNode root)
    {
        BinaryTreeNode T=root;
        if(T!=null)
        {
            Stack s=new Stack();
            s.push(T);//根节点进栈
            boolean flag;//访问标记
            BinaryTreeNode p=null;//p指向刚被访问的节点
            while(!s.isEmpty())
            {
                while(s.peek()!=null)//将栈顶节点的左孩子相继入栈
                {
                    s.push(((BinaryTreeNode)s.peek()).leftChild);
                }
                s.pop();//空节点退栈
            }
            while(!s.isEmpty())
            {
                T=(BinaryTreeNode)s.peek();//查看栈顶元素
                if(T.rightChild==null||T.rightChild==p)
                {
                    System.out.println(T.data);//访问节点
                    s.pop();//移除栈顶元素
                    p=T;//p指向刚被访问过的节点
                    flag=true;//设置访问标记
                }
                else
                {
                    s.push(T.rightChild);//右孩子节点入栈
                    flag=false;//设置未被访问标记
                }
                if(!flag)
                    break;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;先序遍历&quot;&gt;&lt;strong&gt;&lt;em&gt;先序遍历:&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 所谓的先序遍历，是指对一棵二叉树按照根节点，左子树，右子树的顺序递归的在一棵二叉树中的左右子树中访问相关节点的方式。如图1.1所示的一棵二叉树，其先序遍历的结果是ABDEC&lt;/p&gt;
&lt;p&gt; 实现非递归方式的先序遍历，有两种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;第一种:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 注意到，先序遍历的过程为“根左右”，后序遍历的过程为“左右根”，其后序遍历的逆过程为“根右左”，其后序遍历过程可以采用两个栈形式来进行实现，实现的过程中，第一个栈存放当前节点的左孩子节点和右孩子节点，而其得到的出栈结果为“根右左”，为此，我们只需要将入第一个栈的节点顺序调换以下(即先入右节点，再入左节点)即可得到“根左右”的出栈顺序，其具体步骤如下描述:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化一个栈和一个队列&lt;/li&gt;
&lt;li&gt;push根节点入栈&lt;/li&gt;
&lt;li&gt;从该栈中pop出其一节点，并将该节点加入到队列中&lt;/li&gt;
&lt;li&gt;将该栈中pop出的节点的孩子节点，按照右孩子和左孩子的顺序push到该栈中&lt;/li&gt;
&lt;li&gt;重复步骤2和步骤3直至栈为空&lt;/li&gt;
&lt;li&gt;完成之后，所有的节点都push到该队列中，且按先序遍历的方式顺序存放，直接pop出队列中的节点，即为二叉树的先序遍历结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以图1.1为例，其过程如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180107225120768-677067505.png&quot; alt=&quot;一个栈的先序遍历的过程示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;示意代码如下:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于实现二叉树的非递归方式的先序遍历，方式1
 * @param root 二叉树的根节点
 */
public void PreRootTraverse(BinaryTreeNode root)
{
    BinaryTreeNode T=root;
    Stack s=new Stack();
    Queue q=new LinkedList();
    s.push(root);
    while(!s.isEmpty())
    {
        T=s.pop();
        q.push(T);
        if(T.rightChild!=null)
            s.push(T.rightChild);
        if(T.leftChild!=null)
            s.push(T.leftChild);
    }
    //用于得到先序遍历的结果
    while(!q.isEmpty())
    {
        System.out.println(((BinaryTreeNode)q.pop()).data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;第二种:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 借助一个栈来记载当前被访问节点的右孩子节点，以便在遍历完一个节点的左子树后，能够顺利的进入这个节点的右子树进行遍历。从二叉树的根节点出发，沿着该节点的左子树向下搜索，在搜索过程中遇到一个节点就先访问该节点，并将该节点的非空右孩子节点压入栈中，当左子树访问完成之后,从栈顶弹出一个节点的右孩子节点，然后用上述同样的方法去遍历该节点的右子树，以此类推，直至二叉树中的所有节点都被访问了为止。其过程描述如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个栈对象，根节点入栈&lt;/li&gt;
&lt;li&gt;当栈为非空时，将栈顶节点弹出栈内并访问该节点&lt;/li&gt;
&lt;li&gt;对当前访问节点的非空左孩子节点相继依次访问，并将当前访问节点的非空右孩子节点压入栈内&lt;/li&gt;
&lt;li&gt;重复执行步骤2和3，直到栈为空为止&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;示例代码如下:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package queueandstack;
import java.util.Stack;
/**
 * 用于演示二叉树的遍历的三种方式的代码
 * @author 学徒
 *
 */
public class AroundTree
{
    /**
     * 用于实现二叉树的非递归方式的先序遍历，方式2
     * @param root 二叉树的根节点
     */
    public void PreRootTraverse(BinaryTreeNode root)
    {
        BinaryTreeNode T=root;
        if(T!=null)
        {
            Stack s=new Stack();
            s.push(T);//根节点入栈
            while(!s.isEmpty())
            {
                T=(BinaryTreeNode)s.pop();//移除栈顶节点，并返回其值
                System.out.println(T.data);//访问节点
                while(T!=null)
                {
                    if(T.leftChild!=null)//访问左孩子节点
                        System.out.println(T.leftChild.data);//访问节点
                    if(T.rightChild!=null)//右孩子非空入栈
                        s.push(T.rightChild);
                    T=T.leftChild;
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;中序遍历&quot;&gt;&lt;strong&gt;&lt;em&gt;中序遍历:&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 所谓的中序遍历是指对一棵二叉树按照左子树，根节点，右子树的顺序递归的在一棵二叉树的左右子树中访问相关节点的方式。如图1.1所示的一棵二叉树，其中序遍历的结果为DBEAC。&lt;/p&gt;
&lt;p&gt; 进行中序遍历可以借助一个栈来记载遍历过程中所经历的而未被访问过的所有节点，以便遍历完一个节点左子树后能顺利返回到它的父节点。实现中根遍历操作的非递归算法的主要思想是:从二叉树的根节点出发，沿着该节点的左子树向下搜索，在搜索过程中将所遇到的每一个节点依次压栈，直到二叉树中最坐下的的节点压栈为止，然后从栈中弹出栈顶节点并对其进行访问，访问完后再进入该节点的右子树并用上述的同样的方法去遍历该节点的右子树，以此类推，直到二叉树中的所有节点都被访问为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;示例代码如下:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package queueandstack;
import java.util.Stack;
/**
 * 用于演示二叉树的遍历的三种方式的代码
 * @author 学徒
 *
 */
public class AroundTree
{
    /**
     * 用于实现二叉树的非递归方式的中序遍历
     * @param root 二叉树的根节点
     */
    public void PreRootTraverse(BinaryTreeNode root)
    {
        BinaryTreeNode T=root;
        if(T!=null)
        {
            Stack s=new Stack();
            s.push(T);
            while(!s.isEmpty())
            {
                while(s.peek()!=null)//将栈顶节点的左孩子节点相继入栈
                    s.push(((BinaryTreeNode)s.peek()).leftChild);
                s.pop();//空节点退栈
                //在遍历节点时，将该节点对应的右孩子节点压入栈中
                if(!s.isEmpty())
                {
                    T=(BinaryTreeNode)s.pop();//得到未访问的栈顶节点，并返回其值
                    System.out.println(T.data);
                    s.push(T.rightChild);//节点的右孩子入栈
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/MyStringIsNotNull/p/7913174.html&quot;&gt;回到目录|·(工)·）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 14:53:00 +0000</pubDate>
<dc:creator>林学徒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MyStringIsNotNull/p/8232728.html</dc:identifier>
</item>
<item>
<title>豹哥嵌入式讲堂：ARM开发之文件详解（3）- project文件 - Jay豹哥</title>
<link>http://www.cnblogs.com/henjay724/p/8232585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/8232585.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是豹哥，猎豹的豹，犀利哥的哥。今天豹哥给大家讲的是&lt;strong&gt;嵌入式开发里的project文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　前面两节课里，豹哥分别给大家介绍了嵌入式开发中的两种典型input文件：&lt;a href=&quot;http://www.cnblogs.com/henjay724/p/8183257.html&quot;&gt;source文件&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/henjay724/p/8191908.html&quot;&gt;linker文件&lt;/a&gt;。豹哥要再次提问了，还有没有input文件呢?答案确实是有，但这次真的是有且仅有了，本文要介绍的主角project文件也属于半个input文件。为什么说是半个?因为project文件不仅包含开发者指定的input信息，还包含很多其他辅助调试的input/output信息，算是嵌入式开发中承前启后的文件。而本文侧重点在于project文件中与开发者应用相关的input信息，仅当得到了这些input信息，再加上前面介绍的source和linker文件，那么你就已经得到了application所有的信息，你可以用它们来可以生成无歧义的可执行image binary。&lt;br/&gt;　　随着嵌入式软件工程的发展，为了应对日益复杂的需求，现代IDE的功能也越来越强大了，IDE版本更迭让人应接不暇，Keil MDK已然踏入5.0时代，IAR EWARM更是进入了8.0时代，IDE各有千秋，但本文要讲的内容却是每个IDE必须具有的基本功能，还是继续以IAR EWARM为例开始今天的内容：&lt;/p&gt;
&lt;h3 id=&quot;一标准ide功能&quot;&gt;一、标准IDE功能&lt;/h3&gt;
&lt;p&gt;　　在开始今天的主题之前，豹哥觉得有必要先简要给大家科普一下标准IDE应该具有的功能。现代IDE基本都是由组件构成，嵌入式开发中的每个阶段都对应着相应的组件，由这些组件去实现各阶段的需求。&lt;/p&gt;
&lt;h4 id=&quot;ide组件&quot;&gt;1.1 IDE组件&lt;/h4&gt;
&lt;p&gt;　　标准嵌入式开发应该至少包括以下6个阶段，而IAR里对于每个阶段都有1个或多个组件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;输入（IAR Editor）：编辑源文件代码。&lt;/li&gt;
&lt;li&gt;编译（ICCARM、IASMARM）：编译源文件代码生成可执行二进制机器码。&lt;/li&gt;
&lt;li&gt;分析（C-STAT、MISRA-C）：编译过程中检查代码中潜在的问题。&lt;/li&gt;
&lt;li&gt;链接（ILINK）：链接可执行二进制机器码到指定ARM存储空间地址。&lt;/li&gt;
&lt;li&gt;下载（I-jet、flashloader）：将链接好的可执行二进制机器码下载进芯片内部非易失性存储器。&lt;/li&gt;
&lt;li&gt;调试（C-SPY、C-RUN）：在线调试代码在芯片中执行情况。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　project文件主要用来记录整合上述6个阶段的所有开发需求。&lt;/p&gt;
&lt;h4 id=&quot;ide文件类型&quot;&gt;1.2 IDE文件类型&lt;/h4&gt;
&lt;p&gt;　　既然IDE有很多组件，那么同时也会存在不同类型的文件以存储这些组件的所需要的信息。IAR里支持的文件扩展类型非常多，豹哥在这里仅列举你所创建的工程根目录下的与工程同名的扩展文件，相信你一定会觉得眼熟。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;Ext:             Type of file:
.eww             Workspace file
.ewp             IAR Embedded Workbench project
.ewd             Project settings &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; C-SPY
.ewt             Project settings &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; C-STAT and C-RUN
.dep             Dependency information&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本文要讲的内容都包含在.ewp文件里，ewp文件记录了开发者为应用指定的不可缺少的input信息，没有这些信息，application工程是不完整的。换句话说，如果你得到了application的所有source文件和linker文件，但没有ewp文件的话，可能导致最终生成的image binary文件是不同的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Note：更多IAR支持的扩展文件类型请查阅IAR软件安装目录下\IAR Systems\Embedded Workbench xxx\arm\doc\EWARM_IDEGuide.ENU.pdf文档里的File types一节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二解析projectewp文件&quot;&gt;二、解析project（ewp）文件&lt;/h3&gt;
&lt;p&gt;　　前面豹哥铺垫了很多IDE/project基础概念，该是直奔主题的时候了，本文主角ewp工程文件到底包含哪些开发者指定的input信息？豹哥从下面2个方面为大家揭秘：&lt;/p&gt;
&lt;h4 id=&quot;源文件组织&quot;&gt;2.1 源文件组织&lt;/h4&gt;
&lt;p&gt;　　一个稍微复杂一点的嵌入式工程，应用代码行数应该是以百行/千行为单位计算的（此处仅指的是由开发者自己创建的文件与代码），我们在组织代码的时候肯定不会只创建一个.c文件，单文件会导致代码功能模块结构不清晰，不方便工程的管理与维护。&lt;br/&gt;　　当我们为工程创建多个文件时，就会涉及到一个必然问题：路径问题。当源文件数目较多时，通常我们会创建不同文件夹把相同功能的源文件都放在一起，当编译器开始编译.c源文件时会搜索include语句所包含的头文件。熟悉C语言的朋友肯定清楚下面两种不同include语句的用法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;file.h&amp;gt;           &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// 引用编译器类库下的头文件（系统路径）&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;file.h&quot;           &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// 引用当前工程下的头文件（project路径）&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以在ewp文件里会包含路径信息，所有路径都应该列在Options-&amp;gt;C/C++ Compiler-&amp;gt;Preprocessor下有Additional include directories里，这个路径既可以是当前PC的绝对路径，也可以是以ewp文件为基准的相对路径，为了保证工程可以在任意PC任意位置下正常编译，推荐使用如下相对路径方式列出所有路径：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;ewp当前路径：$PROJ_DIR$/
ewp下级路径：$PROJ_DIR$/xxFolder/
ewp上级路径：$PROJ_DIR$/../&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说到路径问题，豹哥在这里顺便给大家介绍一种经典的嵌入式工程文件目录组织方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;\projectDir
           \doc                            --放置工程文档

           \bsp                            --放置bsp相关的source file
                  \linker                    --工程linker文件
                  \src                       --工程板级相关的源文件（比如pinout，clock等）
                  \builds\xxBuild\.ewp       --工程ewp文件
                  .eww                       --工程workspace文件

           \src                            --放置bsp无关的source file
                  \platform                  --芯片头文件及CMSIS文件
                  \drivers                   --芯片各模块driver
                  \include                   --要被所有source引用的头文件
                  \startup                   --标准的startup code
                  \utilities                 --标准的通用函数
                  \components                --应用组件
                  \application               --应用代码&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;编译选项&quot;&gt;2.2 编译选项&lt;/h4&gt;
&lt;p&gt;　　编译选项包含了编译器所需要的所有信息，代码需经过编译器编译才能生成二进制机器码，不同的编译器选项配置会生成不同的机器码，那么需要指定哪些选项呢？打开project的Options选项卡，分别设置下表item：&lt;/p&gt;
&lt;table readability=&quot;16&quot;&gt;&lt;tr&gt;&lt;th&gt;Position&lt;/th&gt;
&lt;th&gt;Item&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td rowspan=&quot;3&quot;&gt;General Options-&amp;gt;Target-&amp;gt;&lt;/td&gt;
&lt;td&gt;Processor variant-&amp;gt;Core&lt;/td&gt;
&lt;td&gt;&lt;span&gt;指定ARM内核版本&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Endian mode&lt;/td&gt;
&lt;td&gt;指定内核大小端模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Floating point settings-&amp;gt;FPU&lt;/td&gt;
&lt;td&gt;指定内核支持的FPU版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;General Options-&amp;gt;Library Configuration-&amp;gt;&lt;/td&gt;
&lt;td&gt;Library&lt;/td&gt;
&lt;td&gt;选择C/C++动态链接库版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;General Options-&amp;gt;Library Option 2-&amp;gt;&lt;/td&gt;
&lt;td&gt;Heap selection&lt;/td&gt;
&lt;td&gt;选择HEAP实现版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;8&quot;&gt;C/C++ Compiler-&amp;gt;&lt;/td&gt;
&lt;td&gt;Language 1-&amp;gt;Language&lt;/td&gt;
&lt;td&gt;指定编程语言类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Language 1-&amp;gt;C dialect&lt;/td&gt;
&lt;td&gt;指定C语言标准&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Language 1-&amp;gt;Language conformance&lt;/td&gt;
&lt;td&gt;选择对标准C/C++的遵循程度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Language 2-&amp;gt;Plain 'char' is&lt;/td&gt;
&lt;td&gt;选择对char的符号性默认处理方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Language 2-&amp;gt;Floating-point semantics&lt;/td&gt;
&lt;td&gt;选择对浮点数的处理遵循C标准的程度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Code-&amp;gt;Process mode&lt;/td&gt;
&lt;td&gt;指定内核指令集模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Code-&amp;gt;Position-independence&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选择要生成位置无关代码的对象&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Optimizations-&amp;gt;Level&lt;/td&gt;
&lt;td&gt;选择优化等级&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Note：更多ewp文件中option解释请查阅IAR软件安装目录下\IAR Systems\Embedded Workbench xxx\arm\doc\EWARM_IDEGuide.ENU.pdf文档里的General Options和Compiler Options俩小节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　当在project中组织好源文件并设置好正确的编译选项，那么恭喜你，你的application设计工作已经基本完成了。&lt;/p&gt;
&lt;h3 id=&quot;番外一几个小技巧&quot;&gt;番外一、几个小技巧&lt;/h3&gt;
&lt;p&gt;　　小技巧待续&lt;/p&gt;
&lt;p&gt;　　至此，嵌入式开发里的project文件豹哥便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 14:27:00 +0000</pubDate>
<dc:creator>Jay豹哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henjay724/p/8232585.html</dc:identifier>
</item>
<item>
<title>DevOps/TestOps概念 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/8232410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/8232410.html</guid>
<description>&lt;p&gt;天下大势分久必合合久必分，早期的软件开发只有软件工程师一人完成，为了提高效率逐渐实行分工模式：开发、测试、运维。不同角色担任不同的任务。分工越来越细之后带来了问题也越来越突出，那就是各角色之间的沟通成本越来越高。而全栈工程师、DevOps/TestOps相关职位和概念的提出，本质就是把不同的工作集中在一个人身上，或者让一个人涉及到更多方面的工作，从而来降低这种沟通成本。&lt;/p&gt;
&lt;p&gt;要想了解TestOps，必须要先了解DevOps。&lt;/p&gt;

&lt;h3 id=&quot;devops-介绍&quot;&gt;DevOps 介绍&lt;/h3&gt;
&lt;p&gt;wikipedia解释：DevOps是一种软件工程文化和实践，旨在统一软件开发(Dev)和软件运维(Ops)。DevOps运动的主要特点是在软件构建的所有步骤中极力提倡自动化和监控，从集成、测试、发布到部署和基础设施管理。DevOps的目标是缩短开发周期，增加部署频率，更可靠的发布，与业务目标紧密结合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://otfah9orz.bkt.clouddn.com/tc_Devops.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Dev、QA、Ops的交汇处我们认为就是DevOps。实际上，DevOps就是把产品开发过程中各角色交汇处的活给干了，让各部门都专注于干他们自己的活儿。&lt;/p&gt;

&lt;h4 id=&quot;devops与持续集成&quot;&gt;DevOps与持续集成&lt;/h4&gt;
&lt;p&gt;DevOps是一个完整的面向IT运维的工作流，以IT自动化以及持续集成（CI）、持续部署（CD）为基础，来优化程式开发、测试、系统运维等所有环节。&lt;/p&gt;

&lt;h4 id=&quot;devops-技术栈与工具链&quot;&gt;DevOps 技术栈与工具链&lt;/h4&gt;
&lt;p&gt;只讲理论是非常空洞的，我们必须通过技术和工具将DevOps落地。这里整理了主流的工具，其中包括版本控制&amp;amp;协作开发工具、自动化构建和测试工具、持续集成&amp;amp;交付工具、部署工具、维护工具、监控，警告&amp;amp;分析工具等等，这里补充了一些国内的服务，可以让你更好的执行实施 DevOps 工作流。&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;版本控制&amp;amp;协作开发：&lt;/strong&gt; GitHub、GitLab、BitBucket、SubVersion、Coding、Gitee&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;自动化构建和测试：&lt;/strong&gt; Apache Ant、Maven、Selenium、UnitTest、JUnit、JMeter、Gradle、PHPUnit&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;持续集成&amp;amp;交付：&lt;/strong&gt; Jenkins、Capistrano、BuildBot、Fabric、Tinderbox、Travis CI、flow.ci Continuum、LuntBuild、CruiseControl、Integrity、Gump、Go&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;容器平台：&lt;/strong&gt; Docker、Rocket、Ubuntu（LXC）、第三方厂商如（AWS/阿里云）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;配置管理：&lt;/strong&gt; Chef、Puppet、CFengine、Bash、Rudder、Powershell、RunDeck、Saltstack、Ansible&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;微服务平台：&lt;/strong&gt; OpenShift、Cloud Foundry、Kubernetes、Mesosphere&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务开通：&lt;/strong&gt; Puppet、Docker Swarm、Vagrant、Powershell、OpenStack Heat&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;日志管理：&lt;/strong&gt; Logstash、CollectD、StatsD、ElasticSearch、Logstash&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;监控，警告&amp;amp;分析：&lt;/strong&gt; Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了这种技术和工具外，在项目中制定出符合DevOps的工作流程是关键，但是，这个东西没有固定模板的，不同的项目、不同的团队和公司文化流程和可能有所不同，只要符合DevOps的理念和思想，你们需要走出一条自己的路。&lt;/p&gt;

&lt;h3 id=&quot;testops-介绍&quot;&gt;TestOps 介绍&lt;/h3&gt;
&lt;p&gt;TestOps主要目的是推动整个研发体系与发布体系更多在质量方面。可以这样理解DevOps是从研发推动配合运维和测试，而TestOps是从测试角度推动研发和运维。所以TestOps才是真正把测试落地到整个研发体系的关键岗位。&lt;/p&gt;
&lt;p&gt;关于TestOps定义：测试运维，测试角度推动研发、运维、持续测试到持续集成。&lt;/p&gt;
&lt;p&gt;新的趋势图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://otfah9orz.bkt.clouddn.com/tc_TestOps.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试与开发交叉的工作，通过测试驱动开发（TestDev）来进行。&lt;/p&gt;
&lt;p&gt;测试与运维交叉的工作，通过TestOps来完成。&lt;/p&gt;
&lt;p&gt;开发与运维交叉的工作，通过DevOps来完成。&lt;/p&gt;
&lt;p&gt;三个角色交叉的部分工作，由god来做吧！哈哈。&lt;/p&gt;

&lt;h4 id=&quot;testops技能&quot;&gt;TestOps技能&lt;/h4&gt;
&lt;p&gt;“TestOps”团队的本质是专注于提供所需的基础设施和平台所有级别的测试，从功能测试到集成测试，再到低级单元和API测试。&lt;/p&gt;
&lt;p&gt;Dev能力：Java、Python、PHP、Shell&lt;/p&gt;
&lt;p&gt;Ops能力：Jenkins、Docker、Maven、Ansible、Git、Linux&lt;/p&gt;
&lt;p&gt;Test能力：测试用例、测试方法、缺陷生命周期、单元测试、接口测试、Selenium&lt;/p&gt;

&lt;h4 id=&quot;testops未来的价值&quot;&gt;TestOps未来的价值&lt;/h4&gt;
&lt;p&gt;团队价值：推动先进的团队协作方式，持续交付生命周期的把控，持续集成高质量要求。&lt;/p&gt;
&lt;p&gt;个人价值：DevOps和TestOps技能，自动化测试推动持续交付，主导开发流程的生命周期。&lt;/p&gt;
&lt;p&gt;DevOps能推动整个测试和运维团队统一整个研发流程，帮助团队更敏捷的提交产品。他能解决流程问题，但无法发现开发过程中的测试的缺陷。只有更专业TestOps的站在专业的测试角度推动开发和运维一起进行。TestOps和DevOps形成一个完整的持续集成和持续交付体系，才是真正提升整个团队的效率。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;最后，抛开这些概念，我觉得测试人员提升自己的综合能力才是关键：培养自己的编程能力，更早的介入项目测试（单元、接口），提高自己的（接口/UI）自动化能力，提升测试效率。学习运维技术，能够独立部署和维护测试环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/what-/p/7780261.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/what-/p/7780261.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 14:02:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/8232410.html</dc:identifier>
</item>
<item>
<title>Unity 3d游戏逆向及.NET Reflector工具使用介绍 - bamb00</title>
<link>http://www.cnblogs.com/goodhacker/p/8232037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodhacker/p/8232037.html</guid>
<description>&lt;p&gt;移动平台游戏框架主要有unity 3d和cocos 2d。我们首先得识别游戏使用的框架。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;识别Unity游戏&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;Android平台的apk包可以直接解压，看是否有./assets/bin/Data/Managed目录，也可以查看lib文件夹下面包含的一些so，如果有libmono,libunity等模块，基本可以确定是unity游戏了。&lt;br/&gt;Android平台中C#编写的主逻辑模块代码静态编辑之后存储于Assembly-CSharp.dll文件中。因为unity的跨平台，Android平台是unity编译的游戏，那么其对应的IOS平台上也是unity编译出来的。如果希望直接从IOS上面去看是否是unity游戏，可以提取游戏中的主模块查看是否有unity之类的函数即可。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;破解思路&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;下面列举了一些破解版思路，如果能直接下断点在函数头修改寄存器可直接修改寄存器测试，遇到一些不能直接修改的，就用第二种方法，把修改后的Assembly-CSharp.dll注入到游戏中，让游戏执行我们修改后的代码。另外也可以动静态修改二进制实现。&lt;/p&gt;&lt;p&gt;1、修改unity游戏逻辑代码编译成汇编代码相关的值&lt;br/&gt;（1） 修改传进来的参数，即寄存器，一般是set之类的函数&lt;br/&gt;（2） 汇编代码中尽量不修改内存，不修改opcode，能改寄存器直接改寄存器&lt;/p&gt;&lt;p&gt;2、反编译Assembly-CSharp.dll，直接修改unity的C#源代码&lt;br/&gt;（1） 修改函数返回值&lt;br/&gt;（2） 直接删除函数体，只剩下 ret 指令&lt;br/&gt;（3） 在对应函数修改，对变量进行处理&lt;br/&gt;（4） 在对应函数增加一些call处理，主动call&lt;/p&gt;&lt;p&gt;3、分析源码直接修改代码&lt;br/&gt;（1） 通过分析unity反编译后的源码找到对应的汇编指令下断点修改寄存器&lt;br/&gt;（2） 通过直接静态分析dll，直接修改IL码的二进制码&lt;/p&gt;&lt;p&gt;4、在加载dll的函数位置dump原来的dll代码，可绕过dll加密，修改源代码&lt;br/&gt;hook住mono_image_open_from_data_full函数，dump出dll可以，用IDA配合jdb挂起进程在那函数位置下断点dump也可以，源代码具体修改方案同“2”和“3”&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用工具&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;1、IDA工具&lt;br/&gt;可以进行动态调试和静态分析的工具，能在合适的位置下断点，修改指定寄存器和编写IDC脚本配合分析&lt;br/&gt;2、ILSpy&lt;br/&gt;反编译和分析dll代码，可以交叉引用，可以以源码形式保存反编译的代码，提供代码给DirFind等字符串搜索定位工具定位代码位置&lt;/p&gt;&lt;p&gt;3、.NET Reflector + Reflexil&lt;br/&gt;反编译和分析dll代码，弥补了ILSpy一些功能性的缺陷，可以分析出错误的CLR文件头，一些在ILSpy显示不出的dll文件，如果只是因为dll头部被修改，放在.NET Reflector中是可以分析出的。Reflexil则是.NET Reflector的一款插件，可以反编译和回编译IL码，方便实用可视化。&lt;/p&gt;&lt;p&gt;4、Ilasm和ildasm&lt;br/&gt;Ildasm可以反编译dll，dump出反编译后的il码，而Ilasm则可以重打包il码，利用命令ilasm /dll *.il即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;常用IL码二进制&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;（1）nop 二进制是 0x00&lt;br/&gt;（2）ldc.i4.0 二进制是 0x16&lt;br/&gt;（3）ldc.i4.1 二进制是 0x17&lt;br/&gt;（4）ret 二进制是 0x2A&lt;br/&gt;（5）ldc.r4 二进制是 0x22 ，后面跟四个字节&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;.NET Reflector + Reflexil的使用&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;用.NET Reflector打开Assembly-CSharp.dll，这里使用的.NET Reflector版本是9.0，Reflexil版本是2.1。如图所示，通过这个Reflexil插件，我们可以插入字段、类、方法等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107212834940-1975386423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过Tools菜单下的Reflexil选项，可以打开unity代码修改器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107212922612-814281056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在左边单击对应函数，就可以对该函数代码进行修改了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107212959643-2136321686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面举例分析。在逆向中我们经常需要插入log语句打印log信息来辅助分析。unity打印log的语句是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Debug.Log
函数原型是：&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Log(&lt;span&gt;object&lt;/span&gt; message);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果我们要打印下面函数中ToString的返回值应该如何操作呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107213049049-1381475069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照正常逻辑，应该是先保存ToString()的值到寄存器，然后当作参数传递给Log函数打印出来。但是我不知道怎么保存这个值，所以想到了另外一个办法，仿照原代码，再次调用ToString()函数，然后将下面调用CalcMD5函数改为调用Debug.Log函数。&lt;br/&gt;具体怎么操作呢？&lt;br/&gt;（1）首先右击“ldloc.3”那一行代码（Offset为 196），选择“Create new...”，OpCode选择“ldloc.3”，然后点击“Insert before select”。&lt;br/&gt;stloc.1 将值从堆栈弹出到局部变量 1&lt;br/&gt;ldloc.1 将索引 1 处的局部变量加载到计算堆栈上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107213133753-1448177700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）OpCode选择“callvirt”,Operand type选择“Method reference”,Operand选择“ToString”函数（在mscorlib模块找到System.Text.StringBuilder::ToString函数）。然后点击“Insert before select”。&lt;br/&gt;（3）OpCode选择“call”,Operand type选择“Method reference”,Operand选择“Log”函数。这个函数是在UnityEngine中查找，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107213205987-446807135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107213225299-1694419740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击“Insert before select”，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107213332237-2014968781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加代码后的情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107213345393-194984733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完成后，右键“Assembly-CSharp.dll”，依次点击“Reflexil”，“Save as...”保存dll文件，重新打包安装运行就可以看到log输出信息了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180107213422065-91923293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;http://gslab.qq.com/article-53-1.html&quot; target=&quot;_blank&quot;&gt;http://gslab.qq.com/article-53-1.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 13:37:00 +0000</pubDate>
<dc:creator>bamb00</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodhacker/p/8232037.html</dc:identifier>
</item>
<item>
<title>关于Oracle开启自动收集统计信息的SPA测试 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/8231728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/8231728.html</guid>
<description>&lt;p&gt;&lt;strong&gt;主题：&lt;/strong&gt;关于Oracle开启自动收集统计信息的SPA测试&lt;br/&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle RAC 11.2.0.4（Primary + Standby）&lt;br/&gt;&lt;strong&gt;需求：&lt;/strong&gt;生产Primary库由于历史原因关闭了自动统计信息的收集，目前客户需求是想要重新开启统计信息的自动收集，虽然一般来说，有了更准确的统计信息，SQL会有更好的执行计划，但由于生产环境数据复杂，实际上还是需要评估哪些SQL会因为重新开启自动统计信息收集性能反而会下降。&lt;br/&gt;&lt;strong&gt;方案：&lt;/strong&gt;本着尽可能减少对生产Primary环境影响的原则，在Standby DG环境临时开启snapshot standby来进行SPA（SQL Performance Analyze）测试，比对开启统计信息自动收集前后的性能差异，给客户提供有价值的参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检查自动统计信息的开启状态：&lt;/strong&gt;&lt;br/&gt;select client_name,status from dba_autotask_client;&lt;br/&gt;确认自动统计信息的收集是关闭的，对于“auto optimizer stats collection”的状态应该是“DISABLED”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select client_name,status from dba_autotask_client;

CLIENT_NAME                                                      STATUS
---------------------------------------------------------------- --------
auto optimizer stats collection                                  DISABLED
auto space advisor                                               ENABLED
sql tuning advisor                                               ENABLED&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;附：关闭数据库的自动统计信息收集：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--光闭自动统计信息收集，（慎用，除非有其他手工收集统计信息的完整方案，否则不建议关闭）
BEGIN
  DBMS_AUTO_TASK_ADMIN.disable(
    client_name =&amp;gt; 'auto optimizer stats collection',
    operation =&amp;gt; NULL,
    window_name =&amp;gt; NULL);
END;
/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DG备库保持和主库同步，所以这些设置项也都是完全一样的。&lt;/p&gt;

&lt;p&gt;主要就是在mount模式下切换数据到snapshot Standby模式再read write打开库，为之后测试做准备。下面是核心步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; shutdown immediate
SQL&amp;gt; startup mount
SQL&amp;gt; alter database convert to snapshot standby;
SQL&amp;gt; shutdown immediate
SQL&amp;gt; startup&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于其他细节可参考下面文章，主要是为“开启11gR2 DG的快照模式”，“后续还原成备库” 等操作提供参考：&lt;/p&gt;

&lt;p&gt;进行SPA测试时，强烈建议在数据库中创建SPA测试专用用户，这样可以与其他用户区分开以及避免误操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt;
CREATE USER SPA IDENTIFIED BY SPA DEFAULT TABLESPACE SYSAUX;
GRANT DBA TO SPA;
GRANT ADVISOR TO SPA;
GRANT SELECT ANY DICTIONARY TO SPA;
GRANT ADMINISTER SQL TUNING SET TO SPA;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;备库从AWR中采集到SQL。&lt;br/&gt;&lt;strong&gt;4.1 获取AWR快照的边界ID&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET LINES 188 PAGES 1000
COL SNAP_TIME FOR A22
COL MIN_ID NEW_VALUE MINID
COL MAX_ID NEW_VALUE MAXID
SELECT MIN(SNAP_ID) MIN_ID, MAX(SNAP_ID) MAX_ID
  FROM DBA_HIST_SNAPSHOT
 WHERE END_INTERVAL_TIME &amp;gt; trunc(sysdate)-10
 ORDER BY 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里的结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    MIN_ID     MAX_ID
---------- ----------
      2755       2848&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.2 新建SQL Set&lt;/strong&gt;&lt;br/&gt;&lt;em&gt;注意：以下的规范部分都是引用之前同事编写的SPA操作规范。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EXEC DBMS_SQLTUNE.DROP_SQLSET ( -
                  SQLSET_NAME  =&amp;gt; '${DBNAME}_SQLSET_${YYYYMMDD}',
                  SQLSET_OWNER =&amp;gt; 'SPA');

EXEC DBMS_SQLTUNE.CREATE_SQLSET ( -
                  SQLSET_NAME  =&amp;gt; '${DBNAME}_SQLSET_${YYYYMMDD}', -
                  DESCRIPTION  =&amp;gt; 'SQL Set Create at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), -
                  SQLSET_OWNER =&amp;gt; 'SPA');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--连接用户
conn SPA/SPA

--如果之前有这个SQLSET的名字，可以这样删除
EXEC DBMS_SQLTUNE.DROP_SQLSET (SQLSET_NAME  =&amp;gt; 'JYZHAO_SQLSET_20180106', SQLSET_OWNER =&amp;gt; 'SPA');

--新建SQLSET：JYZHAO_SQLSET_20180106
EXEC DBMS_SQLTUNE.CREATE_SQLSET ( -
                  SQLSET_NAME  =&amp;gt; 'JYZHAO_SQLSET_20180106', -
                  DESCRIPTION  =&amp;gt; 'SQL Set Create at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), -
                  SQLSET_OWNER =&amp;gt; 'SPA');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.3 转化AWR数据中的SQL，将其载入到SQL Set&lt;/strong&gt;&lt;br/&gt;从备库的AWR中提取SQL（这等同于主库历史的SQL）。&lt;br/&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DECLARE
  SQLSET_CUR DBMS_SQLTUNE.SQLSET_CURSOR;
BEGIN
  OPEN SQLSET_CUR FOR
    SELECT VALUE(P) FROM TABLE(
           DBMS_SQLTUNE.SELECT_WORKLOAD_REPOSITORY( &amp;amp;MINID, &amp;amp;MAXID,
                        'PARSING_SCHEMA_NAME NOT IN (''SYS'', ''SYSTEM'')',
                        NULL, NULL, NULL, NULL, 1, NULL, 'ALL')) P;
  DBMS_SQLTUNE.LOAD_SQLSET(
               SQLSET_NAME =&amp;gt; '${DBNAME}_SQLSET_${YYYYMMDD}',
               SQLSET_OWNER =&amp;gt; 'SPA',
               POPULATE_CURSOR =&amp;gt; SQLSET_CUR,
               LOAD_OPTION =&amp;gt; 'MERGE',
               UPDATE_OPTION =&amp;gt; 'ACCUMULATE');
  CLOSE SQLSET_CUR;
    END;
/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DECLARE
  SQLSET_CUR DBMS_SQLTUNE.SQLSET_CURSOR;
BEGIN
  OPEN SQLSET_CUR FOR
    SELECT VALUE(P) FROM TABLE(
           DBMS_SQLTUNE.SELECT_WORKLOAD_REPOSITORY( 2755, 2848,
                        'PARSING_SCHEMA_NAME NOT IN (''SYS'', ''SYSTEM'')',
                        NULL, NULL, NULL, NULL, 1, NULL, 'ALL')) P;
  DBMS_SQLTUNE.LOAD_SQLSET(
               SQLSET_NAME =&amp;gt; 'JYZHAO_SQLSET_20180106',
               SQLSET_OWNER =&amp;gt; 'SPA',
               POPULATE_CURSOR =&amp;gt; SQLSET_CUR,
               LOAD_OPTION =&amp;gt; 'MERGE',
               UPDATE_OPTION =&amp;gt; 'ACCUMULATE');
  CLOSE SQLSET_CUR;
    END;
/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.4 打包SQL Set(可不做)&lt;/strong&gt;&lt;br/&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP TABLE SPA.${DBNAME}_SQLSETTAB_${YYYYMMDD};
EXEC DBMS_SQLTUNE.CREATE_STGTAB_SQLSET ('${DBNAME}_SQLSETTAB_${YYYYMMDD}', ‘SPA’, 'SYSAUX');
EXEC DBMS_SQLTUNE.PACK_STGTAB_SQLSET ( -
                  SQLSET_NAME          =&amp;gt; '${DBNAME}_SQLSET_${YYYYMMDD}', -
                  SQLSET_OWNER         =&amp;gt; ‘SPA’, -
                  STAGING_TABLE_NAME   =&amp;gt; '${DBNAME}_SQLSETTAB_${YYYYMMDD}', -
                  STAGING_SCHEMA_OWNER =&amp;gt; ‘SPA’);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP TABLE SPA.JYZHAO_SQLSETTAB_20180106;
EXEC DBMS_SQLTUNE.CREATE_STGTAB_SQLSET ('JYZHAO_SQLSETTAB_20180106', 'SPA', 'SYSAUX');
EXEC DBMS_SQLTUNE.PACK_STGTAB_SQLSET ( -
                  SQLSET_NAME          =&amp;gt; 'JYZHAO_SQLSET_20180106', -
                  SQLSET_OWNER         =&amp;gt; 'SPA', -
                  STAGING_TABLE_NAME   =&amp;gt; 'JYZHAO_SQLSETTAB_20180106', -
                  STAGING_SCHEMA_OWNER =&amp;gt; 'SPA');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;说明：其实在我这里的测试场景下，这一步是不需要做的。因为备库的SQL Set可以直接在后面引用，不需要像SPA经典场景中，是从生产源环境打包导出来后，在测试环境再导入进去，再解包为SQL Set。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.1 创建SPA分析任务&lt;/strong&gt;&lt;br/&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VARIABLE SPA_TASK  VARCHAR2(64);
EXEC :SPA_TASK := DBMS_SQLPA.CREATE_ANALYSIS_TASK(  -
                             TASK_NAME    =&amp;gt; 'SPA_TASK_${YYYYMMDD}', -
                             DESCRIPTION =&amp;gt; 'SPA Analysis task at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), -
                             SQLSET_NAME  =&amp;gt; '${DBNAME}_SQLSET_${YYYYMMDD}', -
                             SQLSET_OWNER =&amp;gt; ‘SPA’);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--创建SPA分析任务：
VARIABLE SPA_TASK  VARCHAR2(64);
EXEC :SPA_TASK := DBMS_SQLPA.CREATE_ANALYSIS_TASK(  -
                             TASK_NAME    =&amp;gt; 'SPA_TASK_20180106', -
                             DESCRIPTION =&amp;gt; 'SPA Analysis task at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), -
                             SQLSET_NAME  =&amp;gt; 'JYZHAO_SQLSET_20180106', -
                             SQLSET_OWNER =&amp;gt; 'SPA');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.2 获取变更前的SQL执行效率&lt;/strong&gt;&lt;br/&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_${YYYYMMDD}', -
                EXECUTION_NAME =&amp;gt; 'EXEC_10G_${YYYYMMDD}', -
                EXECUTION_TYPE =&amp;gt; 'CONVERT SQLSET', -
                EXECUTION_DESC =&amp;gt; 'Convert 10g SQLSET for SPA Task at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_20180106', -
                EXECUTION_NAME =&amp;gt; 'EXEC_BEFORE_20180106', -
                EXECUTION_TYPE =&amp;gt; 'CONVERT SQLSET', -
                EXECUTION_DESC =&amp;gt; 'Convert Before gathering stats SQLSET for SPA Task at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.3 开启变更操作&lt;/strong&gt;&lt;br/&gt;变更内容：开启统计信息自动收集并确认已经成功收集了最新的统计信息。&lt;br/&gt;这里首先需要开启统计信息自动收集，并可以把自动收集的窗口时间提前到现在，减少等待的时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--检查自动统计信息的开启状态：
select client_name,status from dba_autotask_client;

--启动自动统计信息收集
BEGIN
  DBMS_AUTO_TASK_ADMIN.enable(
    client_name =&amp;gt; 'auto optimizer stats collection',
    operation =&amp;gt; NULL,
    window_name =&amp;gt; NULL);
END;
/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看窗口任务和有关统计信息自动收集的任务执行状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select window_name,repeat_interval,duration,enabled from dba_scheduler_windows;
select owner, job_name, status, ACTUAL_START_DATE, RUN_DURATION from dba_scheduler_job_run_details where job_name like 'ORA$AT_OS_OPT_S%' order by 4;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调整窗口任务的下一次执行时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--需要确认JOB可以启动
alter system set job_queue_processes=1000;

--调整窗口任务的下一次执行时间
EXEC DBMS_SCHEDULER.SET_ATTRIBUTE('SATURDAY_WINDOW','repeat_interval','freq=daily;byday=SAT;byhour=17;byminute=10;bysecond=0');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多有关调整窗口和自动任务的内容可参考文章：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.4 变更后再次分析性能&lt;/strong&gt;&lt;br/&gt;测试运行SQL Tuning Set中的SQL语句，分析所有语句在收集统计信息之后的执行效率：&lt;br/&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_${YYYYMMDD}', -
                EXECUTION_NAME =&amp;gt; 'EXEC_11G_${YYYYMMDD}', -
                EXECUTION_TYPE =&amp;gt; 'TEST EXECUTE', -
                EXECUTION_DESC =&amp;gt; 'Execute SQL in 11g for SPA Task at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_20180106', -
                EXECUTION_NAME =&amp;gt; 'EXEC_AFTER_20180106', -
                EXECUTION_TYPE =&amp;gt; 'TEST EXECUTE', -
                EXECUTION_DESC =&amp;gt; 'Execute SQL After gathering stats for SPA Task at : '||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.5 变更前后性能对比&lt;/strong&gt;&lt;br/&gt;得到两次SQL Trail之后，可以对比两次Trial之间的SQL执行性能，可以从不同的维度对两次Trail中的所有SQL进行对比分析，主要关注的维度有：SQL执行时间，SQL执行的CPU时间，SQL执行的逻辑读。&lt;br/&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1). 对比两次Trail中的SQL执行时间
EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_${YYYYMMDD}', -
                EXECUTION_NAME =&amp;gt; 'COMPARE_ET_${YYYYMMDD}', -
                EXECUTION_TYPE =&amp;gt; 'COMPARE PERFORMANCE', -
                EXECUTION_PARAMS =&amp;gt; DBMS_ADVISOR.ARGLIST( -
                                                 'COMPARISON_METRIC', 'ELAPSED_TIME', -
                                                 'EXECUTE_FULLDML', 'TRUE', -
                                                 'EXECUTION_NAME1','EXEC_10G_${YYYYMMDD}', -
                                                 'EXECUTION_NAME2','EXEC_11G_${YYYYMMDD}'), -
                EXECUTION_DESC =&amp;gt; 'Compare SQLs between 10g and 11g at :'||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));
2). 对比两次Trail中的SQL执行的CPU时间
EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_${YYYYMMDD}', -
                EXECUTION_NAME =&amp;gt; 'COMPARE_CT_${YYYYMMDD}', -
                EXECUTION_TYPE =&amp;gt; 'COMPARE PERFORMANCE', -
                EXECUTION_PARAMS =&amp;gt; DBMS_ADVISOR.ARGLIST( -
                                                 'COMPARISON_METRIC', 'CPU_TIME', -
                                                 'EXECUTION_NAME1','EXEC_10G_${YYYYMMDD}', -
                                                 'EXECUTION_NAME2','EXEC_11G_${YYYYMMDD}'), -
                EXECUTION_DESC =&amp;gt; 'Compare SQLs between 10g and 11g at :'||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));
3). 对比两次Trail中的SQL执行的逻辑读
EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_D', -
                EXECUTION_NAME =&amp;gt; 'COMPARE_BG_D', -
                EXECUTION_TYPE =&amp;gt; 'COMPARE PERFORMANCE', -
                EXECUTION_PARAMS =&amp;gt; DBMS_ADVISOR.ARGLIST( -
                                                 'COMPARISON_METRIC', 'BUFFER_GETS', -
                                                 'EXECUTION_NAME1','EXEC_10G_${YYYYMMDD}', -
                                                 'EXECUTION_NAME2','EXEC_11G_${YYYYMMDD}'), -
                EXECUTION_DESC =&amp;gt; 'Compare SQLs between 10g and 11g at :'||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1). 对比两次Trail中的SQL执行时间
EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_20180106', -
                EXECUTION_NAME =&amp;gt; 'COMPARE_ET_20180106', -
                EXECUTION_TYPE =&amp;gt; 'COMPARE PERFORMANCE', -
                EXECUTION_PARAMS =&amp;gt; DBMS_ADVISOR.ARGLIST( -
                                                 'COMPARISON_METRIC', 'ELAPSED_TIME', -
                                                 'EXECUTE_FULLDML', 'TRUE', -
                                                 'EXECUTION_NAME1','EXEC_BEFORE_20180106', -
                                                 'EXECUTION_NAME2','EXEC_AFTER_20180106'), -
                EXECUTION_DESC =&amp;gt; 'Compare SQLs between 10g and 11g at :'||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));
2). 对比两次Trail中的SQL执行的CPU时间
EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_20180106', -
                EXECUTION_NAME =&amp;gt; 'COMPARE_CT_20180106}', -
                EXECUTION_TYPE =&amp;gt; 'COMPARE PERFORMANCE', -
                EXECUTION_PARAMS =&amp;gt; DBMS_ADVISOR.ARGLIST( -
                                                 'COMPARISON_METRIC', 'CPU_TIME', -
                                                 'EXECUTION_NAME1','EXEC_BEFORE_20180106', -
                                                 'EXECUTION_NAME2','EXEC_AFTER_20180106'), -
                EXECUTION_DESC =&amp;gt; 'Compare SQLs between 10g and 11g at :'||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));
3). 对比两次Trail中的SQL执行的逻辑读
EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK( -
                TASK_NAME      =&amp;gt; 'SPA_TASK_20180106', -
                EXECUTION_NAME =&amp;gt; 'COMPARE_BG_20180106', -
                EXECUTION_TYPE =&amp;gt; 'COMPARE PERFORMANCE', -
                EXECUTION_PARAMS =&amp;gt; DBMS_ADVISOR.ARGLIST( -
                                                 'COMPARISON_METRIC', 'BUFFER_GETS', -
                                                 'EXECUTION_NAME1','EXEC_BEFORE_20180106', -
                                                 'EXECUTION_NAME2','EXEC_AFTER_20180106'), -
                EXECUTION_DESC =&amp;gt; 'Compare SQLs between Before_STATS and After_STATS at :'||TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;参考规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--a)  获取执行时间全部报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL elapsed_all.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_${YYYYMMDD}','HTML','ALL','ALL',NULL,1000,'SPA_TASK_${YYYYMMDD}_COMP_ET')).GETCLOBVAL(0,0) FROM DUAL;
--b)  获取执行时间下降报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL elapsed_regressed.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_${YYYYMMDD}','HTML','REGRESSED','ALL',NULL,1000,'SPA_TASK_${YYYYMMDD}_COMP_ET')).GETCLOBVAL(0,0) FROM DUAL;
--c)  获取逻辑读全部报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL buffer_all.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_${YYYYMMDD}','HTML','ALL','ALL',NULL,1000,'SPA_TASK_${YYYYMMDD}_COMP_BG')).GETCLOBVAL(0,0) FROM DUAL;
--d)  获取逻辑读下降报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL buffer_regressed.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_${YYYYMMDD}','HTML','REGRESSED','ALL',NULL,1000,'SPA_TASK_${YYYYMMDD}_COMP_BG')).GETCLOBVAL(0,0) FROM DUAL;
--e)  获取错误报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL error.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_${YYYYMMDD}','HTML','ERRORS','ALL',NULL,1000,'SPA_TASK_${YYYYMMDD}_COMP_ET')).GETCLOBVAL(0,0) FROM DUAL;
--f)  获取不支持报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL unsupported.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_${YYYYMMDD}','HTML','UNSUPPORTED','ALL',NULL,1000,'SPA_TASK_${YYYYMMDD}_COMP_ET')).GETCLOBVAL(0,0) FROM DUAL;
--g)  获取执行计划变化报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL changed_plans.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_${YYYYMMDD}','HTML','CHANGED_PLANS','ALL',NULL,1000,'SPA_TASK_${YYYYMMDD}_COMP_ET')).GETCLOBVAL(0,0) FROM DUAL;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据我的实验环境，真实的示例为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--a)  获取执行时间全部报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL elapsed_all.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_20180106','HTML','ALL','ALL',NULL,1000,'COMPARE_ET_20180106')).GETCLOBVAL(0,0) FROM DUAL;
--b)  获取执行时间下降报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL elapsed_regressed.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_20180106','HTML','REGRESSED','ALL',NULL,1000,'COMPARE_ET_20180106')).GETCLOBVAL(0,0) FROM DUAL;
--c)  获取逻辑读全部报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL buffer_all.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_20180106','HTML','ALL','ALL',NULL,1000,'COMPARE_BG_20180106')).GETCLOBVAL(0,0) FROM DUAL;
--d)  获取逻辑读下降报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL buffer_regressed.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_20180106','HTML','REGRESSED','ALL',NULL,1000,'COMPARE_BG_20180106')).GETCLOBVAL(0,0) FROM DUAL;
--e)  获取错误报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL error.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_20180106','HTML','ERRORS','ALL',NULL,1000,'COMPARE_ET_20180106')).GETCLOBVAL(0,0) FROM DUAL;
--f)  获取不支持报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL unsupported.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_20180106','HTML','UNSUPPORTED','ALL',NULL,1000,'COMPARE_ET_20180106')).GETCLOBVAL(0,0) FROM DUAL;
--g)  获取执行计划变化报告
ALTER SESSION SET EVENTS='31156 TRACE NAME CONTEXT FOREVER, LEVEL 0X400';
SET LINES 1111 PAGES 50000 LONG 1999999999 TRIM ON TRIMS ON SERVEROUTPUT ON SIZE UNLIMITED
SPOOL changed_plans.html
SELECT XMLTYPE(DBMS_SQLPA.REPORT_ANALYSIS_TASK('SPA_TASK_20180106','HTML','CHANGED_PLANS','ALL',NULL,1000,'COMPARE_ET_20180106')).GETCLOBVAL(0,0) FROM DUAL;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就得到了各类的性能对比报告，以执行时间的全部报告为例，生成的报告概要头部类似这样：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_elapsed_all.jpg&quot;/&gt;&lt;br/&gt;当然，具体获取到的这些性能对比报告，针对那些有性能下降的SQL，还需要人工干预，评估如何优化处理那些性能下降的SQL。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 13:00:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/8231728.html</dc:identifier>
</item>
<item>
<title>.Net Core建站（3）：搭建三层架构 - 步尘</title>
<link>http://www.cnblogs.com/Onlooker/p/8231522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Onlooker/p/8231522.html</guid>
<description>&lt;p&gt;啊，终于到写三层架构的时候了，老实说，我都不知道自己这个算不算三层架构，姑且就当它是吧，具体属于哪一个体系，希望有大佬指点一下(^o^)／&lt;/p&gt;
&lt;p&gt;不晓得有人注意到没有，我写了三篇博客，然后就改了三次标题ヽ(￣▽￣)ﾉ，&lt;/p&gt;
&lt;p&gt;从最开始的&lt;a href=&quot;http://www.cnblogs.com/Onlooker/p/8047176.html&quot; target=&quot;_blank&quot;&gt;Core建数据库&lt;/a&gt;，到&lt;a href=&quot;http://www.cnblogs.com/Onlooker/p/8097588.html&quot; target=&quot;_blank&quot;&gt;Core数据库操作&lt;/a&gt;，再到现在的Core建站，也算是下决心写个系列啊，，感觉要更好久的样子，，&lt;/p&gt;
&lt;p&gt;好吧，不要在意那些细节，文中可能会有一些我不知道的坑，毕竟自己也是一边自学一边写，不过保证功能还是能用的，发现有坑记得说，，我改，，(〃'▽'〃)&lt;/p&gt;

&lt;p&gt;// ===================emmm，我是分割线===================&lt;/p&gt;

&lt;p&gt; 强烈推荐阅读：&lt;a href=&quot;http://www.uml.org.cn/sjms/201211023.asp&quot; target=&quot;_blank&quot;&gt;设计模式六大原则&lt;/a&gt; 讲的相当浅显易懂，，&lt;/p&gt;
&lt;p&gt;首先上一个截图，看看现在的项目结构，今天的主角是DataBase文件里面的那一堆项目啊，BLL，DAL和Interface，，Models是生成数据库时使用的，所以今天用不上，，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/891962/201801/891962-20180107144925924-1298360565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;按我的理解，先说说正常的三层架构吧，&lt;/p&gt;
&lt;p&gt;UI：界面层，这个层最简单，只是给BLL传递数据，然后，将BLL返回的数据进行一些处理，方便展示，&lt;/p&gt;
&lt;p&gt;BLL：业务逻辑层，接收UI层给的数据，写一些业务逻辑，第一步干啥，第二步干啥，什么什么的，然后把界面需要的数据返回出去，感觉更像是一个API&lt;/p&gt;
&lt;p&gt;DAL：数据访问层，BLL的业务逻辑处理时，总要涉及到数据库的操作，这时候就要用到DAL层了，，&lt;/p&gt;
&lt;p&gt;还有一个Model层，用来传递数据的，，不在三层范畴，，，&lt;/p&gt;

&lt;p&gt;不知道大家是怎么使用三层的，给大家展示一下以前学校教我们怎么用的三层架构啊，，&lt;/p&gt;
&lt;p&gt;分别对应三个类，UI层：HomeController，BLL层：DT_UserBLL，DAL层：DT_UserDAL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; UI层&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IActionResult Index(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userID)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据条件，返回用户
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 和BLL说，给你一堆条件，帮我把这些人找出来&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; userList = DT_UserBLL.GetUser(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(userList);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; BLL层，返回符合条件的用户
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sex&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;age&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; List&amp;lt;DT_User&amp;gt; GetUser(&lt;span&gt;int&lt;/span&gt; sex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; 数据校验
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 性别检测，0：女，1：男&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (sex != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; sex != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拒绝人妖&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 年龄检测，[0,150]岁&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (age &amp;lt; &lt;span&gt;0&lt;/span&gt; || &lt;span&gt;150&lt;/span&gt; &amp;lt;&lt;span&gt; age)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拒绝妖怪&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 和DAL说，数据我校验好了，不是恶搞，
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 帮我查出来这些人，然后我交给UI就完事儿了，，&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; DT_UserDAL.GetUser(&lt;span&gt;int&lt;/span&gt; sex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age).ToList();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; DAL层，返回符合条件的用户
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sex&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;age&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IQueryable&amp;lt;DT_User&amp;gt; GetUser(&lt;span&gt;int&lt;/span&gt; sex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             DbContext DB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DbContext();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; DB.Set&amp;lt;DT_User&amp;gt;().Where(c=&amp;gt;c.Sex==sex&amp;amp;&amp;amp;c.Age==&lt;span&gt;age);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当时学着感觉蛮好的，挺新奇的一个编程思想，不过&lt;span&gt;每一个数据表对应的DAL里面都得写一套增删查改&lt;/span&gt;，，简直是灾难，，[○･｀Д´･ ○]&lt;/p&gt;
&lt;p&gt;出来实习之后，花了个把星期，把我们老大写的一个框架看明白了，就按图索骥地写了起来，嘿嘿&lt;/p&gt;

&lt;p&gt;其实和三层架构差不多的，只是&lt;span&gt;把每个数据表对应的DAL里面的增删查改全部提出来，封装成了一个类&lt;/span&gt;，，&lt;/p&gt;
&lt;p&gt;然后对这个类进行继承，具体操作如下，，，&lt;/p&gt;

&lt;p&gt;首先啊，要大概了解一下依赖注入，，讲真，这个我也是一脸懵逼，所以就不复制百度百科了，，&lt;/p&gt;
&lt;p&gt;说说自己的理解吧，，，，&lt;strong&gt;&lt;span&gt;emmm，此处可能有大量谬论，建议不要被我误导了，看看就好，别往心里去&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依赖注入这东西就好像一个全局的字典类型变量，，都是以键值对的方式存储的&lt;/p&gt;
&lt;p&gt;因为注册依赖注入服务的大部分语法是酱紫的，，，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; services.AddTransient(&lt;span&gt;typeof&lt;/span&gt;(IDT_UserService), &lt;span&gt;typeof&lt;/span&gt;(DT_UserService));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而services这个变量的话，就像一个容器，用来存储这些键值对的，具体从哪来的，我也不知道，ヽ(￣д￣;)ノ&lt;/p&gt;
&lt;p&gt;而要使用的话，语法是酱紫的，，，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IDT_UserService _UserService;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(IDT_UserService _UserService)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖注入得到实例&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._UserService =&lt;span&gt; _UserService;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             ViewBag.list = _UserService.LoadEntites(c =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对的，完全不需要new，，其原理，，起码我不晓得，感觉甚是神奇，，&lt;/p&gt;
&lt;p&gt;先注册一个依赖注入的服务，然后要实例的时候，直接在构造函数里面把键的类型写上就好，，&lt;/p&gt;
&lt;p&gt;好了，灌毒就到此为止了，，还是继续上代码吧，，&lt;/p&gt;

&lt;p&gt;首先，得写一个数据库操作的底层类&lt;strong&gt;DalService&lt;/strong&gt;又因为很多地方调用，所以，肯定是泛型，，&lt;/p&gt;
&lt;p&gt;然后为了解耦和方便注入，所以实现一个接口&lt;strong&gt;IDalService&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;我暂时只写了添加和查询的方法，，其他的方法可以自由发挥，，&lt;span&gt;不过记得先写接口，然后去实现接口中新加的方法&lt;/span&gt;，，不然无法使用的，，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('89cb15b1-1d18-4604-9190-23d967011fea')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_89cb15b1-1d18-4604-9190-23d967011fea&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_89cb15b1-1d18-4604-9190-23d967011fea&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('89cb15b1-1d18-4604-9190-23d967011fea',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_89cb15b1-1d18-4604-9190-23d967011fea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IDalService&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        T AddEntity(T entity);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         IQueryable&amp;lt;T&amp;gt; LoadEntites(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; SaveChanges();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IDalService&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e10a7996-5825-498e-b204-69464563887e')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e10a7996-5825-498e-b204-69464563887e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e10a7996-5825-498e-b204-69464563887e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e10a7996-5825-498e-b204-69464563887e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e10a7996-5825-498e-b204-69464563887e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据访问层：DAL
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DalService&amp;lt;T&amp;gt; : IDalService&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; DbContext DbWrite;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获得数据库上下文
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dbContext&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据库上下文类，各自更改成自己的&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DalService(DBCodeFirst dbContext)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             DbWrite =&lt;span&gt; dbContext;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T AddEntity(T entity)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             DbWrite.Set&amp;lt;T&amp;gt;&lt;span&gt;().Add(entity);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; entity;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IQueryable&amp;lt;T&amp;gt; LoadEntites(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; DbWrite.Set&amp;lt;T&amp;gt;().Where(&lt;span&gt;where&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; SaveChanges()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DbWrite.SaveChanges();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DalService&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后就没有DAL层啥事了，，咱们去看BLL层&lt;/p&gt;

&lt;p&gt;同样的写一个业务逻辑的父级类&lt;strong&gt;BllService&lt;/strong&gt;，依旧是泛型，以及实现接口&lt;strong&gt;IBllService&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('54893639-3385-4913-9614-a8eb21b20d45')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_54893639-3385-4913-9614-a8eb21b20d45&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_54893639-3385-4913-9614-a8eb21b20d45&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('54893639-3385-4913-9614-a8eb21b20d45',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_54893639-3385-4913-9614-a8eb21b20d45&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IBllService&amp;lt;T&amp;gt;&lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         T AddEntity(T entity,&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsSave);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         IQueryable&amp;lt;T&amp;gt; LoadEntites(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; SaveChanges();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IBllService&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('15bc8cac-546c-4e8f-96c5-9885754d3d48')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_15bc8cac-546c-4e8f-96c5-9885754d3d48&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_15bc8cac-546c-4e8f-96c5-9885754d3d48&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('15bc8cac-546c-4e8f-96c5-9885754d3d48',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_15bc8cac-546c-4e8f-96c5-9885754d3d48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据逻辑层：BLL
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BllService&amp;lt;T&amp;gt; : IBllService&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据库服务
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; IDalService&amp;lt;T&amp;gt;&lt;span&gt; DBService;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; BllService(IDalService&amp;lt;T&amp;gt;&lt;span&gt; dalService)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.DBService =&lt;span&gt; dalService;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 保存实体
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;entity&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;IsSave&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; T AddEntity(T entity, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsSave)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             entity =&lt;span&gt; DBService.AddEntity(entity);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IsSave)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; entity;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 查询数据
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;where&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IQueryable&amp;lt;T&amp;gt; LoadEntites(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; DBService.LoadEntites(&lt;span&gt;where&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 保存数据库
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; SaveChanges()
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DBService.SaveChanges();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BllService&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;然后基本就完成了，，我们可以在BLL层创建一个DT_User的逻辑处理类，&lt;strong&gt;继承BllService，并实现接口IDT_UserService&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f6e18dd4-da31-4324-811d-dde0a3d62726')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_f6e18dd4-da31-4324-811d-dde0a3d62726&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f6e18dd4-da31-4324-811d-dde0a3d62726&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f6e18dd4-da31-4324-811d-dde0a3d62726',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f6e18dd4-da31-4324-811d-dde0a3d62726&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IDT_UserService : IBllService&amp;lt;DT_User&amp;gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        DT_User Insert();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         List&amp;lt;DT_User&amp;gt;&lt;span&gt; GetList();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IDT_UserService&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('67190ebd-d8af-464a-9b2c-5e74ff4fe6cb')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_67190ebd-d8af-464a-9b2c-5e74ff4fe6cb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_67190ebd-d8af-464a-9b2c-5e74ff4fe6cb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('67190ebd-d8af-464a-9b2c-5e74ff4fe6cb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_67190ebd-d8af-464a-9b2c-5e74ff4fe6cb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DT_UserService : BllService&amp;lt;DT_User&amp;gt;&lt;span&gt;, IDT_UserService
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    { 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用于实例化父级，DBService变量
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dal&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; DT_UserService(IDalService&amp;lt;DT_User&amp;gt; dal) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(dal)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DT_User Insert()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             DT_User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DT_User
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 Password = &lt;span&gt;new&lt;/span&gt; Random().Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;101&lt;/span&gt;) + &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 UserName = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; AddEntity(user, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; List&amp;lt;DT_User&amp;gt;&lt;span&gt; GetList()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; LoadEntites(c =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;).ToList();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DT_UserService&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;最后使用的话，要把他们统统注册到服务里面，新建一个类&lt;strong&gt;DIBllRegister&lt;/strong&gt;，用来注册这些和数据库相关的服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0a7c28c6-3d79-4ff9-b47e-07374e0f5866')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_0a7c28c6-3d79-4ff9-b47e-07374e0f5866&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0a7c28c6-3d79-4ff9-b47e-07374e0f5866&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0a7c28c6-3d79-4ff9-b47e-07374e0f5866',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0a7c28c6-3d79-4ff9-b47e-07374e0f5866&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Bll层依赖注入
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DIBllRegister
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DIRegister(IServiceCollection services)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于实例化DalService对象，获取上下文对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             services.AddTransient(&lt;span&gt;typeof&lt;/span&gt;(IDalService&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(DalService&amp;lt;&amp;gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置一个依赖注入映射关系 &lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             services.AddTransient(&lt;span&gt;typeof&lt;/span&gt;(IDT_UserService), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DT_UserService));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DIBllRegister&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Startup的ConfigureServices方法中添加两行代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 运行时调用此方法。使用此方法向容器添加服务。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            services.AddOptions();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据库连接字符串&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; conStr = Config.GetVal&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(ConfigKey.ConStr);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             services.AddDbContext&amp;lt;DBCodeFirst&amp;gt;(options =&amp;gt;&lt;span&gt; options.UseSqlServer(conStr));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;strong&gt;&lt;span&gt;DIBllRegister bllRegister = new DIBllRegister();
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&lt;strong&gt;            bllRegister.DIRegister(services);
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            services.AddMvc();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后我们就可以愉快的使用三层架构来写项目了，，ヽ(≧∀≦)ﾉ&lt;/p&gt;
&lt;p&gt;示例以及项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/891962/201801/891962-20180107194940565-621689709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/891962/201801/891962-20180107195556409-1674835729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ol&gt;&lt;li&gt;&lt;span&gt;BLL层的类一定要&lt;strong&gt;继承BllService，并实现它对应的接口&lt;/strong&gt;，参考上文&lt;strong&gt;DT_UserService&lt;/strong&gt;类的格式&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;BLL，DAL任何类要添加方法时，一定要在对应的接口中有个同样的入口，不然无法调用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;BLL层添加类时，记得在&lt;strong&gt;DIBllRegister&lt;/strong&gt;的&lt;strong&gt;DIRegister&lt;/strong&gt;中添加一行注册服务的代码，不然无法调用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;差不多就这些，我想起来了再加，，，&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;其实这个是我从Framework搬过来的，心塞得简直不要不要的，，，填坑日记就不写出来了，，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的搭建思想也不太好用文字表述，大佬不要吐槽，萌新可以照着步骤去建一个小项目调试着看，，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人感觉还是比较好懂的，，毕竟，基本上全是核心代码还带注释，加一个使用样例，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后就是下集预告了，云服务器的FTP发布和数据库连接吧，，毕竟云服务器到手辣么久了，也该拉出来溜溜，，(❁´◡`❁)*✲ﾟ*&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，，有坑记得说，，，，&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 07 Jan 2018 12:29:00 +0000</pubDate>
<dc:creator>步尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Onlooker/p/8231522.html</dc:identifier>
</item>
<item>
<title>灵感：从想法的天空到现实的地面 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/8231380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/8231380.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/815275/201801/815275-20180107201202987-1284951541.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提及写作，就会有人拿灵感说事，比如：没有灵感，不知道写什么好。最近，读到一些关于灵感的文字，就整理了一下关于灵感的思绪，分享下我关于灵感的看法。大概有下面这些内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么说灵感重要，但实际并不是最重要的&lt;/li&gt;
&lt;li&gt;灵感于我们的现实生活有什么用吗？&lt;/li&gt;
&lt;li&gt;如何与灵感建立并保持长期的关系&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;天空&quot;&gt;天空&lt;/h2&gt;
&lt;p&gt;为什么我总觉得灵感是在天空中的？&lt;/p&gt;
&lt;p&gt;灵感，在英语中的单词是 Inspiration，另外还有一个更形象的词 Muse，这个词在中文有个说法，想必大家都挺熟悉的 —— 缪斯。缪斯来自音译，其源自希腊神话，是神话中女神的称号。其实，缪斯女神不是一个神，而是九位文艺女神的总称，她们分别主司不同的艺术门类。所以，我们就用了缪斯来指代灵感，而神什么的不都是住在天上的么。要获得灵感，就好像要得到女神的青睐，似乎是一件颇为困难的事情。&lt;/p&gt;
&lt;p&gt;但实际灵感的来源就在我们的日常生活中，我们每天读文、看书、观察、参会、交流、讨论甚至争论，很多时候似乎有那么一刻感觉获得了某种启悟，感觉闻 “道” 了。灵感就产生于我们每时每刻的 “呼吸” 中，吸入各种各样的思想与观点。&lt;/p&gt;
&lt;p&gt;但很多人都产生或经历过这样的 “灵感” 瞬间，然后慢慢就过去了，淡忘了。还记得我曾经翻译过的一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxMTEyOTQ5OQ==&amp;amp;mid=2650610873&amp;amp;idx=1&amp;amp;sn=d39efc55a4acc71114439b84c564c172&amp;amp;chksm=834c7b4db43bf25b09614bad98e062c3f7ef490ad006e8421c44171546350bcbcbef14ca226a#rd&quot;&gt;《三十秒的小习惯，一辈子的大影响》&lt;/a&gt;么？三十秒的小习惯，可以进一步扩大其应用场景，用来记录你的灵感瞬间。&lt;/p&gt;
&lt;p&gt;为什么要养成随时记录灵感瞬间的小习惯呢？从我开始写作以后，经常碰到这样的场景：有时突然碰到一件事，引发了另一个很好的想法，但有时一天忙碌过后忘了记下来，睡一觉起来发现完全想不起那一刻的想法是什么了，只知道感觉很棒，很重要，但就是想不起来，一种抓心的感觉。从此，我就开始养成记录并写下来的习惯了。&lt;/p&gt;
&lt;p&gt;有人会说，慢慢的记得多了，自己也不常看，也会忘记的，那还有用么？心理学的研究有个观点：仅仅是记录下来，即时后面全忘光了了，也比不记录有用。因为它依然对你的大脑产生了改变，你忘记了想不起来了，只是说明这种记录产生的影响不再存在于意识区，但可能还存在于潜意识区。所以，心理学有句话是这么说的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;潜意识负责做决定，意识负责找理由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话，我第一次听到，细思极恐。反思在一生的过程中，有多少次我们做出了一些莫名其妙的决策，事后却在不断的合理化这些决策。&lt;/p&gt;
&lt;p&gt;随时记录就是为了抓住那些在天空飘舞的灵感。&lt;/p&gt;
&lt;h2 id=&quot;地面&quot;&gt;地面&lt;/h2&gt;
&lt;p&gt;把灵感从天上抓下来后，有什么用？&lt;/p&gt;
&lt;p&gt;关于灵感，大众的意识中觉得只有从事艺术工作是需要的，比如像作家、音乐家之类的职业特别有用。除此之外，灵感在我们普通人的普通现实生活中还有什么用吗？其实，上文已经回答了一部分，仅仅是把灵感抓住，记录下来，就能对你的意识和潜意识发挥作用。这个层面，还是太抽象，我们具体点，先说个故事吧。&lt;/p&gt;
&lt;p&gt;大约半年前吧，去年年中，刚结束了年中大促，开始组织年中技术晋升的事情。程序员的技术晋升，其本质是一个关于成长与认可的事情。所以院长决定在晋升开始前，组织了一个会跟大家分享下关于成长的一些个人心得。&lt;/p&gt;
&lt;p&gt;会上说了很多，方方面面，我现在差不多都忘光了（我想现在属于潜意识还在发挥作用吧:）。但有个场景印象很深，院长进会场时，手上拿了一个厚厚的笔记本，中间谈到关于成长时，大概意思是说：成长就来自这里，并用手指着那个厚厚的笔记本。然后进一步解释说，在工作上一有什么想法就会记录在这个本上，这一本已经是第三本了，办公室的抽屉里还有写得满满的两本。&lt;/p&gt;
&lt;p&gt;时不时有空就拿出来翻翻看，看看曾经记录的想法，如今是否有了更深一层的洞见；看看曾经记录的问题，如今是否有了答案。我理解，这就是他的 “灵感簿”。他是一名技术领导者，而我最近刚看完一本写给技术领导者的书，里面总结了技术领导者的领导方式模型，可以概括为三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;M：激励 Motivation&lt;/li&gt;
&lt;li&gt;O：组织 Organization&lt;/li&gt;
&lt;li&gt;I：创新 Innovation / Ideas&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简称为 MOI 模型。模型就像一个 “类（Class）”，我们把它 “实例化（Instance）” 一下可能更好理解。套在程序员的工作中，为了提升软件交付的质量，作为技术领导者需要创造工具（创新 I），然后教人使用并说服他们尝试（激励 M），最后组织起一种结构体系（环境）来支持工具的使用者（组织 O）。而不同级别和层次的技术领导者，创造的工具形态和组织的结构体系是完全不同的。&lt;/p&gt;
&lt;p&gt;但总的来说，作为技术领导者，既是管理者也是创新者，工作需要有创新性，而所有创新性的工作都需要灵感。因而任何创新者要开展工作，我觉着他们都有一本自己的 “灵感簿”。程序员显然也属于创新者。&lt;/p&gt;
&lt;p&gt;院长可能属于比较怀旧老派（Old Fashion）的代表，喜欢用钢笔加纸质笔记本来记录灵感。而我的 “灵感簿” 则是电子化的笔记软件（Evernote）。任何时候，任何地方，都可以快速记录下来。另外还有一个优势是，记得多了可以辅助利用全文搜索来提取感觉还能想起一点点的内容。&lt;/p&gt;
&lt;p&gt;有了 “灵感簿” 才能与 “女神” 建立起长期关系。它就像一本魔法书， “灵感簿” 记录了召唤 “缪斯女神” 的咒语。召唤了灵感，要让其对你的现实生活更好的发挥作用，还需要魔法仪式。对于灵感与仪式，有一个关于毛姆（代表作《月亮与六便士》）的故事：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有人曾经问毛姆：“你是按照计划定时写作，还是只有感觉有灵感时才写？”。&lt;br/&gt;“我只有在灵感来时才会写”，毛姆回答道：“但幸运的是，她每天早晨九点准时到来。”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;明白了么，毛姆有他自己的办法与灵感建立了长期关系，每天早晨九点就是他和灵感一起准时开启写作的仪式。&lt;/p&gt;
&lt;p&gt;灵感只有附着在你真正的 “工作” 上才能发挥作用，给你带来变化。而这里的 “工作” 不仅仅是狭义的上班工作，指与你有关生活的输出，无论是个人的，还是商业的。当你真正开始坐下来开始 “工作” 时，想法自来，洞见伴生。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;飘在天空的灵感并不重要，重要的是怎样把灵感召唤下来落在现实的地面。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 12:17:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/8231380.html</dc:identifier>
</item>
<item>
<title>大数据学习系列之八----- Hadoop、Spark、HBase、Hive搭建环境遇到的错误以及解决方法 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/8231132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/8231132.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在搭建大数据Hadoop相关的环境时候，遇到很多了很多错误。我是个喜欢做笔记的人，这些错误基本都记载，并且将解决办法也写上了。因此写成博客，希望能够帮助那些搭建大数据环境的人解决问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;: 遇到的问题以及相应的解决办法是对于个人当时的环境，具体因人而异。如果碰到同样的问题，本博客的方法无法解决您的问题，请先检查环境配置问题。&lt;/p&gt;
&lt;h2 id=&quot;hadoop伪分布式相关的问题&quot;&gt;Hadoop伪分布式相关的问题&lt;/h2&gt;
&lt;h3 id=&quot;fatal-conf.configuration-error-parsing-conf-hdfs-site.xml&quot;&gt;1，FATAL conf.Configuration: error parsing conf hdfs-site.xml&lt;/h3&gt;
&lt;p&gt;原因: 字符编码问题。&lt;br/&gt;解决办法: 统一编码，将文件打开，另存为统一编码，如UTF-8 即可。&lt;/p&gt;
&lt;h3 id=&quot;use-of-this-script-to-execute-hdfs-command-is-deprecated&quot;&gt;2，Use of this script to execute hdfs command is deprecated。&lt;/h3&gt;
&lt;p&gt;原因:hadoop版本问题，命令过时。&lt;br/&gt;解决办法: 将hadoop命令改成hdfs。&lt;/p&gt;
&lt;h3 id=&quot;org.apache.hadoop.hdfs.server.namenode.namenode&quot;&gt;3，org.apache.hadoop.hdfs.server.namenode.NameNode。&lt;/h3&gt;
&lt;p&gt;原因:没有指定路径&lt;br/&gt;解决办法:修改hadoop-env.sh文件。安装的hadoop路径是“/usr/local/hadoop/hadoop-2.8.2”， 在此路径下执行 vim etc/hadoop/hadoop-env.sh 在文件最后面添加 export HADOOP_PREFIX=/usr/local/hadoop/hadoop-2.8.2 ，并保存。&lt;/p&gt;
&lt;h2 id=&quot;hadoop相关的错误&quot;&gt;Hadoop相关的错误&lt;/h2&gt;
&lt;h3 id=&quot;启动hadoop时候报错localhost-ssh-could-not-resolve-hostname-localhost-temporary-failure-in-name-resolution&quot;&gt;1，启动hadoop时候报错：localhost: ssh: Could not resolve hostname localhost: Temporary failure in name resolution”&lt;/h3&gt;
&lt;p&gt;原因: hadoop的环境没有配置好，或者没有使配置生效。&lt;br/&gt;解决办法: 如果没有配置Hadoop的环境变量，就填加配置。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/opt/java/jdk
export HADOOP_HOME=/opt/hadoop/hadoop2.8 
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native
export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib&quot;
export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使配置文件生效&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mkdir-userhivewarehouse-no-such-file-or-directory&quot;&gt;2，mkdir: `/user/hive/warehouse': No such file or directory&lt;/h3&gt;
&lt;p&gt;原因: 使用hadoop新建目录的时候报错，命名格式有问题&lt;br/&gt;解决办法: 输入正确的命令格式&lt;br/&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$HADOOP_HOME/bin/hadoop fs -mkdir -p /user/hive/warehouse&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bash...-is-a-directory&quot;&gt;3，bash:...： is a directory&lt;/h3&gt;
&lt;p&gt;原因:可能是/etc/profile 配置未能成功配置&lt;br/&gt;解决办法: 确认配置文件没有问题之后，发现环境变量后面多了空格，将环境变量后面的空格去掉之后就好了。&lt;/p&gt;
&lt;h3 id=&quot;hadoop警告unable-to-load-native-hadoop-library-for-your-platform...-using-builtin-java-classes-where-applicable&quot;&gt;4，Hadoop警告:Unable to load native-hadoop library for your platform... using builtin-java classes where applicable&lt;/h3&gt;
&lt;p&gt;原因:Apache提供的hadoop本地库是32位的，而在64位的服务器上就会有问题，因此需要自己编译64位的版本。&lt;br/&gt;解决办法:&lt;br/&gt;1.编译64位版本的lib包，可以使用这个网站提供的编译好的http://dl.bintray.com/sequenceiq/sequenceiq-bin/ 。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;将这个解压包解压到 hadoop/lib和hadoop/lib/native 目录下。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;设置环境变量，在/etc/profile中添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native  
export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib&quot;  &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;输入 hadoop checknative –a 检查&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考:&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/jack85986370/article/details/51902871&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/jack85986370/article/details/51902871&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;hadoop成功配置之后namenode没有成功启动&quot;&gt;5，hadoop成功配置之后，namenode没有成功启动。&lt;/h3&gt;
&lt;p&gt;原因:可能是hadoop的集群的配置不正确&lt;br/&gt;解决方案: 检查hadoop/ etc/hadoop 的主要配置文件是否正确配置。&lt;/p&gt;
&lt;h2 id=&quot;spark相关的错误&quot;&gt;Spark相关的错误&lt;/h2&gt;
&lt;h2 id=&quot;使用spark-sql的时候报错javax.jdo.jdofatalinternalexception-error-creating-transactional-connection-factory&quot;&gt;1，使用spark sql的时候报错:javax.jdo.JDOFatalInternalException: Error creating transactional connection factory&lt;/h2&gt;
&lt;p&gt;原因:可能是没有添加jdbc的驱动&lt;br/&gt;解决办法: Spark 中如果没有配置连接驱动，在spark/conf 目录下编辑spark-env.sh 添加驱动配置&lt;br/&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export SPARK_CLASSPATH=$SPARK_CLASSPATH:/opt/spark/spark2.2/jars/mysql-connector-java-5.1.41.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者在spark目录下直接加载驱动&lt;/p&gt;
&lt;p&gt;例如输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spark-sql --driver-class-path /opt/spark/spark2.2/jars/mysql-connector-java-5.1.41.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spark-sql-登录日志过多&quot;&gt;2， spark-sql 登录日志过多&lt;/h3&gt;
&lt;p&gt;原因: spark的日志级别设置为了INFO。&lt;br/&gt;解决办法:&lt;br/&gt;将日志级别改成WARN就行了。&lt;br/&gt;进入到spark目录/conf文件夹下，此时有一个log4j.properties.template文件，我们执行如下命令将其拷贝一份为log4j.properties，并对log4j.properties文件进行修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp log4j.properties.template log4j.properties
vim log4j.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;log4j.rootCategory=INFO, console&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;log4j.rootCategory=WARN, console&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spark-sql启动报错org.apache.spark.sql.hive.thriftserver.sparksqlclidriver&quot;&gt;3，spark sql启动报错:org.apache.spark.sql.hive.thriftserver.SparkSQLCLIDriver&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180107194021430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在spark/bin 目录下 修改spark-sql ，添加蓝色的字体的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export _SPARK_CMD_USAGE=&quot;Usage: ./bin/spark-sql [options] [cli option]&quot;
exec &quot;${SPARK_HOME}&quot;  /bin/spark-submit -jars /opt/spark/spark1.6-hadoop2.4-hive/lib/spark-assembly-1.6.3-hadoop2.4.0.jar --class org.apache.spark.sql.hive.thriftserver.SparkSQLCLIDriver &quot;$@&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180107194031850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hbase-相关的错误&quot;&gt;HBase 相关的错误&lt;/h2&gt;
&lt;h3 id=&quot;启动hbase错误--bash-opthbasehbase-1.2.6bin-is-a-directory&quot;&gt;1，启动HBase错误: -bash: /opt/hbase/hbase-1.2.6/bin: is a directory&lt;/h3&gt;
&lt;p&gt;原因:未输入正确的命令，或者Hadoop未能正确运行&lt;br/&gt;解决办法:&lt;br/&gt;首先检查命名格式是否正确，然后检查Hadoop是否成功运行。&lt;/p&gt;
&lt;h3 id=&quot;java-api-连接hbase-报错&quot;&gt;2，Java API 连接HBase 报错&lt;/h3&gt;
&lt;p&gt;org.apache.hadoop.hbase.client.RetriesExhaustedException: Failed after attempts=36, exceptions:&lt;br/&gt;Tue Jul 19 16:36:05 CST 2016, null, java.net.SocketTimeoutException: callTimeout=60000, callDuration=79721: row 'testtable,,' on table 'hbase:meta' at region=hbase:meta,,1.1588230740, hostname=ubuntu,16020,1468916750524, seqNum=0&lt;/p&gt;
&lt;p&gt;原因:可能是使用了主机名进行连接，而未载windows系统的hosts文件进行配置。&lt;br/&gt;解决办法:&lt;br/&gt;1.确认本地和集群服务之间的通信没有问题。&lt;br/&gt;2.修改 C:\Windows\System32\drivers\etc\hosts 的文件，添加集群的主机名和IP做映射。&lt;br/&gt;例如:&lt;br/&gt;192.169.0.23 master&lt;br/&gt;192.169.0.24 slave1&lt;br/&gt;192.169.0.25 slave2&lt;/p&gt;
&lt;h2 id=&quot;hive相关的错误&quot;&gt;Hive相关的错误&lt;/h2&gt;
&lt;h3 id=&quot;hive2-unable-to-instantiate-org.apache.hadoop.hive.ql.metadata.sessionhivemetastoreclient&quot;&gt;1，hive2: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient&lt;/h3&gt;
&lt;p&gt;原因: 无法连接元数据库，可能没有初始化元数据&lt;br/&gt;解决办法:初始化元数据&lt;br/&gt;输入: schematool -dbType mysql -initSchema&lt;br/&gt;然后在输入: hive&lt;/p&gt;
&lt;h3 id=&quot;进入hive警告class-path-contains-multiple-slf4j-bindings&quot;&gt;2，进入hive警告:Class path contains multiple SLF4J bindings&lt;/h3&gt;
&lt;p&gt;原因:日志文件冲突。&lt;br/&gt;解决办法: 移除其中的一个架包就可以了。&lt;br/&gt;例如:移除hive或hadooop相关的一个slf4j.jar就可以；&lt;/p&gt;
&lt;h3 id=&quot;java连接hive报错hive2-error-failed-to-open-new-session-java.lang.runtimeexceptionorg.apache.hadoop.ipc.remoteexc&quot;&gt;3，java连接hive报错:HIVE2 Error: Failed to open new session: java.lang.RuntimeException:org.apache.hadoop.ipc.RemoteExc&lt;/h3&gt;
&lt;p&gt;原因：没有设置远程连接权限。&lt;br/&gt;解决方案：在hadoop/conf/core-site.xml 中添加如下部分，重启服务即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;hadoop.proxyuser.root.hosts&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;*&amp;lt;/value&amp;gt;
 &amp;lt;/property&amp;gt;
 &amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;hadoop.proxyuser.root.groups&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;*&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;java连接hive报错hivejdbc-connection-refused&quot;&gt;4，java连接hive报错:hive:jdbc connection refused&lt;/h3&gt;
&lt;p&gt;原因:可能hive未启动或者配置未能正确配置&lt;br/&gt;解决办法：&lt;br/&gt;1.查看服务是否启动&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;netstat -anp |grep 10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看hive / conf/hive-site.xml配置是否正确，是否添加了这些配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property&amp;gt; 
       &amp;lt;name&amp;gt;hive.server2.thrift.port&amp;lt;/name&amp;gt; 
      &amp;lt;value&amp;gt;10000&amp;lt;/value&amp;gt; 
    &amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
       &amp;lt;name&amp;gt;hive.server2.thrift.bind.host&amp;lt;/name&amp;gt;
       &amp;lt;value&amp;gt;master&amp;lt;/value&amp;gt;
 &amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注: master是我配置主机的名称，可以替换成主机的IP。&lt;/p&gt;
&lt;p&gt;3.确认配置没有问题之后，输入hive --service hiveserver2 之后，在使用java连接测试。&lt;/p&gt;
&lt;h3 id=&quot;使用hive警告warn-conf.hiveconf-hiveconf-of-name-hive.metastore.local-does-not-exist&quot;&gt;5，使用hive警告:WARN conf.HiveConf: HiveConf of name hive.metastore.local does not exist&lt;/h3&gt;
&lt;p&gt;原因: Hive的这个配置在1.0之后就废除了。&lt;br/&gt;解决办法：&lt;br/&gt;在hive / conf/hive-site.xml 去掉这个配置就行了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;property&amp;gt;
         &amp;lt;name&amp;gt;hive.metastore.local&amp;lt;/name&amp;gt;
          &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
     &amp;lt;/property&amp;gt;     &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hive-on-spark报错exception-in-thread-main-java.lang.noclassdeffounderror-scalacollectioniterable&quot;&gt;6，Hive On Spark报错：Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: scala/collection/Iterable&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180107193841191?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;原因:缺少spark编译的jar包&lt;br/&gt;解决办法:&lt;br/&gt;我是使用的spark-hadoop-without-hive 的spark，如果使用的不是这种，可以自行编译spark-without-hive。&lt;br/&gt;1.将spark/lib 目录下的spark-assembly-1.6.3-hadoop2.4.0.jar 拷贝到hive/lib目录下。&lt;br/&gt;2.在hive/conf 中的hive-env.sh 设置该jar的路径。&lt;br/&gt;注:spark-assembly-1.6.3-hadoop2.4.0.jar 架包在spark-1.6.3-bin-hadoop2.4-without-hive 解压包中.&lt;/p&gt;
&lt;p&gt;下载地址:&lt;a href=&quot;http://mirror.bit.edu.cn/apache/spark&quot; class=&quot;uri&quot;&gt;http://mirror.bit.edu.cn/apache/spark&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;hive-使用spark引擎报错failedto-execute-spark-task-with-exceptionorg.apache.hadoop.hive.ql.metadata.hiveexceptionfailed-to-create-sparkclient.&quot;&gt;7, hive 使用spark引擎报错:Failedto execute spark task, with exception'org.apache.hadoop.hive.ql.metadata.HiveException(Failed to create sparkclient.)&lt;/h3&gt;
&lt;p&gt;原因:在使用Hive on Spark 执行查询命令的时候，出现这个错误。&lt;br/&gt;解决办法:&lt;br/&gt;1.检查hive和spark的版本是否正确，如果不相匹配，则配置相匹配的版本。&lt;br/&gt;2.编辑hive/conf 目录下的hive-site.xml 文件，添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property&amp;gt;
           &amp;lt;name&amp;gt;spark.master&amp;lt;/name&amp;gt;        
           &amp;lt;value&amp;gt;spark://hserver1:7077&amp;lt;/value&amp;gt;      
    &amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化hive元数据报错error-duplicate-key-name-pcs_stats_idx-state42000code1061&quot;&gt;8，初始化hive元数据报错:Error: Duplicate key name 'PCS_STATS_IDX' (state=42000,code=1061)&lt;/h3&gt;
&lt;p&gt;原因：这可能是metastore_db文件夹已经存在；&lt;br/&gt;解决办法: 删除该文件&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180107193928806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;hive-初始化元数据库报错&quot;&gt;9，hive 初始化元数据库报错:&lt;/h3&gt;
&lt;p&gt;org.apache.hadoop.hive.metastore.HiveMetaException: Failed to get schema version.&lt;br/&gt;Underlying cause: java.sql.SQLException : Access denied for user &lt;a href=&quot;mailto:'root'@'master&quot;&gt;'root'@'master&lt;/a&gt;' (using password: YES)&lt;br/&gt;SQL Error code: 1045&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180107194119542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因: 以为数据库连接用户名密码或权限问题，然而检查hive/hive-site.xml配置，和mysql设置的用户名和密码以及权限，都没问题。&lt;br/&gt;解决办法: 将hive/hive-site.xml连接数据库的别名改成ip地址就可以了。&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180107194126459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;hive使用mr进行关联查询报错failed-execution-error-return-code-2-from-org.apache.hadoop.hive.ql.exec.mr.mapredlocaltask&quot;&gt;9，hive使用mr进行关联查询报错:FAILED: Execution Error, return code 2 from org.apache.hadoop.hive.ql.exec.mr.MapredLocalTask&lt;/h3&gt;
&lt;p&gt;原因:内存太小了。&lt;br/&gt;解决办法:将mr内存设置大一点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set mapred.reduce.tasks = 2000;
set mapreduce.reduce.memory.mb=16384;
set mapreduce.reduce.java.opts=-Xmx16384m;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zookeeper相关的错误&quot;&gt;Zookeeper相关的错误&lt;/h3&gt;
&lt;h3 id=&quot;zookeeper集群启动之后输入status-报error-contacting-service.-it-is-probably-not-running.&quot;&gt;1，zookeeper集群启动之后输入status 报:Error contacting service. It is probably not running.&lt;/h3&gt;
&lt;p&gt;原因:可能是zoopkeeper集群未能成功配置以及相关的环境未配置好。&lt;br/&gt;解决办法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;集群成功配置并且启动成功后，检查集群中的防火墙是否关闭；&lt;br/&gt;2.检查myid和zoo.cfg文件配置格式是否正确，注意空格！！！&lt;br/&gt;3.输入jps查看zookeeper是否成功启动。&lt;br/&gt;4.zookeeper集群全部都启动成功之后，再输入zkServer.sh status 查看。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Zoo.cfg完整的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataDir=/opt/zookeeper/data
dataLogDir=/opt/zookeeper/dataLog
server.1=master:2888:3888
server.2=slave1:2888:3888
server.3=slave2:2888:3888&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;myid的配置为 1、2、3&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jan 2018 11:47:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/8231132.html</dc:identifier>
</item>
</channel>
</rss>