<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>决策树——Decision Tree - terieqin</title>
<link>http://www.cnblogs.com/terieqin/p/9275983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/terieqin/p/9275983.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;生活中有很多利用决策树的例子。西瓜书上给的例子是西瓜问题（讲到这突然想到书中不少西瓜的例子，难道这就是它西瓜封面的由来？）\。大致意思是，已经有一堆已知好瓜坏瓜的西瓜，每次挑取西瓜的一条属性，将西瓜进行分类。然后在分类的西瓜中，继续挑取下一条属性进行更加细致的划分，直到所有的属性被用完。&lt;/p&gt;
&lt;p&gt;这个例子有一个隐含的前提，就是给出所有的属性，它唯一地决定西瓜的好坏。意思是，不存在两个都是好瓜的瓜，或者都是坏瓜的瓜，它们的所有属性都相同。这有点类似数据库中的实体完整性。这样，你才能通过构建的决策树，按照它的用来分类的属性的顺序，每次前进一个分支，直到最后一层就能知道待测西瓜是否是好瓜。&lt;/p&gt;
&lt;p&gt;但是如果由许多瓜，有好瓜也有坏瓜，他们的属性都相同的时候，就意味着你沿决策树到达叶子节点的时候，面临多种选择。这时候，可以选择出现次数最多的瓜种作为结果返回。&lt;/p&gt;
&lt;p&gt;（这是用手机从西瓜书上拍下来的。结果上传的时候才发现忘记设置照片大小了，2M）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425654/201807/1425654-20180706233858204-2107998531.jpg&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;
&lt;p&gt;决策树的最关键的问题是，如何选择划分属性的顺序才能使得决策树的平均性能最好（即平均在树上走最少的路径就可以知道结果）。比如说，如果触感就能够唯一决定一个瓜是否是好坏，但是触感确实放在最后进行划分的，那么前面走的所有步骤都是多余的。如果一开始就用触感来进行划分，那么只需要走一步，就能够知道西瓜是否是好瓜。&lt;/p&gt;
&lt;p&gt;下面来解释一个概念，它能够决定用何种属性进行划分。&lt;/p&gt;
&lt;h2&gt;熵&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;划分数据集最大的原则就是：将无序的数据变得更加有序&lt;/strong&gt;。我们选取的是，能够将数据划分得“最有序”的属性。换句话说，选取能够给出最多信息的属性进行划分。打个比方，我要判断一个蚊子是否是母蚊子，你首先告诉我它有翅膀。可是所有的蚊子都有翅膀，这对我进行分类毫无意义，就称“有无翅膀”这一属性完全没有给出任何信息。如果你告诉我它经常在你身边上下腾飞骚扰你，那么我能够给出八成的可能说它是母蚊子，就说它给出了部分信息。你如果告诉我它会吸血，那母蚊子没跑了。“会不会吸血”这一属性给出了决定性的信息。&lt;/p&gt;
&lt;p&gt;熵（Entropy）定义为信息的期望值，它在物理学上表示物质的混乱程度。在信息学上可以作类比。熵增加，表示信息更加混乱，熵减，表示信息更加有序。假设划分之前，这堆西瓜的熵是$Ent(D)$，按照某种属性划分之后这堆西瓜的熵是$Ent(D')$，注意后者一定小于等于前者。否则划分就没有任何意义。这两者的差，就是这个属性对于这堆西瓜有序化的贡献。下面说明熵的计算方法：&lt;/p&gt;
&lt;p&gt;假设样本集$D$中，第$k$类样本所占的比例为$p_k$,那么$D$的熵：&lt;/p&gt;
&lt;p&gt;$Ent(D) = - \Sigma p_klog_2p_k$&lt;/p&gt;
&lt;p&gt;这里约定$p_k = 0$时，$p_klog_2p_k  = 0$。当这样本集被某个属性划分成$v$份之后，熵就是所有子集的熵的和：&lt;/p&gt;
&lt;p&gt;$Ent(D') = -\Sigma Ent(D^i) \ \  ,i = [1,...,v]$&lt;/p&gt;
&lt;p&gt;但是，每个样本子集中划分到的样本数量不一样，需要对每个子集的熵进行加权：&lt;/p&gt;
&lt;p&gt;$Ent(D') = -\Sigma \frac{|D^i|}{|D|}Ent(D^i) \ \  ,i = [1,...,v]$&lt;/p&gt;
&lt;p&gt;于是&lt;strong&gt;熵增&lt;/strong&gt;就定义为&lt;/p&gt;
&lt;p&gt;$Gain(D,a) = Ent(D) - Ent(D') = Ent(D) - \Sigma \frac{|D^i|}{|D|}Ent(D^i) \ \ ,i = [1,...,v]$&lt;/p&gt;
&lt;p&gt;表示，按照属性a对D进行划分熵的增益。显然，增益越大，表示越应该提前使用该属性进行划分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面给出计算熵增的python2.x 代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calcShannonEnt(dataSet):
    numEntries &lt;/span&gt;=&lt;span&gt; len(dataSet)
    labelCounts &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; featVec &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dataSet:
        currentLabel &lt;/span&gt;= featVec[-1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; currentLabel &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; labelCounts.keys():
            labelCounts[currentLabel] &lt;/span&gt;=&lt;span&gt; 0
        labelCounts[currentLabel] &lt;/span&gt;+= 1&lt;span&gt;
    shannonEnt &lt;/span&gt;= 0.0
    &lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; labelCounts:
        prob &lt;/span&gt;= float(labelCounts[key])/&lt;span&gt;numEntries
        shannonEnt &lt;/span&gt;-= prob*log(prob,2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; shannonEnt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的dataSet，由多个向量组成，每个向量代表一个样本。&lt;strong&gt;这里的向量的最后一个元素代表该样本的类别&lt;/strong&gt;。这不同于之前的KNN算法。KNN的类别和属性是分开表示的。&lt;/p&gt;
&lt;p&gt;第一个for循环计算每个类别的概率。第二个for循环计算熵。&lt;/p&gt;
&lt;h2&gt;决策树完整算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;样本集D，每个样本包含他们的属性（值）和类别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;决策树&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法描述：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择一个最好的划分属性&lt;/li&gt;
&lt;li&gt;用最好的属性划分D，并从属性列表中删除该属性。&lt;/li&gt;
&lt;li&gt;对每个子集，如果属性已经用完，返回类别标签。否则对每个子集，重复1步骤。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;python2.x 代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用坐标为axis的属性划分dataSet，将该属性的值等于value的样本返回。并且从样本中删除该属性&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; splitDataSet(dataSet,axis,value):
    retDataSet &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; featVec &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dataSet:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; featVec[axis] ==&lt;span&gt; value:
            reducedFeatVec &lt;/span&gt;=&lt;span&gt; featVec[:axis]
            reducedFeatVec.extend(featVec[axis&lt;/span&gt;+1&lt;span&gt;:])
            retDataSet.append(reducedFeatVec)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retDataSet

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择最好的划分属性，它返回的是属性在属性向量中的位置（坐标）&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; chooseBestFeatureToSplit(dataSet):
    numFeatures &lt;/span&gt;= len(dataSet[0]) - 1&lt;span&gt;
    baseEntropy &lt;/span&gt;=&lt;span&gt; calcShannonEnt(dataSet)
    bestInfoGain &lt;/span&gt;= 0.0&lt;span&gt;
    bestFeature &lt;/span&gt;= -1
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(numFeatures):
        featList &lt;/span&gt;= [example[i] &lt;span&gt;for&lt;/span&gt; example &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dataSet]
        uniqueVals &lt;/span&gt;=&lt;span&gt; set(featList)
        newEntropy &lt;/span&gt;= 0.0
        &lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; uniqueVals:
            subDataSet &lt;/span&gt;=&lt;span&gt; splitDataSet(dataSet,i,value)
            prob &lt;/span&gt;= len(subDataSet)/&lt;span&gt;float(len(dataSet))
            newEntropy &lt;/span&gt;+= prob *&lt;span&gt; calcShannonEnt(subDataSet)
        infoGain &lt;/span&gt;= baseEntropy -&lt;span&gt; newEntropy
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(infoGain&amp;gt;&lt;span&gt;bestInfoGain):
            bestInfoGain &lt;/span&gt;=&lt;span&gt; infoGain
            bestFeature &lt;/span&gt;=&lt;span&gt; i
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bestFeature

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; dataSet 中的向量包含了属性和类别&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; createTree(dataSet,labels):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取所有的类别&lt;/span&gt;
    classList = [example[-1] &lt;span&gt;for&lt;/span&gt; example &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dataSet]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果所有的类别都相同，就返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; classList.count(classList[0]) ==&lt;span&gt; len(classList):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; classList[0]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果dataSet中已经没有属性了，表示所有的属性已经被遍历完，就返回出现次数最多的属性&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; len(dataSet[0] == 1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; majorityCnt(classList)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择一个最好的划分属性&lt;/span&gt;
    bestFeat =&lt;span&gt; chooseBestFeatureToSplit(dataSet)

    bestFeatLabel &lt;/span&gt;=&lt;span&gt; labels[bestFeat]
    myTree &lt;/span&gt;=&lt;span&gt; {bestFeatLabel:{}}
    &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;(labels[bestFeat])
    featValues &lt;/span&gt;= [example[bestFeat] &lt;span&gt;for&lt;/span&gt; example &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dataSet]
    uniqueVals &lt;/span&gt;=&lt;span&gt; set(featValues)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; uniqueVals:
        subLabels &lt;/span&gt;=&lt;span&gt; labels[:]
        myTree[bestFeatLabel][value] &lt;/span&gt;=&lt;span&gt; createTree(splitDataSet(dataSet,bestFeat,value),subLabels)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; myTree

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; majorityCnt(classList):
    classCount&lt;/span&gt;=&lt;span&gt;{}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; vote &lt;span&gt;in&lt;/span&gt;&lt;span&gt; classList:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; vote &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; classCount.keys():classCount[vote] =&lt;span&gt; 0
        classCount[vote]&lt;/span&gt;+=1&lt;span&gt;
    sortedClassCount &lt;/span&gt;=&lt;span&gt; sorted(classCount.iteritems(),
                              key &lt;/span&gt;= operator.itemgetter(1),reverse =&lt;span&gt; True)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sortedClassCount[0][0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这里的决策树用的是python的字典嵌套来表示&lt;/strong&gt;。字典每一层的key由属性名和属性值交替，如果这一层的key是属性名，表示由该属性名进行划分，下一层的字典就是该属性的所有可能的取值。然后每一个对于每一个取值，再选一个属性名。如果没有属性名可选，最终的字典就是类别。具体的含义可以参考这篇博客：&lt;a href=&quot;https://blog.csdn.net/lilong117194/article/details/77033791&quot; target=&quot;_blank&quot;&gt;python中字典{}的嵌套。&lt;/a&gt;他里面用的例子刚好是这篇机器学习的代码。&lt;/p&gt;
&lt;p&gt;最后一个函数是为了解决叶子节点有多种结果情况。选择出现次数最多的结果返回。函数createTree中第二个参数labels是属性的名称，一般类型是字符串，比如‘色泽’，‘外观’，‘触感’之类的。而第一个参数dataSet中的属性是属性的值。&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;上述代码中构造的决策树是一个嵌套字典。具体如何使用，其实就是下标索引，在上面给出的博客中也有讲。&lt;/p&gt;
&lt;p&gt;决策树的构建过程耗时比较长，但是构建好之后测试样本就很快。他不同于上一篇的KNN，KNN每次需要测试样本的时候，都需要重新训练一次，即‘懒惰学习’。决策树只有在拿到新的训练样本的时候才需要训练，以后需要测试样本都可以调用已经构建好的决策树，即‘急切学习’。&lt;strong&gt;关于构建出来的用嵌套字典表示的决策树如何绘制出来和存储，在《机器学习实战》里面也有详细提到，分别用matplotlib和pickle库&lt;/strong&gt;。因为我这两个都不会用，python也是先学不到两周，还需要学习，所以就不搬运了。如果什么时候觉得这非常需要作篇博客以表学习，那到时就另起一篇，放在python分类中。&lt;/p&gt;
&lt;h2&gt;增益率&lt;/h2&gt;
&lt;p&gt;西瓜书还提到这个概念。&lt;/p&gt;
&lt;p&gt;是想，如果把训练样本的每一个样本都作编号，然后把编号也作为属性参与决策。通过计算，编号产生的信息熵增益达到0.998，远高于其他属性。这很好理解：每一个编号都产生一个分支，每个分支仅仅包含一个样本，这样就完全不需要考虑其他属性了。然而，这样的决策树并不具有泛化能力，无法对新样本做出有效预测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息增益准则对取值数目多的属性有偏好。&lt;/strong&gt;意思是，一个属性的取值越多，越有可能被选为当前最好的划分属性。为了解决这种偏好带来的不利映像，著名的C4.5决策树算法不直接使用信息增益，而是使用“增益率”来选择最优划分属性。增益率定义为：&lt;br/&gt;$Gain\_ratio(D,a) = \frac{Gain(D,a)}{IV(a)}$&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;$IV(a) = -\Sigma \frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}$&lt;/p&gt;
&lt;p&gt;$IV(a)$称为属性a的“固有值”。属性a的可能取值越多，固有值越大，增益率越小。可以看到，原本的信息增益使用属性的固有值进行了加权，消除了原本算法对取值数目多的属性的偏好带来的影响。&lt;/p&gt;
&lt;p&gt;西瓜书上还有一段：&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;增益率准则对可取值数目较少的属性有所偏好&lt;/strong&gt;，因此，C4.5算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。&lt;/p&gt;

</description>
<pubDate>Sat, 07 Jul 2018 07:49:00 +0000</pubDate>
<dc:creator>terieqin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/terieqin/p/9275983.html</dc:identifier>
</item>
<item>
<title>Python多线程 - makeJbzd</title>
<link>http://www.cnblogs.com/jbzd/p/9275351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jbzd/p/9275351.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;一：Python threading 模块&lt;/p&gt;
&lt;p&gt;线程的创建和调用方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一种&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; thrad_test(n):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是线程%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;n)
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式: threading.Thread(target=函数的名字, args=(函数参数1,函数参数2))&lt;/span&gt;
t1 = threading.Thread(target=thrad_test, args=(1,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建线程实例1&lt;/span&gt;
t2 = threading.Thread(target=thrad_test, args=(2,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建线程实例2&lt;/span&gt;
t3 = threading.Thread(target=thrad_test, args=(3,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建线程实例3&lt;/span&gt;
&lt;span&gt;
t1.start() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
t2.start() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
t3.start() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二种，继承式&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadCust(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,n):
        threading.Thread.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
        self.n &lt;/span&gt;=&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是线程%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.n)

t1 &lt;/span&gt;= ThreadCust(1&lt;span&gt;)
t2 &lt;/span&gt;= ThreadCust(2&lt;span&gt;)
t1.start()
t2.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二：join()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadCust(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,n):
        threading.Thread.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
        self.n &lt;/span&gt;=&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是编号[-%s-]线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.n)
        time.sleep(self.n) 
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是编号[-%s-]线程, 我运行结束了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.n)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是主线程，我开始创建子线程和运行子线程了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

t1 &lt;/span&gt;= ThreadCust(2&lt;span&gt;)
t2 &lt;/span&gt;= ThreadCust(5&lt;span&gt;)
t1.start() #start的作用是 主线程 启动子线程后，就扔给CPU了，不管了
t2.start()
t2.join()  &lt;br/&gt;# t2线程join()，那么则表示：必须得等待t2线程执行完成，主线程才能继续往下执行，作用是用来阻塞主线程的，要join()的子线程命令主线程等待一下
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;我是主线程，但我得等待编号[-5-]的线程工作完成了，才退出')
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# 加join()结果：&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;我是主线程，我开始创建子线程和运行子线程了&lt;br/&gt;我是编号[-2-]线程&lt;br/&gt;我是编号[-5-]线程&lt;br/&gt;我是编号[-2-]线程, 我运行结束了&lt;br/&gt;我是编号[-5-]线程, 我运行结束了&lt;/p&gt;
&lt;p&gt;我是主线程，但是我的得等待编号[-5-]的线程工作完成了，才退出&lt;/p&gt;

&lt;p&gt; --------------------------------------------分割线-------------------------------------------&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;# 不加join()的结果：&lt;/span&gt;&lt;br/&gt;print('我是主线程，我开始创建子线程和运行子线程了'&lt;span&gt;)
t1 = ThreadCust(2&lt;span&gt;)
t2 = ThreadCust(5&lt;span&gt;)
t1.start() #start的作用是 主线程 启动子线程后，就扔给CPU了，不管了
t2.start()
print('我是主线程，我的工作结束了。子线程儿子们，爸爸先走了')&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我是主线程，我开始创建子线程和运行子线程了&lt;br/&gt;我是编号[-2-]线程&lt;br/&gt;我是编号[-5-]线程&lt;br/&gt;我是主线程，我的工作结束了。子线程儿子们，爸爸先走了&lt;br/&gt;我是编号[-2-]线程, 我运行结束了&lt;br/&gt;我是编号[-5-]线程, 我运行结束了&lt;/p&gt;
&lt;p&gt; ####&lt;span&gt;由此说明：一个进程内总共有线程数量:  (一个主线程 + 创建子线程的数量) &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331204/201807/1331204-20180705114729077-79744831.png&quot; alt=&quot;&quot; width=&quot;240&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;p&gt;##小结：&lt;/p&gt;
&lt;p&gt;一个进程内必有一个主线程，主线程的作用是执行代码(线程也是代码)，创建的子线程由主线程运行后，子线程会自动的去执行它所需要执行的代码。另外，主线程从上到下的执行代码，它不管子线程运行的如何，子线程任务有没有运行完成，主线程都不管，但是如果某个子线程加了join()方法的话，那么就等于告诉主线程：主线程爸爸，你得等我执行结束了，你才能执行结束 - -！！！&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 第三: setDaemon 守护线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;span&gt;# setDaemon 守护线程，就是守护主线程，主线程结束，子线程也跟着结束。哪个线程设置了守护，那么哪个线程就跟主线程一起运行完毕(运行完毕，不是运行终止)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;# 设置了setDamon(True)的子线程， 等于告诉主线程：主线程爸爸，你跑(运行完毕)的时候带带我 - -！！！&lt;/span&gt;&lt;br/&gt;import threading,time&lt;br/&gt;class ThreadCust(threading.Thread):&lt;br/&gt;def __init__(self,n):&lt;br/&gt;threading.Thread.__init__(self)&lt;br/&gt;self.n = n&lt;br/&gt;def run(self):&lt;br/&gt;print('我是编号[-%s-]线程'%self.n)&lt;br/&gt;time.sleep(self.n)&lt;br/&gt;print('我是编号[-%s-]线程, 我运行结束了'%self.n)&lt;p&gt;print('我是主线程，我开始创建子线程儿子和运行子线程儿子了')&lt;br/&gt;thre_list = []&lt;br/&gt;t1 = ThreadCust(2)&lt;br/&gt;t2 = ThreadCust(5)&lt;br/&gt;thre_list.append(t1)&lt;br/&gt;thre_list.append(t2)&lt;br/&gt;t2.setDaemon(True)    # &lt;span&gt;设置守护线程时，必须要在start()的上面设置 seDamon(True),否则有报异常&lt;/span&gt;&lt;br/&gt;for t in thre_list:&lt;br/&gt;t.start()&lt;br/&gt;print('我是主线程，我的工作结束了')&lt;/p&gt;&lt;p&gt;#结果：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;我是主线程，我开始创建子线程儿子和运行子线程儿子了&lt;br/&gt;我是编号[-2-]线程&lt;br/&gt;我是编号[-5-]线程&lt;br/&gt;我是主线程，我的工作结束了&lt;br/&gt;我是编号[-2-]线程, 我运行结束了&lt;/p&gt;
&lt;p&gt;由结果得知：t2线程也就是编号为[-5-]，任务没有完成就跟着主线程执行完毕&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 第三：线程锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
#也叫互斥锁&lt;br/&gt;#问题的场景：一个进程可以拥有多个线程，&lt;span&gt;除主线程外&lt;/span&gt;，多个线程共享着进程的内存空间，&lt;br/&gt;这就相当于每个线程可以访问共同的一份数据。当一个以上的线程修改同一份数据的时候，&lt;br/&gt;　　就会产生严重的问题&lt;p&gt;#下面的例子是多个线程修改一个全局变量
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;16&quot;&gt;
import threading,time&lt;br/&gt;class ThreadCust(threading.Thread):&lt;br/&gt;def __init__(self,n):&lt;br/&gt;threading.Thread.__init__(self)&lt;br/&gt;self.n = n&lt;br/&gt;def run(self):&lt;br/&gt;global var&lt;br/&gt;print ('var:',var)&lt;br/&gt;time.sleep(1)&lt;br/&gt;var -= 1&lt;br/&gt;var = 100&lt;br/&gt;thre_list = []&lt;br/&gt;for i in range(3):     # 创建3个线程&lt;br/&gt;t = ThreadCust(i)&lt;br/&gt;t.start()&lt;br/&gt;t.join()&lt;br/&gt;print(var)          &lt;br/&gt;'''   &lt;br/&gt;# 它的正常结果应该是97，因为每个线程都执行 var - 1 操作，最后的结果可能是99、98、97等等，结果不确定性。&lt;br/&gt;　这是因为多个线程创建并运行的时候，&lt;br/&gt;　最先创建并运行的线程拿到的值可能是100，慢一点的线程拿到的值可能是99、98等，有非常大的不确定性。比如：&lt;br/&gt;　线程1、线程2、线程3由于创建的速度和运行的速度够快，几乎同时拿到 var = 100, 这样：&lt;p&gt;　　线程1的 var -= 1  那么就是 100-1=99，&lt;br/&gt;　　线程2的 var -= 1  那么就是 100-1=99，&lt;br/&gt;　　线程3的 var -= 1  那么就是 100-1=99&lt;br/&gt;　　                                   最终修改可能结果：99 ，正常结果是97&lt;/p&gt;&lt;p&gt;　或者这样：&lt;br/&gt;　　可能线程1创建最快，运行最快，那么可能最先成功修改了var的值，var -= 1 此时var等于99&lt;br/&gt;　　线程2 和 线程3 几乎同时快，同时拿到了线程1修改后的值(99)，此时：&lt;br/&gt;　　线程2 var -= 1 那么就是 99 - 1 &lt;br/&gt;　　线程3 var -= 1 那么就是 99 - 1&lt;br/&gt;　　                                   最终修改结果可能是98， 正常结果是97&lt;br/&gt;　或者再这样：&lt;br/&gt;　　线程1的速度 &amp;gt; 线程2的速度 &amp;gt; 线程3的速度&lt;br/&gt;　　var-1=99     var-1=98    var-1=97  最终结果：97 （正确）&lt;/p&gt;&lt;p&gt;&lt;span&gt;#注意：以上情况是属于比较理想的情况，依此类推，不理想的情况下，可能 线程1 比 线程3 的速度慢，线程2 比 线程1 的速度快&lt;br/&gt;等都有这种可能，&lt;br/&gt;　　并不是谁最先创建谁就有执行优先权的&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
'''
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331204/201807/1331204-20180706135039130-1738424616.png&quot; alt=&quot;&quot; width=&quot;833&quot; height=&quot;166&quot;/&gt;
&lt;pre&gt;
&lt;br/&gt;----------------------------------------分割线-------------------------------------------------&lt;br/&gt;解决以上的资源争夺问题：RLock，也叫递归锁
&lt;/pre&gt;
&lt;pre readability=&quot;10&quot;&gt;
import threading,time&lt;p&gt;class ThreadCust(threading.Thread):&lt;br/&gt;def __init__(self,n):&lt;br/&gt;threading.Thread.__init__(self)&lt;br/&gt;self.n = n&lt;br/&gt;def run(self):&lt;br/&gt;global var&lt;br/&gt;lock.acquire() #2. 线程开始锁住，至此，其他线程不得操作变量 var，&lt;br/&gt;　　　　　　　　　　　　　　　　必须得等到 得到此锁的线程修改完毕后 其他得到锁的线程才能修改&lt;br/&gt;print ('var:',var)&lt;br/&gt;time.sleep(1)&lt;br/&gt;var -= 1&lt;br/&gt;lock.release() #3. 锁释放锁&lt;br/&gt;var = 100&lt;br/&gt;thre_list = []&lt;br/&gt;lock = threading.RLock() #1. 生成一个锁&lt;br/&gt;for i in range(3):&lt;br/&gt;t = ThreadCust(i)&lt;br/&gt;t.start()&lt;br/&gt;t.join()&lt;br/&gt;print(var)        结果：97(正确)
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
# 假设线程1得到锁，那么线程2、线程3则不能动，谁得到锁谁就有运行到底的优先权，所以线程2和3只能静静的看着线程1在装B - -！！！&lt;br/&gt;&lt;span&gt;得到锁的情况，类似如下图：~~~~~~~~~~~~~~~~~~~~&lt;/span&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331204/201807/1331204-20180706062613568-1377284393.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;'''&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Python 至始至终，同一时刻只有一个线程在工作，这是由于python 的GIL 超级大锁所决定的，它的作用就是保证同一时间只有一个线程在干活和执行权限，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哪个线程拿到GIL的执行资格,然后加了一个 RLock()锁，那么哪个线程就有执行彻底的资格，即使中途其他线程也拿到了GIL，也会处于阻塞状态并交出执行权，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一直等到&lt;/span&gt;&lt;span&gt;RLock()的释放，其他线程才有运行的机会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;'''&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对比：在一个有超线程技术的双核四线程的处理器里，C++、Java可以做到一个物理核心并行两个线程，而Python始终只能运行一个线程，对CPU的极大浪费&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 第四：信号量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 有一个能容纳五个人的房间，门外有五把钥匙，谁拿到其中的一把，谁就能进去。当第六个人也想进去的时候，门口没了钥匙，他只能此时等待和排队，&lt;br/&gt;　　信号量也是如此，某些共享数据(比如全局变量)，只能供给固定数目的线程使用&lt;br/&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadCust(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,n):
        threading.Thread.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
        self.n &lt;/span&gt;=&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; var
        s.acquire() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2. 线程开始锁住&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,var)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        var &lt;/span&gt;-= 1&lt;span&gt;
        s.release() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 线程释放锁&lt;/span&gt;
var = 100&lt;span&gt;
thre_list &lt;/span&gt;=&lt;span&gt; []
s &lt;/span&gt;= threading.Semaphore(5)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 信号量，允许五个线程去操作共享的数据&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;): 
    t &lt;/span&gt;=&lt;span&gt; ThreadCust(i)
    t.start()
t.join()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(var)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第五：Event(事件)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;今天的作业有:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;作文一篇，800字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数学题60题&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; event状态设置为True,当前线程会被阻塞，阻塞池的其他线程将被激活处于就绪状态，等待操作系统调度&lt;/span&gt;
&lt;span&gt;        event.set()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始交作业&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        event.set()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; event状态为 Flase, 则阻塞当前线程，等待 event.set() 设置为 True 后，这边的线程才能被激活&lt;/span&gt;
&lt;span&gt;        event.wait()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业太多了，老师&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;3&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 恢复event 状态为 Flase&lt;/span&gt;
&lt;span&gt;        event.clear()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 又进入 阻塞状态，等待其他线程的 event.set()&lt;/span&gt;
&lt;span&gt;        event.wait()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业太多，做不完&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        event.clear()
thread_list &lt;/span&gt;=&lt;span&gt; []
event &lt;/span&gt;=&lt;span&gt; threading.Event()
tea &lt;/span&gt;=&lt;span&gt; Teacher()
tea.start()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
    stu &lt;/span&gt;=&lt;span readability=&quot;9&quot;&gt; Student()
    stu.start()

stu.join()&lt;p&gt;小结：&lt;br/&gt;# event.wait() : 如果event的状态为 Flase, 将阻塞当前线程,默认值是False&lt;br/&gt;# event.set() : 设置 event 的状态为 True, 所有阻塞池的线程被激活，进入就绪状态,等待操作系统调度&lt;br/&gt;# event.isSet() : 返回event的状态值&lt;br/&gt;# event.clear() :　　恢复event的值为False&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331204/201807/1331204-20180706195724517-1653443325.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第6：队列queue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_8c107773-48fa-4196-90a1-eea5eaa790c2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8c107773-48fa-4196-90a1-eea5eaa790c2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8c107773-48fa-4196-90a1-eea5eaa790c2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;queue队列的方法
import queue

# 队列种类
q1 &lt;/span&gt;= queue.Queue(maxsize=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) # 先进先出，参数为队列的长度,不写表示队列无限大
q2 &lt;/span&gt;= queue.LifoQueue(maxsize=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) # 先进后出，参数为队列的长度,不写表示队列无限大
q3 &lt;/span&gt;= queue.PriorityQueue(maxsize=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)

# 存值
q1.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) # 将值放入队列里
q1.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) # 将值放入队列里

# 取值
q1.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()# 从队列取元素
print(q1.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;())# 从队列取元素

# 其他方法
q1.qsize() # 返回队列大小
q1.empty() # 队列为空，返回True,否则 False
q1.full() # 队列是否已满，是，返回True, 否，返回False
q1.task_done() # 完成一项任务后，task_done() 向任务已经完成的队列发送一个信号
q1.join()  # 等到队列为空，再执行别的操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Queue&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331204/201807/1331204-20180707103031471-780346715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_5a4af496-d494-4ae5-a756-ae2b66fd2876&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5a4af496-d494-4ae5-a756-ae2b66fd2876&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5a4af496-d494-4ae5-a756-ae2b66fd2876&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import queue

q &lt;/span&gt;=&lt;span&gt; queue.Queue()
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

print(q.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) # tom
print(q.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) # jack
print(q.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;()) # zhangsan
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;先进先出&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 后进先出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331204/201807/1331204-20180707103615351-671664131.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_eb55bfdf-ba01-48e2-8f14-143a000e14c6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eb55bfdf-ba01-48e2-8f14-143a000e14c6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eb55bfdf-ba01-48e2-8f14-143a000e14c6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import queue

q &lt;/span&gt;=&lt;span&gt; queue.LifoQueue()
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

print(q.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) # zhangsan
print(q.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) # jack
print(q.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;()) # tom
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;后进先出，先进后出&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_b1a383ff-a8a5-4231-9ce6-f8d1bf850993&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b1a383ff-a8a5-4231-9ce6-f8d1bf850993&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b1a383ff-a8a5-4231-9ce6-f8d1bf850993&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import time, queue,threading,random


q &lt;/span&gt;=&lt;span&gt; queue.Queue()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueueThread(threading.Thread):
    def __init__(self, name):
        super().__init__()
        self.name &lt;/span&gt;=&lt;span&gt; name
    def run(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;正在做包子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            time.sleep(random.randrange(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
            bun &lt;/span&gt;= random.randrange(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
            print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大厨[-%s-]做了编号[-%s-]的包子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(self.name, bun))
            q.put(bun) # 将包子压入队列
            q.task_done() # 向正在 q.join()的线程发送信号:现在队列里有包子了，可以取了

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(threading.Thread):
    def __init__(self, name):
        super().__init__()
        self.name &lt;/span&gt;=&lt;span&gt; name
    def run(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            q.join()  # 等候task_done() 的通知。有通知将执行下面代码
            bun &lt;/span&gt;= q.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()
            print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;食客[-%s-]吃了编号[-%s-]的包子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(self.name,bun))
            time.sleep(random.randrange(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))

qt &lt;/span&gt;= QueueThread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;汉尼拔&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
per1 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;威尔&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
per2 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;史黛林&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
per3 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;斯大林&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
qt.start()
per1.start()
per2.start()
per3.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;生产者消费者&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_5cd1f937-7bad-43b8-8b7c-6094a90f4611&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5cd1f937-7bad-43b8-8b7c-6094a90f4611&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5cd1f937-7bad-43b8-8b7c-6094a90f4611&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import time, queue,threading,random
q1 &lt;/span&gt;=&lt;span&gt; queue.Queue()
q2 &lt;/span&gt;=&lt;span&gt; queue.Queue()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueueThread(threading.Thread):
    def __init__(self, name):
        super().__init__()
        self.name &lt;/span&gt;=&lt;span&gt; name
    def run(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大厨[-%s-]正在等候客人点单&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.name)
            q2.join()
            dish, guest &lt;/span&gt;= q2.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()
            print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大厨[-%s-]接收到客人[-%s-]点的[-%s-]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (self.name, guest, dish))
            q1.put(dish)  # 厨师做好菜了，将菜放入q1队列
            q1.task_done() # 通知菜已经做好了，可以取了

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(threading.Thread):
    def __init__(self, name):
        super().__init__()
        self.name &lt;/span&gt;=&lt;span&gt; name
    def run(self):

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.acquire()
            menu &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;宫保鸡丁&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;糖醋排骨&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红烧牛肉&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;大肠刺身&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] # 定义菜单
            dish &lt;/span&gt;= menu[random.randrange(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)] # 随机点菜
            time.sleep(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
            q2.put([dish, self.name]) # 将 客人 和 菜一起压入队列
            q2.task_done()            # 通知 q2 队列，有人点菜了
            q1.join()                 # 等候厨师做菜，厨师做好后，往下执行
            dish &lt;/span&gt;= q1.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()           # 取菜
            print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[-%s-]点的[-%s-]菜来了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (self.name, dish))
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; dish:
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.release()
                time.sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; =&lt;span&gt; threading.RLock()
qt &lt;/span&gt;= QueueThread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;汉尼拔&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
per1 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;威尔&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
per2 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;史黛林&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
per3 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;斯大林&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
qt.start()
per1.start()
per2.start()
per3.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;个性版生产者消费者&lt;/span&gt;&lt;/div&gt;































































































































&lt;p&gt;---恢复内容结束---&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;uploading_image_69258&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 07:38:00 +0000</pubDate>
<dc:creator>makeJbzd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jbzd/p/9275351.html</dc:identifier>
</item>
<item>
<title>Java复习2-对象与类 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/java-class.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/java-class.html</guid>
<description>&lt;p&gt;回顾基础知识过程中遇到的感觉需要记录一下的知识点。&lt;/p&gt;
&lt;h2 id=&quot;封装&quot;&gt;封装&lt;/h2&gt;
&lt;p&gt;我们设计的class应当尽可能的高内聚，体现为封装的程度。一个class的属性应该只能自己修改，其他class都只是与本class沟通，而不应该有能力修改。比较常见的一个问题是Date属性。&lt;/p&gt;
&lt;p&gt;业务开发中经常需要设计class的日期属性，比如birthday, createDate等。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {
    private String name;
    private Date birth;
    
    public Date getBirth() {
        return this.birth;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我经常设计一个entity，填入字段，然后就直接getter, setter出去，尤其使用lombok后，更是连生成都改自动了。按照封装的要求，这样的做法是不合适的。因为其他class可以获取Date对象，Date对象是可变的。那么，就有可能会产生日期被修改的可能。&lt;/p&gt;
&lt;p&gt;如果项目有引入Findbugs的扫描，这个class肯定会被扫描出来的，不应该返回一个可变对象。那么，怎么做才可以避免这个问题？我们确实需要暴露Date啊。&lt;/p&gt;
&lt;p&gt;答案是暴露一个不可变的对象。Java8推出了新的日期API，其中LocalDate就是不可变的。用LocalDate替换Date即可。LocalDate就像String一样，没有提供任何可以改变内部属性的方法，所有的修改之类的方法都将会创建一个新的对象。这样，修改操作将不会影响原来的class。&lt;/p&gt;
&lt;p&gt;Date对象可以解决，但很多是自己定义的对象，这个怎么办？比如，User有个属性是Role。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {
    private String name;
    private LocalDate birth;
    private Role role;
    
    public Role getRole() {
        return this.role;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和Date类似，当调用&lt;code&gt;getRole&lt;/code&gt;之后，外界如果可以修改role的属性，比如把role改成admin，那么本对象就拥有了admin权限了。这是我们不愿看到的。可以模仿LocalDate，把Role的所有修改内部属性的方法关闭。这样，外部无法修改Role，就不会影响到User了。然而，我们web中需要把对象渲染成json发送出去，jackson会根据getter setter去做序列化和反序列化操作。这个setter还不能关闭。&lt;/p&gt;
&lt;p&gt;那就只能处理User自己了。user唯一发生风险的地方在于getRole后，把自己内部属性暴露出去了。我们可以getRole的时候给一个新的出去，让其他class随便改都不会影响自己。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {
    private String name;
    private LocalDate birth;
    private Role role;
    
    public Role getRole() {
        return (Role) this.role.clone();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现实是，我们很少关注这样的做法，都是直接返回。而且，也很少遇到错误。这时候可以 忽略findbugs的异常。但，最好的，还是推荐做这样的修改。&lt;/p&gt;
&lt;h2 id=&quot;方法传参的按值调用&quot;&gt;方法传参的按值调用&lt;/h2&gt;
&lt;p&gt;初学Java的时候最容易搞不懂的地方就是传递参数到底是怎么传递的。&lt;/p&gt;
&lt;p&gt;在程序设计语言中有关将参数传递给方法(或函数)的一些专业术语。&lt;strong&gt;按值调用&lt;/strong&gt;(call by value)表示方法接收的是调用者提供的值。而&lt;strong&gt;按引用调用(call be reference)&lt;/strong&gt;表示方法接收的是调用者提供的&lt;strong&gt;变量地址&lt;/strong&gt;。一个方法可以&lt;strong&gt;修改&lt;/strong&gt;传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。&lt;strong&gt;按...调用(call by)&lt;/strong&gt;是一个标准的计算机科学术语，它用来描述各种程序设计语言(不只Java)中方法参数的传递方式。&lt;/p&gt;
&lt;p&gt;Java程序设计语言&lt;strong&gt;总是按值调用&lt;/strong&gt;。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a = 10;
addOne(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不管addOne方法具体实现，a最终依旧还是10. 因为当a传递给addOne方法的时候，拷贝了一份a的值给参数，方法中运行过程中都是一份拷贝，不会影响原来的变量。&lt;/p&gt;
&lt;p&gt;方法参数共有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本数据类型(数字、布尔值)&lt;/li&gt;
&lt;li&gt;对象引用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述demo显示一个方法不可能修改一个基本数据类型的参数。那么对象引用呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;StringBuilder sb = new StringBuilder();

appendOne(sb);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;appendOne执行过程中会对sb产生影响吗？&lt;/p&gt;
&lt;p&gt;这就要看具体方法内容了。比如&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void appendOne(StringBuilder sb) {
    sb.append(&quot;1&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，我们最终执行完结果肯定sb内容添加了1。而换一个方式，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void appendOne2(StringBuilder s){
    s = new StringBuilder();
    s.append(&quot;a&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，方法外面的sb的内容会变成什么？&lt;/p&gt;
&lt;p&gt;这个，首先要记住的是Java方法传参都只是传递拷贝。然后，明白传递拷贝的意义&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/2018/java/basic/method1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为s指向的地址和sb相同，故，当s.append的时候，sb的内容也会改变。这也上开头讲述的封装不应返回一个可变变量的原因。任何拿到这个可变变量地址的方法都可以直接修改变量里的属性。那方法2有什么不同？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/2018/java/basic/method2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法2中，把参数s指向了新地址，那么接下来的任何修改，都将不会影响旧地址。则方法外的sb对应的地址空间也就不会发生变化。这个可以理解为Java传递对象引用的时候只复制了对象引用的地址。&lt;/p&gt;
&lt;h2 id=&quot;类设计技巧&quot;&gt;类设计技巧&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;一定要保证数据私有，即封装性；&lt;/li&gt;
&lt;li&gt;一定要对数据初始化，最好不要依赖系统的默认值，自己给定一个初始值；&lt;/li&gt;
&lt;li&gt;不要在类中使用过多的基本类型，可以把相关的几个变量合成一个class，转为引用class，另外，能用包装类就不用基本类型；&lt;/li&gt;
&lt;li&gt;不是所有的成员变量都应该提供对外访问方法，比如创建日期不可以修改；&lt;/li&gt;
&lt;li&gt;将职责过多的类进行分解；&lt;/li&gt;
&lt;li&gt;类名和方法名要能够体现他们的职责；&lt;/li&gt;
&lt;li&gt;优先使用不可变的类。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 07 Jul 2018 07:34:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/java-class.html</dc:identifier>
</item>
<item>
<title>Oracle分区表删除分区引发错误ORA-01502: 索引或这类索引的分区处于不可用状态 - gegeman</title>
<link>http://www.cnblogs.com/lijiaman/p/9277149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiaman/p/9277149.html</guid>
<description>&lt;p&gt;&lt;strong&gt;（一）问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近在做Oracle数据清理，在对分区表进行数据清理时，采用的方法是drop partition，删除的过程中，没有遇到任何问题，大概过了10分钟，开发人员反馈部分分区表上的业务失败。具体错误为：&lt;/p&gt;
&lt;p&gt;ORA-01502错误：索引或这类索引的分区处于不可用状态（英文：ora-01502:index 'schema.index_name' or partition of such index is in unusable state）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（二）原因分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看出现问题的分区表，均有一个共同点：表上以“pk_”开头的索引为unusable状态，以“pk_”开头的索引是随创建主键约束而创建的。当用户在创建主键约束或唯一性约束的时候，会在相应的列上创建唯一性索引&lt;/p&gt;
&lt;p&gt;经过查证，&lt;strong&gt;发现是在删除分区的时候，导致分区表上的&lt;span&gt;唯一性全局索引&lt;/span&gt;为不可用状态，导致新的数据无法正常插入，从而引发了该错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是不是索引不可用会导致DML操作失败呢？经过验证，发现以下特点：&lt;/p&gt;
&lt;p&gt;1.对于&lt;strong&gt;非唯一性&lt;/strong&gt;索引，如果索引不可用，是不会影响到到DML操作的；&lt;/p&gt;
&lt;p&gt;2.对于&lt;strong&gt;唯一性&lt;/strong&gt;索引，如果索引不可用，在进行DML操作时，会触发ORA-01502错误；&lt;/p&gt;

&lt;p&gt;这里记录一下哪些操作会导致索引失效：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/823295/201807/823295-20180707141454626-1025330487.png&quot;&gt;&lt;img title=&quot;image&quot; border=&quot;0&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/823295/201807/823295-20180707141454946-881516393.png&quot; width=&quot;890&quot; height=&quot;276&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                                              &lt;/strong&gt;                图1.索引失效原因总结&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（三）解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3.1）了解&lt;/span&gt;唯一性索引&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在解决问题之前，我们来分析一下，哪些行为会创建唯一性索引(3种)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;--直接创建唯一性索引。&lt;/p&gt;
&lt;p&gt;     语法为：CREATE UNIQUE INDEX index_name on table_name(col1，col2,…);&lt;/p&gt;
&lt;p&gt;--创建主键约束时自动创建唯一性索引。&lt;/p&gt;
&lt;p&gt;     语法为：ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY(col1,col2,..);&lt;/p&gt;
&lt;p&gt;--创建唯一性约束时自动创建唯一性索引。&lt;/p&gt;
&lt;p&gt;     语法为：ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE(col1,col2,…);&lt;/p&gt;

&lt;p&gt;这里，我总结了3套方案来对应ORA-01502问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3.2）&lt;span&gt;方案一&lt;/span&gt;&lt;/span&gt;：删除唯一性索引&lt;/p&gt;
&lt;p&gt;与业务方面沟通，确认唯一性索引是否可以删除，如果可以，直接删除索引，删除语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; &lt;span&gt;schema&lt;/span&gt;.index_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于由主键约束或唯一性约束创建的唯一性索引，不能直接删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;drop&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt; lijiaman.sale_pk;
&lt;/span&gt;&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt; lijiaman.sale_pk

&lt;span&gt;ORA&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;02429&lt;/span&gt;: cannot &lt;span&gt;&lt;span&gt;drop&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;index&lt;/span&gt;&lt;/span&gt; used &lt;span&gt;&lt;span&gt;for&lt;/span&gt;&lt;/span&gt; enforcement &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;of&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;unique&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&lt;span&gt;primary&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;key&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正确的方法是删除相应的约束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; sales &lt;span&gt;drop&lt;/span&gt; &lt;span&gt;constraint&lt;/span&gt;&lt;span&gt; sale_pk;

&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt; altered
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;：该方法简单粗暴，前提是在约束或索引在业务方面可以删除的情况下才能使用。&lt;/p&gt;
&lt;p&gt;（3.3）&lt;span&gt;方案二&lt;/span&gt;：重建唯一性索引（针对非分区表）&lt;/p&gt;
&lt;p&gt;语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; [schema.]index_name REBUILD &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ONLINE&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;TABLESPACE tablespace name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;：该方法可以使索引可用。但对于分区表而言，依然存在问题：在下一次删除分区后，索引状态又会变为不可用。&lt;/p&gt;
&lt;p&gt;（3.4）&lt;span&gt;方案三&lt;/span&gt;：删除不可用的索引，创建唯一性分区索引（针对分区表）&lt;/p&gt;
&lt;p&gt;创建唯一性分区索引：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; index_name &lt;span&gt;on&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;schema.&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;(col1,col2,...);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于主键约束、唯一性约束，可以使用以下语法添加唯一性局部分区索引：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;schema.&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;table_name &lt;span&gt;ADD&lt;/span&gt; &lt;span&gt;CONSTRAINT&lt;/span&gt; constarint &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY KEY | UNIQUE&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(col1,col2)
     USING &lt;/span&gt;&lt;span&gt;INDEX&lt;/span&gt; LOCAL TABLESPACE tablespace_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;：该方法可以有效解决分区表因删除分区导致的索引不可用问题。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;附录：模拟实验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）首先模拟生产情况，创建一张表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; sales
(
  prod_id &lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;,
  cust_id &lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;,
  time_id date,
  quantity_sold &lt;/span&gt;&lt;span&gt;number&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
)
partition &lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt; range(time_id)
(
  partition sales_q1_2017 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1-4-2017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd-mm-yyyy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) ,
  partition sales_q2_2017 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1-7-2017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd-mm-yyyy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) ,
  partition sales_q3_2017 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1-10-2017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd-mm-yyyy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) ,
  partition sales_q4_2017 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1-1-2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd-mm-yyyy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入数据,确保每个分区都有数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-02-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-06-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-08-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-12-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查一下数据库的数据信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sales;        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;查看整个分区表的数据&lt;/span&gt;
&lt;span&gt;
   PROD_ID    CUST_ID TIME_ID     QUANTITY_SOLD
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------- ---------- ----------- -------------&lt;/span&gt;
         &lt;span&gt;1&lt;/span&gt;         &lt;span&gt;11&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;              &lt;span&gt;103&lt;/span&gt;
         &lt;span&gt;2&lt;/span&gt;         &lt;span&gt;12&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;              &lt;span&gt;103&lt;/span&gt;
         &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;14&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;              &lt;span&gt;103&lt;/span&gt;
         &lt;span&gt;4&lt;/span&gt;         &lt;span&gt;14&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;             &lt;span&gt;103&lt;/span&gt;&lt;span&gt;

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sales partition(sales_q1_2017);      &lt;span&gt;--&lt;/span&gt;&lt;span&gt;查看分区“sales_q1_2017”的数据&lt;/span&gt;
&lt;span&gt;
   PROD_ID    CUST_ID TIME_ID     QUANTITY_SOLD
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------- ---------- ----------- -------------&lt;/span&gt;
         &lt;span&gt;1&lt;/span&gt;         &lt;span&gt;11&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;              &lt;span&gt;103&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）由于出现ORA-01502问题时，与表相关的对象只有主键约束和索引。所以，我在表上创建了索引和约束，并确认了所有索引可用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; sales &lt;span&gt;add&lt;/span&gt; &lt;span&gt;constraint&lt;/span&gt; sale_pk &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;(time_id,cust_id);  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建主键约束&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; inx_sales_1 &lt;span&gt;on&lt;/span&gt; sales(cust_id);  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建普通(全局)索引&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; inx_sales_2 &lt;span&gt;on&lt;/span&gt; sales(time_id) local;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建局部分区索引&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认索引状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;   owner,table_name,index_name,status
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;&lt;span&gt;     dba_indexes
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt;    owner &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt;      table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SALES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

OWNER                          TABLE_NAME                     INDEX_NAME                     STATUS
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------- ------------------------------ ------------------------------ --------&lt;/span&gt;
LIJIAMAN                       SALES                          INX_SALES_2                    N&lt;span&gt;/&lt;/span&gt;&lt;span&gt;A
LIJIAMAN                       SALES                          SALE_PK                        VALID
LIJIAMAN                       SALES                          INX_SALES_1                    VALID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于索引“SALES_PK”和“INX_SALES_1”,索引状态为可用，那”INX_SALES_2“这个索引状态为”N/A“，这又是怎么回事么？经过查找资料，确认索引共有四种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;N/A         ：说明这个是&lt;strong&gt;分区&lt;/strong&gt;索引需要查user_ind_partitions或者user_ind_subpartitions来确定每个分区是否可用；&lt;/li&gt;
&lt;li&gt;VAILD      ：说明这个索引可用；&lt;/li&gt;
&lt;li&gt;UNUSABLE：说明这个索引不可用；&lt;/li&gt;
&lt;li&gt;USABLE    ：说明这个索引的&lt;strong&gt;分区&lt;/strong&gt;是可用的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们再去查看数据字典DBA_IND_PARTITIONS，确认”INX_SALES_2”的状态，索引可用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; INDEX_OWNER,INDEX_NAME,PARTITION_NAME,STATUS &lt;span&gt;FROM&lt;/span&gt; DBA_IND_PARTITIONS I &lt;span&gt;WHERE&lt;/span&gt; I.INDEX_OWNER &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; I.INDEX_NAME &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;INX_SALES_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

INDEX_OWNER                    INDEX_NAME                     PARTITION_NAME                 STATUS
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------- ------------------------------ ------------------------------ --------&lt;/span&gt;
&lt;span&gt;LIJIAMAN                       INX_SALES_2                    SALES_Q1_2017                  USABLE
LIJIAMAN                       INX_SALES_2                    SALES_Q2_2017                  USABLE
LIJIAMAN                       INX_SALES_2                    SALES_Q3_2017                  USABLE
LIJIAMAN                       INX_SALES_2                    SALES_Q4_2017                  USABLE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认主键约束的状态,确认可用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;   owner,table_name,constraint_name,constraint_type,status,deferrable,deferred,validated
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;&lt;span&gt;     dba_constraints
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt;    owner &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt;      table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SALES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

OWNER     TABLE_NAME   CONSTRAINT_NAME   CONSTRAINT_TYPE STATUS   DEFERRABLE     DEFERRED  VALIDATED
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------- ------------ ----------------- --------------- -------- -------------- --------- -------------&lt;/span&gt;
LIJIAMAN  SALES        SALE_PK           P               &lt;strong&gt;ENABLED&lt;/strong&gt;  &lt;span&gt;NOT&lt;/span&gt; DEFERRABLE IMMEDIATE VALIDATED
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）接下来，我们模拟数据清理，删除分区”sales_q1_2017“&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; sales &lt;span&gt;drop&lt;/span&gt;&lt;span&gt; partition sales_q1_2017 ;

&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt; altered
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看分区表的数据，可以看到，分区”sales_q1_2017“的数据已经随着分区被删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; sales;

   PROD_ID    CUST_ID TIME_ID     QUANTITY_SOLD
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------- ---------- ----------- -------------&lt;/span&gt;
         &lt;span&gt;2&lt;/span&gt;         &lt;span&gt;12&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;              &lt;span&gt;103&lt;/span&gt;
         &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;14&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;              &lt;span&gt;103&lt;/span&gt;
         &lt;span&gt;4&lt;/span&gt;         &lt;span&gt;14&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;             &lt;span&gt;103&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;==================转折点==========================&lt;/p&gt;

&lt;p&gt;（4）此时，我们模拟正常的业务交易，发现如下情况&lt;/p&gt;
&lt;p&gt;    --对于insert操作，无法完成，报ORA-01502错误；&lt;/p&gt;
&lt;p&gt;    --对于delete操作，无法完成，报ORA-01502错误；&lt;/p&gt;
&lt;p&gt;    --对于update操作，如果不涉及到主键相关的列，则可以执行成功，如果涉及到主键列，报ORA-01502错误；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;数据插入测试，发现无法插入数据&lt;/span&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-8-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-8-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;)
&lt;strong&gt;ORA&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01502&lt;/span&gt;: &lt;span&gt;index&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN.SALE_PK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; partition &lt;span&gt;of&lt;/span&gt; such &lt;span&gt;index&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; unusable state&lt;/strong&gt;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;数据删除测试，发现无法删除数据&lt;/span&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sales &lt;span&gt;where&lt;/span&gt; prod_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sales &lt;span&gt;where&lt;/span&gt; prod_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
&lt;strong&gt;ORA&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01502&lt;/span&gt;: &lt;span&gt;index&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN.SALE_PK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; partition &lt;span&gt;of&lt;/span&gt; such &lt;span&gt;index&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; unusable state&lt;/strong&gt;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;数据跟新测试，测试3次，发现涉及到与主键相关的列，就会更新失败，其他情况更新成功&lt;/span&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; QUANTITY_SOLD &lt;span&gt;=&lt;/span&gt; &lt;span&gt;105&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row updated
SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;commit&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;Commit&lt;/span&gt;&lt;span&gt; complete

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; QUANTITY_SOLD &lt;span&gt;=&lt;/span&gt; &lt;span&gt;105&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row updated
SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;commit&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;Commit&lt;/span&gt;&lt;span&gt; complete

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
&lt;strong&gt;ORA&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01502&lt;/span&gt;: &lt;span&gt;index&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN.SALE_PK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; partition &lt;span&gt;of&lt;/span&gt; such &lt;span&gt;index&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; unusable state&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次确认，索引的状态，可以看到，普通索引状态已经转变为不可用，而局部分区索引状态未发生改变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;   owner,table_name,index_name,status
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;&lt;span&gt;     dba_indexes
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt;    owner &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt;      table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SALES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

OWNER                          TABLE_NAME                     INDEX_NAME                     STATUS
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------- ------------------------------ ------------------------------ --------&lt;/span&gt;
LIJIAMAN                       SALES                          INX_SALES_2                    N&lt;span&gt;/&lt;/span&gt;&lt;span&gt;A
LIJIAMAN                       SALES                          SALE_PK                        UNUSABLE
LIJIAMAN                       SALES                          INX_SALES_1                    UNUSABLE


SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; INDEX_OWNER,INDEX_NAME,PARTITION_NAME,STATUS &lt;span&gt;FROM&lt;/span&gt; DBA_IND_PARTITIONS I &lt;span&gt;WHERE&lt;/span&gt; I.INDEX_OWNER &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; I.INDEX_NAME &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;INX_SALES_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

INDEX_OWNER                    INDEX_NAME                     PARTITION_NAME                 STATUS
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------- ------------------------------ ------------------------------ --------&lt;/span&gt;
&lt;span&gt;LIJIAMAN                       INX_SALES_2                    SALES_Q2_2017                  USABLE
LIJIAMAN                       INX_SALES_2                    SALES_Q3_2017                  USABLE
LIJIAMAN                       INX_SALES_2                    SALES_Q4_2017                  USABLE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主键约束状态也为发生改变&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;OWNER      TABLE_NAME   CONSTRAINT_NAME  CONSTRAINT_TYPE STATUS   DEFERRABLE     DEFERRED  VALIDATED
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------- ------------ ---------------- --------------- -------- -------------- --------- -------------&lt;/span&gt;
LIJIAMAN   SALES        SALE_PK          P               ENABLED  &lt;span&gt;NOT&lt;/span&gt; DEFERRABLE IMMEDIATE VALIDATED
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，我们对deop分区前后表的信息对比做一个小结&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;800&quot; border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;删除分区前&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;删除分区后&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;查询（select）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;正常&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;正常&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;插入（insert）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;正常&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;无法插入&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;删除（delete）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;正常&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;无法删除&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;更新（update）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;正常&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;设计到主键相关的列，更新失败，其他情况更新成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;约束状态（constraint）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;可用&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;可用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;索引状态（index）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;全部可用&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;318&quot;&gt;1.分区索引可用&lt;br/&gt;&lt;span&gt;2.主键约束上的唯一性索引不可用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.普通索引不可用&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;通过对比，我们可以推测，索引不可用导致了无法正常DML操作。那么到底是哪个索引导致的问题呢？&lt;/p&gt;
&lt;p&gt;（5）首先测试普通索引，先重建索引INX_SALES_1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt; lijiaman.inx_sales_1 rebuild;

&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt; altered

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;   owner,table_name,index_name,status
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;&lt;span&gt;     dba_indexes
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt;    owner &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt;      table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SALES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

OWNER                          TABLE_NAME                     INDEX_NAME                     STATUS
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------- ------------------------------ ------------------------------ --------&lt;/span&gt;
LIJIAMAN                       SALES                          INX_SALES_2                    N&lt;span&gt;/&lt;/span&gt;&lt;span&gt;A
LIJIAMAN                       SALES                          SALE_PK                        UNUSABLE
LIJIAMAN                       SALES                          INX_SALES_1                    VALID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续模拟DML交易,情况与删除分区后的DML结果相同，可以确认，&lt;strong&gt;普通索引不可用并不会引起DML操作失败&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;数据依然无法插入&lt;/span&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-8-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-8-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;)
ORA&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01502&lt;/span&gt;: &lt;span&gt;index&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN.SALE_PK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; partition &lt;span&gt;of&lt;/span&gt; such &lt;span&gt;index&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; unusable state

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;数据无法删除&lt;/span&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sales &lt;span&gt;where&lt;/span&gt; prod_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sales &lt;span&gt;where&lt;/span&gt; prod_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
ORA&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01502&lt;/span&gt;: &lt;span&gt;index&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN.SALE_PK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; partition &lt;span&gt;of&lt;/span&gt; such &lt;span&gt;index&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; unusable state

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;如果没有更新到逐渐相关列，可以更新数据，否则不行&lt;/span&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; QUANTITY_SOLD &lt;span&gt;=&lt;/span&gt; &lt;span&gt;105&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row updated

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; QUANTITY_SOLD &lt;span&gt;=&lt;/span&gt; &lt;span&gt;105&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row updated

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
ORA&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01502&lt;/span&gt;: &lt;span&gt;index&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN.SALE_PK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; partition &lt;span&gt;of&lt;/span&gt; such &lt;span&gt;index&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; unusable state
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）接着重建唯一性索引”SALE_PK”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt; lijiaman.sale_pk rebuild;

&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt; altered
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对SALES表进行DML操作，可以正常进行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; sales(prod_id,cust_id,time_id,quantity_sold)&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-8-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;103&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row inserted

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sales &lt;span&gt;where&lt;/span&gt; prod_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row deleted

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; QUANTITY_SOLD &lt;span&gt;=&lt;/span&gt; &lt;span&gt;105&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row updated

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; QUANTITY_SOLD &lt;span&gt;=&lt;/span&gt; &lt;span&gt;105&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row updated

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; sales &lt;span&gt;set&lt;/span&gt; cust_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; PROD_ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; row updated

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;commit&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;Commit&lt;/span&gt; complete
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，&lt;strong&gt;我们可以大胆猜测：唯一性索引导致的ORA-01502问题。&lt;/strong&gt;由于我们在创建索引的时候，并未直接创建唯一性索引，而是在创建主键约束的时候自动创建的唯一性索引，那么到底是主键约束的问题，还是唯一性索引的问题？根据上面删除分区前后约束状态相同，而索引状态不同，我觉得是索引的问题&lt;strong&gt;。&lt;/strong&gt;继续求证。我们新建一个表，在上面直接创建唯一性索引，不创建任何约束。&lt;/p&gt;
&lt;p&gt;创建表test01,录入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; test01;

        ID NAME                        AGE
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------- -------------------- ----------&lt;/span&gt;
         &lt;span&gt;1&lt;/span&gt;&lt;span&gt; lijiaman             
         &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; gegeman                      &lt;span&gt;25&lt;/span&gt;
         &lt;span&gt;3&lt;/span&gt; xiaoman                      &lt;span&gt;26&lt;/span&gt;
         &lt;span&gt;4&lt;/span&gt; Lijiaman                     &lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在“ID”列创建唯一性索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;unique&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; inx_test01 &lt;span&gt;on&lt;/span&gt;&lt;span&gt; test01(id);

&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt; created


SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; table_owner,index_name,index_type,uniqueness,status
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;&lt;span&gt;   user_indexes
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt;  table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TEST01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

TABLE_OWNER                    INDEX_NAME                     INDEX_TYPE                  UNIQUENESS STATUS
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------- ------------------------------ --------------------------- ---------- --------&lt;/span&gt;
LIJIAMAN                       INX_TEST01                     NORMAL                      &lt;span&gt;UNIQUE&lt;/span&gt;     VALID
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入数据，没有异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test01 &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bokeyuan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row inserted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着将索引置为不可用状态，然后往表里面插入数据，出现了01502错误；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
SQL&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; lijiaman.inx_test01 unusable;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;将索引置为不可用状态&lt;/span&gt;
&lt;span&gt;Index&lt;/span&gt;&lt;span&gt; altered

SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; table_owner,index_name,index_type,uniqueness,status
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;&lt;span&gt;   user_indexes
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt;  table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TEST01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

TABLE_OWNER                    INDEX_NAME                     INDEX_TYPE                  UNIQUENESS STATUS
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------- ------------------------------ --------------------------- ---------- --------&lt;/span&gt;
LIJIAMAN                       INX_TEST01                     NORMAL                      &lt;span&gt;UNIQUE&lt;/span&gt;&lt;span&gt;     UNUSABLE


SQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test01 &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bokeyuan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;);    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;插入数据，发生ORA-01502错误&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test01 &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bokeyuan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;&lt;span&gt;)
ORA&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01502&lt;/span&gt;: &lt;span&gt;index&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN.INX_TEST01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; partition &lt;span&gt;of&lt;/span&gt; such &lt;span&gt;index&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; unusable state
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此可以明确的说：&lt;strong&gt;ORA-01512错误是由于唯一性索引失效导致的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何解决这个问题，前面给出了3种方案，只要选择其中一种即可，不再模拟。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 06:15:00 +0000</pubDate>
<dc:creator>gegeman</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiaman/p/9277149.html</dc:identifier>
</item>
<item>
<title>我的FP感悟 - 旻天clock</title>
<link>http://www.cnblogs.com/clockq/p/9277110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clockq/p/9277110.html</guid>
<description>&lt;h2 id=&quot;我主要总结了以下5点&quot;&gt;我主要总结了以下5点:&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;函数是一等公民: 函数的参数是函数,返回值是函数,类型还是函数...&lt;/li&gt;
&lt;li&gt;舍弃语句,拥抱表达式: 表达式就一定有返回值&lt;/li&gt;
&lt;li&gt;无副作用: 不修改外部闭包的状态.&lt;/li&gt;
&lt;li&gt;immutable: 没有变量,一切不可变,循环递归实现&lt;/li&gt;
&lt;li&gt;引用透明: 程序的运行不依赖状态,不必包.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就以上几点,我编了一首打油诗:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;函数编程很强大
一等公民都是它
外部变量不依赖
返回确保串行化&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;串行化什么意思呢?&lt;br/&gt;同样计算&lt;code&gt;(1+2)*3/4&lt;/code&gt;,java代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a = 1 + 2
int b = a * 3
int c = b / 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而Scala写出来如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val r = subtract(multiply(add(1, 2), 3), 4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此,就可以很简单的改写为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val r = add(1, 2).multiply(3).subtract(4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的美妙自己体会吧~~~&lt;/p&gt;
&lt;h2 id=&quot;那么这么做的意义呢&quot;&gt;那么这么做的意义呢?&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;代码简洁&lt;/li&gt;
&lt;li&gt;接近自然语言&lt;/li&gt;
&lt;li&gt;函数单纯,易于测试&lt;/li&gt;
&lt;li&gt;immutable,并发简单可控&lt;/li&gt;
&lt;li&gt;热升级&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;如果代码包含了任何的var，则是指令式风格，如果全是val则是函数式风格。&lt;/li&gt;
&lt;li&gt;函数的结果类型是Unti的是有副作用的，而结果类型有明确返回类型的则是没有副作用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有机会看到这篇文章的读者，大概都会知道阿兰·图灵（Alan Turing）和约翰·冯·诺伊曼（John von Neumann）。阿兰·图灵提出了图灵机的概念，约翰·冯·诺伊曼基于这一理论，设计出了第一台现代计算机。&lt;/p&gt;
&lt;p&gt;由于图灵以及冯·诺伊曼式计算机的大获成功，历史差点淹没了另外一位同样杰出的科学家和他的理论，那就是阿隆佐·邱奇（Alonzo Church）和他的λ演算。&lt;/p&gt;
&lt;p&gt;阿隆佐·邱奇是阿兰·图灵的老师，上世纪三十年代，他们一起在普林斯顿研究可计算性问题，为了回答这一问题，阿隆佐·邱奇提出了λ演算，其后不久，阿兰·图灵提出了图灵机的概念，尽管形式不同，但后来证明，两个理论在功能上是等价的，条条大路通罗马。&lt;/p&gt;
&lt;p&gt;如果不是约翰·麦卡锡（John McCarthy），阿隆佐·邱奇的λ演算恐怕还要在历史的故纸堆中再多躺几十年，约翰·麦卡锡是人工智能科学的奠基人之一，他发现了λ演算的珍贵价值，发明了基于λ演算的函数式编程语言：Lisp，由于其强大的表达能力，一推出就受到学术界的热烈欢迎，以至于一段时间内，Lisp 成了人工智能领域的标准编程语言。&lt;/p&gt;
&lt;p&gt;很快，λ演算在学术界流行开来，出现了很多函数式编程语言：Scheme 、SML、Ocaml 等，但是在工业界，还是命令式编程语言的天下，Fortran、C、C++、Java 等。&lt;/p&gt;
&lt;p&gt;随着时间的流逝，越来越多的计算机从业人员认识到函数式编程的意义，爱立信公司于上世纪八十年代开发出了 Erlang 语言来解决并发编程的问题；&lt;br/&gt;在互联网的发展浪潮中，越来越多的语言也开始支持函数式编程：JavaScript、Python、Ruby、Haskell、Scala 等。&lt;/p&gt;
&lt;p&gt;可以预见，如果过去找一个懂什么是函数式编程的程序员很困难，那么在不久的将来，找一个一点也没听过函数式编程的程序员将更加困难。&lt;/p&gt;

&lt;p&gt;对于面向对象,我们已经再熟悉不过了,所以这里不做过多介绍,直接分析它的优缺点.&lt;/p&gt;
&lt;h2 id=&quot;面向对象编程的优点&quot;&gt;面向对象编程的优点&lt;/h2&gt;
&lt;p&gt;面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想(抽象现实世界)，这与传统的思想刚好相反。&lt;/p&gt;
&lt;p&gt;传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。&lt;/p&gt;
&lt;p&gt;面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。&lt;/p&gt;
&lt;p&gt;目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。&lt;/p&gt;
&lt;p&gt;此外，支持者声称面向对象程序设计要比以往的做法更加==便于学习==(所以易于推广)，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。&lt;/p&gt;
&lt;p&gt;同时它也是易拓展的，由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。&lt;/p&gt;
&lt;p&gt;在面向对象编程的基础上发展出来的23种设计模式广泛应用于现今的软件工程中，极大方便了代码的书写与维护。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。&lt;/li&gt;
&lt;li&gt;结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。&lt;/li&gt;
&lt;li&gt;行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;面向对象编程的缺点&quot;&gt;面向对象编程的缺点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;(多并发问题)面向对象编程以数据为核心，所以在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。&lt;/li&gt;
&lt;li&gt;在现在的软件工程中，由于面向对象编程的滥用，导致了很多问题。
&lt;ul&gt;&lt;li&gt;(冗余度大)首先就是为了写可重用的代码而产生了很多无用的代码，导致代码膨胀.&lt;/li&gt;
&lt;li&gt;(难理解,难维护)同时很多人并没有完全理解面向对象思想，为了面向对象而面向对象，使得最终的代码晦涩难懂，给后期的维护带来了很大的问题。&lt;/li&gt;
&lt;li&gt;(大型系统不适应)所以对于大项目的开发，使用面向对象会出现一些不适应的情况。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;(低效率)面向对象虽然开发效率高但是代码的运行效率比起面向过程要低很多，这也限制了面向对象的使用场景不能包括那些对性能要求很苛刻的地方。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;下面我们在看看函数式编程(FP)&lt;/p&gt;

&lt;p&gt;狭义地说，函数式编程没有可变的变量、循环等这些命令式编程方式中的元素，像数学里的函数一样，对于给定的输入，不管你调用该函数多少次，永远返回同样的结果。而在我们常用的命令式编程方式中，变量用来描述事物的状态，整个程序，不过是根据不断变化的条件来维护这些变量。&lt;/p&gt;
&lt;p&gt;广义地说，函数式编程重点在函数，函数是这个世界里的==一等公民==，函数和其他值一样，可以到处被定义，可以作为参数传入另一个函数，也可以作为函数的返回值，返回给调用者。利用这些特性，可以灵活组合已有函数形成新的函数，可以在更高层次上对问题进行抽象。本文的重点将放在这一部分。&lt;/p&gt;
&lt;h2 id=&quot;函数式编程的优点&quot;&gt;函数式编程的优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;(不可变,易并发)在函数式编程中，由于数据全部都是不可变的，所以没有并发编程的问题，是多线程安全的。&lt;/li&gt;
&lt;li&gt;(数据一致,结果稳定)可以有效降低程序运行中所产生的副作用，对于快速迭代的项目来说，函数式编程可以实现函数与函数之间的热切换而不用担心数据的问题，因为它是以函数作为最小单位的，只要函数与函数之间的关系正确即可保证结果的正确性。&lt;/li&gt;
&lt;li&gt;(可读性强)函数式编程的表达方式更加符合人类日常生活中的语法，代码可读性更强。&lt;br/&gt;实现同样的功能函数式编程所需要的代码比面向对象编程要少很多，代码更加简洁明晰。&lt;/li&gt;
&lt;li&gt;函数式编程广泛运用于科学研究中，因为在科研中对于代码的工程化要求比较低，写起来更加简单，所以使用函数式编程开发的速度比用面向对象要高很多，如果是对开发速度要求较高但是对运行资源要求较低同时对速度要求较低的场景下使用函数式会更加高效。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;函数式编程的缺点&quot;&gt;函数式编程的缺点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;(变量消耗内存)由于所有的数据都是不可变的，所以所有的变量在程序运行期间都是一直存在的，非常占用运行资源。&lt;/li&gt;
&lt;li&gt;(运行速度慢)同时由于函数式的先天性设计导致性能一直不够。虽然现代的函数式编程语言使用了很多技巧比如惰性计算等来优化运行速度，但是始终无法与面向对象的程序相比，当然面向对象程序的速度也不够快。&lt;/li&gt;
&lt;li&gt;(不普及)函数式编程虽然已经诞生了很多年，但是至今为止在工程上想要大规模使用函数式编程仍然有很多待解决的问题，尤其是对于规模比较大的工程而言。如果对函数式编程的理解不够深刻就会导致跟面相对象一样晦涩难懂的局面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数式编程和面向对象编程各有利弊，一个语法更加自由(FP)，一个健壮性更好(OOP)。作为程序员应该对两种编程方式都有所了解，不管是哪种方式，只要能够很好的解决当前的问题就是正确的方式，毕竟对于软件工程来说解决问题是最主要的，用的工具反而没有那么重要，就像对程序员来说语言不重要，重要的是解决问题的思想。&lt;/p&gt;
&lt;p&gt;现在这两者的发展趋势是相互借鉴的，许多以面向对象作为基础的语言例如Java等都在新的版本中添加了对函数式编程的支持，而函数式编程则借鉴了一些在面向对象语言里用的一些编译技巧使得程序运行更快。&lt;/p&gt;

&lt;p&gt;约翰·巴克斯（John Backus）为人熟知的两项成就是 FORTRAN 语言和用于描述形式系统的巴克斯范式，因为这两项成就，他获得了 1977 年的图灵奖。&lt;/p&gt;
&lt;p&gt;有趣的是他在获奖后，做了一个关于函数式编程的讲演：Can Programming Be Liberated From the von Neumann Style? 1977 Turing Award Lecture。他认为像 FORTRAN 这样的命令式语言不够高级，应该有新的，更高级的语言可以摆脱冯诺依曼模型的限制，于是他又发明了 FP 语言，虽然这个语言未获成功，但是约翰·巴克斯关于函数式编程的论述却得到了越来越多的认可。下面，我们就罗列一些函数式编程的优点。&lt;/p&gt;
&lt;p&gt;首先，函数式编程天然有并发的优势。由于工艺限制，摩尔定律已经失效，芯片厂商只能采取多核策略。程序要利用多核运算，必须采取并发，而并发最头疼的问题就是共享数据，狭义的函数式编程没有可变的变量，数据只读不写，并发的问题迎刃而解。这也是前面两篇文章中，一直建议大家在定义变量时，使用 val 而不是 var 的原因。爱立信公司发明的 Erlang 语言就是为解决并发的问题而生，在电信行业取得了不俗的成绩。&lt;/p&gt;
&lt;p&gt;其次，函数式编程有迹可寻。由于不依赖外部变量，给定输入函数的返回结果永远不变，对于复杂的程序，我们可以用值替换的方式（substitution model）化繁为简，轻松得出一段程序的计算结果。为这样的程序写单元测试也很方便，因为不用担心环境的影响。&lt;/p&gt;
&lt;p&gt;最后，函数式编程高屋建瓴。写程序最重要的就是抽象，不同风格的编程语言为我们提供了不同的抽象层次，抽象层次越高，表达问题越简洁，越优雅。读者从下面的例子中可以看到，使用函数式编程，有一种高屋建瓴的感觉。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 06:00:00 +0000</pubDate>
<dc:creator>旻天clock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clockq/p/9277110.html</dc:identifier>
</item>
<item>
<title>Mybatis学习系列（四）Mapper接口动态代理 - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9277048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9277048.html</guid>
<description>&lt;h2&gt;实现原理及规范&lt;/h2&gt;
&lt;p&gt;Mapper接口动态代理的方式需要手动编写Mapper接口，Mybatis框架将根据接口定义创建接口的动态代理对象，代理对象的方法体实现Mapper接口中定义的方法。&lt;/p&gt;
&lt;p&gt;使用Mapper接口需要遵守以下规范：&lt;/p&gt;
&lt;p&gt;1.  Mapper.xml文件中的namespace与mapper接口的类路径相同&lt;/p&gt;
&lt;p&gt;2.  Mapper接口方法名和Mapper.xml中定义的每个statement的id相同&lt;/p&gt;
&lt;p&gt;3.  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同&lt;/p&gt;
&lt;p&gt;4.  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同&lt;/p&gt;
&lt;h2&gt;编写Mapper.xml映射文件&lt;/h2&gt;
&lt;p&gt;定义mapper映射文件ProductMapper.xml，需要修改namespace的值为 ProductMapper接口路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; namespace:此处使用包名+文件名 的形式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.sl.mapper.ProductMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 返回自定义类型 注意 selectAllProduct返回的是集合，这种情况下resultType是集合包含的类型，而不能是集合本身 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectAllProduct&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.sl.po.Product&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from products
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectProductsByVo&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.sl.po.Product&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from products
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;product.cityCode!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
               and citycode = #{product.cityCode}
               &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; citycode = #{cityCode} &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;product.Name!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                and name like #{product.Name}
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;product.Description!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                and description like #{product.Description}
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编写Mapper.java接口&lt;/h2&gt;
&lt;p&gt;接口定义注意点：&lt;/p&gt;
&lt;p&gt;1.  Mapper接口方法名和Mapper.xml中定义的statement的id相同&lt;/p&gt;
&lt;p&gt;2.  Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同&lt;/p&gt;
&lt;p&gt;3.  Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('84208562-d6a4-4ecc-ad18-bd6a5e449a0e')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_84208562-d6a4-4ecc-ad18-bd6a5e449a0e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_84208562-d6a4-4ecc-ad18-bd6a5e449a0e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('84208562-d6a4-4ecc-ad18-bd6a5e449a0e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_84208562-d6a4-4ecc-ad18-bd6a5e449a0e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.mapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.Product;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.ProductVo;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ProductMapper {
    
    List&lt;/span&gt;&amp;lt;Product&amp;gt;&lt;span&gt; selectAllProduct();
    
    List&lt;/span&gt;&amp;lt;Product&amp;gt;&lt;span&gt; selectProductsByVo(ProductVo vo);
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('35b3aeba-fda3-4842-977a-b69a68a43cfd')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_35b3aeba-fda3-4842-977a-b69a68a43cfd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35b3aeba-fda3-4842-977a-b69a68a43cfd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('35b3aeba-fda3-4842-977a-b69a68a43cfd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35b3aeba-fda3-4842-977a-b69a68a43cfd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.po;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductVo {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; category;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Product product;
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCategory() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; category;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCategory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; category) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.category =&lt;span&gt; category;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product getProduct() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProduct(Product product) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.product =&lt;span&gt; product;
    }
    
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;注册Mapper.xml配置文件（或者Mapper.java接口）&lt;/h2&gt;
&lt;p&gt;修改SqlMapConfig.xml文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册productMapper.xml文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;mapper/productMapper.xml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mapper.xml文件和mapper接口可以不在一个包下  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册mapper接口 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;mapper class=&quot;com.sl.mapper.ProductMapper&quot;&amp;gt;&amp;lt;/mapper&amp;gt;  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过注册mapper接口方式： Mapper接口和mapper.xml必须在同一个包下 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('538283f7-5aba-4a00-a0d4-1bd4e94ec14e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_538283f7-5aba-4a00-a0d4-1bd4e94ec14e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_538283f7-5aba-4a00-a0d4-1bd4e94ec14e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('538283f7-5aba-4a00-a0d4-1bd4e94ec14e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_538283f7-5aba-4a00-a0d4-1bd4e94ec14e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mapper接口动态代理方式&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestProductMapperClient {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义会话SqlSession&lt;/span&gt;
    SqlSession session = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义mabatis全局配置文件&lt;/span&gt;
        String resource = &quot;SqlMapConfig.xml&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载mybatis全局配置文件
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; InputStream inputStream =
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TestClient.class.getClassLoader().getResourceAsStream(resource);&lt;/span&gt;
&lt;span&gt;
        InputStream inputStream &lt;/span&gt;=&lt;span&gt; Resources.getResourceAsStream(resource);
        SqlSessionFactoryBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder();
        SqlSessionFactory factory &lt;/span&gt;=&lt;span&gt; builder.build(inputStream);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据sqlSessionFactory产生会话sqlsession&lt;/span&gt;
        session =&lt;span&gt; factory.openSession();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; select by id
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectProduct() {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取mapper接口的代理对象&lt;/span&gt;
        ProductMapper productMapper = session.getMapper(ProductMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        List&lt;/span&gt;&amp;lt;Product&amp;gt; listProduct =&lt;span&gt; productMapper.selectAllProduct();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Product product : listProduct) {
            System.out.println(product);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭会话&lt;/span&gt;
&lt;span&gt;        session.close();
    }
    
        @Test
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testwhereTest() {
            Product product &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product();
            product.setCityCode(&lt;/span&gt;&quot;A01&quot;&lt;span&gt;);
            product.setName(&lt;/span&gt;&quot;%国际%&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;product.setDescription(&quot;%xx%&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;product.setUnitPrice(new BigDecimal(100));&lt;/span&gt;
            ProductVo vo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProductVo();
            vo.setProduct(product);
            ProductMapper productMapper &lt;/span&gt;= session.getMapper(ProductMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            List&lt;/span&gt;&amp;lt;Product&amp;gt; listProduct =&lt;span&gt; productMapper.selectProductsByVo(vo);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Product pro : listProduct) {
                System.out.println(pro);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭会话&lt;/span&gt;
&lt;span&gt;            session.close();
        }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      动态代理对象内部调用sqlSession.selectOne()和sqlSession.selectList()实现数据库操作，具体调用哪一个是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。&lt;/p&gt;
&lt;p&gt;由于参数类型在mapper.xml配置文件中ParameterType配置，所以Mapper.java中接口方法只有一个参数，且类型与mapper.xml中配置的相同（mapper.xml可省略参数类型配置）。&lt;/p&gt;

</description>
<pubDate>Sat, 07 Jul 2018 05:26:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9277048.html</dc:identifier>
</item>
<item>
<title>Identity Server 4 - Hybrid Flow - 保护API资源 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9276278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9276278.html</guid>
<description>&lt;p&gt;这个系列文章介绍的是Identity Server 4 的 Hybrid Flow, 前两篇文章介绍了如何保护MVC客户端, 本文介绍如何保护API资源.&lt;/p&gt;
&lt;p&gt;保护MVC客户端的文章: &lt;a href=&quot;https://www.cnblogs.com/cgzl/p/9253667.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cgzl/p/9253667.html&lt;/a&gt;,  &lt;a href=&quot;https://www.cnblogs.com/cgzl/p/9268371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cgzl/p/9268371.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码: &lt;a href=&quot;https://github.com/solenovex/Identity-Server-4-Tutorial-Code&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/Identity-Server-4-Tutorial-Code&lt;/a&gt; 里面03那部分.&lt;/p&gt;


&lt;p&gt;回顾一下该项目使用的流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707085542679-490177175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图里有IDP (Identity Provider, 我例子里是用Identity Server 4构建的项目)和客户端(我的例子里是MVC客户端).&lt;/p&gt;
&lt;p&gt;在上面流程走完之后, MVC客户端获得了Access Token, MVC客户端验证Access Token并成功后, 就可以使用Access Token来访问被保护的API资源了, 而Access Token会在被保护的API那里再次进行验证.&lt;/p&gt;


&lt;p&gt;首先在IDP里配置一个返回ApiResoruce的方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707090638957-271679114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和IdentityResource类似, ApiResource就是与API相关的scopes.&lt;/p&gt;

&lt;p&gt;在Client配置那里, 把这个ApiResource的名字添加到允许的scopes里:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707090831778-1147190405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后在IDP的startup里, 注册ApiResources:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707091003546-1029635172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在来到MVC客户端这里, 需要把上面的scope添加上:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707091236284-1312099683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后来到API项目, 首先确保使用HTTPS:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707091413805-1414881514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;API项目还需要安装IdentityServer4.AccessTokenValidation这个包, 可以通过Nuget安装.&lt;/p&gt;
&lt;p&gt;安装后, 还需要进行配置 (官方文档: &lt;a href=&quot;https://identityserver4.readthedocs.io/en/release/quickstarts/1_client_credentials.html#adding-an-api&quot; target=&quot;_blank&quot;&gt;https://identityserver4.readthedocs.io/en/release/quickstarts/1_client_credentials.html#adding-an-api&lt;/a&gt;): &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707092349103-1150232715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中IdentityServerAuthenticationDefaults.AuthenticationScheme 就是 “Bearer” 的意思, 这里使用的就是这个方案.&lt;/p&gt;
&lt;p&gt;AddIdentityServerAuthentication()方法注册了Access Token 验证的处理者. 里面Authority就是IDP的URI, ApiName就是IDP里配置的API的名字.&lt;/p&gt;

&lt;p&gt;在Startup的Configure方法里, 还需要把它添加到管道:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707092816640-57400664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要确保它在UseMVC之前调用.&lt;/p&gt;

&lt;p&gt;我在API项目里使用过滤器为所有的Controller都加上了授权过滤:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707093207364-322548387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然也可以在具体的Controller或Action级写上这个:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707093335461-617488728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无论如何现在访问Country资源是需要授权的.&lt;/p&gt;

&lt;p&gt;回到MVC客户端, 在Home的Contact Action里调用CountryAPI资源:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707101443201-1570683877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707094756574-330653886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面测试一下未使用Access Token访问被保护的Country资源的情况, 重新操作可以看到用户同意授权页面出现了刚才配置的API资源名:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707095539591-1156626073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在访问Contact页面的时候, 提示未授权:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707095658884-385412549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那就用之前介绍过的方法来获取Access Token并设置Authorization Header为 “Bearer [AccessToken]” 即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707115854515-550367258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再修改一下Contact页面, 显示Access Token:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707101612870-1595303288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;重新操作, 就可以看到Country资源数据了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707115931107-1823247026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;Access Token&lt;/h3&gt;
&lt;p&gt;去jwt.io对Access Token进行解码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707123732833-1001373916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下aud (audience, 观众) 这个属性, 它有两个值, 第一个是指IDP那边对资源 (调用用户信息端点), 第二个就是指API那个项目.&lt;/p&gt;
&lt;p&gt;这个属性说明这个access token是为它们俩准备的.&lt;/p&gt;
&lt;p&gt;而scope里面的“restapi”就是aud里面的“restapi”, 所以这个token允许被用来访问我们的“restapi”.&lt;/p&gt;
&lt;p&gt;而scope里面的“profile”等scopes是对应另一个aud的值, 这些scopes来自IDP那里.&lt;/p&gt;

&lt;p&gt;现在Access Token有这些claims, API也就能得到这些claims, 但是有时API还需要用户身份相关的claims.&lt;/p&gt;
&lt;p&gt;修改IDP的ApiResource配置即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707125656444-251396295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再次操作后, 查看token, 就可以看到我刚刚添加的那两个claim了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707125635714-1663914436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而role这个claim, 在API里是可以被识别成角色的, 如果我在API的Action上设置权限如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707130015161-1819908916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么, Nick这个用户就可以得到Country数据, 而Dave则会显示403 Forbidden:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180707130339824-469320938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 07 Jul 2018 05:08:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9276278.html</dc:identifier>
</item>
<item>
<title>springboot + mybatis + gradle项目构建过程 - lzj123</title>
<link>http://www.cnblogs.com/lzj123/p/9277021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzj123/p/9277021.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.从&lt;a href=&quot;https://spring.io/&quot; target=&quot;_blank&quot;&gt;Spring boot官网&lt;/a&gt;根据需求下载脚手架或者到GitHub上去搜索对应的脚手架项目,D_iao ^0^&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• 文件目录如下（此处generatorConfig.xml 和 log4j2.xml文件请忽略，后续会讲解）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/811290/201807/811290-20180707121848238-399277236.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.使用Mybatis代码自动构建插件生成代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•  gradle 相关配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// Mybatis 代码自动生成所引入的包
compile group: 'org.mybatis.generator', name: 'mybatis-generator-core', version: '1.3.3'

// MyBatis代码自动生成插件工具
apply plugin: &quot;com.arenagod.gradle.MybatisGenerator&quot;

configurations {
    mybatisGenerator
}

mybatisGenerator {
    verbose = true
    // 配置文件路径
    configFile = 'src/main/resources/generatorConfig.xml'
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;•  generatorConfig.xml配置详解&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;generatorConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;数据库驱动包路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classPathEntry
            &lt;/span&gt;&lt;span&gt;&amp;lt;!--此驱动包路径可在项目的包库中找到，复制过来即可--&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            location=&quot;C:\Users\pc\.gradle\caches\modules-2\files-2.1\mysql\mysql-connector-java\5.1.38\dbbd7cd309ce167ec8367de4e41c63c2c8593cc5\mysql-connector-java-5.1.38.jar&quot;/&amp;gt;

    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt; targetRuntime&lt;/span&gt;&lt;span&gt;=&quot;MyBatis3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;关闭注释 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;commentGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suppressAllComments&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;commentGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;数据库连接信息 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jdbcConnection &lt;/span&gt;&lt;span&gt;driverClass&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;&lt;span&gt;
                        connectionURL&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://127.0.0.1:3306/xxx&quot;&lt;/span&gt;&lt;span&gt; userId&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;
                        password&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jdbcConnection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;生成的model 包路径 ，其中rootClass为model的基类,配置之后他会自动继承该类作为基类，trimStrings会为model字串去空格&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaModelGenerator &lt;/span&gt;&lt;span&gt;targetPackage&lt;/span&gt;&lt;span&gt;=&quot;com.springboot.mybatis.demo.model&quot;&lt;/span&gt;&lt;span&gt;
                            targetProject&lt;/span&gt;&lt;span&gt;=&quot;D:/self-code/spring-boot-mybatis/spring-boot-mybatis/src/main/java&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;trimStrings&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rootClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.springboot.mybatis.demo.model.common.BaseModel&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaModelGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;生成mapper xml文件路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sqlMapGenerator &lt;/span&gt;&lt;span&gt;targetPackage&lt;/span&gt;&lt;span&gt;=&quot;mapper&quot;&lt;/span&gt;&lt;span&gt;
                         targetProject&lt;/span&gt;&lt;span&gt;=&quot;D:/self-code/spring-boot-mybatis/spring-boot-mybatis/src/main/resources&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sqlMapGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 生成的Mapper接口的路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaClientGenerator &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;XMLMAPPER&quot;&lt;/span&gt;&lt;span&gt;
                             targetPackage&lt;/span&gt;&lt;span&gt;=&quot;com.springboot.mybatis.demo.mapper&quot;&lt;/span&gt;&lt;span&gt; targetProject&lt;/span&gt;&lt;span&gt;=&quot;D:/self-code/spring-boot-mybatis/spring-boot-mybatis/src/main/java&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaClientGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对应的表 这个是生成Mapper xml文件的基础，enableCountByExample如果为true则会在xml文件中生成样例，过于累赘所以不要&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;tableName&lt;/span&gt;&lt;span&gt;=&quot;tb_user&quot;&lt;/span&gt;&lt;span&gt; domainObjectName&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt;
               enableCountByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
               enableDeleteByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
               enableSelectByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
               enableUpdateByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;generatorConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上配置中注意targetProject路径请填写绝对路径，避免错误，其中targetPackage是类所处的包路径(确保包是存在的，否则无法生成)，也就相当于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/811290/201807/811290-20180707122611218-1419208912.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•  代码生成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置完成之后首先得在数据库中新建对应的表，然后确保数据库能正常访问，最后在终端执行gradle mbGenerator或者点击如下任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/811290/201807/811290-20180707123307335-937702866.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成功之后它会生成model、mapper接口以及xml文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.集成日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• gradle 相关配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;compile group: 'org.springframework.boot', name: 'spring-boot-starter-log4j2', version: '1.4.0.RELEASE'

// 排除冲突
configurations {
    mybatisGenerator
    compile.exclude module: 'spring-boot-starter-logging'
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当没有引入spring-boot-starter-log4j2包时会报错：&lt;span&gt;java.lang.IllegalStateException: Logback configuration error detected &lt;span&gt;Logback 配置错误声明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;原因参考链接；&lt;a href=&quot;https://blog.csdn.net/blueheart20/article/details/78111350?locationNum=5&amp;amp;fps=1&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/blueheart20/article/details/78111350?locationNum=5&amp;amp;fps=1&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：排除依赖 spring-boot-starter-logging&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;what???&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;排除依赖之后使用的时候又报错：&lt;span&gt;Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;&lt;/span&gt;&lt;/span&gt; 加载slf4j.impl.StaticLoggerBinder类失败&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因参考链接：&lt;a href=&quot;https://blog.csdn.net/lwj_199011/article/details/51853110&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/lwj_199011/article/details/51853110&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：添加依赖 spring-boot-starter-log4j2 此包所依赖的包如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starters&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.4.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-log4j2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Spring Boot Log4j 2 Starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Starter for using Log4j2 for logging. An alternative to
        spring-boot-starter-logging&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://projects.spring.io/spring-boot/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;organization&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Pivotal Software, Inc.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://www.spring.io&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;organization&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;main.basedir&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${basedir}/../..&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;main.basedir&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j-slf4j-impl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jcl-over-slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jul-to-slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;它依赖了 log4j-slf4j-impl ，使用的是log4j2日志框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里涉及到log4j、logback、log4j2以及slf4j相关概念，那么它们是啥关系呢？unbelievable...相关知识如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;slf4j、log4j、logback、log4j2&lt;/span&gt; &lt;br/&gt;日志接口(slf4j) 
slf4j是对所有日志框架制定的一种规范、标准、接口，并不是一个框架的具体的实现，因为接口并不能独立使用，需要和具体的日志框架实现配合使用（如log4j、logback）&lt;br/&gt;日志实现(log4j、logback、log4j2)
log4j是apache实现的一个开源日志组件
logback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架，是slf4j的原生实现
Log4j2是log4j 1.x和logback的改进版，据说采用了一些新技术（无锁异步、等等），使得日志的吞吐量、性能比log4j 1.x提高10倍，并解决了一些死锁的bug，而且配置更加简单灵活，官网地址： http://logging.apache.org/log4j/2.x/manual/configuration.html
为什么需要日志接口，直接使用具体的实现不就行了吗？
接口用于定制规范，可以有多个实现，使用时是面向接口的（导入的包都是slf4j的包而不是具体某个日志框架中的包），即直接和接口交互，不直接使用实现，所以可以任意的更换实现而不用更改代码中的日志相关代码。
比如：slf4j定义了一套日志接口，项目中使用的日志框架是logback，开发中调用的所有接口都是slf4j的，不直接使用logback，调用是 自己的工程调用slf4j的接口，slf4j的接口去调用logback的实现，可以看到整个过程应用程序并没有直接使用logback，当项目需要更换更加优秀的日志框架时（如log4j2）只需要引入Log4j2的jar和Log4j2对应的配置文件即可，完全不用更改Java代码中的日志相关的代码logger.info(“xxx”)，也不用修改日志相关的类的导入的包（import org.slf4j.Logger; 
import org.slf4j.LoggerFactory;）&lt;br/&gt;使用日志接口便于更换为其他日志框架，适配器作用
log4j、logback、log4j2都是一种日志具体实现框架，所以既可以单独使用也可以结合slf4j一起搭配使用）
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;• &lt;span&gt;到此我们使用的是Log4j2日志框架，接下来是配置log4j，具体配置详解如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;日志级别以及优先级排序: OFF &amp;gt; FATAL &amp;gt; ERROR &amp;gt; WARN &amp;gt; INFO &amp;gt; DEBUG &amp;gt; TRACE &amp;gt; ALL &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Configuration &lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;=&quot;WARN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;定义一些属性&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;PID&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;????&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;LOG_PATTERN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            [%d{yyyy-MM-dd HH:mm:ss.SSS}] - ${sys:PID} --- %c{1}: %m%n
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出源，用于定义日志输出的地方&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Appenders&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出到控制台&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Console &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Console&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;SYSTEM_OUT&quot;&lt;/span&gt;&lt;span&gt; follow&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout
                    &lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_PATTERN}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Console&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;File name=&quot;File&quot; fileName=&quot;logs/log.log&quot; append=&quot;false&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;PatternLayout&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;pattern&amp;gt;[%-5p] %d %c - %m%n&amp;lt;/pattern&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;/PatternLayout&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;/File&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingFile &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;RollingAllFile&quot;&lt;/span&gt;&lt;span&gt; fileName&lt;/span&gt;&lt;span&gt;=&quot;logs/all/all.log&quot;&lt;/span&gt;&lt;span&gt;
                     filePattern&lt;/span&gt;&lt;span&gt;=&quot;logs/all/$${date:yyyy-MM}/all-%d{yyyy-MM-dd}-%i.log.gz&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout
                    &lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_PATTERN}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;以下两个属性结合filePattern使用，完成周期性的log文件封存工作&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;TimeBasedTriggeringPolicy 基于时间的触发策略，以下是它的两个参数：
                    1.interval，integer型，指定两次封存动作之间的时间间隔。单位:以日志的命名精度来确定单位，比如yyyy-MM-dd-HH 单位为小时，yyyy-MM-dd-HH-mm 单位为分钟
                    2.modulate，boolean型，说明是否对封存时间进行调制。若modulate=true，则封存时间将以0点为边界进行偏移计算。比如，modulate=true，interval=4hours，那么假设上次封存日志的时间为03:00，则下次封存日志的时间为04:00，之后的封存时间依次为08:00，12:00，16:00&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;TimeBasedTriggeringPolicy/&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy 基于日志文件大小的触发策略，以下配置解释为：
                    当单个文件达到20M后，会自动将以前的内容，先创建类似 2014-09（年-月）的目录，然后按 &quot;xxx-年-月-日-序号&quot;命名，打成压缩包&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;200 MB&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RollingFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 添加过滤器ThresholdFilter,可以有选择的输出某个级别及以上的类别  onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;意思是匹配就接受,否则直接拒绝 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingFile &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;RollingErrorFile&quot;&lt;/span&gt;&lt;span&gt; fileName&lt;/span&gt;&lt;span&gt;=&quot;logs/error/error.log&quot;&lt;/span&gt;&lt;span&gt;
                     filePattern&lt;/span&gt;&lt;span&gt;=&quot;logs/error/$${date:yyyy-MM}/%d{yyyy-MM-dd}-%i.log.gz&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;ERROR&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout
                    &lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_PATTERN}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;TimeBasedTriggeringPolicy/&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;200 MB&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RollingFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingFile &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;RollingWarnFile&quot;&lt;/span&gt;&lt;span&gt; fileName&lt;/span&gt;&lt;span&gt;=&quot;logs/warn/warn.log&quot;&lt;/span&gt;&lt;span&gt;
                     filePattern&lt;/span&gt;&lt;span&gt;=&quot;logs/warn/$${date:yyyy-MM}/%d{yyyy-MM-dd}-%i.log.gz&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;WARN&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;ERROR&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout
                    &lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_PATTERN}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;TimeBasedTriggeringPolicy/&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;200 MB&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RollingFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Appenders&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;然后定义Loggers，只有定义了Logger并引入的Appender，Appender才会生效&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Loggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;org.hibernate.validator.internal.util.Version&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;WARN&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;WARN&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;org.apache.tomcat.util.net.NioSelectorPool&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;WARN&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;org.apache.catalina.startup.DigesterFactory&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;ERROR&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;org.springframework&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;INFO&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.springboot.mybatis.demo&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;DEBUG&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;以上的logger会继承Root，也就是说他们默认会输出到Root下定义的符合条件的Appender中，若不想让它继承可以设置 additivity=&quot;false&quot;
        并可以在Logger中设置 &amp;lt;AppenderRef ref=&quot;Console&quot;/&amp;gt; 指定输出到Console&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;INFO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;Console&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;RollingAllFile&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;RollingErrorFile&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;RollingWarnFile&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Loggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到此我们就算是把日志集成进去了，可以在终端看到各种log，very exciting!!! &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;未完！待续。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 05:08:00 +0000</pubDate>
<dc:creator>lzj123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzj123/p/9277021.html</dc:identifier>
</item>
<item>
<title>【算法类原创】复杂网络分析法中的还原论与整体论 - 行愚</title>
<link>http://www.cnblogs.com/xingyuzl/p/9276967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xingyuzl/p/9276967.html</guid>
<description>&lt;p&gt;&lt;strong&gt;0）概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        前不久听一位颇有造诣的老先生讲了一堂关于仿真的讲座，其中涉及到了还原论与整体论。于是借着先生的智慧，说说贯彻整个复杂网络分析过程（包含复杂网络的构建，下同）的还原论和整体论。&lt;/p&gt;
&lt;p&gt;        本文首先阐述还原论、整体论及复杂网络的定义，继而叙述复杂网络分析与还原论、整体论的关系，然后提出对复杂网络的一些算法进行改进的思路并提出价值路径的概念，最后用复杂网络节点强度和介数的算法作为改进算例进行进一步的阐述。&lt;/p&gt;
&lt;p&gt;        因作者经历有限，算例部分未配图片及详细计算过程，因此本文理解起来可能略为抽象，感兴趣的朋友可以与作者进行进一步的交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）还原论与整体论相辅相成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        整体论讲的是事物之间的普遍联系，而还原论则是整体论的逆向，讲的是事物可以拆分成部分（要素）加以理解。咋一看整体论与还原论的思想有点矛盾，实际上它们相辅相成，缺一不可。针对复杂网络而言，根据事物的作用（整体论）依据还原论进行拆分的过程便是复杂网络构建的过程，基于要素（节点）及其之间的关系的整体作用（还原论里所包含的知识）构成了复杂网络分析的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）复杂网络中的还原论与整体论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        钱学森对复杂网络的定义为：具有自组织、自相似、吸引子、小世界、无标度中部分或全部性质的网络称为复杂网络。暂且不论定义中各种性质的具体含义，我们可以简单直观的将网络理解为由节点和关系组成。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ia9lygP8lSvXWicruRicD40HEHL1H30YwCic6ZaBfbIuBMuD1K6dvC3GwQiaGMAXcmBCRxEbHGwIE2WcfHd7eQogSDw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1） 复杂网络与还原论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        当决定用复杂网络算法分析事物时，你便在使用还原论了，这也是网络构建的过程。根据事物的作用将事物拆解成要素及其之间的关系便是还原，便是构建复杂网络。&lt;/p&gt;
&lt;p&gt;        事物有不同的作用，因此分析的目的会有不同。事物的不同作用是由不同的要素及其之间通过不同的关系来体现的，因此同一件事物，分析的目的不同，则按照还原论还原出来的复杂网络也可能不同。&lt;/p&gt;
&lt;p&gt;        此外，还原的过程可以不止一次，即事物可以用分层网络来描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2）复杂网络与整体论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        当将事物还原成网络后，要素及要素间的关系便成为独立的客观存在。但是如果要用该网络对原始事物进行描述分析，则必须要将所有客观存在（包含节点和关系）作为一个整体进行分析。复杂网络分析中一些常用的指标算法（比如度、介数，紧密度等）都是基于这个思想的。这也是复杂网络分析中的整体论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）复杂网络算法的一些改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        本文不会对所有复杂网络分析中所用到的算法的改进进行介绍。但本文会介绍算法改进的思路并拿强度和介数作为算例对改进思路进行进一步的阐述。&lt;/p&gt;
&lt;p&gt;        基于事物的作用与还原论构建的网络是包含知识的，所以复杂网络便不再是一个单纯的数学模型，因此基于数学模型进行的诸如强度、介数的分析结果都是不可靠的，这类似于灰色关联度、主成份分析、因子分析法等算法（以后我会单独写一篇来证明所有这类方法的计算结果都是“荒谬不可信”的，同样也会介绍复杂网络算法与这类算法之间的联系以及如何改进这类算法）。&lt;/p&gt;
&lt;p&gt;        数学模型落地的方式之一便是让它走入“生活”，因此复杂网络数学模型的改进便是让它走进事物的作用，把基于还原论构建的网络中所包含的知识提取出来。下面用节点强度与介数（节点介数和边介数同理）举例分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 节点强度算法的改进   &lt;/strong&gt;     &lt;/p&gt;
&lt;p&gt;        节点（要素）的强度，其定义为与该节点相邻边的条数。但根据分析目的的不同，并非所有的边（关系）都应纳入强度的计算，例如描述足球比赛的网络中，球员定义为节点，边定义为球员之间的传球或进球，则根据强度描述球员的进球能力时，就不应将球员传球的边纳入到强度计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 介数算法的改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        节点的介数（边介数同节点介数）定义为网络图中经过该节点的最短路径条数占总最短路径条数的比。&lt;/p&gt;
&lt;p&gt;        最短路径是数学的，无业务（作用）含义的，因此其改进的方法是将最短路径业务化。如3.1中所描述足球比赛的网络中，根据节点介数描述球员对进球的贡献时，计算介数时的最短路径应该替换为至少包含进球边的路径，这样的路径我们可以定义为价值路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        复杂网络的构建及分析的过程中处处包含还原论与整体论。如应根据事物的作用及还原论的思想进行复杂网络的构建，基于还原论的思想抽取事物的功能，并将功能运用到包含整体论思想的复杂网络分析时的计算算法中。如在计算介数时，可以将最短路径替换为价值路径。&lt;/p&gt;
&lt;p&gt;        包含了还原论、整体论的网络不再是传统的数学网络；事物作用的多样性决定了实际分析时不同网络算法的取舍及其复杂性。可以说，除对网络分析中算法的理解外，对还原论、整体论在复杂网络构建及分析中作用的理解与运用，直接决定了分析结果的可信度及整个分析过程的质量。&lt;/p&gt;



&lt;p&gt;澄清：本菜十足“半吊子”，所见所闻均极其有限，容易偏听偏信，偏读偏错，实在惶恐。写的东西也捡最简单最容易的写，如有写错的地方欢迎批评指正。&lt;/p&gt;
&lt;p&gt;        另扫码可关注本菜公众号 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ia9lygP8lSvXWicruRicD40HEHL1H30YwCicySo2asw3Miaia2bOiboNh2nGuEVqaqRWY8QvYkPSdTBWjhTOvfiazhVMng/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 04:37:00 +0000</pubDate>
<dc:creator>行愚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xingyuzl/p/9276967.html</dc:identifier>
</item>
<item>
<title>在PHP中避免一些代码中的坏味道 - Summer7C</title>
<link>http://www.cnblogs.com/Summer7C/p/9276901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer7C/p/9276901.html</guid>
<description>&lt;p&gt;做PHP开发已经有快一年的时间了，在这一年的时间中，学习了很多生产环境中的技巧，学习了很多东西，期间也阅读了一些优秀的源码和关于代码的书，对写代码这一块有了一定的思考，也看过很多别人写的好的代码和坏的代码，这里说说自己的感悟和改进吧。&lt;/p&gt;
&lt;p&gt;本篇博客直说自己的感悟，在写代码时，我给自己立下的规则，这样可以让代码清晰可读并少走一些坑。这些简单的规则虽然没有设计模式看起来那么激动人心，但是，平常注意可以让代码看起来很清爽。&lt;/p&gt;
&lt;p&gt;1. 不要在对象外使用未声明的变量&lt;/p&gt;
&lt;p&gt;这个问题其实表述起来可能不容易理解。这个问题是因为PHP语言本身的特点决定的。由于PHP是一个弱类型的动态脚本语言，所以很多情况下，给了这个语言本省很宽松的条件让开发者去编写代码。但是往往这些便利也会变为坑，所以在使用一些动态语言很方便的写法的时候，尤其要注意。&lt;/p&gt;
&lt;p&gt;下面我们先声明一个类，暂且叫这个类为用户类，这个User类的背景设定为，框架自带，不允许修改，并且隐藏在框架深处，不容易发现，实际案例可以参考laravel框架的Request类，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;$username&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;$password&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;$otherInfo&lt;/span&gt; =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; readUserInfo() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             'username' =&amp;gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;username,
&lt;span&gt;11&lt;/span&gt;             'password' =&amp;gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;password,
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        ];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; addAtri(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;array_push&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;otherInfo, &lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的代码看似中规中矩，但是接下来，我们需要对这个类进行操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;$user&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;$user&lt;/span&gt;-&amp;gt;userRealName = &quot;hello world&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的代码在PHP中是完全可以运行的，并且不会报错，但是这样的代码会对之后的一些事情做为干扰。我们现在假定，上边的代码是在PHP web项目中是一个拦截器，或者叫做中间件也可以，然后我们在controller中会会使用到这个类的实例，并且使用到这个中间件中添加的这个变量，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebOperate {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; doOprate(User &lt;span&gt;$user&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;$user&lt;/span&gt;-&amp;gt;userRealName = &quot;hello world&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;next&lt;/span&gt;(&lt;span&gt;$user&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里设定的场景是，WebOperate是一个中间件，所有的Controller都会走这个中间件后到达Controller，之后，在处理相应的Controller的功能，接下来，Controller会将中间件的实例注入进来，供控制器使用，而中间件开发人员不是很在意其的存在：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexController {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; index(User &lt;span&gt;$user&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$user&lt;/span&gt;-&amp;gt;&lt;span&gt;userRealName;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而这样的代码是可以完美运行的，接下来，开发人员想要的实另一个User类，这个User类中添加一些其他功能，正如之前所说，这个类在框架深处并且很难找到，且不允许修改，因为其他功能使用了这个类，所以，我们只有继承并添加方法。根据开发经验，开发人员会认为User类中存在这个userRealName变量，所以就造成了这个写法：&lt;/p&gt;
&lt;p&gt;首先是基于这个User衍生出来的Teacher类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Teacher &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sayHello() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;hello world&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们的Teacher就可以sayhello了，但是，这个时候，在我们的Controller中还想知道老师的真实姓名，怎么办？根据经验，我们可以将注入的类换成Teacher并且返回真实姓名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexController {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; index(Teacher &lt;span&gt;$user&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$user&lt;/span&gt;-&amp;gt;&lt;span&gt;userRealName;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么这下问题来了，其实User类中并没有这个类，所以这个变量根本没有数值，但是根据经验，是中间件已经赋值过一次了，所以我们应该可以直接使用，但是并没有这个数值，我们开始看源码发现，继承的User类中根本不存在这个变量，那么这个变量之前为什么可以使用呢，因为在中间件中，给User的实力付了值。&lt;/p&gt;
&lt;p&gt;所以我们的不能这样直接使用未声明的变量，在一个类中。&lt;/p&gt;
&lt;p&gt;我们应该这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebOperate {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; doOprate(User &lt;span&gt;$user&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;$user&lt;/span&gt;-&amp;gt;&lt;span&gt;addAtri([
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             'userRealName' =&amp;gt; 'hello world',
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        ]);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;next&lt;/span&gt;(&lt;span&gt;$user&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的中间件，在调用的时候继承类也可以使用同样的方法，很简单并且很不容易出现坏的味道。&lt;/p&gt;
&lt;p&gt;2. 类or数组&lt;/p&gt;
&lt;p&gt;其实这个问题同时也衍生出了另外的问题，就是函数返回值的问题。&lt;/p&gt;
&lt;p&gt;首先，我明确表示，一个函数做多种类型的返回值是我个人感觉是不好的，在动态语言中虽然很常见，很多PHP的原生方法也有这样的，但是，在生产中使用这样的方式会造成函数返回的不确定性，我们需要作出很多判断来证明我们的结论，但是，如果返回值类型只有一种，我们就可以直接判断返回值就好了。&lt;/p&gt;
&lt;p&gt;就像如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addNewUser() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;addData();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 'error' =&amp;gt; 1,
&lt;span&gt; 8&lt;/span&gt;                 'errormsg' =&amp;gt; &quot;没有添加成功&quot;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            ];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的代码在作为调用者往往会多一次判断，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; index() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;addNewUser();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;is_array&lt;/span&gt;(&lt;span&gt;$res&lt;/span&gt;) &amp;amp;&amp;amp; &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$res&lt;/span&gt;['error'&lt;span&gt;])) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$res&lt;/span&gt;['errormsg']) ? &lt;span&gt;$res&lt;/span&gt;['errormsg'] : &quot;未知错误&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;成功&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的代码几乎每一次调用完成这个函数都会有这一套出现，不仅代码不美观，而且很臃肿。&lt;/p&gt;
&lt;p&gt;这样的代码需要改善，首先限制住函数的返回值。比如，我们只让这个函数返回bool类型的数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addNewUser() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;addData();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，显然，很多时候，我们要的不是简单的真价值，所以，我们会选择返回更多信息，这个时候，我们可以有三种处理方式。&lt;/p&gt;
&lt;p&gt;1）返回int类型的数，然后通过这个int类型的数去判断处理结果，我们可以添加上映射关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operate{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; $operateRes =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         0 =&amp;gt; '成功',
&lt;span&gt; 4&lt;/span&gt;         1 =&amp;gt; '添加失败',
&lt;span&gt; 5&lt;/span&gt;         2 =&amp;gt; '未知错误',
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    ];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addNewUser() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;addData();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$res&lt;/span&gt; &amp;gt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样方法的调用者就可以很简单的使用方法并给出提示了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;$opera&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Operate();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$opera&lt;/span&gt;-&amp;gt;&lt;span&gt;addNewUser();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$opera&lt;/span&gt;-&amp;gt;operateRes[&lt;span&gt;$res&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给出统一的返回值类型的时候就完全不需要判断返回值类型而且可以设置一个规范返回提示。&lt;/p&gt;
&lt;p&gt;2）我们也可以使用数组&lt;/p&gt;
&lt;p&gt;3）数组给人不缺定性，因为很多时候，数组里可以认为的少写一些元素，如果少写了，程序直接报错，很不好。&lt;/p&gt;
&lt;p&gt;所以第三种方式就是建议将固定格式的返回，写成一个类，做返回的时候，使用这个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operate{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addNewUser() {
        &lt;/span&gt;&lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;addData();
        &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Result();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt;-&amp;gt;errno = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt;-&amp;gt;errmsg = &quot;成功&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$res&lt;/span&gt; &amp;gt; 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt;-&amp;gt;errno = 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt;-&amp;gt;errmsg = &quot;失败&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt;-&amp;gt;errno = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt;-&amp;gt;errmsg = &quot;未知错误&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$result&lt;/span&gt;&lt;span&gt;;
    }
    
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Result {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$errno&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$errmsg&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的返回，保证了所有变量的存在，同样可以减少一次判断。&lt;/p&gt;
&lt;p&gt;所以，综合以上，在我们返回结果的时候，尽量使用同种类型的变量，尽量减少使用数组返回。&lt;/p&gt;


&lt;p&gt;先想这么多，后面有其他的想法了，继续总结。&lt;/p&gt;
&lt;p&gt;以上风格仅仅代表本人坚持对代码的要求，不代表官方立场。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 04:03:00 +0000</pubDate>
<dc:creator>Summer7C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Summer7C/p/9276901.html</dc:identifier>
</item>
</channel>
</rss>