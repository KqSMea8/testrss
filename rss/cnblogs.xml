<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入JavaScript类型判定 - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/8452242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/8452242.html</guid>
<description>&lt;h2 id=&quot;基本区分方法&quot;&gt;基本区分方法&lt;/h2&gt;
&lt;p&gt;ECMAScript标准定义了7种数据类型&lt;br/&gt;6 种 基本类型:&lt;br/&gt;Boolean，两种取值：true和false&lt;br/&gt;Null，一种取值：null&lt;br/&gt;Undefined，一种取值：undefined&lt;br/&gt;Number，JS的数值为基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1）。&lt;br/&gt;String，JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。它不可改变。&lt;br/&gt;Symbol，符号是唯一的并且是不可修改的, 并且也可以用来作为Object的key。&lt;br/&gt;一种复杂类型：&lt;br/&gt;Object，可以认为Object是一种键值对的集合。Array和Function就是Object的子类型。&lt;/p&gt;
&lt;h2 id=&quot;另一种区分方法值和址&quot;&gt;另一种区分方法：值和址&lt;/h2&gt;
&lt;p&gt;从C语言过来的朋友一定常听到传值和传址这样的说法，C语言里有指针的概念，指针本质上是一个内存地址，程序员可以通过指针来修改某些内容。&lt;br/&gt;在java和JavaScript这样的类C语言中虽然没有了指针这么强大却危险的东西，但是在函数中操作变量的方式却一脉而成。&lt;br/&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
    globalA &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt; (a) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;(globalA)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(globalA)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在函数中，如果入参是值类型，那么函数将会在执行时上下文建立一个副本，在函数中，实际修改的这个副本，不会影响真正的原始入参。&lt;br/&gt;如果入参是值类型，也就是我们常说的引用类型，那么将直接操作所引用的对象，也就是所说的，通过地址操作值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;
    obj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;foo2&lt;/span&gt; (o) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;o&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;ArrFoo&lt;/span&gt;(obj)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(obj)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//{a:2}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处需要注意的一点是，函数的形参o虽然是引用类型，但是它也是一个执行上下文中建立的副本，如果直接将它重新赋值，例如&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;o &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种写法是不能影响到原始的入参的，执行完毕以后，原始的obj不会被修改。&lt;br/&gt;上面提到的是我们不论在C还是Java中也会涉及的一些传址传值的基本概念。&lt;br/&gt;但是在JavaScript中有一些特别的地方。&lt;/p&gt;
&lt;h3 id=&quot;每个函数都可能是构造函数&quot;&gt;每个函数都可能是构造函数&lt;/h3&gt;
&lt;p&gt;值和址一般是在入参里做体现，出参方面，按照正常理解即可。由于JavaScript的原型链特点，每个函数都可能是构造函数。在构造函数中，情况稍有不同。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;构造函数中带有return语句，如果return的是：&lt;br/&gt;值类型，那么构造函数会忽略掉这个值，返回构造的新对象；&lt;br/&gt;引用类型(数组、函数、对象)，那么构造函数就会直接返回该引用类型；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 因为Super1返回的 123 是值类型，它被丢弃，直接返回构造对象&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super1&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;a&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;// 将return语句注释掉也没影响&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Super1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super1&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Super2直接返回了对象，而前面构造函数的所有操作全被丢弃&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 包括它的构造函数、原型链全部都没有返回&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super2&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;a&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Super2&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super2&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换言之，如果是return的是值类型，return则没什么作用；如果是引用类型，则对构造对象的任何操作不生效，直接返回原来的引用对象。&lt;/p&gt;

&lt;p&gt;其实js有一个自带的操作符专门用来进行类型判定———typeof，不过它只能判断几种基本类型。对于复杂类型，它有些无能无力，而且，对于一些基本类型，它还有一些陷阱。&lt;br/&gt;类型 | 结果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;| -:&lt;br/&gt;Undefined | &quot;undefined&quot;&lt;br/&gt;Null | &quot;object&quot;&lt;br/&gt;Boolean | &quot;boolean&quot;&lt;br/&gt;Number | &quot;number&quot;&lt;br/&gt;String | &quot;string&quot;&lt;br/&gt;Symbol | &quot;symbol&quot;&lt;br/&gt;function | &quot;function&quot;&lt;br/&gt;任何其他对象(Array，Date等原生对象) | &quot;object&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;typeof有一些古怪的bug&quot;&gt;typeof有一些古怪的bug&lt;/h2&gt;
&lt;p&gt;即使是在typeof可以判定的地方，也会有一些bug。例如：&lt;br/&gt;最经典的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及new操作符&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Number&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'number'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Number&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于typeof的功能简陋，尤其是无法对object下的子类型做出详细的判定，所以我们常用另一个操作符进行判定。&lt;/p&gt;

&lt;p&gt;instanceof 用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。&lt;br/&gt;大概原理就是不停地去判断当前对象 _ _ proto _ _ 上的对象是否与实例的prototype相等。不相等的话，就令当前对象&lt;/p&gt;
&lt;p&gt;a. _ _ proto _ _ = a. _ _ proto _ _ . _ _ proto _ _ 继续判断。直到结果为null和true为止。&lt;br/&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 构造函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Foo&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;
    foo1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Foo&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;foo1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; Foo&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//true&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;foo1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; Foo&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true;&lt;/span&gt;


&lt;span class=&quot;va&quot;&gt;foo1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Foo&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;foo1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;foo1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码展示了instanceof的判断原理，具体实现可以参考规范：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-instanceofoperator&quot; class=&quot;uri&quot;&gt;https://tc39.github.io/ecma262/#sec-instanceofoperator&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinaryhasinstance&quot; class=&quot;uri&quot;&gt;https://tc39.github.io/ecma262/#sec-ordinaryhasinstance&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据instanceof，我们基本上可以判断Object下的所有对象类型了。但是instanceof也有一个问题。&lt;/p&gt;
&lt;h3 id=&quot;一切都在window下&quot;&gt;一切都在window下&lt;/h3&gt;
&lt;p&gt;在浏览器环境里，所有的构造函数，基本的对象，都挂在window下。Object也不例外。这导致了一个问题，在iframe这样的独立于当前窗口的环境里，instanceof可能会有bug产生。&lt;br/&gt;对于Array这样的常用对象，新版本提供了Array.isArray原生方法进行判定，但是对于Date等对象，就没有这么好了。所以我们还是需要一个更加健壮的类型判定方法。&lt;br/&gt;Prototype.js、underScore.js和jQuery的前辈们为我们找到了一个绝妙的方法——&lt;br/&gt;&lt;em&gt;Object.prototype.toString.call&lt;/em&gt;&lt;br/&gt;通过这个技巧，再结合typeof和instanceof，我们可以判断几乎全部的原生对象类型。&lt;br/&gt;下面是underscore的部分源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;each&lt;/span&gt;([&lt;span class=&quot;st&quot;&gt;'Arguments'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Function'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'String'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Number'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Date'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 
  &lt;span class=&quot;st&quot;&gt;'RegExp'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Error'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Symbol'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Map'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'WeakMap'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Set'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'WeakSet'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    _[&lt;span class=&quot;st&quot;&gt;'is'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;toString&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[object '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; name &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;']'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;感谢阅读。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof&quot;&gt;typeof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof&quot;&gt;instanceof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jashkenas/underscore&quot;&gt;underscore.js&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 17 Feb 2018 14:04:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/8452242.html</dc:identifier>
</item>
<item>
<title>应用负载均衡之LVS(一)：基本概念和三种模式 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8451982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8451982.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog1&quot;&gt;&lt;span&gt;1. LVS简介&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog2&quot;&gt;&lt;span&gt;2. LVS-ipvs三种模式的工作原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog2.1&quot;&gt;&lt;span&gt;2.1 VS/NAT模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog2.2&quot;&gt;&lt;span&gt;2.2 VS/TUN模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog2.3&quot;&gt;&lt;span&gt;2.3 VS/DR模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog2.4&quot;&gt;&lt;span&gt;2.4 lvs-ipvs的三种模式比较&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog3&quot;&gt;&lt;span&gt;3. VS/TUN和VS/DR模式中的ARP问题&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html#blog4&quot;&gt;&lt;span&gt;4. LVS负载均衡的调度算法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;网站架构中，负载均衡技术是实现网站架构&lt;span&gt;&lt;strong&gt;伸缩性&lt;/strong&gt;&lt;/span&gt;的主要手段之一。所谓&quot;伸缩性&quot;，是指可以不断向集群中添加新的服务器来提升性能、缓解不断增加的并发用户访问压力。通俗地讲，就是一头牛拉不动时，就用两头、三头、更多头牛来拉。&lt;/p&gt;
&lt;p&gt;负载均衡有好几种方式：http URL重定向、DNS的A记录负载均衡、反向代理负载均衡、IP负载均衡和链路层负载。本文所述为LVS，它的VS/NAT和VS/TUN模式是IP负载均衡的优秀代表，而它的VS/DR模式则是链路层负载均衡的优秀代表。&lt;/p&gt;

&lt;h2 id=&quot;1-lvs-&quot;&gt;1.LVS简介&lt;/h2&gt;
&lt;p&gt;LVS中文官方手册：&lt;span&gt;&lt;a href=&quot;http://www.linuxvirtualserver.org/zh/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.linuxvirtualserver.org/zh/index.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。这个手册对于了解lvs的背景知识很有帮助。&lt;/p&gt;
&lt;p&gt;LVS英文官方手册：&lt;span&gt;&lt;a href=&quot;http://www.linuxvirtualserver.org/Documents.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.linuxvirtualserver.org/Documents.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。这个手册比较全面，对于了解和学习lvs的原理、配置很有帮助。&lt;/p&gt;
&lt;p&gt;LVS是章文嵩开发的一个国产开源负载均衡软件。LVS最初是他在大学期间的玩具，随着后来使用的用户越来越多，LVS也越来越完善，最终集成到了Linux的内核中。有不少开源牛人都为LVS开发过辅助工具和辅助组件，最出名的就是Alexandre为LVS编写的Keepalived，它最初专门用于监控LVS，后来加入了通过VRRP实现高可用的功能。&lt;/p&gt;
&lt;p&gt;LVS的全称是Linux virtual server，即Linux虚拟服务器。之所以是虚拟服务器，是因为LVS自身是个负载均衡器(director)，不直接处理请求，而是将请求转发至位于它后端真正的服务器realserver上。&lt;/p&gt;
&lt;p&gt;LVS是四层(传输层tcp/udp)、七层(应用层)的负载均衡工具，只不过大众一般都使用它的四层负载均衡功能ipvs，而七层的内容分发负载工具ktcpvs(kernel tcp virtual server)不怎么完善，使用的人并不多。&lt;/p&gt;
&lt;p&gt;ipvs是集成在内核中的框架，可以通过用户空间的程序&lt;code&gt;ipvsadm&lt;/code&gt;工具来管理，该工具可以定义一些规则来管理内核中的ipvs。就像iptables和netfilter的关系一样。&lt;/p&gt;

&lt;h2 id=&quot;2-lvs-ipvs-&quot;&gt;2.LVS-ipvs三种模式的工作原理&lt;/h2&gt;
&lt;p&gt;首先要解释的是LVS相关的几种IP：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;VIP&lt;/code&gt;:virtual IP，LVS服务器上接收外网数据包的网卡IP地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DIP&lt;/code&gt;:director IP，LVS服务器上转发数据包到realserver的网卡IP地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RIP&lt;/code&gt;:realserver(常简称为RS)上接收Director转发数据包的IP，即提供服务的服务器IP。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIP&lt;/code&gt;:客户端的IP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180211225301232-212054825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LVS的三种工作模式：通过网络地址转换(NAT)将一组服务器构成一个高性能的、高可用的虚拟服务器，是VS/NAT技术。在分析VS/NAT的缺点和网络服务的非对称性的基础上，提出了通过IP隧道实现虚拟服务器的方法VS/TUN（Virtual Server via IP Tunneling），和通过直接路由实现虚拟服务器的方法VS/DR（Virtual Server via Direct Routing），它们可以极大地提高系统的伸缩性。&lt;/p&gt;

&lt;h3 id=&quot;2-1-vs-nat-&quot;&gt;2.1 VS/NAT模式&lt;/h3&gt;
&lt;p&gt;客户端发送的请求到达Director后，Director根据负载均衡算法改写目标地址为后端某个RIP(web服务器池中主机之一)并转发给该后端主机，就像NAT一样。当后端主机处理完请求后，后端主机将响应数据交给Director，并由director改写源地址为VIP后传输给客户端。大多数商品化的IP负载均衡硬件都是使用此方法，如Cisco的LocalDirector、F5的Big/IP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180211234714295-412364937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种模式下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RIP和DIP一般处于同一私有网段中。但并非必须，只要它们能通信即可。&lt;/li&gt;
&lt;li&gt;各RealServer的网关指向DIP，这样能保证将响应数据交给Director。&lt;/li&gt;
&lt;li&gt;VS/NAT模式的最大缺点是Director负责所有进出数据：不仅处理客户端发起的请求，还负责将响应传输给客户端。而响应数据一般比请求数据大得多，调度器Director容易出现瓶颈。&lt;/li&gt;
&lt;li&gt;这种模式配置起来最简单。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-2-vs-tun-&quot;&gt;2.2 VS/TUN模式&lt;/h3&gt;
&lt;p&gt;采用NAT技术时，由于请求和响应报文都必须经过调度器地址重写，当客户请求越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。由于一般网络服务响应报文比请求报文大许多，采用VS/TUN技术后，调度器得到极大的解放，集群系统的最大吞吐量可以提高10倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180213102345546-471661305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VS/TUN模式的工作原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)IP隧道技术又称为IP封装技术，它可以将带有源和目标IP地址的数据报文使用新的源和目标IP进行第二次封装，这样这个报文就可以发送到一个指定的目标主机上；&lt;/li&gt;
&lt;li&gt;(2)VS/TUN模式下，调度器和后端服务器组之间使用IP隧道技术。当客户端发送的请求(CIP--&amp;gt;VIP)被director接收后，director修改该报文，加上IP隧道两端的IP地址作为新的源和目标地址，并将请求转发给后端被选中的一个目标；&lt;/li&gt;
&lt;li&gt;(3)当后端服务器接收到报文后，首先解封报文得到原有的CIP--&amp;gt;VIP，该后端服务器发现自身的tun接口上配置了VIP，因此接受该数据包。&lt;/li&gt;
&lt;li&gt;(4)当请求处理完成后，结果将不会重新交给director，而是直接返回给客户端；在后端服务器返回给客户端数据包时，由于使用的是普通网卡接口，根据一般的路由条目，源IP地址将是该网卡接口上的地址，例如是RIP。因此，要让响应数据包的源IP为VIP，必须添加一条特殊的路由条目，明确指定该路由的源地址是VIP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;采用VS/TUN模式时的基本属性和要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RealServer的RIP和director的DIP不用处于同一物理网络中，且RIP必须可以和公网通信。也就是说集群节点可以跨互联网实现。&lt;/li&gt;
&lt;li&gt;realserver的tun接口上需要配置VIP地址，以便接收director转发过来的数据包，以及作为响应报文的源IP。&lt;/li&gt;
&lt;li&gt;director给realserver时需要借助隧道，隧道外层的IP头部的源IP是DIP，目标IP是RIP。而realsever响应给客户端的IP头部是根据隧道内层的IP头分析得到的，源IP是VIP，目标IP是CIP。这样客户端就无法区分这个VIP到底是director的还是服务器组中的。&lt;/li&gt;
&lt;li&gt;需要添加一条特殊的路由条目，使得后端服务器返回响应给客户端时的源IP为VIP。&lt;/li&gt;
&lt;li&gt;director只处理入站请求，响应请求由realserver完成。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一般来说，VS/TUN模式会用来负载调度缓存服务器组，这些缓存服务器一般放置在不同网络环境，可以就近返回数据给客户端。在请求对象不能在Cache服务器本地命中的情况下，Cache服务器要向源服务器发请求，将结果取回，最后将结果返回给客户。&lt;/p&gt;

&lt;h3 id=&quot;2-3-vs-dr-&quot;&gt;2.3 VS/DR模式&lt;/h3&gt;
&lt;p&gt;VS/TUN模式下，调度器对数据包的处理是使用IP隧道技术进行二次封装。VS/DR模式和VS/TUN模式很类似，只不过调度器对数据包的处理是改写数据帧的目标MAC地址，通过链路层来负载均衡。&lt;/p&gt;
&lt;p&gt;VS/DR通过改写请求报文的目标MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返回给客户。同VS/TUN技术一样，VS/DR技术可极大地提高集群系统的伸缩性。这种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但是要求调度器与真实服务器都有一块网卡连在同一物理网段上，以便使用MAC地址通信转发数据包。&lt;/p&gt;
&lt;p&gt;VS/DR模式的工作原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)客户端发送的请求被director接收后，director根据负载均衡算法，改写数据帧的目标MAC地址为后端某RS的MAC地址，并将该数据包转发给该RS(实际上是往整个局域网发送，但只有该MAC地址的RS才不会丢弃)。&lt;/li&gt;
&lt;li&gt;(2)RS接收到数据包后，发现数据包的目标IP地址为VIP，而RS本身已经将VIP配置在了某个接口上，因此RS会接收下这个数据包并进行处理。&lt;/li&gt;
&lt;li&gt;(3)处理完毕后，RS直接将响应报文响应给客户端。在返回给客户端的时候，由于实用的是普通网卡接口，根据一般的路由条目，源IP地址将是该网卡接口上的地址，例如RIP。因此，要让响应数据包的源IP为VIP，需要添加一条特殊的路由条目，明确指定该路由的源地址为VIP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，客户端请求发送到LB上，源和目标IP为CIP:VIP，LB上有VIP和DIP，重新改写MAC地址后通过DIP发送给某个realserver，如RS1，此时源和目标IP还是CIP:VIP，但是目标MAC地址改写为RIP1所在网卡的MAC地址&quot;RS1_MAC&quot;，RS1发现自身有VIP地址，所以收下此数据报文(所以在RS上必须配置VIP)。返回时，RS1根据路由表直接返回给客户端，此时，源和目标IP是VIP:CIP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180213102610124-276805076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用VS/DR模式时的基本属性和要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RealServer的RIP和director的DIP必须处于同一网段中，以便使用MAC地址进行通信。&lt;/li&gt;
&lt;li&gt;realserver上必须配置VIP地址，以便接收director转发过来的数据包，以及作为响应报文的源IP。&lt;/li&gt;
&lt;li&gt;realsever响应给客户端的数据包的源和目标IP为VIP--&amp;gt;CIP。&lt;/li&gt;
&lt;li&gt;需要添加一条特殊的路由条目，使得后端服务器返回响应给客户端时的源IP为VIP。&lt;/li&gt;
&lt;li&gt;director只处理入站请求，响应请求由realserver完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-4-lvs-ipvs-&quot;&gt;2.4 lvs-ipvs的三种模式比较&lt;/h3&gt;
&lt;p&gt;三种模式的比较如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180213110217531-1638772778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在性能上，VS/DR和VS/TUN远高于VS/NAT，因为调度器只处于从客户到服务器的半连接中，按照半连接的TCP有限状态机进行状态迁移，极大程度上减轻了调度器的压力。VS/DR性能又稍高于VS/TUN，因为少了隧道的开销。但是，VS/DR和VS/TUN的主要区别是VS/TUN可以跨网络实现后端服务器负载均衡(也可以局域网内)，而VS/DR只能和director在局域网内进行负载均衡。&lt;/p&gt;

&lt;h2 id=&quot;3-vs-tun-vs-dr-arp-&quot;&gt;3.VS/TUN和VS/DR模式中的ARP问题&lt;/h2&gt;
&lt;p&gt;在【【VS/TUN和VS/DR的arp问题】】中非常详细地分析了ARP、arp_ignore和arp_announce相关原理和设置方法。此处简单说明为何需要设置arp抑制以及设置arp抑制的方法。&lt;/p&gt;
&lt;p&gt;当一个目标IP地址为VIP的数据包进入Director前端的路由器时，路由器会向局域网内发送ARP广播，以找出VIP地址的MAC地址在哪台主机上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180213170727562-1125645743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Director和各RS都配置了VIP。当路由器发送ARP广播后，Director和RS都会收到这个广播包，且都认为这个广播包找的就是自己，于是都回应给路由器，这样路由器上的ARP缓存表中的条目&lt;code&gt;VIP&amp;lt;--&amp;gt;vip_MAC&lt;/code&gt;就不断被覆盖直到最后一个回应。这样一来，路由器将把客户端的数据包发送给最后一个回应的主机，这台主机的VIP可能是Director上的，也可能是某个RS上的。在一定时间内，路由器收到目标IP为VIP的数据包都会发送给该主机。但路由器会定时发送ARP广播包，这样一来ARP缓存表中的VIP对应的MAC地址可能会换成另一台主机。&lt;/p&gt;
&lt;p&gt;因此，必须要保证路由器只保存Director上VIP对应的MAC地址，即只允许Director才对路由器的ARP广播进行回应。也就是说，所有RS上的VIP必须隐藏起来。&lt;/p&gt;
&lt;p&gt;一般通过将Real Server上的VIP设置在lo接口的别名接口上(如lo:0)，并设置&lt;code&gt;arp_ignore=1&lt;/code&gt;和&lt;code&gt;arp_announce=2&lt;/code&gt;的方式来隐藏RS上的VIP。至于VIP为何要设置在lo接口上以及为何要这样设置这两个arp参数，请参看【【VS/TUN和VS/DR的arp问题】】，内容非常详细。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/all/arp_ignore
echo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/all/arp_announce
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sysctl&lt;/span&gt; -w net.ipv4.conf.&lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt;.arp_ignore=1
&lt;span class=&quot;hljs-keyword&quot;&gt;sysctl&lt;/span&gt; -w net.ipv4.conf.&lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt;.arp_announce=2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者将arp参数设置到内核参数配置文件中以让其永久生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;net.ipv4.conf.all.arp_ignore=1&quot;&lt;/span&gt; &lt;span class=&quot;hljs-prompt&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;/etc/sysctl.conf
echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;net.ipv4.conf.all.arp_announce=2&quot;&lt;/span&gt; &lt;span class=&quot;hljs-prompt&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;/etc/sysctl.conf
sysctl -p
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在网上几乎所有文章还设置了lo接口上的arp参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/lo/arp_ignore
echo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/lo/arp_announce
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这没有任何意义，因为从lo接口不受arp参数的影响。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;应该在配置VIP之前就设置arp参数，以防止配置VIP后、设置arp抑制之前被外界主机发现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-lvs-&quot;&gt;4.LVS负载均衡的调度算法&lt;/h2&gt;
&lt;p&gt;LVS的调度算法，详细内容见官方手册：&lt;span&gt;&lt;a href=&quot;http://www.linuxvirtualserver.org/zh/lvs4.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.linuxvirtualserver.org/zh/lvs4.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;IPVS在内核中的负载均衡调度是&lt;span&gt;&lt;strong&gt;以连接为粒度&lt;/strong&gt;&lt;/span&gt;的。在HTTP协议（非持久）中，每次从WEB服务器上获取资源都需要建立一个TCP连接，同一用户的不同请求会被调度到不同的服务器上，所以这种细粒度的调度在一定程度上可以避免单个用户访问的突发性引起服务器间的负载不平衡。&lt;/p&gt;
&lt;p&gt;LVS分为两种调度方式：静态调度和动态反馈调度。&lt;/p&gt;
&lt;p&gt;静态调度方式是指不管RS的繁忙程度，根据调度算法计算后轮到谁就调度谁。例如两台realserver，一开始双方都在处理500个连接，下一个请求到来前，server1只断开了10个，而server2断开了490个，但是此时轮到了server1，就会调度server1而不管繁忙的程度。&lt;/p&gt;
&lt;p&gt;动态调度方式是指根据RS的繁忙程度反馈，计算出下一个连接应该调度谁(动态反馈负载均衡算法考虑服务器的实时负载和响应情况，不断调整服务器间处理请求的比例，来避免有些服务器超载时依然收到大量请求，从而提高整个系统的吞吐率)。&lt;/p&gt;
&lt;p&gt;在内核中的连接调度算法上，IPVS已实现了以下八种调度算法：默认的算法为wlc。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;静态调度：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;轮叫调度（Round-Robin Scheduling,rr）&lt;/li&gt;
&lt;li&gt;加权轮叫调度（Weighted Round-Robin Scheduling,wrr），按照权重比例作为轮询标准&lt;/li&gt;
&lt;li&gt;目标地址散列调度（Destination Hashing Scheduling,dh），目标地址哈希，对于同一目标IP的请求总是发往同一服务器&lt;/li&gt;
&lt;li&gt;源地址散列调度（Source Hashing Scheduling,sh），源地址哈希，在一定时间内，只要是来自同一个客户端的请求，就发送至同一个realserver&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态反馈调度：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;最小连接调度（Least-Connection Scheduling,lc），调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某服务器，其连接数加1；当连接中止或超时，其连接数减1。当各个服务器的处理能力不同时，该算法不理想。&lt;/li&gt;
&lt;li&gt;加权最小连接调度（Weighted Least-Connection Scheduling,wlc）&lt;/li&gt;
&lt;li&gt;基于本地的最少连接（Locality-Based Least Connections Scheduling,lblc），目前该算法主要用于cache集群系统。&lt;/li&gt;
&lt;li&gt;带复制的基于局部性最少连接（Locality-Based Least Connections with Replication Scheduling,lblcr），目前主要用于Cache集群系统。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8451982.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8451982.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Feb 2018 08:51:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8451982.html</dc:identifier>
</item>
<item>
<title>CNN网络架构演进：从LeNet到DenseNet - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8451834.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8451834.html</guid>
<description>&lt;p&gt;卷积神经网络可谓是现在深度学习领域中大红大紫的网络框架，尤其在计算机视觉领域更是一枝独秀。CNN从90年代的LeNet开始，21世纪初沉寂了10年，直到12年AlexNet开始又再焕发第二春，从ZF Net到VGG，GoogLeNet再到ResNet和最近的DenseNet，网络越来越深，架构越来越复杂，解决反向传播时梯度消失的方法也越来越巧妙。新年有假期，就好好总结一波CNN的各种经典架构吧，领略一下CNN的发展历程中各路大神之间的智慧碰撞之美。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131558874-187072295.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面那图是ILSVRC历年的Top-5错误率，我们会按照以上经典网络出现的时间顺序对他们进行介绍。&lt;/p&gt;
&lt;p&gt;本文将会谈到以下经典的卷积神经网络：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LeNet&lt;/li&gt;
&lt;li&gt;AlexNet&lt;/li&gt;
&lt;li&gt;ZF&lt;/li&gt;
&lt;li&gt;VGG&lt;/li&gt;
&lt;li&gt;GoogLeNet&lt;/li&gt;
&lt;li&gt;ResNet&lt;/li&gt;
&lt;li&gt;DenseNet&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;开山之作lenet&quot;&gt;开山之作：LeNet&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131615671-367457714.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;闪光点：定义了CNN的基本组件，是CNN的鼻祖。&lt;/p&gt;
&lt;p&gt;LeNet是卷积神经网络的祖师爷LeCun在1998年提出，用于解决手写数字识别的视觉任务。自那时起，CNN的最基本的架构就定下来了：卷积层、池化层、全连接层。如今各大深度学习框架中所使用的LeNet都是简化改进过的LeNet-5（-5表示具有5个层），和原始的LeNet有些许不同，比如把激活函数改为了现在很常用的ReLu。&lt;/p&gt;
&lt;p&gt;LeNet-5跟现有的conv-&amp;gt;pool-&amp;gt;ReLU的套路不同，它使用的方式是conv1-&amp;gt;pool-&amp;gt;conv2-&amp;gt;pool2再接全连接层，但是不变的是，卷积层后紧接池化层的模式依旧不变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131630609-291700181.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上图为例，对经典的LeNet-5做深入分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先输入图像是单通道的28*28大小的图像，用矩阵表示就是[1,28,28]&lt;/li&gt;
&lt;li&gt;第一个卷积层conv1所用的卷积核尺寸为5*5，滑动步长为1，卷积核数目为20，那么经过该层后图像尺寸变为24，28-5+1=24，输出矩阵为[20,24,24]。&lt;/li&gt;
&lt;li&gt;第一个池化层pool核尺寸为2*2，步长2，这是没有重叠的max pooling，池化操作后，图像尺寸减半，变为12×12，输出矩阵为[20,12,12]。&lt;/li&gt;
&lt;li&gt;第二个卷积层conv2的卷积核尺寸为5*5，步长1，卷积核数目为50，卷积后图像尺寸变为8,这是因为12-5+1=8，输出矩阵为[50,8,8].&lt;/li&gt;
&lt;li&gt;第二个池化层pool2核尺寸为2*2，步长2，这是没有重叠的max pooling，池化操作后，图像尺寸减半，变为4×4，输出矩阵为[50,4,4]。&lt;/li&gt;
&lt;li&gt;pool2后面接全连接层fc1，神经元数目为500，再接relu激活函数。&lt;/li&gt;
&lt;li&gt;再接fc2，神经元个数为10，得到10维的特征向量，用于10个数字的分类训练，送入softmaxt分类，得到分类结果的概率output。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;LeNet的Keras实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def LeNet():
    model = Sequential()
    model.add(Conv2D(32,(5,5),strides=(1,1),input_shape=(28,28,1),padding='valid',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    model.add(Conv2D(64,(5,5),strides=(1,1),padding='valid',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    model.add(Flatten())
    model.add(Dense(100,activation='relu'))
    model.add(Dense(10,activation='softmax'))
    return model&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;王者归来alexnet&quot;&gt;王者归来：AlexNet&lt;/h2&gt;
&lt;p&gt;AlexNet在2012年ImageNet竞赛中以超过第二名10.9个百分点的绝对优势一举夺冠，从此深度学习和卷积神经网络名声鹊起，深度学习的研究如雨后春笋般出现，AlexNet的出现可谓是卷积神经网络的王者归来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131643890-1883639712.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;闪光点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更深的网络&lt;/li&gt;
&lt;li&gt;数据增广&lt;/li&gt;
&lt;li&gt;ReLU&lt;/li&gt;
&lt;li&gt;dropout&lt;/li&gt;
&lt;li&gt;LRN&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上图AlexNet架构为例，这个网络前面5层是卷积层，后面三层是全连接层，最终softmax输出是1000类，取其前两层进行详细说明。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;AlexNet共包含5层卷积层和三层全连接层，层数比LeNet多了不少，但卷积神经网络总的流程并没有变化，只是在深度上加了不少。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;AlexNet针对的是1000类的分类问题，输入图片规定是256×256的三通道彩色图片，为了增强模型的泛化能力，避免过拟合，作者使用了随机裁剪的思路对原来256×256的图像进行随机裁剪，得到尺寸为3×224×224的图像，输入到网络训练。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131703406-1977094290.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为使用多GPU训练，所以可以看到第一层卷积层后有两个完全一样的分支，以加速训练。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;针对一个分支分析：第一层卷积层conv1的卷积核尺寸为11×11，滑动步长为4，卷积核数目为48。卷积后得到的输出矩阵为[48,55,55]。这里的55是个难以理解的数字，作者也没有对此说明，如果按照正常计算的话(224-11)/4+1 != 55的，所以这里是做了padding再做卷积的，即先padiing图像至227×227，再做卷积(227-11)/4+1 = 55。这些像素层经过relu1单元的处理，生成激活像素层，尺寸仍为2组48×55×55的像素层数据&lt;br/&gt;。然后经过归一化处理，归一化运算的尺度为5*5。第一卷积层运算结束后形成的像素层的规模为48×27×27。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;输入矩阵是[48,55,55].接着是池化层，做max pooling操作，池化运算的尺度为3*3，运算的步长为2，则池化后图像的尺寸为(55-3)/2+1=27。所以得到的输出矩阵是[48,27,27]。后面层不再重复叙述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;AlexNet用到训练技巧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据增广技巧来增加模型泛化能力。&lt;/li&gt;
&lt;li&gt;用ReLU代替Sigmoid来加快SGD的收敛速度&lt;/li&gt;
&lt;li&gt;Dropout:Dropout原理类似于浅层学习算法的中集成算法，该方法通过让全连接层的神经元（该模型在前两个全连接层引入Dropout）以一定的概率失去活性（比如0.5）失活的神经元不再参与前向和反向传播，相当于约有一半的神经元不再起作用。在测试的时候，让所有神经元的输出乘0.5。Dropout的引用，有效缓解了模型的过拟合。&lt;/li&gt;
&lt;li&gt;Local Responce Normalization：局部响应归一层的基本思路是，假如这是网络的一块，比如是 13×13×256， LRN 要做的就是选取一个位置，比如说这样一个位置，从这个位置穿过整个通道，能得到 256 个数字，并进行归一化。进行局部响应归一化的动机是，对于这张 13×13 的图像中的每个位置来说，我们可能并不需要太多的高激活神经元。但是后来，很多研究者发现 LRN 起不到太大作用，因为并不重要，而且我们现在并不用 LRN 来训练网络。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AlexNet的Keras实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def AlexNet():

    model = Sequential()
    model.add(Conv2D(96,(11,11),strides=(4,4),input_shape=(227,227,3),padding='valid',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(3,3),strides=(2,2)))
    model.add(Conv2D(256,(5,5),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(3,3),strides=(2,2)))
    model.add(Conv2D(384,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(384,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(256,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(3,3),strides=(2,2)))
    model.add(Flatten())
    model.add(Dense(4096,activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(4096,activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(1000,activation='softmax'))
    return model
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;稳步前行zf-net&quot;&gt;稳步前行：ZF-Net&lt;/h2&gt;
&lt;p&gt;ZFNet是2013ImageNet分类任务的冠军，其网络结构没什么改进，只是调了调参，性能较Alex提升了不少。ZF-Net只是将AlexNet第一层卷积核由11变成7，步长由4变为2，第3，4，5卷积层转变为384，384，256。这一年的ImageNet还是比较平静的一届，其冠军ZF-Net的名堂也没其他届的经典网络架构响亮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131724437-1439325209.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ZF-Net的Keras实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def ZF_Net():
    model = Sequential()  
    model.add(Conv2D(96,(7,7),strides=(2,2),input_shape=(224,224,3),padding='valid',activation='relu',kernel_initializer='uniform'))  
    model.add(MaxPooling2D(pool_size=(3,3),strides=(2,2)))  
    model.add(Conv2D(256,(5,5),strides=(2,2),padding='same',activation='relu',kernel_initializer='uniform'))  
    model.add(MaxPooling2D(pool_size=(3,3),strides=(2,2)))  
    model.add(Conv2D(384,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))  
    model.add(Conv2D(384,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))  
    model.add(Conv2D(256,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))  
    model.add(MaxPooling2D(pool_size=(3,3),strides=(2,2)))  
    model.add(Flatten())  
    model.add(Dense(4096,activation='relu'))  
    model.add(Dropout(0.5))  
    model.add(Dense(4096,activation='relu'))  
    model.add(Dropout(0.5))  
    model.add(Dense(1000,activation='softmax'))  
    return model
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;越走越深vgg-nets&quot;&gt;越走越深：VGG-Nets&lt;/h2&gt;
&lt;p&gt;VGG-Nets是由牛津大学VGG（Visual Geometry Group）提出，是2014年ImageNet竞赛定位任务的第一名和分类任务的第二名的中的基础网络。VGG可以看成是加深版本的AlexNet. 都是conv layer + FC layer，在当时看来这是一个非常深的网络了，因为层数高达十多层，我们从其论文名字就知道了（《Very Deep Convolutional Networks for Large-Scale Visual Recognition》），当然以现在的目光看来VGG真的称不上是一个very deep的网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131736640-1269864740.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面一个表格是描述的是VGG-Net的网络结构以及诞生过程。为了解决初始化（权重初始化）等问题，VGG采用的是一种Pre-training的方式，这种方式在经典的神经网络中经常见得到，就是先训练一部分小网络，然后再确保这部分网络稳定之后，再在这基础上逐渐加深。表1从左到右体现的就是这个过程，并且当网络处于D阶段的时候，效果是最优的，因此D阶段的网络也就是VGG-16了！E阶段得到的网络就是VGG-19了！VGG-16的16指的是conv+fc的总层数是16，是不包括max pool的层数！&lt;/p&gt;
&lt;p&gt;下面这个图就是VGG-16的网络结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131751843-269987601.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图看出，VGG-16的结构非常整洁，深度较AlexNet深得多，里面包含多个conv-&amp;gt;conv-&amp;gt;max_pool这类的结构,VGG的卷积层都是same的卷积，即卷积过后的输出图像的尺寸与输入是一致的，它的下采样完全是由max pooling来实现。&lt;/p&gt;
&lt;p&gt;VGG网络后接3个全连接层，filter的个数（卷积后的输出通道数）从64开始，然后没接一个pooling后其成倍的增加，128、512，VGG的注意贡献是使用小尺寸的filter，及有规则的卷积-池化操作。&lt;/p&gt;
&lt;p&gt;闪光点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;卷积层使用更小的filter尺寸和间隔&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与AlexNet相比，可以看出VGG-Nets的卷积核尺寸还是很小的，比如AlexNet第一层的卷积层用到的卷积核尺寸就是11*11，这是一个很大卷积核了。而反观VGG-Nets，用到的卷积核的尺寸无非都是1×1和3×3的小卷积核，可以替代大的filter尺寸。&lt;/p&gt;
&lt;p&gt;3×3卷积核的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多个3×3的卷基层比一个大尺寸filter卷基层有更多的非线性，使得判决函数更加具有判决性&lt;/li&gt;
&lt;li&gt;多个3×3的卷积层比一个大尺寸的filter有更少的参数，假设卷基层的输入和输出的特征图大小相同为C，那么三个3×3的卷积层参数个数3×（3×3×C×C）=27CC；一个7×7的卷积层参数为49CC；所以可以把三个3×3的filter看成是一个7×7filter的分解（中间层有非线性的分解）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1*1卷积核的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作用是在不影响输入输出维数的情况下，对输入进行线性形变，然后通过Relu进行非线性处理，增加网络的非线性表达能力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;VGG-16的Keras实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def VGG_16():   
    model = Sequential()
    
    model.add(Conv2D(64,(3,3),strides=(1,1),input_shape=(224,224,3),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(64,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    
    model.add(Conv2D(128,(3,2),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(128,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    
    model.add(Conv2D(256,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(256,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(256,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    
    model.add(Conv2D(512,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(512,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(512,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    
    model.add(Conv2D(512,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(512,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(Conv2D(512,(3,3),strides=(1,1),padding='same',activation='relu',kernel_initializer='uniform'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    
    model.add(Flatten())
    model.add(Dense(4096,activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(4096,activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(1000,activation='softmax'))
    
    return model
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;大浪推手googlenet&quot;&gt;大浪推手：GoogLeNet&lt;/h2&gt;
&lt;p&gt;GoogLeNet在2014的ImageNet分类任务上击败了VGG-Nets夺得冠军，其实力肯定是非常深厚的，GoogLeNet跟AlexNet,VGG-Nets这种单纯依靠加深网络结构进而改进网络性能的思路不一样，它另辟幽径，在加深网络的同时（22层），也在网络结构上做了创新，引入Inception结构代替了单纯的卷积+激活的传统操作（这思路最早由Network in Network提出）。GoogLeNet进一步把对卷积神经网络的研究推上新的高度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131814499-915840988.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;闪光点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引入Inception结构&lt;/li&gt;
&lt;li&gt;中间层的辅助LOSS单元&lt;/li&gt;
&lt;li&gt;后面的全连接层全部替换为简单的全局平均pooling&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131828906-234829229.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图结构就是Inception，结构里的卷积stride都是1，另外为了保持特征响应图大小一致，都用了零填充。最后每个卷积层后面都立刻接了个ReLU层。在输出前有个叫concatenate的层，直译的意思是“并置”，即把4组不同类型但大小相同的特征响应图一张张并排叠起来，形成新的特征响应图。Inception结构里主要做了两件事：1. 通过3×3的池化、以及1×1、3×3和5×5这三种不同尺度的卷积核，一共4种方式对输入的特征响应图做了特征提取。2. 为了降低计算量。同时让信息通过更少的连接传递以达到更加稀疏的特性，采用1×1卷积核来实现降维。&lt;/p&gt;
&lt;p&gt;这里想再详细谈谈1×1卷积核的作用，它究竟是怎么实现降维的。下面图1是3×3卷积核的卷积，图2是1×1卷积核的卷积过程。对于单通道输入，1×1的卷积确实不能起到降维作用，但对于多通道输入，就不不同了。考虑[50,200,200]的矩阵输入，我们可以使用20个1×1的卷积核进行卷积，得到输出[20,200,200]。有人问，我用20个3×3的卷积核不是也能得到[20,200,200]的矩阵输出吗，为什么就1×1的可以降维？我们计算一下卷积参数就知道了，对于1×1的参数总数：20×200×200×（1×1），对于3×3的参数总数：20×200×200×（3×3），可以看出，使用1×1的参数总数仅为3×3的总数的九分之一！这就是降维！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131851234-1368185941.gif&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131904781-1419692084.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GoogLeNet网络结构中有3个LOSS单元，这样的网络设计是为了帮助网络的收敛。在中间层加入辅助计算的LOSS单元，目的是计算损失时让低层的特征也有很好的区分能力，从而让网络更好地被训练。在论文中，这两个辅助LOSS单元的计算被乘以0.3，然后和最后的LOSS相加作为最终的损失函数来训练网络。&lt;/p&gt;
&lt;p&gt;GoogLeNet还有一个闪光点值得一提，那就是将后面的全连接层全部替换为简单的全局平均pooling，在最后参数会变的更少。而在AlexNet中最后3层的全连接层参数差不多占总参数的90%，使用大网络在宽度和深度允许GoogleNet移除全连接层，但并不会影响到结果的精度，在ImageNet中实现93.3%的精度，而且要比VGG还要快。&lt;/p&gt;
&lt;p&gt;GoogLeNet的Keras实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def Conv2d_BN(x, nb_filter,kernel_size, padding='same',strides=(1,1),name=None):
    if name is not None:
        bn_name = name + '_bn'
        conv_name = name + '_conv'
    else:
        bn_name = None
        conv_name = None

    x = Conv2D(nb_filter,kernel_size,padding=padding,strides=strides,activation='relu',name=conv_name)(x)
    x = BatchNormalization(axis=3,name=bn_name)(x)
    return x

def Inception(x,nb_filter):
    branch1x1 = Conv2d_BN(x,nb_filter,(1,1), padding='same',strides=(1,1),name=None)

    branch3x3 = Conv2d_BN(x,nb_filter,(1,1), padding='same',strides=(1,1),name=None)
    branch3x3 = Conv2d_BN(branch3x3,nb_filter,(3,3), padding='same',strides=(1,1),name=None)

    branch5x5 = Conv2d_BN(x,nb_filter,(1,1), padding='same',strides=(1,1),name=None)
    branch5x5 = Conv2d_BN(branch5x5,nb_filter,(1,1), padding='same',strides=(1,1),name=None)

    branchpool = MaxPooling2D(pool_size=(3,3),strides=(1,1),padding='same')(x)
    branchpool = Conv2d_BN(branchpool,nb_filter,(1,1),padding='same',strides=(1,1),name=None)

    x = concatenate([branch1x1,branch3x3,branch5x5,branchpool],axis=3)

    return x

def GoogLeNet():
    inpt = Input(shape=(224,224,3))
    #padding = 'same'，填充为(步长-1）/2,还可以用ZeroPadding2D((3,3))
    x = Conv2d_BN(inpt,64,(7,7),strides=(2,2),padding='same')
    x = MaxPooling2D(pool_size=(3,3),strides=(2,2),padding='same')(x)
    x = Conv2d_BN(x,192,(3,3),strides=(1,1),padding='same')
    x = MaxPooling2D(pool_size=(3,3),strides=(2,2),padding='same')(x)
    x = Inception(x,64)#256
    x = Inception(x,120)#480
    x = MaxPooling2D(pool_size=(3,3),strides=(2,2),padding='same')(x)
    x = Inception(x,128)#512
    x = Inception(x,128)
    x = Inception(x,128)
    x = Inception(x,132)#528
    x = Inception(x,208)#832
    x = MaxPooling2D(pool_size=(3,3),strides=(2,2),padding='same')(x)
    x = Inception(x,208)
    x = Inception(x,256)#1024
    x = AveragePooling2D(pool_size=(7,7),strides=(7,7),padding='same')(x)
    x = Dropout(0.4)(x)
    x = Dense(1000,activation='relu')(x)
    x = Dense(1000,activation='softmax')(x)
    model = Model(inpt,x,name='inception')
    return model&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;里程碑式创新resnet&quot;&gt;里程碑式创新：ResNet&lt;/h2&gt;
&lt;p&gt;2015年何恺明推出的ResNet在ISLVRC和COCO上横扫所有选手，获得冠军。ResNet在网络结构上做了大创新，而不再是简单的堆积层数，ResNet在卷积神经网络的新思路，绝对是深度学习发展历程上里程碑式的事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131926202-233779647.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;闪光点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;层数非常深，已经超过百层&lt;/li&gt;
&lt;li&gt;引入残差单元来解决退化问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从前面可以看到，随着网络深度增加，网络的准确度应该同步增加，当然要注意过拟合问题。但是网络深度增加的一个问题在于这些增加的层是参数更新的信号，因为梯度是从后向前传播的，增加网络深度后，比较靠前的层梯度会很小。这意味着这些层基本上学习停滞了，这就是梯度消失问题。深度网络的第二个问题在于训练，当网络更深时意味着参数空间更大，优化问题变得更难，因此简单地去增加网络深度反而出现更高的训练误差，深层网络虽然收敛了，但网络却开始退化了，即增加网络层数却导致更大的误差，比如下图，一个56层的网络的性能却不如20层的性能好，这不是因为过拟合（训练集训练误差依然很高），这就是烦人的退化问题。残差网络ResNet设计一种残差模块让我们可以训练更深的网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131941296-1327847371.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里详细分析一下残差单元来理解ResNet的精髓。&lt;/p&gt;
&lt;p&gt;从下图可以看出，数据经过了两条路线，一条是常规路线，另一条则是捷径（shortcut），直接实现单位映射的直接连接的路线，这有点类似与电路中的“短路”。通过实验，这种带有shortcut的结构确实可以很好地应对退化问题。我们把网络中的一个模块的输入和输出关系看作是y=H(x)，那么直接通过梯度方法求H(x)就会遇到上面提到的退化问题，如果使用了这种带shortcut的结构，那么可变参数部分的优化目标就不再是H(x),若用F(x)来代表需要优化的部分的话，则H(x)=F(x)+x，也就是F(x)=H(x)-x。因为在单位映射的假设中y=x就相当于观测值，所以F(x)就对应着残差，因而叫残差网络。为啥要这样做，因为作者认为学习残差F(X)比直接学习H(X)简单！设想下，现在根据我们只需要去学习输入和输出的差值就可以了，绝对量变为相对量（H（x）-x 就是输出相对于输入变化了多少），优化起来简单很多。&lt;/p&gt;
&lt;p&gt;考虑到x的维度与F(X)维度可能不匹配情况，需进行维度匹配。这里论文中采用两种方法解决这一问题(其实是三种，但通过实验发现第三种方法会使performance急剧下降，故不采用):&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;zero_padding:对恒等层进行0填充的方式将维度补充完整。这种方法不会增加额外的参数&lt;/li&gt;
&lt;li&gt;projection:在恒等层采用1x1的卷积核来增加维度。这种方法会增加额外的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217131952952-92773471.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图展示了两种形态的残差模块，左图是常规残差模块，有两个3×3卷积核卷积核组成，但是随着网络进一步加深，这种残差结构在实践中并不是十分有效。针对这问题，右图的“瓶颈残差模块”（bottleneck residual block）可以有更好的效果，它依次由1×1、3×3、1×1这三个卷积层堆积而成，这里的1×1的卷积能够起降维或升维的作用，从而令3×3的卷积可以在相对较低维度的输入上进行，以达到提高计算效率的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217132002999-1852938927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ResNet-50的Keras实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def Conv2d_BN(x, nb_filter,kernel_size, strides=(1,1), padding='same',name=None):
    if name is not None:
        bn_name = name + '_bn'
        conv_name = name + '_conv'
    else:
        bn_name = None
        conv_name = None

    x = Conv2D(nb_filter,kernel_size,padding=padding,strides=strides,activation='relu',name=conv_name)(x)
    x = BatchNormalization(axis=3,name=bn_name)(x)
    return x

def Conv_Block(inpt,nb_filter,kernel_size,strides=(1,1), with_conv_shortcut=False):
    x = Conv2d_BN(inpt,nb_filter=nb_filter[0],kernel_size=(1,1),strides=strides,padding='same')
    x = Conv2d_BN(x, nb_filter=nb_filter[1], kernel_size=(3,3), padding='same')
    x = Conv2d_BN(x, nb_filter=nb_filter[2], kernel_size=(1,1), padding='same')
    if with_conv_shortcut:
        shortcut = Conv2d_BN(inpt,nb_filter=nb_filter[2],strides=strides,kernel_size=kernel_size)
        x = add([x,shortcut])
        return x
    else:
        x = add([x,inpt])
        return x

def ResNet50():
    inpt = Input(shape=(224,224,3))
    x = ZeroPadding2D((3,3))(inpt)
    x = Conv2d_BN(x,nb_filter=64,kernel_size=(7,7),strides=(2,2),padding='valid')
    x = MaxPooling2D(pool_size=(3,3),strides=(2,2),padding='same')(x)
    
    x = Conv_Block(x,nb_filter=[64,64,256],kernel_size=(3,3),strides=(1,1),with_conv_shortcut=True)
    x = Conv_Block(x,nb_filter=[64,64,256],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[64,64,256],kernel_size=(3,3))
    
    x = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3),strides=(2,2),with_conv_shortcut=True)
    x = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[128,128,512],kernel_size=(3,3))
    
    x = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3),strides=(2,2),with_conv_shortcut=True)
    x = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[256,256,1024],kernel_size=(3,3))
    
    x = Conv_Block(x,nb_filter=[512,512,2048],kernel_size=(3,3),strides=(2,2),with_conv_shortcut=True)
    x = Conv_Block(x,nb_filter=[512,512,2048],kernel_size=(3,3))
    x = Conv_Block(x,nb_filter=[512,512,2048],kernel_size=(3,3))
    x = AveragePooling2D(pool_size=(7,7))(x)
    x = Flatten()(x)
    x = Dense(1000,activation='softmax')(x)
    
    model = Model(inputs=inpt,outputs=x)
    return model&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;继往开来densenet&quot;&gt;继往开来：DenseNet&lt;/h2&gt;
&lt;p&gt;自Resnet提出以后，ResNet的变种网络层出不穷，都各有其特点，网络性能也有一定的提升。本文介绍的最后一个网络是CVPR 2017最佳论文DenseNet，论文中提出的DenseNet（Dense Convolutional Network）主要还是和ResNet及Inception网络做对比，思想上有借鉴，但却是全新的结构，网络结构并不复杂，却非常有效，在CIFAR指标上全面超越ResNet。可以说DenseNet吸收了ResNet最精华的部分，并在此上做了更加创新的工作，使得网络性能进一步提升。&lt;/p&gt;
&lt;p&gt;闪光点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;密集连接：缓解梯度消失问题，加强特征传播，鼓励特征复用，极大的减少了参数量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DenseNet 是一种具有密集连接的卷积神经网络。在该网络中，任何两层之间都有直接的连接，也就是说，网络每一层的输入都是前面所有层输出的并集，而该层所学习的特征图也会被直接传给其后面所有层作为输入。下图是 DenseNet 的一个dense block示意图，一个block里面的结构如下，与ResNet中的BottleNeck基本一致：BN-ReLU-Conv(1×1)-BN-ReLU-Conv(3×3) ，而一个DenseNet则由多个这种block组成。每个DenseBlock的之间层称为transition layers，由BN−&amp;gt;Conv(1×1)−&amp;gt;averagePooling(2×2)组成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217132019609-1216378928.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;密集连接不会带来冗余吗？不会！密集连接这个词给人的第一感觉就是极大的增加了网络的参数量和计算量。但实际上 DenseNet 比其他网络效率更高，其关键就在于网络每层计算量的减少以及特征的重复利用。DenseNet则是让l层的输入直接影响到之后的所有层，它的输出为：xl=Hl([X0,X1,…,xl−1])，其中[x0,x1,...,xl−1]就是将之前的feature map以通道的维度进行合并。并且由于每一层都包含之前所有层的输出信息，因此其只需要很少的特征图就够了，这也是为什么DneseNet的参数量较其他模型大大减少的原因。这种dense connection相当于每一层都直接连接input和loss，因此就可以减轻梯度消失现象，这样更深网络不是问题&lt;/p&gt;
&lt;p&gt;需要明确一点，dense connectivity 仅仅是在一个dense block里的，不同dense block 之间是没有dense connectivity的，比如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180217132035937-2041404109.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;天底下没有免费的午餐，网络自然也不例外。在同层深度下获得更好的收敛率，自然是有额外代价的。其代价之一，就是其恐怖如斯的内存占用。&lt;/p&gt;
&lt;p&gt;DenseNet-121的Keras实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def DenseNet121(nb_dense_block=4, growth_rate=32, nb_filter=64, reduction=0.0, dropout_rate=0.0, weight_decay=1e-4, classes=1000, weights_path=None):
    '''Instantiate the DenseNet 121 architecture,
        # Arguments
            nb_dense_block: number of dense blocks to add to end
            growth_rate: number of filters to add per dense block
            nb_filter: initial number of filters
            reduction: reduction factor of transition blocks.
            dropout_rate: dropout rate
            weight_decay: weight decay factor
            classes: optional number of classes to classify images
            weights_path: path to pre-trained weights
        # Returns
            A Keras model instance.
    '''
    eps = 1.1e-5

    # compute compression factor
    compression = 1.0 - reduction

    # Handle Dimension Ordering for different backends
    global concat_axis
    if K.image_dim_ordering() == 'tf':
      concat_axis = 3
      img_input = Input(shape=(224, 224, 3), name='data')
    else:
      concat_axis = 1
      img_input = Input(shape=(3, 224, 224), name='data')

    # From architecture for ImageNet (Table 1 in the paper)
    nb_filter = 64
    nb_layers = [6,12,24,16] # For DenseNet-121

    # Initial convolution
    x = ZeroPadding2D((3, 3), name='conv1_zeropadding')(img_input)
    x = Convolution2D(nb_filter, 7, 7, subsample=(2, 2), name='conv1', bias=False)(x)
    x = BatchNormalization(epsilon=eps, axis=concat_axis, name='conv1_bn')(x)
    x = Scale(axis=concat_axis, name='conv1_scale')(x)
    x = Activation('relu', name='relu1')(x)
    x = ZeroPadding2D((1, 1), name='pool1_zeropadding')(x)
    x = MaxPooling2D((3, 3), strides=(2, 2), name='pool1')(x)

    # Add dense blocks
    for block_idx in range(nb_dense_block - 1):
        stage = block_idx+2
        x, nb_filter = dense_block(x, stage, nb_layers[block_idx], nb_filter, growth_rate, dropout_rate=dropout_rate, weight_decay=weight_decay)

        # Add transition_block
        x = transition_block(x, stage, nb_filter, compression=compression, dropout_rate=dropout_rate, weight_decay=weight_decay)
        nb_filter = int(nb_filter * compression)

    final_stage = stage + 1
    x, nb_filter = dense_block(x, final_stage, nb_layers[-1], nb_filter, growth_rate, dropout_rate=dropout_rate, weight_decay=weight_decay)

    x = BatchNormalization(epsilon=eps, axis=concat_axis, name='conv'+str(final_stage)+'_blk_bn')(x)
    x = Scale(axis=concat_axis, name='conv'+str(final_stage)+'_blk_scale')(x)
    x = Activation('relu', name='relu'+str(final_stage)+'_blk')(x)
    x = GlobalAveragePooling2D(name='pool'+str(final_stage))(x)

    x = Dense(classes, name='fc6')(x)
    x = Activation('softmax', name='prob')(x)

    model = Model(img_input, x, name='densenet')

    if weights_path is not None:
      model.load_weights(weights_path)

    return model


def conv_block(x, stage, branch, nb_filter, dropout_rate=None, weight_decay=1e-4):
    '''Apply BatchNorm, Relu, bottleneck 1x1 Conv2D, 3x3 Conv2D, and option dropout
        # Arguments
            x: input tensor 
            stage: index for dense block
            branch: layer index within each dense block
            nb_filter: number of filters
            dropout_rate: dropout rate
            weight_decay: weight decay factor
    '''
    eps = 1.1e-5
    conv_name_base = 'conv' + str(stage) + '_' + str(branch)
    relu_name_base = 'relu' + str(stage) + '_' + str(branch)

    # 1x1 Convolution (Bottleneck layer)
    inter_channel = nb_filter * 4  
    x = BatchNormalization(epsilon=eps, axis=concat_axis, name=conv_name_base+'_x1_bn')(x)
    x = Scale(axis=concat_axis, name=conv_name_base+'_x1_scale')(x)
    x = Activation('relu', name=relu_name_base+'_x1')(x)
    x = Convolution2D(inter_channel, 1, 1, name=conv_name_base+'_x1', bias=False)(x)

    if dropout_rate:
        x = Dropout(dropout_rate)(x)

    # 3x3 Convolution
    x = BatchNormalization(epsilon=eps, axis=concat_axis, name=conv_name_base+'_x2_bn')(x)
    x = Scale(axis=concat_axis, name=conv_name_base+'_x2_scale')(x)
    x = Activation('relu', name=relu_name_base+'_x2')(x)
    x = ZeroPadding2D((1, 1), name=conv_name_base+'_x2_zeropadding')(x)
    x = Convolution2D(nb_filter, 3, 3, name=conv_name_base+'_x2', bias=False)(x)

    if dropout_rate:
        x = Dropout(dropout_rate)(x)

    return x


def transition_block(x, stage, nb_filter, compression=1.0, dropout_rate=None, weight_decay=1E-4):
    ''' Apply BatchNorm, 1x1 Convolution, averagePooling, optional compression, dropout 
        # Arguments
            x: input tensor
            stage: index for dense block
            nb_filter: number of filters
            compression: calculated as 1 - reduction. Reduces the number of feature maps in the transition block.
            dropout_rate: dropout rate
            weight_decay: weight decay factor
    '''

    eps = 1.1e-5
    conv_name_base = 'conv' + str(stage) + '_blk'
    relu_name_base = 'relu' + str(stage) + '_blk'
    pool_name_base = 'pool' + str(stage) 

    x = BatchNormalization(epsilon=eps, axis=concat_axis, name=conv_name_base+'_bn')(x)
    x = Scale(axis=concat_axis, name=conv_name_base+'_scale')(x)
    x = Activation('relu', name=relu_name_base)(x)
    x = Convolution2D(int(nb_filter * compression), 1, 1, name=conv_name_base, bias=False)(x)

    if dropout_rate:
        x = Dropout(dropout_rate)(x)

    x = AveragePooling2D((2, 2), strides=(2, 2), name=pool_name_base)(x)

    return x


def dense_block(x, stage, nb_layers, nb_filter, growth_rate, dropout_rate=None, weight_decay=1e-4, grow_nb_filters=True):
    ''' Build a dense_block where the output of each conv_block is fed to subsequent ones
        # Arguments
            x: input tensor
            stage: index for dense block
            nb_layers: the number of layers of conv_block to append to the model.
            nb_filter: number of filters
            growth_rate: growth rate
            dropout_rate: dropout rate
            weight_decay: weight decay factor
            grow_nb_filters: flag to decide to allow number of filters to grow
    '''

    eps = 1.1e-5
    concat_feat = x

    for i in range(nb_layers):
        branch = i+1
        x = conv_block(concat_feat, stage, branch, growth_rate, dropout_rate, weight_decay)
        concat_feat = merge([concat_feat, x], mode='concat', concat_axis=concat_axis, name='concat_'+str(stage)+'_'+str(branch))

        if grow_nb_filters:
            nb_filter += growth_rate

    return concat_feat, nb_filter
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 17 Feb 2018 05:21:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8451834.html</dc:identifier>
</item>
<item>
<title>树莓派小车（三）Python控制小车 - 李汉祥</title>
<link>http://www.cnblogs.com/lihanxiang/p/8451818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lihanxiang/p/8451818.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-57ab4d3b34d0f7e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;正文之前&quot;&gt;正文之前&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于最近忙于复习赶考，所以暂时没有拿起树莓派小车，直到昨天，终于空出时间来把代码整理一下来和大家分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.jianshu.com/p/27b256f1afa8&quot;&gt;树莓派小车系列之二&lt;/a&gt;中，讲到了树莓派的引脚定义方式有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PHYSICAL NUMBERING&lt;/li&gt;
&lt;li&gt;GPIO NUMBERING&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我采用的是第二种方式。&lt;/p&gt;
&lt;h4 id=&quot;开始写&quot;&gt;开始写&lt;/h4&gt;
&lt;h5 id=&quot;导入库&quot;&gt;1. 导入库&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;import RPi.GPIO as GPIO
import time&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;定义接口方式以及接口位置&quot;&gt;2. 定义接口方式以及接口位置&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;GPIO.setmode(GPIO.BCM)
IN1 = 17
IN2 = 18
IN3 = 27
IN4 = 22
IN5 = 23
IN6 = 24 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IN1 - IN4为L298N接入，IN5和IN6为红外线模块接入。&lt;/p&gt;
&lt;h6 id=&quot;车轮驱动方式&quot;&gt;车轮驱动方式：&lt;/h6&gt;
&lt;p&gt;IN1和IN2负责驱动车轮转动（前进）。&lt;br/&gt;IN3和IN4负责驱动车轮转动（后退）。&lt;/p&gt;
&lt;h5 id=&quot;初始化&quot;&gt;3. 初始化&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;def init():
    GPIO.setup(IN1, GPIO.OUT)
    GPIO.setup(IN2, GPIO.OUT)
    GPIO.setup(IN3, GPIO.OUT)
    GPIO.setup(IN4, GPIO.OUT)
    GPIO.setup(IN5, GPIO.IN)
    GPIO.setup(IN6, GPIO.IN)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接L298N的接口设为输出，因为需要输出的信号来驱动电机。&lt;br/&gt;连接红外线模块的接口为输入，因为需要输入的信号来做出判断。&lt;/p&gt;
&lt;h5 id=&quot;基础方向行为&quot;&gt;4. 基础方向行为&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;def up():
    GPIO.output(IN1, GPIO.HIGH)          //右侧车轮前进
    GPIO.output(IN2, GPIO.HIGH)          //左侧车轮前进
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.LOW)


def down():
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.HIGH)          //右侧车轮后退
    GPIO.output(IN4, GPIO.HIGH)          //左侧车轮后退


def turn_left():
    GPIO.output(IN1, GPIO.HIGH)          //右侧车轮前进
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.LOW)


def turn_right():
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.HIGH)          //左侧车轮前进
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.LOW)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要说明的是：由于不含舵机，转弯的操作是单边车轮驱动，带动车身转动&lt;/p&gt;
&lt;h5 id=&quot;红外控制&quot;&gt;5. 红外控制&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;init()

n = 5

while (n &amp;gt; 0):                                  //总共转弯五次
    in_left = GPIO.input(IN5)                   //左侧红外线接收器
    in_right = GPIO.input(IN6)                  //右侧红外线接收器
    up()                                        //未遇到障碍时直行
    if (in_left == GPIO.LOW):
        down()
        time.sleep(1)
        turn_right()
        time.sleep(1)
        n = n - 1
        continue
    
    if (in_right == GPIO.LOW):
        down()
        time.sleep(1)
        turn_left()
        time.sleep(1)
        n = n - 1
        continue
    
    if (in_right == GPIO.LOW &amp;amp; in_left == GPIO.LOW):
        down()
        time.sleep(1)
        turn_right()               //如果两侧都有障碍，就右转（个人喜好）
        time.sleep(1)
        n = n - 1
        continue

stop()                      
GPIO.cleanup()                    //清空GPIO接口配置信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果前方遇到障碍，就后退一秒，然后转弯，最后继续直行，直到遇到下一个障碍。&lt;/p&gt;
&lt;p&gt;需要说明的是time.sleep()的用法：&lt;br/&gt;time.sleep(time) 表示的是经过 time 秒后执行下一步操作，就是休眠一段时间的意思。&lt;br/&gt;如果不使用time.sleep()，将会一直执行第一步操作。&lt;/p&gt;
&lt;h4 id=&quot;关于运行&quot;&gt;关于运行：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;由于红外传感器的有效距离偏短(5cm左右)，以及传感器的安装位置在车的底部，所以在车辆运动时，如果遇到凹凸不平的物体，有可能造成避障的延迟。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;运行视频&quot;&gt;运行视频&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XMzE2NzkzNjAwMA==.html?spm=a2h3j.8428770.3416059.1&quot;&gt;树莓派小车&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;遇到凹凸不平的物体有些许碰撞（环境简陋）&lt;/p&gt;
&lt;p&gt;关于树莓派信息的内容就先告一段落，等我做出遥控器再来介绍，谢谢大家的关注。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Feb 2018 05:04:00 +0000</pubDate>
<dc:creator>李汉祥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lihanxiang/p/8451818.html</dc:identifier>
</item>
<item>
<title>新年干货分享--10分钟学会概率数据结构 - 卿哥聊技术</title>
<link>http://www.cnblogs.com/huashao1985/p/8450115.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huashao1985/p/8450115.html</guid>
<description>&lt;p&gt;平时总用hashmap，tree, set，vector，queue/stack/heap, linklist, graph，是不是觉得数据结构就那点东西。新年到，卿哥给大家分享点段位比较高的大数据专用数据结构--概率数据结构，让你不管是参与系统设计也好，平时和老板同事聊天也好，找工作面试也好都能让人眼前一亮，即probabilistic data structure, 也有人称之为 approximation algorithm 近似算法或者 online algorithm在线算法。今天教大家概率数据结构的5种招式俗称打狗5式，分别是用于基数统计的HyperLogLog, 元素存在检测的Bloom filter, 相似度检测的MinHash, 频率统计的count-min sketch 和 流统计的tdigest，把这打狗5式吃透就足够你闯荡江湖华山论剑啦。&lt;/p&gt;
&lt;h2&gt;Set cardinality -- HyperLogLog&lt;/h2&gt;
&lt;p&gt;即基数统计，这是很常用的功能，比如我这个网站这段时间到底被多少独立IP访问过啊？诸如此类需要counting unique的问题。那么正常的思路是什么？建一个hashset往里装，最后返回hashset的结果。可是如果数据量很大，hashset内存就不够了怎么半呢？那就用多台机器memcached或者redis，内存不够了再往硬盘里装，总之就是硬吃。&lt;/p&gt;
&lt;p&gt;这个时候其实可以换个思路，牺牲一点准确度来换取内存的节省。这就是HyperLogLog啦！下面的例子用1%的error bound来达到近似结果的目的，效率超级高，内存使用率超级低。下面用https://github.com/svpcom/hyperloglog提供的实现：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

jabber_text &lt;/span&gt;= &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
`Twas brillig, and the slithy toves 
      Did gyre and gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome raths outgrabe. 

&quot;Beware the Jabberwock, my son! 
      The jaws that bite, the claws that catch! 
Beware the Jubjub bird, and shun 
      The frumious Bandersnatch!&quot; 

He took his vorpal sword in hand; 
      Long time the manxome foe he sought- 
So rested he by the Tumtum tree 
      And stood awhile in thought. 

And, as in uffish thought he stood, 
      The Jabberwock, with eyes of flame, 
Came whiffling through the tulgey wood, 
      And burbled as it came! 

One, two! One, two! And through and through 
      The vorpal blade went snicker-snack! 
He left it dead, and with its head 
      He went galumphing back. 

&quot;And hast thou slain the Jabberwock? 
      Come to my arms, my beamish boy! 
O frabjous day! Callooh! Callay!&quot; 
      He chortled in his joy. 

`Twas brillig, and the slithy toves 
      Did gyre and gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome raths outgrabe.
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

packer_text &lt;/span&gt;= &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
My answers are inadequate
To those demanding day and date
And ever set a tiny shock
Through strangers asking what's o'clock;
Whose days are spent in whittling rhyme-
What's time to her, or she to Time? 
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; clean_words(text):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; filter(&lt;span&gt;lambda&lt;/span&gt; x: len(x) &amp;gt;0, re.sub(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[^A-Za-z]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;, text).split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

jabber_words &lt;/span&gt;=&lt;span&gt; clean_words(jabber_text.lower())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print jabber_words&lt;/span&gt;
&lt;span&gt;
packer_words &lt;/span&gt;=&lt;span&gt; clean_words(packer_text.lower())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print packer_words&lt;/span&gt;
&lt;span&gt;
jabber_uniq &lt;/span&gt;=&lt;span&gt; sorted(set(jabber_words))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print jabber_uniq&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hyperloglog

hll &lt;/span&gt;= hyperloglog.HyperLogLog(0.01&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; jabber_words:
    hll.add(word)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prob count %d, true count %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (len(hll),len(jabber_uniq))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;observed error rate %0.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (abs(len(hll) - len(jabber_uniq))/float(len(jabber_uniq)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
prob count 90, true count 91
observed error rate 0.01
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Set membership -- Bloom Filter&lt;/h2&gt;
&lt;p&gt;Bloom Filter是这几种数据结构里你最应该掌握的，如果是读过我“聊聊canssandra”的读者一定耳熟能详。在cassandra的读操作里，如果memtable里没有那么就看bloomfilter，如果bloomfilter说没有就结束了，真没有，如果说有继续查key cache，etc。说没有就没有这个属性太牛逼了。下半句是说有也不一定有但是误差率可以控制为0.001，下面用https://github.com/jaybaird/python-bloomfilter给大家举个例子(上面重复的code我就不写了)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pybloom &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BloomFilter

bf &lt;/span&gt;= BloomFilter(capacity=1000, error_rate=0.001&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; packer_words:
    bf.add(word)

intersect &lt;/span&gt;=&lt;span&gt; set([])

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; jabber_words:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; bf:
        intersect.add(word)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; intersect
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
set(['and', 'in', 'o', 'to', 'through', 'time', 'my', 'day'])
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Set Similarity -- MinHash&lt;/h2&gt;
&lt;p&gt;就是说两篇文章我来看看它们到底有多相似，听起来可以预防论文抄袭啥的，下面我们通过https://github.com/ekzhu/datasketch的实现来看一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; datasketch &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MinHash

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mh_digest(data):
    m &lt;/span&gt;= MinHash(num_perm=512) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;number of permutation&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data:
        m.update(d.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; m

m1 &lt;/span&gt;=&lt;span&gt; mh_digest(set(jabber_words))
m2 &lt;/span&gt;=&lt;span&gt; mh_digest(set(packer_words))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jaccard simularity %f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % m1.jaccard(m2), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;estimated&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

s1 &lt;/span&gt;=&lt;span&gt; set(jabber_words)
s2 &lt;/span&gt;=&lt;span&gt; set(packer_words)
actual_jaccard &lt;/span&gt;= float(len(s1.intersection(s2)))/&lt;span&gt;float(len(s1.union(s2)))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jaccard simularity %f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % actual_jaccard, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;actual&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Jaccard simularity 0.060547 estimated
Jaccard simularity 0.069565 actual
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Frequency Summaries -- count-min sketch&lt;/h2&gt;
&lt;p&gt;频率统计算法一般用在排行榜中，既当前的🏆是谁，🥈是谁，🥉是谁，我们比较关注和比较发生次数非常多的事件，我们不太关心谁排第n和谁排第n+1，具体说你打枪打了1000环还是1001环这种误差也不重要。还有一个应用实例是写作语言检测，把出现频率最多的一些词取出就能知道你这篇文章是用哪种语言写的。下面通过https://github.com/IsaacHaze/countminsketch来具体看一看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Counter
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; yacms &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CountMinSketch

counts &lt;/span&gt;=&lt;span&gt; Counter()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200 is hash width in bits, 3 is number of hash functions&lt;/span&gt;
cms = CountMinSketch(200, 3&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; jabber_words:
    counts[word] &lt;/span&gt;+= 1&lt;span&gt;
    cms.update(word, &lt;/span&gt;1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;he&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;that&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;word %s counts %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (word, cms.estimate(word))

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; counts:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; counts[e] !=&lt;span&gt; cms.estimate(e):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;missed %s counter: %d, sketch: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (e, counts[e], cms.estimate(e))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
word the counts 19
word he counts 7
word and counts 14
word that counts 2
missed two counter: 2, sketch: 3
missed chortled counter: 1, sketch: 2
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Streaming Quantiles -- tdigest&lt;/h2&gt;
&lt;p&gt;流统计，这个厉害了，假设你有一个超大流数据源源不断，比如是交易数据，现在让你来检测哪些可能是属于信用卡盗刷，那么拿到平均交易价格，最大交易价格就很重要。实时获取这个统计也增大了计算和处理难度，那么t-digest就要闪亮登场了，下面我们看看怎么实时拿到5%头数据，5%尾数据和中间值。下面通过https://github.com/trademob/t-digest来看一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; tdigest &lt;span&gt;import&lt;/span&gt;&lt;span&gt; TDigest
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

td &lt;/span&gt;=&lt;span&gt; TDigest()

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; xrange(0, 1000&lt;span&gt;):
    td.add(random.random(), &lt;/span&gt;1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; q &lt;span&gt;in&lt;/span&gt; [0.05, 0.5, 0.95&lt;span&gt;]:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%f @ %f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (q, td.quantile(q))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
0.050000 @ 0.052331
0.500000 @ 0.491775
0.950000 @ 0.955989
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，今天关于概率数据结构的讲解就到此为止，大家有兴趣可以看看相关代码的具体实现，代码行数都很少，背后蕴藏的数学技巧却很值得品味。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Feb 2018 03:29:00 +0000</pubDate>
<dc:creator>卿哥聊技术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huashao1985/p/8450115.html</dc:identifier>
</item>
<item>
<title>使用VS Code开发asp.net core (下) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8450409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8450409.html</guid>
<description>&lt;p&gt;第一部分: &lt;a href=&quot;https://www.cnblogs.com/cgzl/p/8450179.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cgzl/p/8450179.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是基于Windows10的.&lt;/p&gt;
&lt;h2&gt;Debugging javascript&lt;/h2&gt;
&lt;p&gt;打开wwwroot/js/site.js, 写一段简单的js代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($) {
    $(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $(&lt;/span&gt;'#myButton').on('click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            alert(&lt;/span&gt;'Hello world!'&lt;span&gt;);
        });
    });
})(jQuery);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216193456827-368357743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以设置断点, 但是由于整个项目是用于服务器端的. 而js文件是用于客户端开发的, 我们需要一种方法来调试js文件.&lt;/p&gt;
&lt;p&gt;这里我们就需要安装一个扩展: Chrome Debugger.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216193728968-1753704114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打开launch.json, 可以直接打开文件, 也可以如下图方式打开:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216193834609-1448054966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击右下角的Add Configuration:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216194008624-1259862840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改配置的端口和目录:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&quot;configurations&quot;&lt;span&gt;: [
        {
            &lt;/span&gt;&quot;type&quot;: &quot;chrome&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;request&quot;: &quot;launch&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;name&quot;: &quot;Launch Chrome&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;url&quot;: &quot;http://localhost:&lt;span&gt;5000&lt;/span&gt;&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;webRoot&quot;: &quot;${workspaceFolder}&lt;span&gt;/wwwroot&lt;/span&gt;&quot;&lt;span&gt;
        },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在About.cshtml里面添加一个button:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myButton&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;My Button&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Debugger中运行Launch Chome:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195156406-286329980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行后, 弹出浏览器, 但是页面无法显示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195412156-1918072500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为Chrome Debugger仅仅运行客户端的代码. 而服务器段的代码买有运行.&lt;/p&gt;
&lt;p&gt;所以还需要在另外的命令行执行dotnet run命令.&lt;/p&gt;
&lt;p&gt;然后再次运行Chrome Launch. 这次运行成功了&lt;/p&gt;
&lt;p&gt;点击About页面的My Button, 断点并没有响应. 切换到代码页面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195815718-1641836304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到断点被灰掉了, 这是因为debugger并未找到这段代码.&lt;/p&gt;
&lt;p&gt;这是因为dotnet run运行的是Production环境:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195920374-1357235543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而看下代码_Layout.cshtml:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216200024234-629318560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序只有在Development环境下才会包含site.js.&lt;/p&gt;
&lt;p&gt;这时可以打开bundleconfig.json, 把sourceMap属性设置成true. 并且安装这个包: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet add package BuildBundlerMinifier
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行dotnet clean 和 dotnet build&lt;/p&gt;
&lt;p&gt;这是一种办法, 但是我更想直接调试site.js, 所以可以在命令行设置一下临时的环境变量:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
set ASPNETCORE_ENVIRONMENT=Development
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行dotnet run.&lt;/p&gt;
&lt;p&gt;这时刷新后再点击按钮, 就可以触发断点了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216200811093-1150378998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外还可以使用浏览器自带的debugger.&lt;/p&gt;
&lt;h2&gt;Debug Typescript&lt;/h2&gt;
&lt;p&gt;在wwwroot/js里面添加test.ts:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Test {
    constructor(private msg: string) {

    }
    show() {
        alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要为项目配置一下Typescript:&lt;/p&gt;
&lt;p&gt;建立一个tsconfig.json文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
    &quot;compileOnSave&quot;: true,
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;es5&quot;,
        &quot;sourceMap&quot;: true,
        &quot;module&quot;: &quot;commonjs&quot;
    },
    &quot;include&quot;: [
        &quot;wwwroot/js/*.ts&quot;
    ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时候, ts文件还不能编译, 因为typescript还没有被安装. 也就是说tsc命令还不能用.&lt;/p&gt;
&lt;p&gt;所以需要安装typescript:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install typescript -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时在项目目录执行tsc命令就可以生成js文件了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216203034218-503828171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是, 如果更改了test.ts文件, 保存后. 并没有生成新的js文件. 这是因为在保存的时候vscode不知道应该做什么.&lt;/p&gt;
&lt;p&gt;可以在项目build之前进行tsc这个命令, 所以修改csproj文件, 添加如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Target &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;PrecompileScript&quot;&lt;/span&gt;&lt;span&gt; BeforeTargets&lt;/span&gt;&lt;span&gt;=&quot;BeforeBuild&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Exec &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;tsc&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行dotnet build, 就可以看到生成了新的test.js文件.&lt;/p&gt;

&lt;p&gt;针对sqlite, 没有太好的办法, 到&lt;a href=&quot;http://sqlite.org/download.html&quot; target=&quot;_blank&quot;&gt;官方网站&lt;/a&gt;下载工具, 使用命令行sqlite3.&lt;/p&gt;
&lt;p&gt;针对sqlserver, 需要安装一个mssql扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205254734-1805030111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我本机有一个localdb实例的数据库.&lt;/p&gt;
&lt;p&gt;在项目建立一个test.sql文件, 打开文件后会自动安装sql tools service:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205447140-741866174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择连接字符串, MSSQL Connect:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205621593-719995259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为现在还没有建立任何连接字符串, 所以这时它会让你建立一个:&lt;/p&gt;
&lt;p&gt;首先输入Server Name:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205835687-1877059535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后输入数据库名:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205926609-423429386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择登陆方式, 我选择integrated:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216210016124-379047259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后输入这个档案的名字: SalesDB&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216210132077-1103503235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确定后, VSCode就会开始尝试连接该数据库, 成功后会有提示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216210905749-466402249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vscode右下角状态栏也会有显示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211009640-511833025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时再写sql语句就会有智能提示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211118124-283708197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后执行这个sql语句: 可以先看看有哪些命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211226359-1864401161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+Shift+E是执行sql语句的命令. 执行后的结果如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211321218-1459183885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面所配置的Sql连接字符串实际上是保存在了UserSettings里面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211541343-1834815707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于mysql和postgresql等, 需要安装vscode-database这个扩展. 这里就先不介绍了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建新文件: Advanced New File 扩展 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搜索并安装advanced new file扩展, 这两个哪个都行. 我安装的是带横线的那个:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217064552249-73463435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过Command Palette可以看到创建新文件的快捷键是Ctrl+Alt+N.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217064810859-1837207768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择相对的路径:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217064923718-23430551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择后输入文件名即可, 这时可以带着目录结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217065136906-887487233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果目录结构中的目录不存在, 那么它也会自动被创建. 点击Enter就会创建新文件个所需的目录.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESLint扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先安装ESLint:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217065554843-311830478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你没有安装eslint库的话还需要通过npm来进行全局安装:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install -g eslint
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要添加一个eslint的配置文件, 选择Create .eslintrc.json文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217065738968-1632724647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成的文件如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070147656-481765981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时就可以看到eslint扩展起作用了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070101077-907243182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体ESLint的内容, 请查看官方文档.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TSLint扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装tslint扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070346593-42591807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过npm安装tslint:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install -g tslint
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后看一下tslint有哪些命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070520765-892671292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择创建tslint.json文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070610124-289826690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找一个ts文件试一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070641624-428784628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tslint也起作用了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bower扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装Bower扩展&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070801421-1178060497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好后, 在Command Palette中输入并选择Bower命令会出下如下选项:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070959046-1311346493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你使用bower, 那么这里的命令你应该比较熟悉.&lt;/p&gt;
&lt;p&gt;这里比较有用的一个命令是Bower Search and Install. 选择后, 搜索一个包例如 underscore:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217071209062-1634829686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Install as Dependency:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217071246593-1829667972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装后, 该包会出现在bower.json文件中.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XML格式化扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vscode在不安装扩展的情况下xml文件是无法被自动格式化的.&lt;/p&gt;
&lt;p&gt;可以安装扩展Xml Tools:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217072409171-1429528481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装后, 查看它都有哪些命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217072547171-501675231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时, 如果想格式化xml文件, 直接使用vscode默认的格式化文件命令(Shift+Alt+F)即可, 它会按照项目的配置进行格式化.&lt;/p&gt;
&lt;p&gt;其他类型的文件如果需要格式化, 可以在扩展市场搜索安装, 自行研究一下即可.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rest Client扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装Rest Client扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073439109-1754178008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后创建一个文件, 例如叫 httptest, 之后选择该文件的language mode:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073555937-1393801892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Http:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073625796-204070443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在文件中写一个http的地址:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073700874-1788415790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写完http地址后, 在地址的上方会出现一个链接: Send Request, 点击这个链接, 就会发送请求, 请求响应后, 在右侧可以看到返回的结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073756484-1544823136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里还可以添加请求的各种参数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217074031093-480907570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求的结果可以保存到文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217074346796-1257451852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样这里可以发送 POST, PUT, DELETE等请求.&lt;/p&gt;

&lt;p&gt;VSCode的扩展太多了, 可以选择Poppular Extensions或者Recommend Extensions去安装并研究一下.&lt;/p&gt;
&lt;p&gt;这个文章就写这些了, 谢谢&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 23:45:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8450409.html</dc:identifier>
</item>
<item>
<title>树莓派小车（二）树莓派、小车和红外线模块连接（多图） - 李汉祥</title>
<link>http://www.cnblogs.com/lihanxiang/p/8451299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lihanxiang/p/8451299.html</guid>
<description>&lt;h3 id=&quot;正文之前&quot;&gt;正文之前&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上一篇文章介绍了小车底盘以及驱动板的安装，这一次来讲一讲树莓派与驱动板以及红外线模块的安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;h4 id=&quot;树莓派的gpio引脚定义&quot;&gt;1. 树莓派的GPIO引脚定义：&lt;/h4&gt;
&lt;p&gt;树莓派的GPIO引脚共分为两种类型，一种是PHYSICAL NUMBERING&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-97eb8f7e9277fedc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;PHYSICAL NUMBERING&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单纯地用从下至上，从左至右的顺序来定义引脚。&lt;/p&gt;
&lt;p&gt;在我们的小车中：&lt;/p&gt;
&lt;p&gt;黄色的GPIO接口连接L298N驱动板以及其他模块如红外线模块等等，&lt;/p&gt;
&lt;p&gt;黑色的Ground接口连接红外线模块上的GND接口，&lt;/p&gt;
&lt;p&gt;红色的5V供电接口连接L298N驱动板上的+5V接口。&lt;/p&gt;
&lt;p&gt;另外一种引脚定义方式是GPIO NUMBERING&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-80416d6b4bae1e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;GPIO NUMBERING&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用特殊（未知）的方式来标记GPIO接口&lt;/p&gt;
&lt;p&gt;黄色的GPIO接口连接L298N驱动板以及其他模块如红外线模块等等，&lt;/p&gt;
&lt;p&gt;黑色的Ground接口连接红外线模块上的GND接口，&lt;/p&gt;
&lt;p&gt;红色的5V供电接口连接L298N驱动板上的+5V接口。&lt;/p&gt;
&lt;p&gt;我采用的是&lt;strong&gt;第二种&lt;/strong&gt;，关于如何设置哪一种类型以及编写代码驱动小车，将会在树莓派小车系列之三中介绍。&lt;/p&gt;
&lt;h4 id=&quot;连接驱动板和树莓派&quot;&gt;2. 连接驱动板和树莓派：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-a63511fe483baf40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;连接红外线模块和树莓派&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-3af0a03c1589d4dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;四路探测红外线模块&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我购买的是四路探测红外线模块，先拿其中两个红外线接发器来做前方探测。&lt;/p&gt;
&lt;p&gt;在模块电路板中，每个与红外线探测器相连的接口共有三种口，分别是：VCC，GND，IN（1，2，3，4）&lt;/p&gt;
&lt;p&gt;在模块电路板与树莓派相连的接口中，也有三种口：VCC，GND，OUT（1，2，3，4）&lt;/p&gt;
&lt;p&gt;在电路板与红外探测器之间连接时，按照对应接口：&lt;/p&gt;
&lt;p&gt;VCC - VCC GND - GND IN - OUT&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-77bea3452c18b1f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;接口1和4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在电路板与树莓派之间连接时，按照对应接口：&lt;/p&gt;
&lt;p&gt;VCC - 3.3V GND - GND OUT - GPIO&lt;/p&gt;
&lt;p&gt;将OUT1和OUT4接在GPIO22 和 GPIO24（读者随意，只要是GPIO口就行）&lt;/p&gt;
&lt;h4 id=&quot;将红外线模块固定在车底部&quot;&gt;3.将红外线模块固定在车底部&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-db8e76a94f4e57b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;红外线模块&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;最后&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;在小车的第二层放上树莓派和充电宝，小车就全部组装完毕了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-a83a02ce183c9a26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;整辆小车&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于小车的组装就完成了，在下一篇文章中将会给出驱动小车的Python代码。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 15:39:00 +0000</pubDate>
<dc:creator>李汉祥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lihanxiang/p/8451299.html</dc:identifier>
</item>
<item>
<title>在ConcurrentModificationException异常上的联想 - 呼呼呼呼呼65</title>
<link>http://www.cnblogs.com/huhu1203/p/8445827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huhu1203/p/8445827.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.什么是ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家都听说过快速报错fast-fail吧，fast-fail的发生就是说明发生了ConcurrentModificationException异常。其实发生这种异常的事件有两种，一种是在Iterator在迭代过程中，出现删除或者增加Collection中的元素的时候。另一种是多线程情况下，一个线程在用Iterator迭代Collection元素时，另一个线程却在给这个Collection增加或者删除元素。大家也许看出来了，两种情况其实都是在Iterator迭代元素过程中增加或者删除元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.制造ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cme表示ConcurrentModificationException
 * 目的是制造ConcurrentModificationException
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cme &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    List list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        list.add(&lt;/span&gt;1&lt;span&gt;);
        list.add(&lt;/span&gt;2&lt;span&gt;);

        Iterator itr &lt;/span&gt;=&lt;span&gt; list.listIterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (itr.hasNext()) {
            System.out.println(itr.next());
            list.add(&lt;/span&gt;3&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Cme cm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cme();
        Thread thread_1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(cm);
        thread_1.start();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;Thread-0&quot;&lt;span&gt; java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:&lt;/span&gt;901&lt;span&gt;)
    at java.util.ArrayList$Itr.next(ArrayList.java:&lt;/span&gt;851&lt;span&gt;)
    at dp.Cme.run(Cme.java:&lt;/span&gt;17&lt;span&gt;)
    at java.lang.Thread.run(Thread.java:&lt;/span&gt;745)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;确实是发生错误了，点击错误信息，调到了下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;大概意思是Collection中的元素与开始遍历的时候传来的个数不相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那到底是什么调用了上面的方法？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
           checkForComodification();
           &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;= SubList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size)
                  &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
           Object[] elementData &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offset + i &amp;gt;=&lt;span&gt; elementData.length)
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
           cursor &lt;/span&gt;= i + 1&lt;span&gt;;
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) elementData[offset + (lastRet =&lt;span&gt; i)];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那我们在next（）方法后面，仿照CAS机制中的ABA问题，先添加元素然后删除元素，行不行呢？（这样做毫无意义）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案是不行的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
    checkForComodification();

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
           SubList.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
           cursor &lt;/span&gt;=&lt;span&gt; lastRet;
           lastRet &lt;/span&gt;= -1&lt;span&gt;;
           expectedModCount &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.modCount;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为remove中也调用了上面的那个方法。但是我们可以用一种方法，在遍历的过程中把需要删除的对象保存到一个集合中，等遍历结束后再调用removeAll()方法来删除，或者使用iterator.remove()方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.为什么我们需要ConcurrentHashMap和CopyOnWriteArrayList？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步的集合类（Hashtable和Vector），同步的封装类（使用Collections.synchronizedMap()方法和Collections.synchronizedList()方法返回的对象）可以创建出线程安全的Map和List。但是有些因素使得它们不适合高并发的系统。它们仅有单个锁，对整个集合加锁，以及为了防止ConcurrentModificationException异常经常要在迭代的时候要将集合锁定一段时间，这些特性对可扩展性来说都是障碍。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.为什么用CopyOnWriteArrayList代替ArrayList，就不会产生ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从字面意思上可以看出来复制出来一份来操作，然后写道原先的ArrayList中。这样说肯定不行，我们看看源码，验证字面意思对不对？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然在迭代的时候能add，我们先看看add的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
*1、获取互斥锁
*2、Copy当前元素数组创建新数组，数组内存空间增1
*3、添加元素
*4、请求容器数据数组内存地址变更为新数组地址
*5、释放互斥锁
*6、返回结果
*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lock;
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Object[] elements &lt;/span&gt;=&lt;span&gt; getArray();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; elements.length;
            Object[] newElements &lt;/span&gt;= Arrays.copyOf(elements, len + 1&lt;span&gt;);
            newElements[len] &lt;/span&gt;=&lt;span&gt; e;
            setArray(newElements);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那还有一个问题，在调用Iterator的next方法，结果会是什么样的呢？边add边迭代吗？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cme表示ConcurrentModificationException
 * 目的是消除ConcurrentModificationException
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cme2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    List list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CopyOnWriteArrayList();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        list.add(&lt;/span&gt;1&lt;span&gt;);
        list.add(&lt;/span&gt;2&lt;span&gt;);

        Iterator itr &lt;/span&gt;=&lt;span&gt; list.listIterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (itr.hasNext()) {
            System.out.println(itr.next());
            list.add(&lt;/span&gt;3&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Cme2 cm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cme2();
        Thread thread_1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(cm);
        thread_1.start();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看看原因：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; COWIterator&amp;lt;E&amp;gt;(getArray(), 0&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; COWIterator&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Snapshot of the array &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object[] snapshot;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Index of element to be returned by subsequent call to next.  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cursor;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; COWIterator(Object[] elements, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCursor) {
            cursor &lt;/span&gt;=&lt;span&gt; initialCursor;
            snapshot &lt;/span&gt;=&lt;span&gt; elements;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor &amp;lt;&lt;span&gt; snapshot.length;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor &amp;gt; 0&lt;span&gt;;
        }

        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; hasNext())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) snapshot[cursor++&lt;span&gt;];
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;并发场景下对容器的添加操作是通过在容器内部数据数组的副本来完成的。对容器的迭代使用的是容器原始数据数组因为迭代不会产生修改，因此多个线程可以同时对容器进行迭代，而不会对彼此干扰或影响修改容器的线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.为什么用ConcurrentHashMap代替hashMap，就不会产生ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cme表示ConcurrentModificationException
 * 目的是制造ConcurrentModificationException
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cme &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    Map list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        list.put(&lt;/span&gt;'1',1&lt;span&gt;);
        list.put(&lt;/span&gt;'2',2&lt;span&gt;);

        Iterator itr &lt;/span&gt;=&lt;span&gt; list.values().iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (itr.hasNext()) {
            System.out.println(itr.next());
            list.put(&lt;/span&gt;'3',3&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Cme cm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cme();
        Thread thread_1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(cm);
        thread_1.start();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;Thread-0&quot;&lt;span&gt; java.util.ConcurrentModificationException
    at java.util.HashMap$HashIterator.nextNode(HashMap.java:&lt;/span&gt;1437&lt;span&gt;)
    at java.util.HashMap$ValueIterator.next(HashMap.java:&lt;/span&gt;1466&lt;span&gt;)
    at dp.Cme.run(Cme.java:&lt;/span&gt;19&lt;span&gt;)
    at java.lang.Thread.run(Thread.java:&lt;/span&gt;745)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看看原因：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt; nextNode() {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt;[] t;
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((next = (current = e).next) == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (t = table) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; {} &lt;span&gt;while&lt;/span&gt; (index &amp;lt; t.length &amp;amp;&amp;amp; (next = t[index++]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还是期望值与传进来的元素数量不相等所导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;由于map是key-&lt;span&gt;value形式的，并且map是有自己的空间的，所以在put的时候，并不影响。
在迭代时是如何保证遍历出原来的map的value的，具体原因我会再深入，及时修改文章。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6.hashtable怎么就不能代替在多线程情况下的hashMap?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hashtable和ConcurrentHashMap都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。也就是说代替是可以代替，但是在解决线程安全的同时降低了性能，所以选用ConcurrentHashMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.为什么要在多线程下使用hashMap呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是废话。线程不安全你还偏要用，非得跟自己过不去吗？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/kobejayandy/article/details/16834311&quot;&gt;CocurrentHashMap和Hashtable的区别&lt;/a&gt;         &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/dove_knowledge/article/details/71023512&quot; target=&quot;_blank&quot;&gt;Iterator&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/ybygjy/article/details/38147779&quot; target=&quot;_blank&quot;&gt;JCIP_5_01_CopyOnWriteArrayList为什么不会产生ConcurrentModificationException&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;link_title&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/1e9cf0ac07f4&quot; target=&quot;_blank&quot;&gt;老生常谈，HashMap的死循环&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.jianshu.com/p/f3f6b12330c1&quot; target=&quot;_blank&quot;&gt;理解和解决Java并发修改异常ConcurrentModificationException&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原创不易，转载请注明地址&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 制造ConcurrentModificationException异常&quot; href=&quot;http://www.cnblogs.com/huhu1203/p/8445827.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/huhu1203/p/8445827.html&lt;/a&gt; ，如有问题，请指正！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 15:28:00 +0000</pubDate>
<dc:creator>呼呼呼呼呼65</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huhu1203/p/8445827.html</dc:identifier>
</item>
<item>
<title>数学对于人类意味着什么 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/8450327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/8450327.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/8450327.html 

　　作者：窗户

　　QQ：6679072

　　E-mail：6679072@qq.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个话题是个很常见的话题，也是一个很难说明的问题。每当闲着无事的时候，我都会去思考一下关于数学的问题。正值假期，我有很多的时间来思考。&lt;/p&gt;
&lt;p&gt;　　昨天大年三十，母校老师问了我一个微分方程y''+py'+qy=Ae&lt;sup&gt;r&lt;/sup&gt;&lt;sup&gt;x&lt;/sup&gt;的解法问题，当然在此之前也问过我类似的方程的解答问题，虽然我已经很久没有去想微分方程的解析解问题，但是依稀还记得微分方程的一些知识。于是用纸张比划了很多，一通推导，关于此类方程的解法，引申出了线性空间、基、解空间的问题乃至比这个更复杂的高阶问题的解答。自己觉得还算满意，庆幸还没有完全把此类问题还给老师。过程中回忆起了一般的n阶齐次常微分方程归约到一元n次方程，以及后面的常函数项是形如Ax&lt;sup&gt;n&lt;/sup&gt;e&lt;sup&gt;r&lt;/sup&gt;&lt;sup&gt;x&lt;/sup&gt;之和的形式的解法，这是拓展的形式。&lt;/p&gt;
&lt;p&gt;　　从古埃及尼罗河泛滥丈量土地开始，人类就已经在为了技术的需要探索数学。中国在古代的时候，为了建筑、丈量的需要，也诞生了很多技术，辅助着也产生了一些应用上的数学。这些产生的数学都是应用上的数学。然而古希腊却是古数学的一个奇葩，他们脱离了远古社会中生产力低下的现实，而开始在数学的石器时代就开始去探索数学的本质，其代表作《几何原本》是考虑数学应该是先建立公理，再通过演绎法来建立所有的命题，而不是只去考虑当时的实用性。我至今无法理解为什么古希腊数学家会有如此抽象的想法，虽然不得不说其数学思想还是有很多的缺陷，但毕竟是人类记录历史里第一次思考数学的本质。&lt;/p&gt;
&lt;p&gt;　　我们从小学就开始做数学应用题，这是很科学的，因为不可能一上来就教小学生什么叫公理，什么叫peano算术系统，因为这个太抽象。人类最开始研究数学就是这样从实际应用来出发的，以及后面很多时候数学的进步也是为了实际应用来建模。我们做数学应用题，做着做着，发现那种鸡兔同笼这样的问题开始就要用所谓的技巧了，这个很不方便，于是我们学习了方程，此类问题的解决手段一下子变的简单。那么从简单应用题到一元一次方程就是一个数学的进步。&lt;/p&gt;
&lt;p&gt;　　到了初中，我们的数学开始变的抽象起来，应用题越来越少，题目越来越多的是纯数学。这就是开始训练演绎的手段了。到了高中，所有的一切进一步升华。&lt;/p&gt;
&lt;p&gt;　　到了大学，接触到了数学分析，又是一种什么样的情景呢?数学分析在整个数学中有个非常重要的作用，大多数学生是学到数学分析的时候才第一次真正意义上明白了数学的严格性，因为数学分析第一步则是学习实数。虽然到了初中，所有的学生都已经明白了什么叫实数，可完全没有深入的去明白实数系统是如何建立的，也没有明白诸如3.1415926...这样的表示的意义，当然，我们现在明白，它其实是用一个级数的极限来表示一个数。实数系的学习可能是很多人对于数学永远痛苦的回忆之一，因为人生第一次明白了数学的严格性，严格性带来的痛苦是，可能一个定理的证明花费半天甚至一天时间。而封闭曲线的定义恐怕要让很多人绞尽脑汁。&lt;/p&gt;
&lt;p&gt;　　然而，真实的数学发展却未必是按我们学习的方向。实数系的建立是在微积分发展了之后才开始建立的，甚至当时已经有微分方程的研究了。而微积分建立之初是为了力学的研究，Newton和Leibniz希望通过一种通用的手段来解决力学问题。微积分建立的基础在最开始的百年是不牢固的，一些基础性的问题并没有考虑清楚，所以牛顿曾经被红衣大主教驳的哑口无言，而直到Cauthy完备了实数系基础理论，才让微积分站的住脚。&lt;/p&gt;
&lt;p&gt;　　一元五次方程的求解问题、三大尺规作图问题、多n边形的尺规作图问题，这些问题曾缠绕了数学家很多年，特别是三大尺规作图问题，数学家被困扰了一两千年。而Galois的抽象代数则成功的把这些问题最终规避为一个问题。&lt;/p&gt;
&lt;p&gt;　　二十世纪为数理逻辑的世纪，这个世纪里发展了很多与数理逻辑相关的学科，包括计算理论。曾经的三大数学危机带来了新的思维，带来了数学的发展，这最后一大数学危机正是给数理逻辑准备的，而数理逻辑，则是数学的本质所在了，在数理逻辑逻辑里看来，计算10*10=100，和解决P?=NP问题，还真未必有什么本质区别。&lt;/p&gt;
&lt;p&gt;　　然而我们还是要问一下，数学对于人类到底意味着什么？&lt;/p&gt;
&lt;p&gt;　　人类一代代生存、一代代思考，过程中遇到了问题，数学是为了解决问题的。我们总是不断的把实际情况抽象化，客观上使用数学建模，无论那叫不叫数学建模。人们期望有种通用的方法解决所遇到的一类问题，于是我们就有了算术，有了平面几何。数学的发展就是为了不断的总结，不断的抽象，以希望提炼出精华，从而得到更一般的工具。&lt;/p&gt;
&lt;p&gt;　　另一方面，发展数学本身的时候，我们会遇到一些数学难题，以及所建立出来的数学（比如曾经的微积分）存在着很多的底层问题，这都需要人们要去解决。数学难题往往推动着数学的发展，而数学底层的问题就更大，数学如果站不住脚，在此之上的工具是不可靠的。&lt;/p&gt;
&lt;p&gt;　　有些人曾经问我，解决哥德巴赫猜想有什么作用？这似乎是民科最感兴趣的数学问题，因为它简单易懂，不需要很高的数学修养就可以明白。于是有些人就认为这其实是一个解决了也没有多大意义的问题。然而我要说的是，解决任何一个数学问题可能都是有意义的，因为解决它的过程中，我们可能造出了新的数学工具，从而对于解决其他的问题有意义。比如四色问题和单群分类问题都是通过计算机解决的，因为实在太复杂，计算机相对方便干重复而枯燥的事情，这就给了我们一个新的启发。&lt;/p&gt;
&lt;p&gt;　　我觉得数学对于人类的意义，是在于人类可以用统一、可靠的手段解决一类问题，而每当遇到问题的时候，我们都可以使用数学建模，从而使用那同一类的解决手段，使之有理可循，让我们从完全的经验化中走出，而向理论化、工具化发展。远古社会，数学为我们提供基础算术，从而有了度量手段；工业社会来了，数学为我们提供了微积分等一系列工具；信息时代来了，数学为我们提供了计算理论、递归论、图论这样的工具，也为我们提供了算法这样的东西；AI时代来了，数学一样为我们所有的算法模型提供最基本的数学保障。P?=NP的问题，甚至可能改变未来的社会格局。总之，数学是个取之不尽的大仓库。从这个方面来看，我是反对奥数的，因为总觉得它是希望问题复杂化，在我看来意义并不大，仿佛是数学杂技。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 14:35:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/8450327.html</dc:identifier>
</item>
<item>
<title>使用VS Code开发asp.net core (上) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8450179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8450179.html</guid>
<description>&lt;p&gt;本文是基于Windows10的.&lt;/p&gt;
&lt;p&gt;下载地址: &lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;insider 版下载地址: &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot; target=&quot;_blank&quot;&gt;https://code.visualstudio.com/insiders/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两个版本可以同时安装在系统中.&lt;/p&gt;
&lt;p&gt;安装过程就不介绍了.&lt;/p&gt;

&lt;p&gt;1.可以点击图标打开vscode&lt;/p&gt;
&lt;p&gt;2.如果安装的时候勾选了注册到Path, 那么可以在命令行输入code来打开vscode.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216135404702-1031473833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Git集成&lt;/h2&gt;
&lt;p&gt;使用git随便clone一个项目下来, 然后用vscode打开项目, 随便打开某个文件, 添加几行代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216135812218-1732291166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9-11行是我新添加的, 左边&lt;span&gt;绿色&lt;/span&gt;的竖条(点击就会看到明细)就表示这几行是新添加的.&lt;/p&gt;
&lt;p&gt;然后修改一下h1的标题:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216135932765-433837279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改的地方左边会出现&lt;span&gt;蓝色&lt;/span&gt;的竖条(点击就会看到明细). 表示这行发生了变化.&lt;/p&gt;
&lt;p&gt;这次再删除两行代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140112109-526449999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边会出现一个&lt;span&gt;红色&lt;/span&gt;的箭头, 鼠标可以放在这个箭头上, 然后点击一下查看明细, 就可以看到删除的代码行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140203984-1001069912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击vscode左边的Source Control按钮:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140417234-183857668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按钮图标上的1表示有一个文件有变化. 文件上还有undo, stage按钮. 点击文件后可以看到文件变化前后的对比明细.&lt;/p&gt;
&lt;p&gt;左侧上方还有很多功能菜单就不一一介绍了.&lt;/p&gt;
&lt;h2&gt;配置VSCode&lt;/h2&gt;
&lt;p&gt;打开File-Preferences-&lt;strong&gt;Settings&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140908577-1931781330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141131687-996914008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边的是VSCode默认的设置, 如果想要修改某些设置, 就把他们复制到右侧窗口, 保存后会立即生效.&lt;/p&gt;
&lt;p&gt;在上图中, 我设置了终端命令行为采用外部的命令行程序, 并且使用git的bash作为命令行程序. 保存后会立即生效, 无需重启VSCode.&lt;/p&gt;
&lt;p&gt;注意右侧文件上方, 目前修改的是User Settings. 也就是当前登录用户的配置.&lt;/p&gt;
&lt;p&gt;如果只想针对某个项目(文件夹)进行设置的话, 那么可以点击Workspace Settings. 这时候, 该目录会自动生成一个文件: vscode/settings.json, 所有修改的设置都会保存在这个文件里面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141524734-839434953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了Settings, 还可以配置&lt;strong&gt;快捷键&lt;/strong&gt;, 点击Preferences-Keyboard Shortcuts (Ctrl+K, S):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141731499-811246851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开后点击文件上方的keybindings.json:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141950999-161695263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也会出现类似的配置画面.&lt;/p&gt;
&lt;p&gt;左边的菜单, 如果不需要的话也可以隐藏起来, 鼠标右键点击Hide即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142242202-284370893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示所有命令&lt;/strong&gt;: &lt;span&gt;Ctrl+Shift+P&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142457749-1121916549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搜索并打开文件: &lt;span&gt;Ctrl+P&lt;/span&gt;. 随着输入就会自动过滤文件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142754265-1121812605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装扩展&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;点击Extensions按钮图标, 进入扩展页面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142956109-1749329911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用各种排序方法展示扩展, 然后点击扩展, 安装然后点击reload重启vscode即可.&lt;/p&gt;
&lt;p&gt;这里我们必须要安装C#扩展.&lt;/p&gt;
&lt;p&gt;去掉过滤条件, 就可以看到安装好的扩展了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216143214140-56820590.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;


&lt;p&gt;安装asp.net core环境:&lt;/p&gt;
&lt;p&gt;打开网站 &lt;a href=&quot;https://www.microsoft.com/net&quot; target=&quot;_blank&quot;&gt;https://www.microsoft.com/net&lt;/a&gt;, 点击download.&lt;/p&gt;
&lt;p&gt;然后选择下载.net core.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216143500234-2138457368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载后安装即可. 如果你已经安装vs2017, 可能就不需要再安装这个了.&lt;/p&gt;
&lt;p&gt;打开命令行: 输入dotnet --version检查安装.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216143647515-1002329764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功, 版本为2.1.4&lt;/p&gt;
&lt;h2&gt;建立asp.net core 项目&lt;/h2&gt;
&lt;p&gt;用命令行找个地方, 建立目录, 然后执行一下dotnet new --help命令, 查看一下建项目的帮助:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216144000734-1907039252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我建立一个不带用户验证的mvc项目:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet new mvc --auth None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216144209702-1178934639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令行输入 code . 就会用vscode打开该目录:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216144358515-41550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些就是生成文件.&lt;/p&gt;
&lt;p&gt;打开后, vscode会自动安装C#依赖.&lt;/p&gt;
&lt;p&gt;如果VSCode上方有任何选择提示, 请选择Yes或者Restore.&lt;/p&gt;
&lt;p&gt;试一下项目是否正确:&lt;/p&gt;
&lt;p&gt;打开命令行: Ctrl+Shift+C或者在VSCode内打开命令行: Ctrl+Shift+`&lt;/p&gt;
&lt;p&gt;内置的默认命令行是Powershell, 我不是很喜欢它的速度, 所以可以通过之前讲的修改settings的方法把它改成Commmand Prompt.&lt;/p&gt;
&lt;p&gt;执行命令dotnet run:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216145550296-450066323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行成功, 打开浏览器, 可以看到项目的画面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216145619140-1682152655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码导航.&lt;/p&gt;
&lt;p&gt;使用F12来导航代码, 这个和vs是一样的.&lt;/p&gt;
&lt;p&gt;打开Program.cs 鼠标选中22行左右的StartUp这个单词, 然后按F12. 就会导航到Startup这个类.&lt;/p&gt;
&lt;p&gt;点击类或方法上面的Reference, 可以查看对其的引用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150011734-2138542336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用Alt+左右方向键, 来导航的前一个或者下一个动作画面.&lt;/p&gt;
&lt;p&gt;按住Shift+F12可以看到它的所有的引用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150243171-65147476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上点击鼠标右键, 都会有相应的菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150347077-313473643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一个重要的导航方法就是 使用Ctrl+P, 通过文件名来查找文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150459156-59260252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;添加文件&lt;/h2&gt;
&lt;p&gt;可以使用这个图标按钮来添加文件, 也可以使用菜单, 或者鼠标右键, 这个就不详细讲了.&lt;/p&gt;
&lt;p&gt;这里添加一个TestController.cs:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150850952-457795324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开该文件, 开始编写代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151002749-427452876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚刚输入了names, 然后出现了两个貌似一样的提示...其实他们是不一样的, 第一个表示的是C#关键字namespace. 第二个表示的是namespace代码片段.&lt;/p&gt;
&lt;p&gt;所以选中第二个, 再输入命名空间的名字, 就会出现这段代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151237499-1280515502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立TestController, 继承于Controller:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151447515-777154355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候Controller并没有被识别出来. 当然可以点击左边黄色的图标, 来选择引用.&lt;/p&gt;
&lt;p&gt;但是我们可以使用快捷键Ctrl+. 来进行Quick Fix快速修复, 选择引用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151709952-1035672654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151750374-1947677742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代码段 Snippets&lt;/h2&gt;
&lt;p&gt;打开User Snippets菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216152200906-1897613791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择C#:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216152243281-1537448306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后把里面注释的文字留下, 复制其中那段代码并修改称自己的代码段:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &quot;Create Controller&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;&lt;span&gt;con&lt;/span&gt;&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public class &lt;span&gt;$1&lt;/span&gt;Controller: Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t&lt;span&gt;$0&lt;/span&gt;&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a Controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个代码段的名字叫Create Controller, 输入con后将会调用该代码段, 代码段中$1的位置需要用户输入Controller的名字, 输入完成后按Tab光标将会留在$0的位置.&lt;/p&gt;
&lt;p&gt;您可以试一下, 肯定是好用的.&lt;/p&gt;
&lt;p&gt;但是这样输入的时候会稍显不友好, 因为没有提示, 那么可以将用户输入的部分改成这样:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &quot;Create Controller&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;con&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public class &lt;span&gt;${1: ControllerName}&lt;/span&gt;Controller: Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t$0&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216155303749-1956189405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就好多了.&lt;/p&gt;
&lt;p&gt;这个在代码段输入的变量也可以被引用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &quot;Create Controller&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;con&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public class ${1: ControllerName}Controller: Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t// 建立了&lt;span&gt;${1: ControllerName}&lt;/span&gt;Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t$0&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216155227812-448309395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再建立一个Action的代码段:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &quot;Create Action&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;act&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public IActionResult ${1: ActionName}()&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t// 建立了${1: ActionName} Action Method&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t$0&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\treturn View();&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装snippet扩展.&lt;/h2&gt;
&lt;p&gt;去vscode扩展画面可以搜索snippet关键字就可以看到各种snippet扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216155543718-1015743213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Html Zen coding&lt;/span&gt;: &lt;/h2&gt;
&lt;p&gt;zen coding是一种编写html和css的方法, 很快捷. &lt;/p&gt;
&lt;p&gt;打开Views/Home/About.cshtml, 然后在空白处输入div然后按Tab:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160623249-2000710133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后完整的div标签就出来了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160651234-36504889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zen coding允许你使用&lt;span&gt;css选择器&lt;/span&gt;进行更复杂的结构化写法, 例如输入 div&amp;gt;p&amp;gt;ul&amp;gt;li:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160813749-1456239410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后立即按Tab, 就会出现下列代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160848906-173137808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想&lt;span&gt;重复5个&lt;/span&gt;li, 那么输入 div&amp;gt;p&amp;gt;ul&amp;gt;li*5:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160950234-33930066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想加上class属性, div&amp;gt;p&amp;gt;ul.list-group&amp;gt;li.list-group-item*5:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216161103390-689137209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个建立bootstrap form的例子,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
form&amp;gt;(.form-group&amp;gt;label+input.form-control)*4+.form-group&amp;gt;input[type=submit].form-control
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就会生成下面的form:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216161259577-1583655035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中+表示下一个元素中括号可以写其他属性.&lt;/p&gt;
&lt;h2&gt;添加移除asp.net core项目引用.&lt;/h2&gt;
&lt;p&gt;可以通过编辑.csproj文件来添加或者移除项目引用.&lt;/p&gt;

&lt;p&gt;注意这里并没有智能提示, 最好是在Nuget网站搜索好相关包之后填写进来.&lt;/p&gt;
&lt;p&gt;编辑结束之后, vscode会提示进行restore, 这就相当于在命令行执行dotnet restore命令.&lt;/p&gt;
&lt;p&gt;此外, 也可以通过命令行来添加nuget包, 使用dotnet add package xxx命令来添加nuget包:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216162415781-1896227834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时, csproj文件里就会出现AutoMapper的PackageReference:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216162542921-488540064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Build项目&lt;/h2&gt;
&lt;p&gt;使用命令dotnet build来进行此操作.&lt;/p&gt;
&lt;p&gt;运行项目使用dotnet run.&lt;/p&gt;
&lt;p&gt;项目中.vscode目录下有个tasks.json文件, 打开它:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163135484-504060657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有一个task叫做build, 命令是dotnet, 参数是build和项目文件.&lt;/p&gt;
&lt;p&gt;如果执行VSCode命令&lt;span&gt;Ctrl+Shift+B&lt;/span&gt;, 选择build就会执行此命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163345327-1669095971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163404984-287363752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一个launch.json和它也差不多, 一会再说.&lt;/p&gt;
&lt;h2&gt;Debugging&lt;/h2&gt;
&lt;p&gt;看一下Debugging画面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163602406-1755888031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下来选单里面两个配置就来自launch.json.&lt;/p&gt;
&lt;p&gt;点击&lt;span&gt;绿色箭头&lt;/span&gt;就可以debugging (F5也行).  当然也可以start without debugging (Ctrl+F5), 这时浏览器会自动打开主页:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163837656-1323590590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开HomeController.cs设置一个断点:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216164206531-134036987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按F5开始并debug项目, 点击About菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216164325546-1998291894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到命中了断点, 打开Debug画面, 里面有丰富的信息. &lt;/p&gt;
&lt;p&gt;可以添加watch:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216164446640-759088141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样也可以在RazorView里面设置断点.&lt;/p&gt;
&lt;p&gt;通过这些可以看到vscode的debug体验很好, 不必任何一款IDE差多少. 所以vscode绝不是一个高级编辑器这么简单.&lt;/p&gt;
&lt;h2&gt;Build Watcher .&lt;/h2&gt;
&lt;p&gt;还有另外一种方式可以, 它允许对项目持续的Build.&lt;/p&gt;
&lt;p&gt;首先打开csproj文件, 添加一个watcher tool:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.0&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;AutoMapper&quot; Version=&quot;6.2.2&quot; /&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.All&quot; Version=&quot;2.0.5&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;DotNetCliToolReference Include=&quot;Microsoft.VisualStudio.Web.CodeGeneration.Tools&quot; Version=&quot;2.0.2&quot; /&amp;gt;
    &lt;span&gt;&amp;lt;DotNetCliToolReference Include=&quot;Microsoft.DotNet.Watcher.Tools&quot; Version=&quot;2.0.0&quot; /&amp;gt;&lt;/span&gt;
  &amp;lt;/ItemGroup&amp;gt;  

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它就是一个nuget包.&lt;/p&gt;
&lt;p&gt;然后执行 dotnet restore.&lt;/p&gt;
&lt;p&gt;它的用法就是在dotnet xxx命令之间加上watch, 例如 dotnet watch run.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165437765-1885743092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后我更改一下HomeController About方法里面的Message:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165729890-2050349913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到项目被停止, 重新Build, 然后又开始了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165649015-1381496541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;dotnet watch run配合Debugging.&lt;/h2&gt;
&lt;p&gt;看一下Debug里面的.net core Attach启动项:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165833468-647087019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击绿色箭头后出现如下选项:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165918765-1283366726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的dotnet watch run正在运行, 这时候我还想进行debug, 那么就可以选择dotnet exec这个选项, 它会执行dotnet watch run实时build出来的dll. 这两个动作是在不同的进程执行的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216170242281-2077617522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置断点试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216170334562-682583622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很好.&lt;/p&gt;
&lt;p&gt;如果不想debug了, 点击红色插头即可停止, 并且不影响dotnet watch run的运行.&lt;/p&gt;

&lt;p&gt;剩下有一半内容, 过一两天再写.&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 09:08:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8450179.html</dc:identifier>
</item>
</channel>
</rss>