<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[.NET Core] 简单读取 json 配置文件 - 反骨仔</title>
<link>http://www.cnblogs.com/liqingwen/p/8561284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqingwen/p/8561284.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;　　目前发现网上的 .NET Core 读取配置文件有点麻烦，自己想搞个简单点的。&lt;/p&gt;
&lt;p&gt;　　.NET Core 已经不使用之前的诸如 app.config 和 web.config 等 xml 形式的配置文件，一致采用 json 格式来存储配置文件信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201803/711762-20180313200201725-1004780718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;json 文件 demo&lt;/h2&gt;
&lt;p&gt;　　appsettings.json：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;name&quot;: &quot;wen&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;age&quot;: 26&lt;span&gt;,
  &lt;/span&gt;&quot;family&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;mother&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;name&quot;: &quot;娘&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;age&quot;: 55&lt;span&gt;
    },
    &lt;/span&gt;&quot;father&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;name&quot;: &quot;爹&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;age&quot;: 56&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Nuget 类库引用&lt;/h2&gt;
&lt;p&gt;　　需要 Nuget 两个类库：&lt;/p&gt;
&lt;p&gt;　　①Microsoft.Extensions.Configuration&lt;/p&gt;
&lt;p&gt;　　②Microsoft.Extensions.Configuration.Json&lt;/p&gt;

&lt;h2&gt;核心代码&lt;/h2&gt;
&lt;p&gt;　　Program.cs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 json 文件路径&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt; ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建配置根对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; configurationRoot =&lt;span&gt; builder.Build();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取配置根下的 name 部分&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; nameSection = configurationRoot.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取配置根下的 family 部分&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; familySection = configurationRoot.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;family&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取 family 部分下的 mother 部分下的 name 部分&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; motherNameSection = familySection.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mother&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取 family 部分下的 father 部分下的 age 部分&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; fatherAgeSection = familySection.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;father&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Value 为文本值&lt;/span&gt;
            Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name: {nameSection.Value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;motherName: {motherNameSection.Value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fatherAge: {fatherAgeSection.Value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.Read();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201803/711762-20180313201130357-1669273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　直观的关系对比图，可以看到核心就是 GetSection() 方法，每继续往下一个层次获取就再次调用 GetSection() 方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201803/711762-20180313205133287-1667442235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;备注&lt;/h2&gt;
&lt;p&gt; 　　别忘了设置 json 文件的属性哦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201803/711762-20180313201350155-1669601213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 23:31:00 +0000</pubDate>
<dc:creator>反骨仔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqingwen/p/8561284.html</dc:identifier>
</item>
<item>
<title>回滚 - 每天5分钟玩转 Docker 容器技术（141） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8553331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8553331.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每次更新应用时 Kubernetes 都会记录下当前的配置，保存为一个 revision（版次），这样就可以回滚到某个特定 revision。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;默认配置下，Kubernetes 只会保留最近的几个 revision，可以在 Deployment 配置文件中通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;revisionHistoryLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性增加 revision 数量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面实践回滚功能。应用有如下三个配置文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd.v1.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd.v2.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd.v3.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，分别对应不同的 httpd 镜像 &lt;/span&gt;&lt;code&gt;&lt;span&gt;2.4.16&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;2.4.17&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;2.4.18&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180313062109198-100414829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180313062124230-63553263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180313062149480-1835735517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 部署并更新应用：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180313062202594-1240816176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;--record&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的作用是将当前命令记录到 revision 记录中，这样我们就可以知道每个 revison 对应的是哪个配置文件。通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl rollout history deployment httpd&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看 revison 历史记录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180313062214573-1513361220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CHANGE-CAUSE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--record&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的结果。如果要回滚到某个版本，比如 revision 1，可以执行命令 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl rollout undo deployment httpd --to-revision=1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180313062227529-342922924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，revison 历史记录也会发生相应变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180313062239991-658896736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;revison 1 变成了 revison 4。不过我们可以通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CHANGE-CAUSE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 知道每个 revison 的具体含义。所以一定要在执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时加上 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--record&lt;/span&gt;&lt;/code&gt;&lt;span&gt;参数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;滚动更新我们就讨论到这里，下一节开始学习 k8s 的 Health Check 功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://item.jd.com/16936307278.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 22:11:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8553331.html</dc:identifier>
</item>
<item>
<title>前端综合学习笔记---异步、ES6/7、Module、Promise同步 vs 异步 - 叶落偏执</title>
<link>http://www.cnblogs.com/yuanziwen/p/8533590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanziwen/p/8533590.html</guid>
<description>&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-17&quot;&gt;同步 vs 异步&lt;/h3&gt;
&lt;p&gt;先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印&lt;span&gt;&lt;code&gt;100&lt;/code&gt;&lt;/span&gt;，1秒钟之后打印&lt;span&gt;&lt;code&gt;200&lt;/code&gt;&lt;/span&gt;，最后打印&lt;span&gt;&lt;code&gt;300&lt;/code&gt;&lt;/span&gt;。但是实际运行根本不是那么回事&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(100&lt;span&gt;)
setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;200&lt;span&gt;)
}, &lt;/span&gt;1000&lt;span&gt;)
console.log(&lt;/span&gt;300)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再对比以下程序。先打印&lt;code&gt;100&lt;/code&gt;，再弹出&lt;code&gt;200&lt;/code&gt;（等待用户确认），最后打印&lt;code&gt;300&lt;/code&gt;。这个运行效果就符合预期要求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(100&lt;span&gt;)
alert(&lt;/span&gt;200)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1秒钟之后点击确认&lt;/span&gt;
console.log(300)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 异步（后面这个叫做 同步 ），即不会阻塞后面程序的运行。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-18&quot;&gt;异步和单线程&lt;/h3&gt;
&lt;p&gt;JS 需要异步的根本原因是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。&lt;/p&gt;
&lt;p&gt;一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。&lt;/p&gt;
&lt;p&gt;讲到单线程，我们再来看个真题：&lt;/p&gt;
&lt;p&gt;第一问：下面代码的执行过程和结果&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    a &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}, &lt;/span&gt;100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(a){
    console.log(&lt;/span&gt;'while执行了'&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个很有迷惑性的题目，不少候选人认为&lt;span&gt;&lt;code&gt;100ms&lt;/code&gt;&lt;/span&gt;之后，由于&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;变成了&lt;span&gt;&lt;code&gt;false&lt;/code&gt;&lt;/span&gt;，所以&lt;span&gt;&lt;code&gt;while&lt;/code&gt;&lt;/span&gt;就中止了，实际不是这样，因为&lt;span&gt;JS&lt;/span&gt;是单线程的，所以进入&lt;code&gt;while&lt;/code&gt;循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-19&quot;&gt;前端异步的场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;定时 &lt;span&gt;&lt;code&gt;setTimeout &lt;/code&gt;&lt;code&gt;setInverval&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;网络请求，如 &lt;span&gt;&lt;code&gt;Ajax&lt;/code&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/span&gt;加载&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ajax 代码示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
console.log('start'&lt;span&gt;)
$.get(&lt;/span&gt;'./data1.json', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data1) {
    console.log(data1)
})
console.log(&lt;/span&gt;'end')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;img 代码示例（常用于打点统计）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log('start'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; img = document.createElement('img'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者 img = new Image()&lt;/span&gt;
img.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;'loaded'&lt;span&gt;)
    img.onload &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
}
img.src &lt;/span&gt;= '/xxx.png'&lt;span&gt;
console.log(&lt;/span&gt;'end'&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-20&quot;&gt;ES6/7 新标准的考查&lt;/h2&gt;
&lt;p&gt;第二问：ES6 箭头函数中的&lt;code&gt;this&lt;/code&gt;和普通函数中的有什么不同&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-21&quot;&gt;箭头函数&lt;/h3&gt;
&lt;p&gt;箭头函数是 ES6 中新的函数定义形式，&lt;code&gt;function name(arg1, arg2) {...}&lt;/code&gt;可以使用&lt;code&gt;(arg1, arg2) =&amp;gt; {...}&lt;/code&gt;来定义。示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JS 普通函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; arr = [1, 2, 3&lt;span&gt;]
arr.map(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
    console.log(index)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ES6 箭头函数&lt;/span&gt;
const arr = [1, 2, 3&lt;span&gt;]
arr.map((item, index) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(index)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中&lt;code&gt;this&lt;/code&gt;是全局变量的问题，看如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    console.log(&lt;/span&gt;'real', &lt;span&gt;this&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {a: 100} ，该作用域下的 this 的真实的值&lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [1, 2, 3&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 普通 JS&lt;/span&gt;
    arr.map(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
        console.log(&lt;/span&gt;'js', &lt;span&gt;this&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window 。普通函数，这里打印出来的是全局变量，令人费解&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
    })
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 箭头函数&lt;/span&gt;
    arr.map(item =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'es6', &lt;span&gt;this&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {a: 100} 。箭头函数，这里打印的就是父作用域的 this&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
    })
}
fn.call({a: &lt;/span&gt;100})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三问：ES6 模块化如何使用？&lt;/p&gt;
&lt;p&gt;ES6 中模块化语法更加简洁，直接看示例。&lt;/p&gt;
&lt;p&gt;如果只是输出一个唯一的对象，使用&lt;span&gt;&lt;code&gt;export default&lt;/code&gt;&lt;/span&gt;即可，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 util1.js 文件，内容如&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    a: &lt;/span&gt;100&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 index.js 文件，内容如&lt;/span&gt;
import obj from './util1.js'&lt;span&gt;
console.log(obj)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想要输出许多个对象，就不能用&lt;span&gt;&lt;code&gt;default&lt;/code&gt;&lt;/span&gt;了，且&lt;span&gt;&lt;code&gt;import&lt;/code&gt;&lt;/span&gt;时候要加&lt;span&gt;&lt;code&gt;{...}&lt;/code&gt;&lt;/span&gt;，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 util2.js 文件，内容如&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn1() {
    alert(&lt;/span&gt;'fn1'&lt;span&gt;)
}
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2() {
    alert(&lt;/span&gt;'fn2'&lt;span&gt;)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 index.js 文件，内容如&lt;/span&gt;
import { fn1, fn2 } from './util2.js'&lt;span&gt;
fn1()
fn2()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四问：ES6 class 和普通构造函数的区别&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-23&quot;&gt;class&lt;/h3&gt;
&lt;p&gt;class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如：&lt;/p&gt;
&lt;p&gt;JS 构造函数的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MathHandle(x, y) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
}&lt;br/&gt;MathHandle.prototype.add &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.x + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m = &lt;span&gt;new&lt;/span&gt; MathHandle(1, 2&lt;span&gt;);
console.log(m.add())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 ES6 class 的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class MathHandle {
  constructor(x, y) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
  }

  add() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.x + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y;
  }
}
const m &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MathHandle(1, 2&lt;span&gt;);
console.log(m.add())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意以下几点，全都是关于 class 语法的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;class&lt;/span&gt; 是一种新的语法形式，是&lt;span&gt;class Name {...}&lt;/span&gt;这种形式，和函数的写法完全不一样&lt;/li&gt;
&lt;li&gt;两者对比，构造函数函数体的内容要放在 &lt;span&gt;class&lt;/span&gt; 中的&lt;span&gt;constructor&lt;/span&gt;函数中，&lt;span&gt;constructor&lt;/span&gt;即构造器，初始化实例时默认执行&lt;/li&gt;
&lt;li&gt;class 中函数的写法是&lt;span&gt;add() {...}&lt;/span&gt;这种形式，并没有&lt;span&gt;function&lt;/span&gt;关键字&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子&lt;/p&gt;
&lt;p&gt;JS 构造函数实现继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动物&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Animal() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;'animal eat'&lt;span&gt;)
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 狗&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Dog() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bark = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;'dog bark'&lt;span&gt;)
    }
}
Dog.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animal()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈士奇&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; hashiqi = &lt;span&gt;new&lt;/span&gt; Dog()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ES6 class 实现继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Animal {
    constructor(name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    }
    eat() {
        console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name} eat`)
    }
}

class Dog extends Animal {
    constructor(name) {
        super(name) //调用父对象的构造函数
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    }
    say() {
        console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name} say`)
    }
}
const dog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dog('哈士奇'&lt;span&gt;)
dog.say()
dog.eat()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意以下两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;span&gt;&lt;code&gt;extends&lt;/code&gt;&lt;/span&gt;即可实现继承，更加符合经典面向对象语言的写法，如 &lt;span&gt;Java&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;子类的&lt;span&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/span&gt;一定要执行&lt;span&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/span&gt;，以调用父类的&lt;span&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第五问：ES6 中新增的数据类型有哪些？&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-24&quot;&gt;Set 和 Map&lt;/h3&gt;
&lt;p&gt;Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Set&lt;/span&gt; 类似于数组，但数组可以允许元素重复，&lt;span&gt;Set&lt;/span&gt; 不允许元素重复&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Map&lt;/span&gt; 类似于对象，但普通对象的 &lt;span&gt;key&lt;/span&gt; 必须是字符串或者数字，而 &lt;span&gt;Map&lt;/span&gt; 的 &lt;span&gt;key&lt;/span&gt; 可以是任何数据类型&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Set&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 例1&lt;/span&gt;
const set = &lt;span&gt;new&lt;/span&gt; Set([1, 2, 3, 4, 4&lt;span&gt;]);
console.log(set) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set(4) {1, 2, 3, 4}&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 例2&lt;/span&gt;
const set = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
[&lt;/span&gt;2, 3, 5, 4, 5, 8, 8].forEach(item =&amp;gt;&lt;span&gt; set.add(item));
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 3 5 4 8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Set&lt;/span&gt; 实例的属性和方法有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;size&lt;/span&gt;：获取元素数量。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;add(value)&lt;/span&gt;：添加元素，返回 Set 实例本身。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;delete(value)&lt;/span&gt;：删除元素，返回一个布尔值，表示删除是否成功。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;has(value)&lt;/span&gt;：返回一个布尔值，表示该值是否是 Set 实例的元素。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;clear()&lt;/span&gt;：清除所有元素，没有返回值。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
s.add(&lt;/span&gt;1).add(2).add(2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加元素&lt;/span&gt;
&lt;span&gt;
s.size &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;
s.has(&lt;/span&gt;1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
s.has(2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
s.has(3) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;
s.&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;(2&lt;span&gt;);
s.has(&lt;/span&gt;2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;
s.clear();
console.log(s);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set(0) {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Set&lt;/span&gt; 实例的遍历，可使用如下方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;keys()&lt;/span&gt;：返回键名的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;values()&lt;/span&gt;：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以&lt;span&gt;keys()&lt;/span&gt;和&lt;span&gt;values()&lt;/span&gt;返回结果一致。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;entries()&lt;/span&gt;：返回键值对的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;forEach()&lt;/span&gt;：使用回调函数遍历每个成员。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
let set = &lt;span&gt;new&lt;/span&gt; Set(['aaa', 'bbb', 'ccc'&lt;span&gt;]);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set.keys()) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ccc&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set.values()) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ccc&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set.entries()) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;aaa&quot;, &quot;aaa&quot;]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; [&quot;bbb&quot;, &quot;bbb&quot;]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; [&quot;ccc&quot;, &quot;ccc&quot;]&lt;/span&gt;
&lt;span&gt;
set.forEach((value, key) &lt;/span&gt;=&amp;gt; console.log(key + ' : ' +&lt;span&gt; value))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa : aaa&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb : bbb&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ccc : ccc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Map&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Map&lt;/span&gt; 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 &lt;span&gt;key&lt;/span&gt; 的特性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
const obj &lt;/span&gt;= {p: 'Hello World'&lt;span&gt;};

map.set(obj, &lt;/span&gt;'OK'&lt;span&gt;)
map.get(obj) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;OK&quot;&lt;/span&gt;
&lt;span&gt;
map.has(obj) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
map.&lt;span&gt;delete&lt;/span&gt;(obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
map.has(obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要使用&lt;span&gt;new Map()&lt;/span&gt;初始化一个实例，下面代码中&lt;span&gt;set get has delete&lt;/span&gt;顾名即可思义（下文也会演示）。其中，&lt;span&gt;map.set(obj, 'OK')&lt;/span&gt;就是用对象作为的 &lt;span&gt;key&lt;/span&gt; （不光可以是对象，任何数据类型都可以），并且后面通过&lt;span&gt;map.get(obj)&lt;/span&gt;正确获取了。 &lt;span&gt;Map&lt;/span&gt; 实例的属性和方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;size&lt;/code&gt;&lt;/span&gt;：获取成员的数量&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;set&lt;/code&gt;&lt;/span&gt;：设置成员 key 和 value&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;get&lt;/code&gt;&lt;/span&gt;：获取成员属性值&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;has&lt;/code&gt;&lt;/span&gt;：判断成员是否存在&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/span&gt;：删除成员&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/span&gt;：清空所有&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(&lt;/span&gt;'aaa', 100&lt;span&gt;);
map.set(&lt;/span&gt;'bbb', 200&lt;span&gt;);

map.size &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;
map.get(&lt;/span&gt;'aaa') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;
&lt;span&gt;
map.has(&lt;/span&gt;'aaa') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;
map.&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;('aaa'&lt;span&gt;)
map.has(&lt;/span&gt;'aaa') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;
map.clear()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Map 实例的遍历方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;keys()&lt;/code&gt;&lt;/span&gt;：返回键名的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/span&gt;：返回键值的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;entries()&lt;/code&gt;&lt;/span&gt;：返回所有成员的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;forEach()&lt;/code&gt;&lt;/span&gt;：遍历 Map 的所有成员。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(&lt;/span&gt;'aaa', 100&lt;span&gt;);
map.set(&lt;/span&gt;'bbb', 200&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let key of map.keys()) {
  console.log(key);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;aaa&quot;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; &quot;bbb&quot;&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let value of map.values()) {
  console.log(value);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of map.entries()) {
  console.log(item[&lt;/span&gt;0], item[1&lt;span&gt;]);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa 100&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb 200&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [key, value] of map.entries()) {
  console.log(key, value);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa 100&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb 200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-25&quot;&gt;Promise&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/span&gt;是 &lt;span&gt;CommonJS&lt;/span&gt; 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 &lt;span&gt;Promise&lt;/span&gt; 对象，非 ES6 环境可以用类似 &lt;span&gt;Bluebird&lt;/span&gt;、&lt;span&gt;Q&lt;/span&gt; 这类库来支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt; 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。&lt;/p&gt;
&lt;p&gt;简单归纳下 &lt;span&gt;Promise&lt;/span&gt;：&lt;span&gt;三个状态&lt;/span&gt;、&lt;span&gt;两个过程&lt;/span&gt;、&lt;span&gt;一个方法&lt;/span&gt;，快速记忆方法：&lt;span&gt;3-2-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三个状态：&lt;span&gt;&lt;code&gt;pending&lt;/code&gt;&lt;/span&gt;、&lt;span&gt;&lt;code&gt;fulfilled&lt;/code&gt;&lt;/span&gt;、&lt;span&gt;&lt;code&gt;rejected&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;两个过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;pending→fulfilled（resolve）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;pending→rejected（reject）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个方法：&lt;span&gt;&lt;code&gt;then&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然还有其他概念，如&lt;span&gt;&lt;code&gt;catch&lt;/code&gt;&lt;/span&gt;、 &lt;code&gt;&lt;span&gt;Promise.all&lt;/span&gt;/&lt;span&gt;race&lt;/span&gt;&lt;/code&gt;，这里就不展开了。&lt;/p&gt;
&lt;p&gt;关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;ES6入门&lt;/a&gt;》。&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 15:02:00 +0000</pubDate>
<dc:creator>叶落偏执</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanziwen/p/8533590.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（六）WPF带标题的内容控件简单介绍 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8563417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8563417.html</guid>
<description>&lt;p&gt;      在WPF自学入门（二）WPF-XAML布局控件的文章中分别介绍StackPanel,WarpPanel,DockPanel,Grid,Canvas五种布局容器的使用，可以让我们大致了解容器可以使用在什么地方。今天我们就来简单了解一下WPF中的三个带标题的内容控件，分别是GroupBox,TabControl和Expander&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、GroupBox控件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       这个控件可以叫做分组控件，可以把已经用布局控件包装好的一系列的控件放到里面分为一个组，例如，我们可以放入RadioButton进去，那么就不用设置GroupName也能对单选按钮进行分组了。这个GroupBox是带有圆角的和一个标签和内容的控件，大概是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224340911-372327011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       创建一个GroupBox就是这么简单。好了，这就是GroupBox的使用。当然，Header可以使用更复杂的逻辑，这就要发挥了。控件使用注意事项：我刚开始使用WPF时在使用GroupBox做登录框的布局，发现放一个标签后无法再次放标签。后面想了想在GroupBox控件上放布局控件StackPanel，在放多个控件就没有问题了。所以请大家注意放多个控件时，需要放布局控件在放需要常规控件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、TabControl控件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       TabItem是代表TabControl中的一页，在一个TabControl中需要多少页就要靠自己添加。默认的页签是字符串,例如：页签一，看一下TabControl长什么样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224350582-1714185499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      页签可以是字符串，也可以是图片。接下来，我们可以将页签一的文字更改为图片。看看实际效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224400431-357834983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       只添加图片无法满足实际设计需要，WPF中的TabControl也可以弄成图文形式的组合。看看效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224408990-125255748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      这是默认模式的，选择栏是顶部，可以设置为侧边显示，可以通过设置TabStripPlacement属性有四种模式：Left,Right,Bottom,Top(默认)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224417672-686691170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、Expander控件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        Expander控件是可扩展的控件，它内容默认开始是隐藏好的，很像帮助界面那样，不会在界面给出全部的信息，全部隐藏好，如果你想知道哪个方面的东西，就扩展哪一个Expander，系统默认的样式个人觉得不是很好的，我们可以通过自定义模板来改进样式，首先，一起来看一下Expander控件的使用方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224425928-279573663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        我定义了4个Expender，展开内容使用了4种不同颜色标注。分别是不同方向的展开方式,注意展开方向的使用ExpandDirection控制着在，然后内容各自镶嵌的自己的东西，就是这么简单，最后，看一下程序结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224439346-1464128252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     到这里已经简单介绍了三个控件的基本使用，大家应该都知道了三个带标题的内容控件的使用，其实操作一遍后会感觉很简单。WPF是编写程序的核心回到了数据驱动程序的模式上面。下一篇我们进入数据驱动的学习，初识Binding。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 14:43:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8563417.html</dc:identifier>
</item>
<item>
<title>mongodb分布式集群搭建手记 - zale.tang</title>
<link>http://www.cnblogs.com/littleatp/p/8563273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/8563273.html</guid>
<description>&lt;h2 id=&quot;一架构简介&quot;&gt;一、架构简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;br/&gt;单机搭建mongodb分布式集群(副本集 + 分片集群)，演示mongodb分布式集群的安装部署、简单操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201803/242916-20180313222747434-1293437958.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;br/&gt;在同一个vm启动由两个分片组成的分布式集群，每个分片都是一个PSS(Primary-Secondary-Secondary)模式的数据副本集；&lt;br/&gt;Config副本集采用PSS(Primary-Secondary-Secondary)模式。&lt;/p&gt;
&lt;h2 id=&quot;二配置说明&quot;&gt;二、配置说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;端口通讯&lt;br/&gt;当前集群中存在shard、config、mongos共12个进程节点，端口矩阵编排如下：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;mongos&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;mongos&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;mongos&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;shard1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;shard1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;shard1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;shard2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;shard2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;shard2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;内部鉴权&lt;br/&gt;节点间鉴权采用keyfile方式实现鉴权，mongos与分片之间、副本集节点之间共享同一套keyfile文件。 &lt;a href=&quot;http://www.cnblogs.com/littleatp/p/8563273.html&quot;&gt;官方说明&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;账户设置&lt;br/&gt;管理员账户：&lt;a href=&quot;mailto:admin/Admin@01&quot;&gt;admin/Admin@01&lt;/a&gt;，具有集群及所有库的管理权限&lt;br/&gt;应用账号：&lt;a href=&quot;mailto:appuser/AppUser@01&quot;&gt;appuser/AppUser@01&lt;/a&gt;，具有appdb的owner权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;关于初始化权限&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;keyfile方式默认会开启鉴权，而针对初始化安装的场景，Mongodb提供了&lt;a href=&quot;https://docs.mongodb.com/manual/core/security-users/#localhost-exception&quot;&gt;localhost-exception机制&lt;/a&gt;，&lt;br/&gt;可以在首次安装时通过本机创建用户、角色，以及副本集初始操作。&lt;/p&gt;
&lt;h2 id=&quot;三准备工作&quot;&gt;三、准备工作&lt;/h2&gt;
&lt;h3 id=&quot;下载安装包&quot;&gt;1. 下载安装包&lt;/h3&gt;
&lt;p&gt;官方地址：&lt;a href=&quot;https://www.mongodb.com/download-center&quot; class=&quot;uri&quot;&gt;https://www.mongodb.com/download-center&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.3.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署目录&quot;&gt;2. 部署目录&lt;/h3&gt;
&lt;p&gt;解压压缩文件，将bin目录拷贝到目标路径&lt;strong&gt;/opt/local/mongo-cluster&lt;/strong&gt;，参考以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -xzvf mongodb-linux-x86_64-rhel70-3.6.3.tgz
mkdir -p  /opt/local/mongo-cluster
cp -r mongodb-linux-x86_64-rhel70-3.6.3/bin  /opt/local/mongo-cluster&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建配置文件&quot;&gt;3. 创建配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/local/mongo-cluster
mkdir conf &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A. &lt;strong&gt;mongod 配置文件 mongo_node.conf&lt;/strong&gt;&lt;br/&gt;mongo_node.conf 作为mongod实例共享的配置文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;storage:
    engine: wiredTiger
    directoryPerDB: true
    journal:
        enabled: true
systemLog:
    destination: file
    logAppend: true
operationProfiling:
  slowOpThresholdMs: 10000
replication:
    oplogSizeMB: 10240
processManagement:
    fork: true
net:
    http:
      enabled: false
security:
    authorization: &quot;enabled&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选项说明可&lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/index.html&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;strong&gt;mongos 配置文件 mongos.conf&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemLog:
    destination: file
    logAppend: true
processManagement:
    fork: true
net:
    http:
      enabled: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建keyfile文件&quot;&gt;4. 创建keyfile文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/local/mongo-cluster
mkdir keyfile
openssl rand -base64 756 &amp;gt; mongo.key
chmod 400 mongo.key
mv mongo.key keyfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mongo.key 采用随机算法生成，用作节点内部通讯的密钥文件&lt;/p&gt;
&lt;h3 id=&quot;创建节点目录&quot;&gt;5. 创建节点目录&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
mkdir -p $WORK_DIR/nodes/config/n1/data
mkdir -p $WORK_DIR/nodes/config/n2/data
mkdir -p $WORK_DIR/nodes/config/n3/data

mkdir -p $WORK_DIR/nodes/shard1/n1/data
mkdir -p $WORK_DIR/nodes/shard1/n2/data
mkdir -p $WORK_DIR/nodes/shard1/n3/data

mkdir -p $WORK_DIR/nodes/shard2/n1/data
mkdir -p $WORK_DIR/nodes/shard2/n2/data
mkdir -p $WORK_DIR/nodes/shard2/n3/data

mkdir -p $WORK_DIR/nodes/mongos/n1
mkdir -p $WORK_DIR/nodes/mongos/n2
mkdir -p $WORK_DIR/nodes/mongos/n3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以config 节点1 为例，nodes/config/n1/data是数据目录，而pid文件、日志文件都存放于n1目录&lt;br/&gt;以mongos 节点1 为例，nodes/mongos/n1 存放了pid文件和日志文件&lt;/p&gt;
&lt;h2 id=&quot;四搭建集群&quot;&gt;四、搭建集群&lt;/h2&gt;
&lt;h3 id=&quot;config副本集&quot;&gt;1. Config副本集&lt;/h3&gt;
&lt;p&gt;按以下脚本启动3个Config实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
KEYFILE=$WORK_DIR/keyfile/mongo.key
CONFFILE=$WORK_DIR/conf/mongo_node.conf
MONGOD=$WORK_DIR/bin/mongod

$MONGOD --port 26001 --configsvr --replSet configReplSet --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/config/n1/data --pidfilepath $WORK_DIR/nodes/config/n1/db.pid --logpath $WORK_DIR/nodes/config/n1/db.log --config $CONFFILE

$MONGOD --port 26002 --configsvr --replSet configReplSet --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/config/n2/data --pidfilepath $WORK_DIR/nodes/config/n2/db.pid --logpath $WORK_DIR/nodes/config/n2/db.log --config $CONFFILE

$MONGOD --port 26003 --configsvr --replSet configReplSet --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/config/n3/data --pidfilepath $WORK_DIR/nodes/config/n3/db.pid --logpath $WORK_DIR/nodes/config/n3/db.log --config $CONFFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待成功启动后，输出日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;about to fork child process, waiting until server is ready for connections.
forked process: 4976
child process started successfully, parent exiting&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时通过ps 命令也可以看到3个启动的进程实例。&lt;/p&gt;
&lt;p&gt;连接其中一个Config进程，执行副本集初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mongo --port 26001 --host 127.0.0.1
&amp;gt; MongoDB server version: 3.4.7
&amp;gt; cfg={
    _id:&quot;configReplSet&quot;, 
    configsvr: true,
    members:[
        {_id:0, host:'127.0.0.1:26001'},
        {_id:1, host:'127.0.0.1:26002'}, 
        {_id:2, host:'127.0.0.1:26003'}
    ]};
rs.initiate(cfg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;strong&gt;configsvr:true&lt;/strong&gt;指明这是一个用于分片集群的Config副本集。&lt;br/&gt;关于副本集配置可&lt;a href=&quot;https://docs.mongodb.com/manual/reference/replica-configuration/&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建分片&quot;&gt;2. 创建分片&lt;/h3&gt;
&lt;p&gt;按以下脚本启动Shard1的3个实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
KEYFILE=$WORK_DIR/keyfile/mongo.key
CONFFILE=$WORK_DIR/conf/mongo_node.conf
MONGOD=$WORK_DIR/bin/mongod

echo &quot;start shard1 replicaset&quot;

$MONGOD --port 27001 --shardsvr --replSet shard1 --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/shard1/n1/data --pidfilepath $WORK_DIR/nodes/shard1/n1/db.pid --logpath $WORK_DIR/nodes/shard1/n1/db.log --config $CONFFILE
$MONGOD --port 27002 --shardsvr --replSet shard1 --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/shard1/n2/data --pidfilepath $WORK_DIR/nodes/shard1/n2/db.pid --logpath $WORK_DIR/nodes/shard1/n2/db.log --config $CONFFILE
$MONGOD --port 27003 --shardsvr --replSet shard1 --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/shard1/n3/data --pidfilepath $WORK_DIR/nodes/shard1/n3/db.pid --logpath $WORK_DIR/nodes/shard1/n3/db.log --config $CONFFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待成功启动后，输出日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;about to fork child process, waiting until server is ready for connections.
forked process: 5976
child process started successfully, parent exiting&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时通过ps 命令也可以看到3个启动的Shard进程实例。&lt;/p&gt;
&lt;p&gt;连接其中一个Shard进程，执行副本集初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mongo --port 27001 --host 127.0.0.1
&amp;gt; MongoDB server version: 3.4.7
&amp;gt; cfg={
    _id:&quot;shard1&quot;, 
    members:[
        {_id:0, host:'127.0.0.1:27001'},
        {_id:1, host:'127.0.0.1:27002'}, 
        {_id:2, host:'127.0.0.1:27003'}
    ]};
rs.initiate(cfg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考以上步骤，启动Shard2的3个实例进程，并初始化副本集。&lt;/p&gt;
&lt;h3 id=&quot;启动mongos路由&quot;&gt;3. 启动mongos路由&lt;/h3&gt;
&lt;p&gt;执行以下脚本启动3个mongos进程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
KEYFILE=$WORK_DIR/keyfile/mongo.key
CONFFILE=$WORK_DIR/conf/mongos.conf
MONGOS=$WORK_DIR/bin/mongos

echo &quot;start mongos instances&quot;
$MONGOS --port=25001 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile $KEYFILE --pidfilepath $WORK_DIR/nodes/mongos/n1/db.pid --logpath $WORK_DIR/nodes/mongos/n1/db.log --config $CONFFILE
$MONGOS --port 25002 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile $KEYFILE --pidfilepath $WORK_DIR/nodes/mongos/n2/db.pid --logpath $WORK_DIR/nodes/mongos/n2/db.log --config $CONFFILE
$MONGOS --port 25003 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile $KEYFILE --pidfilepath $WORK_DIR/nodes/mongos/n3/db.pid --logpath $WORK_DIR/nodes/mongos/n3/db.log --config $CONFFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待成功启动后，通过ps命令看到mongos进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dbuser      7903    1  0 17:49 ?        00:00:00 /opt/local/mongo-cluster/bin/mongos --port=25001 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile /opt/local/mongo-cluster/keyfile/mongo.key --pidfilepath /opt/local/mongo-cluster/nodes/mongos/n1/db.pid --logpath /opt/local/mongo-cluster/nodes/mongos/n1/db.log --config /opt/local/mongo-cluster/conf/mongos.conf
dbuser      7928    1  0 17:49 ?        00:00:00 /opt/local/mongo-cluster/bin/mongos --port 25002 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile /opt/local/mongo-cluster/keyfile/mongo.key --pidfilepath /opt/local/mongo-cluster/nodes/mongos/n2/db.pid --logpath /opt/local/mongo-cluster/nodes/mongos/n2/db.log --config /opt/local/mongo-cluster/conf/mongos.conf
dbuser      7954    1  0 17:49 ?        00:00:00 /opt/local/mongo-cluster/bin/mongos --port 25003 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile /opt/local/mongo-cluster/keyfile/mongo.key --pidfilepath /opt/local/mongo-cluster/nodes/mongos/n3/db.pid --logpath /opt/local/mongo-cluster/nodes/mongos/n3/db.log --config /opt/local/mongo-cluster/conf/mongos.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接入其中一个mongos实例，执行添加分片操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mongo --port 25001 --host 127.0.0.1
mongos&amp;gt; MongoDB server version: 3.4.7
mongos&amp;gt; sh.addShard(&quot;shard1/127.0.0.1:27001&quot;)
{ &quot;shardAdded&quot; : &quot;shard1&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; sh.addShard(&quot;shard2/127.0.0.1:27004&quot;)
{ &quot;shardAdded&quot; : &quot;shard2&quot;, &quot;ok&quot; : 1 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，分布式集群架构启动完毕，但进一步操作需要先添加用户。&lt;/p&gt;
&lt;h3 id=&quot;初始化用户&quot;&gt;4. 初始化用户&lt;/h3&gt;
&lt;p&gt;接入其中一个mongos实例，添加管理员用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use admin
db.createUser({
    user:'admin',pwd:'Admin@01',
    roles:[
        {role:'clusterAdmin',db:'admin'},
        {role:'userAdminAnyDatabase',db:'admin'},
        {role:'dbAdminAnyDatabase',db:'admin'},
        {role:'readWriteAnyDatabase',db:'admin'}
]})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前admin用户具有集群管理权限、所有数据库的操作权限。&lt;br/&gt;需要注意的是，在第一次创建用户之后，localexception不再有效，接下来的所有操作要求先通过鉴权。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use admin
db.auth('admin','Admin@01')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;检查集群状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
    &quot;_id&quot; : 1,
    &quot;minCompatibleVersion&quot; : 5,
    &quot;currentVersion&quot; : 6,
    &quot;clusterId&quot; : ObjectId(&quot;5aa39c3e915210dc501a1dc8&quot;)
}
  shards:
    {  &quot;_id&quot; : &quot;shard1&quot;,  &quot;host&quot; : &quot;shard1/127.0.0.1:27001,127.0.0.1:27002,127.0.0.1:27003&quot;,  &quot;state&quot; : 1 }
    {  &quot;_id&quot; : &quot;shard2&quot;,  &quot;host&quot; : &quot;shard2/127.0.0.1:27004,127.0.0.1:27005,127.0.0.1:27006&quot;,  &quot;state&quot; : 1 }
  active mongoses:
    &quot;3.4.7&quot; : 3
autosplit:
    Currently enabled: yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;集群用户&lt;/strong&gt;&lt;br/&gt;分片集群中的访问都会通过mongos入口，而鉴权数据是存储在config副本集中的，即config实例中system.users数据库存储了集群用户及角色权限配置。mongos与shard实例则通过内部鉴权(keyfile机制)完成，因此shard实例上可以通过添加本地用户以方便操作管理。在一个副本集上，只需要在Primary节点上添加用户及权限，相关数据会自动同步到Secondary节点。&lt;br/&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/core/security-users/#sharded-cluster-users&quot;&gt;关于集群鉴权&lt;/a&gt;&lt;br/&gt;在本案例中，我们为两个分片副本集都添加了本地admin用户。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongostat/&quot;&gt;mongostat工具&lt;/a&gt;可以显示集群所有角色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;          host insert query update delete getmore command dirty used flushes mapped vsize  res faults qrw arw net_in net_out conn    set repl                time
127.0.0.1:27001    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.49G 44.0M    n/a 0|0 0|0  429b  56.1k  25 shard1  PRI Mar 10 19:05:13.928
127.0.0.1:27002    *0    *0    *0    *0      0    7|0  0.1% 0.1%      0        1.43G 43.0M    n/a 0|0 0|0  605b  55.9k  15 shard1  SEC Mar 10 19:05:13.942
127.0.0.1:27003    *0    *0    *0    *0      0    7|0  0.1% 0.1%      0        1.43G 43.0M    n/a 0|0 0|0  605b  55.9k  15 shard1  SEC Mar 10 19:05:13.946
127.0.0.1:27004    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.48G 43.0M    n/a 0|0 0|0  546b  55.8k  18 shard2  PRI Mar 10 19:05:13.939
127.0.0.1:27005    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.43G 42.0M    n/a 0|0 0|0  540b  54.9k  15 shard2  SEC Mar 10 19:05:13.944
127.0.0.1:27006    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.46G 44.0M    n/a 0|0 0|0  540b  54.9k  17 shard2  SEC Mar 10 19:05:13.936&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五数据操作&quot;&gt;五、数据操作&lt;/h2&gt;
&lt;p&gt;在案例中，创建appuser用户、为数据库实例appdb启动分片。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use appdb
db.createUser({user:'appuser',pwd:'AppUser@01',roles:[{role:'dbOwner',db:'appdb'}]})
sh.enableSharding(&quot;appdb&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建集合book，为其执行分片初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use appdb
db.createCollection(&quot;book&quot;)
db.device.ensureIndex({createTime:1})
sh.shardCollection(&quot;appdb.book&quot;, {bookId:&quot;hashed&quot;}, false, { numInitialChunks: 4} )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续往device集合写入1000W条记录，观察chunks的分布情况&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use appdb
var cnt = 0;
for(var i=0; i&amp;lt;1000; i++){
    var dl = [];
    for(var j=0; j&amp;lt;100; j++){
        dl.push({
                &quot;bookId&quot; : &quot;BBK-&quot; + i + &quot;-&quot; + j,
                &quot;type&quot; : &quot;Revision&quot;,
                &quot;version&quot; : &quot;IricSoneVB0001&quot;,
                &quot;title&quot; : &quot;Jackson's Life&quot;,
                &quot;subCount&quot; : 10,
                &quot;location&quot; : &quot;China CN Shenzhen Futian District&quot;,
                &quot;author&quot; : {
                      &quot;name&quot; : 50,
                      &quot;email&quot; : &quot;RichardFoo@yahoo.com&quot;,
                      &quot;gender&quot; : &quot;female&quot;
                },
                &quot;createTime&quot; : new Date()
            });
      }
      cnt += dl.length;
      db.book.insertMany(dl);
      print(&quot;insert &quot;, cnt);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;strong&gt;db.book.getShardDistribution()&lt;/strong&gt;,输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Shard shard1 at shard1/127.0.0.1:27001,127.0.0.1:27002,127.0.0.1:27003
data : 13.41MiB docs : 49905 chunks : 2
estimated data per chunk : 6.7MiB
estimated docs per chunk : 24952

Shard shard2 at shard2/127.0.0.1:27004,127.0.0.1:27005,127.0.0.1:27006
data : 13.46MiB docs : 50095 chunks : 2
estimated data per chunk : 6.73MiB
estimated docs per chunk : 25047

Totals
data : 26.87MiB docs : 100000 chunks : 4
Shard shard1 contains 49.9% data, 49.9% docs in cluster, avg obj size on shard : 281B
Shard shard2 contains 50.09% data, 50.09% docs in cluster, avg obj size on shard : 281B&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Mongodb集群架构由Mongos、Config副本集和多个分片组成；&lt;br/&gt;安装过程中先初始化Config副本集、分片副本集，最后通过Mongos添加分片&lt;/li&gt;
&lt;li&gt;Config副本集存储了集群访问的用户及角色权限，为了方便管理，可以给分片副本集添加本地用户&lt;/li&gt;
&lt;li&gt;Mongodb提供了LocalException机制，首次安装数据库时可以在本机直接添加用户&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 13 Mar 2018 14:29:00 +0000</pubDate>
<dc:creator>zale.tang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/8563273.html</dc:identifier>
</item>
<item>
<title>函数与函数式编程 - BluesQian</title>
<link>http://www.cnblogs.com/QianBoy/p/8562719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QianBoy/p/8562719.html</guid>
<description>&lt;p&gt;纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。&lt;/p&gt;
&lt;h5 data-id=&quot;heading-0&quot;&gt;一、函数声明、函数表达式、匿名函数与自执行函数&lt;/h5&gt;
&lt;p&gt;关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，JavaScript中，有两种声明方式，一个是使用&lt;code&gt;var&lt;/code&gt;的变量声明，另一个是使用&lt;code&gt;function&lt;/code&gt;的函数声明。&lt;/p&gt;
&lt;p&gt;变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fn();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; function&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    console.log(&lt;/span&gt;'function'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;函数表达式 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与函数声明不同，函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明（我们知道使用var进行变量声明，其实是进行了两步操作。）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际执行顺序&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = undefined;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明，初始值undefined，变量提升，提升顺序次于function声明&lt;/span&gt;
a = 20;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量赋值，该操作不会提升&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;变量声明过程+变量执行过程　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fn(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; fn = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'function'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例子的执行顺序为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fn = undefined;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明提升&lt;/span&gt;
fn();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行报错&lt;/span&gt;
fn = &lt;span&gt;function&lt;/span&gt;() {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值操作，此时将后边函数的引用赋值给fn&lt;/span&gt;
    console.log('function'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;变量声明过程+变量执行过程+赋值操作过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;在构造函数中添加方法
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在构造函数内部中添加方法&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.getAge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给原型添加方法&lt;/span&gt;
Person.prototype.getName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在对象中添加方法&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; {
    m: &lt;/span&gt;20&lt;span&gt;,
    getM: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.m;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;匿名函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指的没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(bar, num) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bar() +&lt;span&gt; num;
}

fn(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}, &lt;/span&gt;20)        //30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数自执行与块级作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。&lt;/p&gt;
&lt;p&gt;根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有变量&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = 'Tom'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `your name is ` +&lt;span&gt; name;
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是共有方法和变量应该怎么办？大家还记得我们前面讲到过的&lt;strong&gt;闭包&lt;/strong&gt;的特性吗？没错，利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有变量&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = 'Tom'&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `your name is ` +&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 共有方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收&lt;/span&gt;
    window.getAge =&lt;span&gt; getAge;
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了帮助大家进一步理解闭包，我们来看看jQuery中，是如何利用我们模块与闭包的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用函数自执行的方式创建模块&lt;/span&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(window, undefined) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明jQuery构造函数&lt;/span&gt;
     &lt;span&gt;var&lt;/span&gt; jQuery = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主动在构造函数中，返回一个jQuery实例&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; jQuery.fn.init(name);
     }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加原型方法&lt;/span&gt;
     jQuery.prototype = jQuery.fn =&lt;span&gt; {
         constructor: jQuery,
         init:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { ... },
         css: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { ... }
     }
     jQuery.fn.init.prototype &lt;/span&gt;=&lt;span&gt; jQuery.fn;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了&lt;/span&gt;
     window.jQuery = window.$ =&lt;span&gt; jQuery;
 })(window);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了&lt;/span&gt;
$('#div1');
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 data-id=&quot;heading-1&quot;&gt;二、函数参数传递方式：按值传递&lt;/h5&gt;
&lt;p&gt;还记得基本数据类型与引用数据类型在复制上的差异吗？基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a;
b &lt;/span&gt;= 10&lt;span&gt;;
console.log(a);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; m = { a: 1, b: 2&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n =&lt;span&gt; m;
n.a &lt;/span&gt;= 5&lt;span&gt;;
console.log(m.a) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。如下例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(a) {
    a &lt;/span&gt;= a + 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}

console.log(a); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = { m: 10, n: 20&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(a) {
    a.m &lt;/span&gt;= 20&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}

fn(a);
console.log(a);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; { m: 20, n: 20 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; {
    name: &lt;/span&gt;'Nicholas'&lt;span&gt;,
    age: &lt;/span&gt;20&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; setName(obj) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入一个引用&lt;/span&gt;
    obj = {};   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将传入的引用指向另外的值&lt;/span&gt;
    obj.name = 'Greg';  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改引用的name属性&lt;/span&gt;
&lt;span&gt;}

setName(person);
console.log(person.name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas 未被改变&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。&lt;/p&gt;
&lt;h5 data-id=&quot;heading-2&quot;&gt;四、函数式编程&lt;/h5&gt;
&lt;p&gt;虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己写的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数是第一等公民&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓&quot;第一等公民&quot;（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;function&lt;/span&gt; foo() {}  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; fn(&lt;span&gt;function&lt;/span&gt;() {}, num) {}   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数作为参数&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数作为返回值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        ... ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 13 Mar 2018 13:42:00 +0000</pubDate>
<dc:creator>BluesQian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QianBoy/p/8562719.html</dc:identifier>
</item>
<item>
<title>Java集合中的HashMap类 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8558983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8558983.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;jdk1.8.0_144&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         HashMap作为最常用集合之一，继承自AbstractMap。JDK8的HashMap实现与JDK7不同，新增了红黑树作为底层数据结构，结构变得复杂，效率变得更高。为满足自身需要，也重新实现了很多AbstractMap中的方法。本文会围绕HashMap，详细探讨HashMap的底层数据结构、扩容机制、并发环境下的死循环问题等。&lt;/p&gt;
&lt;p&gt;         JDK8同JDK7一样对Map.Entry进行了重新实现，改了个名字叫——Node，我想这是因为在红黑树中更方便理解，方法和JDK7大体相同只是取消了几个方法。并且此时的Node节点（也就是Entry）结构更加完善：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点hash值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; K key;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     V value;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;value值&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     Node&amp;lt;K,V&amp;gt; next;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向的下一个节点
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略，由于JDK8的Map接口新增了几个compare比较的方法，Node直接就继承了&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Node作为HashMap维护key-value的内部数据结构比较简单，下面是HashMap重新实现Map的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public int size()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         HashMap并没有继承AbstractMap的size方法，而是重写了此方法。HashMap在类中定义了一个size变量，再此处直接返回size变量而不用调用entrySet方法返回集合再计算。可以猜测这个size变量是当插入一个key-value键值对的时候自增。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public boolean isEmpty()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         判断size变量是否0即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public boolean containsKey(Object key)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         AbstractMap通过遍历Entry节点的方式实现了这个方法，显然HashMap觉得效率太低并没有复用而是重写了这个方法。&lt;/p&gt;
&lt;p&gt;         JDK8的HashMap底层数据结构引入了红黑树，它的实现要比JDK7略微复杂，我们先来看JDK7关于这个方法的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK7，HashMap#containsKey&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(Object key) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; getEntry(key) != &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用getEntry方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　getEntry实现的思路也比较简单，由于JDK7的HashMap是数组+链表的数据结构，当key的hash值冲突的时候使用链地址法直接加到冲突地址Entry的next指针行程链表即可。所以getEntry方法的思路也是先计算key的hash值，计算后再找到它在散列表的下标，找到过再遍历这个位置的链表返回结果即可。&lt;/p&gt;
&lt;p&gt;　　JDK8加入了红黑树，在链表的个数达到阈值8时会将链表转换为红黑树，如果此时是红黑树，则不能通过遍历链表的方式寻找key值，所以JDK8对该方法进行了改进主要是需要遍历红黑树，有关&lt;strong&gt;红黑树&lt;/strong&gt;的具体算法在此不多介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8，HashMap#containsKey&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(Object key) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; getNode(hash(key), key) != &lt;span&gt;null&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8中新增了一个getNode方法，且将key的hash值计算好后作为参数传递。&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HashMap#getNode&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法相比较于JDK7中的getEntry基本相同，唯一不同的是发现key值冲突过后会通过“first instanceof TreeNode”检查此时是否是红黑树结构。如果是红黑树则会调用getTreeNode方法在红黑树上进行查询。如果不是红黑树则是链表结构，遍历链表即可。&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;public boolean containsValue(Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　遍历散列表中的元素&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public V get(Object key)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 在JDK8中get方法调用了containsKey的方法getNode，这点和JDk7的get方法中调用getEntry方法类似。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将参数key的hash值和key作为参数，调用getNode方法；&lt;/li&gt;
&lt;li&gt;根据(n - 1) &amp;amp; hash(key)计算key值所在散列桶的下标；&lt;/li&gt;
&lt;li&gt;取出散列桶中的key与参数key进行比较：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;         3.1 如果相等则直接返回Node节点；&lt;/p&gt;
&lt;p&gt;         3.2 如果不相等则判断当前节点是否有后继节点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                   3.2.1&lt;/strong&gt; &lt;strong&gt;判断是否是红黑树结构，是则调用getTreeNode&lt;/strong&gt;&lt;strong&gt;查询键值为key&lt;/strong&gt;&lt;strong&gt;的Node  &lt;/strong&gt; &lt;strong&gt;节点；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                   3.2.2 如果是链表结构，则遍历整个链表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public V put(K key, V value)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法最为关键，插入key-value到Map中，在这个方法中需要计算key的hash值，然后通过hash值计算所在散列桶的位置，判断散列桶的位置是否有冲突，冲突过后需要使用链地址法解决冲突，使之形成一个链表，从JDK8开始如果链表的元素达到8个过后还会转换为红黑树。在插入时还需要判断是否需要扩容，扩容机制的设计，以及在并发环境下扩容所带来的死循环问题。&lt;/p&gt;
&lt;p&gt;　　由于JDK7比较简单，我们先来查看JDK7中的put方法源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK7&lt;/strong&gt;&lt;strong&gt;——HashMap#put&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK7, HashMap#put&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 首先判断是否是第一次插入，即散列表是否指向空的数组，如果是，则调用inflateTable方法对HashMap进行初始化。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (table ==&lt;span&gt; EMPTY_TABLE) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        inflateTable(threshold);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 判断key是否等于null，等于空则调用putForNullKey方法存入key为null的key-value，HashMap支持key=null。&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. 调用hash方法计算key的hash值，调用indexFor根据hash值和散列表的长度计算key值所在散列表的下标i。&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4. 这一步通过循环遍历的方式判断插入的key-value是否已经在HashMap中存在，判断条件则是key的hash值相等，且value要么引用相等要么equals相等，如果满足则直接返回value。&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e = e.next) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果插入位置没有散列冲突，即这个位置没有Entry元素，则不进入循环。有散列冲突则需要遍历链表进行判断。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        Object k;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k))) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             e.recordAccess(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     modCount++；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录修改次数，在并发环境下通过迭代器遍历时会抛出ConcurrentModificationException异常（Fail-Fast机制），就是通过这个变量来实现的。在迭代器初始化过程会将modCount赋给迭代器的ExpectedModCount，是否会抛出ConcurrentModificationException异常的实现就是在迭代过程中判断modCount是否与ExpectedModCount相等。
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入key-value键值对，传入key的hash值、key、value、散列表的插入位置i&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    addEntry(hash, key, value, i);    
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }                
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK7，HashMap#addEntry，这个方法是put方法的实现核心，在其中会判断是否冲突，是否扩容。&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步判断就是是否扩容，需要扩容的条件需要满足以下两个：1、Map中的key-value的个数大于等于Map的容量threshold（threshold=散列表容量（数组大小）*负载因子）。2、key值所对应的散列表位置不为null。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; table[bucketIndex])) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         resize(2 * table.length);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键的扩容机制，扩容后的大小是之前的两倍&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         hash = (&lt;span&gt;null&lt;/span&gt; != key) ? hash(key) : 0;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算key的hash值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         bucketIndex = indexFor(hash, table.length);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新计算key所在散列表的下标&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Entry节点并插入，每次插入都会插在链表的第一个位置。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    createEntry(hash, key, value, bucketIndex);    
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　来看看HashMap是如何扩容的。JDK7HashMap扩容的大小是前一次散列表大小的两倍2 * table.length&lt;/p&gt;
&lt;p&gt;void resize(int newCapacity)&lt;/p&gt;
&lt;p&gt;　　在这个方法中最核心的是transfer(Entry[], boolean)方法，第一个参数表示扩容后新的散列表引用，第二参数表示是否初始化hash种子。&lt;/p&gt;
&lt;p&gt;　　结合源码我们用图例来说明HashMap在JDK7中是如何进行扩容的。&lt;/p&gt;
&lt;p&gt;　　假设现在有如下HashMap，初始容量initialCapacity=4，负载因子loadFactor=0.5。初始化时阈值threshold=4*0.5=2。也就是说在插入第三个元素时，HashMap中的size=3大于阈值threshold=2，此时就会进行扩容。我们从来两种情况来对扩容机制进行分析，一种是两个key-value未产生散列冲突，第二种是两个key-value产生了散列冲突。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;扩容时，当前HashMap&lt;/strong&gt;&lt;strong&gt;的key-value&lt;/strong&gt;&lt;strong&gt;未产生散列冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164741963-1506245727.png&quot; alt=&quot;&quot; width=&quot;93&quot; height=&quot;155&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;此时当插入第三个key-value时，HashMap会进行扩容，容量大小为之前的两倍，并且在扩容时会对之前的元素进行转移，未产生冲突的HashMap转移较为简单，直接遍历散列表对key重新计算出新散列表的数组下标即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164841516-1916010981.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;　　2. &lt;/strong&gt;&lt;strong&gt;扩容时，当前HashMap&lt;/strong&gt;&lt;strong&gt;的key-value&lt;/strong&gt;&lt;strong&gt;产生散列冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164911829-1292587354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在对散列冲突了的元素进行扩容转移时，需要遍历当前位置的链表，链表的转移若新散列表还是冲突则采用头插法的方式进行插入，此处需要了解链表的头插法。同样通过for (Entry&amp;lt;K,V&amp;gt; e : table)遍历散列表中的元素，判断当前元素e是否为null。由例可知，当遍历到第2个位置的时候元素e不为null。此时创建临时变量next=e.next。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164931235-707507507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　重新根据新的散列表计算e的新位置i，后面则开始通过头插法把元素插入进入新的散列表。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164948743-1963087153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　通过头插法将A插入进了新散列表的i位置，此时指针通过e=next继续移动，待插入元素变成了B，如下所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165006669-268407373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　此时会对B元素的key值进行hash运算，计算出它在新散列表中的位置，无论在哪个位置，均是头插法，假设还是在位置A上产生了冲突，头插法后则变成了如下所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165020288-1089878541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　可知，在扩容过程中，链表的转移是关键，链表的转移通过头插法进行插入，所以正是因为头插法的原因，新散列表冲突的元素位置和旧散列表冲突的元素位置相反。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　关于HashMap的扩容机制还有一个需要注意的地方，在并发条件下，HashMap不仅仅是会造成数据错误，致命的是可能会造成CPU100%被占用，原因就是并发条件下，由于HashMap的扩容机制可能会导致&lt;strong&gt;死循环&lt;/strong&gt;。下面将结合图例说明，为什么HashMap在并发环境下会造成死循环。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　假设在并发环境下，有两个线程现在都在对同一个HashMap进行扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165041650-565489199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　此时线程T1对扩容前的HashMap元素已经完成了转移，但由于Java内存模型的缘故线程T2此时看到的还是它自己线程中HashMap之前的变量副本。此时T2对数据进行转移，如下图所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165101297-1166619103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　进一步地，在T2中的新散列表中newTable[i]指向了元素A，此时待插入节点变成了B，如下图所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165118985-1540878734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　原本在正常情况下，next会指向null，但由于T1已经对A-&amp;gt;B链表进行了转置B-&amp;gt;A，即next又指回了A，并且B会插入到T2的newTable[i]中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165132974-1110044729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　由于此时next不为空，下一步又会将next赋值给e，即e = next，反反复复A、B造成闭环形成死循环。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165146875-1793743642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　所以，千万不要使用在并发环境下使用HashMap，一旦出现死循环CPU100%，这个问题不容易复现及排查。并发环境一定需要使用ConcurrentHashMap线程安全类。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　探讨了JDK7中的put方法，接下来看看JDK8新增了红黑树HashMap是如何进行put，如何进行扩容，以及如何将链表转换为红黑树的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK8&lt;/strong&gt;&lt;strong&gt;——HashMap#put&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8, HashMap#put&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在JDK8中，put方法直接调用了putVal方法，该方法有5个参数：key哈希值，key，value，onlyIfAbsent（如果为ture则Map中已经存在该值的时候将不会把value值替换），evict在HashMap中无意义&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　所以关键的方法还是putVal。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8中putVal方法和JDK7中put方法中的插入步骤大致相同，同样需要判断是否是第一次插入，插入的位置是否产生冲突，不同的是会判断插入的节点是“链表节点”还是“红黑色”节点。&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 是否是第一次插入，是第一次插入则复用resize算法，对散列表进行初始化&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 　　&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 　　　　n = (tab =&lt;span&gt; resize()).length;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 通过i = (n - 1) &amp;amp; hash计算key值所在散列表的下标，判断tab[i]是否已经有元素存在，即有无冲突，没有则直接插入即可，注意如果插入的key=null，此处和JDK7的策略略有不同，JDK7是遍历散列表只要为null就直接插入，而JDK8则是始终会插入第一个位置，即使有元素也会形成链表&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 　　&lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　　　tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. tab[i]已经有了元素即产生了冲突，如果是JDK7则直接使用头插法即可，但在JDK8中HashMap增加了红黑树数据结构，此时有可能已经是红黑树结构，或者处在链表转红黑树的临界点，所以此时需要有几个判断条件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 　　&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.1 这是一个特殊判断，如果tab[i]的元素hash和key都和带插入的元素相等，则直接覆盖value值即可&lt;/span&gt;
&lt;span&gt;12　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;13　　　　　　&lt;/span&gt;e =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.2 待插入节点是一个红黑树节点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 　　　　&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;16　　　　　　&lt;/span&gt;e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
&lt;/span&gt;&lt;span&gt;17　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.3 插入后可能继续是一个链表，也有可能转换为红黑树。在元素个数超过8个时则会将链表转换为红黑树，所以第一个则需要一个计数器来遍历计算此时tab[i]上的元素个数&lt;/span&gt;
&lt;span&gt;18　　　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19　　　　　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
&lt;/span&gt;&lt;span&gt;20　　　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21　　　　　　　　　　&lt;/span&gt;p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历到当前元素的next指向null，则通过尾插法插入，这也是和JDK7采用头插法略微不同的地方&lt;/span&gt;
&lt;span&gt;22　　　　　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tab[i]的数量超过了临界值8，此时将会进行链表转红黑树的操作，并跳出循环&lt;/span&gt;
&lt;span&gt;23　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;treeifyBin(tab, hash);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 　　　　　　　　   &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(k))))        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这种情况同3.1，出现了和插入key相同的元素，直接跳出循环，覆盖value值即可，无需插入操作&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;               　　&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;              p =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;29　　　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;30　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;31　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这种情况表示带插入元素的key在Map中已经存在，此时没有插入操作，直接覆盖value值即可&lt;/span&gt;
&lt;span&gt;32　　　　　　&lt;/span&gt;V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;33　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34　　　　　　　　&lt;/span&gt;e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;35　　　　　　&lt;/span&gt;&lt;span&gt;afterNodeAccess(e);
&lt;/span&gt;&lt;span&gt;36　　　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;37　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39　　&lt;/span&gt;++modCount;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改计数，在使用Iterator迭代器时会和这个变量比较，如果不相等，则会抛出ConcurrentModificationException异常&lt;/span&gt;
&lt;span&gt;40　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++size &amp;gt; threshold)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否需要扩容&lt;/span&gt;
&lt;span&gt;41　　　　&lt;/span&gt;&lt;span&gt;resize();
&lt;/span&gt;&lt;span&gt;42　　&lt;/span&gt;afterNodeInsertion(evict);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并无意义&lt;/span&gt;
&lt;span&gt;43　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;　　从上面的JDK7和JDK8的put插入方法源码分析来看，JDK8确实复杂了不少，在没有耐心的情况下，这个“干货”确实显得比较干，我试着用下列图解的方式回顾JDK7和JDK8的插入过程，在对比过后接着对JDK8中的红黑树插入、链表转红黑树以及扩容作分析。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165818146-448391420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313170007447-1369876724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　综上JDK7和JDK8的put插入方法大体上相同，其核心均是计算key的hash并通过hash计算散列表的下标，再判断是否产生冲突。只是在实现细节上略有区别，例如JDK7会对key=null做特殊处理，而JDK8则始终会放置在第0个位置；而JDK7在产生冲突时会使用头插法进行插入，而JDK8在链表结构时会采用尾插法进行插入；当然最大的不同还是JDK8对节点的判断分为了：链表节点、红黑树节点、链表转换红黑树临界节点。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　对于红黑树的插入暂时不做分析，接下来是对JDK8扩容方法的分析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JDK8，HashMap#resize扩容，HashMap扩容的大小仍然是前一次散列表大小的两倍 &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
&lt;/span&gt;&lt;span&gt; 3　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 由于JDK8初始化散列表时复用了resize方法，所以前面是对oldTab的判断，是否为0（表示是初始化），是否已经大于等于了最大容量。判断结束后newTab会扩大为oldTab的两倍，同样newThr（阈值）也是以前的两倍。源码略。
&lt;/span&gt;&lt;span&gt; 4　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 确定好newTab的大小后接下来就是初始化newTab散列表数组&lt;/span&gt;
&lt;span&gt; 5　　&lt;/span&gt;Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
&lt;/span&gt;&lt;span&gt; 6　　&lt;/span&gt;table =&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt; 7　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. 如果是初始化（即oldTab==null），则直接返回新的散列表数组，不是则进行转移
&lt;/span&gt;&lt;span&gt; 8　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4. 首先还是遍历散列表&lt;/span&gt;
&lt;span&gt; 9　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;10　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5. e = oldCap[i] != null，则继续判断
&lt;/span&gt;&lt;span&gt;11　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.1 当前位置i，是否有冲突，没有则直接转移&lt;/span&gt;
&lt;span&gt;12　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13　　　　　　&lt;/span&gt;newTab[e.hash &amp;amp; (newCap - 1)] = e;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里并没有对要转移的元素重新计算hash，对于JDK7来会通过hash(e.getKey()) ^ newCap重新计算e在newTab中的位置，此处则是e.hash &amp;amp; (newCap - 1)，减少了重新计算hash的过程。扩容后的位置要么在原来的位置上，要么在原索引 + oldCap位置 
&lt;/span&gt;&lt;span&gt;14　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.2 判断是否是红黑树节点&lt;/span&gt;
&lt;span&gt;15　　　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;16　　　　　　&lt;/span&gt;((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
&lt;/span&gt;&lt;span&gt;17　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.3 判断是否是链表节点&lt;/span&gt;
&lt;span&gt;18　　　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 　　　　&lt;span&gt;…
&lt;/span&gt;&lt;span&gt;20　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;　　JDK8的扩容机制相比较于JDK7除了增加对节点是否为红黑树的判断，其余大致相同，只是做了一些微小的优化。特别在于在JDK8中并不会重新计算key的hash值。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;public V remove(Object key)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　如果已经非常清楚put过程，我相信对于HashMap中的其他方法也基本能知道套路。remove删除也不例外，计算hash(key)以及所在散列表的位置i，判断i是否有元素，元素是否是红黑树还是链表。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　这个方法容易陷入的陷阱是key值是一个自定义的pojo类，且并没有重写equals和hashCode方法，此时用pojo作为key值进行删除，很有可能出现“删不掉”的情况。这需要重写equals和hashCode才能使得两个pojo对象“相等”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　剩下的方法思路大同小异，基本均是计算hash、计算散列表下标i、遍历、判断节点类型等等。本文在弄清put和resize方法后，一切方法基本上都能举一反三。所以在看完本文后，你应该试着问自己以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HashMap的底层数据结构是什么？&lt;/li&gt;
&lt;li&gt;HashMap的put过程？&lt;/li&gt;
&lt;li&gt;HashMap的扩容机制？&lt;/li&gt;
&lt;li&gt;并发环境下HashMap会带来什么致命问题？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 13:32:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8558983.html</dc:identifier>
</item>
<item>
<title>使用asyncio实现redis客户端 - walkabc</title>
<link>http://www.cnblogs.com/hitfire/p/8562560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hitfire/p/8562560.html</guid>
<description>&lt;p&gt;redis协议格式请参考，http://doc.redisfans.com/topic/protocol.html&lt;/p&gt;
&lt;p&gt;这里简单介绍下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
*&amp;lt;参数数量&amp;gt;&lt;span&gt; \r\n
$&lt;/span&gt;&amp;lt;参数 &lt;span&gt;1&lt;/span&gt; 的字节数量&amp;gt;&lt;span&gt; \r\n
&lt;/span&gt;&amp;lt;参数 &lt;span&gt;1&lt;/span&gt; 的数据&amp;gt;&lt;span&gt; \r\n
$&lt;/span&gt;&amp;lt;参数 N 的字节数量&amp;gt;&lt;span&gt; \r\n
&lt;/span&gt;&amp;lt;参数 N 的数据&amp;gt; \r\n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送给redis服务器时的数据要按照redis要求的协议格式发送，只有这样redis服务器才能成功解析。&lt;/p&gt;
&lt;p&gt;首先根据协议格式写一个封包方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; format_command(self, commands):
        length &lt;/span&gt;=&lt;span&gt; len(commands)
        command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(length)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; commands:
            bytes &lt;/span&gt;= v.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            bytes_length &lt;/span&gt;=&lt;span&gt; len(bytes)
            sub_command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(bytes_length) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(v)
            command &lt;/span&gt;+=&lt;span&gt; sub_command
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; command
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到format_command函数中的“*”和“$”符号了么。其实就是根据commands列表中的数据然后按照redis协议格式封装起来的。&lt;/p&gt;
&lt;p&gt;弄懂了如何安装redis协议封装数据之后，就可以把数据发送到redis服务器了。&lt;/p&gt;
&lt;p&gt;asyncio的官方demo可参考：&lt;/p&gt;
&lt;p&gt;https://docs.python.org/3/library/asyncio-stream.html#tcp-echo-client-using-streams&lt;/p&gt;
&lt;p&gt;下面就是完整的代码，无其他依赖，顺利执行之后，可以通过redis-cli命令行查看是否设置成功。&lt;/p&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncRedis:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, host, port, loop):
        self.host &lt;/span&gt;=&lt;span&gt; host
        self.port &lt;/span&gt;=&lt;span&gt; port
        self.loop &lt;/span&gt;=&lt;span&gt; loop
        self.separator &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.encode()

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect(self):
        reader, writer &lt;/span&gt;= await asyncio.open_connection(self.host, self.port, loop=&lt;span&gt;self.loop)
        self.reader &lt;/span&gt;=&lt;span&gt; reader
        self.writer &lt;/span&gt;=&lt;span&gt; writer

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; format_command(self, commands):
        length &lt;/span&gt;=&lt;span&gt; len(commands)
        command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(length)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; commands:
            bytes &lt;/span&gt;= v.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            bytes_length &lt;/span&gt;=&lt;span&gt; len(bytes)
            sub_command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(bytes_length) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(v)
            command &lt;/span&gt;+=&lt;span&gt; sub_command
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(command)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; command

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; execute_command(self, command):
        self.writer.write(command.encode(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set(self, key, value):
        command &lt;/span&gt;= self.format_command([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key, value])
        self.execute_command(command)
        ret, error &lt;/span&gt;=&lt;span&gt; await self.wait_ret()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hset(self, hash_key, key, value):
        command &lt;/span&gt;= self.format_command([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HSET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hash_key, key, value])
        self.execute_command(command)

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, key):
        command &lt;/span&gt;= self.format_command([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, key])
        self.execute_command(command)
        ret &lt;/span&gt;=&lt;span&gt; await self.wait_ret()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wait_ret(self):
        ret &lt;/span&gt;=&lt;span&gt; await self.reader.readuntil(self.separator)
        ret &lt;/span&gt;=&lt;span&gt; ret.decode()
        mark &lt;/span&gt;= ret[0:1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; mark == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            pos &lt;/span&gt;= ret.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= ret[1&lt;span&gt;:pos]
            ret &lt;/span&gt;=&lt;span&gt; await self.reader.read(int(ret))
            ret &lt;/span&gt;=&lt;span&gt; ret.decode()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret, True
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; mark == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            pos &lt;/span&gt;= ret.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= ret[1&lt;span&gt;:pos]
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret, True
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; mark == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            pos &lt;/span&gt;= ret.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= ret[1&lt;span&gt;:pos]
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret, False

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; close(self):
        self.writer.close()

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; NewRedis(loop):
    redis &lt;/span&gt;= AsyncRedis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 6379&lt;span&gt;, loop)
    await redis.connect()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; await redis.get(&quot;name&quot;)&lt;/span&gt;
    await redis.set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;云想衣裳花想容，春风拂槛露华浓。\r\n 若非群玉山头见，会向瑶台月下逢。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
loop.run_until_complete(NewRedis(loop))
loop.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 13 Mar 2018 13:32:00 +0000</pubDate>
<dc:creator>walkabc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hitfire/p/8562560.html</dc:identifier>
</item>
<item>
<title>IDE-IntelliJ IDEA 主题、字体、编辑区主题、文件编码修改、乱码问题 - 赵小叔</title>
<link>http://www.cnblogs.com/mm15732621582/p/8561942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mm15732621582/p/8561942.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;same-origin&quot;/&gt;&lt;title&gt;IDE-IntelliJ IDEA 主题、字体、编辑区主题、文件编码修改、乱码问题 - 赵小叔 - 博客园&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=-hy83QNg62d4qYibixJzxMJkbf1P9fTBlqv7SK5zVL01&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/darkgreentrip/bundle-darkgreentrip.css?v=xPXJVC4GCITs1yYYgSeLkcicCxapqseaPVQLFGMO1wc1&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/blog/customcss/305167.css?v=vYbvNcQ9UMRg8MrPo2Utg42E3Sc%3d&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/darkgreentrip/bundle-darkgreentrip-mobile.css?v=6NcJHqsIyaE4w19VtgFvCFahrnr2rYCTRRTdxlMDhhQ1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;http://www.cnblogs.com/mm15732621582/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;http://www.cnblogs.com/mm15732621582/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;http://www.cnblogs.com/mm15732621582/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-a-theme-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-a-theme-setting-1.jpg&quot; alt=&quot;主题修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;上图标注 1 所示为 IntelliJ IDEA 修改主题的地方，可以通过打开左上角的File -&amp;gt; Setting。在 Windows 系统上 IntelliJ IDEA 默认提供的主题有四套：&lt;code&gt;Darcula&lt;/code&gt;、&lt;code&gt;IntelliJ&lt;/code&gt;、&lt;code&gt;Windows&lt;/code&gt;、&lt;code&gt;Alloy. IDEA Theme&lt;/code&gt;。除了 &lt;code&gt;Darcula&lt;/code&gt; 是黑色主题，其他三套都是以白色为背景的。&lt;/li&gt;
&lt;li&gt;其他操作系统上不一定会也有四套主题的，主题的选择上大家根据自己喜好即可。改变主题需要重启 IntelliJ IDEA 方可看到效果。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2&gt;字体修改&lt;/h2&gt;
&lt;h3&gt;主题字体修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-b-font-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-1.jpg&quot; alt=&quot;主题字体修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图标注 1 所示，IntelliJ IDEA 主题字体的修改要先勾选 &lt;code&gt;Override default fonts by&lt;/code&gt; 。默认 IntelliJ IDEA 是不推荐修改的，但是由于字体是有分包含中文和不包含中文之分的，一般使用英文的国家是不需要额外担心乱码问题的，而我们需要。&lt;/li&gt;
&lt;li&gt;字体的审美上每个人不一样，但是如上一段说的，这里的字体修改是需要知道一个前提的，那就是你选择的那个字体必须含有中文，比如微软雅黑和宋体这类是包含中文的，而 &lt;code&gt;Courier New&lt;/code&gt; 和 &lt;code&gt;Monaco&lt;/code&gt; 这类只是单纯的英文字体。&lt;/li&gt;
&lt;li&gt;如果你选择的字体不包含中文，那可能会在很多位置上出现类似 &lt;code&gt;口口口口口&lt;/code&gt; 这样的乱码问题，比如文件名含有中文、字体是中文名字的都会变成 &lt;code&gt;口口口口口&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在修改 IntelliJ IDEA 的主题字体的时候，不建议把字体调成很大，因为很多人遇到这样一种情况：显示器分辨率低，主题字体又大，在 IntelliJ IDEA 的某些操作的工具菜单、右键菜单选项中部分选项超出了分辨率显示范围，没办法被选中。当然了，如果你一定要把字体改大，又不用大分辨率显示器，那可以通过 IntelliJ IDEA 的 &lt;code&gt;Menus and Toolbars&lt;/code&gt; 删除部分你认为用不到的菜单，但是一般不建议这样做。&lt;/li&gt;
&lt;li&gt;还需要特别注意的时候，如果你是开着 IntelliJ IDEA 的时候，新装了一个字体的话，那必须重启IntelliJ IDEA 之后才能在下拉列表找到新装的字体。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;代码编辑字体修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-b-font-setting-2.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-2.jpg&quot; alt=&quot;代码编辑字体修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图标注 1 所示，默认 IntelliJ IDEA 是不能直接在默认的代码模板上修改字体的，需要先 &lt;code&gt;Save As&lt;/code&gt; 一份出来，然后才可以修改。这种设计在 IntelliJ IDEA 其他很多设置也是如此的，所以如果你还看到类似有 &lt;code&gt;Copy&lt;/code&gt;、&lt;code&gt;Save As&lt;/code&gt; 这类选项的按钮就要想到是此设计思想。&lt;/li&gt;
&lt;li&gt;如上图标注 2 所示，勾选的 &lt;code&gt;Show only monospaced fonts&lt;/code&gt; 表示筛选显示系统上的等宽字体。由于 Windows 系统上等宽字体并不多，勾选此选项出现的下拉字体可选择就很少。取消勾选之后，就可以显示系统上所有已安装的字体。&lt;/li&gt;
&lt;li&gt;如上图标注 3 所示，其中编码字体有第一字体（&lt;code&gt;Primary font&lt;/code&gt;） 和 第二字体（&lt;code&gt;Secondary font&lt;/code&gt;）之分。当有些字符在第一字体支持不了的时候，会去使用第二字体进行支持。&lt;/li&gt;
&lt;li&gt;我个人习惯上：英文字体使用 &lt;code&gt;Monaco&lt;/code&gt;，由于此字体不支持中文，所以我把这个设置为第一字体，第二字体使用 &lt;code&gt;Yahei Consolas Hybrid&lt;/code&gt; 进行支持，该字体含有中文。这两个字体都不是系统自带的，需要自行下载安装。&lt;/li&gt;
&lt;li&gt;如果你的第一字体不包含中文的话，第二字体包含中文，那在有些地方也还是会出现 &lt;code&gt;口口口口口&lt;/code&gt; 这类问题，比如 &lt;code&gt;Ctrl + Shift + N&lt;/code&gt; 进行查找文件的时候，如果你输入中文也会变成 &lt;code&gt;口口口口口&lt;/code&gt; ，我个人文件名为中文的不多，所以就容忍了这种情况。如果你不愿意容忍这种情况，那还是回到最开始的要求：第一字体包含中文。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;控制台输出字体修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-b-font-setting-3.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-3.jpg&quot; alt=&quot;控制台输出字体修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图为控制台输出内容字体修改，有很多 IntelliJ IDEA 新人在做输出的时候出现乱码原因就是因为没有在这里进行设置。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;控制台输出字体&lt;/em&gt; 修改的原理跟 &lt;em&gt;代码编辑字体修改&lt;/em&gt; 是一样的，所以这里不进行讲解。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2&gt;编辑区主题修改&lt;/h2&gt;
&lt;h3&gt;编辑区主题介绍&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-c-code-theme-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-c-code-theme-setting-1.jpg&quot; alt=&quot;编辑区主题介绍&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;编辑区主题，也就是代码书写区的主题修改。基本上大家在 &lt;code&gt;General&lt;/code&gt; 上都有对此进行小修小改，我下面也主要介绍下我个人在 &lt;code&gt;General&lt;/code&gt; 上常修改的一些地方，其他特性的颜色修改我一般默认，但是修改方法原理一样。&lt;/li&gt;
&lt;li&gt;如上图红圈下拉所示，展示的是我当前电脑可以选择的编辑区主题。&lt;/li&gt;
&lt;li&gt;对于编辑区的主题，也有人制作成模板在网络上提供下载。这里主要介绍两个站点：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3&gt;编辑区主题细节修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-c-code-theme-setting-2.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-c-code-theme-setting-2.jpg&quot; alt=&quot;编辑区主题细节修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;上图标注 1 为可修改的通用细节内容&lt;/li&gt;
&lt;li&gt;上图标注 2 为可修改属性，其中并不是每个细节都可以修改所有属性的。比如细节：&lt;code&gt;Default text&lt;/code&gt; 是可以勾选 &lt;code&gt;Bold&lt;/code&gt;，而 &lt;code&gt;Caret row&lt;/code&gt; 则是无法勾选 &lt;code&gt;Bold&lt;/code&gt;，因为只有文本才有加粗的属性需求。&lt;/li&gt;
&lt;li&gt;上图标注 3 为修改后的预览区，预览区是实时动态展示的。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;General&lt;/code&gt; 区，我常修改的有：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Default text&lt;/code&gt;，指的是默认代码文本，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Caret row&lt;/code&gt;，指的是光标所在行，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vertical indent guide&lt;/code&gt;，指的是垂直缩进线，我一般会修改其 &lt;code&gt;Foreground&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Identifier under caret&lt;/code&gt;，指的是光标所在位置的相同标识符呈现什么效果，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Text search result&lt;/code&gt;，指的是在查找模式下，匹配字符的样式，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;文件编码修改&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-d-encoding-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-d-encoding-setting-1.jpg&quot; alt=&quot;文件编码修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;上图标注 1 所示，IDE 的编码默认是 &lt;code&gt;UTF-8&lt;/code&gt;，&lt;code&gt;Project Encoding&lt;/code&gt; 虽然默认是 &lt;code&gt;GBK&lt;/code&gt;，但是一般我都建议修改为 &lt;code&gt;UTF-8&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;上图标注 2 所示，IntelliJ IDEA 可以对 &lt;code&gt;Properties&lt;/code&gt; 文件进行专门的编码设置，一般也建议改为 &lt;code&gt;UTF-8&lt;/code&gt;，其中有一个重点就是属性 &lt;code&gt;Transparent native-to-ascii conversion&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;上图标注 3 所示，对于 &lt;code&gt;Properties&lt;/code&gt; 文件，重要属性 &lt;code&gt;Transparent native-to-ascii conversion&lt;/code&gt; 主要用于转换 &lt;code&gt;ascii&lt;/code&gt;，一般都要勾选，不然 &lt;code&gt;Properties&lt;/code&gt; 文件中的注释显示的都不会是中文。&lt;/li&gt;
&lt;li&gt;上图标注 4 所示，IntelliJ IDEA 除了支持对整个 Project 设置编码之外，还支持对目录、文件进行编码设置。如果你要对目录进行编码设置的话，可能会出现需要 &lt;code&gt;Convert&lt;/code&gt; 编码的弹出操作选择，强烈建议 在转换之前做好文件备份，不然可能出现转换过程变成乱码，无法还原。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-d-encoding-setting-2.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-d-encoding-setting-2.gif&quot; alt=&quot;文件编码修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图演示，对单独文件的编码修改还可以点击右下角的编码设置区。如果代码内容中包含中文，则会弹出演示中的操作选择。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Reload&lt;/code&gt; 表示使用新编码重新加载，新编码不会保存到文件中，重新打开此文件，旧编码是什么依旧还是什么。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Convert&lt;/code&gt; 表示使用新编码进行转换，新编码会保存到文件中，重新打开此文件，新编码是什么则是什么。&lt;/li&gt;
&lt;li&gt;含有中文的代码文件，&lt;code&gt;Convert&lt;/code&gt; 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;由于编码问题引起的编译错误&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;编译报错：&lt;code&gt;找不到符号&lt;/code&gt;、&lt;code&gt;未结束的字符串文字&lt;/code&gt; 等的解决办法：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;由于 UTF-8 编码文件有分 &lt;code&gt;有BOM&lt;/code&gt; 和 &lt;code&gt;无BOM&lt;/code&gt; 之分，默认情况下 IntelliJ IDEA 使用的编译器是 &lt;code&gt;javac&lt;/code&gt;，而此编译只能编译 &lt;code&gt;无BOM&lt;/code&gt; 的文件，有很多 Eclipse 用户在使用 IntelliJ IDEA 开发 Eclipse 项目的时候常常会遇到此问题。主要是因为 Eclipse 的编译器是 &lt;code&gt;Eclipse&lt;/code&gt;，此编译器支持 &lt;code&gt;有BOM&lt;/code&gt; 的文件编译。故，解决办法是对于此文件进行 BOM 去除。&lt;/li&gt;
&lt;li&gt;批量去除 BOM，你可以 Google：&lt;code&gt;批量去除 BOM&lt;/code&gt;、&lt;code&gt;批量转换无 BOM&lt;/code&gt; 等关键字，网络上已有提供各种方案。&lt;/li&gt;
&lt;li&gt;除了通过去除 BOM 还有设置 IntelliJ IDEA 的编译器为 &lt;code&gt;Eclipse&lt;/code&gt;，但是一般不建议这样做。&lt;/li&gt;
&lt;li&gt;如果上述问题都无法解决，而且你也确认 IntelliJ IDEA 各个配置编码的地方都是 &lt;code&gt;UTF-8&lt;/code&gt;，报错文件编码也是是&lt;code&gt;UTF-8 无 BOM&lt;/code&gt; 的话，那还有一种可能也会出现这种情况：项目配置文件有问题。项目编码的配置文件在：&lt;code&gt;/项目目录/.idea/encodings.xml&lt;/code&gt;。如果你会修改此文件可以进行修改，如果不会，那就删除掉 &lt;code&gt;.idea&lt;/code&gt; 整个目录，重启 IntelliJ IDEA 重新配置这个项目即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Tomcat 控制台输出乱码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-e-encoding-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-e-encoding-setting-1.jpg&quot; alt=&quot;Tomcat 控制台输出乱码&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你的 Tomcat 控制台输出乱码，并且你已经保证了本文上面的控制台字体设置你设置的字体包含中文，那你还可以尝试下在 Tomcat 的 VM 参数上加上：&lt;code&gt;-Dfile.encoding=UTF-8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;更多资料：https://github.com/judasn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2018-03-13 20:54&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/mm15732621582/&quot;&gt;赵小叔&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=8561942&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/mm15732621582/p/8561942.html#&quot; onclick=&quot;AddToWz(8561942);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Tue, 13 Mar 2018 12:54:00 +0000</pubDate>
<dc:creator>赵小叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mm15732621582/p/8561942.html</dc:identifier>
</item>
<item>
<title>机器学习之二：分类算法 之 逻辑回归 - Fordestiny</title>
<link>http://www.cnblogs.com/Fordestiny/p/8561293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fordestiny/p/8561293.html</guid>
<description>&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;p&gt;分类应是极为常见的问题，我们生活周边的一切事物，皆是类别分明。机器学习领域，处理分类问题的方法有多种，如逻辑回归、支持向量机、以及无监督学习的K-mean等等。本文主要介始逻辑回归。&lt;/p&gt;
&lt;h2 id=&quot;逻辑回归&quot;&gt;逻辑回归&lt;/h2&gt;
&lt;p&gt;逻辑回归，主要用于解决分类问题，例如二分类。&lt;/p&gt;
&lt;p&gt;对于二分类问题，通过给出的样本&lt;span class=&quot;math inline&quot;&gt;\(（x,y）\)&lt;/span&gt;（若为二分类，y={0,1}），确定一个可以对数据一分为二的边界，有了这个边界，对于一个新的样本，根据其特征，便能预测其类属。边界可以是一根直线，或是一个圆，或是一个多边形等。&lt;/p&gt;
&lt;p&gt;对于多分类问题，可以通过执行多次逻辑回归解决。&lt;/p&gt;
&lt;p&gt;分类问题的解决方法，与线性回归类似，一样从误差函数入手，一样使用梯度下降法。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;分类问题，其 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 值一般设置为有限的离散值，例如0、1。所以系统所要做的工作，就是当一个新的样本输入时，需要判断其为可能值的概率分别有多大，以此在确定其y值。&lt;/p&gt;
&lt;h3 id=&quot;模型假设&quot;&gt;1、模型假设&lt;/h3&gt;
&lt;p&gt;令逻辑回归的假设函数为：&lt;span class=&quot;math inline&quot;&gt;\(h_\theta(x) = g(\theta^TX)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(g(z) = \frac{1}{1+e^{-z}}\)&lt;/span&gt;，为sigmoid函数。&lt;/p&gt;
&lt;h4 id=&quot;对gz函数的理解&quot;&gt;对g(z)函数的理解&lt;/h4&gt;
&lt;p&gt;g(z)函数是来源于最大熵原理，通过拉格朗日乘数法（寻找变量受一个或多个条件限制的多元函数极值的方法）求偏导得出，故而 &lt;span class=&quot;math inline&quot;&gt;\(h_\theta(x)\)&lt;/span&gt;的值，其实是系统 &quot;认为&quot; 样本为 &quot;1&quot; 的概率值P，即：&lt;/p&gt;
&lt;p&gt;$&lt;br/&gt;h_\theta(x) = P(y=1|x)&lt;br/&gt;$&lt;/p&gt;
&lt;h4 id=&quot;使用-sigmoid-函数的优点&quot;&gt;使用 sigmoid 函数的优点&lt;/h4&gt;
&lt;p&gt;以二分类为例，输入样本，输出 0 或 1，显然阶跌函数有这些特性，如下&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \varepsilon(t-t_0) = \begin{cases} 0, &amp;amp; t &amp;lt; t_0 \\ 1, &amp;amp; t &amp;gt; t_0 \end{cases} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但阶跃函数在 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 处理，有两个问题：&lt;/p&gt;
&lt;p&gt;（1）是 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 时的值应当认为 0 还是 1？&lt;/p&gt;
&lt;p&gt;（2）是 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 发生了跃变，数学上求导麻烦。&lt;/p&gt;
&lt;p&gt;而sigmoid函数，其值满足0~1之间，且为单调递增的连续曲线，比之阶跃函数更有优势。&lt;/p&gt;
&lt;h3 id=&quot;误差函数&quot;&gt;2、误差函数&lt;/h3&gt;
&lt;p&gt;误差函数为&lt;/p&gt;
&lt;p&gt;$&lt;br/&gt;J = \frac{1}{m} \sum_{i=1}^{m}[-y^{(i)}log(h_\theta(x^{(i)})) - (1-y^{(i)})log(1-h_\theta(x^{(i)}))]&lt;br/&gt;$&lt;/p&gt;
&lt;p&gt;误差函数对 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 的导数为&lt;/p&gt;
&lt;p&gt;$&lt;br/&gt;grad = \frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}&lt;br/&gt;$&lt;/p&gt;
&lt;h2 id=&quot;一最简单的二分类一阶特征直线边界&quot;&gt;一、最简单的二分类，一阶特征，直线边界&lt;/h2&gt;
&lt;h3 id=&quot;误差函数及偏导数&quot;&gt;1、误差函数及偏导数&lt;/h3&gt;
&lt;h4 id=&quot;误差函数实现&quot;&gt;1.1 误差函数实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;function [J, grad] = costFunction(theta, X, y)

m = length(y); % number of training examples
J = 0;

grad = zeros(size(theta));

h = sigmoid(X*theta);

J = ((-y' * log(h)) - (1-y)' * log(1-h))/m;

grad = 1/m .* X' * (h-y); 

% =============================================================

end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;误差函数测试&quot;&gt;1.2 误差函数测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[m, n] = size(X);

% Add intercept term to x and X_test
X = [ones(m, 1) X];

% Initialize fitting parameters
initial_theta = zeros(n + 1, 1);

% Compute and display initial cost and gradient
[cost, grad] = costFunction(initial_theta, X, y);

fprintf('Cost at initial theta (zeros): %f\n', cost);
fprintf('Expected cost (approx): 0.693\n');
fprintf('Gradient at initial theta (zeros): \n');
fprintf(' %f \n', grad);
fprintf('Expected gradients (approx):\n -0.1000\n -12.0092\n -11.2628\n');

% Compute and display cost and gradient with non-zero theta
test_theta = [-24; 0.2; 0.2];
[cost, grad] = costFunction(test_theta, X, y);

fprintf('\nCost at test theta: %f\n', cost);
fprintf('Expected cost (approx): 0.218\n');
fprintf('Gradient at test theta: \n');
fprintf(' %f \n', grad);
fprintf('Expected gradients (approx):\n 0.043\n 2.566\n 2.647\n');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;梯度下降算法&quot;&gt;2、梯度下降算法&lt;/h3&gt;
&lt;p&gt;这里使用优化的函数进行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%  Set options for fminunc
options = optimset('GradObj', 'on', 'MaxIter', 400);

%  Run fminunc to obtain the optimal theta
%  This function will return theta and the cost 
[theta, cost] = fminunc(@(t)(costFunction(t, X, y)), initial_theta, options);

% Print theta to screen
fprintf('Cost at theta found by fminunc: %f\n', cost);
fprintf('Expected cost (approx): 0.203\n');
fprintf('theta: \n');
fprintf(' %f \n', theta);
fprintf('Expected theta (approx):\n');
fprintf(' -25.161\n 0.206\n 0.201\n');
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预测&quot;&gt;3、预测&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;prob = sigmoid([1 45 85] * theta);
fprintf(['For a student with scores 45 and 85, we predict an admission ' ...
         'probability of %f\n'], prob);
fprintf('Expected value: 0.775 +/- 0.002\n\n');

% Compute accuracy on our training set
p = predict(theta, X);

fprintf('Train Accuracy: %f\n', mean(double(p == y)) * 100);
fprintf('Expected accuracy (approx): 89.0\n');&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二多边形边界&quot;&gt;二、多边形边界&lt;/h2&gt;
&lt;p&gt;上面是最简单的分类问题，而现实中的样本，往往需要拟合一条曲线来划分数据，即是多项式拟合。&lt;/p&gt;
&lt;p&gt;其处理方法，基本与上式相同。不同的是需要将特征转为多项式转换，使之能拟合更复杂的边界，如圆、或者其他的不规则图形。&lt;/p&gt;
&lt;h3 id=&quot;数据预处理生成多项式特征&quot;&gt;1、数据预处理，生成多项式特征&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;X = mapFeature(X(:,1), X(:,2));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;生成多项式的方法如下&quot;&gt;生成多项式的方法如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;function out = mapFeature(X1, X2)
degree = 6;  
out = ones(size(X1(:,1)));
for i = 1:degree
    for j = 0:i
        out(:, end+1) = (X1.^(i-j)).*(X2.^j);
    end
end

end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;训练&quot;&gt;2、训练&lt;/h3&gt;
&lt;p&gt;使用与一阶边界相同的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;% Initialize fitting parameters
initial_theta = zeros(size(X, 2), 1);

% Set Options
options = optimset('GradObj', 'on', 'MaxIter', 400);

% Optimize
[theta, J, exit_flag] = ...
    fminunc(@(t)(costFunction(t, X, y)), initial_theta, options);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预测-1&quot;&gt;3、预测&lt;/h3&gt;
&lt;p&gt;二分类的预测方法：对于一个新的样本，分别计算其为0、1概率，取大于0.5的值做为输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = predict(theta, X);
fprintf('Train Accuracy: %f\n', mean(double(p == y)) * 100);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;function p = predict(theta, X)
m = size(X, 1); % Number of training examples
p = zeros(m, 1);
p_medium = sigmoid(X*theta);  
pos = find(p_medium &amp;gt;= 0.5);  
p(pos,1)=1;  
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三多分类问题&quot;&gt;三、多分类问题&lt;/h2&gt;
&lt;p&gt;例如给出如下训练集，100张大小为20*20图，内容为0~9的数字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/6cbb8645gw1f9gxsvzg6kj20v40ncadw.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;X 为每张图的像素数值，即特征数 n = 400&lt;/p&gt;
&lt;p&gt;y 为图上的数字，即y = {0,1,2,3,4,5,6,7,8,9}&lt;/p&gt;
&lt;h3 id=&quot;训练-1&quot;&gt;1、训练&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[all_theta] = oneVsAll(X, y, num_labels);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别对每个数字进行训练，得出10个theta矩阵。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function [all_theta] = oneVsAll(X, y, num_labels)
m = size(X, 1);
n = size(X, 2);
all_theta = zeros(num_labels, n + 1);

% Add ones to the X data matrix
X = [ones(m, 1) X];

initial_thata  = zeros(n+1,1);
options = optimset('GradObj','on','MaxIter',50);
for c = 1:num_labels
    [all_theta(c,:)] =  fmincg(@(t)(costFunction(t,X,(y ==c))),initial_thata,options);
end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预测-2&quot;&gt;2、预测&lt;/h3&gt;
&lt;p&gt;输入一张图片，计算其为0~9的各个概率，概率最大的值就是其输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pred = predictOneVsAll(all_theta, X);

fprintf('\nTraining Set Accuracy: %f\n', mean(double(pred == y)) * 100);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;function p = predictOneVsAll(all_theta, X)

m = size(X, 1);
num_labels = size(all_theta, 1);
p = zeros(size(X, 1), 1);
X = [ones(m, 1) X];

% 计算得出X中，可能的所有概率值，取最大
h  = sigmoid(X* all_theta');
[~,p] = max(h,[],2); 
end
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 13 Mar 2018 12:37:00 +0000</pubDate>
<dc:creator>Fordestiny</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fordestiny/p/8561293.html</dc:identifier>
</item>
</channel>
</rss>