<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>xBIM WeXplorer xViewer 浏览器检查 - 在 水 一 方</title>
<link>http://www.cnblogs.com/w2011/p/8467945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w2011/p/8467945.html</guid>
<description>&lt;h3&gt;目录&lt;/h3&gt;
&lt;h4&gt;    基础&lt;/h4&gt;
&lt;h4&gt;     高级应用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;xBIM 综合使用案例与 ASP.NET MVC 集成（一）&lt;/li&gt;
&lt;li&gt;xBIM 综合使用案例与 ASP.NET MVC 集成（二）&lt;/li&gt;
&lt;li&gt;xBIM 综合使用案例与 ASP.NET MVC 集成（三）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    在之前的博客&lt;a href=&quot;http://www.cnblogs.com/w2011/p/8457805.html&quot; target=&quot;_blank&quot;&gt;xBIM WeXplorer xViewer 基本应用&lt;/a&gt; 我们已经提到，WeXplore不能在所有的浏览器上运行。为了方便简单操作，我们觉得使用最新技术。浏览器应该满足几个先决条件才能运行查看器。请不要放弃检查浏览器，它可以在几年前的电脑上运行Chrome 或者 Mozilla的PC 上运行。并且可以在平板电脑和移动设备上运行。主要的限制是关于在IE11之前不支持WebGLass的IE。为了在开发的过程中方便。查看器具有静态功能来检查其要求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; check &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xViewer.check();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (check.noErrors)
    {
        ...
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实很简单的，只要运行这个静态函数，他会向你报告任何错误和警告。（当然现在一般也不会遇到错误)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello building!&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;css/layout.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/xbim-viewer.debug.bundle.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;viewer&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;500&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; check &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xViewer.check();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (check.noErrors)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; viewer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; xViewer(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;viewer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                viewer.load(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/SampleHouse.wexbim&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                viewer.start();
            }
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果检查浏览器不兼容、可以向用户提供错误报告，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; check &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xViewer.check();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (check.noErrors)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;start animation, listen to events and do all the funny stuff&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; msg &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        msg.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; check.errors)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; error &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; check.errors[i];
            msg.innerHTML &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div style='color: red;'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; error &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 24 Feb 2018 15:16:00 +0000</pubDate>
<dc:creator>在 水 一 方</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w2011/p/8467945.html</dc:identifier>
</item>
<item>
<title>TensorFlow实战之实现自编码器过程 - 蓝色之旅</title>
<link>http://www.cnblogs.com/georgeli/p/8467831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/georgeli/p/8467831.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt; &lt;span&gt; &lt;span&gt;      &lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;关于本文说明，已同步本人另外一个博客地址位于http://blog.csdn.net/qq_37608890，详见http://blog.csdn.net/qq_37608890/article/details/79352212。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;      本文根据最近学习TensorFlow书籍网络文章的情况,特将一些学习心得做了总结,详情如下.如有不当之处,请各位大拿多多指点,在此谢过。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;一、相关概念&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;strong&gt;1、稀疏性（Sparsity）及稀疏编码（Sparse Coding）&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         Sparsity 是当今机器学习领域中的一个重要话题。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;          Sparsity 的最重要的“客户”大概要属 high dimensional data 了吧。现在的机器学习问题中，具有非常高维度的数据随处可见。例如，在文档或图片分类中常用的 bag of words 模型里，如果词典的大小是一百万，那么每个文档将由一百万维的向量来表示。高维度带来的的一个问题就是计算量：在一百万维的空间中，即使计算向量的内积这样的基本操作也会是非常费力的。不过，如果向量是稀疏的的话（事实上在 bag of words 模型中文档向量通常都是非常稀疏的），例如两个向量分别只有L1 和 L2 个非零元素，那么计算内积可以只使用min(L1,L2) 次乘法完成。因此稀疏性对于解决高维度数据的计算量问题是非常有效的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;          稀疏编码(Sparse Coding)算法是一种无监督学习方法，它用来寻找一组“超完备”基向量来更高效地表示样本数据。稀疏编码算法的目的就是找到一组基向量 &lt;img src=&quot;http://img.blog.csdn.net/20180223130625593&quot; alt=&quot;&quot;/&gt;，使得我们能将输入向量&lt;img src=&quot;http://img.blog.csdn.net/20180223130636249&quot; alt=&quot;&quot;/&gt; 表示为这些基向量的线性组合：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180223130647735&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;       虽然形如主成分分析技术（PCA）能使我们方便地找到一组“完备”基向量，但是这里我们想要做的是找到一组“超完备”基向量来表示输入向量&lt;img src=&quot;http://img.blog.csdn.net/20180223130845723&quot; alt=&quot;&quot;/&gt;（也就是说，k &amp;gt; n）。超完备基的好处是它们能更有效地找出隐含在输入数据内部的结构与模式。然而，对于超完备基来说，系数 ai 不再由输入向量&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180223130636249&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 唯一确定。因此，在稀疏编码算法中，我们另加了一个评判标准“稀疏性”来解决因超完备而导致的退化（degeneracy）问题。要求系数 ai 是稀疏的意思就是说：对于一组输入向量，我们只想有尽可能少的几个系数远大于零。选择使用具有稀疏性的分量来表示我们的输入数据是有原因的，因为绝大多数的感官数据，比如自然图像，可以被表示成少量基本元素的叠加，在图像中这些基本元素可以是面或者线。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         在早期，学者们研究稀疏编码（Sparse Coding）时，搜集了大量黑白风景照片，且从中提取了16像素*16像素的图片碎片。结果发现：几乎所有的图像碎片都可以用64种正交的边组合得到，且组合出一张图像碎片需要的边的数量是很少的，即稀疏的。学者们同时也发现，声音其实也存在这种情况，他们从大量的未标注的音频中发现了20种基本结构，绝大多数声音可以由这些基本结构线性组合得到。显然，这就是特征的稀疏表达，使用少量的基本特征组合拼装得到更高层抽象的特征。一般情况想，我们也需要多层的神经网络，对每一层神经网络而言，前一层的输出都是未加工的像素，而这一层则是对像素进行加工组织成更高阶的特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、自编码（AutoEncoder）&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         顾名思义，即可以使用自身的高阶特征编码自己。自编码器其实也是一种神经网络，它的输入和输出是一致的，它借助稀疏编码的思想，目标是使用稀疏的一些高阶特征重新组合来重构自己，即 ：对所有的自编码器来讲，目标都是样本重构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         在机器学习中，自编码器的使用十分广泛。自编码器首先通过编码层，将高维空间的向量，压缩成低维的向量（潜在变量），然后通过解码层将低维向量解压重构出原始样本&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、隐含层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        指输入层和输出层以外，中间的那些层。输入层和输出层是可见的，且层的结构是相对固定的，而隐含层结构不固定，相当于不可见。只要隐含的节点足够多，即是只有一个隐含层的神经网络也可以拟合任意函数。隐含层层数越多，越容易拟合复杂的函数。拟合复杂函数需要的隐含节点数目随着层数的增多而呈指数下降。即层数越深，概念越抽象，这就是深度学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、过拟合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      指模型预测准确率在训练集上升高，但在测试集上反而下降。这是模型的泛化性不好，只记住了当前数据的特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、Dropout&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       Dropout:防止过拟合的一种方法。将神经网络某一层的输出节点数据随机丢弃一部分。可以理解为是对特征的采样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、优化函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        优化调试网络中的参数。一般情况下，在调参时，学习率的设置会导致最后结果差异很大。神经网络通常不是凸优化，充满局部最优，但是神经网络可能有很多个局部最优都能达到良好效果，反而全局最优容易出现过拟合。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       对于SGD，通常一开始学习率大一些，可以快速收敛，但是训练的后期，希望学习率可以小一些，可以比较稳定地落到一个局部最优解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        除SGD之外，还有自适应调节学习率的Adagrad、Adam、Adadelta等优化函数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、激活函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Sigmoid函数的输出在（0,1），最符合概率输出的定义，但局限性较大。&lt;br/&gt;ReLU,当x&amp;lt;=0时，y=0；当x&amp;gt;0时，y=x。这非常类似于人类的阈值响应机制。ReLU的3个显著特点：单侧抑制；相对宽阔的兴奋边界；稀疏激活性。它是目前最符合实际神经元的模型。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;二、自解码器算法原理     &lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、BacsicAuto-Encoder&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;         Auto-Encoder(AE)是20世纪80年代晚期提出的，简单讲，AE可以被视为一个三层神经网络结构：一个输入层、一个隐藏层和一个输出层，从数据规模上讲，输入层与输出层具有相同的规模。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;             &lt;img src=&quot;http://img.blog.csdn.net/20180224204452857&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                             图1  Auto-Encoder网络结构示意图&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;     其中，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;n&lt;span lang=&quot;zh-cn&quot;&gt;表示输入层（同时也是作为输出层）的规模；m&lt;span lang=&quot;zh-cn&quot;&gt;表示隐藏层的规模；&lt;img src=&quot;http://img.blog.csdn.net/20180224205033962&quot; alt=&quot;&quot;/&gt;，&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;分别表示输出层、隐藏层和输出层上的向量，也是各层上对应的数据个数，这里隐藏层h&lt;span lang=&quot;zh-cn&quot;&gt;的数据低于输入层和输出层的数据，即x&amp;gt;h&amp;lt;y&lt;span lang=&quot;zh-cn&quot;&gt;且x=y&lt;span lang=&quot;zh-cn&quot;&gt;。根据输入层x&lt;span lang=&quot;zh-cn&quot;&gt;到隐藏层h&lt;span lang=&quot;zh-cn&quot;&gt;的映射矩阵求出h&lt;span lang=&quot;zh-cn&quot;&gt;，再根据隐藏层h&lt;span lang=&quot;zh-cn&quot;&gt;到输出层的映射矩阵求出y。&lt;img src=&quot;http://img.blog.csdn.net/20180224205122114&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;分别表示隐藏层和输出层上的偏置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;向量。&lt;img src=&quot;http://img.blog.csdn.net/20180224205203602&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;表示输入层与隐藏层之间的权值矩阵，即x&lt;span lang=&quot;zh-cn&quot;&gt;到h&lt;span lang=&quot;zh-cn&quot;&gt;的映射矩阵，是n&lt;span lang=&quot;zh-cn&quot;&gt;乘m&lt;span lang=&quot;zh-cn&quot;&gt;阶矩阵；&lt;img src=&quot;http://img.blog.csdn.net/2018022420524792&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;表示隐藏层与输出层之间的权值矩阵，即h&lt;span lang=&quot;zh-cn&quot;&gt;到y&lt;span lang=&quot;zh-cn&quot;&gt;的映射矩阵，是m&lt;span lang=&quot;zh-cn&quot;&gt;乘n&lt;span lang=&quot;zh-cn&quot;&gt;阶矩阵，也是W&lt;span lang=&quot;zh-cn&quot;&gt;的逆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;矩阵。&lt;span lang=&quot;zh-cn&quot;&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;   针对AE而言，重要的是解决好矩阵W问题，一个好的矩阵W可以保证x完全等于y，可实际上很难，尤其当输入层x的数据量大成千上百个时，x和y的差别就可以说明矩阵W的优良程度。总之，我们的工作就是要求出矩阵W，并使得x和y之间的差异尽可能小。下面给出下图，进一步做出解释&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;     &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                  &lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224205351622&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;                        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                         &lt;span&gt;图2 Auto-Encoder抽象结构 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;如图2所示，AE由编码器（Enconder）和解码器（Decoder）两部分构成。显然，从输入层到隐藏层属于编码过程，从隐藏层到输出层属于解码过程。我们设定f和g分别表示编码和解码函数，结合上面的内容，我们可以给出f和g的方程，如下(1.1)和(1.2)式所示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                  &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224205555754&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       其中 &lt;img src=&quot;http://img.blog.csdn.net/2018022420563142&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;为编码器的激活函数，通常情况下取Sigmoid&lt;span lang=&quot;zh-cn&quot;&gt;函数，即 &lt;img src=&quot;http://img.blog.csdn.net/20180224205655758&quot; alt=&quot;&quot;/&gt;；&lt;img src=&quot;http://img.blog.csdn.net/2018022420572379&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;为解码器的激活函数，一般取Sigmoid&lt;span lang=&quot;zh-cn&quot;&gt;函数或恒等函数，即&lt;img src=&quot;http://img.blog.csdn.net/2018022420574696&quot; alt=&quot;&quot;/&gt;。权值矩阵&lt;img src=&quot;http://img.blog.csdn.net/20180224205817657&quot; alt=&quot;&quot;/&gt;一般取&lt;img src=&quot;http://img.blog.csdn.net/20180224205829436&quot; alt=&quot;&quot;/&gt;，&lt;span lang=&quot;zh-cn&quot;&gt;一些文献资料中提及称，这种情况下的AE&lt;span lang=&quot;zh-cn&quot;&gt;具有tiedweights&lt;span lang=&quot;zh-cn&quot;&gt;。本文指讨论二者相等的情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       所以，&lt;span lang=&quot;zh-cn&quot;&gt;截止目前，我们可知，AE&lt;span lang=&quot;zh-cn&quot;&gt;的参数为 &lt;img src=&quot;http://img.blog.csdn.net/20180224210005655&quot; alt=&quot;&quot;/&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         假设目前我们有一个训练集&lt;/span&gt;&lt;/span&gt;&lt;span&gt;S=&lt;img src=&quot;http://img.blog.csdn.net/20180224210040279&quot; alt=&quot;&quot;/&gt;，&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;那么我们要考虑的问题是如何利用S&lt;span lang=&quot;zh-cn&quot;&gt;取&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;训练&lt;img src=&quot;http://img.blog.csdn.net/20180224210112771&quot; alt=&quot;&quot;/&gt;，首先是建立一个训练目标。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       结合前面的梳理，我们可知，AE可以被看成一个普通的三层神经网络，y也可以看成由x做的一个预测（prediction），且保证x和y尽可能接近，这种接近程度可以通过重构误差（reconstruction error）函数L（x，y）来进行表达。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;    根据解码器激活函数&lt;img src=&quot;http://img.blog.csdn.net/20180224210456815&quot; alt=&quot;&quot;/&gt;的不同，这里L（x,y)一般有两种取值方法：&lt;br/&gt;             第一种，当&lt;img src=&quot;http://img.blog.csdn.net/20180224210518463&quot; alt=&quot;&quot;/&gt;为恒等函数时，取平方误差（sequared error）函数&lt;img src=&quot;http://img.blog.csdn.net/20180224210603953&quot; alt=&quot;&quot;/&gt;。&lt;br/&gt;     第二种，当 &lt;img src=&quot;http://img.blog.csdn.net/20180224210518463&quot; alt=&quot;&quot;/&gt;为sigmoid函数（此种情况输入&lt;img src=&quot;http://img.blog.csdn.net/20180224210654305&quot; alt=&quot;&quot;/&gt;）时，取交叉熵（cross-entropy）函数&lt;img src=&quot;http://img.blog.csdn.net/20180224210816895&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;    取得重构函数后，我们就可以对数据集S进行针对性的训练，去得到一个整体的损失函数（loss function）（1.5）&lt;br/&gt;                                 &lt;img src=&quot;http://img.blog.csdn.net/20180224210921163&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        将上面这个函数（1.5）进行极小化处理，我们就可以得到所需的参数&lt;img src=&quot;http://img.blog.csdn.net/20180224211016808&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        注意，一般文献中损失函数多数使用的是平均重构误差（average reconstruction error)，即下面函数（1.6）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;                         &lt;img src=&quot;http://img.blog.csdn.net/20180224211049914&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;         对于一个给定的训练集S而言，系数1/N并不对于上面这个损失函数最小化产生多大的影响，所以，为了简便，这里忽略这个系数。&lt;/p&gt;&lt;p&gt;    最开始，AE只是作为一种降维技巧来使用的，视隐藏层h为x的一种降维表示，也要求m&amp;lt;n（h&amp;lt;x）。但是，目前来看，AE在m&amp;gt;=n的情况（有些文献中称为 over-complete setting）下应用更多,以便获取更高维数更有意义的表达方式。当然，在次情况下，也会有一个问题不可忽略：若直接对损失函数（1.5）进行极小化的而没有加入任何其他限制条件的话，AE在这里学到的很可能是一个恒等函数（where the auto-encoder could perfectly reconstruction the input without needing to extract any useful feature），这种结果是不符合预期的。需要解决，例如  ， 在损失函数中加入稀疏性限制（Sparse Auto-Encoder），或在网络中引入随机性（如RBN，Denoising Auto-Encoder）等。&lt;br/&gt;    下面先介绍 Regularized Auto-Encoer 和Sparse Auto-Encoder，其余的AE变种算法，后续有机会继续梳理。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt; &lt;span&gt;&lt;strong&gt;2、 Regularized Auto-Encoder&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         我们在损失函数（1.5）中加入正则项，便可以得到所谓的Regularized Auto-Encoder。 常见的正则化有L1 正则和 L2正则。以L2正则为例进行介绍，损失  函数则变为如下（2.7）：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                        &lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211213129&quot; alt=&quot;&quot;/&gt;        &lt;br/&gt;      其中 &lt;img src=&quot;http://img.blog.csdn.net/20180224211305257&quot; alt=&quot;&quot;/&gt;     为权值矩阵W的元素。&lt;br/&gt;公式（2.7）中的&lt;img src=&quot;http://img.blog.csdn.net/20180224211335477&quot; alt=&quot;&quot;/&gt;即为L2正则项，也叫做权重衰减（weight-decay）项（&lt;img src=&quot;http://img.blog.csdn.net/20180224211402618&quot; alt=&quot;&quot;/&gt;下标中的&lt;img src=&quot;http://img.blog.csdn.net/20180224211416110&quot; alt=&quot;&quot;/&gt; 就是weight-decay的意思），lambda为权重衰减参数，用来控制公式中两项的相对重要性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、Sparse Auto-Encoder&lt;/strong&gt;&lt;br/&gt;         由公式（2.7）可以看出，权重衰减项实际上是对权重提出一些要求，也就是要求它们不能过大，否则会被惩罚。这里所讲的Sparse Auto-Encoder 是对隐藏层上神经元的激活度提出要求，使其满足一定的稀疏性。&lt;br/&gt;        关于隐藏层上神经元激活度如何刻画的问题，下面展开来看：&lt;br/&gt;            假设&lt;img src=&quot;http://img.blog.csdn.net/20180224211446567&quot; alt=&quot;&quot;/&gt;表示输入为x时，隐藏层上第j个神经元的激活度（&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211446567&quot; alt=&quot;&quot;/&gt;  是（1.1）中向量h的第j个分量），则（3.8）&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211524286&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;         表示隐藏层上第j个神经元在训练集 &lt;img src=&quot;http://img.blog.csdn.net/20180224211554424&quot; alt=&quot;&quot;/&gt;上的平均激活度。为了保证隐藏层上的神经元大部分时间被抑制为零或者接近于零（即稀疏性限制），这里要求（3.9）&lt;img src=&quot;http://img.blog.csdn.net/2018022421161515&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;其中，&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;为稀疏性参数，一般情况下取一个很小的数（如   &lt;img src=&quot;http://img.blog.csdn.net/20180224211720594&quot; alt=&quot;&quot;/&gt;）。对于那些与&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;有显著不同的&lt;img src=&quot;http://img.blog.csdn.net/2018022421174477&quot; alt=&quot;&quot;/&gt;，会进行惩罚。这个限制方法的实现有多种，这里以一种基于KL divergence的方法，即引入（3.10） &lt;img src=&quot;http://img.blog.csdn.net/20180224211808841&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其中，（3.11）&lt;img src=&quot;http://img.blog.csdn.net/20180224211918498&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;函数 &lt;img src=&quot;http://img.blog.csdn.net/20180224211941978&quot; alt=&quot;&quot;/&gt;具有如下性质：&lt;br/&gt;      随着&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/2018022421174477&quot; alt=&quot;&quot;/&gt;和   &lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;之间的差异增大而单调递增，尤其当 &lt;img src=&quot;http://img.blog.csdn.net/20180224212107723&quot; alt=&quot;&quot;/&gt;时，存在&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224212042114&quot; alt=&quot;&quot;/&gt;达到最小值。所以，如果将（3.10）加入到损失函数里，则最小化损失函数即可达到使得&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/2018022421174477&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;尽可能靠近 &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的效果。这样来看，Sparse Auto-Encoder的损失函数就可以表达为（3.12）&lt;br/&gt;                           &lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224212203293&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;         这里beta为控制稀疏性惩罚项的权重系数。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;        我们也可以将L2正则和稀疏性限制结合起来使用，这时的损失函数也就变为（3.13）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                     &lt;img src=&quot;http://img.blog.csdn.net/2018022421230530&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;三、实现去噪自编码器过程&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;1、代码实现过程如下&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;91&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 这里以最具代表性的去噪自编码器为例。

#导入MNIST数据集

import numpy as np

import sklearn.preprocessing as prep

import tensorflow as tf

from tensorflow.examples.tutorials.mnist import input_data


#这里使用一种参数初始化方法xavier initialization，需要对此做好定义工作。

#Xaiver初始化器的作用就是让权重大小正好合适。

#这里实现的是标准均匀分布的Xaiver初始化器。

def xavier_init(fan_in, fan_out, constant = 1):

&quot;&quot;&quot;

目的是合理初始化权重。

参数：

fan_in --行数；

fan_out -- 列数；

constant --常数权重，条件初始化范围的倍数。

return 初始化后的权重tensor.

&quot;&quot;&quot;

low = -constant * np.sqrt(6.0 / (fan_in + fan_out))

high = constant * np.sqrt(6.0 / (fan_in + fan_out))

return tf.random_uniform((fan_in, fan_out),

minval = low, maxval = high,

dtype = tf.float32)


#定义一个去噪的自编码类

class AdditiveGaussianNoiseAutoencoder(object):

&quot;&quot;&quot;

__init__() :构建函数；

n_input : 输入变量数；

n_hidden : 隐含层节点数；

transfer_function: 隐含层激活函数，默认是softplus；

optimizer : 优化器，默认是Adam;

scale : 高斯噪声系数，默认是0.1；

&quot;&quot;&quot;

def __init__(self, n_input, n_hidden, transfer_function =tf.nn.softplus, optimizer = tf.train.AdamOptimizer(),

scale = 0.1):

self.n_input = n_input

self.n_hidden = n_hidden

self.transfer = transfer_function

self.scale = tf.placeholder(tf.float32)

self.training_scale = scale

network_weights = self._initialize_weights()

self.weights = network_weights


# 定义网络结构，为输入x创建一个维度为n_input的placeholder，然后

#建立一个能提取特征的隐含层。

self.x = tf.placeholder(tf.float32, [None, self.n_input])

self.hidden = self.transfer(tf.add(tf.matmul(self.x +scale * tf.random_normal((n_input,)),

self.weights['w1']),

self.weights['b1']))

self.reconstruction = tf.add(tf.matmul(self.hidden,self.weights['w2']), self.weights['b2'])


#首先，定义自编码器的损失函数，在此直接使用平方误差(SquaredError)作为cost。

#然后，定义训练操作作为优化器self.optimizer对损失self.cost进行优化。

#最后，创建Session，并初始化自编码器全部模型参数。

self.cost = 0.5 *tf.reduce_sum(tf.pow(tf.subtract(self.reconstruction, self.x), 2.0))

self.optimizer = optimizer.minimize(self.cost)


init = tf.global_variables_initializer()

self.sess = tf.Session()

self.sess.run(init)


def _initialize_weights(self):

all_weights = dict()

all_weights['w1'] = tf.Variable(xavier_init(self.n_input,self.n_hidden))

all_weights['b1'] = tf.Variable(tf.zeros([self.n_hidden],dtype = tf.float32))

all_weights['w2'] = tf.Variable(tf.zeros([self.n_hidden,self.n_input], dtype = tf.float32))

all_weights['b2'] = tf.Variable(tf.zeros([self.n_input],dtype = tf.float32))

return all_weights


def partial_fit(self, X):

cost, opt = self.sess.run((self.cost, self.optimizer),feed_dict = {self.x: X,

self.scale: self.training_scale})

return cost


def calc_total_cost(self, X):

return self.sess.run(self.cost, feed_dict = {self.x: X,

self.scale:self.training_scale})

#定义一个transform函数，以便返回自编码器隐含层的输出结果，目的是提供一个接口来获取抽象后的特征。

def transform(self, X):

return self.sess.run(self.hidden, feed_dict = {self.x: X,

self.scale:self.training_scale})


def generate(self, hidden = None):

if hidden is None:

hidden = np.random.normal(size = self.weights[&quot;b1&quot;])

return self.sess.run(self.reconstruction, feed_dict ={self.hidden: hidden})

def reconstruct(self, X):

return self.sess.run(self.reconstruction, feed_dict ={self.x: X,

self.scale: self.training_scale})


def getWeights(self): #获取隐含层的权重w1.

return self.sess.run(self.weights['w1'])


def getBiases(self): #获取隐含层的偏执系数b1.

return self.sess.run(self.weights['b1'])

#利用TensorFlow提供的读取示例数据的函数载入MNIST数据集。

mnist = input_data.read_data_sets('MNIST_data', one_hot = True)

#定义一个对训练、测试数据进行标准化处理的函数。

def standard_scale(X_train, X_test):

preprocessor = prep.StandardScaler().fit(X_train)

X_train = preprocessor.transform(X_train)

X_test = preprocessor.transform(X_test)

return X_train, X_test


def get_random_block_from_data(data, batch_size):

start_index = np.random.randint(0, len(data) - batch_size)

return data[start_index:(start_index + batch_size)]


X_train, X_test = standard_scale(mnist.train.images,mnist.test.images)


n_samples = int(mnist.train.num_examples)

training_epochs = 20

batch_size = 128

display_step = 1

autoencoder = AdditiveGaussianNoiseAutoencoder(n_input = 784,

n_hidden = 200,

transfer_function =tf.nn.softplus,

optimizer =tf.train.AdamOptimizer(learning_rate = 0.001),

scale = 0.01)

for epoch in range(training_epochs):

avg_cost = 0.

total_batch = int(n_samples / batch_size)

# Loop over all batches

for i in range(total_batch):

batch_xs = get_random_block_from_data(X_train, batch_size)


# Fit training using batch data

cost = autoencoder.partial_fit(batch_xs)

# Compute average loss

avg_cost += cost / n_samples * batch_size

# Display logs per epoch step

if epoch % display_step == 0:

print(&quot;Epoch:&quot;, '%04d' % (epoch + 1), &quot;cost=&quot;,&quot;{:.9f}&quot;.format(avg_cost))

#最后对训练完的模型进行性能测试。

print(&quot;Total cost: &quot; +str(autoencoder.calc_total_cost(X_test)))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、执行结果如下&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
Extracting MNIST_data/train-images-idx3-ubyte.gz
Extracting MNIST_data/train-labels-idx1-ubyte.gz
Extracting MNIST_data/t10k-images-idx3-ubyte.gz
Extracting MNIST_data/t10k-labels-idx1-ubyte.gz
Epoch: 0001 cost= 18871.253996591
Epoch: 0002 cost= 12308.673515909
Epoch: 0003 cost= 10227.495348864
Epoch: 0004 cost= 11243.596613636
Epoch: 0005 cost= 10782.029647727
Epoch: 0006 cost= 9165.328120455
Epoch: 0007 cost= 8487.490198295
Epoch: 0008 cost= 9195.667004545
Epoch: 0009 cost= 9026.087407955
Epoch: 0010 cost= 8301.502948295
Epoch: 0011 cost= 9921.268600568
Epoch: 0012 cost= 8789.966229545
Epoch: 0013 cost= 9115.636243182
Epoch: 0014 cost= 8993.681156818
Epoch: 0015 cost= 7670.030270455
Epoch: 0016 cost= 8108.834190341
Epoch: 0017 cost= 7897.135417045
Epoch: 0018 cost= 8332.914957955
Epoch: 0019 cost= 8091.132888068
Epoch: 0020 cost= 7822.976949432
Total cost: 725054.5
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    &lt;br/&gt;           至此，我们可以发现，从实现的角度而言，自编码器其实和一个单隐含层的神经网络差不多，只是自编码器在数据输入时做了标准化处理，且加上了一个高斯噪声，同时我们的输出结果不是数字分类结果，而是复原的数据，因此不需要用标注过的数据进行监督训练。自编码器作为一种无监督学习方法，它与其他无监督学习的区别主要在于：它不是对数据进行聚类，而是把数据中最有用、最频繁的高阶特征提取出来，然后根据这些高阶特征进行重构数据。在深度学习发展早期非常流行的DBN，也是依靠这种思想，先对数据进行无监督学习，提取到一些有用的特征，将神经网络权重初始化到一个较好的分布，然后再使用有标注的数据进行监督训练，即对权重进行fine-tune。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         现实生活中，大部分数据是没有标准信息的，但人脑比较擅长处理这些数据，会提取出其中的高阶抽象特征，并使用在别的地方。自编码器作为深度学习在无监督领域的应用的确非常成功，同时无监督学习也将成为深度学习一个重要发展方向。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考资料   &lt;strong&gt;主要参考资料《TensorFlow实战》（黄文坚  唐源 著）（电子工业出版社）&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Sat, 24 Feb 2018 14:07:00 +0000</pubDate>
<dc:creator>蓝色之旅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/georgeli/p/8467831.html</dc:identifier>
</item>
<item>
<title>【深度学习】常用的模型评估指标 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8467613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8467613.html</guid>
<description>&lt;p&gt;“没有测量，就没有科学。”这是科学家门捷列夫的名言。在计算机科学中，特别是在机器学习的领域，对模型的测量和评估同样至关重要。只有选择与问题相匹配的评估方法，我们才能够快速的发现在模型选择和训练过程中可能出现的问题，迭代地对模型进行优化。本文将总结机器学习最常见的模型评估指标，其中包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;precision&lt;/li&gt;
&lt;li&gt;recall&lt;/li&gt;
&lt;li&gt;F1-score&lt;/li&gt;
&lt;li&gt;PRC&lt;/li&gt;
&lt;li&gt;ROC和AUC&lt;/li&gt;
&lt;li&gt;IOU&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;从混淆矩阵谈起&quot;&gt;从混淆矩阵谈起&lt;/h2&gt;
&lt;p&gt;看一看下面这个例子：假定瓜农拉来一车西瓜，我们用训练好的模型对这些西瓜进行判别，显然我们可以使用错误率来衡量有多少比例的瓜被判别错误。但如果我们关心的是“挑出的西瓜中有多少比例是好瓜”，或者“所有好瓜中有多少比例被挑出来了”，那么错误率显然就不够用了，这时我们需要引入新的评估指标，比如“查准率”和查全率更适合此类需求的性能度量。&lt;/p&gt;
&lt;p&gt;在引入查全率和查准率之前我们必须先理解到什么是混淆矩阵（Confusion matrix）。这个名字起得是真的好，初学者很容易被这个矩阵搞得晕头转向。下图a就是有名的混淆矩阵，而下图b则是由混淆矩阵推出的一些有名的评估指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204329655-1160264310.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们首先好好解读一下混淆矩阵里的一些名词和其意思。根据混淆矩阵我们可以得到TP,FN,FP,TN四个值，显然TP+FP+TN+FN=样本总数。这四个值中都带两个字母，单纯记忆这四种情况很难记得牢，我们可以这样理解：第一个字母表示本次预测的正确性，T就是正确，F就是错误；第二个字母则表示由分类器预测的类别，P代表预测为正例，N代表预测为反例。比如TP我们就可以理解为分类器预测为正例（P），而且这次预测是对的（T），FN可以理解为分类器的预测是反例（N），而且这次预测是错误的（F），正确结果是正例，即一个正样本被错误预测为负样本。我们使用以上的理解方式来记住TP、FP、TN、FN的意思应该就不再困难了。，下面对混淆矩阵的四个值进行总结性讲解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;True Positive （真正，TP）被模型预测为正的正样本&lt;/li&gt;
&lt;li&gt;True Negative（真负 , TN）被模型预测为负的负样本&lt;/li&gt;
&lt;li&gt;False Positive （假正, FP）被模型预测为正的负样本&lt;/li&gt;
&lt;li&gt;False Negative（假负 , FN）被模型预测为负的正样本&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;precisionrecallprcf1-score&quot;&gt;Precision、Recall、PRC、F1-score&lt;/h2&gt;
&lt;p&gt;Precision指标在中文里可以称为查准率或者是精确率，Recall指标在中卫里常被称为查全率或者是召回率，查准率 P和查全率 R分别定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205202185-367942820.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查准率P和查全率R的具体含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查准率(Precision）是指在所有系统判定的“真”的样本中，确实是真的的占比&lt;/li&gt;
&lt;li&gt;查全率（Recall）是指在所有确实为真的样本中，被判为的“真”的占比&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里想强调一点，precision和accuracy（正确率）不一样的，accuracy针对所有样本，precision针对部分样本，即正确的预测/总的正反例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205007882-641098274.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查准率和查全率是一对矛盾的度量，一般而言，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。我们从直观理解确实如此：我们如果希望好瓜尽可能多地选出来，则可以通过增加选瓜的数量来实现，如果将所有瓜都选上了，那么所有好瓜也必然被选上，但是这样查准率就会越低；若希望选出的瓜中好瓜的比例尽可能高，则只选最有把握的瓜，但这样难免会漏掉不少好瓜，导致查全率较低。通常只有在一些简单任务中，才可能使查全率和查准率都很高。&lt;/p&gt;
&lt;p&gt;再说PRC， 其全称就是Precision Recall Curve，它以查准率为Y轴，、查全率为X轴做的图。它是综合评价整体结果的评估指标。所以，哪总类型（正或者负）样本多，权重就大。也就是通常说的『对样本不均衡敏感』，『容易被多的样品带走』。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204341976-647484907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图就是一幅P-R图，它能直观地显示出学习器在样本总体上的查全率和查准率，显然它是一条总体趋势是递减的曲线。在进行比较时，若一个学习器的PR曲线被另一个学习器的曲线完全包住，则可断言后者的性能优于前者，比如上图中A优于C。但是B和A谁更好呢？因为AB两条曲线交叉了，所以很难比较，这时比较合理的判据就是比较PR曲线下的面积，该指标在一定程度上表征了学习器在查准率和查全率上取得相对“双高”的比例。因为这个值不容易估算，所以人们引入“平衡点”(BEP)来度量，他表示“查准率=查全率”时的取值，值越大表明分类器性能越好，以此比较我们一下子就能判断A较B好。&lt;/p&gt;
&lt;p&gt;BEP还是有点简化了，更常用的是F1度量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205027586-434414606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F1-score 就是一个综合考虑precision和recall的指标，比BEP更为常用。&lt;/p&gt;
&lt;h2 id=&quot;roc-auc&quot;&gt;ROC &amp;amp; AUC&lt;/h2&gt;
&lt;p&gt;ROC全称是“受试者工作特征”（Receiver Operating Characteristic）曲线，ROC曲线以“真正例率”（TPR）为Y轴，以“假正例率”（FPR）为X轴，对角线对应于“随机猜测”模型，而（0,1）则对应“理想模型”。ROC形式如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204355006-1724131879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TPR和FPR的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205043320-355960721.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从形式上看TPR就是我们上面提到的查全率Recall，而FPR的含义就是：所有确实为“假”的样本中，被误判真的样本。&lt;/p&gt;
&lt;p&gt;进行学习器比较时，与PR图相似，若一个学习器的ROC曲线被另一个学习器的曲线包住，那么我们可以断言后者性能优于前者；若两个学习器的ROC曲线发生交叉，则难以一般性断言两者孰优孰劣。此时若要进行比较，那么可以比较ROC曲线下的面积，即AUC，面积大的曲线对应的分类器性能更好。&lt;/p&gt;
&lt;p&gt;AUC（Area Under Curve）的值为ROC曲线下面的面积，若分类器的性能极好，则AUC为1。但现实生活中尤其是工业界不会有如此完美的模型，一般AUC均在0.5到1之间，AUC越高，模型的区分能力越好，上图AUC为0.81。若AUC=0.5，即与上图中红线重合，表示模型的区分能力与随机猜测没有差别。若AUC真的小于0.5，请检查一下是不是好坏标签标反了，或者是模型真的很差。&lt;/p&gt;
&lt;h2 id=&quot;怎么选择评估指标&quot;&gt;怎么选择评估指标？&lt;/h2&gt;
&lt;p&gt;这种问题的答案当然是具体问题具体分析啦，单纯地回答谁好谁坏是没有意义的，我们需要结合实际场景给出合适的回答。&lt;/p&gt;
&lt;p&gt;考虑下面是两个场景，由此看出不同场景下我们关注的点是不一样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;地震的预测对于地震的预测，我们希望的是Recall非常高，也就是说每次地震我们都希望预测出来。这个时候我们可以牺牲Precision。情愿发出1000次警报，把10次地震都预测正确了；也不要预测100次对了8次漏了两次。所以我们可以设定在合理的precision下，最高的recall作为最优点，找到这个对应的threshold点。&lt;/li&gt;
&lt;li&gt;嫌疑人定罪基于不错怪一个好人的原则，对于嫌疑人的定罪我们希望是非常准确的。及时有时候放过了一些罪犯（Recall低），但也是值得的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ROC和PRC在模型性能评估上效果都差不多，但需要注意的是，在正负样本分布得极不均匀(highly skewed datasets)的情况下，PRC比ROC能更有效地反应分类器的好坏。在数据极度不平衡的情况下，譬如说1万封邮件中只有1封垃圾邮件，那么如果我挑出10封，50封，100...封垃圾邮件（假设我们每次挑出的N封邮件中都包含真正的那封垃圾邮件），Recall都是100%，但是FPR分别是9/9999, 49/9999, 99/9999（数据都比较好看：FPR越低越好），而Precision却只有1/10，1/50， 1/100 （数据很差：Precision越高越好）。所以在数据非常不均衡的情况下，看ROC的AUC可能是看不出太多好坏的，而PR curve就要敏感的多。&lt;/p&gt;
&lt;h2 id=&quot;iou&quot;&gt;IOU&lt;/h2&gt;
&lt;p&gt;上面讨论的是分类任务中的评价指标，这里想简单讲讲目标检测任务中常用的评价指标：IOU（Intersection over Union），中文翻译为交并比。&lt;/p&gt;
&lt;p&gt;这里是一个实际例子：下图绿色框是真实感兴趣区域，红色框是预测区域，这种情况下交集确实是最大的，但是红色框并不能准确预测物体位置。因为预测区域总是试图覆盖目标物体而不是正好预测物体位置。这时如果我们能除以一个并集的大小，就可以规避这种问题。这就是IOU要解决的问题了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204408601-1945220368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图表示了IOU的具体意义，即：预测框与标注框的交集与并集之比，数值越大表示该检测器的性能越好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204418589-582088419.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用IOU评价指标后，上面提到的问题一下子解决了：我们控制并集不要让并集太大，对准确预测是有益的，这就有效抑制了“一味地追求交集最大”的情况的发生。下图的2,3小图就是目标检测效果比较好的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204428523-871794088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 12:45:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8467613.html</dc:identifier>
</item>
<item>
<title>Redis Sentinel安装与部署，实现redis的高可用 - youzhibing2904</title>
<link>http://www.cnblogs.com/youzhibing/p/8466491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youzhibing/p/8466491.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　对于生产环境，高可用是避免不了要面对的问题，无论什么环境、服务，只要用于生产，就需要满足高可用；此文针对的是redis的高可用。&lt;/p&gt;
&lt;p&gt;　　接下来会有系列文章，该系列是对&lt;a href=&quot;http://www.cnblogs.com/youzhibing/p/7348337.html&quot; target=&quot;_blank&quot;&gt;spring-session实现分布式集群session的共享&lt;/a&gt;的完整阐述，同时也引伸出缓存的实现；而此篇是该系列的第一篇。&lt;/p&gt;
&lt;p&gt;　　github地址：&lt;a href=&quot;https://github.com/youzhibing/redis&quot; target=&quot;_blank&quot;&gt;https://github.com/youzhibing/redis&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;p&gt;　　redis版本：redis-3.0.0&lt;/p&gt;
&lt;p&gt;　　linux：centos6.7&lt;/p&gt;
&lt;p&gt;　　ip：192.168.11.202， 一台服务器上搭建搭建全部redis实例，包括数据节点实例以及哨兵(sentinel)实例&lt;/p&gt;
&lt;p&gt;　　客户端jedis，基于spring-boot&lt;/p&gt;
&lt;h2&gt;redis主从复制&lt;/h2&gt;
&lt;p&gt;　　搭建一主二从的主从环境&lt;/p&gt;
&lt;h3&gt;　　1、redis安装&lt;/h3&gt;
&lt;p&gt;　　　　安装很简单，网上资料很多，redis官网也有说明；主要就是3步：解压，make，make install&lt;/p&gt;
&lt;h3&gt;　　2、数据节点配置文件&lt;/h3&gt;
&lt;p&gt;　　　　redis解压后，redis home目录下有redis配置的样例文件，我们不直接在此文件上就行修改，在redis home目录下新建文件夹master_slave，将配置文件都放于此目录下&lt;/p&gt;
&lt;p&gt;　　　　master配置文件：redis-6379.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
port 6379&lt;span&gt;
bind &lt;/span&gt;192.168.11.202&lt;span&gt;
requirepass &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;6379.log&quot;&lt;span&gt;
dbfilename &lt;/span&gt;&quot;dump-6379.rdb&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;

#如若master设置了认证密码，那么所有redis数据节点都配置上masterauth属性
masterauth &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　slave-1配置文件：redis-6380.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
port 6380&lt;span&gt;
bind &lt;/span&gt;192.168.11.202&lt;span&gt;
requirepass &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;6380.log&quot;&lt;span&gt;
dbfilename &lt;/span&gt;&quot;dump-6380.rdb&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;

#如若master设置了认证密码，那么所有redis数据节点都配置上masterauth属性
masterauth &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
slaveof &lt;/span&gt;192.168.11.202 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　slave-2配置文件：redis-6381.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
port 6381&lt;span&gt;
bind &lt;/span&gt;192.168.11.202&lt;span&gt;
requirepass &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;6381.log&quot;&lt;span&gt;
dbfilename &lt;/span&gt;&quot;dump-6381.rdb&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;

#如若master设置了认证密码，那么所有redis数据节点都配置上masterauth属性
masterauth &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
slaveof &lt;/span&gt;192.168.11.202 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、节点启动&lt;/h3&gt;
&lt;p&gt;　　　　如下相关路径需要根据自己的情况进行改动，可能和我的不一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# cd /opt/redis-3.0.0/master_slave/&lt;span&gt;
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-server redis-6379&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-server redis-6380&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-server redis-6381.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　确认主从关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6379 -&lt;span&gt;a myredis info replication
# Replication
role:master
connected_slaves:&lt;/span&gt;2&lt;span&gt;
slave0:ip&lt;/span&gt;=192.168.11.202,port=6380,state=online,offset=393,lag=0&lt;span&gt;
slave1:ip&lt;/span&gt;=192.168.11.202,port=6381,state=online,offset=393,lag=0&lt;span&gt;
master_repl_offset:&lt;/span&gt;393&lt;span&gt;
repl_backlog_active:&lt;/span&gt;1&lt;span&gt;
repl_backlog_size:&lt;/span&gt;1048576&lt;span&gt;
repl_backlog_first_byte_offset:&lt;/span&gt;2&lt;span&gt;
repl_backlog_histlen:&lt;/span&gt;392
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　还可以从从节点视角来看：[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6380 -a myredis info replication&lt;/p&gt;
&lt;p&gt;　　如若进行顺利，按如上配置，一主二从环境搭建完毕&lt;/p&gt;
&lt;h3&gt;　　4、从节点作用&lt;/h3&gt;
&lt;p&gt;　　　　主要两个作用：1、作为主节点的一个备份，一旦主节点出现故障，从节点可以作为后备&quot;顶&quot;上来，并且保证数据尽量不丢失（主从复制是最终一致性）；2、从节点可以拓展主节点的能力，一旦主节点不能支撑大并发的读操作，从节点可以在一定程度上帮助主节点分担读压力&lt;/p&gt;
&lt;h3&gt;　　5、主从复制问题&lt;/h3&gt;
&lt;p&gt;　　　　1、一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程需要人工干预&lt;/p&gt;
&lt;p&gt;　　　　2、主节点的写能力受到单机的限制&lt;/p&gt;
&lt;p&gt;　　　　3、主节点的存储能力受到单机的限制&lt;/p&gt;
&lt;h2&gt;redis sentinel部署&lt;/h2&gt;
&lt;p&gt;　　此片主要讲通过sentinel解决上述问题1，问题2、3则在下篇博客进行说明&lt;/p&gt;
&lt;h3&gt;　　1、3个sentinel节点的配置文件基本一致，区别的只是端口&lt;/h3&gt;
&lt;p&gt;　　　　sentinel-26379.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 26379&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;26379.log&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;
sentinel monitor mymaster &lt;/span&gt;192.168.11.202 6380 2&lt;span&gt;
#redis数据master节点设置了认证，则需要如下配置
sentinel auth&lt;/span&gt;-&lt;span&gt;pass mymaster myredis
sentinel down&lt;/span&gt;-after-milliseconds mymaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs mymaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout mymaster 180000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　sentinel-26380.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 26380&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;26379.log&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;
sentinel monitor mymaster &lt;/span&gt;192.168.11.202 6380 2&lt;span&gt;
#redis数据master节点设置了认证，则需要如下配置
sentinel auth&lt;/span&gt;-&lt;span&gt;pass mymaster myredis
sentinel down&lt;/span&gt;-after-milliseconds mymaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs mymaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout mymaster 180000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　sentinel-26381.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 26381&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;26379.log&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;
sentinel monitor mymaster &lt;/span&gt;192.168.11.202 6380 2&lt;span&gt;
#redis数据master节点设置了认证，则需要如下配置
sentinel auth&lt;/span&gt;-&lt;span&gt;pass mymaster myredis
sentinel down&lt;/span&gt;-after-milliseconds mymaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs mymaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout mymaster 180000
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、启动sentinel&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-sentinel sentinel-26379&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-sentinel sentinel-26380&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-sentinel sentinel-26381.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、sentinel确认&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 26379&lt;span&gt; info Sentinel
# Sentinel
sentinel_masters:&lt;/span&gt;1&lt;span&gt;
sentinel_tilt:&lt;/span&gt;0&lt;span&gt;
sentinel_running_scripts:&lt;/span&gt;0&lt;span&gt;
sentinel_scripts_queue_length:&lt;/span&gt;0&lt;span&gt;
master0:name&lt;/span&gt;=mymaster,status=ok,address=192.168.11.202:6379,slaves=2,sentinels=3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Redis  Sentinel 最终拓扑结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224202458889-1076709938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　4、高可用测试&lt;/h3&gt;
&lt;p&gt;　　　　手动停掉6379实例或者kill掉6379实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6379 -&lt;span&gt;a myredis
&lt;/span&gt;192.168.11.202:6379&amp;gt; shutdown
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　查看26379.log&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224185113303-44074682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　master节点已经自动切换到192.168.11.202:6380了，重启6379，6379则是6378的从节点了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6380 -&lt;span&gt;a myredis
&lt;/span&gt;192.168.11.202:6380&amp;gt;&lt;span&gt; info replication
# Replication
role:master
connected_slaves:&lt;/span&gt;2&lt;span&gt;
slave0:ip&lt;/span&gt;=192.168.11.202,port=6381,state=online,offset=80802,lag=1&lt;span&gt;
slave1:ip&lt;/span&gt;=192.168.11.202,port=6379,state=online,offset=80802,lag=1&lt;span&gt;
master_repl_offset:&lt;/span&gt;80945&lt;span&gt;
repl_backlog_active:&lt;/span&gt;1&lt;span&gt;
repl_backlog_size:&lt;/span&gt;1048576&lt;span&gt;
repl_backlog_first_byte_offset:&lt;/span&gt;2&lt;span&gt;
repl_backlog_histlen:&lt;/span&gt;80944　
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;客户端（Jedis）连接&lt;/h2&gt;
&lt;p&gt;　　基于spring-boot开发，spring-boot-test测试， 这两者本文不做说明，网上资料很多，不熟悉的自行去补充； 工程结构如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224190204996-1522466455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3f45f652-f5ff-4250-976b-02c6297ebdde&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3f45f652-f5ff-4250-976b-02c6297ebdde&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3f45f652-f5ff-4250-976b-02c6297ebdde&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.lee&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;redis&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.9.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;!-- 日志过滤器 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.codehaus.janino&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;janino&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　redis-sentinel.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_b8989f92-9eb9-4962-af0f-59dfbf51a9fe&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b8989f92-9eb9-4962-af0f-59dfbf51a9fe&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b8989f92-9eb9-4962-af0f-59dfbf51a9fe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
redis.masterName=&lt;span&gt;mymaster
redis.sentinels&lt;/span&gt;=192.168.11.202:26379,192.168.11.202:26380,192.168.11.202:26381&lt;span&gt;
redis.timeout&lt;/span&gt;=10000&lt;span&gt;
#连接master需要用到的密码，如果redis数据节点开启了连接认证
redis.password&lt;/span&gt;=&lt;span&gt;myredis

# 连接池
# 连接池最大连接数（使用负值表示没有限制）
redis.pool.maxActive&lt;/span&gt;=150&lt;span&gt;
# 连接池中的最大空闲连接
redis.pool.maxIdle&lt;/span&gt;=10&lt;span&gt;
# 连接池中的最小空闲连接
redis.pool.minIdle&lt;/span&gt;=1&lt;span&gt;
# 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认&lt;/span&gt;-1&lt;span&gt;
redis.pool.maxWaitMillis&lt;/span&gt;=3000&lt;span&gt;
# 每次释放连接的最大数目
redis.pool.numTestsPerEvictionRun&lt;/span&gt;=50&lt;span&gt;
# 释放连接的扫描间隔（毫秒）
redis.pool.timeBetweenEvictionRunsMillis&lt;/span&gt;=3000&lt;span&gt;
# 连接最小空闲时间（毫秒）
redis.pool.minEvictableIdleTimeMillis&lt;/span&gt;=1800000&lt;span&gt;
# 连接空闲多久后释放, 当空闲时间&lt;/span&gt;&amp;gt;该值 且 空闲连接&amp;gt;&lt;span&gt;最大空闲连接数 时直接释放（毫秒）
redis.pool.softMinEvictableIdleTimeMillis&lt;/span&gt;=10000&lt;span&gt;
# 在获取连接的时候检查有效性, 默认false
redis.pool.testOnBorrow&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 在空闲时检查有效性, 默认false
redis.pool.testWhileIdle&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 在归还给pool时，是否提前进行validate操作
redis.pool.testOnReturn&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true
redis.pool.blockWhenExhausted&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　RedisConfig.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_49540c68-8672-4578-8549-54ced71e0bca&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_49540c68-8672-4578-8549-54ced71e0bca&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_49540c68-8672-4578-8549-54ced71e0bca&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lee.redis.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.PropertySource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisPoolConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisSentinelPool;

@Configuration
@PropertySource(&lt;/span&gt;&quot;redis/redis-sentinel.properties&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisConfig {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(RedisConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @Value(&lt;/span&gt;&quot;${redis.masterName}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String masterName;
    @Value(&lt;/span&gt;&quot;${redis.sentinels}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sentinels;
    @Value(&lt;/span&gt;&quot;${redis.timeout}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; timeout;
    @Value(&lt;/span&gt;&quot;${redis.password}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    
    @Value(&lt;/span&gt;&quot;${redis.pool.maxActive}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxTotal;

    @Value(&lt;/span&gt;&quot;${redis.pool.maxIdle}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxIdle;

    @Value(&lt;/span&gt;&quot;${redis.pool.minIdle}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; minIdle;

    @Value(&lt;/span&gt;&quot;${redis.pool.maxWaitMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxWaitMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.numTestsPerEvictionRun}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numTestsPerEvictionRun;

    @Value(&lt;/span&gt;&quot;${redis.pool.timeBetweenEvictionRunsMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeBetweenEvictionRunsMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.minEvictableIdleTimeMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; minEvictableIdleTimeMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.softMinEvictableIdleTimeMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; softMinEvictableIdleTimeMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.testOnBorrow}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; testOnBorrow;

    @Value(&lt;/span&gt;&quot;${redis.pool.testWhileIdle}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; testWhileIdle;

    @Value(&lt;/span&gt;&quot;${redis.pool.testOnReturn}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; testOnReturn;

    @Value(&lt;/span&gt;&quot;${redis.pool.blockWhenExhausted}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; blockWhenExhausted;
    
    @SuppressWarnings({ &lt;/span&gt;&quot;unchecked&quot;, &quot;rawtypes&quot;&lt;span&gt; })
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JedisSentinelPool jedisSentinelPool(JedisPoolConfig poolConfig) {
        LOGGER.info(&lt;/span&gt;&quot;sentinel set : {}&quot;&lt;span&gt;, sentinels);
        Set sentinelSet &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet(Arrays.asList(sentinels.split(&quot;,&quot;&lt;span&gt;)));
        JedisSentinelPool jedisPool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisSentinelPool(masterName, sentinelSet, poolConfig, timeout, password);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jedisPool;
    }
    
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JedisPoolConfig jedisPoolConfig() {
        JedisPoolConfig jedisPoolConfig &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(maxTotal);
        jedisPoolConfig.setMaxIdle(maxIdle);
        jedisPoolConfig.setMinIdle(minIdle);
        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);
        jedisPoolConfig.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
        jedisPoolConfig
                .setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        jedisPoolConfig
                .setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        jedisPoolConfig
                .setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);
        jedisPoolConfig.setTestOnBorrow(testOnBorrow);
        jedisPoolConfig.setTestWhileIdle(testWhileIdle);
        jedisPoolConfig.setTestOnReturn(testOnReturn);
        jedisPoolConfig.setBlockWhenExhausted(blockWhenExhausted);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jedisPoolConfig;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　Application.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ca24ef0a-e6da-46c7-9020-9bf5965385b1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ca24ef0a-e6da-46c7-9020-9bf5965385b1&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ca24ef0a-e6da-46c7-9020-9bf5965385b1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lee.redis;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.Banner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.EnableAutoConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

@Configuration
@EnableAutoConfiguration
@ComponentScan
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        SpringApplication app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SpringApplication(Application.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        app.setBannerMode(Banner.Mode.OFF);            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否打印banner
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; app.setApplicationContextClass();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定spring应用上下文启动类&lt;/span&gt;
        app.setWebEnvironment(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        app.run(args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　RedisTest.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_cf455dd6-3923-431b-81c6-2d3e4837fbcf&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cf455dd6-3923-431b-81c6-2d3e4837fbcf&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cf455dd6-3923-431b-81c6-2d3e4837fbcf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lee.redis;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.test.context.SpringBootTest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringRunner;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.Jedis;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisSentinelPool;

@RunWith(SpringRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest(classes &lt;/span&gt;= Application.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisTest {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(RedisTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JedisSentinelPool sentinelPool;
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getNameTest() {
        Jedis jedis &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            jedis &lt;/span&gt;=&lt;span&gt; sentinelPool.getResource();
            String name &lt;/span&gt;= jedis.get(&quot;name&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;name is &quot; +&lt;span&gt; name);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e) {
            LOGGER.error(e.getMessage(), e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jedis != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                jedis.close();
            }
        }
        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　更多详情请上我的github&lt;/p&gt;
&lt;p&gt;　　运行RedisTest.java的getNameTest方法（name属性已经在redis中设置，没设置的需要提前设置），得到结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224190848962-1545756249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;注意点&lt;/h2&gt;
&lt;p&gt;　　1、有人可能会有这样的疑问：为什么通过sentinel来获取redis的连接，而不是直接连接master来获取redis连接呢？&lt;/p&gt;
&lt;p&gt;　　　　试想一下，客户端直接通过master节点获取redis连接，如果master节点挂掉了，虽然Redis Sentinel可以完成故障转移，但是客户端无法获取这个变化，那么客户端就无法获取redis连接了；&lt;/p&gt;
&lt;p&gt;　　　　最了解master节点信息的就是Sentinel节点集合，所以通过sentinel来获取redis连接就能满足高可用的要求了。&lt;/p&gt;
&lt;p&gt;　　2、redis master的故障转移不影响客户端连接代码， 但是转移期间内，通过sentinel是获取不到主节点的连接的， 因为转移期间内master节点还没被选举出来；&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;　　《Redis开发与运维》&lt;/p&gt;
&lt;p&gt;　　http://www.redis.cn/topics/sentinel.html&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 12:40:00 +0000</pubDate>
<dc:creator>youzhibing2904</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youzhibing/p/8466491.html</dc:identifier>
</item>
<item>
<title>.NET Core UI框架Avalonia - LineZero</title>
<link>http://www.cnblogs.com/linezero/p/Avalonia.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linezero/p/Avalonia.html</guid>
<description>&lt;p&gt;.NET Core UI框架Avalonia，Avalonia是一个基于WPF XAML的跨平台UI框架，并支持多种操作系统：Windows（.NET Framework，.NET Core），Linux（GTK），MacOS，Android和iOS。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Avalonia目前处于测试阶段。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;GitHub:https://github.com/AvaloniaUI/Avalonia&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;开发准备&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;VS 2017安装扩展 https://marketplace.visualstudio.com/items?itemName=AvaloniaTeam.AvaloniaforVisualStudio&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后就可以开发项目&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/443844/201802/443844-20180224180609352-1238142874.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择 Avalonia Application ，就可以创建一个项目，默认有两个会创建两个框架.NET Framework 4.6.1和.NET Core 2.0。&lt;/p&gt;
&lt;p&gt;在项目中可以创建&lt;strong&gt;Window 和&lt;/strong&gt;&lt;strong&gt;UserControl。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;示例UI项目&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;新建一个基础项目myapp，将MainWindow.xaml 添加几个按钮，就是WPF XAML 的语法，直接可以实现对应布局。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;Window xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://github.com/avaloniaui&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        xmlns:x&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://schemas.microsoft.com/winfx/2006/xaml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        Title&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myapp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;Grid Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;800&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;StackPanel Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

        &amp;lt;Button Content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Button1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;

        &amp;lt;Button Content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Button2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;

        &amp;lt;Button Content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Button3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;TextBox Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LineZero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/TextBox&amp;gt;

      &amp;lt;/StackPanel&amp;gt;
    &amp;lt;/Grid&amp;gt;
  &amp;lt;/Window&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后台对应代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainWindow : Window
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainWindow()
        {
            InitializeComponent();
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; DEBUG
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.AttachDevTools();
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeComponent()
        {
            AvaloniaXamlLoader.Load(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.FindControl&amp;lt;Button&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Click +=&lt;span&gt; Btn1_Click;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Btn1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, Avalonia.Interactivity.RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; txt = &lt;span&gt;this&lt;/span&gt;.FindControl&amp;lt;TextBox&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            txt.FontFamily &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微软雅黑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            txt.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LineZero 按钮1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/443844/201802/443844-20180224182922729-353504662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下中文显示有点问题，设置字体既可。&lt;/p&gt;
&lt;p&gt;不同系统的支持安装： https://github.com/AvaloniaUI/Avalonia/wiki/Platform-support&lt;/p&gt;

&lt;h2 class=&quot;public&quot;&gt;&lt;span&gt;AvalonStudio&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;目前Avalonia 比较成熟的一个方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/443844/201802/443844-20180224200458306-619585410.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;GitHub: https://github.com/VitalElement/AvalonStudio&lt;/p&gt;
&lt;p&gt;目前官方介绍是有对应功能，实际操作有些缺少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/443844/201802/443844-20180224201102832-295572183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AvaloniaEdit.Demo 也是还算不错的示例。&lt;/p&gt;
&lt;p&gt;GitHub: https://github.com/AvaloniaUI/AvaloniaEdit&lt;/p&gt;
&lt;p&gt;可以查看官方文档：http://avaloniaui.net/guides/   .NET Core 未来更加好。&lt;/p&gt;

</description>
<pubDate>Sat, 24 Feb 2018 12:15:00 +0000</pubDate>
<dc:creator>LineZero</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linezero/p/Avalonia.html</dc:identifier>
</item>
<item>
<title>GO开发：接口 - 宁生信</title>
<link>http://www.cnblogs.com/gregoryli/p/8467385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/8467385.html</guid>
<description>&lt;h2 id=&quot;接口定义&quot;&gt;接口定义&lt;/h2&gt;
&lt;p&gt;Interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type example interface{
        Method1(参数列表) 返回值列表
        Method2(参数列表) 返回值列表
        …
        var a example
        a.Method1()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;interface类型默认是一个指针&lt;/p&gt;
&lt;h2 id=&quot;接口实现&quot;&gt;接口实现：&lt;/h2&gt;
&lt;p&gt;a. Golang中的接口，不需要显示的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。因此，golang中没有implement类似的关键字&lt;/p&gt;
&lt;p&gt;b. 如果一个变量含有了多个interface类型的方法，那么这个变量就实现了多个接口。&lt;/p&gt;
&lt;p&gt;c.如果一个变量只含有了1个interface的方部分方法，那么这个变量没有实现这个接口。&lt;/p&gt;
&lt;h2 id=&quot;接口嵌套&quot;&gt;接口嵌套&lt;/h2&gt;
&lt;p&gt;一个接口可以嵌套在另外的接口，如下所示&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt; &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; ReadWrite &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; {
               Read(b Buffer) &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;
               Write(b Buffer) &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;
} 
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Lock &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; {
               Lock()
               Unlock() 
} 
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; File &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; {
               ReadWrite
               Lock 
               Close() 
} &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Reader &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; {
   Read()
}

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Writer &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; {
   Write()
}

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; ReadWriter &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; {
   Reader
   Writer
}

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; File &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; {
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (f *File) Read() {
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;read data&quot;&lt;/span&gt;)
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (f *File) Write() {
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;write data&quot;&lt;/span&gt;)
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; Test(rw ReadWriter) {
   rw.Read()
   rw.Write()
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; f *File
   Test(f)

   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}
   b = f
   v, ok := b.(ReadWriter)
   fmt.Println(v, ok)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;类型断言&quot;&gt;类型断言&lt;/h2&gt;
&lt;p&gt;由于接口是一般类型，不知道具体类型，如果要转成具体类型，可以采用以下方法进行转换：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;var t int&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;var x interface{}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;x = t&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;y = x.(int)   //转成int&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;var t int&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;var x interface{}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;x = t&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;y, ok = x.(int)   //转成int，带检查&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Student &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; {
    Name &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;
    Sex  &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; Test(a &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}) {
    b, ok := a.(Student)
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ok == &lt;span class=&quot;ot&quot;&gt;false&lt;/span&gt; {
        fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;convert failed&quot;&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
    }
    &lt;span class=&quot;co&quot;&gt;//b += 3&lt;/span&gt;
    fmt.Println(b)
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main()  {
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
    a = b
    c := a.(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)
    fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%d %T&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,a,a)
    fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%d %T&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,b,b)
    fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%d %T&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,c,c)

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; st Student = Student{
        Name: &lt;span class=&quot;st&quot;&gt;&quot;stu01&quot;&lt;/span&gt;,
        Sex:  &lt;span class=&quot;st&quot;&gt;&quot;female&quot;&lt;/span&gt;,
    }
    Test(st)
    fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%T&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,st)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类型断言，采用type switch方式&lt;/p&gt;
&lt;p&gt;空接口Interface{}&lt;/p&gt;
&lt;p&gt;nterface{}，接口中一个方法也没有，所以任何类型都实现了空接口，也就是任何变量都可以赋值给空接口。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}
b  = a&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断一个变量是否实现了指定接口&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt; &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Stringer &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; {
        String() &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; 
}
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; v MyStruct
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; sv, ok := v.(Stringer); ok {
       fmt.Printf(“v implements String(): %s\n”, sv.String()); 
} &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现一个通用的链表类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; LinkNode &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; {
   data &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}
   next *LinkNode
}

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Link &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; {
   head *LinkNode
   tail *LinkNode
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (p *Link) InsertHead(data &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}) {
   node := &amp;amp;LinkNode{
      data: data,
      next: &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt;,
   }

   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; p.tail == &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; p.head == &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
      p.tail = node
      p.head = node
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
   }

   node.next = p.head
   p.head = node
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (p *Link) InsertTail(data &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}) {
   node := &amp;amp;LinkNode{
      data: data,
      next: &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt;,
   }

   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; p.tail == &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; p.head == &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
      p.tail = node
      p.head = node
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
   }

   p.tail.next = node
   p.tail = node
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (p *Link) Trans() {
   q := p.head
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; q != &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
      fmt.Println(q.data)
      q = q.next
   }
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; link Link
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++ {
      &lt;span class=&quot;co&quot;&gt;//intLink.InsertHead(i)&lt;/span&gt;
      link.InsertTail(fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;str %d&quot;&lt;/span&gt;, i))
   }
   link.Trans()
}      &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 24 Feb 2018 10:56:00 +0000</pubDate>
<dc:creator>宁生信</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/8467385.html</dc:identifier>
</item>
<item>
<title>点堆中子动力学方程求解程序 - ik-heu</title>
<link>http://www.cnblogs.com/ik-heu/p/8331794.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ik-heu/p/8331794.html</guid>
<description>&lt;p&gt;我学的是核科学与技术专业，本科和硕士期间写了不少程序，如计算堆芯中子动力学的，计算流体力学的。但多数仅针对具体问题，通用性有些不足。硕士修了一门仿真技术的课程，我的作业是求解点堆中子动力学程序，靠这个还拿了优秀。觉得这个程序还蛮通用的，对于同专业的搞个大作业，或用于毕设等或许有帮助。&lt;/p&gt;
&lt;p&gt;详细的推导、验证过程、程序代码见：&lt;a href=&quot;https://github.com/ikheu/point_reactor&quot; target=&quot;_blank&quot;&gt;https://github.com/ikheu/point_reactor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1、概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;计算中子通量密度的瞬变特性，对反应堆动力系统的运行安全分析与仿真而言十分重要。点堆中子动力学模型是反应堆动态学中最常用的方法。&lt;/p&gt;
&lt;p&gt;点堆中子动力学模型描述了中子密度和缓发中子先驱核浓度随时间变化的规律，基本方程如式（1）所示。由于瞬发中子寿命与缓发中子寿命间存在着数量级的差别，耦合的点堆动力学微分方程组存在着刚性，这给数值求解带来了一定困难。常规的显式方法，如欧拉法、龙格库塔法在计算该问题时会存在稳定性问题，这要求时间步长需取得很小，会带来计算耗时以及大的累计误差。针对点堆动力学方程组的刚性问题，发展了许多种处理方法，包括：（1）线性多步法，如GEAR算法及其改进形式；（2）基于积分方程的方法，如Hansen方法；（3）分段多项式逼近法，如埃尔米特插值型；（4）权重限制法；（5）指数基函数法等。 &lt;/p&gt;
&lt;p&gt;$\left\{ \begin{gathered}&lt;br/&gt;\frac{{dn(t)}}{{dt}} = \frac{{\rho (t) - \beta }}{\Lambda }n(t) + \sum\limits_{i = 1}^I {{\lambda _i}{C_i}(t)} + q \hfill \\&lt;br/&gt;\frac{{d{C_i}(t)}}{{dt}} = \frac{{{\beta _i}}}{\Lambda }n(t) - {\lambda _i}{C_i}(t){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} i = 1,2,...,I \hfill \\ &lt;br/&gt;\end{gathered} \right.　　　　　　　　　　　　　　　　　(1)$&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;式中，${n(t)}$为中子密度； &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         ${{C_i}(t)}$为第i组缓发中子先驱核的浓度；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         ${\rho (t)}$为反应性；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         $\Lambda$为中子代时间；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         ${{\lambda _i}}$为第i组缓发中子先驱核衰变常数；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         ${{\beta _i}}$为第i组缓发中子份额；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         $\beta$为缓发中子的总份额；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         $q$为外加中子源项。&lt;/p&gt;
&lt;p&gt;本文使用一阶泰勒多项式积分方法求解点堆动力学方程，该方法能很好地解决方程的刚性问题，具有计算精度高、适用性好的特点。文章内容包括：探讨点堆方程的刚性问题；给出一阶泰勒多项式积分方法的推导过程及计算流程；编制计算程序，完成计算验证与相关讨论。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2 一阶泰勒多项式积分方法&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;详细的推导过程有些繁琐，这里只说明其中两个关键的步骤。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一个是积分处理。合并式(1)，并在$\left[ {{t_n},{t_{n + 1}}} \right]$区间内积分，可获得式（2）：&lt;/p&gt;
&lt;p&gt;$n({t_{n + 1}}) - n({t_n}) = \int_{{t_n}}^{{t_{n + 1}}} {\frac{{\rho (t)}}{\Lambda }n(t)}  - \sum\limits_{i = 1}^6 {[{C_i}({t_{n + 1}}) - {C_i}({t_n})]}  + q \cdot h　　　　　　　　　　　　　　(2)$&lt;/p&gt;
&lt;p&gt;第二个是对中子密度作一阶泰勒展开：&lt;/p&gt;
&lt;p&gt;$n(\tau ) = n({t_{n + 1}}) + {n^,}({t_{n + 1}})(\tau  - {t_{n + 1}})　　　　　　　　　　　　　　　　　　　　(3)$&lt;/p&gt;
&lt;p&gt;经过一系列的推导，可获得中子密度的表达式：&lt;/p&gt;
&lt;p&gt;$n({t_{n + 1}}) = \frac{{n({t_n}) + q \cdot h + \sum\limits_{i = 1}^6 {{C_i}({t_n})}  - \sum\limits_{i = 1}^6 {\exp ( - {\lambda _i}h){C_i}({t_n})}  + \frac{{({F_2} - \sum\limits_{i = 1}^6 {\frac{{{\beta _i}}}{\Lambda }{G_{2,i}})} (\sum\limits_{i = 1}^6 {{\lambda _i}\exp ( - {\lambda _i}h){C_i}({t_n})}  + q)}}{{(1 - \sum\limits_{i = 1}^6 {\frac{{{\lambda _i}{\beta _i}}}{\Lambda }{G_{2,i}}} )}}}}{{1 - {F_1} + \sum\limits_{i = 1}^6 {\frac{{{\beta _i}}}{\Lambda }{G_{1,i}}}  - ({F_2} - \sum\limits_{i = 1}^6 {\frac{{{\beta _i}}}{\Lambda }{G_{2,i}})} (\frac{{\rho ({t_{n + 1}}) - \beta }}{\Lambda } + \sum\limits_{i = 1}^6 {\frac{{{\lambda _i}{\beta _i}}}{\Lambda }{G_{1,i}}} )/(1 - \sum\limits_{i = 1}^6 {\frac{{{\lambda _i}{\beta _i}}}{\Lambda }{G_{2,i}}} )}}　　　　　　　　　　　　　(4)$&lt;/p&gt;
&lt;p&gt;截断误差是该方法的主要误差来源，可考虑更高阶数的泰勒展开，当然这会使模型更加复杂（上式已经很复杂了），求解过程也不够简便。&lt;/p&gt;
&lt;p&gt;下图为本方法的计算流程图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285395/201802/1285395-20180224142837144-142159375.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先给出初始条件，即${t_n} = 0$时的${n(t)}$、 ${{C_i}(t)}$，确定已知项${\rho (t)}$、 ${{\lambda _i}}$、${{\beta _i}}$、$q$等；然后给定计算条件：计算时长与时间步长；逐时刻依次计算下一时刻${t_{n + 1}} = {t_n} + \Delta t$ 时的$n({t_{n + 1}})$、${n^,}({t_{n + 1}})$与${C_i}({t_{n + 1}})$，直至达到设置的计算时间。&lt;/p&gt;
&lt;p&gt;认为反应堆初始状态是稳定的，给定初始的中子密度$n(0)$，根据式（1）可得：&lt;/p&gt;
&lt;p&gt;$\frac{{d{C_i}(t)}}{{dt}} = 0{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  \Rightarrow {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {C_i}(0) = \frac{{{\beta _i}}}{{{\lambda _i}\Lambda }}n(0)　　　　　　　　　　　　　　　　　　　　(5)$&lt;/p&gt;
&lt;p&gt;使用老掉牙的Fortran90程序编制的计算程序，博客里甚至没有这个语言的着色，IT行业估计也没人用这个，所以代码就不贴了。可以在文章开头的github链接里找到。 &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3 计算结果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这里给出了四种反应性引入，包括正反应性阶跃、负反应性阶跃、反应性线性变化、反应性正弦变化情形下，典型热中子堆的中子密度响应曲线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285395/201802/1285395-20180224145440113-1915541110.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; github链接中有个“&lt;a id=&quot;07e988fd28900da87dd216c42bcf250f-bfe4cf968e68cd14cecb2b43a33eb7ef44d02853&quot; class=&quot;js-navigation-open&quot; title=&quot;点堆模型与求解.pdf&quot; href=&quot;https://github.com/ikheu/point_reactor/blob/master/%E7%82%B9%E5%A0%86%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B1%82%E8%A7%A3.pdf&quot;&gt;点堆模型与求解.pdf&lt;/a&gt;”的文件，可以在其中找到计算结果与解析解的比较和分析。计算程序还适用于快中子堆的求解。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 10:48:00 +0000</pubDate>
<dc:creator>ik-heu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ik-heu/p/8331794.html</dc:identifier>
</item>
<item>
<title>ThreadLocal源码解析 - Yrion</title>
<link>http://www.cnblogs.com/wyq178/p/8414719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq178/p/8414719.html</guid>
<description>&lt;p&gt;本篇博客的目录：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：ThreadLocal的简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：ThreadLocal源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：ThreadLocal实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四：总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一：ThreadLocal的简介&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1:简单解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      ThrealLocal望文生义，简单解释就是线程的本地变量。我们来看一下jdk对它的定义：&lt;strong&gt;该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 &lt;tt&gt;get&lt;/tt&gt; 或 &lt;tt&gt;set&lt;/tt&gt; 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。&lt;tt&gt;ThreadLocal&lt;/tt&gt; 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。&lt;/strong&gt;从这段解释中可以看出它是实现线程安全的一种新的方式，不同于以前加锁synchronized的方式,每个线程都有自己的独立的变量，这样他们之间是互不影响的，这样就间接的解决线程安全的问题。举个通俗的例子，相当于由以前的贫穷年代，大家哄抢一块蛋糕，到现在的物质丰盛年代，每个人都有一块自己的蛋糕，大家互不影响，就不会存在争抢的情况。&lt;/p&gt;
&lt;p&gt;1.2:&lt;strong&gt;ThreadLocal的方法摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从jdk看ThreadLocal向外暴露出基本的增删改查方法，几个方法都是很简单，通过get和set方法是访问和修改的入口，再通过initialValue进行初始化值和remove方法移除值。&lt;/p&gt;
&lt;table summary=&quot;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;&lt;tbody readability=&quot;3.641196013289&quot;&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;1.9090909090909&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;span&gt;&lt;code&gt;&lt;a title=&quot;ThreadLocal 中的类型参数&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a&gt;get&lt;/a&gt;&lt;/strong&gt;()&lt;/code&gt;&lt;br/&gt;返回此线程局部变量的当前线程副本中的值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;1.6543209876543&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;span&gt;&lt;code&gt;&lt;a title=&quot;ThreadLocal 中的类型参数&quot;&gt; &lt;/a&gt;&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a&gt;initialValue&lt;/a&gt;&lt;/strong&gt;()&lt;/code&gt;&lt;br/&gt;返回此线程局部变量的当前线程的“初始值”。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;1.8&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt; &lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a&gt;remove&lt;/a&gt;&lt;/strong&gt;()&lt;/code&gt;&lt;br/&gt;移除此线程局部变量当前线程的值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;1.9120879120879&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt; &lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a&gt;set&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;ThreadLocal 中的类型参数&quot;&gt;T&lt;/a&gt; value)&lt;/code&gt;&lt;br/&gt;将此线程局部变量的当前线程副本中的值设置为指定值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;二：&lt;strong&gt;ThreadLocal的源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1:误解读之处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人以为ThreadLocal的内部维持了一个map，其中以当前线程作为键，传入的数据作为值来进行封装的，这个想法是&lt;strong&gt;错误&lt;/strong&gt;的。&lt;strong&gt;ThreadLocal的内部维护着一个叫做ThreadLocalmap的静态类，它由一个首位闭合的动态数组组成（默认大小为16），每个数组都是一个Entry对象，该对象以ThreadLocal对象作为key，以传入的数据作为值作为值进行封装而成。&lt;/strong&gt;以下是TheadLocalMap的图示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1066538/201802/1066538-20180224142513040-912203924.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;2.2：&lt;strong&gt;关于Entry对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry &lt;span&gt;extends&lt;/span&gt; WeakReference&amp;lt;ThreadLocal&amp;gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用虚引用封装的ThreadLocal&lt;/span&gt;&lt;span&gt;
            Object value;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个值&lt;/span&gt;&lt;span&gt;
            Entry(ThreadLocal k, Object v) {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用ThreadLocal对象和值创建一个Entry&lt;/span&gt;
                &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(k);
                value &lt;/span&gt;=&lt;span&gt; v;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该对象继承自弱引用WeakReference,我们知道java中引用类分为4种，强度从大到小的排列顺序为：&lt;strong&gt;强引用、软引用、弱引用、虚引用&lt;/strong&gt;。这样做的最大好处就是可以方便GC处理&lt;/p&gt;
&lt;p&gt;其中关于弱引用：&lt;strong&gt; 具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以可以调用get方法获取对应的泛型值ThreadLocal，&lt;strong&gt;下面很多都会用到get方法，它来自于Reference类，返回T：为泛型引用类型&lt;/strong&gt;。ThreadLocal本身有一个构造方法，为TheadLocal和value。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1066538/201802/1066538-20180224155830940-478673197.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;2.2:&lt;strong&gt;几个重要方法解读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.2.1：get方法源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; T get() {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get方法&lt;/span&gt;
        Thread t = Thread.currentThread();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前的线程&lt;/span&gt;
        ThreadLocalMap map = getMap(t);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据线程获取线程本地的map&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果map不为null&lt;/span&gt;
            ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据threadlocal对象获取Entry&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果键值映射对象不为null&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; (T)e.value;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回获取它的值&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; setInitialValue();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果map里面为null 返回setInitialValue方法&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先是先获取当前运行的线程，再通过线程来获取ThreadLocalMap对象，我们来看一下getMap(Thread)这个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ThreadLocalMap getMap(Thread t) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据线程获取本地的map&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; t.threadLocals;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回线程的线程本地变量&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里就是通过Thread来间接引用ThreadLocal，再引用ThreadLocalMap，从而达到通过线程来获取ThreadLocalmap的目的。然后判断该map是否为null,不为null的情况下获取Entry对象，以下是getEntry对象的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; Entry getEntry(ThreadLocal key) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据ThreadLocal作为key键获取Entry&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据键的HashCode值与运算数组的长度-1获取一个位置&lt;/span&gt;
            Entry e = table[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到该位置上的节点对象&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == key)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该对象不为null并且通过get方法获取对应的值判断其是否等于传入的key&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果两个条件成立 返回该节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; getEntryAfterMiss(key, i, e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则调取getEntryAfterMiss方法&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出它考虑到了&lt;strong&gt;哈希碰撞&lt;/strong&gt;的情况,这个在HashMap源码分析篇也讲解过了，因为在遍历set值的时候考虑到哈希碰撞的问题（一个节点对应两个值），&lt;strong&gt;一般会取key的hashcode值和数组的长度-1（默认情况下是15）进行与运算,获取一个数组的位置，将其放入到该节点的位置。&lt;/strong&gt;这里相当是一个逆运算，省去了遍历的性能开销问题，直接取该节点上的值。当然还有getEntryAfterMiss方法是为了解决出现了hash碰撞的问题，以下是getEntryAfterMiss方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; Entry getEntryAfterMiss(ThreadLocal key, &lt;span&gt;int&lt;/span&gt; i, Entry e) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过hash直接找不到对应的值调用此方法&lt;/span&gt;
            Entry[] tab = table;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数组&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到数组的长度&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环直到节点Entry对象不为null&lt;/span&gt;
                ThreadLocal k = e.get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键值ThreadLocal&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (k == key)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果key值相同&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回该节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果key为null&lt;/span&gt;
                    expungeStaleEntry(i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调取exoungeStaleEntry方法&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    i &lt;/span&gt;= nextIndex(i, len);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点顺移&lt;/span&gt;
                e = tab[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取下一节点值赋给该节点&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则返回null&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法主要是相当于一个遍历（While循环）比较key来获取值的过程，从中可以看出ThreadLocalMap是允许键为null的，当键为null的情况下，调用expungeStaleEntry方法进行GC处理，便于垃圾回收器回收键为null的数组元素。&lt;/p&gt;
&lt;p&gt;2.2.2：&lt;strong&gt;set方法源码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(ThreadLocal key, Object value) {&lt;/span&gt;&lt;span&gt;
            Entry[] tab &lt;/span&gt;= table; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数组&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到数组的长度&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键值的hashCode与数组的长度-1进行与运算&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历循环整个数组&lt;/span&gt;
                 e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                 e &lt;/span&gt;= tab[i =&lt;span&gt; nextIndex(i, len)]) {
                ThreadLocal k &lt;/span&gt;= e.get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到键值&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果键和传入的键相同（也就是传入的key已经存在了）&lt;/span&gt;
                    e.value = value;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用新值覆盖旧值&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束该方法&lt;/span&gt;
&lt;span&gt;                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果键为null&lt;/span&gt;
                    replaceStaleEntry(key, value, i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用replaceStaleEntry方法&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束该方法&lt;/span&gt;
&lt;span&gt;                }
            }

            tab[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把传入的键和值进行构造新建Entry对象&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; sz = ++size;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size+1赋值为sz&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果数组中没有冗余的null值并且如果size大于临界值&lt;/span&gt;
                rehash();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩容重新hash&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当进行set值的时候，首先是计算键位（通过key的HashCode值和数组的长度-1进行与运算），然后检查数组中有没有和传入的key相同的键值，如果有的话就用新值覆盖掉旧值，然后结束该方法。如果key为null时，就调用replaceStaleEntry方法清除掉null值，两个情况都没的话，新构建一个Entry对象，放入到计算出的键位中，并且把数组的长度+1.再判断没有null值的情况下，并且数组的大小超过临界值了就进行重hash的操作：&lt;/p&gt;
&lt;p&gt;我们来看一下rehash的源码：可以看出是先进行处理Entry值，然后再进行重建size:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rehash() {
            expungeStaleEntries();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除不用的entry

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use lower threshold for doubling to avoid hysteresis&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / 4) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果size大于等于临界值-临界值的4分之一（这里相当于是12）&lt;/span&gt;
                resize();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩容&lt;/span&gt;
        } 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; expungeStaleEntries() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除不用的entry从而达到自动释放内存的目的&lt;/span&gt;
            Entry[] tab = table;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制整个数组&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; len = tab.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到数组的长度&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; len; j++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历循环整个数组&lt;/span&gt;
                Entry e = tab[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数组中的元素&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果元素不为null并且获取的键为null&lt;/span&gt;
                    expungeStaleEntry(j);&lt;span&gt;//调用&lt;/span&gt;&lt;/em&gt;expungeStaleEntry方法
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; } }&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expungeStaleEntry(&lt;span&gt;int&lt;/span&gt; staleSlot) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动释放内存&lt;/span&gt;
            Entry[] tab = table; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数组&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到数组的长度

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; expunge entry at staleSlot&lt;/span&gt;
            tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组的对应节点值设为nulll&lt;/span&gt;
            tab[staleSlot] = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组对应的节点设为null&lt;/span&gt;
            size--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组大小-1

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rehash until we encounter null&lt;/span&gt;
&lt;span&gt;            Entry e;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = nextIndex(staleSlot, len);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环遍历&lt;/span&gt;
                 (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                 i &lt;/span&gt;= nextIndex(i, len)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动到下一节点&lt;/span&gt;
                ThreadLocal k = e.get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果键不为null&lt;/span&gt;
                    e.value = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;value值不为null&lt;/span&gt;
                    tab[i] = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组节点的值设为null&lt;/span&gt;
                    size--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size-1&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (len - 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;键的hashcode值与数组长度-1进行与运算获取一个位置&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (h != i) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该位置不是下一节点&lt;/span&gt;
                        tab[i] = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组的元素设为null&lt;/span&gt;
                        &lt;span&gt;while&lt;/span&gt; (tab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//
&lt;/span&gt;                            h =&lt;span&gt; nextIndex(h, len);
                        tab[h] &lt;/span&gt;=&lt;span&gt; e;
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; resize() {
            Entry[] oldTab &lt;/span&gt;= table;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到旧数组&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; oldLen = oldTab.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到旧数组长度&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; newLen = oldLen * 2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;旧数组长度乘以2&lt;/span&gt;
            Entry[] newTab = &lt;span&gt;new&lt;/span&gt; Entry[newLen];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个数组 长度为旧数组的2倍&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; count = 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义count为0&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldLen; ++j) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历旧数组&lt;/span&gt;
                Entry e = oldTab[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取久数组的节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不为null&lt;/span&gt;
                    ThreadLocal k = e.get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键值&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果键为bull&lt;/span&gt;
                        e.value = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 值也设为null&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (newLen - 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过hashcode值计算键位&lt;/span&gt;
                        &lt;span&gt;while&lt;/span&gt; (newTab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;键位移动直到不为null&lt;/span&gt;
                            h =&lt;span&gt; nextIndex(h, newLen);
                        newTab[h] &lt;/span&gt;= e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给数据元素设值&lt;/span&gt;
                        count++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;count进行+1&lt;/span&gt;
&lt;span&gt;                    }
                }
            }

            setThreshold(newLen);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置临界值为新数组的长度&lt;/span&gt;
            size = count;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大小为count值&lt;/span&gt;
            table = newTab;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新数组替换过去的旧数组&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩容的过程是原来数组长度的2倍,也就是说现在是16，接下来就是32，再然后就是64...，再新建一个新Entry数组,把不为null的的元素放进去新数组，放入的位置为根据键的HashCode和长度-1进行与运算后的值，再接着遍历循环设置值。后面再把临界值扩大，size大小重设，维护的新数组重设就完成了&lt;/p&gt;
&lt;p&gt;2.2.3：&lt;strong&gt;remove方法源码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(ThreadLocal key) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据键移除对应的值&lt;/span&gt;
            Entry[] tab = table;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制整个数组&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到数组的长度&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据HashCode值计算键位&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历循环整个数组&lt;/span&gt;
                 e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                 e &lt;/span&gt;= tab[i =&lt;span&gt; nextIndex(i, len)]) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.get() == key) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果找到的值和键相同&lt;/span&gt;
                    e.clear();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用reference类中的clear方法将引用置为null&lt;/span&gt;
                    expungeStaleEntry(i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;除去不用的null值&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束该方法&lt;/span&gt;
&lt;span&gt;                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;remove方法是根据传入的ThreadLocal作为键，然后去计算键位，再从键位的下一个index值开始进行逐个遍历，直到找到的值和键相同，就调用reference的clear方法将引用置为null，并且清除无用的null值，然后结束该方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：ThreadLocal使用实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1：用ThreadLocal解决SimpleDateFormat的线程不安全的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   simpleDateFormate是一个线程不安全的格式化日期类,创建一个 SimpleDateFormat实例的开销比较昂贵，解析字符串时间时频繁创建生命周期短暂的实例导致性能低下。即使将 SimpleDateFormat定义为静态类变量，貌似能解决这个问题，但是SimpleDateFormat是非线程安全的，同样存在问题，如果用 ‘synchronized’线程同步同样面临问题，同步导致性能下降（线程之间序列化的获取SimpleDateFormat实例）。可以使用Threadlocal解决了此问题，对于每个线程SimpleDateFormat不存在影响他们之间协作的状态，为每个线程创建一个SimpleDateFormat变量的拷贝：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DateUtil {  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATE_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal threadLocal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadLocal(){  
          &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; Object initialValue() {  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(DATE_FORMAT);  
            }  
    };  
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DateFormat getDateFormat() {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (DateFormat) threadLocal.get();  
    }  
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Date parse(String textDate) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ParseException {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getDateFormat().parse(textDate);  
    }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;3.2：使用ThreadLocal实现数字自增&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AutoAddNumber {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; seqNum = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt;&lt;span&gt;() {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer initialValue() {

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }

    };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getNextNum() {

        seqNum.set(seqNum.get() &lt;/span&gt;+ 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; seqNum.get();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;线程类：TestThreadLocalThread维护一个AutoAddNumber引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestThreadLocalThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AutoAddNumber an;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestThreadLocalThread(AutoAddNumber an) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.an =&lt;span&gt; an;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {

            System.out.println(&lt;/span&gt;&quot;当前线程是：&quot; + Thread.currentThread().getName() + &quot;对应的编号是:&quot; +&lt;span&gt; an.getNextNum());
        }
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类，启动4个线程，每个线程在自己的run方法里循环遍历10次然后进行输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        AutoAddNumber an &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutoAddNumber();

        TestThreadLocalThread testThread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThreadLocalThread(an);

        TestThreadLocalThread testThread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThreadLocalThread(an);

        TestThreadLocalThread testThread3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThreadLocalThread(an);
        
        TestThreadLocalThread testThread4 &lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThreadLocalThread(an);

        testThread1.start();

        testThread2.start();

        testThread3.start();
        
        testThread4.start();

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
当前线程是：Thread-0对应的编号是:1&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:2&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:3&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:4&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:5&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:6&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:7&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:8&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:9&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-0对应的编号是:10&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:1&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:2&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:3&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:4&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:5&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:6&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:7&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:8&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:9&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-2对应的编号是:10&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:1&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:2&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:3&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:4&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:5&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:6&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:7&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:8&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:9&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-1对应的编号是:10&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:1&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:2&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:3&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:4&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:5&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:6&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:7&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:8&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:9&lt;span&gt;
当前线程是：Thread&lt;/span&gt;-3对应的编号是:10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出每个线程都产生出了10个数字。他们互不影响，线程运行的顺序可能有会不同，但是每个都是独立的，以当前线程作为键，值作为value，每个数字产生器都生成了独立的数字，达到了线程独立的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四：总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   本篇博文介绍了ThreadLocal，主要从结构、源码角度分析了它的api，对于向外暴露出来的get/set/remove方法都进行了分析，关于其实际使用，用两个简单的例子进行了表现，希望从本篇博文中能更进一步的学习和了解到ThreadLocal，对于我们在多线程的学习过程中，适当的使用ThreadLocal。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 24 Feb 2018 10:17:00 +0000</pubDate>
<dc:creator>Yrion</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq178/p/8414719.html</dc:identifier>
</item>
<item>
<title>腾讯IVWEB前端工程化工具feflow思考与实践 - cpselvis</title>
<link>http://www.cnblogs.com/cpselvis/p/8467206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpselvis/p/8467206.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://qpic.url.cn/feeds_pic/eMJXws7FFlauUALSWA3S7iceia5xM4HrEfUve3X4PJyAw/&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍&lt;a href=&quot;https://ivweb.io/&quot;&gt;腾讯IVWEB团队&lt;/a&gt;从0到1在工程化的思考和实践。&lt;a href=&quot;https://github.com/feflow/feflow&quot;&gt;feflow&lt;/a&gt;的全称是Front-end flow（前端工作流），致力于提升研发效率和规范的工程化解决方案。愿景是通过feflow，可以使项目创建、开发、构建、规范检查到最终项目上线的整个过程更加自动化和标准化。&lt;/p&gt;
&lt;h3 id=&quot;要解决的问题&quot;&gt;要解决的问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;项目的目录结构按约定生成&lt;/li&gt;
&lt;li&gt;团队有一套开发规范进行约束&lt;/li&gt;
&lt;li&gt;支持多种类型的构建，包括Fis构建和webpack构建&lt;/li&gt;
&lt;li&gt;团队内部的代码贡献统计、离线包内置App等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决上述问题，我们于17年2月底开始投入工程化feflow工具的开发和相关规范的制定，目前已经研发出了 feflow 的 &lt;a href=&quot;https://github.com/feflow/feflow&quot;&gt;CLI&lt;/a&gt; 版本，后续会推出 GUI 版本。&lt;/p&gt;
&lt;h3 id=&quot;架构设计&quot;&gt;架构设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://qpic.url.cn/feeds_pic/Fia6FID6YXfJiaVVicpFaNg2GfB6KzsNIibpxK3YdDINCGY/&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了让 feflow 的具有高可扩展性，我们设计了4层结构，分别是：插件生态、内核层、参数解析器和控制台。除了贯穿整个开发工作流的基础命令选择通过内部插件内置在CLI 的Core里面，其它非必要命令统一通过插件机制进行扩展。&lt;/p&gt;
&lt;p&gt;另一方面，为了使得 feflow 能够适用多种类型的项目。我们开发了多种类型的业务脚手架，如：活动模板、App H5模板、RN模板和业务组件模板。&lt;/p&gt;
&lt;h3 id=&quot;执行过程&quot;&gt;执行过程&lt;/h3&gt;
&lt;p&gt;当用户在控制台里面输入某个命令。首先会通过CLI 的参数解析器，将这个命令解析成一个object对象，然后传递给CLI 的内核。所有的命令都是通过内核上下文提供的 register 函数 进行注册的，一方面内核自身会读取内置插件 注册的基础命令，另一方面，内核会读取本地已经安装的外部插件注册的命令。如果找到用户输入的命令则开始执行命令对应的回调函数。&lt;/p&gt;
&lt;h3 id=&quot;基础命令设计&quot;&gt;基础命令设计&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 初始化项目
$ feflow init

# 本地开发
$ feflow dev

# 代码质量检查
$ feflow lint

# 打包构建
$ feflow build

# 代码发布
$ feflow publish

# 安装插件、脚手架等
$ feflow install package

# 配置本地客户端，如: npm 的源和 proxy
$ feflow config &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面提到，CLI 的命令包含两部分，分别是内置在内核里的基础命令和外部插件提供的命令。那么外部插件要如何设计呢？&lt;/p&gt;
&lt;h3 id=&quot;插件机制设计&quot;&gt;插件机制设计&lt;/h3&gt;
&lt;h4 id=&quot;插件实现原理&quot;&gt;插件实现原理&lt;/h4&gt;
&lt;p&gt;这里有一个非常巧妙的设计，通过使用node提供的module和vm模块，可以通注入feflow全局变量来访问到cli的实例。从而能够访问cli上的各种属性，比如config, log和一些helper等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; loadPlugin(path, callback) {
    const self = this;

    return fs.readFile(path).then((script) =&amp;gt; {

      const module = new Module(path);
      module.filename = path;
      module.paths = Module._nodeModulePaths(path);

      function require(path) {
          return module.require(path);
      }

      require.resolve = function(request) {
          return Module._resolveFilename(request, module);
      };

      require.main = process.mainModule;
      require.extensions = Module._extensions;
      require.cache = Module._cache;

      // Inject feflow variable
      script = '(function(exports, require, module, __filename, __dirname, feflow){' +
          script + '});';

      const fn = vm.runInThisContext(script, path);

      return fn(module.exports, require, module, path, pathFn.dirname(path), self);
      }).asCallback(callback);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;命令注册&quot;&gt;命令注册：&lt;/h4&gt;
&lt;p&gt;命令需要以feflow.cmd.register进行注册，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;feflow.cmd.register('deps', 'Config ivweb dependencies', function(args) {
    console.log(args);
    // Plugin logic here.
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;register有3个参数，第一个是子命令名称，第二个是命令描述说明信息，第三个是对应的子命令执行逻辑函数。&lt;/li&gt;
&lt;li&gt;feflow会将命令行参数args解析成Object对象，传递给插件处理函数&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;
&lt;p&gt;可以通过feflow.version获取当前feflow的版本，feflow.baseDir 获取feflow跟目录（在用户目录下的.feflow），通过feflow.pluginDir 获取插件目录&lt;/p&gt;
&lt;h4 id=&quot;日志&quot;&gt;日志&lt;/h4&gt;
&lt;p&gt;通过feflow.log来进行相关命令行日志输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const log = feflow.log;
log.info()    // 提示日志，控制台中显示绿色
log.debug()   // 调试日志,  命令行增加--debug可以开启，控制台中显示灰色
log.warn()    // 警告日志，控制台中显示黄色背景
log.error()   // 错误日志，控制台中显示红色
log.fatal()   // 致命错误日志，，控制台中显示红色&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;插件开发完成后，可以通过 feflow 提供的 install 命令安装插件。安装的插件会放置在本地客户端 ~/.feflow/node_modules 文件夹下，并且写入到 ~/.feflow/package.json 中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ feflow install feflow-plugin-xxx   // 安装某个插件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后每次运行命令时，便会从本地加载插件所注册的命令&lt;/p&gt;
&lt;h3 id=&quot;全量更新和增量更新&quot;&gt;全量更新和增量更新&lt;/h3&gt;
&lt;p&gt;当CLI发布了一个新的版本，可能我们会废弃掉某些功能或者提供了新功能。这个时候如果用户依然使用的是旧版本，由于某些服务已经废弃掉了则会报错。在这种新旧版本不兼容的情况下，如何强制用户进行CLI的升级呢？需要在运行命令之前检查本地的CLI是否和远程提供的新版本是否兼容。在新旧版本不兼容时，会强制全量更新。如何判断当前用户安装的本地版本和远程最新版本是否兼容呢？&lt;/p&gt;
&lt;p&gt;这里非常巧妙的运用了一下 npm 的 registry机制，每次发布新版本，我们会在 package.json 里面新增一个自定义字段 compatibleVersion，它的值是一个 semver 的版本号。本地检查时，会读取本地已经安装的版本和远程最新的版本进行比较，看看是否满足 compatibleVersion 的要求。如果不满足，则会自动运行 &lt;code&gt;npm install feflow-cli&lt;/code&gt; 到最新的版本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &quot;configs&quot;: {
    &quot;compatibleVersion&quot;: &quot;&amp;gt;=0.13.0&quot;
 },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于插件，采取的是增量更新机制。每个发布到 npm 上的插件的package.json 中同样会有上面的这个字段，对于本地安装的不兼容的插件列表，会采取增量更新。&lt;/p&gt;
&lt;h3 id=&quot;多类型脚手架的架构设计&quot;&gt;多类型脚手架的架构设计&lt;/h3&gt;
&lt;p&gt;项目拷贝存在的问题显而易见，大致有以下三个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容易出错；一旦某个关键文件拷贝丢失或者错误，很可能需要耗费半天到一天的时间排查环境问题。&lt;/li&gt;
&lt;li&gt;不同场景下对目录结构要求不同；平时开发过程中，工程通常会分为运营活动、Hybrid业务、入口级别的项目（对性能和体验有极致和苛刻的要求）。需要基于RN或者Node.js的首屏直出，还有常用的业务组件等的开发。&lt;/li&gt;
&lt;li&gt;新的Feature和BugFix难以同步；某个同学开发过程中增加的新方法或者解决的bug很难传递给其它同学并且沉淀成经验积累下来。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;社区里面提供了完美的Yeoman解决方案，它是为了自动化项目的创建而生。Yeoman创建项目包括以下几个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;initializing: 初始化一些状态之类的，通常是和用户输入的 options 或者 arguments 打交道&lt;/li&gt;
&lt;li&gt;prompting: 和用户交互的时候（命令行问答之类的）调用&lt;/li&gt;
&lt;li&gt;configuring: 保存配置文件（如 .babelrc 等）&lt;/li&gt;
&lt;li&gt;writing: 生成模板文件&lt;/li&gt;
&lt;li&gt;install: 安装依赖&lt;/li&gt;
&lt;li&gt;end: 结束部分，初始代码自动提交&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们只需要继承Yeoman的Generator类做模板定制化，基于Yeoman的脚手架设计思路应该如下图所示：&lt;br/&gt;&lt;img src=&quot;https://qpic.url.cn/feeds_pic/Q3auHgzwzM5OeF65JG7fNeUbvwzbQ7wEjX4Bzs5TBJjgyZ9r8F7gZA/&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当开发者输入 feflow init 命令时，开发者会告诉CLI需要创建哪一种类型的项目，CLI收到命令后。从本地已经安装的Yeoman脚手架里面选择某种类型的模板。然后，CLI会调用Gitlab API在远程创建仓库并且授予开发者master权限。接下来，会根据实际业务场景需要，自动化申请一些打点信息，常见的如离线包id，监控告警id等等。之后，在本地目录生成代码并且安装项目依赖的npm包，最后将本次初始化生成的所有代码自动提交到远程Git仓库。&lt;/p&gt;
&lt;h3 id=&quot;多类型主流构建支持&quot;&gt;多类型主流构建支持&lt;/h3&gt;
&lt;p&gt;为了让feflow 支持多种类型的构建环境，比如 Fis3 和 webpack，或者前不久刚推出的号称零配置成本的 Parcel 构建。在每个项目的跟目录会放置一份配置文件，名称为 feflow.json。它的配置可能是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;builderType&quot;: &quot;builder-webpack3&quot;,
    &quot;builderOptions&quot;: {
        &quot;moduleName&quot;: &quot;mobile&quot;,
        &quot;bizName&quot;: &quot;category&quot;,
        &quot;minifyHTML&quot;: true,
        &quot;minifyCSS&quot;: true,
        &quot;minifyJS&quot;: true,
        &quot;usePx2rem&quot;: true,
        &quot;remUnit&quot;: 100,
        &quot;remPrecision&quot;: 8,
        &quot;inject&quot;: true,
        &quot;port&quot;: 8001
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;builderType为构建的npm包，builderOptions为构建的参数配置。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;腾讯IVWEB团队的工程化解决方案feflow已经开源：Github主页：&lt;a href=&quot;https://github.com/feflow/feflow&quot; class=&quot;uri&quot;&gt;https://github.com/feflow/feflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果对您的团队或者项目有帮助，请给个Star支持一下哈～&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 09:51:00 +0000</pubDate>
<dc:creator>cpselvis</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpselvis/p/8467206.html</dc:identifier>
</item>
<item>
<title>浅谈分词算法（1）分词中的基本问题 - xlturing</title>
<link>http://www.cnblogs.com/xlturing/p/8465965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xlturing/p/8465965.html</guid>
<description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;分词或说切词是自然语言处理中一个经典且基础的问题，在平时的工作中也反复的接触到分词问题，用到了不同的模型，不同的方法应用在各个领域中，所以想对分词问题做一个系统的梳理。大多数分词问题主要是针对类似汉语、韩语、日语等，词语之间并没有天然的分割，而像英语等，句子中是带有天然的分割的。但是英语也会涉及到分词问题，比如实体识别、词性标注等内容。而本系列文章更多的是讨论汉语中的分词问题，首先我们从分词问题的基本出发，之后从传统的词典分词到将分词转为序列标注问题的分词，以及最新的结合深度学习的分词，基本按照时间顺序对分词模型可能用到的算法模型进行一步步尝试与介绍，所有代码我会放在自己的github上：&lt;a href=&quot;https://github.com/xlturing&quot;&gt;xlturing&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xlturing/p/8465965.html&quot;&gt;浅谈分词算法（1）分词中的基本问题&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/xlturing/p/8467021.html&quot;&gt;浅谈分词算法（2）基于词典的分词方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/xlturing/p/8467033.html&quot;&gt;浅谈分词算法（3）基于字的分词方法（HMM）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/xlturing/p/8465965.html&quot;&gt;浅谈分词算法（4）基于字的分词方法（CRF）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/xlturing/p/8465965.html&quot;&gt;浅谈分词算法（5）基于字的分词方法（LSTM）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单的讲，汉语自动分词就是让计算机在汉语文本中的词与词之间自动加上空格或其他边界标记。分词中涉及到三个基本问题：分词规范、歧义切分和未登录词的识别。&lt;/p&gt;
&lt;h2 id=&quot;分词规范&quot;&gt;分词规范&lt;/h2&gt;
&lt;p&gt;我们从小学习汉语开始，基本顺序就是汉字-&amp;gt;词语-&amp;gt;句子-&amp;gt;段落-&amp;gt;篇章，而其中词是什么，什么是词语，这个问题看似有些莫名其妙，但是如何界定一个词语却是分词中一个很重要的话题。有关专家的调查表明，在母语为汉语的被试者之间，对汉语文本中出现的词语的认同率只有大约70%，从计算的严格意义上说，自动分词是一个没有明确定义的问题[黄昌宁等,2003]。举个简单的例子：&lt;br/&gt;“小明看到湖岸上的花草，一株不知名的小花引起了他的注意”&lt;/p&gt;
&lt;p&gt;对于这句话中的“湖岸”、“花草”、“不知名”等，不同的词语界定方式就会出现不一样的分词结果，如我们可以切分成以下几种形式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;“小明/看到/湖岸/上/的/花草/，一株/不知名/的/小花/引起/了/他的/注意”&lt;/li&gt;
&lt;li&gt;“小明/看到/湖/岸/上/的/花/草，一株/不/知名/的/小花/引起了/他的/注意”&lt;/li&gt;
&lt;li&gt;“小明/看到/湖岸/上的/花/草，一株/不知名的/小花/引起了/他的/注意”&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以看出不同的词语界定方式，可以组合出很多种分词结果，所以说分词可以看做是找寻一个没有明确定义问题的答案。所以当我们在衡量一个分词模型的好坏时，我们首先需要确定一个统一的标准，即所谓Golden Data，大家所有的模型都在统一的数据集上进行训练和评测，这样比较才会具有可参考性。&lt;/p&gt;
&lt;h2 id=&quot;歧义切分&quot;&gt;歧义切分&lt;/h2&gt;
&lt;p&gt;歧义字段在汉语中是普遍存在的，而歧义字段是汉语切分的一个重要难点。梁南元最早对歧义字段进行了两种基本的定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;交集型切分歧义：汉字串AJB称作交集型切分歧义，如果满足AJ、JB同时为词（A、J、B分别为汉字串）。此时汉字串J称作交集串。如，大学生（大学/学生）、研究生物（研究生/生物）、结合成（结合/合成）.&lt;/li&gt;
&lt;li&gt;组合型切分歧义：汉字串AB称作多义组合型切分歧义，如果满足A、B、AB同时为词。如，起身（他|站|起|身|来/明天|起身|去北京）、学生会（我在|学生会|帮忙/我的|&lt;br/&gt;学生|会来|帮忙）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以看出歧义字段给我们的分词问题带来了极大的困扰，所以想要正确的做出切分判断，一定要结合上下文语境，甚至韵律、语气、重音、停顿等。&lt;/p&gt;
&lt;h2 id=&quot;未登录词识别&quot;&gt;未登录词识别&lt;/h2&gt;
&lt;p&gt;未登录词，一种是指已有的词表中没有收录的词，另一种是指训练语料中未曾出现过的词。而后一种含义也可以被称作集外词，OOV（out of vocabulary），即训练集以外的词。通常情况下未登录词和OOV是一回事，我们这里不加以区分。&lt;br/&gt;未登录词大体可以分为如下几个类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新出现的普通词汇，如网络用语当中层出不穷的新词，这在我们的分词系统这种也是一大挑战，一般对于大规模数据的分词系统，会专门集成一个新词发现模块，用于对新词进行挖掘发现，经过验证后加入到词典当中。&lt;/li&gt;
&lt;li&gt;专有名词，在分词系统中我们有一个专门的模块，命名体识别（NER name entity recognize），用于对人名、地名以及组织机构名等单独进行识别。&lt;/li&gt;
&lt;li&gt;专业名词和研究领域名称，这个在通用分词领域出现的情况比较少，如果出现特殊的新领域，专业，就会随之产生一批新的词汇。&lt;/li&gt;
&lt;li&gt;其他专用名词，包含其他新产生的产品名、电影、书籍等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过统计汉语分词出现问题更多是由于未登录词造成的，那么分词模型对于未登录词的处理将是衡量一个系统好坏的重要指标。&lt;/p&gt;

&lt;h2 id=&quot;基于词典的分词方法&quot;&gt;基于词典的分词方法&lt;/h2&gt;
&lt;p&gt;基于词典的方法是经典的传统分词方法，这种方式很直观，我们从大规模的训练语料中提取分词词库，并同时将词语的词频统计出来，我们可以通过逆向最大匹配、N-最短路径以及N-Gram模型等分词方法对句子进行切分。基于词典的分词方法非常直观，我们可以很容易的通过增减词典来调整最终的分词效果，比如当我们发现某个新出现的名词无法被正确切分的时候，我们可以直接在词典当中进行添加，以达到正确切分的目的；同样的过于依赖于词典也导致这种方法对于未登录词的处理不是很好，并且当词典当中的词出现公共子串的时候，就会出现歧义切分的问题，这需要语料库足够的丰富，从而能够对每个词的频率有一个很好的设置。&lt;/p&gt;
&lt;h2 id=&quot;基于字的分词方法&quot;&gt;基于字的分词方法&lt;/h2&gt;
&lt;p&gt;不同于基于词典的分词方法，需要依赖于一个事先编制好的词典，通过查词典的方式作出最后的切分决策；基于字的分词方法将分词过程看作是字的分类问题，其认为每个字在构造一个特定词语时都占据着一个确定的构词位置（词位）[1]。这种方法最早由薛念文等人于2002年提出，并在各种分词大赛上取得了不错的成绩，尤其是对未登录词问题的处理，召回率一直很高。&lt;br/&gt;一般情况下，我们认为每个字的词位有4种情况：B（Begin）、E（End）、M（Middle）、S（Single），那么我们对于一个句子的切分就可以转为对句子中每个字打标签的过程，举个例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自然语言处理/可以/应用/在/诸多/领域。&lt;/li&gt;
&lt;li&gt;自B 然M 语M 言M 处M 理E 可B 以E 应B 用E 在S 诸B 多E 领B 域E。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们对句子中的每个字赋予了一个词位，即BEMS中的一个标签，这样我们就完成了分词的目的。&lt;br/&gt;基于字的方法将传统的语言学问题转换为了一个更加容易建模的序列标注问题，我们可以用最大熵模型为每个字进行标签分类；也可以利用HMM将其看作一个解码问题；或者考虑句子间的时序关系，利用判别模型CRF来建模；同样时下火热的深度学习中的LSTM也可以用在这里进行建模。&lt;/p&gt;

&lt;p&gt;本篇博文我们先简单介绍分词问题本身，其重点和难点是什么，已经大的方向上用到了哪些方法和模型，后续我们会选取常用的分词模型进行一一介绍和实现。这里需要特别说明下的是，本系列文章在介绍的时候是分开单个模型进行介绍的，在实际生产环境中，我们往往会融合多种方法来提高准确率和召回率，比如在github中经常被提及的结巴分词就融合了n-gram词典分词和HMM字分词，大家具体用到的时候要根据实际环境进行选择和搭配，必要的时候要对模型进行重train和调整。&lt;/p&gt;
&lt;p&gt;如有任何纰漏，欢迎大家指正。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;《统计自然语言处理 第2版》&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 24 Feb 2018 09:20:00 +0000</pubDate>
<dc:creator>xlturing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xlturing/p/8465965.html</dc:identifier>
</item>
</channel>
</rss>