<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【LeetCode题解】232_用栈实现队列（Implement-Queue-using-Stacks） - StrongXGP</title>
<link>http://www.cnblogs.com/xugenpeng/p/10051819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xugenpeng/p/10051819.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;4.4642857142857&quot;&gt;
&lt;p&gt;更多 LeetCode 题解笔记可以访问我的 &lt;a href=&quot;https://github.com/Genpeng/play-with-leetcode&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;push(x) -- 将一个元素放入队列的尾部。&lt;/li&gt;
&lt;li&gt;pop() -- 从队列首部移除元素。&lt;/li&gt;
&lt;li&gt;peek() -- 返回队列首部的元素。&lt;/li&gt;
&lt;li&gt;empty() -- 返回队列是否为空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你只能使用标准的栈操作 -- 也就是只有 &lt;code&gt;push to top&lt;/code&gt;, &lt;code&gt;peek/pop from top&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, 和 &lt;code&gt;is empty&lt;/code&gt; 操作是合法的。&lt;/li&gt;
&lt;li&gt;你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。&lt;/li&gt;
&lt;li&gt;假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;队列是一种先入先出（first in first out, FIFO）的数据结构，而栈是一种后入先出（last in first out, LIFO）的数据结构。因此，如果要使用栈来达到队列的效果，即用有后入先出性质的数据结构来实现先入先出的效果，需要借用两个栈来改变元素的出队顺序。当然，借用两个栈来实现队列也有不同的实现方式，这一节介绍第一种实现方式，在下一小节介绍第二种方式。&lt;/p&gt;
&lt;p&gt;第一种方式是&lt;u&gt;&lt;strong&gt;在一个栈中维持所有元素的出队顺序&lt;/strong&gt;&lt;/u&gt;，即所有的元素在入队操作完成后只会保存在一个栈中，且其出栈的顺序和出队的顺序是一致的。下面对入队、出队等操作的底层实现分别进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;入队push&quot;&gt;入队（push）&lt;/h3&gt;
&lt;p&gt;为了实现出栈顺序和出队顺序是一致的，&lt;em&gt;入栈时必须将新的元素压入栈底&lt;/em&gt;。为了实现这种效果，在入队时，首先将栈1（假设栈1中保存所有的元素）中所有的元素弹出并压入栈2中，接着将新的元素压入栈1中，最后再将栈2中的所有弹出并压入栈1中。详细的步骤如图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181201235453535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;small&gt;图1：将一个元素入队&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;代码（Java）实现如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void push(int x) {
    // 将栈1中的所有元素弹出并压入栈2中
    while (!s1.isEmpty()) {
        s2.push(s1.pop());
    }

    // 将新的元素压入栈1
    s1.push(x);

    // 将栈2的所有元素弹出并压入栈1
    while (!s2.isEmpty()) {
        s1.push(s2.pop());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 表示入队时队列元素的数目，即栈1中元素的数目。入队时，栈1中的元素需要进行出栈和入栈两次，需要 &lt;span class=&quot;math inline&quot;&gt;\(4n\)&lt;/span&gt; 次操作，再加上新的元素的一次入栈操作，总的操作次数为 &lt;span class=&quot;math inline&quot;&gt;\(4n + 1\)&lt;/span&gt; 次。由于栈的入栈和出栈的时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; 的，因此，入队的时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; 的&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;出队pop&quot;&gt;出队（pop）&lt;/h3&gt;
&lt;p&gt;出队操作比较简单，由于栈1中元素的出栈顺序和队列的出队顺序一致，因此，只需要弹出栈顶元素即可完成出队操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int pop() {
    if (s1.isEmpty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    return s1.pop();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查看队首peek&quot;&gt;查看队首（peek）&lt;/h3&gt;
&lt;p&gt;与出队操作类似，只需要查看栈1栈顶的元素即可完成查看队首的操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int peek() {
    if (s1.isEmpty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    return s1.peek();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;是否为空empty&quot;&gt;是否为空（empty）&lt;/h3&gt;
&lt;p&gt;由于栈1中保存队列的所有元素，因此只需要判断栈1是否为空即可知道队列是否为空。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public boolean empty() {
    return s1.isEmpty();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-实现&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class MyQueue {
    private Stack&amp;lt;Integer&amp;gt; s1;
    private Stack&amp;lt;Integer&amp;gt; s2;

    /** Initialize your data structure here. */
    public MyQueue() {
        s1 = new Stack&amp;lt;&amp;gt;();
        s2 = new Stack&amp;lt;&amp;gt;();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        while (!s1.isEmpty()) {
            s2.push(s1.pop());
        }
        s1.push(x);
        while (!s2.isEmpty()) {
            s1.push(s2.pop());
        }
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if (s1.isEmpty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        return s1.pop();
    }

    /** Get the front element. */
    public int peek() {
        if (s1.isEmpty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        return s1.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return s1.isEmpty();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyQueue:
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self._s1, self._s2 = [], []
        
    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: void
        &quot;&quot;&quot;
        while self._s1:
            self._s2.append(self._s1.pop())  
        self._s1.append(x)
        while self._s2:
            self._s1.append(self._s2.pop())

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self._s1.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        return self._s1[-1]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self._s1&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;思路-1&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;解法二的实现方式与解法一有点不同，按照功能的不同，解法二将&lt;u&gt;&lt;strong&gt;两个栈一个用于入队，一个用于出队&lt;/strong&gt;&lt;/u&gt;。假设栈 &lt;code&gt;inStack&lt;/code&gt; 用于实现入队操作，栈 &lt;code&gt;outStack&lt;/code&gt; 用于实现出队操作。下面对入队、出队等操作的底层实现分别进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;入队push-1&quot;&gt;入队（push）&lt;/h3&gt;
&lt;p&gt;入队操作比较简单，直接将新的元素压入栈 &lt;code&gt;inStack&lt;/code&gt; 中，同时，对于第一个进入栈中的元素，我们用一个变量 &lt;code&gt;front&lt;/code&gt; 保存起来，用于表示栈 &lt;code&gt;inStack&lt;/code&gt; 这个队列的队首。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Push element x to the back of queue. */
public void push(int x) {
    if (inStack.empty()) {
        front = x;
    }
    inStack.push(x);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，需要额外的空间用于存储队列元素&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;出队pop-1&quot;&gt;出队（pop）&lt;/h3&gt;
&lt;p&gt;在入队时，由于先入的元素处于输入栈 &lt;code&gt;inStack&lt;/code&gt; 的栈底，因此，为了能够弹出栈底的元素实现出队操作，需要将输入栈 &lt;code&gt;inStack&lt;/code&gt; 中的元素弹出并压入到输出栈 &lt;code&gt;outStack&lt;/code&gt; 中。此时，输出栈 &lt;code&gt;outStack&lt;/code&gt; 中元素的出栈顺序和队列的出队顺序是一致的。只要输出栈 &lt;code&gt;outStack&lt;/code&gt; 中还有元素，每次执行出队操作只需要将栈 &lt;code&gt;outStack&lt;/code&gt; 的栈顶元素弹出即可。当输出栈 &lt;code&gt;outStack&lt;/code&gt; 为空时，执行出队操作则需要先将输入栈 &lt;code&gt;inStack&lt;/code&gt; 中的元素弹出并压入输出栈。详细的步骤如图2所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181201235621214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;small&gt;图2：将一个元素出队&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;代码（Java）实现如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Removes the element from in front of queue and returns that element. */
public int pop() {
    if (empty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    if (outStack.isEmpty()) {
        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
    }
    return outStack.pop();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：均摊时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;，最坏情况下，时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，更为详细的均摊复杂度分析可以查看&lt;a href=&quot;https://leetcode.com/articles/implement-queue-using-stacks/?page=2&quot;&gt;官网的文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查看队首peek-1&quot;&gt;查看队首（peek）&lt;/h3&gt;
&lt;p&gt;与出队操作类似，当输出栈 &lt;code&gt;outStack&lt;/code&gt; 不为空时，只需要返回输出栈 &lt;code&gt;outStack&lt;/code&gt; 的栈顶元素即可。不同的是，由于我们用变量 &lt;code&gt;front&lt;/code&gt; 存储了输入栈最先进入的元素，因此，当输出栈 &lt;code&gt;outStack&lt;/code&gt; 为空时，不需要再将输入栈 &lt;code&gt;inStack&lt;/code&gt; 的元素弹出并压入到输出栈 &lt;code&gt;outStack&lt;/code&gt; 中便可以得到当前队首的元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Get the front element. */
public int peek() {
    if (empty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    if (!outStack.isEmpty()) {
        return outStack.peek();
    } else {
        return front;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;，借助于变量 &lt;code&gt;front&lt;/code&gt;，可以使得 &lt;code&gt;peek&lt;/code&gt; 操作在任意情况下都是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; 的时间复杂度&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;是否为空empty-1&quot;&gt;是否为空（empty）&lt;/h3&gt;
&lt;p&gt;由于两个都有可以存在元素，因此，要判断队列是否为空，需要同时判断两个栈。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Returns whether the queue is empty. */
public boolean empty() {
    return inStack.isEmpty() &amp;amp;&amp;amp; outStack.isEmpty();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-实现-1&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class MyQueue {
    /**
     * The stack used to implement enqueue functionality
     */
    private Stack&amp;lt;Integer&amp;gt; inStack;
    /**
     * The stack used to implement dequeue functionality
     */
    private Stack&amp;lt;Integer&amp;gt; outStack;
    /**
     * The front element in the stack `inStack` 's queue
     */
    private int front;

    /** Initialize your data structure here. */
    public MyQueue2() {
        inStack = new Stack&amp;lt;&amp;gt;();
        outStack = new Stack&amp;lt;&amp;gt;();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        if (inStack.empty()) {
            front = x;
        }
        inStack.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if (empty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.pop();
    }

    /** Get the front element. */
    public int peek() {
        if (empty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        if (!outStack.isEmpty()) {
            return outStack.peek();
        } else {
            return front;
        }
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return inStack.isEmpty() &amp;amp;&amp;amp; outStack.isEmpty();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现-1&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyQueue:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self._in_stack, self._out_stack, self._front = [], [], None
        
    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: void
        &quot;&quot;&quot;
        if not self._in_stack:
            self._front = x
        self._in_stack.append(x)

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        if self.empty():
            raise Exception(&quot;[ERROR] The queue is empty!&quot;)
            
        if not self._out_stack:
            while self._in_stack:
                self._out_stack.append(self._in_stack.pop())
        return self._out_stack.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        if self.empty():
            raise Exception(&quot;[ERROR] The queue is empty!&quot;)
            
        if not self._out_stack:
            return self._front
        else:
            return self._out_stack[-1]
        

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self._in_stack and not self._out_stack&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 01 Dec 2018 15:58:00 +0000</pubDate>
<dc:creator>StrongXGP</dc:creator>
<og:description>更多 LeetCode 题解笔记可以访问我的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xugenpeng/p/10051819.html</dc:identifier>
</item>
<item>
<title>HttpURLConnection 实现get提交 - 梦想战士</title>
<link>http://www.cnblogs.com/mmtBlog/p/10051753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmtBlog/p/10051753.html</guid>
<description>&lt;p&gt;package com.mmt.test.urlConnection;&lt;/p&gt;
&lt;p&gt;import java.io.ByteArrayOutputStream;&lt;br/&gt;import java.io.IOException;&lt;br/&gt;import java.io.InputStream;&lt;br/&gt;import java.io.StreamTokenizer;&lt;br/&gt;import java.net.HttpURLConnection;&lt;br/&gt;import java.net.URL;&lt;/p&gt;
&lt;p&gt;public class URLConnection_GET {&lt;/p&gt;&lt;p&gt;public static void main(String args[]){&lt;br/&gt;String urlPath = &quot;http://www.besti.edu.cn&quot;;&lt;br/&gt;String encodeType = &quot;UTF-8&quot;;&lt;br/&gt;String resultString = getWEBPageContentByURLPath(urlPath, encodeType);&lt;br/&gt;System.out.println(resultString);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static String getWEBPageContentByURLPath(String urlPath,String encodeType){&lt;br/&gt;String resultString = null ;&lt;/p&gt;&lt;p&gt;InputStream inputStream = getInputStreamByURLPath(urlPath, encodeType);&lt;br/&gt;resultString = streamToString(inputStream, encodeType);&lt;br/&gt;return resultString ;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private static InputStream getInputStreamByURLPath(String urlPath,String encodeType){&lt;/p&gt;&lt;p&gt;InputStream inputStream = null ;&lt;br/&gt;URL url = null ;&lt;br/&gt;try {&lt;br/&gt;url = new URL(urlPath );&lt;/p&gt;&lt;p&gt;HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();&lt;br/&gt;httpURLConnection.setConnectTimeout(3000);&lt;br/&gt;httpURLConnection.setDoInput(true);&lt;br/&gt;httpURLConnection.setRequestMethod(&quot;GET&quot;);&lt;/p&gt;&lt;p&gt;int responseCode = httpURLConnection.getResponseCode();&lt;br/&gt;if(responseCode ==200){&lt;br/&gt;inputStream = httpURLConnection.getInputStream();&lt;br/&gt;}&lt;br/&gt;} catch (Exception e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;return inputStream ;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private static String streamToString(InputStream inputStream,String encodeType){&lt;br/&gt;String resultString = null ;&lt;/p&gt;&lt;p&gt;ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();&lt;br/&gt;int len = 0;&lt;br/&gt;byte data[]=new byte[1024];&lt;br/&gt;try {&lt;br/&gt;while((len=inputStream.read(data))!=-1){&lt;br/&gt;byteArrayOutputStream.write(data,0,len);&lt;br/&gt;}&lt;br/&gt;byte[]allData = byteArrayOutputStream.toByteArray();&lt;br/&gt;resultString = new String(allData,encodeType);&lt;br/&gt;} catch (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;return resultString ;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 15:48:00 +0000</pubDate>
<dc:creator>梦想战士</dc:creator>
<og:description>package com.mmt.test.urlConnection; import java.io.ByteArrayOutputStream;import java.io.IOException;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mmtBlog/p/10051753.html</dc:identifier>
</item>
<item>
<title>nginx解析漏洞，配置不当，目录遍历漏洞复现 - 晓枫v5</title>
<link>http://www.cnblogs.com/hackxf/p/10051732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hackxf/p/10051732.html</guid>
<description>&lt;h3 id=&quot;nginx解析漏洞配置不当目录遍历漏洞复现&quot;&gt;nginx解析漏洞，配置不当，目录遍历漏洞复现&lt;/h3&gt;
&lt;h4 id=&quot;ubuntu14.04安装nginx-php5-fpm&quot;&gt;1.Ubuntu14.04安装nginx-php5-fpm&lt;/h4&gt;
&lt;p&gt;安装了nginx，需要安装以下依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install libpcre3 libpcre3-dev
sudo apt-get install zlib1g.dev
sudo apt-get install libssl-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装php：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install php5-fpm&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启&lt;strong&gt;Nginx对php的支持&lt;/strong&gt;，去掉配置文件中关于php的注释并重启Nginx即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/nginx/sites-available/default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181128235050419-1085108164.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;nginx网站目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/share/nginx/html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181128235703558-78496602.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx解析php&quot;&gt;nginx解析php&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;nginx无法启动可以查看日记查找解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /var/log/nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129000043402-1783933872.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问php文件403&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在/etc/php5/fpm/pool.d/www.conf中编辑
listen = /var/run/php5-fpm.sock为127.0.0.1:9000

在/etg/nginx/sites-available/**.conf中编辑
fastcgi_pass/var/run/php5-fpm.sock为127.0.0.1:9000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后重启nginx,php5-fpm即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;重启服务命令
service php5-fpm restart
service nginx restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129000510403-203499008.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx的文件解析漏洞复现&quot;&gt;2.Nginx的文件解析漏洞复现&lt;/h4&gt;
&lt;p&gt;如果在访问test.jpg这个文件时以这种去访问/test.jpg/1.php，可能会被当做PHP代码去执行&lt;/p&gt;
&lt;p&gt;用户配置不当造成的解析漏洞。 我们现在进行不当配置实现解析漏洞&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/php5/fpm/php.ini
修改cgi.fix_pathinfo为1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129001719662-292856967.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/php5/fpm/pool.d/www.conf
修改security.limit_extensions允许解析其他格式文件为PHP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129001922424-902834985.png&quot;/&gt;&lt;br/&gt;解析漏洞成功&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002007870-872967856.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002023024-342285575.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx目录遍历漏洞&quot;&gt;3.Nginx目录遍历漏洞&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/nginx/sites-available/default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在location这里加上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;autoindex on;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002850021-940684083.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002920580-1094199487.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx目录穿越漏洞&quot;&gt;4.nginx目录穿越漏洞&lt;/h4&gt;
&lt;p&gt;Nginx在配置别名（Alias）的时候，如果忘记加/，将造成一个目录穿越漏洞。&lt;/p&gt;
&lt;p&gt;错误的配置文件示例（原本的目的是为了让用户访问到/home/目录下的文件）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;location /files {
    alias /home/;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129102739403-439895723.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129102806472-672050090.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129102825882-1444736927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;==遇到的坑==&lt;/p&gt;
&lt;h4 id=&quot;docker为什么刚运行就退出了&quot;&gt;5.Docker为什么刚运行就退出了&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d -p 80:80 ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行了一个简单的容器后,然后docker ps -a 进行查看, 会发现容器已经退出&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129105111136-1422161505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很重要的要说明的一点: &lt;strong&gt;Docker容器后台运行,就必须有一个前台进程.&lt;/strong&gt;&lt;br/&gt;容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的&lt;br/&gt;这个是docker的机制问题,比如你的web容器,我们以nginx和fpm为例,&lt;br/&gt;正常情况下,我们配置启动服务只需要启动响应的service即可,例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service nginx start &amp;amp;&amp;amp; service php5-fpm start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是,这样做,nginx和fpm均为后台进程模式运行,就导致docker前台没有运行的应用,&lt;br/&gt;这样的容器,后台启动后,会立即自杀,因为他觉得他没事可做了.&lt;/p&gt;
&lt;p&gt;解决方法:&lt;br/&gt;1.最佳的解决方案是,将你要运行的程序以前台进程的形式运行,当然,如果你的容器需要同时启动多个进程,&lt;br/&gt;那么也只需要,或者说只能将其中一个挂起到前台即可.&lt;br/&gt;比如上面所说的web容器,我们只需要将启动指令修改为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service php5-fpm start &amp;amp;&amp;amp; nginx -g &quot;daemon off;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样,fpm会在容器中以后台进程的方式运行,而nginx则挂起进程至前台运行,这样,就可以保持容器不会认为没事可做而自杀了.&lt;/p&gt;
&lt;p&gt;2.对于有一些你可能不知道怎么前台运行的程序,提供一个投机方案,你只需要在你启动的命令之后,&lt;br/&gt;添加类似于 tail top 这种可以前台运行的程序,这里特别推荐 tail ,然后持续输出你的log文件.&lt;br/&gt;还是以上文的web容器为例,我们还可以写成:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service nginx start &amp;amp;&amp;amp; service php5-fpm start &amp;amp;&amp;amp; tail -f /var/log/nginx/error.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把这条命令加到start.sh实现自启&lt;/p&gt;
&lt;p&gt;参考链接&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/13d5912a6417&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/13d5912a6417&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_32434307/article/details/79480036&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_32434307/article/details/79480036&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/wang_quan_li/article/details/48003811&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wang_quan_li/article/details/48003811&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/&quot; class=&quot;uri&quot;&gt;https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 15:45:00 +0000</pubDate>
<dc:creator>晓枫v5</dc:creator>
<og:description>nginx解析漏洞，配置不当，目录遍历漏洞复现 1.Ubuntu14.04安装nginx php5 fpm 安装了nginx，需要安装以下依赖 安装php： 开启 Nginx对php的支持 ，去掉配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hackxf/p/10051732.html</dc:identifier>
</item>
<item>
<title>错误的理解引起的bug async await 执行顺序 - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/10041941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/10041941.html</guid>
<description>&lt;p&gt;今天有幸好碰到一个bug，让我知道了之前我对await async 的理解有点偏差。&lt;/p&gt;

&lt;p&gt;之前我一直以为  await 后面的表达式，如果是直接返回一个具体的值就不会等待，而是继续执行async function 中的函数， 如下demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; method () {
    getParams () {
      let params &lt;/span&gt;=&lt;span&gt; {}
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.serachFrom.time !== 0&lt;span&gt;) {
        params.month &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substr(5, 2&lt;span&gt;)
        params.year &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substring(0, 4&lt;span&gt;)
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; params
    },
    async testNoAwait () {
      console.log(&lt;/span&gt;'run testNoAwait'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'this is no await'&lt;span&gt;
    },
    async testAsync () {
      console.log(&lt;/span&gt;'run testAsync'&lt;span&gt;)
      let params &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getParams()
      const data &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;.$store.dispatch('initSchemeTimeTest'&lt;span&gt;, params)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
    },
    async test () {
      console.log(&lt;/span&gt;'test start'&lt;span&gt;)
      const v1 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testNoAwait()
      console.log(v1)
      const v2 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testAsync()
      console.log(v2)
      console.log(v1, v2)
    }
},
 created () {
    console.log(&lt;/span&gt;'this is run created '&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.test()
    console.log(&lt;/span&gt;'test last ...'&lt;span&gt;)
    console.log(&lt;/span&gt;'test end ...'&lt;span&gt;)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如上程序我之前认为   await this.testNoAwait() 会直接执行完不会等待，继续执行   console.log(v1)，如果这样那么是一个错误的理解。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上MDN描述的暂停执行，并不是真正的暂停，而是&lt;strong&gt;让出了线程（跳出async函数体）&lt;/strong&gt;然后继续执行后面的语句。&lt;/p&gt;

&lt;h2&gt;vue  created &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async created () {
    console.log(&lt;/span&gt;'this is run created '&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.test()
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; let data = this.test()&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(data)&lt;/span&gt;
    console.log('test last ...'&lt;span&gt;)
    console.log(&lt;/span&gt;'test end ...'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testSayHello()
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;vue  methods &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;testSayHello () {
      console.log(&lt;/span&gt;'this is run hello'&lt;span&gt;)
    },
    getParams () {
      let params &lt;/span&gt;=&lt;span&gt; {}
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.serachFrom.time !== 0&lt;span&gt;) {
        params.month &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substr(5, 2&lt;span&gt;)
        params.year &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substring(0, 4&lt;span&gt;)
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; params
    },
    testNoAwait () {
      console.log(&lt;/span&gt;'run testNoAwait'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'this is no await'&lt;span&gt;
    },
    async testAsync () {
      console.log(&lt;/span&gt;'run testAsync'&lt;span&gt;)
      let params &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getParams()
      const data &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;.$store.dispatch('initSchemeTimeTest'&lt;span&gt;, params)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
    },
    async test () {
      console.log(&lt;/span&gt;'test start'&lt;span&gt;)
      const v1 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testNoAwait()
      console.log(v1)
      const v2 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testAsync()
      console.log(v2)
      console.log(v1, v2)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;vuex 中&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// actions&lt;br/&gt;async initSchemeTimeTest ({commit, state, dispatch}, params) {
    console.log(&lt;/span&gt;'run initSchemeTimeTest'&lt;span&gt;)
    const data &lt;/span&gt;=&lt;span&gt; await schemeListTest(params)
    console.log(&lt;/span&gt;'开始返回结果'&lt;span&gt;)
    commit(types.SCHEME_DATA_TIME_LIST, data)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;services api 中&lt;/h2&gt;
&lt;p&gt;注意在 testAsync 中  dispatch 了 initSchemeTimeTest，然后在调用了服务端的 schemeListTest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; schemeListTest (params) {
  console.log(&lt;/span&gt;'this is run server'&lt;span&gt;)
  const data &lt;/span&gt;= await postTest(`/provid/spot/dailydeclareschemestatus/&lt;span&gt;list`, params)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;common 中封装的 axiosServer &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; postTest (url, params) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(async (resolve, reject) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;'this is run common'&lt;span&gt;)
      const {
        data:
          {
            respHeader,
            respBody
          }
      } &lt;/span&gt;=&lt;span&gt; await axiosServer({
        url,
        type: &lt;/span&gt;'post'&lt;span&gt;,
        params: {
          reqBody: params
        }
      })
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respHeader.needLogin &amp;amp;&amp;amp; process.env.NODE_ENV !== 'development'&lt;span&gt;) {
        Message.error(respHeader.message)
        location.href &lt;/span&gt;= condition.frontDomain + `/login?redirect=${encodeURI(condition.frontDomain + '/spot/race')}`
&lt;span&gt;        reject(respHeader.message)
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respHeader.resultCode === 0&lt;span&gt;) {
        resolve(respBody &lt;/span&gt;||&lt;span&gt; respHeader.message)
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respHeader.resultCode === 21050 &amp;amp;&amp;amp;&lt;span&gt; respBody) {
          Message.error(respHeader.message)
          resolve(respBody)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (respHeader.message === '您没有该应用的权限'&lt;span&gt;) {
          location.href &lt;/span&gt;= 'frame.huidiancloud.com'&lt;span&gt;
        }  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          Message.error(respHeader.message)
          reject(respHeader.message)
        }
      }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
      reject(e)
      Message.error(&lt;/span&gt;'系统繁忙，请稍后再试！'&lt;span&gt;)
    }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果按照之前的理解那么这个应该是输出了 run testNoAwait  之后继续输出  this is no await 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/825196/201811/825196-20181130225158306-1495585640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;js是单线程（同时只能干一件事情），&lt;/p&gt;
&lt;p&gt;以上测试的关键点在于当程序碰到await 时，把后面的表达式执行一次，然后把&lt;span&gt;resolve 函数或者reject 函数&lt;/span&gt;&lt;span&gt;（await 操作符会把表达式的结果解析成promise 对象） push 回调队列&lt;/span&gt;，接着跳过当前这个async function ，执行async function 后面的代码，如上面代码中，执行 this.testNoAwait() 之后就跳过 this.test()这个方法，执行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log('test last ...'&lt;span&gt;)
console.log(&lt;/span&gt;'test end ...'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testSayHello()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于什么时候知道这个promise 对象的状态，这就是事件循环的事情了，监听到这个异步的状态事件改变时，如果执行环境栈是空的那么就会执行取出回调队列中的回调，推入执行环境栈，然后继续async function 后面的语句。&lt;/p&gt;
&lt;p&gt;vue 开始执行created 生命周期&lt;/p&gt;
&lt;p&gt;输出：this is run created&lt;/p&gt;
&lt;p&gt;输出：test start &lt;/p&gt;
&lt;p&gt;执行：testNoAwait  // &lt;span&gt;关键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出 ：run testNoAwait 之后 &lt;span&gt;跳过 test() 函数 执行created 后面的语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：test last ... 、test end ... 、this is run hello &lt;/p&gt;
&lt;p&gt;程序回到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const v1 = await &lt;span&gt;this&lt;/span&gt;.testNoAwait()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果监听到这个异步事件完成 则开始执行 后面的代码所以会&lt;/p&gt;
&lt;p&gt;输出：this is no await&lt;/p&gt;
&lt;p&gt; 下面这个 await 跟上面同理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const v2 = await &lt;span&gt;this&lt;/span&gt;.testAsync()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;await 后面的表达式执行一次，如果里面存在await 也是同理继续执行下去，执行完之后，跳过这个async function 等到异步操作完成了继续回到 const v2 这里执行。&lt;/p&gt;
&lt;p&gt;这里需要注意的是在common 中的postTest 中&lt;span&gt;构造的Promise 对象是立即执行传入的function&lt;/span&gt; 所以在 services api 输出了 this is run server  之后接着输出 this is run common&lt;/p&gt;
&lt;p&gt;因为上面的列子不是很方便看，所以我写了一个简单的测试 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; name=&quot;viewport&quot;&amp;gt;
  &amp;lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&amp;gt;
  &amp;lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&amp;gt;
  &amp;lt;meta content=&quot;telephone=no,email=no&quot; name=&quot;format-detection&quot;&amp;gt;
  &amp;lt;meta name=&quot;App-Config&quot; content=&quot;fullscreen=yes,useHistoryState=yes,transition=yes&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
  &amp;lt;title&amp;gt;async await demo&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;async await demo&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;

  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async1() {
    console.log(&lt;/span&gt;'async1 start'&lt;span&gt;)
    await async2()
    console.log(&lt;/span&gt;'async1 end'&lt;span&gt;)
  }
  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async2() {
    console.log(&lt;/span&gt;'async2'&lt;span&gt;)
    await async3()
  }
  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async3() {
    console.log(&lt;/span&gt;'async3'&lt;span&gt;)
    await async4()
    console.log(&lt;/span&gt;'async4 end'&lt;span&gt;)
  }
  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async4() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
    console.log(&lt;/span&gt;'async4'&lt;span&gt;)
    resolve()
  })
  }
  console.log(&lt;/span&gt;'script start'&lt;span&gt;)
  setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;'setTimeout'&lt;span&gt;)
  }, &lt;/span&gt;0&lt;span&gt;)
  async1();
  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
    console.log(&lt;/span&gt;'promise1'&lt;span&gt;)
    resolve();
  }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;'promise2'&lt;span&gt;)
  })
  console.log(&lt;/span&gt;'script end'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; script start async1 start async2 async3 async4 promise1  script end promise2 async4 end async1 end setTimeout&lt;/span&gt;

&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;事件循环机制&lt;/li&gt;
&lt;li&gt;回调队列&lt;/li&gt;
&lt;li&gt;执行环境栈、入栈、出栈&lt;/li&gt;
&lt;li&gt;Promise 的构造函数是立即执行，但是他的成功、失败的回调函数是一个异步执行的回调&lt;/li&gt;
&lt;li&gt;Promise 的回调优先于 setTimeout 的任务队列&lt;/li&gt;
&lt;li&gt;async 返回promise 对象&lt;/li&gt;
&lt;li&gt;await 表达式的作用和返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、js 是单线程（同时只能做一件事情），在js引擎内部异步的处理是跟事件循环机制、以及回调队列有关&lt;/p&gt;
&lt;p&gt;2、构造的promise 对象是立即执行传入的function&lt;/p&gt;
&lt;p&gt;3、async function 是返回一个promise 对象&lt;/p&gt;
&lt;p&gt;4、await 操作符会把表达式的结果进行解析成promise 对象&lt;/p&gt;

</description>
<pubDate>Sat, 01 Dec 2018 15:22:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<og:description>今天有幸好碰到一个bug，让我知道了之前我对await async 的理解有点偏差。 错误的理解 之前我一直以为 await 后面的表达式，如果是直接返回一个具体的值就不会等待，而是继续执行async</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/10041941.html</dc:identifier>
</item>
<item>
<title>Java Monitoring&amp;Troubleshooting Tools - Hopkins'Cybernetics</title>
<link>http://www.cnblogs.com/HopkinsCybn/p/10051603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HopkinsCybn/p/10051603.html</guid>
<description>&lt;p&gt;&lt;u&gt;You can use the following tools to monitor JVM performance statistics. The tools described in this section are unsupported and experimental, and should be used with that in mind. &lt;span&gt;&lt;strong&gt;They may not be available in future JDK versions&lt;/strong&gt;&lt;/span&gt;.&lt;br/&gt;These tools are supported on all platforms except Windows 98 and Windows ME.&lt;br/&gt;&lt;/u&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jps&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental: JVM Process Status Tool - Lists instrumented HotSpot Java virtual machines on a target system.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jstat&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental: JVM Statistics Monitoring Tool - Attaches to an instrumented HotSpot Java virtual machine and collects and logs performance statistics as specified by the command line options.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;jstatd&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental: JVM jstat Daemon - Launches an RMI server application that monitors for the creation and termination of instrumented HotSpot Java virtual machines and provides a interface to allow remote monitoring tools to attach to Java virtual machines running on the local system.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;&lt;u&gt;Troubleshooting Tools&lt;br/&gt;The following tools can be used for specific troubleshooting tasks. The tools described in this section are unsupported and experimental in nature and should be used with that in mind. &lt;span&gt;&lt;strong&gt;They may not be available in future JDK versions&lt;/strong&gt;&lt;/span&gt;.&lt;br/&gt;Some of these tools are not currently available on Windows platforms.&lt;/u&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jinfo&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Configuration Info for Java - Prints configuration information for a given process or core file or a remote debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;jhat&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Heap Dump Browser - Starts a web server on a heap dump file (for example, produced by jmap -dump), allowing the heap to be browsed.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jmap&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Memory Map for Java - Prints shared object memory maps or heap memory details of a given process or core file or a remote debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jsadebugd&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Serviceability Agent Debug Daemon for Java - Attaches to a process or core file and acts as a debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jstack&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Stack Trace for Java - Prints a stack trace of threads for a given process or core file or remote debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sat, 01 Dec 2018 15:09:00 +0000</pubDate>
<dc:creator>Hopkins&amp;#39;Cybernetics</dc:creator>
<og:description>You can use the following tools to monitor JVM performance statistics. The tools described in this s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HopkinsCybn/p/10051603.html</dc:identifier>
</item>
<item>
<title>《数据结构与算法之美》- 栈 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/algo-stack.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/algo-stack.html</guid>
<description>&lt;p&gt;栈，在这里说的是一种数据结构。&lt;/p&gt;
&lt;h3 id=&quot;你还可能知道的栈&quot;&gt;你还可能知道的栈&lt;/h3&gt;
&lt;p&gt;提到“栈”，做Java的同学还会想起Java内存模型中的“栈”，与之紧密关联的还有一个名词——堆，但是这里，此栈非彼栈。&lt;/p&gt;
&lt;p&gt;引用《深入理解Java虚拟机》中有关栈的介绍&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;局部变量表存放了编译可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个只想对象起始地址的引用指针，也可能是指向一个对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说人话就是，Java内存结构中的一部分，线程私有，用来存储指定的数据类型数据。&lt;/p&gt;
&lt;h3 id=&quot;栈是什么&quot;&gt;栈是什么&lt;/h3&gt;
&lt;p&gt;栈是一种数据结构，它有自己的特点&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它是一种线性表，同为线性表的还有之前说到的数组和链表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;它操作受限，具体表现在先进后出，后进先出，只能在一端进行数据的插入和删除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于以上两点，大概就能勾勒出栈的模样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224002074-766097680.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;栈的应用&quot;&gt;栈的应用&lt;/h3&gt;
&lt;p&gt;经常听到有很多人抱怨说（也包括我~~~），如果知道这门课这么重要，我当时拼死老命也要把它学好。&lt;/p&gt;
&lt;p&gt;还记得当时看吴恩达的《machine learning》，在前几节课里展示了如何使用聚类算法进行图像处理，如果使用增强学习算法让一个模型飞机飞起来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224010930-1238448179.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224018658-2096505422.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，我们来看下栈有什么应用&lt;/p&gt;
&lt;h4 id=&quot;栈在表达式求值中的应用&quot;&gt;栈在表达式求值中的应用&lt;/h4&gt;
&lt;p&gt;给出一个表达式“3+5*8-6”，如果让你算，想必难不倒你。&lt;/p&gt;
&lt;p&gt;交给机器做，肯定也难不倒它，机器甚至可以做更加复杂的你做不到的运算。&lt;/p&gt;
&lt;p&gt;但是机器底层是怎么做的，如果不给定规则，它并不知道加减乘除是什么，也不知道他们的优先级顺序。所以，这时候栈就排上了用场。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;p&gt;准备两个栈，一个用来存储需要运算的数字，一个用来存储运算符号。&lt;/p&gt;
&lt;p&gt;数字栈按照从左到右的顺序入栈，符号栈也是如此，只是除此之外还多了一个规则限定。&lt;/p&gt;
&lt;p&gt;当新入栈的符号优先级比当前栈顶符号的优先级高的时候，继续入栈；当比栈顶符号优先级低或者相同时，则取出当前栈顶符号，同时取出数字栈的操作数字进行运算，将运算后的结果压栈，直至两个栈元素全部弹出。&lt;/p&gt;
&lt;p&gt;具体看专题中给出的过程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224028549-204281758.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;栈在括号匹配中的应用&quot;&gt;栈在括号匹配中的应用&lt;/h4&gt;
&lt;p&gt;给出一串“{(({[{{}}]}))}”，需要校验这串表达式中是否能前后一一匹配。&lt;/p&gt;
&lt;p&gt;没错，这个也可以利用栈的特性解决。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;p&gt;从左到右扫描表达式，对于左括号入栈，遇到右括号则取出当前栈顶元素，如果发现匹配，则取出栈顶元素继续匹配。&lt;/p&gt;
&lt;p&gt;当所有字符串匹配完成，并且栈最后是空栈，说明字符串可以正确匹配。&lt;/p&gt;
&lt;h3 id=&quot;栈在浏览器前进后退中的应用&quot;&gt;栈在浏览器前进后退中的应用&lt;/h3&gt;
&lt;p&gt;在浏览器中，我们可以通过前进后退回到自己想要的网页。&lt;/p&gt;
&lt;p&gt;这个功能也是可以通过栈来实现的，具体做法：&lt;/p&gt;
&lt;p&gt;准备两个栈，一个用于存放前进栈的网页ID，一个用于存放后退栈的网页ID。当需要前进的时候，从前进栈取出栈顶元素，并将该元素放入后退栈中；&lt;/p&gt;
&lt;p&gt;当需要后退的时候，从后退栈取出栈顶元素，并将该元素放入前进栈中。&lt;/p&gt;
&lt;p&gt;具体实现参见项目rome中的BackAndForwardUtil和BackAndForwardUtilDemo类&lt;/p&gt;
&lt;h3 id=&quot;如何实现一个栈&quot;&gt;如何实现一个栈&lt;/h3&gt;
&lt;p&gt;采用链表接口实现一个栈结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.algo.geek.time.chapter8_stack;

/**
 * @Author: Jackie
 */
public class Stack {
    private Node top = null;

    /**
     * 压栈
     * @see com.jackie.algo.geek.time.chapter6_linkedlist.LinkedList 中的insertToHead方法和这里的push思想类似
     *
     * |------|
     * | node | 上移后的top在这个位置
     * |------|
     * |   p  | 一开始top在这里，经过node.next = top绑定了node和p关系后，又通过top = node，则将top上移
     * |------|
     * |  ... |
     * |------|
     *
     */
    public void push(int value) {
        Node node = new Node(value, null);

        if (top == null) {
            top = node;
        } else {
            node.next = top;
            top = node;
        }
    }
    /**
     * 出栈
     */
    public int pop() {
        if (top == null) {
            return -1;
        }
        int value = top.value;
        top = top.next;

        return value;
    }
    public void printAll() {
        Node p = top;
        while (p != null) {
            System.out.print(p.value + &quot; &quot;);
            p = p.next;
        }
        System.out.println();
    }
    public static class Node {
        private int value;

        private Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体参见项目&lt;a href=&quot;https://github.com/DMinerJackie/rome/tree/master/algo/geek-time-algo&quot;&gt;rome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 14:51:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>介绍数据结构栈以及栈的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/algo-stack.html</dc:identifier>
</item>
<item>
<title>程序员英语二三事(1) - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/English-Of-Software-Engineer-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/English-Of-Software-Engineer-1.html</guid>
<description>&lt;p&gt;前段时间我在广州.NET微软技术俱乐部微信群里面教过大家几个程序员英语题, 因为当时是看到有人在群里招聘, 发的招聘简介全是英文. 所以即兴教了几个程序员方面的英语题. 因为是即兴和群聊的缘故,我并没有全面的解析这几道英语题, 为了怕大家把我教的这几道英语题用在错误的地方, 所以我专门写了这篇文章.&lt;/p&gt;

&lt;p&gt;这几道英语题分别是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;“你很胖”和”圣诞快乐&quot;用英语应该这么说?&lt;/li&gt;
&lt;li&gt;别人说Thank you, 你应该怎么回答?&lt;/li&gt;
&lt;li&gt;Skype应该怎么念? &lt;/li&gt;
&lt;li&gt;awesome是什么意思?&lt;/li&gt;
&lt;li&gt;Make sense是什么意思?&lt;/li&gt;
&lt;li&gt;lovelace是什么意思?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在详细解答以上英语题之前, 我必须说明, 世界上任何语言\技术\工具都是有对应的应用场景和上下文环境的. 比如:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Angular/React/Vue都是很好的JS框架, 但是你客户要求支持IE6, 那么抱歉, 这些这么好的JS框架都满足不了这个需求.&lt;/li&gt;
&lt;li&gt;潮汕人为何当不了太监？原因是派他侍候皇帝用膳，他准备妥贴之后高声跪喊：皇上啊......驾崩了！(吃饭了，潮汕话叫食饭了，音为：jiag ben le）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我对这些英语题的解答都是有适用环境的.&lt;/p&gt;

&lt;p&gt;我为什么会教大家这些英语题, 因为这些都来自我的实践经验, 我买过教训的.&lt;/p&gt;

&lt;p&gt;在我去硅谷的第二天, 我还不熟悉办公室环境, 一上班刚进办公楼, 就问前台厕所在哪里, where is W.C? 结果美国人根本就没听过W.C 这个词, 不知道是啥, 再加上我是刚进办公楼, 以为我是游客, 于是把我审问了一顿, 最后我不得不打同事电话让同事领我进去.&lt;/p&gt;

&lt;p&gt;然后同事问我how are you? 我条件反射般超快的回答I am fine, thank you , and you? 结果同事哈哈大笑, 问, 是不是刚到美国的中国人都是这样的啊.&lt;/p&gt;

&lt;p&gt;我的这些都是中国教科书上的回答, 然而好像在硅谷是doesn’t work. 后来我才弄清楚了.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;英国和美国都不讲W.C, 只有在欧洲大陆的非英语国家讲起英语才会用W.C这个词.&lt;/li&gt;
&lt;li&gt;别人问how are you其实就是个打招呼, 结果我还超严肃的背教科书, 气氛都被搞得怪怪的, 同事自然会哈哈大笑.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我想很多同学都对此深有体会, 都读了9年英语, 但是看到英文的招聘启事却不敢应聘.&lt;/p&gt;

&lt;p&gt;好了, 说完背景知识, 开始解答英语题了.&lt;/p&gt;

&lt;ol readability=&quot;21.5&quot;&gt;&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;“你很胖”和”圣诞快乐&quot;用英语应该这么说?&lt;/p&gt;
&lt;p&gt;很多人会答You are fat和Merry Christmas. 这些回答在美国以外好像没问题, 但是在美国这些回答是十分危险, 至于为啥十分危险, 咳咳, 这就涉及到很多背景知识了, 总之你翻遍所有新闻, 是不会出现这些说法的, 因为这些说法曾经引起过官司, 特别是在硅谷, 因为硅谷是在深蓝色的加州. 大家知道回答”you are big”和”happy holiday”就可以了, 这样就降低了吃官司的概率.&lt;/p&gt;
&lt;p&gt;很多人对此表示不认同和不理解, 的确我也说过you are fat和Merry Christmas, 但是我一说出口就被同事哈哈一笑纠正过来了. 说白了, 我跑到异国他乡无非就是求过个安稳生活, 能尽量降低吃官司的概率当然是能尽量去降低啦.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;别人说Thank you, 你应该怎么回答?&lt;/p&gt;
&lt;p&gt;My pleasure是比较生疏的回答. 要想和同事拉近距离, sure是比较熟络的回答.&lt;/p&gt;
&lt;p&gt;这里有个适用场景的问题, 只适用于在美西地区的程序员. &lt;/p&gt;
&lt;p&gt;英语是世界使用人数最多和使用范围最广的语言, 比汉语还多. 既然汉语都有方言和口音. 英语也一样是有方言和口音的. 大家也许知道美式英语和英式英语是有区别. 然而英语的方言和口音远远不止这两种. 比如:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我到新加坡中部地区, 我发现服务员讲的英语我一句都听不懂, 我讲的英语服务员也一句都听不懂, 后来才知道新加坡的英语和英国英语是有很大区别的 (新加坡沿海地区则没有这种情况, 因为外国人多嘛.)&lt;/li&gt;
&lt;li&gt;美国东部(以纽约波士顿为代表)和美国西部(以硅谷西雅图为代表)的差别也很大, 美东以伦敦腔为荣, 美西以伦敦腔为耻. 所以sure这个回答在美西会让同事觉得你很哥们, 但是在美东却不大好使.&lt;/li&gt;
&lt;li&gt;比尔盖茨的传记有写: 微软早期的时候，从盖茨到下面的程序员都穿T恤，也以这样的文化为荣。但是，某一天微软接到通知IBM要跟他们谈一个大生意，那一次就是决定微软后来命运的那一次。比尔盖茨很重视，去谈判的全体都穿了西装，打了领带。到了IBM，却发现IBM为了表示对微软的重视，谈判的全体人员都穿了T恤。我想My pleasure和sure的区别就像这个故事里的一样, 实际上哪个回答更好真的是要看实际运用场景的. 我喜欢用sure, 因为觉得比较亲切和哥们.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;Skype应该怎么念? &lt;/p&gt;
&lt;p&gt;很多人念Sky pi. 特别是香港人. 这么念的人数多到Skype不得不在2008-2009年间在官网公告正确读音是Sky P.&lt;/p&gt;
&lt;p&gt;然而并没有什么用. 还是很多香港人会念Sky pi. 所以如果你是应聘香港的职位, 还是念Sky pi吧. 如果是应聘美国公司的职位, 还是念Sky P吧, 毕竟Skype都出过公告说这是正确读音了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;嗯, 很多同学会说以上三个问题其实答错了也没啥, 最多也就是吃官司的概率大一点. &lt;/p&gt;
&lt;p&gt;但是以下问题就涉及到听不听得懂的问题了. 毕竟你可以控制自己怎么回答, 你总不能控制别人怎么说话吧.&lt;/p&gt;

&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;awesome是什么意思?&lt;/p&gt;
&lt;p&gt;这个词在美西的程序员口中简直是口头禅啊. 你一查字典, 好像是贬义词. 然而其实别人不但没有贬低你的意思, 反而是赞扬你的意思. 就是说你很棒.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;Make sense是什么意思?&lt;/p&gt;
&lt;p&gt;这个词好像也是美国人的口头禅, 其实是和do you understand? 一个意思. 我回国后习惯性跟很多人说过这句话, 很多人都没反应过来, 都听不懂.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;lovelace是什么意思?&lt;/p&gt;
&lt;p&gt;这个就更狗血了. 一搜字典, 是色鬼的意思. 然而, 在程序员面试中提到这个词, 更多的是指世界第一个程序员ada lovelace. 就好像建筑行业的鲁班一样, ada lovelace是程序员的祖师爷.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我在硅谷做过面试官, 面试过美国人. 所以我知道, 以上3个问题中, 第1和第2个问题是大概率事件. 第3个问题虽然是小概率事件, 然而一般能问出这个问题很大概率是资深技术狂热粉丝(甚至有种宗教般的狂热), 甚至对你已经很认同了, 然而你却不知道lovelace是啥, 连祖师爷都不知道啊, 你在他心目中的分数可是会狂掉啊.&lt;/p&gt;

&lt;p&gt;好啦, 说到这里, 相信大家应该很清楚了, 我教的这些英语都是有特定应用场景的, 主要是针对程序员面试用的. 可不要用错地方哦, 用错地方可是会适得其反的哦.&lt;/p&gt;

&lt;p&gt;最后, 相信大家都清楚了, 实践证明, .NET的好工作一点都不比Java少, 然而好工作都是需要英语的. 我们广州.NET微软技术俱乐部将会持续的在帮助大家找到.NET好工作的道路上前进!&lt;/p&gt;

&lt;p&gt;谢谢大家.&lt;/p&gt;

&lt;p&gt;对了, 为了适应时代的发展, 广州.NET俱乐部已经更名为广州.NET微软技术俱乐部. 所以广州.NET俱乐部和广州.NET微软技术俱乐部是同一回事哦. &lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 14:49:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>实践证明, .NET的好工作一点都不比Java少, 然而好工作都是需要英语的. 我们广州.NET微软技术俱乐部将会持续的在帮助大家找到.NET好工作的道路上前进!</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adalovelacer/p/English-Of-Software-Engineer-1.html</dc:identifier>
</item>
<item>
<title>Java并发专题（二）线程安全 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10049342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10049342.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　随着时代的发展，CPU核数的增加和计算速度的提升，串行化的任务执行显然是对资源的极大浪费，掌握多线程是每个程序员必须掌握的技巧。但是同时多线程也是一把双刃剑，带来了共享资源安全的隐患。在本节会介绍线程安全是什么、最基本的独占悲观式来保证线程安全的介绍。随着章节步步深入。&lt;/p&gt;

&lt;h2&gt;1.1 什么是线程安全？&lt;/h2&gt;
&lt;h3&gt;1.1.1 初识线程安全的尴尬&lt;/h3&gt;
&lt;p&gt;　　本人是17年毕业的，刚进第一家公司的时候没有开发经验，对接第三方支付公司外部API压测的时候碰到一个问题：对方要求我5次/s，一共发300s的付款请求。其中一个请求的id，保证当日每一次唯一。我请求的id从1开始递增，但是总是也达不到300*5=1500。也闹出了很尴尬的笑话。这是我第一次接触多线程。为了简化问题，例子如下：2个线程对一个数字递增加2000次，看看是否最后是2000。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 多线程递增某一个数字的测试类。
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnsafeAdd {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getNext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        UnsafeAdd multiAdd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsafeAdd();

        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 1000; i++&lt;span&gt;) {
                multiAdd.getNext();
            }
        });

        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 1000; i++&lt;span&gt;) {
                multiAdd.getNext();
            }
        });

        thread1.start();
        thread2.start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请结合上一章节体会为何写下面2行&lt;/span&gt;
&lt;span&gt;        thread1.join();
        thread2.join();

        System.out.println(multiAdd.i);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行的结果99%都不是自己想要的结果，说明这边出现了线程安全的问题。除了这个例子相信很多同学都会听到类似这种话&quot;&lt;span&gt;HashMap不是线程安全的&lt;/span&gt;&quot;、&quot;&lt;span&gt;不可变对象一定是线程安全的&lt;/span&gt;&quot;等等。这些都是在说线程安全方面的话题，之后的源码分析专题会分析为什么HashMap不是线程安全的，取而代之的ConcurrentHashMap如何保证线程安全的？同时JDK6引入ConsurrentSkipListMap和ConcurrentSkipListSet分别作为同步的SortedMap和SortedSet的并发替代品，还有用synchronizedxxx()方法包装的Map。&lt;/p&gt;
&lt;h3&gt;1.1.2 线程安全的概念&lt;/h3&gt;
&lt;p&gt;　　对于线程安全的概念，参考《Java Concurrency in Practice》中的一句对线程安全的定义：&lt;span&gt;当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.1.3 Race condition（竞态条件）&lt;/h3&gt;
&lt;p&gt;　　现在我们来分析一下上面的数据不一致问题，这种情况成为竞态条件，为什么会出现这个问题？UnsafeAdd的问题在于，线程的执行是由CPU时间片轮询调度的，如果执行的时机不对，那么可能在调用getNext()方法的时候得到一样的值、或者某些值被忽略等。主要是i++;看起来是一个原子操作，但是它包含了3个独立的操作：读取i，将i+1，并将计算结果写入i。简单画一张图，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201812/1465200-20181201140944960-1782726531.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　线程A和线程B可能都读到i的变量为10，所以可能导致重复的情况，造成达不到2000的效果。&lt;/p&gt;

&lt;h2&gt;1.2 初识保证线程安全的基本方法&lt;/h2&gt;
&lt;h3&gt;1.2.1 synchronized关键字&lt;/h3&gt;
&lt;p&gt;　　什么是synchronized？引入一段来自JDK官网对synchronized关键字比较权威的解释：Synchronized keyword enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object's variables are done through synchronized methods. 如果一个对象对多线程是可见的，那么对改对象的读写操作都将通过同步的方式进行。网上对他的讲解千千万，很多都是一样的。接下来讲一下我对他的具体表现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;synchronized关键字用到的是monitor enter和monitor exit两个&lt;span&gt;JVM指令（请用javap命令自行研究），且遵循happens-before规则。&lt;/span&gt;能保证在monitor enter，获取到锁之前必须从主内存获取数据，而不是线程的本地内存。在monitor exit之后变量会刷新到主内存。（&lt;span&gt;这里和上面的图都涉及到JMM模型，这是并发的基础，后面章节会详细介绍&lt;/span&gt;）&lt;/li&gt;
&lt;li&gt;“synchronized是一把锁”，这种理解是不严谨的。准确的来说是&lt;span&gt;某线程获取了对象的monitor锁，在没有释放该锁之前，其他线程在同一时刻无法获取该锁&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;synchronized可以用于对代码块或者方法进行修饰，不能对变量进行修饰&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如果要解决之前的问题，那么在getNext()方法上加上synchronized关键字就可以解决了问题。原因就是上面提到的，当某个线程获取了monitor锁，那么其他线程是无法获取锁的。也就是说其他线程都无法执行该方法，直到其他线程放弃该锁。每一个内置锁都有且只能有一个相关联的条件队列（&lt;span&gt;这里的设计是否好呢？&lt;/span&gt;），当一个线程获取锁进行操作的时候，其他线程都在这个队列里等待该锁。那么解决掉问题也了解最基本的保证线程安全的方法之后，我们来看一下JDK对synchronized的优化以及synchronized的弊端。&lt;/p&gt;
&lt;h3&gt;1.2.2 synchronized的优化&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;自旋锁&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;自旋锁在JD&lt;span&gt;K1.4引入，在JDK1.&lt;/span&gt;6默认开启。自旋锁到底是什么呢？之前我们说的互斥锁对性能的影响很大，Java线程是映射到操作系统的原生线程上的，&lt;span&gt;如果要阻塞或者唤醒一个线程就需要操作系统的帮助，因此状态转换需要花费很多CPU时间。&lt;/span&gt;因为锁定的状态一般只会持续很短很短的时间，为了这段时间去挂起然后再唤醒是很不值得的。如果服务器有多个处理器，我们就可以让后面的线程稍微等等，&lt;span&gt;但是并不放弃CPU执行时间，&lt;span&gt;这个稍微等等的过程就是自旋。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自旋锁和阻塞锁很大的区别就是是否要放弃CPU执行时间&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;锁消除&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;锁消除是JIT编译器对锁的具体实现所做的一种优化，如果同步块所使用的锁对象通过逃逸分析出只有一个线程会访问，那么JIT编译器在编译这个同步块的时候会消除同步&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;锁粗化
&lt;ul&gt;&lt;li&gt;如果在一段代码中对一个对象反复加锁解锁，那么会放宽锁的范围，减少性能消耗。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 如以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100000;i++&lt;span&gt;){  
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){  
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;();  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;粗化成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){  
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100000;i++&lt;span&gt;){  
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;();  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.2.3 synchronized的死穴：锁是慢的&lt;/h3&gt;
&lt;p&gt;　　虽然内置锁优化至今已经和显式锁相差无几，但是，它的死穴就是：锁是慢的。让我们来做一个实验，一个单线程对一个数字相加1kw次，加锁和不加锁的时间的对比。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 对比有无锁的测试类。
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CompareLockTest {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; y = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addWithNoLock() {
        i&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addWithLock() {
        y&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no lock&lt;/span&gt;
        CompareLockTest noLockTest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompareLockTest();
        StopWatch stopWatch &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StopWatch();

        stopWatch.start();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = 0; index &amp;lt; 10000000; index++&lt;span&gt;) {
            noLockTest.addWithNoLock();
        }
        stopWatch.stop();
        System.out.println(&lt;/span&gt;&quot;no lock: &quot; +&lt;span&gt; stopWatch.getTotalTimeMillis());


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; with lock&lt;/span&gt;
&lt;span&gt;        stopWatch.start();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = 0; index &amp;lt; 10000000; index++&lt;span&gt;) {
            noLockTest.addWithLock();
        }
        stopWatch.stop();
        System.out.println(&lt;/span&gt;&quot;with lock: &quot; +&lt;span&gt; stopWatch.getTotalTimeMillis());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果不加锁的大概是7毫秒，加锁大概是250毫秒。这还只是单线程，如果是多线程呢？&lt;span&gt;并发很难而锁的性能糟糕。&lt;span&gt;线程就像是两兄弟为一个玩具争吵，操作系统就像是父母来决定他们谁拿玩具。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.2.4 如何加锁&lt;/h3&gt;
&lt;p&gt;　　我们碰到最多的问题就是若没有则添加，我们来看一个例子，先写一个错误的加锁方式，后写一个正确的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * list测试类。
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; list = Collections.synchronizedList(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;());

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 非线程安全
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; element
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; unsafePutIfAbsent(String element) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; absent = !&lt;span&gt;list.contains(element);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (absent) {
            list.add(element);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; absent;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 线程安全
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; element
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; safePutIfAbsent(String element) {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (list) {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; absent = !&lt;span&gt;list.contains(element);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (absent) {
                list.add(element);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; absent;
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...其他对list操作的方法&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个方法为何不是线程安全的？方法不是也已经用synchronized修饰了么？这个list也是线程安全的。对不对？&lt;span&gt;问题在于在错误的锁上进行了同步，只是带来了同步的假象&lt;/span&gt;，这就意味着该方法相对于List的其他操作来说并不是原子的。因此无法确保当方法执行的时候，另外一个线程不会修改链表。&lt;/p&gt;
&lt;p&gt;　　第二个方法是正确的线程安全的，最重要的是因为list在外部加锁时要使用同一个锁。对于使用list的代码，使用list本身用于保护其状态的锁来保护这段代码。&lt;span&gt;说白了就是你要知道你获取的什么锁，锁的是什么对象，这个是一定要搞清楚的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;1.3 死锁&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;1.3.1 死锁的介绍&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　在多线程访问共享资源的情况下，如果对线程驾驭不当很容易引起死锁的情况发生。死锁又分：交叉锁、数据库锁等。比如说数据库锁，如果A线程执行了select xxx for update语句退出了事务，那么别的线程访问都将陷入死锁。简而言之，死锁说白了就是“我在等你，你也在等我”。还是写个例子吧。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 死锁测试类。
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeadLockTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Object a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
        Object b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (a) {
                System.out.println(&lt;/span&gt;&quot;已经锁住a了&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (b){
                    System.out.println(&lt;/span&gt;&quot;同时锁住a和b了&quot;&lt;span&gt;);
                }
            }
        }).start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (b) {
                System.out.println(&lt;/span&gt;&quot;已经锁住b了&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (a){
                    System.out.println(&lt;/span&gt;&quot;同时锁住a和b了&quot;&lt;span&gt;);
                }
            }
        }).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果A线程已经获取a对象的锁，现在想要获取b对象的锁。此时B线程已经获取b对象的锁，想要获取a对象的锁。那么如果两个线程都不释放已经持有对象的锁，大家都无法拿到第二个对象的锁。如果程序出现死锁，可以利用jstack等工具进行分析。&lt;/p&gt;

</description>
<pubDate>Sat, 01 Dec 2018 14:46:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 随着时代的发展，CPU核数的增加和计算速度的提升，串行化的任务执行显然是对资源的极大浪费，掌握多线程是每个程序员必须掌握的技巧。但是同时多线程也是一把双刃剑，带来了共享资源安全的隐患。在本节会介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10049342.html</dc:identifier>
</item>
<item>
<title>MySQL导入导出实践 - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/10051338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/10051338.html</guid>
<description>&lt;p&gt;最近一次数据迁移，需要将MySQL的数据导出、处理后导入到新表和ES。这里做个简单记录，方便后续查询。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注: 为了写文章方便及隐私安全，实际内容会有所简化。例如表结构简化、数据库连接部分全部用 xxx 表示、目录及文件名均为化名等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实践过程&quot;&gt;实践过程&lt;/h2&gt;
&lt;p&gt;原表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;book_db 库
  - b_book(id,create_time,update_time,price,title,intro)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;book 库
  - book(id,price,title,create_time,update_time)
  - book_ext(id,book_id,intro,create_time)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mysql导出&quot;&gt;MySQL导出&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mkdir -p /tmp/

# 导出原始数据
mysql -hxxx -uxxx -pxxx book_db  --default-character-set=utf8  -e 'select id,create_time,update_time,price,title,intro from b_book' | sed 's/NULL//g'   &amp;gt; /tmp/b_book.csv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sed 's/NULL//g'&lt;/code&gt;是因为导出的数据有些字段存的NULL，新表不需要存储NULL，所以去掉。&lt;/p&gt;
&lt;p&gt;导出的数据每行默认以&lt;code&gt;\t&lt;/code&gt;分隔，第一行包含字段名。这里我们删掉第一行：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sed -i '1d' /tmp/b_book.csv&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据处理&quot;&gt;数据处理&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /tmp/

# 处理create_time,update_time,price，并生成文件 book.csv
cat b_book.csv | awk -F '\t' -v OFS=' @@@ ' '{gsub(/[-:]/,&quot; &quot;,$2); $2=mktime($2);gsub(/[-:]/,&quot;&quot;,$3);$3=mktime($3);$4=$4*100;$6=&quot;&quot;;print $0}' &amp;gt; book.csv

# 生成文件 book_ext.csv
cat b_book.csv | awk -F '\t' -v OFS=' @@@ ' '{print $1,$6}' &amp;gt; book_ext.csv

# 生成文件 book_es.csv
cat b_book.csv | awk -F '\t' -v OFS=' @@@ ' '{$4=$4*100;print $0}' &amp;gt; book_es.csv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为原表里时间都是datetime格式，新表是时间戳格式，这里处理成时间戳格式。价格原表是以元为单位，这里&lt;code&gt;*100&lt;/code&gt;是为了处理成以分为单位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-v OFS=' @@@ '&lt;/code&gt;表示输出的时候每列以&lt;code&gt;@@@&lt;/code&gt;为分隔符。原因是原表里的&lt;code&gt;intro&lt;/code&gt;字段存储的是html，可能包含常用转义字符，这里使用&lt;code&gt;@@@&lt;/code&gt;确保能正确分隔每列。&lt;/p&gt;
&lt;h3 id=&quot;导入到mysql&quot;&gt;导入到MySQL&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mysql -hxxx -uxxx -pxxx book&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;Load Data LOCAL InFile '/tmp/book.csv' Into Table book 
character set utf8 
Fields Terminated By ' @@@ ' Enclosed By '' Escaped By '' Lines Terminated By '\n'
(id,create_time,update_time,price,title);
 
Load Data LOCAL InFile '/tmp/book_ext.csv' Into Table book_ext 
character set utf8 
Fields Terminated By ' @@@ ' Enclosed By '' Escaped By '' Lines Terminated By '\n'
(book_id,intro);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Terminated 字段分隔符（列分隔符）。一般是空格或者&lt;code&gt;\t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Enclosed 字段括起字符。没有为空字符即可&lt;/li&gt;
&lt;li&gt;Escaped 转义字符。没有为空字符即可&lt;/li&gt;
&lt;li&gt;Terminated 记录分隔符（行结束符）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Into Table&lt;/code&gt; 代表插入，记录已存在（唯一键约束）则失败不再往下执行。&lt;code&gt;Replace Into Table&lt;/code&gt; 代表覆盖，记录已存在则覆盖（是整条记录覆盖，没有列出的字段给默认值）。&lt;code&gt;Ignore Into Table&lt;/code&gt; 遇到已存在直接跳过。&lt;/p&gt;
&lt;h3 id=&quot;导入到es&quot;&gt;导入到ES&lt;/h3&gt;
&lt;p&gt;由于生产的&lt;code&gt;book_es.csv&lt;/code&gt;文件比较大，所以这里按20000条生成一个文件，防止文件过大，ES导入失败。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /tmp/

awk '{filename = &quot;book_es.csv.&quot; int((NR-1)/20000) &quot;.csv&quot;; print &amp;gt;&amp;gt; filename}' book_es.csv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ConvertBookToEs.php&lt;/code&gt;是PHP脚本，生成ES批量导入的文件。见附录。执行后生成很多&lt;code&gt;book_es.csv.*.csv.json&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;php ConvertBookToEs.php&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;importToEs.sh&lt;/code&gt;是ES批量导入脚本，如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#!/bin/bash
for file in `ls /tmp/book_es.csv.*.csv.json` 
do
   echo $file;
   curl -XPOST http://xxx:9200/book/doc/_bulk -H &quot;Content-Type: application/json&quot; --data-binary &quot;@$file&quot;  &amp;gt;&amp;gt; importToEs.log
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行脚本：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sh importToEs.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待数分钟，便执行完毕了。&lt;/p&gt;
&lt;h2 id=&quot;实现mysql-load-data按字段更新&quot;&gt;实现MySQL LOAD DATA按字段更新&lt;/h2&gt;
&lt;p&gt;为了将大量数据加载到MySQL中，&lt;code&gt;LOAD DATA INFILE&lt;/code&gt;是迄今为止最快的选择。但是，虽然这可以以&lt;code&gt;INSERT IGNORE&lt;/code&gt;或&lt;code&gt;REPLACE&lt;/code&gt;的方式使用，但目前不支持&lt;code&gt;ON DUPLICATE KEY UPDATE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果我们想批量更新某个字段，&lt;code&gt;ON DUPLICATE KEY UPDATE&lt;/code&gt;如何使用&lt;code&gt;LOAD DATA INFILE&lt;/code&gt;模拟？&lt;/p&gt;
&lt;p&gt;stackoverflow 上有网友给了答案。步骤是：&lt;/p&gt;
&lt;p&gt;1）创建一个新的临时表。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TEMPORARY TABLE temporary_table LIKE target_table;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）从临时表中删除所有索引以加快速度。（可选）&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SHOW INDEX FROM temporary_table;

DROP INDEX `PRIMARY` ON temporary_table;
DROP INDEX `some_other_index` ON temporary_table;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）将CSV加载到临时表中&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;LOAD DATA INFILE 'your_file.csv'
INTO TABLE temporary_table
Fields Terminated By '\t' Enclosed By '' Escaped By '' Lines Terminated By '\n'
(field1, field2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）使用&lt;code&gt;ON DUPLICATE KEY UPDATE&lt;/code&gt;复制数据&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SHOW COLUMNS FROM target_table;

INSERT INTO target_table
SELECT * FROM temporary_table
ON DUPLICATE KEY UPDATE field1 = VALUES(field1), field2 = VALUES(field2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MySQL将假定&lt;code&gt;=&lt;/code&gt;之前的部分引用&lt;code&gt;INSERT INTO&lt;/code&gt;子句中指定的列，第二部分引用&lt;code&gt;SELECT&lt;/code&gt;列。&lt;/p&gt;
&lt;p&gt;5）删除临时表&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP TEMPORARY TABLE temporary_table;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;SHOW INDEX FROM&lt;/code&gt;和&lt;code&gt;SHOW COLUMNS FROM&lt;/code&gt;此过程可以针对任何给定的表自动执行。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：官方文档里 &lt;code&gt;INSERT ... SELECT ON DUPLICATE KEY UPDATE&lt;/code&gt;语句被标记为基于语句的复制不安全。所以上述方案请在充分测试后再实施。详见：&lt;br/&gt;https://dev.mysql.com/doc/refman/5.6/en/insert-on-duplicate.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;ConvertBookToEs.php&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
/**
 * 转换wish_book为ES 批量格式(json)
 */

//id,create_time,update_time,price,title,intro
function dealBook($file)
{
    $fp = fopen($file, 'r');
    while (!feof($fp)) {
        $line = explode(' @@@ ', fgets($fp, 65535));
        if ($line &amp;amp;&amp;amp; isset($line[1])) {
            $arr_head = [
                'index' =&amp;gt; [
                    '_id' =&amp;gt; (int)$line[0]
                ]
            ];
            $arr = [
                'id' =&amp;gt; (int)$line[0],
                'create_time' =&amp;gt; strtotime($line[1]),
                'update_time' =&amp;gt; strtotime($line[2]),
                'price' =&amp;gt; intval($line[3]),
                'title' =&amp;gt; (string)$line[4],
                'intro' =&amp;gt; (string)$line[18],
            ];

            file_put_contents($file . '.json', json_encode($arr_head, JSON_UNESCAPED_UNICODE) . PHP_EOL, FILE_APPEND);
            file_put_contents($file . '.json', json_encode($arr, JSON_UNESCAPED_UNICODE) . PHP_EOL, FILE_APPEND);
        }
    }

}

try {

    //处理CSV文件为es bluk json格式
    //参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/_batch_processing.html
    $files = glob(&quot;/tmp/book_es.csv.*.csv&quot;);
    if (false === $files) {
        exit(&quot;can not find csv file&quot;);
    }
    $pids = [];

    foreach ($files as $i =&amp;gt; $file) {
        $pid = pcntl_fork();
        if ($pid &amp;lt; 0) {
            exit(&quot;could not fork&quot;);
        }

        if ($pid &amp;gt; 0) {
            $pids[$pid] = $pid;
        } else {
            echo time() . &quot; new process, pid:&quot; . getmypid() . PHP_EOL;
            dealBook($file);
            exit();
        }
    }

    while (count($pids)) {
        foreach ($pids as $key =&amp;gt; $pid) {
            $res = pcntl_waitpid($pid, $status, WNOHANG);
            if ($res == -1 || $res &amp;gt; 0) {
                echo 'Child process exit,pid ' . $pid . PHP_EOL;
                unset($pids[$key]);
            }
        }
        sleep(1);
    }

} catch (Exception $e) {
    $message = $e-&amp;gt;getFile() . ':' . $e-&amp;gt;getLine() . ' ' . $e-&amp;gt;getMessage();
    echo $message;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、Linux命令行文本工具 - 飞鸿影~ - 博客园&lt;br/&gt;https://www.cnblogs.com/52fhy/p/5836429.html&lt;br/&gt;2、mysqldump 导出 csv 格式 --fields-terminated-by=, ：字段分割符； - superhosts的专栏 - CSDN博客&lt;br/&gt;https://blog.csdn.net/superhosts/article/details/26054997&lt;br/&gt;3、Batch Processing | Elasticsearch Reference [6.4] | Elastic&lt;br/&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/_batch_processing.html&lt;br/&gt;4、mysql导入数据load data infile用法整理 - conanwang - 博客园&lt;br/&gt;https://www.cnblogs.com/conanwang/p/5890753.html&lt;br/&gt;5、MySQL LOAD DATA INFILE with ON DUPLICATE KEY UPDATE - Stack Overflow&lt;br/&gt;https://stackoverflow.com/questions/15271202/mysql-load-data-infile-with-on-duplicate-key-update&lt;br/&gt;6、mysql - INSERT INTO ... SELECT FROM ... ON DUPLICATE KEY UPDATE - Stack Overflow&lt;br/&gt;https://stackoverflow.com/questions/2472229/insert-into-select-from-on-duplicate-key-update&lt;br/&gt;7、MySQL :: MySQL 5.6参考手册:: 13.2.5.2 INSERT ... ON DUPLICATE KEY UPDATE语法&lt;br/&gt;https://dev.mysql.com/doc/refman/5.6/en/insert-on-duplicate.html&lt;br/&gt;8、复制表结构和数据SQL语句 - becket - 博客园&lt;br/&gt;https://www.cnblogs.com/zhengxu/articles/2206894.html&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 14:26:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<og:description>最近一次数据迁移，需要将MySQL的数据导出、处理后导入到新表和ES。这里做个简单记录，方便后续查询。 注: 为了写文章方便及隐私安全，实际内容会有所简化。例如表结构简化、数据库连接部分全部用 xxx</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/10051338.html</dc:identifier>
</item>
<item>
<title>JavaScript基础--------三座大山（前端面试必考） - 帅气兆</title>
<link>http://www.cnblogs.com/zhaozhaoli/p/10051265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaozhaoli/p/10051265.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.原型和原型链&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.作用域和闭包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.异步和单线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;被称为JavaScript的三座大山&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;原型和原型链：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在JavaScript中，数组，对象和函数被称为引用类型，他们都有一个__proto__属性，该属性是一个对象（我们称之为隐式原型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483803/201812/1483803-20181201190912527-605020336.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;108&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;arr数组的构造函数是Array，Array构造函数中有一个prototype属性，（我们暂时称之为显式原型）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483803/201812/1483803-20181201191428745-541458800.png&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;arr是构造函数的实例对象，arr中的__proto__对象指向构造函数中的prototype对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483803/201812/1483803-20181201191635869-78679109.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;47&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来是一个简单的demo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个构造函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Animal(name){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Animal.prototype.eat = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             console.log('Animal--eat'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用new初始化一个Animal的实例对象&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; dog = &lt;span&gt;new&lt;/span&gt; Animal('xiaohuang'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        console.log(dog.name)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         console.log(dog.eat())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483803/201812/1483803-20181201192622886-1982897773.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;59&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下dog对象中有什么属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483803/201812/1483803-20181201192736609-1485429645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用dog的属性和方法时，会先从dog本身去查找，如果dog本身没有那个属性或方法，就会去dog的__proto__原型中去查找，而__proto__又指向Animal的prototype（看第二个constructor对象，指向Animal），这就是原型链&lt;/p&gt;
&lt;p&gt;再来一个demo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个构造函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Animal(name){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Hashiqi的构造函数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Hashiqi(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Animal.prototype.eat = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             console.log('Animal--eat'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Hashiqi.prototype.color = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             console.log('Hashiqi---color'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变prototype的指向&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         Animal.prototype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Hashiqi()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用new初始化一个Animal的实例对象&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; dog = &lt;span&gt;new&lt;/span&gt; Animal('xiaohuang'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        console.log(dog.name)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        console.log(dog.eat())
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         console.log(dog.color())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个demo中改变了Animal的prototype，将其指向一个Hashiqi的实例对象，我们来看结果。此时dog.eat()会报错，dog.color正常输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483803/201812/1483803-20181201194114779-1264245227.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三个demo，比较上档次一点&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;div id=&quot;wrapper&quot;&amp;gt;&lt;span&gt;this&lt;/span&gt; is wrapper&amp;lt;/div&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Elem的构造函数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Elem(id){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取dom元素&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;            &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; document.getElementById(id)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        Elem.prototype.html = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果val为空，则打印dom元素的innerhtml值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt;(val == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.id.innerHTML)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回this，可以用来进行链式操作&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;            }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                &lt;span&gt;this&lt;/span&gt;.id.innerHTML =&lt;span&gt; val
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定事件&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;        Elem.prototype.on = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(type, fn){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.id.addEventListener(type,fn)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;        
&lt;span&gt;24&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先new一个实例对象：　　var el = new Elem('wrapper')&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　el.html(' ookook ').on('click', function(){  console.log('this is ook') }  )&lt;/p&gt;
&lt;p&gt;接下来点击ookook就会打印this is ook&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 作用域和闭包：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JavaScript中有函数作用域和全局作用域（es6中用let声明的变量具有块作用域）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 函数作用域是在一个函数中有效，全局作用域在全局都有效&lt;/p&gt;
&lt;p&gt;*函数内部如果变量和全局变量重名了，则在该函数内部，以函数变量为准&lt;/p&gt;
&lt;p&gt;*函数外部无法访问函数内部定义的变量（该变量是函数私有的），不过函数内部可以访问函数外部的全局变量&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　1.变量提升&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;javascript中声明并定义一个变量时，会把声明提前，以下会先打印出undefined，再打印出10&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　　　　&lt;span&gt;console.log(a)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; a = 10
&lt;span&gt;3&lt;/span&gt;         console.log(a)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;相当于&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        console.log(a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         a = 10
&lt;span&gt;4&lt;/span&gt;         console.log(a)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数声明也是，以下函数相当于把整个fn提到作用域的最上面，所以调用fn时会正常打印jack&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fn('jack'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn (name){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            console.log(name)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过函数表达式不行，以下是一个函数表达式，JavaScript会把var fn提到作用域最上面，没有吧函数提上去，所以会报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fn(&quot;jack&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;       
&lt;span&gt;3&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; fn = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        console.log(name);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;       };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.闭包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;使用场景：1.函数作为参数传递　　2.函数作为返回值传递&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　三言两语说不清楚，我们来看一个demo&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F1(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; a = 100
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个函数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            console.log(a)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;       var a = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; f1 = F1(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将f1指向F1&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;       f1()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第11行输出结果是100&lt;/p&gt;
&lt;p&gt;第11行调用f1的时候要打印a变量，return的函数中没有a变量，所以a是个自由变量，要去&lt;strong&gt;声明&lt;/strong&gt;该函数（不是调用）的父级作用域去查找，即functin F1中，a=100&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;闭包在开发中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;以下函数的目的是：当_list中没有val值时，返回true并把val添加到_list中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个demo使用了闭包，在外部无法直接访问_list这个Fn函数的私有变量，这样可以保证数据不被污染，提高了安全性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Fn(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;           &lt;span&gt;var&lt;/span&gt; _list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             
&lt;span&gt; 4&lt;/span&gt;           &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;(_list.indexOf(val) &amp;lt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                  _list.push(val)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;               }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; f1 =&lt;span&gt; Fn()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       console.log(f1(10))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;       console.log(f1(10))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;       console.log(f1(20))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;       console.log(f1(20))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;异步和单线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　异步和单线程是相辅相成的，js是一门单线程脚本语言，所以需要异步来辅助&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;异步和同步的区别&lt;/strong&gt;: 异步会阻塞程序的执行，同步不会阻塞程序的执行，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　比如只有在执行完alert后才会打印100，如果你不去点击弹框的确定键，console.log就永远不会执行，这就是同步的阻塞&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　第二个demo中，会马上就打印100，两秒后再打印setTimeout，这就是异步&lt;strong&gt;不会阻塞&lt;/strong&gt;程序执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     alert('ook'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      console.log(100)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             console.log('setTimeout'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         },2000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         console.log(100)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;在哪些场景中会异步执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;JavaScript中以下三种情况会异步执行　　&lt;span&gt;1.定时任务：setTimeout, setInterval　　2.网络请求：ajax请求，动态加载&amp;lt;img&amp;gt;图标　　3.事件绑定：比如‘click’等&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　看一个demo&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　以下函数的目的是在页面中创建5个a标签，点击第一个a标签打印1，点击第二个a标签打印2，以此类推。可执行结果都是5，为什么呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　因为click是一个异步事件，计算机不知道用户什么时候会点击，所以不能够是同步，不然用户不点击，程序就永远无法往下执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　异步事件会先拿出来放到一个队列里，等同步事件执行完了，再来执行异步事件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　所以当你点击a标签的时候，i已经循环到5了（i是全局变量。这也涉及到了js作用域：该函数没有定义i变量，就要去声明该函数的父级作用域中去找，而不是调　用）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　　　&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个a标签&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; a = document.createElement('a'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             a.innerHTML = i + 1 + '&amp;lt;br&amp;gt;'
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给a标签绑定click事件&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             a.addEventListener('click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                e.preventDefault()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                console.log(i)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将a标签添加到wrpper中&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             document.querySelector('#wrapper'&lt;span&gt;).appendChild(a)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决这个问题就可以用闭包，用一个function把给a添加时间的地方包起来，(function（i）{})(i) 这是函数的自调用。注意：自调用前要加分号，也就是第4行结束要加分号，不然js会分不清何时开始自调用，会报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个a标签&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; a = document.createElement('a'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             a.innerHTML = i+1 + '&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给a标签绑定click事件&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 a.addEventListener('click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                e.preventDefault()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 console.log(i+1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            })(i)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将a标签添加到wrpper中&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             document.querySelector('#wrapper'&lt;span&gt;).appendChild(a)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 01 Dec 2018 14:03:00 +0000</pubDate>
<dc:creator>帅气兆</dc:creator>
<og:description>1.原型和原型链 2.作用域和闭包 3.异步和单线程 被称为JavaScript的三座大山 原型和原型链： 在JavaScript中，数组，对象和函数被称为引用类型，他们都有一个__proto__属性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaozhaoli/p/10051265.html</dc:identifier>
</item>
</channel>
</rss>