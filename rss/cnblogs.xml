<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第六节：SignalR完结篇之依赖注入和分布式部署 - Yaopengfei</title>
<link>http://www.cnblogs.com/yaopengfei/p/9353630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaopengfei/p/9353630.html</guid>
<description>&lt;p&gt;&lt;span&gt;一. SignalR中DI思想的应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;DI，即依赖注入，它是一种不负责创建其自己的依赖项对象的一种模式，通常用来降低代码之间的耦合性，广泛应用于架构设计，是必不可少的一种思想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面结合一个需求来说一说SignalR中依赖注入思想的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需求：比如在前面章节的聊天室案例中，想把发送的每条消息都记录下来 (下面的代码中，使用群发这个接口进行测试)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 分析解决思路：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1. 新建Repository类和IRepository接口，里面声明SaveMsg方法，用来存储信息 (PS：便于测试，这里将信息保存到txt文本文档中)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRepository
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; SaveMsg(&lt;span&gt;string&lt;/span&gt; connectionId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Repository : IRepository
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 模拟数据库插入操作
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 这里以日志代替
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connectionId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SaveMsg(&lt;span&gt;string&lt;/span&gt; connectionId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处执行插入数据库操作&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             FileOperateHelp.WriteFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Logs/msg.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户【{connectionId}】发来消息：{msg}，时间为：{DateTime.Now.ToLongDateString()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分享一个文件相关操作的工具类FileOperateHelp：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fd54bfd2-dccd-4dcd-bfe3-0d27f106aab0')&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_fd54bfd2-dccd-4dcd-bfe3-0d27f106aab0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fd54bfd2-dccd-4dcd-bfe3-0d27f106aab0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fd54bfd2-dccd-4dcd-bfe3-0d27f106aab0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fd54bfd2-dccd-4dcd-bfe3-0d27f106aab0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileOperateHelp
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 01.写文件(.txt-覆盖)
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 写文件(覆盖源文件内容)
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件不存在的话自动创建
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;FileName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Content&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Write_Txt(&lt;span&gt;string&lt;/span&gt; FileName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Content)
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                 Encoding code = Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gb2312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; htmlfilename =&lt;span&gt; FileOperateHelp.PathConvert(FileName);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;string htmlfilename = HttpContext.Current.Server.MapPath(FileName + &quot;.txt&quot;);　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件的路径  &lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Content;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                 StreamWriter sw = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                         sw = &lt;span&gt;new&lt;/span&gt; StreamWriter(htmlfilename, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, code);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;                        sw.Write(str);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;                        sw.Flush();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                sw.Close();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                sw.Dispose();
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 02.读文件(.txt)
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读文件
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filename&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Read_Txt(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filename)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 Encoding code = Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gb2312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; temp =&lt;span&gt; FileOperateHelp.PathConvert(filename);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  string temp = HttpContext.Current.Server.MapPath(filename + &quot;.txt&quot;);&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; str = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(temp))
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                     StreamReader sr = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                         sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(temp, code);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                         str = sr.ReadToEnd(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取文件  &lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                    sr.Close();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                    sr.Dispose();
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                     str = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 03.写文件（.txt-添加）
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 写文件  
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;FileName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Strings&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; WriteFile(&lt;span&gt;string&lt;/span&gt; FileName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Strings)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; Path =&lt;span&gt; FileOperateHelp.PathConvert(FileName);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(Path))
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                     System.IO.FileStream f =&lt;span&gt; System.IO.File.Create(Path);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                    f.Close();
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                    f.Dispose();
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 System.IO.StreamWriter f2 = &lt;span&gt;new&lt;/span&gt; System.IO.StreamWriter(Path, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, System.Text.Encoding.UTF8);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                f2.WriteLine(Strings);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                f2.Close();
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                f2.Dispose();
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 04.读文件（.txt）
&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读文件  
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;118&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;FileName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;  
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ReadFile(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; FileName)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; Path =&lt;span&gt; FileOperateHelp.PathConvert(FileName);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(Path))
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                     s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不存在相应的目录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                     StreamReader f2 = &lt;span&gt;new&lt;/span&gt; StreamReader(Path, System.Text.Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gb2312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                     s =&lt;span&gt; f2.ReadToEnd();
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                    f2.Close();
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                    f2.Dispose();
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 05.删除文件
&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除文件  
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Path&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FileDel(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; Path)
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; temp =&lt;span&gt; FileOperateHelp.PathConvert(Path);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;                File.Delete(temp);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt; 
&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 06.移动文件
&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;166&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移动文件  
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;OrignFile&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;原始路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt;169&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;NewFile&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;新路径,需要写上路径下的文件名，不能单写路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FileMove(&lt;span&gt;string&lt;/span&gt; OrignFile, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; NewFile)
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                 OrignFile =&lt;span&gt; FileOperateHelp.PathConvert(OrignFile);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                 NewFile =&lt;span&gt; FileOperateHelp.PathConvert(NewFile);
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;                File.Move(OrignFile, NewFile);
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt; 
&lt;span&gt;186&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 07.复制文件
&lt;span&gt;187&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;188&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 复制文件  
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;190&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;OrignFile&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;原始文件(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;NewFile&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;新文件路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FileCopy(&lt;span&gt;string&lt;/span&gt; OrignFile, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; NewFile)
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;                 OrignFile =&lt;span&gt; FileOperateHelp.PathConvert(OrignFile);
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                 NewFile =&lt;span&gt; FileOperateHelp.PathConvert(NewFile);
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                 File.Copy(OrignFile, NewFile, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 08.创建文件夹
&lt;span&gt;209&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建文件夹  
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;212&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Path&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;相对路径(web里相对路径,控制台在根目录下写)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
&lt;span&gt;213&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FolderCreate(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; Path)
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;                 Path =&lt;span&gt; FileOperateHelp.PathConvert(Path);
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断目标目录是否存在如果不存在则新建之  &lt;/span&gt;
&lt;span&gt;219&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Directory.Exists(Path))
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;                    Directory.CreateDirectory(Path);
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;231&lt;/span&gt; 
&lt;span&gt;232&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 09.递归删除文件夹目录及文件
&lt;span&gt;233&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 递归删除文件夹目录及文件  
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
&lt;span&gt;236&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dir&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;相对路径(web里相对路径,控制台在根目录下写) 截止到哪删除到哪，eg：/a/ 连a也删除&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;    
&lt;span&gt;237&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;  
&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DeleteFolder(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; dir)
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; 
&lt;span&gt;241&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;242&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; adir =&lt;span&gt; FileOperateHelp.PathConvert(dir);
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (Directory.Exists(adir)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在这个文件夹删除之   &lt;/span&gt;
&lt;span&gt;245&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Directory.GetFileSystemEntries(adir))
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(d))
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;                             File.Delete(d); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接删除其中的文件                          &lt;/span&gt;
&lt;span&gt;250&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;251&lt;/span&gt;                             DeleteFolder(d); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归删除子文件夹   &lt;/span&gt;
&lt;span&gt;252&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;                     Directory.Delete(adir, &lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除已空文件夹                   &lt;/span&gt;
&lt;span&gt;254&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt; 
&lt;span&gt;263&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 10.将相对路径转换成绝对路径
&lt;span&gt;266&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;267&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 10.将相对路径转换成绝对路径
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;269&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;strPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;相对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;270&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PathConvert(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; strPath)
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;web程序使用&lt;/span&gt;
&lt;span&gt;273&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (HttpContext.Current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HttpContext.Current.Server.MapPath(strPath);
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非web程序引用             &lt;/span&gt;
&lt;span&gt;278&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt;                 strPath = strPath.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (strPath.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;                     strPath = strPath.TrimStart(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, strPath);
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;288&lt;/span&gt; 
&lt;span&gt;289&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 采用构造函数注入的方式，在MySpecHub1这个Hub类中进行配置。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180723131014057-1369527230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 配置注入代码，在Startup类中的Configuration方法中，进行依赖注入代码的配置。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;每当需要创建MySpecHub1实例,SignalR 将调用此匿名函数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;GlobalHost.DependencyResolver.Register(typeof(MySpecHub1), () =&amp;gt; new MySpecHub1(new Repository()));&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 4. 在群发接口中进行SaveMsg方法的调用进行测试。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180723131541252-730718036.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 测试结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180723131742665-2046235577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;二. 基于SQLServer或Redis进行部署&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　我们都知道，当用户量并发量非常大的时候，单台服务器已经无法承载所需的业务，这个时候我们会配置负载均衡，项目会部署在多台服务器上，通常利用Nginx进行反向代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外在使用SignalR的过程中，你会发现，当连接数比较大的时候，会比较卡顿，所以分布式部署或许是一种不错的解决方案，但我们会面临一个问题，如何打通不同地址间的SignalR的通讯呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;这个时候可以引入“中间件”的概念，比如可以用“SQLServer”或“Redis”为底板，来实现不同地址间SignalR的通讯。&lt;span&gt;（此方案可能非最佳方案，不喜勿喷）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.  引入“中间件”后，SignalR之间的通讯势必会减慢，正如鱼和熊掌不可兼得哦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.  以Redis为底板性能肯定要比SQLServer要高的多。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;下面以SQLServer为例简单的配置一下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 通过Nuget下载程序集：Microsoft.AspNet.SignalR.SqlServer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 在SQLServer中新建一个数据库，比如 SignalRDB，不需要创建任何表，因为程序运行时，会自动生成所需表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180723171802909-585745988.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180723171918277-1919230206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. 在Startup中配置映射数据库，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configuration(IAppBuilder app)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {   
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            app.UseCors(CorsOptions.AllowAll).MapSignalR();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;四. 性能优化 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. SQLServer版本（跨服务器通信代码配置）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; sqlConnectionString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source=localhost;initial catalog=SignalRDB;persist security info=True;user id=sa;password=123456;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            GlobalHost.DependencyResolver.UseSqlServer(sqlConnectionString);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;以上3步，已经实现了不同地址间SignalR间的通讯，配置非常简单，内部复杂实现微软已经给实现好了，那么下面我们简单的部署一下，分别部署在1001 和 1002 端口下，进行通讯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180723172412288-1991414120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PS：补充Redis的配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 通过Nuget下载程序集：Microsoft.AspNet.SignalR.Redis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 代码配置：GlobalHost.DependencyResolver.UseRedis(&quot;127.0.0.1&quot;, 6379, &quot;123456&quot;, &quot;mykey&quot;);&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;截止到此处Signalr系列入门已经全部更新完成，再深入的需要小伙伴们自行研究了，原计划的项目案例由于剥离代码实在是太耗时间了，暂时搁置，后面有时间在补充，下一步会给该系列做一个目录就彻底告一段落。&lt;/p&gt;





&lt;div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;作       者 : &lt;span&gt;Yaopengfei(姚鹏飞)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;博客地址 : &lt;a href=&quot;http://www.cnblogs.com/yaopengfei/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/yaopengfei/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;声     明1 : 本人才疏学浅，用郭德纲的话说“我是一个小学生”，如有错误，欢迎讨论，请勿谩骂^_^。&lt;/li&gt;
&lt;li&gt;声     明2 : 原创博客请在转载时保留原文链接或在文章开头加上本人博客地址，否则保留追究法律责任的权利。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 23 Jul 2018 23:42:00 +0000</pubDate>
<dc:creator>Yaopengfei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaopengfei/p/9353630.html</dc:identifier>
</item>
<item>
<title>柯里化与反柯里化 - 我是leon</title>
<link>http://www.cnblogs.com/walls/p/9357818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walls/p/9357818.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;柯里化，可以理解为&lt;strong&gt;提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数&lt;/strong&gt;。因为这样的特性，也被称为部分计算函数。柯里化，是一个逐步接收参数的过程。在接下来的剖析中，你会深刻体会到这一点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;反柯里化，是一个&lt;strong&gt;泛型化&lt;/strong&gt;的过程。它使得被反柯里化的函数，可以&lt;strong&gt;接收更多参数&lt;/strong&gt;。目的是创建一个更普适性的函数，可以被不同的对象使用。有鸠占鹊巢的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一柯里化&quot;&gt;一、柯里化&lt;/h2&gt;
&lt;h3 id=&quot;例子&quot;&gt;1.1 例子&lt;/h3&gt;
&lt;p&gt;实现 &lt;code&gt;add(1)(2, 3)(4)() = 10&lt;/code&gt; 的效果&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;依题意，有两个关键点要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传入参数时，代码不执行输出结果，而是先记忆起来&lt;/li&gt;
&lt;li&gt;当传入空的参数时，代表可以进行真正的运算&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function currying(fn){
    var allArgs = [];

    return function next(){
        var args = [].slice.call(arguments);

        if(args.length &amp;gt; 0){
            allArgs = allArgs.concat(args);
            return next;
        }else{
            return fn.apply(null, allArgs);
        }
    } 
}
var add = currying(function(){
    var sum = 0;
    for(var i = 0; i &amp;lt; arguments.length; i++){
        sum += arguments[i];
    }
    return sum;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;记忆传入参数&quot;&gt;1.2 记忆传入参数&lt;/h3&gt;
&lt;p&gt;由于是延迟计算结果，所以要对参数进行记忆。&lt;br/&gt;这里的实现方式是采用闭包。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function currying(fn){
    var allArgs = [];

    return function next(){
        var args = [].slice.call(arguments);

        if(args.length &amp;gt; 0){
            allArgs = allArgs.concat(args);
            return next;
        }
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行&lt;code&gt;var add = currying(...)&lt;/code&gt;时，&lt;code&gt;add&lt;/code&gt;变量已经指向了&lt;code&gt;next&lt;/code&gt;方法。此时，&lt;code&gt;allArgs&lt;/code&gt;在&lt;code&gt;next&lt;/code&gt;方法内部有引用到，所以不能被GC回收。也就是说，&lt;code&gt;allArgs&lt;/code&gt;在该赋值语句执行后，一直存在，形成了闭包。&lt;br/&gt;依靠这个特性，只要把接收的参数，不断放入&lt;code&gt;allArgs&lt;/code&gt;变量进行存储即可。&lt;br/&gt;所以，当&lt;code&gt;arguments.length &amp;gt; 0&lt;/code&gt;时，就可以将接收的新参数，放到&lt;code&gt;allArgs&lt;/code&gt;中。&lt;br/&gt;最后返回&lt;code&gt;next&lt;/code&gt;函数指针，形成链式调用。&lt;/p&gt;
&lt;h3 id=&quot;判断触发函数执行条件&quot;&gt;1.3 判断触发函数执行条件&lt;/h3&gt;
&lt;p&gt;题意是，空参数时，输出结果。所以，只要判断&lt;code&gt;arguments.length == 0&lt;/code&gt;即可执行。&lt;br/&gt;另外，由于计算结果的方法，是作为参数传入&lt;code&gt;currying&lt;/code&gt;函数，所以要利用&lt;code&gt;apply&lt;/code&gt;进行执行。&lt;br/&gt;综合上述思考，就可以得到以下完整的柯里化函数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function currying(fn){
    var allArgs = []; // 用来接收参数

    return function next(){
        var args = [].slice.call(arguments);

        // 判断是否执行计算
        if(args.length &amp;gt; 0){
            allArgs = allArgs.concat(args); // 收集传入的参数，进行缓存
            return next;
        }else{
            return fn.apply(null, allArgs); // 符合执行条件，执行计算
        }
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;1.4 总结&lt;/h3&gt;
&lt;p&gt;柯里化，在这个例子中可以看出很明显的行为规范：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;逐步接收参数，并缓存供后期计算使用&lt;/li&gt;
&lt;li&gt;不立即计算，延后执行&lt;/li&gt;
&lt;li&gt;符合计算的条件，将缓存的参数，统一传递给执行方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;扩展&quot;&gt;1.5 扩展&lt;/h3&gt;
&lt;p&gt;实现 &lt;code&gt;add(1)(2, 3)(4)(5) = 15&lt;/code&gt; 的效果。&lt;br/&gt;很多人这里就犯嘀咕了：我怎么知道执行的时机？&lt;br/&gt;其实，这里有个忍者技艺：&lt;code&gt;valueOf&lt;/code&gt;和&lt;code&gt;toString&lt;/code&gt;。&lt;br/&gt;js在获取当前变量值的时候，会根据语境，隐式调用&lt;code&gt;valueOf&lt;/code&gt;和&lt;code&gt;toString&lt;/code&gt;方法进行获取需要的值。&lt;br/&gt;那么，实现起来就很简单了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function currying(fn){
    var allArgs = [];

    function next(){
        var args = [].slice.call(arguments);
        allArgs = allArgs.concat(args);
        return next;
    }
    // 字符类型
    next.toString = function(){
        return fn.apply(null, allArgs);
    };
    // 数值类型
    next.valueOf = function(){
        return fn.apply(null, allArgs);
    }

    return next;
}
var add = currying(function(){
    var sum = 0;
    for(var i = 0; i &amp;lt; arguments.length; i++){
        sum += arguments[i];
    }
    return sum;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二反柯里化&quot;&gt;二、反柯里化&lt;/h2&gt;
&lt;h3 id=&quot;例子-1&quot;&gt;2.1 例子&lt;/h3&gt;
&lt;p&gt;有以下轻提示类。现在想要单独使用其&lt;code&gt;show&lt;/code&gt;方法，输出新对象&lt;code&gt;obj&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 轻提示
function Toast(option){
  this.prompt = '';
}
Toast.prototype = {
  constructor: Toast,
  // 输出提示
  show: function(){
    console.log(this.prompt);
  }
};

// 新对象
var obj = {
    prompt: '新对象'
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用反柯里化的方式，可以这么做&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function unCurrying(fn){
    return function(){
        var args = [].slice.call(arguments);
        return fn.apply(args[0], args.shift());
    }
}

var objShow = unCurrying(Toast.prototype.show);

objShow(obj); // 输出&quot;新对象&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反柯里化的行为&quot;&gt;2.2 反柯里化的行为&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;非我之物，为我所用&lt;/li&gt;
&lt;li&gt;增加被反柯里化方法接收的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在上面的例子中，&lt;code&gt;Toast.prototype.show&lt;/code&gt;方法，本来是&lt;code&gt;Toast&lt;/code&gt;类的私有方法。跟新对象&lt;code&gt;obj&lt;/code&gt;没有半毛钱关系。&lt;br/&gt;经过反柯里化后，却可以为&lt;code&gt;obj&lt;/code&gt;对象所用。&lt;br/&gt;为什么能被&lt;code&gt;obj&lt;/code&gt;所用，是因为内部将&lt;code&gt;Toast.prototype.show&lt;/code&gt;的上下文重新定义为&lt;code&gt;obj&lt;/code&gt;。也就是用&lt;code&gt;apply&lt;/code&gt;改变了&lt;code&gt;this&lt;/code&gt;指向。&lt;br/&gt;而实现这一步骤的过程，就需要增加反柯里化后的&lt;code&gt;objShow&lt;/code&gt;方法参数。&lt;/p&gt;
&lt;h3 id=&quot;另一种反柯里化的实现&quot;&gt;2.3 另一种反柯里化的实现&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Function.prototype.unCurrying = function(){
    var self = this;
    return function(){
        return Function.prototype.call.apply(self, arguments);
    }
}

// 使用
var objShow = Toast.prototype.show.unCurrying();
objShow(obj);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的难点，在于理解&lt;code&gt;Function.prototype.call.apply(self, arguments);&lt;/code&gt;。&lt;br/&gt;可以分拆为两步：&lt;/p&gt;
&lt;p&gt;1） &lt;strong&gt;&lt;code&gt;Function.prototype.call.apply(...)&lt;/code&gt;的解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看成是&lt;code&gt;callFunction.apply(...)&lt;/code&gt;。这样，就清晰很多。&lt;br/&gt;&lt;code&gt;callFunction&lt;/code&gt;的&lt;code&gt;this&lt;/code&gt;指针，被&lt;code&gt;apply&lt;/code&gt;修改为&lt;code&gt;self&lt;/code&gt;。&lt;br/&gt;然后执行&lt;code&gt;callFunction&lt;/code&gt; -&amp;gt; &lt;code&gt;callFunction(arguments)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2） &lt;strong&gt;&lt;code&gt;callFunction(arguments)&lt;/code&gt;的解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt;方法，第一个参数，是用来指定&lt;code&gt;this&lt;/code&gt;的。所以&lt;code&gt;callFunction(arguments)&lt;/code&gt; -&amp;gt; &lt;code&gt;callFunction(arguments[0], arguments[1-n])&lt;/code&gt;。&lt;br/&gt;由此可以得出，反柯里化后，第一个参数，是用来指定&lt;code&gt;this&lt;/code&gt;指向的。&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;为什么要用apply(self, arguments)&lt;/strong&gt;&lt;br/&gt;如果使用&lt;code&gt;apply(null, arguments)&lt;/code&gt;，因为&lt;code&gt;null&lt;/code&gt;对象没有&lt;code&gt;call&lt;/code&gt;方法，会报错。&lt;/p&gt;
&lt;h2 id=&quot;三实战&quot;&gt;三、实战&lt;/h2&gt;
&lt;h3 id=&quot;判断变量类型&quot;&gt;3.1 判断变量类型&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var fn = function(){};
var val = 1;

if(Object.prototype.toString.call(fn) == '[object Function]'){
    console.log(`${fn} is function.`);
}

if(Object.prototype.toString.call(val) == '[object Number]'){
    console.log(`${val} is number.`);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码，用反柯里化，可以这么写：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var fn = function(){};
var val = 1;
var toString = Object.prototype.toString.unCurrying();

if(toString(fn) == '[object Function]'){
    console.log(`${fn} is function.`);
}

if(toString(val) == '[object Number]'){
    console.log(`${val} is number.`);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;其实，反柯里化和泛型方法一样，只是理念上有一些不同而已。理解这种思维即可。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 17:49:00 +0000</pubDate>
<dc:creator>我是leon</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walls/p/9357818.html</dc:identifier>
</item>
<item>
<title>Netty源码—二、server启动（2） - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/9357760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/9357760.html</guid>
<description>&lt;p&gt;我们在使用Netty的时候的初始化代码一般如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;EventLoopGroup bossGroup = new NioEventLoopGroup();
EventLoopGroup workerGroup = new NioEventLoopGroup();
try {
    // 配置服务器的NIO线程组
    ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, 1024)
        .childHandler(new ChildChannelHandler());

    // 绑定端口，同步等待成功
    ChannelFuture f = b.bind(port).sync();
    // 等待服务端监听端口关闭
    f.channel().closeFuture().sync();
} finally {
    // 优雅退出，释放线程池资源
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面已经说过线程池的启动过程，接下来就是通过builder模式构造启动参数，接下来看看bind的过程。channel的注册和ip:port的绑定都是在bind方法中进行的，bind方法的主要逻辑是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化channel&lt;/li&gt;
&lt;li&gt;channel注册到selector&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;nioserversocketchannel&quot;&gt;NioServerSocketChannel&lt;/h2&gt;
&lt;p&gt;先看看channel的初始化，server端使用的NioServerSocketChannel封装了JDK的ServerSocketChannel，初始化过程如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 配置使用的channel的时候会指定对应的channelFactory
public B channel(Class&amp;lt;? extends C&amp;gt; channelClass) {
    if (channelClass == null) {
        throw new NullPointerException(&quot;channelClass&quot;);
    }
    return channelFactory(new ReflectiveChannelFactory&amp;lt;C&amp;gt;(channelClass));
}

final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // channelFactory是ReflectiveChannelFactory
        channel = channelFactory.newChannel();
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))
            channel.unsafe().closeForcibly();
            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }

    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }

    // If we are here and the promise is not failed, it's one of the following cases:
    // 1) If we attempted registration from the event loop, the registration has been completed at this point.
    //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
    // 2) If we attempted registration from the other thread, the registration request has been successfully
    //    added to the event loop's task queue for later execution.
    //    i.e. It's safe to attempt bind() or connect() now:
    //         because bind() or connect() will be executed *after* the scheduled registration task is executed
    //         because register(), bind(), and connect() are all bound to the same thread.

    return regFuture;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面使用的是io.netty.channel.ReflectiveChannelFactory#newChannel来创建channel，利用反射创建实例，使用的是NioServerSocketChannel的无参构造方法，在午无参造方法中调用newChannel&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 创建serverChannel的时候先调用newSocket，然后调用下面的构造方法
public NioServerSocketChannel(ServerSocketChannel channel) {
    // 设置当前socket监听的事件，由于是server一定要添加accept事件
    super(null, channel, SelectionKey.OP_ACCEPT);
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}
// io.netty.channel.socket.nio.NioServerSocketChannel#newSocket
private static ServerSocketChannel newSocket(SelectorProvider provider) {
    try {
        /**
             *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in
             *  {@link SelectorProvider#provider()} which is called by each ServerSocketChannel.open() otherwise.
             *
             *  See &amp;lt;a href=&quot;https://github.com/netty/netty/issues/2308&quot;&amp;gt;#2308&amp;lt;/a&amp;gt;.
             */
        return provider.openServerSocketChannel();
    } catch (IOException e) {
        throw new ChannelException(
            &quot;Failed to open a server socket.&quot;, e);
    }
}

ServerSocketChannelImpl(SelectorProvider sp) throws IOException {
    super(sp);
    // 创建一个socket，返回的是socket对应的文件描述符
    this.fd =  Net.serverSocket(true);
    this.fdVal = IOUtil.fdVal(fd);
    this.state = ST_INUSE;
}

// sun.nio.ch.Net#serverSocket
static FileDescriptor serverSocket(boolean stream) {
    // socket0是一个native方法，返回的是int类型的linux的文件描述符，使用newFD转化为Java的文件描述符
    return IOUtil.newFD(socket0(isIPv6Available(), stream, true));
}

// jdk/src/solaris/native/sun/nio/ch/Net.c
JNIEXPORT int JNICALL
Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,
                            jboolean stream, jboolean reuse)
{
    // 省略中间代码...
    // 调用socket方法创建一个socket，并返回对应的文件描述符
    fd = socket(domain, type, 0);
    if (fd &amp;lt; 0) {
        return handleSocketError(env, errno);
    }

    // 省略中间代码...
    return fd;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难看出channel初始化的过程就是创建了一个socket，接下来看看channel的注册&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// config()返回的是ServerBootstrapConfig
// group()返回的是parentGroup，对应开始的例子是bossGroup，也就是NioEventLoopGroup
// 所以是调用的是NioEventLoopGroup.register，该方法继承自MultithreadEventLoopGroup
ChannelFuture regFuture = config().group().register(channel);

// io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)
public ChannelFuture register(Channel channel) {
    // 使用的是bossGroup，next方法选出第一个NioEventLoop，调用NioEventLoop.register，该方法继承自SingleThreadEventLoop
    return next().register(channel);
}

// io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)
public ChannelFuture register(Channel channel) {
    // 注册的还是使用一个promise，可以异步注册
    return register(new DefaultChannelPromise(channel, this));
}

// io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.ChannelPromise)
public ChannelFuture register(final ChannelPromise promise) {
    ObjectUtil.checkNotNull(promise, &quot;promise&quot;);
    // channel返回的是NioServerSocketChannel
    // unsafe返回的是io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe
    // 所以调用的是NioMessageUnsafe.register，该方法继承自AbstractUnsafe
    promise.channel().unsafe().register(this, promise);
    return promise;
}

// io.netty.channel.AbstractChannel.AbstractUnsafe#register
public final void register(EventLoop eventLoop, final ChannelPromise promise) {
    // 省略中间代码...
    // 当前线程是main线程，eventLoop是bossGroup中的一个线程，所以这里返回false，会在新线程中执行register0
    if (eventLoop.inEventLoop()) {
        register0(promise);
    } else {
        try {
            // 在eventLoop中执行
            eventLoop.execute(new Runnable() {
                @Override
                public void run() {
                    register0(promise);
                }
            });
        } catch (Throwable t) {
        // 省略中间代码...
        }
    }
}

private void register0(ChannelPromise promise) {
    try {
        // 省略中间代码...
        // 这里面主要是调用ServerSocketChannelImpl.register，注册的过程中主要是将需要监听的文件描述符添加到EPollArrayWrapper中
        doRegister();
        neverRegistered = false;
        registered = true;

        // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
        // user may already fire events through the pipeline in the ChannelFutureListener.
        pipeline.invokeHandlerAddedIfNeeded();

        safeSetSuccess(promise);
        pipeline.fireChannelRegistered();
        // Only fire a channelActive if the channel has never been registered. This prevents firing
        // multiple channel actives if the channel is deregistered and re-registered.
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
            }
        }
    } catch (Throwable t) {
        // 省略中间代码...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面看看channel注册过程中做了哪些事情&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// sun.nio.ch.SelectorImpl#register
// 这里ch是ServerSocketChannelImpl
// attachment是NioServerSocketChannel
// ops是0，这里并不注册需要监听的事件
// selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
protected final SelectionKey register(AbstractSelectableChannel ch,
                                      int ops,
                                      Object attachment)
{
    if (!(ch instanceof SelChImpl))
        throw new IllegalSelectorException();
    // 创建一个SelectionKeyImpl，
    SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);
    k.attach(attachment);
    synchronized (publicKeys) {
        // 调用sun.nio.ch.EPollSelectorImpl#implRegister
        implRegister(k);
    }
    // 设置当前channel关注的事件
    k.interestOps(ops);
    return k;
}

protected void implRegister(SelectionKeyImpl ski) {
    if (closed)
        throw new ClosedSelectorException();
    SelChImpl ch = ski.channel;
    int fd = Integer.valueOf(ch.getFDVal());
    fdToKey.put(fd, ski);
    // poolWrapper是epoll监听事件所需数据结构的java版本
    // add方法调用setUpdateEvents来指定当前socket监听的事件
    pollWrapper.add(fd);
    keys.add(ski);
}

/**
 * struct epoll_event {
 *     __uint32_t events;
 *     epoll_data_t data;
 * };
 * 由于一开始并不知道会监听多少个socket，所以jdk默认指定了MAX_UPDATE_ARRAY_SIZE
 * 如果小于MAX_UPDATE_ARRAY_SIZE则使用数组eventsLow存储每个socket监听的事件，eventsLow的下标就是socket对应的文件描述符
 * 如果大于等于MAX_UPDATE_ARRAY_SIZE个则使用EPollArrayWrapper#eventsHigh，也就是一个map来保存每个socket监听的事件
 * 
 * 注意这个时候调用setUpdateEvents的events参数是0，也就是还没有执行监听的事件类型
 */
private void setUpdateEvents(int fd, byte events, boolean force) {
    if (fd &amp;lt; MAX_UPDATE_ARRAY_SIZE) {
        if ((eventsLow[fd] != KILLED) || force) {
            eventsLow[fd] = events;
        }
    } else {
        Integer key = Integer.valueOf(fd);
        if (!isEventsHighKilled(key) || force) {
            eventsHigh.put(key, Byte.valueOf(events));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的时候上面并没有设置当前channel监听的事件，真正设置监听的事件类型是在beginRead方法里面，在当前channel被激活的时候会调用beginRead方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.channel.nio.AbstractNioChannel#doBeginRead
protected void doBeginRead() throws Exception {
    // Channel.read() or ChannelHandlerContext.read() was called
    final SelectionKey selectionKey = this.selectionKey;
    if (!selectionKey.isValid()) {
        return;
    }

    readPending = true;

    final int interestOps = selectionKey.interestOps();
    if ((interestOps &amp;amp; readInterestOp) == 0) {
        // readInterestOp是16，在NioServerSocketChannel构造方法里面指定了这个channel需要监听accept事件
        // 这里才是真正设置socket监听事件的地方
        // 下面这个方法最后会调用到sun.nio.ch.EPollArrayWrapper#setInterest
        selectionKey.interestOps(interestOps | readInterestOp);
    }
}

// sun.nio.ch.EPollArrayWrapper#setInterest
void setInterest(int fd, int mask) {
    synchronized (updateLock) {
        // record the file descriptor and events
        int oldCapacity = updateDescriptors.length;
        if (updateCount == oldCapacity) {
            int newCapacity = oldCapacity + INITIAL_PENDING_UPDATE_SIZE;
            int[] newDescriptors = new int[newCapacity];
            System.arraycopy(updateDescriptors, 0, newDescriptors, 0, oldCapacity);
            updateDescriptors = newDescriptors;
        }
        updateDescriptors[updateCount++] = fd;

        // events are stored as bytes for efficiency reasons
        byte b = (byte)mask;
        assert (b == mask) &amp;amp;&amp;amp; (b != KILLED);
        // 上面已经说过这个方法了，把当前socket对应的文件描述符监听的事件设置为b
        setUpdateEvents(fd, b, false);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里一个serverSocketChannel注册成功了，而且也设置了关注的事件，接下来看看完成ip:port的绑定&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
    synchronized (lock) {
        // 省略中间代码...
        // 调用native方法的bind，最后调用linux的bind方法
        Net.bind(fd, isa.getAddress(), isa.getPort());
        // 最后调用listen方法完成监听serverSocket的文件描述符
        Net.listen(fd, backlog &amp;lt; 1 ? 50 : backlog);
        synchronized (stateLock) {
            localAddress = Net.localAddress(fd);
        }
    }
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;server在bind的过程中主要初始化了NioServerSocketChannel，并将channel注册到selector，添加了channel需要监听的事件，接下来该socketChannel就可以监听端口接受来自客户端的请求了。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 16:47:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/9357760.html</dc:identifier>
</item>
<item>
<title>初学Node.js - 超暖系呆少年i</title>
<link>http://www.cnblogs.com/chaonuanxi/p/9357685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaonuanxi/p/9357685.html</guid>
<description>&lt;p&gt;下载Node.js，官方网址:https://nodejs.org/en/download/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422481/201807/1422481-20180724000350069-1996633084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可根据根据自己的电脑配置来下载相当于的Node.js&lt;/p&gt;
&lt;p&gt;下载完成后使用Windows键+R 输入cmd   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422481/201807/1422481-20180724000436718-242542549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 Node.js,输入1+1是否出现=2,当出现,那么你Node.Js就安装成功了&lt;img id=&quot;uploading_image_1102&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422481/201807/1422481-20180724000533630-259622705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后在Visual Studio Code测试代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422481/201807/1422481-20180724000902324-178253432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;var http=require('http');&lt;br/&gt;http.createServer(function(req,res)&lt;br/&gt;{&lt;br/&gt;res.writeHead(200,{'Content-Type':'text/html;charset=utf-8'});&lt;br/&gt;res.end('我在用Node.JS写程序');&lt;br/&gt;}).listen(3000,'127.0.0.2')&lt;br/&gt;console.log(&quot;Server running at http://127.0.0.2:3000&quot;);&lt;/p&gt;
&lt;p&gt;最后在浏览器中访问http://127.0.0.2:3000 则显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422481/201807/1422481-20180724001039767-47676679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Jul 2018 16:07:00 +0000</pubDate>
<dc:creator>超暖系呆少年i</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaonuanxi/p/9357685.html</dc:identifier>
</item>
<item>
<title>PHP错误：SQLSTATE[HY000] [2054] The server requested authentication method unknown to the client - 有欲</title>
<link>http://www.cnblogs.com/cndavidwang/p/9357684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cndavidwang/p/9357684.html</guid>
<description>&lt;p&gt;使用PHP连接MySQL 8的时候，可能会发生如标题所示的错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SQLSTATE[HY000] [2054] The server requested authentication method unknown to the client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发生这种错误，是由于MySQL 8默认使用了新的密码验证插件：caching_sha2_password，而之前的PHP版本中所带的mysqlnd无法支持这种验证。解决这个问题，有两种办法。&lt;/p&gt;
&lt;p&gt;一种办法是升级PHP支持MySQL 8的新验证插件。&lt;/p&gt;
&lt;p&gt;PHP 7.2.8和PHP 7.1.20已经可以支持caching_sha2_password，直接连接MySQL 8。&lt;/p&gt;
&lt;p&gt;截止PHP 7.0.31和PHP 5.6.37还无法支持caching_sha2_password，不知道后续版本是否会做出支持。&lt;/p&gt;
&lt;p&gt;可以通过phpinfo()函数了解当前安装的PHP是否支持caching_sha2_password：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/565080/201807/565080-20180723233653114-1774199744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不能升级PHP，可以在MySQL 8中创建（或修改）使用caching_sha2_password插件的账户，使之使用mysql_native_password，这样先前版本的PHP就可以连接使用了。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;在CREATE USER时，使用IDENTIFIED WITH xxx_plugin BY 'password'，比如：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;USER&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;WITH&lt;/span&gt; mysql_native_password &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password!2#4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;使用ALTER USER修改已有账户的验证插件：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;USER&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;WITH&lt;/span&gt; mysql_native_password
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;USER&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;WITH&lt;/span&gt; mysql_native_password &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;采用前一种方式，账户的密码将被清除；BY子句将为账户设置新的密码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;/etc/my.cnf配置文件中，有一行：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# default-authentication-plugin=mysql_native_password
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请删除注释符号“#”并重新启动mysqld使之生效，此后创建的账户均默认使用mysql_native_password。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果您完成MySQL Server的安装之后，在没有启动过mysqld服务的情况下修改/etc/my.cnf配置，那么启动mysqld之后创建的'root'@'localhost'账户也是使用mysql_native_password插件的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就这些，希望有帮助。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 16:06:00 +0000</pubDate>
<dc:creator>有欲</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cndavidwang/p/9357684.html</dc:identifier>
</item>
<item>
<title>Java并发编程原理与实战六：主线程等待子线程解决方案 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9349239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9349239.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文将研究的是主线程等待所有子线程执行完成之后再继续往下执行的解决方案&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()  
    {  
        System.out.println(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getName() + &quot;子线程开始&quot;&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;  
        {  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子线程休眠五秒  &lt;/span&gt;
            Thread.sleep(5000&lt;span&gt;);  
        }  
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)  
        {  
            e.printStackTrace();  
        }  
        System.out.println(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getName() + &quot;子线程结束&quot;&lt;span&gt;);  
    }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;首先是一个线程，它执行完成需要5秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、主线程等待一个子线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  
    {  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();  
          
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThread();  
        thread.start();  
          
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();  
        System.out.println(&lt;/span&gt;&quot;子线程执行时长：&quot; + (end -&lt;span&gt; start));  
    }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在主线程中，需要等待子线程执行完成。但是执行上面的main发现并不是想要的结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;子线程执行时长：0&lt;br/&gt;Thread-0子线程开始&lt;br/&gt;Thread-0子线程结束&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显主线程和子线程是并发执行的，主线程并没有等待。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于只有一个子线程，如果主线程需要等待子线程执行完成，再继续向下执行，可以使用Thread的join()方法。join()方法会阻塞主线程继续向下执行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  
    {  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();  
          
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThread();  
        thread.start();  
          
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;  
        {  
            thread.join();  
        }  
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)  
        {  
            e.printStackTrace();  
        }  
          
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();  
        System.out.println(&lt;/span&gt;&quot;子线程执行时长：&quot; + (end -&lt;span&gt; start));  
    }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;Thread-0子线程开始&lt;br/&gt;Thread-0子线程结束&lt;br/&gt;子线程执行时长：5000&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：join()要在start()方法之后调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、主线程等待多个子线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如主线程需要等待5个子线程。这5个线程之间是并发执行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  
    {  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();  
          
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;)  
        {  
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThread();  
            thread.start();  
              
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;  
            {  
                thread.join();  
            }  
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)  
            {  
                e.printStackTrace();  
            }  
        }  
          
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();  
        System.out.println(&lt;/span&gt;&quot;子线程执行时长：&quot; + (end -&lt;span&gt; start));  
    }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在上面的代码套上一个for循环，执行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;Thread-0子线程开始&lt;br/&gt;Thread-0子线程结束&lt;br/&gt;Thread-1子线程开始&lt;br/&gt;Thread-1子线程结束&lt;br/&gt;Thread-2子线程开始&lt;br/&gt;Thread-2子线程结束&lt;br/&gt;Thread-3子线程开始&lt;br/&gt;Thread-3子线程结束&lt;br/&gt;Thread-4子线程开始&lt;br/&gt;Thread-4子线程结束&lt;br/&gt;子线程执行时长：25000&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于thread.join()阻塞了主线程继续执行，导致for循环一次就需要等待一个子线程执行完成，而下一个子线程不能立即start()，5个子线程不能并发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要想子线程之间能并发执行，那么需要在所有子线程start()后，在执行所有子线程的join()方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  
    {  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();  
          
        List&lt;/span&gt;&amp;lt;Thread&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Thread&amp;gt;&lt;span&gt;();  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;)  
        {  
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThread();  
            thread.start();  
            list.add(thread);  
        }  
          
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;  
        {  
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Thread thread : list)  
            {  
                thread.join();  
            }  
        }  
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)  
        {  
            e.printStackTrace();  
        }  
          
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();  
        System.out.println(&lt;/span&gt;&quot;子线程执行时长：&quot; + (end -&lt;span&gt; start));  
    }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;Thread-0子线程开始&lt;br/&gt;Thread-3子线程开始&lt;br/&gt;Thread-1子线程开始&lt;br/&gt;Thread-2子线程开始&lt;br/&gt;Thread-4子线程开始&lt;br/&gt;Thread-3子线程结束&lt;br/&gt;Thread-0子线程结束&lt;br/&gt;Thread-2子线程结束&lt;br/&gt;Thread-1子线程结束&lt;br/&gt;Thread-4子线程结束&lt;br/&gt;子线程执行时长：5000&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;3、主线程等待多个子线程（CountDownLatch实现）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CountDownLatch是Java.util.concurrent中的一个同步辅助类，可以把它看做一个倒数计数器，就像神舟十号发射时倒数：10,9,8,7….2,1,0,走你。初始化时先设置一个倒数计数初始值，每调用一次countDown()方法，倒数值减一，await()方法会阻塞当前进程，直到倒数至0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样还是主线程等待5个并发的子线程。修改上面的代码，在主线程中，创建一个初始值为5的CountDownLatch，并传给每个子线程，在每个子线程最后调用countDown()方法对倒数器减1，当5个子线程等执行完成，那么CountDownLatch也就倒数完成，主线程调用await()方法等待5个子线程执行完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改MyThread接收传入的CountDownLatch：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread    
{    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CountDownLatch countDownLatch;    
            
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestThread(CountDownLatch countDownLatch)    
    {    
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.countDownLatch =&lt;span&gt; countDownLatch;    
    }    
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()    
    {    
        System.out.println(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getName() + &quot;子线程开始&quot;&lt;span&gt;);    
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;    
        {    
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子线程休眠五秒    &lt;/span&gt;
            Thread.sleep(5000&lt;span&gt;);    
        }    
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)    
        {    
            e.printStackTrace();    
        }  
  
        System.out.println(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getName() + &quot;子线程结束&quot;&lt;span&gt;);  
            
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 倒数器减1  &lt;/span&gt;
&lt;span&gt;        countDownLatch.countDown();  
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改main：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  
    {  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();  
          
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个初始值为5的倒数计数器  &lt;/span&gt;
        CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(5&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;)  
        {  
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThread(countDownLatch);  
            thread.start();  
        }  
          
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;  
        {  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞当前线程，直到倒数计数器倒数到0  &lt;/span&gt;
&lt;span&gt;            countDownLatch.await();  
        }  
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)  
        {  
            e.printStackTrace();  
        }  
          
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();  
        System.out.println(&lt;/span&gt;&quot;子线程执行时长：&quot; + (end -&lt;span&gt; start));  
    }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Thread-0子线程开始&lt;br/&gt;Thread-2子线程开始&lt;br/&gt;Thread-1子线程开始&lt;br/&gt;Thread-3子线程开始&lt;br/&gt;Thread-4子线程开始&lt;br/&gt;Thread-2子线程结束&lt;br/&gt;Thread-4子线程结束&lt;br/&gt;Thread-1子线程结束&lt;br/&gt;Thread-0子线程结束&lt;br/&gt;Thread-3子线程结束&lt;br/&gt;子线程执行时长：5000&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：如果子线程中会有异常，那么countDownLatch.countDown()应该写在finally里面，这样才能保证异常后也能对计数器减1，不会让主线程永远等待。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，await()方法还有一个实用的重载方法：public booleanawait(long timeout, TimeUnit unit)，设置超时时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如上面的代码，想要设置超时时间10秒，到了10秒无论是否倒数完成到0，都会不再阻塞主线程。返回值是boolean类型，如果是超时返回false，如果计数到达0没有超时返回true。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置超时时间为10秒  &lt;/span&gt;
&lt;span&gt;boolean&lt;/span&gt; timeoutFlag = countDownLatch.await(10&lt;span&gt;,TimeUnit.SECONDS);  
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(timeoutFlag)  
{  
    System.out.println(&lt;/span&gt;&quot;所有子线程执行完成&quot;&lt;span&gt;);  
}  
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;  
{  
    System.out.println(&lt;/span&gt;&quot;超时&quot;&lt;span&gt;);  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、主线程等待线程池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java线程池java.util.concurrent.ExecutorService是很好用的多线程管理方式。ExecutorService的一个方法boolean awaitTermination(long timeout, TimeUnit unit)，即阻塞主线程，等待线程池的所有线程执行完成，用法和上面所说的CountDownLatch的public boolean await(long timeout,TimeUnit unit)类似，参数设置一个超时时间，返回值是boolean类型，如果超时返回false，如果线程池中的线程全部执行完成，返回true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于ExecutorService没有类似CountDownLatch的无参数的await()方法，只能通过awaitTermination来实现主线程等待线程池。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  
    {  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();  
          
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个同时允许两个线程并发执行的线程池  &lt;/span&gt;
        ExecutorService executor = Executors.newFixedThreadPool(2&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;)  
        {  
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThread();  
            executor.execute(thread);  
        }  
        executor.shutdown();  
          
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;  
        {  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; awaitTermination返回false即超时会继续循环，返回true即线程池中的线程执行完成主线程跳出循环往下执行，每隔10秒循环一次  &lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (!executor.awaitTermination(10&lt;span&gt;, TimeUnit.SECONDS));  
        }  
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)  
        {  
            e.printStackTrace();  
        }  
          
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();  
        System.out.println(&lt;/span&gt;&quot;子线程执行时长：&quot; + (end -&lt;span&gt; start));  
    }  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Thread-0子线程开始&lt;br/&gt;Thread-1子线程开始&lt;br/&gt;Thread-0子线程结束&lt;br/&gt;Thread-2子线程开始&lt;br/&gt;Thread-1子线程结束&lt;br/&gt;Thread-3子线程开始&lt;br/&gt;Thread-2子线程结束&lt;br/&gt;Thread-4子线程开始&lt;br/&gt;Thread-3子线程结束&lt;br/&gt;Thread-4子线程结束&lt;br/&gt;子线程执行时长：15000&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，while(!executor.isTerminated())也可以替代上面的while (!executor.awaitTermination(10,TimeUnit.SECONDS))，isTerminated()是用来判断线程池是否执行完成。但是二者比较我认为还是awaitTermination更好，它有一个超时时间可以控制每隔多久循环一次，而不是一直在循环来消耗性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.其它方案参考：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;解决方案1：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本思路是这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个SubThread子线程类实例有个自己的状态99-初始化  0-执行成功 1-执行失败，当执行完毕之后，将状态修改为0或者1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MainThread主线程类中有个List，用来登记所有子线程。子线程的创建通过主线程来创建，每次创建之后，都会将子线程添加到List中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有子线程创建完成之后，通过主线程的start方法启动所有子线程，并通过一个while循环来遍历List中的所有子线程的状态，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;判断是否存在状态为99的，如果没有，则便是全部子线程执行完毕&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 子线程类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; status = 99; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;99-初始化  0-执行成功 1-执行失败 &lt;/span&gt;
 
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.out.println(&lt;/span&gt;&quot;开始执行...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
            e.printStackTrace();
        }
        status&lt;/span&gt;=0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;执行完毕...&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getStatus() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setStatus(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.status =&lt;span&gt; status;
    }
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 主线程类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainThread {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;SubThread&amp;gt; subThreadList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;SubThread&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建子线程
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SubThread createSubThread(){
        SubThread subThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubThread();
        subThreadList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubThread());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; subThread;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; start(){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(SubThread subThread : subThreadList){
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(subThread).start();
        }
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 监控所有子线程是否执行完毕
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; continueFlag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(continueFlag){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(SubThread subThread : subThreadList){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(subThread.getStatus()==99&lt;span&gt;){
                    continueFlag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                continueFlag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 判断子线程的执行结果
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(SubThread subThread : subThreadList){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(subThread.getStatus()!=0&lt;span&gt;){
                result &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
 
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        MainThread main &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainThread();
        main.createSubThread();
        main.createSubThread();
        main.createSubThread();
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result =&lt;span&gt; main.start();
        System.out.println(result);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;解决方案2：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过计数器方式解决。基本思路如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计数器类CountLauncher负责记录正在执行的子线程的总数，所有的子线程共享该计数器类对象，当子线程执行完毕之后，调用计数器的counDown()方法进行计数器减1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主线程通过计数器类来判断是否所有子线程都执行完毕。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 计数器类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountLauncher {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CountLauncher(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; countDown(){
        count &lt;/span&gt;--&lt;span&gt;;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
    }
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 子线程类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 计数器类对象实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CountLauncher countLauncher;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; status = 99; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;99-初始化  0-执行成功 1-执行失败 &lt;/span&gt;
    
 
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.out.println(&lt;/span&gt;&quot;开始执行...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
            e.printStackTrace();
        }
        status&lt;/span&gt;=0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;执行完毕...&quot;&lt;span&gt;);
        countLauncher.countDown();
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getStatus() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setStatus(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.status =&lt;span&gt; status;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CountLauncher getCountLauncher() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; countLauncher;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCountLauncher(CountLauncher countLauncher) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.countLauncher =&lt;span&gt; countLauncher;
    }
    
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 主线程类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainThread {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;SubThread&amp;gt; subThreadList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;SubThread&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建子线程
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; SubThread createSubThread(){
        SubThread subThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubThread();
        subThreadList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubThread());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; subThread;
    }
    
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; start(){
        CountLauncher countLauncher &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountLauncher(subThreadList.size());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(SubThread subThread : subThreadList){
            subThread.setCountLauncher(countLauncher);
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(subThread).start();
        }
        
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(countLauncher.getCount()&amp;gt;0&lt;span&gt;){
            System.out.println(countLauncher.getCount());
        }
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 判断子线程的执行结果
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(SubThread subThread : subThreadList){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(subThread.getStatus()!=0&lt;span&gt;){
                result &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        MainThread main &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainThread();
        main.createSubThread();
        main.createSubThread();
        main.createSubThread();
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result =&lt;span&gt; main.start();
        System.out.println(result);
    }
 
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;六.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;解决方案（推荐）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用的是Java自带的计数器类java.util.concurrent.CountDownLatch。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一点就是不需要在主线程中通过while来监控所有子线程，是否通过调用它的await方法进行等待所有子线程的执行完毕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用计数器时，需要注意的一点是：子线程中调用countDown()方法时一定要放在最后来执行，否则会出现子线程未执行完毕，主线程就开始往下执行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为一定计数器为0，就会自动唤醒主线程的。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:59:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9349239.html</dc:identifier>
</item>
<item>
<title>Spring的核心接口 - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/9281785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/9281785.html</guid>
<description>&lt;h3&gt;ContextLoaderListener接口&lt;/h3&gt;
&lt;p&gt;Create a new &lt;code&gt;ContextLoaderListener&lt;/code&gt; that will create a web application context based on the &quot;contextClass&quot; and &quot;contextConfigLocation&quot; servlet context-params. See &lt;a title=&quot;class in org.springframework.web.context&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/Spring-3.1.1/org/springframework/web/context/ContextLoader.html&quot;&gt;&lt;code&gt;ContextLoader&lt;/code&gt;&lt;/a&gt;superclass documentation for details on default values for each.&lt;/p&gt;
&lt;p&gt;This constructor is typically used when declaring &lt;code&gt;ContextLoaderListener&lt;/code&gt; as a &lt;code&gt;&amp;lt;listener&amp;gt;&lt;/code&gt; within &lt;code&gt;web.xml&lt;/code&gt;, where a no-arg constructor is required.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个接口实现了J2EE的&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/javaEE6/javax/servlet/ServletContextListener.html&quot; target=&quot;_blank&quot;&gt;ServletContextListener&lt;/a&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 通过listener 像Servlet容器注册 Web容器启动时 初始化Spring上下文的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 加载Spring容器 --&amp;gt;
     &amp;lt;context-param&amp;gt;
         &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
         &amp;lt;param-value&amp;gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;classpath:applicationContext-core.xml&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&amp;lt;/param-value&amp;gt; 
      &amp;lt;/context-param&amp;gt;
      &amp;lt;!-- 通过listener 像Servlet容器注册 Web容器启动时 初始化context-param的配置信息。--&amp;gt;
    &amp;lt;listener&amp;gt;
        &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/listener&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;BeanFactory接口&lt;/h3&gt;
&lt;p&gt;　　Spring通过BeanFactory接口的&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/Spring-3.1.1/org/springframework/beans/factory/BeanFactory.html#getBean(java.lang.Class)&quot; target=&quot;_blank&quot;&gt;getBean&lt;/a&gt;来拿到我们所配置Bean的实列，交给Spring管理的Bean全部默认是单例。&lt;/p&gt;
&lt;p&gt;　　以下是批量扫描初始化Bean 交给Spring管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;com.sk.service.*&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;IOC&lt;/h3&gt;
&lt;p&gt;ioc 是依赖注入，当我们的成员变量是Spring的一个Bean的时候，那这个成员变量可以由Spring帮我们注入(Spring会通过反射调用Set方法)&lt;/p&gt;
&lt;p&gt;依赖注入也叫控制反转，以前编程完完全全控制在我自己的手里。用了Spring之后 成员变量的初始化过程控制过程反转到Spring手里。&lt;/p&gt;
&lt;p&gt;注解用法:&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　DemoService demoService;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;AOP&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/ssskkk/p/9191845.html&quot; target=&quot;_blank&quot;&gt;AOP的实现原理，动态代理。&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从代理的原理我们知道，代理的目的是调用目标方法时可以转而执行&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/InvocationHandler.html&quot; target=&quot;_blank&quot;&gt;InvocationHandler&lt;/a&gt;的&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/InvocationHandler.html#invoke(java.lang.Object,%20java.lang.reflect.Method,%20java.lang.Object[])&quot; target=&quot;_blank&quot;&gt;invoke&lt;/a&gt;方法，所以如何在&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/InvocationHandler.html&quot; target=&quot;_blank&quot;&gt;InvocationHandler&lt;/a&gt;上做文章就是Spring实现AOP的关键所在。&lt;/p&gt;
&lt;p&gt;Spring的AOP实现遵守AOP联盟的约定，同时Spring又扩展了它。增加了 PointCut Advisor接口使得其更加灵活&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 切面逻辑类的对象 --&amp;gt;
    &amp;lt;bean id=&quot;myInterceptor&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.sk.util.MyInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 在add方法上加各种各样的我们切入进来的逻辑 --&amp;gt;
        &amp;lt;aop:pointcut expression=&quot;execution(public * com.sk.service..*.*(..))&quot; id=&quot;servicePointcut&quot;/&amp;gt;
        
        &amp;lt;aop:aspect id = &quot;logAspect&quot; ref=&quot;myInterceptor&quot;&amp;gt;
            &amp;lt;!-- aop:pointcut可以加到aspect的里面来   加到里面的话 只能是logAspect 这个aspect使用 --&amp;gt;
            &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;servicePointcut&quot;/&amp;gt;
            &amp;lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;servicePointcut&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们执行的时候 符合我们execution(public * com.sk.service..*.*(..))语法要求的方法的时候，&lt;/p&gt;
&lt;p&gt;它会在方法执行之前 执行before方法(logInterceptor的before方法) 方法执行之后 执行after方法。&lt;/p&gt;
&lt;h3&gt;Junit测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testIoc() {
        BeanFactory beanFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext-core.xml&quot;&lt;span&gt;);
        DemoService demoService &lt;/span&gt;= beanFactory.getBean(DemoService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        demoService.testAop();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;利用JoinPoint模拟AOP 实现事物管理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;JoinPoint:连接点(AOP切面切到我们程序时的连接点，切入的那个点)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的配置保持不变，首先给我们的Service 加一个自定义的注解&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MyAnnotation {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String transaction() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DemoServiceImpl  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DemoService{
    @Override
    @MyAnnotation(transaction&lt;/span&gt;= &quot;transaction&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testAop() {
        System.out.println(&lt;/span&gt;&quot;excute Service***********&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;完善我们的切面逻辑类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们的切面发现这个注解的时候 就进行事物的控制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyInterceptor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; before(JoinPoint jp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        MyAnnotation myAnnotation &lt;/span&gt;=&lt;span&gt;getHandlerChain(jp);
        System.out.println(&lt;/span&gt;&quot;方法开始通过AOP拿到方法上的注解-开始事物&quot;+&lt;span&gt;myAnnotation.transaction());
    }    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; after(JoinPoint jp)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception  {
        MyAnnotation myAnnotation &lt;/span&gt;=&lt;span&gt;getHandlerChain(jp);
        System.out.println(&lt;/span&gt;&quot;放过结束通过AOP拿到方法上的注解-结束事物&quot;+&lt;span&gt;myAnnotation.transaction());
    }    
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取方法或者类上的HandlerChain注解，方法上的优先 &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; MyAnnotation getHandlerChain(JoinPoint jp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        MethodSignature methodSignature &lt;/span&gt;=&lt;span&gt; (MethodSignature) jp.getSignature();
        Method realMethod &lt;/span&gt;=&lt;span&gt; jp.getTarget().getClass().getDeclaredMethod(methodSignature.getName(), methodSignature.getParameterTypes());  
        MyAnnotation myAnnotation &lt;/span&gt;= realMethod.getAnnotation(MyAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(myAnnotation==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Object&amp;gt; cls =&lt;span&gt; jp.getTarget().getClass();
            myAnnotation &lt;/span&gt;= (MyAnnotation) cls.getAnnotation(MyAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; myAnnotation;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;p&gt;方法开始通过AOP拿到方法上的注解-开始事物transaction&lt;br/&gt;excute Service***********&lt;br/&gt;放过结束通过AOP拿到方法上的注解-结束事物transaction&lt;/p&gt;
&lt;p&gt;这里只是打印模拟，项目中需要和JDBC(或者Mybatis Hibernate)结合，进而控制数据库transaction的开启和关闭&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ssskkk/p/9191845.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;推荐文章JAVA动态代理设计模式(AOP背后的原理)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:50:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssskkk/p/9281785.html</dc:identifier>
</item>
<item>
<title>Python学习：16.Python面对对象（三、反射，构造方法，静态字段，静态方法） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9357613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9357613.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、构造方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在使用类创建对象的时候（就是类后面加括号）就自动执行__init__方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj &lt;/span&gt;=&lt;span&gt; A()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;虽然只是创建了obj对象，但是执行了__init__方法，输出了A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Python中派生类可以继承父类的构造方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.基于super()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遇到super()就表示去执行父类的xxx属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.tp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;annimal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        super(B,self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行B父类中的__init__方法，这里的self是obj&lt;br/&gt;　　　　 #super里的self不是传入后面的__init__方法里，而是直接传入A中的__init__，这里super会帮你传递参数&lt;/span&gt;
&lt;span&gt;
obj &lt;/span&gt;=&lt;span&gt; B()

输出结果：
B
A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.通过父类的名称执行父类的构造方法。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.tp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;annimal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        A.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;父类的名称跟上__init__()&lt;/span&gt;
&lt;span&gt;
obj &lt;/span&gt;=&lt;span&gt; B()    


输出结果：
B
A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两种方式中推荐super，使用第二中方法的时候，进行继承父类的方法的时候，是你指定父类的方法，看起来比较乱，但是使用super的时候，没有让你指定父类的名称，这种继承时候就按照正常的继承规则（上一节所讲）来进行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、反射&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;利用反射查看面向对象的成员&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据字符串的形式去对象（某个模块）操作其成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fshow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

r &lt;/span&gt;= hasattr(Foo,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看Foo类中是否有show函数&lt;/span&gt;
obj = Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
s &lt;/span&gt;= hasattr(obj,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看obj对象里name是否存在&lt;/span&gt;
t = hasattr(obj,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(t)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过对象查看是否存在show这个函数&lt;/span&gt;
&lt;span&gt;
输出结果：
True
True
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们通过类进行查询的时候，仅仅只能找到类中的属性，但是我们通过类创建的对象查询的时候，我们不但可以找到对象中的属性（例如，self.name，直接在类中查询找不到），还可以找到对象中的方法（例如show函数），因为对象中有一个指向类的指针，当通过对象进行查询的时候，可以通过指针找到类中的属性。&lt;/p&gt;
&lt;h3&gt;利用反射导入模块、查找类、创建对象、查找对象中的字段&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.首先使用__import__导入文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数功能用于动态的导入模块，主要用于反射或者延迟加载模块。&lt;/p&gt;
&lt;p&gt; __import__(module)相当于import module&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.使用getattr(所导入的文件名，类名)导入类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getattr根据字符串的形式去某个模块中寻找东西&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.通过找到的类创建对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.获取对象中的属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;s2.py文件中的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fshow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s1.py文件中的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
m = &lt;span&gt;__import__&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

class_name &lt;/span&gt;= getattr(m,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj &lt;/span&gt;= class_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

val &lt;/span&gt;= getattr(obj,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(val)


输出结果：
Alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;三、静态字段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;静态字段的作用，将每个对象里存在的重复的东西，使用静态字段在类中只需写一份。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    annimal &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个是静态字段，是在类中保存的&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;普通字段，存放在对象中&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;普通方法，存放在类中&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Foo.annimal)


输出结果：
Cat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用静态字段的时候，优先使用类名访问静态字段。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;四、静态方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，主要是一些逻辑属于类，但是和类本身没有交互，即在静态方法中，不会涉及到类中的方法和属性的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    annimal &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;装饰器，使用这个装饰器装饰类中的一个方法，这个方法就变为静态方法&lt;/span&gt;
&lt;span&gt;    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; out():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


Foo.out()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;静态方法中不需要传递self，所以访问静态方法优先使用类去访问&lt;/span&gt;
obj =&lt;span&gt; Foo()
obj.out()


输出结果：
out
out&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态方法可以让我们不需要创建对象就可以执行类中的方法。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;五、类方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　类方法是将类本身作为对象进行操作的方法。他和静态方法的区别在于：不管这个方式是从实例调用还是从类调用，它都用第一个参数把类传递过来&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    annimal &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;装饰器，使用这个装饰器装饰类中的一个方法，这个方法就变为类方法&lt;/span&gt;
&lt;span&gt;    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; out(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,cls)


Foo.out()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;类方法，会自动将的类传递到类方法的cls中&lt;/span&gt;
&lt;span&gt;

输出结果：
out &lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 23 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9357613.html</dc:identifier>
</item>
<item>
<title>ParisGabriel：Python全栈工程师（0基础到精通）教程 第二十五课（文件操作、） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9357601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9357601.html</guid>
<description>
&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;&lt;span&gt;ParisGabriel&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;         每天坚持手写  一天一篇  决定坚持几年 为了梦想为了信仰&lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;Python人工智能从入门到精通&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;最近简直要死了 发烧感冒 喉咙痛。。。。、&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;如何长期保存计算机中数据：&lt;br/&gt;需要文件操作&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;文件 file：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　文件&lt;strong&gt;是用于数据存储的单位&lt;/strong&gt;&lt;br/&gt;　　　　文件通常&lt;strong&gt;用来长期储存数据&lt;/strong&gt;&lt;br/&gt;　　　　文件中的&lt;strong&gt;数据&lt;/strong&gt;是&lt;strong&gt;以字节为单位&lt;/strong&gt;进行&lt;strong&gt;顺序储存&lt;/strong&gt;的&lt;br/&gt;&lt;span&gt;&lt;strong&gt;文件的操作流程：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;1.打开文件&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;2.读/写文件&lt;/strong&gt;&lt;br/&gt;　&lt;strong&gt;　3.关闭文件&lt;/strong&gt;&lt;br/&gt;　　注：&lt;br/&gt;　　　　&lt;strong&gt;任何&lt;/strong&gt;操作&lt;strong&gt;系统&lt;/strong&gt;， 一个应用程序&lt;strong&gt;同时打开文件&lt;/strong&gt;的&lt;strong&gt;数量有&lt;/strong&gt;最大数&lt;strong&gt;限&lt;/strong&gt;制&lt;br/&gt;&lt;strong&gt;文件打开函数：&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;open&lt;/span&gt;&lt;/strong&gt;（file， mode=‘rt’） 用于&lt;strong&gt;打开&lt;/strong&gt;一个&lt;strong&gt;文件&lt;/strong&gt;， 返回此文件流对象，&lt;br/&gt;　　如果打开文件&lt;strong&gt;失败&lt;/strong&gt;， 则会&lt;strong&gt;触发osError&lt;/strong&gt;错误&lt;br/&gt;文件的关闭方法：&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;F.colse（）&lt;/span&gt;&lt;/strong&gt; #&lt;strong&gt;关闭问津&lt;/strong&gt;， &lt;strong&gt;释放系统资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意文件的打开和关闭操作&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./aaa.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不存在此文件&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; f = open('./myfile.txt')  # 不存在此文件&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开文件成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处要进行读/写操作&lt;/span&gt;
&lt;span&gt;
    f.close()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 半闭文件&lt;/span&gt;
&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件方法：&lt;/p&gt;
&lt;h2 id=&quot;_1&quot;&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;mode&quot;&gt;mode 模式字符的含义&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'r'&lt;/td&gt;
&lt;td&gt;以只读方式打开(默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;'w'&lt;/td&gt;
&lt;td&gt;以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;'x'&lt;/td&gt;
&lt;td&gt;创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生&quot;FileExistsError&quot;错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'a'&lt;/td&gt;
&lt;td&gt;以只写文件打开一个文件，如果有原文件则追加到文件末尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;'b'&lt;/td&gt;
&lt;td&gt;用二进制模式打开&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'t'&lt;/td&gt;
&lt;td&gt;文本文件模式打开 (默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'+'&lt;/td&gt;
&lt;td&gt;为更新内容打开一个磁盘文件 (可读可写)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;缺省模式是 'rt'&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;'w+b'&lt;/span&gt; 可以实现二进制随机读写，当打开文件时，文件内容将被清零&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;'r+b'&lt;/span&gt; 以二进制读和更新模式打开文件,打开文件时不会清空文件内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;'r+'&lt;/span&gt; 以文本模式读和更新模式打开文件,打开文件时不会清空文件内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;python_1&quot;&gt;&lt;span&gt;python 文件常用方法:&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.close()&lt;/td&gt;
&lt;td&gt;关闭文件(关闭后文件不能再读写会发生ValueError错误)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.readline()&lt;/td&gt;
&lt;td&gt;读取一行数据, 如果到达文件尾则返回空行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;F.readlines(max_chars=-1)&lt;/td&gt;
&lt;td&gt;返回每行字符串的列表,max_chars为最大字符(或字节)数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.writelines(lines)&lt;/td&gt;
&lt;td&gt;将字符串的列表或字符串的列表中的内容写入文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;二进制文件操作方法&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.read(size=-1)&lt;/td&gt;
&lt;td&gt;从一个文件流中最多读取size个字符(文本文件)或字节(二进制文件),如果不给出参数，则默认读取文件中全部的内容并返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.write(text)&lt;/td&gt;
&lt;td&gt;写一个字符串到文件流中，返回写入的字符数(文本文件)或字节数(二进制文件)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.tell()&lt;/td&gt;
&lt;td&gt;返回当前文件流读写指针的绝对位置(字节为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seek(offset, whence=0)&lt;/td&gt;
&lt;td&gt;改变数据流读写指针的位置，返回新的绝对位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.flush()&lt;/td&gt;
&lt;td&gt;把写入文件对象的缓存内容写入到磁盘&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.readable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可读,可读返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.writable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可写,可写返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seekable()&lt;/td&gt;
&lt;td&gt;返回这个文件对象是否支持随机定位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.truncate(pos = None)&lt;/td&gt;
&lt;td&gt;剪掉 自pos位置之后的数据，返回新的文件长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;文本文件操作：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;操作模式：&lt;/strong&gt;&lt;br/&gt;　　‘t’&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1.默认&lt;strong&gt;文件&lt;/strong&gt;中&lt;strong&gt;储存的都为字节数据&lt;/strong&gt;， 在&lt;strong&gt;读写过程&lt;/strong&gt;中&lt;strong&gt;会自动&lt;/strong&gt;进行&lt;strong&gt;编解码&lt;/strong&gt;操作&lt;br/&gt;　　　　2.文本&lt;strong&gt;文件以行位单位进行分割&lt;/strong&gt;， 在&lt;strong&gt;python内部统一用&quot;\n&quot;&lt;/strong&gt;做为换行符&lt;strong&gt;进行分割&lt;/strong&gt;&lt;br/&gt;　　　　3.对文本文件的&lt;strong&gt;读写操作需要用字符串（str）进行数据操作&lt;/strong&gt;&lt;br/&gt;Linux换行符: '\n'&lt;br/&gt;Windows 换行符: '\r\n'&lt;br/&gt;新的Mac OS 换行符: '\n'&lt;br/&gt;旧的Macintosh换行符: '\r'(已不用了)&lt;/p&gt;

&lt;p&gt;文件流对象是可迭代对象， 迭代过程中将换行符“\n”作为分隔符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phonenumber.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(line)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印每一行的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;标准输入输出文件：&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;sys.stdin&lt;/strong&gt;&lt;/span&gt; 　　 &lt;strong&gt;标准输入&lt;/strong&gt;文件&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;Ctrl + D&lt;/span&gt;&lt;/strong&gt;　　    输入文件&lt;strong&gt;结束符&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;sys.stdout&lt;/span&gt;&lt;/strong&gt; 　 &lt;strong&gt; 标准输出文件&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;sys.stderr &lt;/strong&gt;&lt;/span&gt;      &lt;strong&gt;标准错误&lt;/strong&gt;输出文件&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;标准文件绝对不能关闭&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;Linux系统内所有的硬件都会映射成文件 关闭文件会导致错误&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;模块：sys&lt;/strong&gt;&lt;br/&gt;注：&lt;br/&gt;　　&lt;strong&gt;标准文件不需要打开和关闭就可以使用&lt;/strong&gt;&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

sys.stdout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是标准输出\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
sys.stderr.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是一个错误\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

s &lt;/span&gt;=&lt;span&gt; sys.stdin.read()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二进制文件操作：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　二进制文件操作模式字符：&lt;span&gt;&lt;strong&gt;‘b’&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;默认&lt;/strong&gt;文件中存储的是以&lt;strong&gt;字节数据为单位&lt;/strong&gt;， &lt;strong&gt;通常有人为规定&lt;/strong&gt;的&lt;strong&gt;格式&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;二进制文件&lt;/strong&gt;操作需要&lt;strong&gt;用字节串进行读写&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;F.read&lt;/span&gt;&lt;/strong&gt;（）/&lt;span&gt;&lt;strong&gt;F.readline&lt;/strong&gt;&lt;/span&gt;() &lt;span&gt;&lt;strong&gt;F.readlines&lt;/strong&gt;&lt;/span&gt;（）返回类型&lt;br/&gt;对于文本操作&lt;br/&gt;　　&lt;span&gt;F.write&lt;/span&gt;（） 对于二进制文件也需要用字节串进行操作&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;F.tell&lt;/strong&gt;&lt;/span&gt;：&lt;br/&gt;&lt;strong&gt;　　作用：&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;返回当前的读写位置&lt;/strong&gt;（从文件头以字节为单位）&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;F.seek&lt;/span&gt;&lt;/strong&gt;方法：&lt;br/&gt;　　　　F.seek（偏移量，whence=相对位置）&lt;br/&gt;&lt;strong&gt;　　偏移量&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;大于0&lt;/strong&gt;的数代表向&lt;strong&gt;文件尾方向移动&lt;/strong&gt;的字节数&lt;br/&gt;　　　　&lt;strong&gt;小于0&lt;/strong&gt;的数代表向&lt;strong&gt;文件头方向移动&lt;/strong&gt;的字节数&lt;br/&gt;　&lt;strong&gt;　相对位置&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;代表从&lt;strong&gt;文件头开始偏移&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;代表从文件当&lt;strong&gt;前位置开始偏移&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;代表从&lt;strong&gt;文件尾开始偏移&lt;/strong&gt; （第一个参数必须是负的）&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意用seek改变文件的读写位置,用tell来得到读写位置&lt;/span&gt;
&lt;span&gt;
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myseek.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
b &lt;/span&gt;= f.read(2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; b'AB' 读取出来&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(b)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; b'AB&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从头开始向后走5个字节&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; f.seek(5, 0)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从当前位置向后走3个字节&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; f.seek(3, 1)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从文件尾向前数15个字节&lt;/span&gt;
f.seek(-15, 2&lt;span&gt;)

b &lt;/span&gt;= f.read(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; b'abcde'&lt;/span&gt;
&lt;span&gt;
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;汉字编码&lt;/span&gt;（只讲两种）&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;国标系列:&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;GB18030&lt;/span&gt;(&lt;strong&gt;二字节或四字节&lt;/strong&gt;编码&lt;strong&gt;27553&lt;/strong&gt;个字)&lt;br/&gt;　　　　&lt;span&gt;GBk&lt;/span&gt;（&lt;strong&gt;二字节&lt;/strong&gt;编码&lt;strong&gt;21003&lt;/strong&gt;个字）&lt;br/&gt;　　　　&lt;span&gt;GB2312&lt;/span&gt;（&lt;strong&gt;二字节&lt;/strong&gt;编码&lt;strong&gt;6763&lt;/strong&gt;个字）&lt;br/&gt;　　　　（Windows 常用）&lt;br/&gt;　　&lt;strong&gt;国际标准&lt;/strong&gt;： &lt;strong&gt;Unicode &amp;lt;---&amp;gt; UTF-8 (Ascii 占1字节 汉字占3字节)&lt;/strong&gt;&lt;br/&gt;　　　　（Linux Mac OS X / IOS /Android）&lt;br/&gt;　　　　python编码字符串：&lt;br/&gt;　　　　‘gb18030’&lt;br/&gt;　　　　‘gb2312’&lt;br/&gt;　　　　‘gbk’&lt;br/&gt;　　　　‘utf-8’&lt;br/&gt;　　　　‘ascii’&lt;br/&gt;　　　　....&lt;br/&gt;&lt;strong&gt;以上字符串用于&lt;span&gt;encide&lt;/span&gt;和&lt;span&gt;decode&lt;/span&gt;中&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;编码注释：&lt;/strong&gt;&lt;br/&gt;　　在Python源文件中的&lt;strong&gt;第一行&lt;/strong&gt;或&lt;strong&gt;第二行&lt;/strong&gt;写入如下内容：&lt;br/&gt;　　　　&lt;strong&gt;&lt;span&gt;# -*- codeing：gbk -*-&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　#设置源文件&lt;strong&gt;编码格式为gbk&lt;/strong&gt;&lt;br/&gt;　　　　或&lt;br/&gt;　　　&lt;span&gt;&lt;strong&gt;　# -*- codeing：utf-8 -*-&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　#设置源文件&lt;strong&gt;编码格式为utf-8&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;作用：&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;告诉解释执行器&lt;/strong&gt;此&lt;strong&gt;文件的编码&lt;/strong&gt;是什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180723233711203-1903857670.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;练习:&lt;br/&gt;自己写一个文件 'info.txt' 内部存一些文字信息&lt;br/&gt;如:&lt;br/&gt;张三 20 100&lt;br/&gt;李四 21 96&lt;br/&gt;小王 22 98&lt;br/&gt;写程序将这些数据读取出来，打印到终端上&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfile.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    L &lt;/span&gt;=&lt;span&gt; f.readlines()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
        s &lt;/span&gt;=&lt;span&gt; x.strip()
        n, a, s &lt;/span&gt;=&lt;span&gt; s.split()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, n, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, int(a), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成绩：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, int(s))
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开文件是失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;练习:&lt;br/&gt;1. 写程序，循环输入很多个人的姓名，电话号码,&lt;br/&gt;当输入结束后将这些信息存入到文件phonenumber.txt中&lt;br/&gt;(建议先用列表暂存数据，格式自己定义)&lt;/p&gt;
&lt;p&gt;　　２．　写程序，将phonenumber.txt文件中的数据读取出来．&lt;br/&gt;　　　　　再用以下格式打印出来:&lt;br/&gt;如:&lt;br/&gt;小张 的电话是 13888888888&lt;br/&gt;小李 的电话是 13999999999&lt;/p&gt;

&lt;p&gt;练习:&lt;br/&gt;1. 写程序实现复制文件的功能&lt;br/&gt;要求:&lt;br/&gt;1. 要考虑特大文件问题&lt;br/&gt;2. 要关闭文件&lt;br/&gt;3. 要能复制二进制文件&lt;br/&gt;如:&lt;br/&gt;请输入源文件路径名: /home/tarena/xxx.tar.gz&lt;br/&gt;请输入目标文件路径名: ./a.tar.gz&lt;br/&gt;显示:&lt;br/&gt;文件已成功复制&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; copy_myfile():
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        ypath &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please inout raw path:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        xpath &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please inout new path:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        f1 &lt;/span&gt;= open(xpath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w+b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        f &lt;/span&gt;= open(ypath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r+b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
            f1.write(x)
        f1.close()
        f.close()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File copied&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file not inexeistence&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


copy_myfile()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 修改学生信息管理程序,要求加入两个功能:&lt;br/&gt;9) 保存信息到文件(si.txt)&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
L = [{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 98&lt;span&gt;},
     {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 21, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 99&lt;span&gt;},
     {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Garin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 19, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 100&lt;span&gt;}]


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student_file(L):
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./si.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
            f.write(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; FileExistsError:
        f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./si.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
            f.write(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

student_file(L)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;10) 从文件中读取数据(si.tx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;..................&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:39:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9357601.html</dc:identifier>
</item>
<item>
<title>springboot+security整合1 - 烦嚣的人</title>
<link>http://www.cnblogs.com/wuyoucao/p/9357551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyoucao/p/9357551.html</guid>
<description>&lt;p&gt;下一篇，&lt;a href=&quot;https://www.cnblogs.com/wuyoucao/p/9357554.html&quot;&gt;点击跳转&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明springboot版本2.0.3&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-介绍&quot;&gt;一、 介绍&lt;/h2&gt;
&lt;p&gt;  Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。&lt;/p&gt;
&lt;h2 id=&quot;二-环境搭建&quot;&gt;二、 环境搭建&lt;/h2&gt;
&lt;p&gt;  建立springboot2项目,加入security依赖,mybatis依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库为传统的用户--角色--权限，权限表记录了url和method，springboot配置文件如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;mybatis:
  type-aliases-package: com.example.demo.entity
server:
  port: 8081
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true
    username: root
    password: 123456
  http:
    encoding:
      charset: utf-8
      enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;springboot启动类中加入如下代码,设置路由匹配规则。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void configurePathMatch(PathMatchConfigurer configurer) {
    configurer.setUseSuffixPatternMatch(false) //设置路由是否后缀匹配，譬如/user能够匹配/user.,/user.aa
        .setUseTrailingSlashMatch(false); //设置是否后缀路径匹配，比如/user能够匹配/user,/user/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三-security配置&quot;&gt;三、 security配置&lt;/h2&gt;
&lt;p&gt;  默认情况下security是无需任何自定义配置就可使用的，我们不考虑这种方式，直接讲如何个性化登录过程。&lt;/p&gt;
&lt;h4 id=&quot;建立security配置文件目前配置文件中还没有任何配置&quot;&gt;1、 建立security配置文件,目前配置文件中还没有任何配置。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;个性化登录security中的登录如下&quot;&gt;2、 个性化登录，security中的登录如下：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAZAAD/4QOTaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTdFRTJGMTQ4RTFFMTFFOEFCNzlFMzVDMTkzNERBNDIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTdFRTJGMTM4RTFFMTFFOEFCNzlFMzVDMTkzNERBNDIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiBXaW5kb3dzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiBzdFJlZjpkb2N1bWVudElEPSI2NDVGMTQxMkU0QjRCRTBBNTU0N0YyN0YzNjBGQUNFMSIvPiA8ZGM6Y3JlYXRvcj4gPHJkZjpTZXE+IDxyZGY6bGk+ZnhiPC9yZGY6bGk+IDwvcmRmOlNlcT4gPC9kYzpjcmVhdG9y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&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;security需要一个user的实体类实现&lt;code&gt;UserDetails&lt;/code&gt;接口,该实体类最后与系统中用户的实体类分开，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SecurityUser implements UserDetails{
    private static final long serialVersionUID = 1L;
    private String password;
    private String name;
    List&amp;lt;GrantedAuthority&amp;gt; authorities;
    
    public User(string name,string password) {
        this.id = id;
        this.password = password;
        this.name = name;
        this.age = age;
    }

    public void setAuthorities(List&amp;lt;GrantedAuthority&amp;gt; authorities) {
        this.authorities = authorities;
    }

    @Override
    public Collection&amp;lt;GrantedAuthority&amp;gt; getAuthorities() {
        return this.authorities;
    }

    @Override //获取校验用户名
    public String getUsername() {
        return String.valueOf(this.id);
    }

    @Override //获取校验用密码
    public String getPassword() {
        return password;
    }

    @Override //账户是否未过期
    public boolean isAccountNonExpired() {
        // TODO Auto-generated method stub
        return true;
    }

    @Override  //账户是否未锁定
    public boolean isAccountNonLocked() {
        // TODO Auto-generated method stub
        return true;
    }

    @Override  //帐户密码是否未过期，一般有的密码要求性高的系统会使用到，比较每隔一段时间就要求用户重置密码
    public boolean isCredentialsNonExpired() {
        // TODO Auto-generated method stub
        return true;
    }

    @Override //账户是否可用
    public boolean isEnabled() {
        // TODO Auto-generated method stub
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编写了实体类还需要编写一个服务类SecurityService实现&lt;code&gt;UserDetailsService&lt;/code&gt;接口，重写loadByUsername方法，通过这个方法根据用户名获取用户信息，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SecurityUserService implements UserDetailsService {
    @Autowired
    private JurisdictionMapper jurisdictionMapper;
    @Autowired
    private UserMapper userMapper;
    private Logger log = LoggerFactory.getLogger(this.getClass());


    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.info(&quot;登录用户id为：{}&quot;,username);
        int id = Integer.valueOf(username);
        User user = userMapper.getById(id);
        if(user==null) {
            //抛出错误，用户不存在
            throw new UsernameNotFoundException(&quot;用户名 &quot;+username+&quot;不存在&quot;);
        }
        //获取用户权限
        List&amp;lt;GrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Jurisdiction&amp;gt; jurisdictions = jurisdictionMapper.selectByUserId(id);
        for(Jurisdiction item : jurisdictions) {
            GrantedAuthority authority = new MyGrantedAuthority(item.getMethod(),item.getUrl());
            authorities.add(authority);
        }
        SecurityUser securityUser = new SecurityUser(user.getName(),user.getPassword(),authority):
        user.setAuthorities(authorities);
        return securityUser;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通常我们会对密码进行加密，所有还要编写一个passwordencode类，实现PasswordEncoder接口，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class MyPasswordEncoder implements PasswordEncoder {
    private Logger log = LoggerFactory.getLogger(this.getClass());

    @Override //不清楚除了在下面方法用到还有什么用处
    public String encode(CharSequence rawPassword) {
        return StringUtil.StringToMD5(rawPassword.toString());
    }

    //判断密码是否匹配
    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        return encodedPassword.equals(this.encode(rawPassword));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编辑配置文件&quot;&gt;3、 编辑配置文件&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;编写config Bean以使用上面定义的验证逻辑,securityUserService、myPasswordEncoder通过@Autowired引入。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(securityUserService)
        .passwordEncoder(myPasswordEncoder);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后编写configure Bean（和上一个不一样，参数不同），实现security验证逻辑,代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    protected void configure(HttpSecurity http) throws Exception {
        http
        .csrf() //跨站
        .disable() //关闭跨站检测
        .authorizeRequests()//验证策略策略链
            .antMatchers(&quot;/public/**&quot;).permitAll()//无需验证路径
           .antMatchers(&quot;/login&quot;).permitAll()//放行登录
            .antMatchers(HttpMethod.GET, &quot;/user&quot;).hasAuthority(&quot;getAllUser&quot;)//拥有权限才可访问
            .antMatchers(HttpMethod.GET, &quot;/user&quot;).hasAnyAuthority(&quot;1&quot;,&quot;2&quot;)//拥有任一权限即可访问
            //角色类似，hasRole(),hasAnyRole()
            .anyRequest().authenticated()
        .and()
        .formLogin()
            .loginPage(&quot;/public/unlogin&quot;) //未登录跳转页面,设置了authenticationentrypoint后无需设置未登录跳转页面
            .loginProcessingUrl(&quot;/public/login&quot;)//处理登录post请求接口，无需自己实现
            .successForwardUrl(&quot;/success&quot;)//登录成功转发接口
            .failureForwardUrl(&quot;/failed&quot;)//登录失败转发接口
            .usernameParameter(&quot;id&quot;) //修改用户名的表单name，默认为username
            .passwordParameter(&quot;password&quot;)//修改密码的表单name，默认为password
        .and()
        .logout()//自定义登出
            .logoutUrl(&quot;/public/logout&quot;) //自定义登出api，无需自己实现
            .logoutSuccessUrl(&quot;public/logoutSuccess&quot;)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里便可实现security与springboot的基本整合。&lt;/p&gt;
&lt;h2 id=&quot;四实现记住我功能&quot;&gt;四、实现记住我功能&lt;/h2&gt;
&lt;h4 id=&quot;建表&quot;&gt;1、 建表&lt;/h4&gt;
&lt;p&gt;  记住我功能需要数据库配合实现，首先要在数据库建一张表用户保存cookie和用户名，数据库建表语句如下：不能做修改&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `persistent_logins` (
  `username` varchar(64) NOT NULL,
  `series` varchar(64) NOT NULL,
  `token` varchar(64) NOT NULL,
  `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`series`)
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写remembermeservice-bean&quot;&gt;2、 编写rememberMeservice Bean&lt;/h4&gt;
&lt;p&gt;  代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    public RememberMeServices rememberMeServices(){
        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
        jdbcTokenRepository.setDataSource(dataSource);
        PersistentTokenBasedRememberMeServices rememberMeServices =
                new PersistentTokenBasedRememberMeServices(&quot;INTERNAL_SECRET_KEY&quot;,securityUserService,jdbcTokenRepository);
        //还可设置许多其他属性
       rememberMeServices.setCookieName(&quot;kkkkk&quot;); //客户端cookie名
        return rememberMeServices;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dataSource为@Autowired引入&lt;/p&gt;
&lt;h4 id=&quot;配置文件设置remember&quot;&gt;3、 配置文件设置remember&lt;/h4&gt;
&lt;p&gt;  在config(HttpSecurity http)中加入记住我功能&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;.rememberMe()
    .rememberMeServices(rememberMeServices())
    .key(&quot;INTERNAL_SECRET_KEY&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在登录表单中设置remember-me即可实现记住我功能。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:21:00 +0000</pubDate>
<dc:creator>烦嚣的人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyoucao/p/9357551.html</dc:identifier>
</item>
</channel>
</rss>