<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>返回一个二维数整数组中最大子数组的和 - 掠取你芳心</title>
<link>http://www.cnblogs.com/zzy0823/p/9825248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzy0823/p/9825248.html</guid>
<description>&lt;p&gt;题目：返回一个二维整数数组中最大子数组的和 &lt;/p&gt;
&lt;div class=&quot;O&quot; readability=&quot;9&quot;&gt;要求： n输入一个二维整形数组，数组里有正数也有负数。
&lt;div class=&quot;O2&quot; readability=&quot;20.5&quot;&gt;
&lt;p&gt;n二维数组中连续的一个子矩阵组成一个子数组，每个子数组都有一个和。&lt;/p&gt;
&lt;p&gt;n求所有子数组的和的最大值。要求时间复杂度为O(n)。&lt;/p&gt;
&lt;div readability=&quot;28&quot;&gt;组员：张子阳：责程序分析，代码编程。马世杰：代码复审和测试。

&lt;p&gt;思路：结合上一次编程的情况，我们想二维数组和一位数组求最大子数组有什么联系吗？我们想，可以把每行求和，然后再把每行的和看成一个一维数组，再按照一维数组求最大子数组的和的方法就可以解决这个问题了。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;#include&amp;lt;iostream&amp;gt;&lt;br/&gt;using namespace std;&lt;br/&gt;void main ()&lt;br/&gt;{&lt;br/&gt;    int x,y,i,j,n=0,A[100][100];&lt;br/&gt; &lt;br/&gt;    cout&amp;lt;&amp;lt;&quot;输入矩阵的行()和列&quot;;&lt;br/&gt;    cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y;&lt;br/&gt;    if(x&amp;gt;100||y&amp;gt;100)&lt;br/&gt;    {&lt;br/&gt;        cout&amp;lt;&amp;lt;&quot;请重新输入：&quot;;&lt;br/&gt;        cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y;&lt;br/&gt;    }&lt;br/&gt;    for(i=0;i&amp;lt;x;i++)&lt;br/&gt;    {&lt;br/&gt;        for(j=0;j&amp;lt;y;j++)&lt;br/&gt;        {&lt;br/&gt;            cin&amp;gt;&amp;gt;A[i][j];&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;    }&lt;br/&gt;    int sum[100]={0},max=0,result=A[0][0];&lt;br/&gt; &lt;br/&gt;    for(i=0;i&amp;lt;x;i++)//确定子数组的最大上界（为第i行）&lt;br/&gt;    {&lt;br/&gt;        while(n+i&amp;lt;x)//确定子数组有m+i行&lt;br/&gt;        {&lt;br/&gt;            //把子数组当成一位数组一样，求最大子数组的和&lt;br/&gt;            for(j=0;j&amp;lt;y;j++)&lt;br/&gt;            {&lt;br/&gt;                sum[j]=sum[j]+A[n+i][j];&lt;br/&gt; &lt;br/&gt;            }&lt;br/&gt;            max=0;&lt;br/&gt;            for(j=0;j&amp;lt;y;j++)&lt;br/&gt;            {&lt;br/&gt;                if(max+sum[j]&amp;gt;sum[j])&lt;br/&gt;                {&lt;br/&gt;                    max=max+sum[j];&lt;br/&gt;                }&lt;br/&gt;                else&lt;br/&gt;                {&lt;br/&gt;                    max=sum[j];&lt;br/&gt;                }&lt;br/&gt;                if(max&amp;gt;result)&lt;br/&gt;                {&lt;br/&gt;                    result=max;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            n++;//是子数组的行数+1&lt;br/&gt;        }&lt;br/&gt;        //初始化m和sum[]的值，使子数组最大上界下降1，之后重新循环。&lt;br/&gt;        n=0;&lt;br/&gt;        for(j=0;j&amp;lt;y;j++)&lt;br/&gt;        {&lt;br/&gt;            sum[j]=0;&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    cout&amp;lt;&amp;lt;result;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499919/201810/1499919-20181021153129685-2101731934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;在这次任务中，我们首先想到了是不是可以根据一维数组来进行二维数组的最大子数组求和，然后我们也在网上查了一些别人做的，最后我们才做出了这个程序，遇到的问题还是之前学的c语言太浅，而且大一学的现在基本上都忘了，基础不好，上网看着别人做的自己百度，最终才做出这个程序。最后附上我们的工作照。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499919/201810/1499919-20181021153938939-1428540572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 21 Oct 2018 07:40:00 +0000</pubDate>
<dc:creator>掠取你芳心</dc:creator>
<og:description>题目：返回一个二维整数数组中最大子数组的和 要求： n输入一个二维整形数组，数组里有正数也有负数。 n二维数组中连续的一个子矩阵组成一个子数组，每个子数组都有一个和。 n求所有子数组的和的最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzy0823/p/9825248.html</dc:identifier>
</item>
<item>
<title>设计模式——中介模式 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9784735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9784735.html</guid>
<description>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;假设有老赵、老钱、老孙三位房东，他们自己手里有一套房租需要出租，但是又有不同的需求，于是相互商量：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181021141350242-865088892.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可是出租房子的人毕竟很多，哪种房型好租，租什么价格需要了解很多出租情况，而自己要与那么多人交流需要花费很大的时间与精力……所以他们都不约而同地找到了中介，将自己房子出租的信息放到了中介&lt;span&gt;，让中介去和租客交互，自己有什么问题也可以直接找中介问，还能躺着收房租，只需要和中介打交道就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181021151433761-306578173.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这就是中介者模式的应用场景。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;中介者模式&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;通用类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181014174322927-230661543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mediator 抽象中介者角色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;抽象中介者角色定义统一的接口，用于各同事角色之间的通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Concrete Mediator 具体中介者角色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Colleague 同事角色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;每一个同事角色都知道中介者角色，而且与其他同事角色通信的时候，一定要通过中介者角色协作。协作分为两种，一种是本身的行为，比如自己状态变化，独立可以完成的行为；另一种是必须依赖中介者才能完成的行为，比如与其他同事角色通信。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;中介者例子&lt;/h2&gt;
&lt;h3&gt;前提条件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;老赵、老钱、老孙的房子信息如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;老赵：一套一室一厨一卫房子&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;老钱：一套一室一厅一卫的房子&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;老孙：一套两室一厅一厨一卫的房子&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;老赵感觉自己房子（一室一厨一卫）比老钱房子（一室一厅一卫）好出租，想比老钱的房子多租100元，如果老钱不告诉他自己的价格，那么老赵就准备按2500出租；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;老钱就想租2500，且想知道老赵和老孙的房子出租的信息；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;老孙觉得自己房子适合一家人住一起，想租3600，并且自己想知道小户型房子（老赵和老孙房子）出租情况；&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;关系类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181021151716217-1063856868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mediator：抽象中介者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LettingAgent：具体的中介者实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AbstractLessor：抽象的同事类（非必须）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;XXXLessor：具体的同事类（多个出租人之间关系对等，类似同事关系）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;代码实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于中介mediator来说，它指定老赵、老钱、老孙的信息，他们可以通过询问中介来知道自己想知道的事情，不需要单独分别去问另外两人，对象之间的依赖更简单了，中介实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mediator {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; MrZhaoLessor mrZhaoLessor;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; MrQianLessor mrQianLessor;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; MrSunLessor mrSunLessor;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Mediator(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mrZhaoLessor = &lt;span&gt;new&lt;/span&gt; MrZhaoLessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mrQianLessor = &lt;span&gt;new&lt;/span&gt; MrQianLessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mrSunLessor = &lt;span&gt;new&lt;/span&gt; MrSunLessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MrZhaoLessor getMrZhaoLessor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mrZhaoLessor;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMrZhaoLessor(MrZhaoLessor mrZhaoLessor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mrZhaoLessor =&lt;span&gt; mrZhaoLessor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MrQianLessor getMrQianLessor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mrQianLessor;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMrQianLessor(MrQianLessor mrQianLessor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mrQianLessor =&lt;span&gt; mrQianLessor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MrSunLessor getMrSunLessor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mrSunLessor;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMrSunLessor(MrSunLessor mrSunLessor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mrSunLessor =&lt;span&gt; mrSunLessor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getZhaoAndQianInfo();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getZhaoAndSunInfo();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getQianAndSunInfo();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getAllRoomInfo();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getAllRoomPrice();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体中介者实现了抽象中介者的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LettingAgent &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Mediator {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAllRoomInfo() {
        String roomInfo &lt;/span&gt;= &quot;我手里有这几种房型：\n&quot;
                + &lt;span&gt;super&lt;/span&gt;.getMrZhaoLessor().roomInfo() + &quot;\n&quot;
                + &lt;span&gt;super&lt;/span&gt;.getMrQianLessor().roomInfo() + &quot;\n&quot;
                + &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getMrSunLessor().roomInfo();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roomInfo;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAllRoomPrice() {
        String roomPrice &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;.getMrZhaoLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;.getMrZhaoLessor().roomPrice() + &quot;\n&quot;
                + &lt;span&gt;super&lt;/span&gt;.getMrQianLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;.getMrQianLessor().roomPrice() + &quot;\n&quot;
                + &lt;span&gt;super&lt;/span&gt;.getMrSunLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getMrSunLessor().roomPrice();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roomPrice;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getZhaoAndQianInfo(){
        String otherRoom &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;.getMrZhaoLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;.getMrZhaoLessor().roomPrice() + &quot;\n&quot;
                + &lt;span&gt;super&lt;/span&gt;.getMrQianLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getMrQianLessor().roomPrice();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; otherRoom;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getZhaoAndSunInfo(){
        String otherRoom &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;.getMrZhaoLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;.getMrZhaoLessor().roomPrice() + &quot;\n&quot;
                + &lt;span&gt;super&lt;/span&gt;.getMrSunLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getMrSunLessor().roomPrice();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; otherRoom;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getQianAndSunInfo(){
        String otherRoom &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;.getMrQianLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;.getMrQianLessor().roomPrice() + &quot;\n&quot;
                + &lt;span&gt;super&lt;/span&gt;.getMrSunLessor().roomInfo() + &quot;,价格：&quot; + &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getMrSunLessor().roomPrice();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; otherRoom;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以根据出租人之间是否有相同需求来决定是否需要增加出租人抽象接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractLessor {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Mediator mediator;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AbstractLessor(Mediator mediator){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mediator =&lt;span&gt; mediator;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;老赵的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MrZhaoLessor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractLessor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MrZhaoLessor(Mediator mediator) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(mediator);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String roomInfo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;老赵的一室一厨一卫&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal roomPrice() {
        BigDecimal roomWithKitchAndToiletPrice &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.mediator.getMrQianLessor().roomPrice();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (roomWithKitchAndToiletPrice == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自己内心价格&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; BigDecimal.valueOf(2500&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; roomWithKitchAndToiletPrice.add(BigDecimal.valueOf(100&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String talk() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;很好租，独立厨房卫生间&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;老钱与老孙实现差不多，以老钱为例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MrQianLessor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractLessor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MrQianLessor(Mediator mediator) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(mediator);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String roomInfo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;老钱的一室一厅一卫&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal roomPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; BigDecimal.valueOf(2500&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String askOtherRoomInfo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.mediator.getZhaoAndSunInfo();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;老赵与老钱通过中介交互：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        LettingAgent agent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LettingAgent();

        MrZhaoLessor zhaoLessor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MrZhaoLessor(agent);
        BigDecimal zhaoPrice &lt;/span&gt;=&lt;span&gt; zhaoLessor.roomPrice();
        String talk &lt;/span&gt;=&lt;span&gt; zhaoLessor.talk();
        System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;赵先生：\n&quot; + zhaoPrice + &quot;,\n&quot; + talk+&quot;\n&quot;&lt;span&gt;);

        MrQianLessor qianLessor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MrQianLessor(agent);
        String qianRoom &lt;/span&gt;=&lt;span&gt; qianLessor.askOtherRoomInfo();
        System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;钱先生：\n&quot; + qianRoom+&quot;\n&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;赵先生：&lt;br/&gt;2600,&lt;br/&gt;很好租，独立厨房卫生间&lt;/p&gt;&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;钱先生：&lt;br/&gt;老赵的一室一厨一卫,价格：2600&lt;br/&gt;老孙的两室一厅一厨一卫,价格：3600&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;优点：减少类之间的依赖，引入中介者将原来多对多依赖便成了一对一，降低了类之间的耦合性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：中介者封装了不同对象之间的依赖关系，当对象增多，中介者会变得很复杂，同事类越多中介者越复杂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;a href=&quot;https://github.com/yangyp8110/design-patterns/tree/master/src/main/java/mediator&quot; target=&quot;_blank&quot;&gt;本文demo&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 07:31:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>引言 假设有老赵、老钱、老孙三位房东，他们自己手里有一套房租需要出租，但是又有不同的需求，于是相互商量： 可是出租房子的人毕竟很多，哪种房型好租，租什么价格需要了解很多出租情况，而自己要与那么多人交流</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9784735.html</dc:identifier>
</item>
<item>
<title>记一次电话面试的题目 - 致力it</title>
<link>http://www.cnblogs.com/chenpt/p/9824548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenpt/p/9824548.html</guid>
<description>&lt;p&gt;昨天下午六点正准备关电脑下班去和对象约定好的地方吃饭的时候，突然接到了一个电话面试邀请，于是内心快速纠结了一下，还是同意了这次电话邀约（其实内心是拒绝的，但是转念一想刚好通过这个电话面试对自己查漏补缺），聊了接近一个小时的通话，公司的人都走的差不多了。别的不多说了，下面就整理下面试题吧。（文末公布下lz是怎么解决晚饭······聪明的你们应该能猜到结局了）&lt;/p&gt;
&lt;h2&gt;1.自我介绍 2.为什么离职&lt;/h2&gt;
&lt;p&gt;这些不关技术的事情我就不叙述了（把lz的经历的公司都问了个遍，就问为什么离职。。。好煎熬）&lt;/p&gt;
&lt;p&gt;下面正式切入技术问题，只记了个大概，暂且写出来，并附上答案（只是lz拙见，不做深入探讨）。&lt;/p&gt;
&lt;h2&gt;3.集合HashMap、HashTable、ConcurrentHashMap区别&lt;/h2&gt;
&lt;p&gt;面试官：你了解集合吗？&lt;/p&gt;
&lt;p&gt;lz:了解呀！&lt;/p&gt;
&lt;p&gt;面试官：说说HashMap、HashTable有什么不同？&lt;/p&gt;
&lt;p&gt;lz:首先最大的不同就是HashMap线程不安全，效率高、HashTable线程安全，效率低，还有HashMap允许k、v为null，HashTable不允许&lt;/p&gt;
&lt;p&gt;面试官：HashTable为什么是线程安全的？&lt;/p&gt;
&lt;p&gt;lz：因为HashTable内部为所有的操作都加了同步锁（synchronized）&lt;/p&gt;
&lt;p&gt;面试官：为什么加了synchronized锁会导致效率降低？&lt;/p&gt;
&lt;p&gt;lz：因为加了同步锁（synchronized）其他线程再想访问的话，必须等到前一个线程释放了锁才能使用。比如十个线程，只能一个一个排队等候执行，所以效率会降低。&lt;/p&gt;
&lt;p&gt;面试官：我们公司有些大数据量等需要用到HashTable，但又想保证执行效率，怎么办？还有其他可用的集合吗？&lt;/p&gt;
&lt;p&gt;lz：有啊ConcurrentHashMap。&lt;/p&gt;
&lt;p&gt;面试官：ConcurrentHashMap是如何保证线程安全的？&lt;/p&gt;
&lt;p&gt;lz：因为使用了分段锁segment。&lt;/p&gt;
&lt;p&gt;面试官：为什么分段锁比同步锁效率高？&lt;/p&gt;
&lt;p&gt;lz：分段锁就是把Map分成了多个segment去处理，进行put操作时，根据hashcode找到相应的锁，彼此之间不受影响，所以效率高。而同步锁--锁住的是整个HashTable，因此效率会低。&lt;/p&gt;
&lt;p&gt;面试官：知道HashMap的实现原理吗？了解hash碰撞吗？&lt;/p&gt;
&lt;p&gt;lz：HashMap是一个数组+链表的数据结构。采用hashing原理，在进行put 操作时根据Key计算出它的hashcode，根据hashcode找到相应的桶的位置。在进行get 时也是根据hashcode 找到相应位置的数据的。当发生hash碰撞时，即hashcode相同。那么会在相应的桶中形成一个链表结构进行存储。&lt;/p&gt;
&lt;h2&gt;4.如何保证订单重复提交的问题（当发生网络延迟等情况）&lt;/h2&gt;
&lt;p&gt;lz：楼主只回答了前端校验和后端校验具体其他操作不是很清楚，下面答案引用自百度百科只列举几个经典的（力争为园友提交较可信的答案）&lt;/p&gt;
&lt;p&gt;　　更详细的答案可以参考：http://www.bkjia.com/jingyan/471187.html&lt;/p&gt;
&lt;p&gt;　　1：在前端进行校验，当表单提交后，把提交按钮置灰&lt;/p&gt;
&lt;p&gt;　　2：表单提交后进行页面重定向，转到处理结果页面。&lt;/p&gt;
&lt;p&gt;　　3：在session中存放一个标识符（当表单数据被请求时，在session中生成一个标识符放在表单隐藏域中，当后端处理表单数据时，检查标识符是否存在，如果存在则表明第一次提交并从session中清除标识，如果不存在则表明重复提交）&lt;/p&gt;
&lt;p&gt;　　4：在数据中添加约束&lt;/p&gt;
&lt;h2&gt;5.防止订单重复支付问题&lt;/h2&gt;
&lt;p&gt;lz：我们公司的支付都是跳到微信或支付宝的（--把此问题抛给了腾讯和阿里）；但是我们自己应该也能想到一种解决方法：就是同一笔订单我们可以设置它的支付状态。&lt;/p&gt;
&lt;p&gt;　　更详细的答案可参考：https://www.jianshu.com/p/530228b71888&lt;/p&gt;
&lt;h2&gt;6.Spring原理（Ioc、Aop、动态代理）&lt;/h2&gt;
&lt;p&gt;lz：Ioc呢就是不需要我们手动创建new对象，把这个动作交给了Spring容器去管理，大大降低了程序的耦合度。&lt;/p&gt;
&lt;p&gt;　　Aop采用的就是动态代理的技术来实现切面编程的。&lt;/p&gt;
&lt;p&gt;面试官：djk动态代理和cglib动态代理有什么不同？&lt;/p&gt;
&lt;p&gt;lz：JDK只能代理实现了接口的类，cglib采用继承的方式 两种类都可以代理。（注意final类和静态方法是不能被代理的，因此aop也不能织入静态方法）&lt;/p&gt;
&lt;h2&gt;7.对事物了解多少（主要是特性、传播机制、隔离级别）&lt;/h2&gt;
&lt;p&gt;lz：事物主要的特性就是：原子性、一致性、隔离性、永久性&lt;/p&gt;
&lt;p&gt;　   隔离级别：default数据库默认的隔离级别、未提交读、已提交读、重复读、串行化。&lt;/p&gt;
&lt;p&gt;　　传播特性：PROPAGATION_REQUIRED 、PROPAGATION_SUPPORTS 、PROPAGATION_MANDATORY、PROPAGATION_REQUIRES_NEW、PROPAGATION_NOT_SUPPORTED、PROPAGATION_NEVER、PROPAGATION_NESTED；&lt;/p&gt;
&lt;p&gt;具体请参考：https://blog.csdn.net/weixin_38070406/article/details/78157603&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;lz抛个问题&lt;/strong&gt;&lt;/span&gt;：假如一个没有事务的方法调用了有事务的方法然后有事务的方法又调用了其他无事务的方法。那么请问事务还生效吗？（欢迎留言评论）&lt;/p&gt;
&lt;h2&gt;8.MySQL索引&lt;/h2&gt;
&lt;p&gt;lz：主键索引、唯一索引、普通索引、组合索引&lt;/p&gt;
&lt;p&gt;具体请参考：https://blog.csdn.net/goodsave/article/details/78018174&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;再抛个问题&lt;/strong&gt;&lt;/span&gt;：假如表中建立了一个组合索引（name、city、age）当查询时采用city、age时索引生不生效？&lt;/p&gt;
&lt;h2&gt;9.数据库执行计划&lt;/h2&gt;
&lt;p&gt;lz：具体一些细节就是怎么优化sql、还有查看sql语句性能，当然就是采用执行计划（explain）的方式了。&lt;/p&gt;
&lt;p&gt;具体可参考：https://blog.csdn.net/wangpeng047/article/details/12849331&lt;/p&gt;
&lt;h2&gt;10.线程池&lt;/h2&gt;
&lt;p&gt;lz：主要就是ThreadPoolExecutor类的使用构造函数，4种构造函数里各参数代表的意思。&lt;/p&gt;
&lt;p&gt;　　corePoolSize：核心池大小&lt;/p&gt;
&lt;p&gt;　　maximumPoolSize：线程池最大线程数。&lt;/p&gt;
&lt;p&gt;　　keepAliveTime：线程没有任务执行时最多存活时间。&lt;/p&gt;
&lt;p&gt;　　unit：为keepAliveTime设置时间的单位。&lt;/p&gt;
&lt;p&gt;还有几种常见的线程池：&lt;strong&gt;newFixedThreadPool、&lt;/strong&gt;newSingleThreadExecutor、&lt;strong&gt;newCachedThreadPool、&lt;/strong&gt;newScheduledThreadPool&lt;/p&gt;
&lt;p&gt;具体线程资料可参考：&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/dolphin0520/p/3932921.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/superfj/p/7544971.html&lt;/p&gt;

&lt;p&gt;好了，目前lz只能记得这么多了，所以就写到这吧。（还有一些lz做的模块的细碎问题也不赘述）&lt;/p&gt;
&lt;p&gt;ps: 最后lz完美的错过了饭局，自己一个人随便吃了点饭，然后等着对象一起愉快的回家了&lt;/p&gt;

</description>
<pubDate>Sun, 21 Oct 2018 04:19:00 +0000</pubDate>
<dc:creator>致力it</dc:creator>
<og:description>昨天下午六点正准备关电脑下班去和对象约定好的地方吃饭的时候，突然接到了一个电话面试邀请，于是内心快速纠结了一下，还是同意了这次电话邀约（其实内心是拒绝的，但是转念一想刚好通过这个电话面试对自己查漏补缺</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenpt/p/9824548.html</dc:identifier>
</item>
<item>
<title>自然语言处理中的语言模型预训练方法 - robert_ai</title>
<link>http://www.cnblogs.com/robert-dlut/p/9824346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robert-dlut/p/9824346.html</guid>
<description>&lt;p&gt;&lt;span&gt;自然语言处理中的语言模型预训练方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最近，在自然语言处理（&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;）领域中，使用语言模型预训练方法在多项&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上都获得了不错的提升，广泛受到了各界的关注。就此，我将最近看的一些相关论文进行总结，选取了几个代表性模型（包括&lt;/span&gt;&lt;span&gt;ELMo [1]&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;OpenAI GPT [2]&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;BERT [3]&lt;/span&gt;&lt;span&gt;）和大家一起学习分享。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;在介绍论文之前，我将先简单介绍一些相关背景知识。首先是语言模型（&lt;/span&gt;&lt;span&gt;Language Model&lt;/span&gt;&lt;span&gt;），语言模型简单来说就是一串词序列的概率分布。具体来说，语言模型的作用是为一个长度为&lt;/span&gt;&lt;span&gt;&lt;em&gt;m&lt;/em&gt;&lt;/span&gt;&lt;span&gt;的文本确定一个概率分布&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;，表示这段文本存在的可能性。在实践中，如果文本的长度较长，&lt;/span&gt;&lt;span&gt;P(w&lt;sub&gt;i&lt;/sub&gt; | w&lt;sub&gt;1&lt;/sub&gt;, w&lt;sub&gt;2&lt;/sub&gt;, . . . , w&lt;sub&gt;i−1&lt;/sub&gt;)&lt;/span&gt;&lt;span&gt;的估算会非常困难。因此，研究者们提出使用一个简化模型：&lt;/span&gt;&lt;span&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;&lt;span&gt;元模型（&lt;/span&gt;&lt;span&gt;n-gram model&lt;/span&gt;&lt;span&gt;）。在&lt;/span&gt; &lt;span&gt;n&lt;/span&gt; &lt;span&gt;元模型中估算条件概率时，只需要对当前词的前&lt;/span&gt;&lt;span&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;&lt;span&gt;个词进行计算。在&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;元模型中，传统的方法一般采用频率计数的比例来估算&lt;/span&gt;&lt;span&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;&lt;span&gt;元条件概率。当&lt;/span&gt;&lt;span&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;&lt;span&gt;较大时，机会存在数据稀疏问题，导致估算结果不准确。因此，一般在百万词级别的语料中，一般也就用到三元模型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105841161-1049507108.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了缓解&lt;/span&gt;&lt;span&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt;&lt;span&gt;元模型估算概率时遇到的数据稀疏问题，研究者们提出了神经网络语言模型。代表性工作是&lt;/span&gt;&lt;span&gt;Bengio&lt;/span&gt;&lt;span&gt;等人在&lt;/span&gt;&lt;span&gt;2003&lt;/span&gt;&lt;span&gt;年提出的神经网络语言模型，该语言模型使用了一个三层前馈神经网络来进行建模。其中有趣的发现了第一层参数，用做词表示不仅低维紧密，而且能够蕴涵语义，也就为现在大家都用的词向量（例如&lt;/span&gt;&lt;span&gt;word2vec&lt;/span&gt;&lt;span&gt;）打下了基础。其实，语言模型就是根据上下文去预测下一个词是什么，这不需要人工标注语料，所以语言模型能够从无限制的大规模单语语料中，学习到丰富的语义知识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105841528-1919672155.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来在简单介绍一下预训练的思想。我们知道目前神经网络在进行训练的时候基本都是基于后向传播（&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;）算法，通过对网络模型参数进行随机初始化，然后通过&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;算法利用例如&lt;/span&gt;&lt;span&gt;SGD&lt;/span&gt;&lt;span&gt;这样的优化算法去优化模型参数。那么预训练的思想就是，该模型的参数不再是随机初始化，而是先有一个任务进行训练得到一套模型参数，然后用这套参数对模型进行初始化，再进行训练。其实早期的使用自编码器栈式搭建深度神经网络就是这个思想。还有词向量也可以看成是第一层&lt;/span&gt;&lt;span&gt;word embedding&lt;/span&gt;&lt;span&gt;进行了预训练，此外在基于神经网络的迁移学习中也大量用到了这个思想。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105841814-613533463.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，我们就具体看一下这几篇用语言模型进行预训练的工作。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;2.1&lt;/span&gt; &lt;span&gt;引言&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;Deep Contextualized Word Representations&lt;/span&gt;&lt;span&gt;》这篇论文来自华盛顿大学的工作，最后是发表在今年的&lt;/span&gt;&lt;span&gt;NAACL&lt;/span&gt;&lt;span&gt;会议上，并获得了最佳论文。其实这个工作的前身来自同一团队在&lt;/span&gt;&lt;span&gt;ACL2017&lt;/span&gt;&lt;span&gt;发表的《&lt;/span&gt;&lt;span&gt;Semi-supervised sequence tagging with bidirectional language models&lt;/span&gt;&lt;span&gt;》&lt;/span&gt; &lt;span&gt;[4]&lt;/span&gt;&lt;span&gt;，只是在这篇论文里，他们把模型更加通用化了。首先我们来看看他们工作的动机，他们认为一个预训练的词表示应该能够包含丰富的句法和语义信息，并且能够对多义词进行建模。而传统的词向量（例如&lt;/span&gt;&lt;span&gt;word2vec&lt;/span&gt;&lt;span&gt;）是上下文无关的。例如下面&lt;/span&gt;&lt;span&gt;&quot;apple&quot;&lt;/span&gt;&lt;span&gt;的例子，这两个&lt;/span&gt;&lt;span&gt;&quot;apple&quot;&lt;/span&gt;&lt;span&gt;根据上下文意思是不同的，但是在&lt;/span&gt;&lt;span&gt;word2vec&lt;/span&gt;&lt;span&gt;中，只有&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;一个词向量，无法对一词多义进行建模。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105842103-862207975.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以他们利用语言模型来获得一个上下文相关的预训练表示，称为&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;，并在&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上获得了提升。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105842328-786164759.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;2.2&lt;/span&gt; &lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;EMLo&lt;/span&gt;&lt;span&gt;中，他们使用的是一个双向的&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;语言模型，由一个前向和一个后向语言模型构成，目标函数就是取这两个方向语言模型的最大似然。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105842585-294009665.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在预训练好这个语言模型之后，&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;就是根据下面的公式来用作词表示，其实就是把这个双向语言模型的每一中间层进行一个求和。最简单的也可以使用最高层的表示来作为&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105842864-2048363298.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后在进行有监督的&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务时，可以将&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;直接当做特征拼接到具体任务模型的词向量输入或者是模型的最高层表示上。总结一下，不像传统的词向量，每一个词只对应一个词向量，&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;利用预训练好的双向语言模型，然后根据具体输入从该语言模型中可以得到上下文依赖的当前词表示（对于不同上下文的同一个词的表示是不一样的），再当成特征加入到具体的&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;有监督模型里。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;2.3&lt;/span&gt; &lt;span&gt;实验&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这里我们简单看一下主要的实验，具体实验还需阅读论文。首先是整个模型效果的实验。他们在&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上进行了实验，首先根据目前每个任务搭建了不同的模型作为&lt;/span&gt;&lt;span&gt;baseline&lt;/span&gt;&lt;span&gt;，然后加入&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;，可以看到加入&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;后&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;个任务都有所提升，平均大约能够提升&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;个多百分点，并且最后的结果都超过了之前的先进结果（&lt;/span&gt;&lt;span&gt;SOTA&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105843198-1899267826.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在下面的分析实验中，我们可以看到使用所有层的效果要比只使用最后一层作为&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;的效果要好。在输入还是输出上面加&lt;/span&gt;&lt;span&gt;EMLo&lt;/span&gt;&lt;span&gt;效果好的问题上，并没有定论，不同的任务可能效果不一样。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105843479-1730758972.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;3.1&lt;/span&gt; &lt;span&gt;引言&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们来看看第二篇论文《&lt;/span&gt;&lt;span&gt;Improving Language Understanding by Generative Pre-Training&lt;/span&gt;&lt;span&gt;》，这是&lt;/span&gt;&lt;span&gt;OpenAI&lt;/span&gt; &lt;span&gt;团队前一段时间放出来的预印版论文。他们的目标是学习一个通用的表示，能够在大量任务上进行应用。这篇论文的亮点主要在于，他们利用了&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;网络代替了&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;作为语言模型来更好的捕获长距离语言结构。然后在进行具体任务有监督微调时使用了语言模型作为附属任务训练目标。最后再&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上进行了实验，&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;个任务获得了&lt;/span&gt;&lt;span&gt;SOTA&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105843743-449093208.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;3.2&lt;/span&gt; &lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先我们来看一下他们无监督预训练时的语言模型。他们仍然使用的是标准的语言模型目标函数，即通过前&lt;/span&gt;&lt;span&gt;&lt;em&gt;k&lt;/em&gt;&lt;/span&gt;&lt;span&gt;个词预测当前词，但是在语言模型网络上他们使用了&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;团队在《&lt;/span&gt;&lt;span&gt;Attention is all your need&lt;/span&gt;&lt;span&gt;》论文中提出的T&lt;/span&gt;&lt;span&gt;ransformer&lt;/span&gt;&lt;span&gt;解码器作为语言模型。&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;模型主要是利用自注意力（&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;）机制的模型，这里我就不多进行介绍，大家可以看论文或者参考我之前的博客（&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/robert-dlut/p/8638283.html&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105844156-2101267400.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后再具体&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务有监督微调时，与&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;当成特征的做法不同，&lt;/span&gt;&lt;span&gt;OpenAI GPT&lt;/span&gt;&lt;span&gt;不需要再重新对任务构建新的模型结构，而是直接在&lt;/span&gt;&lt;span&gt;transformer&lt;/span&gt;&lt;span&gt;这个语言模型上的最后一层接上&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;作为任务输出层，然后再对这整个模型进行微调。他们额外发现，如果使用语言模型作为辅助任务，能够提升有监督模型的泛化能力，并且能够加速收敛。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105844634-618425800.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于不同&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务的输入有所不同，在&lt;/span&gt;&lt;span&gt;transformer&lt;/span&gt;&lt;span&gt;模型的输入上针对不同&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务也有所不同。具体如下图，对于分类任务直接讲文本输入即可；对于文本蕴涵任务，需要将前提和假设用一个&lt;/span&gt;&lt;span&gt;Delim&lt;/span&gt;&lt;span&gt;分割向量拼接后进行输入；对于文本相似度任务，在两个方向上都使用&lt;/span&gt;&lt;span&gt;Delim&lt;/span&gt;&lt;span&gt;拼接后，进行输入；对于像问答多选择的任务，就是将每个答案和上下文进行拼接进行输入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105845000-829413930.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;3.3&lt;/span&gt; &lt;span&gt;实验&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面我简单的列举了一下不同&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上的实验结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语言推理任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105845241-1775410918.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问答和常识推理任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105845477-111776507.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语义相似度和分类任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105845732-1155391210.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以看到在多项任务上，&lt;/span&gt;&lt;span&gt;OpenAI GPT&lt;/span&gt;&lt;span&gt;的效果要比&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;的效果更好。从下面的消除实验来看，在去掉预训练部分后，所有任务都大幅下降，平均下降了&lt;/span&gt;&lt;span&gt;14.8%&lt;/span&gt;&lt;span&gt;，说明预训练很有效；在大数据集上使用语言模型作为附加任务的效果更好，小数据集不然；利用&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;代替&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;后，结果平均下降了&lt;/span&gt;&lt;span&gt;5.6%&lt;/span&gt;&lt;span&gt;，也体现了&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;的性能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105846248-247284394.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;4.1&lt;/span&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上周&lt;/span&gt;&lt;span&gt;Google&lt;/span&gt;&lt;span&gt;放出了他们的语言模型预训练方法，瞬时受到了各界广泛关注，不少媒体公众号也进行了相应报道，那我们来看看这篇论文《&lt;/span&gt;&lt;span&gt;BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding&lt;/span&gt;&lt;span&gt;》。这篇论文把预训练语言表示方法分为了基于特征的方法（代表&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;）和基于微调的方法（代表&lt;/span&gt;&lt;span&gt;OpenAI GPT&lt;/span&gt;&lt;span&gt;）。而目前这两种方法在预训练时都是使用单向的语言模型来学习语言表示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105846494-614240727.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这篇论文中，作者们证明了使用双向的预训练效果更好。其实这篇论文方法的整体框架和&lt;/span&gt;&lt;span&gt;GPT&lt;/span&gt;&lt;span&gt;类似，是进一步的发展。具体的，他们&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;是使用&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;的编码器来作为语言模型，在语言模型预训练的时候，提出了两个新的目标任务（即遮挡语言模型&lt;/span&gt;&lt;span&gt;MLM&lt;/span&gt;&lt;span&gt;和预测下一个句子的任务），最后在&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上取得了&lt;/span&gt;&lt;span&gt;SOTA&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105846733-1832357796.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;4.2&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在语言模型上，&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;使用的是&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;编码器，并且设计了一个小一点&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;结构和网络一个更大的结构。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105847246-110331522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对比一下三种语言模型结构，&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;使用的是&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;编码器，由于&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;机制，所以模型上下层直接全部互相连接的。而&lt;/span&gt;&lt;span&gt;OpenAI GPT&lt;/span&gt;&lt;span&gt;使用的是&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;编码器，它是一个需要从左到右的受限制的&lt;/span&gt;&lt;span&gt;Transformer&lt;/span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;使用的是双向&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;，虽然是双向的，但是也只是在两个单向的&lt;/span&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;span&gt;的最高层进行简单的拼接。所以作者们任务只有&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;是真正在模型所有层中是双向的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105847524-1030716839.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而在模型的输入方面，&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;做了更多的细节，如下图。他们使用了&lt;/span&gt;&lt;span&gt;WordPiece embedding&lt;/span&gt;&lt;span&gt;作为词向量，并加入了位置向量和句子切分向量。并在每一个文本输入前加入了一个&lt;/span&gt;&lt;span&gt;CLS&lt;/span&gt;&lt;span&gt;向量，后面会有这个向量作为具体的分类向量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105848051-927674788.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在语言模型预训练上，他们不在使用标准的从左到右预测下一个词作为目标任务，而是提出了两个新的任务。第一个任务他们称为&lt;/span&gt;&lt;span&gt;MLM&lt;/span&gt;&lt;span&gt;，即在输入的词序列中，随机的挡上&lt;/span&gt;&lt;span&gt;15%&lt;/span&gt;&lt;span&gt;的词，然后任务就是去预测挡上的这些词，可以看到相比传统的语言模型预测目标函数，&lt;/span&gt;&lt;span&gt;MLM&lt;/span&gt;&lt;span&gt;可以从任何方向去预测这些挡上的词，而不仅仅是单向的。但是这样做会带来两个缺点：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）预训练用&lt;/span&gt;&lt;span&gt;[MASK]&lt;/span&gt;&lt;span&gt;提出挡住的词后，在微调阶段是没有&lt;/span&gt;&lt;span&gt;[MASK]&lt;/span&gt;&lt;span&gt;这个词的，所以会出现不匹配；&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）预测&lt;/span&gt;&lt;span&gt;15%&lt;/span&gt;&lt;span&gt;的词而不是预测整个句子，使得预训练的收敛更慢。但是对于第二点，作者们觉得虽然是慢了，但是效果提升比较明显可以弥补。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105848765-428734181.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于第一点他们采用了下面的技巧来缓解，即不是总是用&lt;/span&gt;&lt;span&gt;[MASK]&lt;/span&gt;&lt;span&gt;去替换挡住的词，在&lt;/span&gt;&lt;span&gt;10%&lt;/span&gt;&lt;span&gt;的时间用一个随机词取替换，&lt;/span&gt;&lt;span&gt;10%&lt;/span&gt;&lt;span&gt;的时间就用这个词本身。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105849010-476466771.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而对于传统语言模型，并没有对句子之间的关系进行考虑。为了让模型能够学习到句子之间的关系，作者们提出了第二个目标任务就是预测下一个句子。其实就是一个二元分类问题，&lt;/span&gt;&lt;span&gt;50%&lt;/span&gt;&lt;span&gt;的时间，输入一个句子和下一个句子的拼接，分类标签是正例，而另&lt;/span&gt;&lt;span&gt;50%&lt;/span&gt;&lt;span&gt;是输入一个句子和非下一个随机句子的拼接，标签为负例。最后整个预训练的目标函数就是这两个任务的取和求似然。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105849335-554549282.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在微调阶段，不同任务的模型如下图，只是在输入层和输出层有所区别，然后整个模型所有参数进行微调。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105849660-1802295372.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;4.3&lt;/span&gt; &lt;span&gt;实验&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面我们列出一下不同&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;的效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;GLUE&lt;/span&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105850474-1878508931.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;QA&lt;/span&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105851044-446422450.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体识别结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105851455-165576217.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SWAG&lt;/span&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105851694-773319745.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以看到在这些所有&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上，&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;都取得了&lt;/span&gt;&lt;span&gt;SOTA&lt;/span&gt;&lt;span&gt;，而且相比&lt;/span&gt;&lt;span&gt;EMLo&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;GPT&lt;/span&gt;&lt;span&gt;的效果提升还是比较大的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在预训练实验分析上，可以看到本文提出的两个目标任务的作用还是很有效的，特别是在&lt;/span&gt;&lt;span&gt;MLM&lt;/span&gt;&lt;span&gt;这个目标任务上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105851943-801561677.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者也做了模型规模的实验，大规模的模型效果更好，即使在小数据集上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105852247-903827513.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此外，作者也做了像&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;当成特征加入的实验，从下图可以看到，当成特征加入最好效果能达到&lt;/span&gt;&lt;span&gt;96.1%&lt;/span&gt;&lt;span&gt;和微调的&lt;/span&gt;&lt;span&gt;96.4%&lt;/span&gt;&lt;span&gt;差不多，说明&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;对于基于特征和基于微调这两种方法都是有效的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105852507-2007942882.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;最后进行简单的总结，和传统的词向量相比，使用语言模型预训练其实可以看成是一个句子级别的上下文的词表示，它可以充分利用大规模的单语语料，并且可以对一词多义进行建模。而且从后面两篇论文可以看到，通过大规模语料预训练后，使用统一的模型或者是当成特征直接加到一些简单模型上，对各种&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务都能取得不错的效果，说明很大程度上缓解了具体任务对模型结构的依赖。在目前很多评测上也都取得了&lt;/span&gt;&lt;span&gt;SOTA&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;ELMo&lt;/span&gt;&lt;span&gt;也提供了官网供大家使用。但是这些方法在空间和时间复杂度上都比较高，特别是&lt;/span&gt;&lt;span&gt;BERT&lt;/span&gt;&lt;span&gt;，在论文中他们训练&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;版本需要在&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;TGPU&lt;/span&gt;&lt;span&gt;上，&lt;/span&gt;&lt;span&gt;large&lt;/span&gt;&lt;span&gt;版本需要在&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;TPU&lt;/span&gt;&lt;span&gt;上训练&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;天，对于一般条件，一个&lt;/span&gt;&lt;span&gt;GPU&lt;/span&gt;&lt;span&gt;训练的话，得用上&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;年。还有就是可以看出这些方法里面都存在很多工程细节，一些细节做得不好的话，效果也会大大折扣。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670089/201810/670089-20181021105852828-370844858.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;[1] Peters, M. E. et al. Deep contextualized word representations. naacl (2018).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2] Radford, A. &amp;amp; Salimans, T. Improving Language Understanding by Generative Pre-Training. (2018).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[3] Devlin, J., Chang, M.-W., Lee, K. &amp;amp; Toutanova, K. BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. (2018).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[4] Peters, M. E., Ammar, W., Bhagavatula, C. &amp;amp; Power, R. Semi-supervised sequence tagging with bidirectional language models. Acl (2017).&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sun, 21 Oct 2018 02:59:00 +0000</pubDate>
<dc:creator>robert_ai</dc:creator>
<og:description>自然语言处理中的语言模型预训练方法 最近，在自然语言处理（NLP）领域中，使用语言模型预训练方法在多项NLP任务上都获得了不错的提升，广泛受到了各界的关注。就此，我将最近看的一些相关论文进行总结，选取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/robert-dlut/p/9824346.html</dc:identifier>
</item>
<item>
<title>.net core实践系列之SSO-跨域实现 - 陈珙</title>
<link>http://www.cnblogs.com/skychen1218/p/9805995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skychen1218/p/9805995.html</guid>
<description>&lt;p&gt;接着上篇的《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/skychen1218/p/9773466.html&quot;&gt;.net core实践系列之SSO-同域实现&lt;/a&gt;》，这次来聊聊SSO跨域的实现方式。这次虽说是.net core实践，但是核心点使用jquery居多。&lt;/p&gt;
&lt;p&gt;建议看这篇文章的朋友可以先看上篇《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/skychen1218/p/9773466.html&quot;&gt;.net core实践系列之SSO-同域实现&lt;/a&gt;》做一个SSO大概了解。&lt;/p&gt;
&lt;p&gt;源码地址：https://github.com/SkyChenSky/Core.SSO.git&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488722/201810/488722-20181018172353136-313352697.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;实现原则&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;只要统一Token的产生和校验方式，无论授权与认证的在哪（&lt;/strong&gt;认证系统或业务系统），也无论用户信息存储在哪（浏览器、服务器），其实都可以实现单点登录的效果&lt;/p&gt;
&lt;h2&gt;实现关键点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Token的生成&lt;/li&gt;
&lt;li&gt;Token的共享&lt;/li&gt;
&lt;li&gt;Token校验&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Token共享复杂度&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;同域&lt;/li&gt;
&lt;li&gt;跨域&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Token认证方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;业务系统自认证&lt;/li&gt;
&lt;li&gt;转发给认证中心认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有支持JavaScript 的浏览器，都必须遵守的安全策略，也是浏览器最基本的安全功能。&lt;/p&gt;
&lt;p&gt;如果没有处理过发起跨域请求，就算服务器接收到了，响应成功了浏览器也是会拦截的。&lt;/p&gt;
&lt;h2&gt;同源&lt;/h2&gt;
&lt;p&gt;指域名，协议，端口相同&lt;/p&gt;
&lt;h2&gt;目的&lt;/h2&gt;
&lt;p&gt;浏览器为了阻止恶意脚本获取不同源上的的敏感信息。&lt;/p&gt;
&lt;h2&gt;跨域请求&lt;/h2&gt;
&lt;p&gt;然而在实际情况下跨域请求的场景也是存在的，解决方案有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JSONP&lt;/li&gt;
&lt;li&gt;响应头设置“Access-Control-Allow-Origin”&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Cookie&lt;/h2&gt;
&lt;p&gt;Cookie的读取和发送也是必须遵循同源策略的。&lt;/p&gt;
&lt;p&gt;虽说请求共享可以设置响应头Access-Control-Allow-Credentials、Access-Control-Allow-Origin与Ajax请求属性xhrFields: {withCredentials: true}进行解决，但是！&lt;/p&gt;
&lt;p&gt;就算响应头有set-cookie浏览器也是无法正常保存的。&lt;/p&gt;

&lt;p&gt;针对cookie认证，我唯一能找到的解决方案就是跳转页面。&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;认证中心登录成功后，请求登录中心接口获得token&lt;/li&gt;
&lt;li&gt;携带token逐个跳转到业务系统的中转页面。&lt;/li&gt;
&lt;li&gt;跳转完成后，返回到认证中心登录页面进行引导。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;strong&gt;PS：如果哪位朋友有更加好的方案，可以及时与我沟通，非常感谢&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;登录中心授权&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $(&lt;/span&gt;&quot;#submit&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&quot;#postForm&quot;).ajaxSubmit(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (result) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.success) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token =&lt;span&gt; getToken();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (token) {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authorizeHostArray = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(
                            &lt;/span&gt;&quot;http://www.web1.com/Token/Authorization&quot;&lt;span&gt;,
                            &lt;/span&gt;&quot;http://www.web2.com/Token/Authorization&quot;&lt;span&gt;
                        );
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authorizeHostParams = &quot;&quot;&lt;span&gt;;
                        authorizeHostArray.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
                            authorizeHostParams &lt;/span&gt;+= &quot;&amp;amp;hostAuthorization=&quot; +&lt;span&gt; item;
                        });
                        window.location.href &lt;/span&gt;= authorizeHostArray[0] + &quot;?token=&quot; + token +&lt;span&gt; authorizeHostParams;
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    alert(result.msg);
                }
            });
        });

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getToken() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            $.ajax({
                url: &lt;/span&gt;&quot;/api/Token&quot;&lt;span&gt;,
                type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
                async: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (d) {
                    token &lt;/span&gt;=&lt;span&gt; d.token;
                }
            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; token;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;业务系统Token保存与注销&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TokenController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TokenCookieOptions CookieOptions { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Authorization(&lt;span&gt;string&lt;/span&gt; token, List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; hostAuthorization = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CookieOptions == &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(token))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();

            HttpContext.Response.Cookies.Append(CookieOptions.Name, token, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookieOptions
            {
                Domain &lt;/span&gt;=&lt;span&gt; CookieOptions.Domain,
                Expires &lt;/span&gt;=&lt;span&gt; DateTimeOffset.UtcNow.Add(CookieOptions.Expires),
                HttpOnly &lt;/span&gt;=&lt;span&gt; CookieOptions.HttpOnly,
                IsEssential &lt;/span&gt;=&lt;span&gt; CookieOptions.IsEssential,
                MaxAge &lt;/span&gt;=&lt;span&gt; CookieOptions.MaxAge,
                Path &lt;/span&gt;=&lt;span&gt; CookieOptions.Path,
                SameSite &lt;/span&gt;=&lt;span&gt; CookieOptions.SameSite
            });

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hostAuthorization.Any())
                hostAuthorization &lt;/span&gt;= hostAuthorization.Where(a =&amp;gt; !&lt;span&gt;a.Contains(HttpContext.Request.Host.Host)).ToList();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hostAuthorization.Any())
                hostAuthorization &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.sso.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenViewData
            {
                Token &lt;/span&gt;=&lt;span&gt; token,
                HostAuthorization &lt;/span&gt;=&lt;span&gt; hostAuthorization
            });
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Logout(List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; hostAuthorization = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            HttpContext.Response.Cookies.Delete(CookieOptions.Name);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hostAuthorization.Any())
                hostAuthorization &lt;/span&gt;= hostAuthorization.Where(a =&amp;gt; !&lt;span&gt;a.Contains(HttpContext.Request.Host.Host)).ToList();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hostAuthorization.Any())
                hostAuthorization &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.sso.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenViewData
            {
                HostAuthorization &lt;/span&gt;=&lt;span&gt; hostAuthorization
            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;与同域的实现的方式一致。&lt;/p&gt;
&lt;p&gt;生成与认证是一对的，与之对应的就是AES的加密与解密。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
                .AddCookie(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
               {
                   options.Cookie.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                   options.Cookie.HttpOnly &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                   options.ExpireTimeSpan &lt;/span&gt;= TimeSpan.FromMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
                   options.LoginPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Account/Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                   options.LogoutPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Account/Logout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                   options.SlidingExpiration &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.DataProtectionProvider = DataProtectionProvider.Create(new DirectoryInfo(@&quot;D:\sso\key&quot;));&lt;/span&gt;
                   options.TicketDataFormat = &lt;span&gt;new&lt;/span&gt; TicketDataFormat(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AesDataProtector());
                   TokenController.CookieName &lt;/span&gt;=&lt;span&gt; options.Cookie.Name;
               });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AesDataProtector : IDataProtector
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!@#13487&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDataProtector CreateProtector(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; purpose)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Protect(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] plaintext)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AESHelper.Encrypt(plaintext, Key);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Unprotect(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] protectedData)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AESHelper.Decrypt(protectedData, Key);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;业务系统自主认证的方式，对于系统的代码复用率与维护性都很低。如果想进行转发到认证系统进行认证，可以对[&lt;em id=&quot;__mceDel&quot;&gt;Authorize&lt;/em&gt;]进行重写。&lt;/p&gt;
&lt;p&gt;大致思路是：&lt;/p&gt;
&lt;p&gt;访问业务系统时，由自定义的[&lt;em id=&quot;__mceDel&quot;&gt;Authorize&lt;/em&gt;]进行拦截&lt;/p&gt;
&lt;p&gt;获取到Token设置到请求头进行HttpPost到认证系统提供的/api/token/Authentication接口&lt;/p&gt;
&lt;p&gt;响应给业务系统如果是成功则继续访问，如果是失败则401或者跳转到登录页。&lt;/p&gt;

&lt;p&gt;最近事情比较多，demo与文章写的比较仓促，如果朋友们有更好的实现方式与建议，麻烦在下面评论反馈给我，先在此感谢。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 02:54:00 +0000</pubDate>
<dc:creator>陈珙</dc:creator>
<og:description>前言 接着上篇的《.net core实践系列之SSO-同域实现》，这次来聊聊SSO跨域的实现方式。这次虽说是.net core实践，但是核心点使用jquery居多。 建议看这篇文章的朋友可以先看上篇《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skychen1218/p/9805995.html</dc:identifier>
</item>
<item>
<title>L1与L2损失函数和正则化的区别 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/9824310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/9824310.html</guid>
<description>&lt;blockquote readability=&quot;3.2340425531915&quot;&gt;
&lt;p&gt;本文翻译自文章：&lt;a href=&quot;http://www.chioka.in/differences-between-l1-and-l2-as-loss-function-and-regularization/&quot;&gt;Differences between L1 and L2 as Loss Function and Regularization&lt;/a&gt;，如有翻译不当之处，欢迎拍砖，谢谢~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  在机器学习实践中，你也许需要在神秘的L1和L2中做出选择。通常的两个决策为：1) L1范数 vs L2范数 的损失函数； 2) L1正则化 vs L2正则化。&lt;/p&gt;
&lt;h3 id=&quot;作为损失函数&quot;&gt;作为损失函数&lt;/h3&gt;
&lt;p&gt;  L1范数损失函数，也被称为最小绝对值偏差（LAD），最小绝对值误差（LAE）。总的说来，它是把目标值（&lt;span class=&quot;math inline&quot;&gt;\(Y_{i}\)&lt;/span&gt;）与估计值（&lt;span class=&quot;math inline&quot;&gt;\(f(x_{i})\)&lt;/span&gt;）的绝对差值的总和（&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;）最小化：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[S=\sum\limits_{i=1}^{n}|Y_{i}-f(x_{i})|.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  L2范数损失函数，也被称为最小平方误差（LSE）。总的来说，它是把目标值（&lt;span class=&quot;math inline&quot;&gt;\(Y_{i}\)&lt;/span&gt;）与估计值（&lt;span class=&quot;math inline&quot;&gt;\(f(x_{i})\)&lt;/span&gt;）的差值的平方和（&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;）最小化：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[S=\sum\limits_{i=1}^{n}\Big(Y_{i}-f(x_{i})\Big)^{2}.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  L1范数与L2范数作为损失函数的区别能快速地总结如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;不是非常的鲁棒（robust）&lt;/td&gt;
&lt;td&gt;鲁棒&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;稳定解&lt;/td&gt;
&lt;td&gt;不稳定解&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;总是一个解&lt;/td&gt;
&lt;td&gt;可能多个解&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  &lt;strong&gt;鲁棒性（robustness）&lt;/strong&gt;，根据维基百科，被解释为：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为与最小平方相比，最小绝对值偏差方法的鲁棒性更好，因此，它在许多场合都有应用。最小绝对值偏差之所以是鲁棒的，是因为它能处理数据中的异常值。这或许在那些异常值可能被安全地和有效地忽略的研究中很有用。如果需要考虑任一或全部的异常值，那么最小绝对值偏差是更好的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从直观上说，因为L2范数将误差平方化（如果误差大于1，则误差会放大很多），模型的误差会比L1范数来得大（ e vs e^2 ），因此模型会对这个样本更加敏感，这就需要调整模型来最小化误差。如果这个样本是一个异常值，模型就需要调整以适应单个的异常值，这会牺牲许多其它正常的样本，因为这些正常样本的误差比这单个的异常值的误差小。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;稳定性&lt;/strong&gt;，根据维基百科，被解释为：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;最小绝对值偏差方法的不稳定性意味着，对于数据集的一个小的水平方向的波动，回归线也许会跳跃很大。在一些数据结构（data configurations）上，该方法有许多连续解；但是，对数据集的一个微小移动，就会跳过某个数据结构在一定区域内的许多连续解。（The method has continuous solutions for some data configurations; however, by moving a datum a small amount, one could “jump past” a configuration which has multiple solutions that span a region. ）在跳过这个区域内的解后，最小绝对值偏差线可能会比之前的线有更大的倾斜。相反地，最小平方法的解是稳定的，因为对于一个数据点的任何微小波动，回归线总是只会发生轻微移动；也就说，回归参数是数据集的连续函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的图是用真实数据和真实拟合模型生成的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-4ec4e760bc180a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里使用的基本模型为梯度提升回归（GradientBoostingRegressor），使用L1范数和L2范数作为损失函数。绿线和红色分别代表了模型使用L1范数与L2范数作为损失函数时的情形。实线代表了训练的模型中不含有异常值（橙色）的情形，虚线代表了训练的模型中含有异常值（橙色）的情形。&lt;br/&gt;  我缓慢地将这个异常值从左向右移动，使得它在中间时不那么异常，而在左右两边时更加异常。当这个异常值不那么异常时（在中间的情形），在拟合直线的时候，L2范数的变动较小，而L1范数的表动较大。&lt;br/&gt;  当这个异常值更加异常（上左位置，下右位置，它们离左、右两边更加远）时，这两个范数都有大的变动，但是再一次地，L1范数总体上比L2范数变动更大。&lt;br/&gt;  通过数据可视化，我们能够对这两个损失函数的稳定性有更好的认知。&lt;/p&gt;
&lt;h3 id=&quot;作为正规化&quot;&gt;作为正规化&lt;/h3&gt;
&lt;p&gt;  在机器学习中，正规化是防止过拟合的一种重要技巧。从数学上讲，它会增加一个正则项，防止系数拟合得过好以至于过拟合。L1与L2的区别只在于，L2是权重的平方和，而L1就是权重的和。如下：&lt;/p&gt;
&lt;p&gt;最小平方损失函数的L1正则化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-8d49da6164a8a169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最小平方损失函数的L2正则化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-8a28b9119d5ae8e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它们的性质的区别能快速地总结如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;计算效率高（因为有解析解）&lt;/td&gt;
&lt;td&gt;在非稀疏情形下计算效率低&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;非稀疏输出&lt;/td&gt;
&lt;td&gt;稀疏输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;无特征选择&lt;/td&gt;
&lt;td&gt;内置特征选择&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  &lt;strong&gt;解的唯一性&lt;/strong&gt;是一个更简单的性质，但需要一点想象。首先，看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-db86ff5f277d88d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绿色的线（L2范数）是唯一的最短的路径，而红色、蓝色、黄色线条（L1范数）都是同一路径，长度一样（12）。可以将其扩展至n-维的情形。这就是为什么L2范数有唯一解而L1并不是。&lt;br/&gt;  &lt;strong&gt;内置特征选择&lt;/strong&gt;是L1范数被经常提及的有用的性质，而L2范数并不具备。这是L1范数的自然结果，它趋向于产生稀疏的系数（在后面会解释）。假设模型有100个系数，但是仅仅只有其中的10个是非零的，这实际上是说“其余的90个系数在预测目标值时都是无用的”。L2范数产生非稀疏的系数，因此它不具备这个性质。&lt;br/&gt;  &lt;strong&gt;稀疏性&lt;/strong&gt;指的是一个矩阵（或向量）中只有少数的项是非零的。L1范数具备性质：产生许多0或非常小的系数和少量大的系数。&lt;br/&gt;  &lt;strong&gt;计算效率&lt;/strong&gt;。L1范数没有一个解析解，但是L2范数有。这就允许L2范数在计算上能高效地计算。然而，L1范数的解具备稀疏性，这就允许它可以使用稀疏算法，以使得计算更加高效。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 02:47:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>L1与L2损失函数和正则化的区别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/9824310.html</dc:identifier>
</item>
<item>
<title>重识 PWA 进阶到 workbox3 - ESnail</title>
<link>http://www.cnblogs.com/EnSnail/p/9824198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EnSnail/p/9824198.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;看到&lt;code&gt;PWA&lt;/code&gt;，似曾相识，但又感觉很模糊，于是乎，又重新翻阅文档，学习了一遍，顺便把相关知识学习了一下，比如&lt;code&gt;service worker&lt;/code&gt;,&lt;code&gt;workbox3&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;pwa-概念&quot;&gt;PWA 概念：&lt;/h3&gt;
&lt;p&gt;全称：Progressive Web APP, 渐进式 Web 应用。&lt;/p&gt;
&lt;p&gt;实际上是通过 Web 技术编写出的一个网页应用，加上&lt;code&gt;App Manifest&lt;/code&gt;和&lt;code&gt;Service Worker&lt;/code&gt;来实现&lt;code&gt;PWA&lt;/code&gt;的安装和离线缓存等功能。&lt;/p&gt;
&lt;p&gt;解决了哪些问题?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以添加至主屏幕，点击主屏幕图标可以实现启动动画及隐藏地址栏&lt;/li&gt;
&lt;li&gt;实现离线缓存功能&lt;/li&gt;
&lt;li&gt;实现了消息推送&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;pwa-的实现-manifest-实现添加至主屏幕&quot;&gt;PWA 的实现-Manifest 实现添加至主屏幕&lt;/h3&gt;
&lt;p&gt;首先在&lt;code&gt;index.html&lt;/code&gt;的&lt;code&gt;head&lt;/code&gt;中引入&lt;code&gt;manifest.json&lt;/code&gt;文件，尽可能早的引入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;head&amp;gt;
    ...
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&amp;gt;
    &amp;lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&amp;gt;
    ...
&amp;lt;/head&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后编写&lt;code&gt;manifest.json&lt;/code&gt;文件，参考文档：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Manifest&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/Manifest&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称
  &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name
  &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用
  &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的
  &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url
  &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色
  &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。
  &quot;icons&quot;: [ // 桌面图标，是一个数组
    {
    &quot;src&quot;: &quot;icon/lowres.webp&quot;,
    &quot;sizes&quot;: &quot;48x48&quot;,  // 以空格分隔的图片尺寸
    &quot;type&quot;: &quot;image/webp&quot;  // 帮助userAgent快速排除不支持的类型
  },
  {
    &quot;src&quot;: &quot;icon/lowres&quot;,
    &quot;sizes&quot;: &quot;48x48&quot;
  },
  {
    &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,
    &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;
  },
  {
    &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,
    &quot;sizes&quot;: &quot;72x72&quot;
  }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pwa的实现-service-worker-实现离线缓存&quot;&gt;PWA的实现-Service Worker 实现离线缓存&lt;/h3&gt;
&lt;p&gt;Service worker，是 Chrome 团队提出和力推的一个 WEB API，就像介于服务器和网页之间的拦截器，能够拦截进出的http请求，从而完全控制你的网站。&lt;/p&gt;
&lt;h4 id=&quot;最主要的特点&quot;&gt;最主要的特点：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和拦截作用域范围内所有页面的 HTTP 请求。&lt;/li&gt;
&lt;li&gt;网站必须使用 HTTPS，处于安全考虑，避免被攻击。除了使用贝蒂开发环境调试。&lt;/li&gt;
&lt;li&gt;运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求&lt;/li&gt;
&lt;li&gt;单独的作用域范围，单独的运行环境和执行线程&lt;/li&gt;
&lt;li&gt;不能操作页面 DOM ，但是可以通过事件机制来处理&lt;/li&gt;
&lt;li&gt;事件驱动型服务线程&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;浏览器支持情况&quot;&gt;浏览器支持情况：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/806524/201810/806524-20181021102938669-423993596.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;生命周期&quot;&gt;生命周期&lt;/h4&gt;
&lt;p&gt;解析成功(parsed)、正在安装(installing)、安装整个(installed)、正在激活(activating)、激活成功(activated)、废弃(redundant)&lt;/p&gt;
&lt;p&gt;若 installing 事件失败或 activeing 事件失败，service worker 都会被废弃。&lt;/p&gt;
&lt;h4 id=&quot;实现离线缓存&quot;&gt;实现离线缓存&lt;/h4&gt;
&lt;p&gt;首先在&lt;code&gt;index.html&lt;/code&gt;中注册&lt;code&gt;sw.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script async src=&quot;/js/script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;     
&amp;lt;script&amp;gt;
  // 注册 service worker
  if ('serviceWorker' in navigator) {           
    navigator.serviceWorker.register('/sw.js', {scope: '/'}).then(function (registration) {
      // 注册成功
      console.log('ServiceWorker registration successful with scope: ', registration.scope);
    }).catch(function (err) {                   
      // 注册失败 :(
      console.log('ServiceWorker registration failed: ', err);
    });
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写&lt;code&gt;sw.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var cacheStorageKey = 'cachesName'
var cacheList = [
  // 注册成功后要立即缓存的资源列表
]

// 当浏览器解析完sw文件时触发install事件
self.addEventListener('install', function(e) {
  // install事件中一般会将cacheList中要换存的内容通过addAll方法，拉一遍放入caches中
  e.waitUntil(
    caches.open(cacheStorageKey).then(function(cache) {
      return cache.addAll(cacheList)
    })
  )
})

// 激活时触发activate事件
self.addEventListener('activate', function(e) {
  // active事件中通常做一些过期资源释放的工作，匹配到就从caches中删除
  var cacheDeletePromises = caches.keys().then(cacheNames =&amp;gt; {
    return Promise.all(cacheNames.map(name =&amp;gt; {
      if (name !== cacheStorageKey) {
        return caches.delete(name);
      } else {
        return Promise.resolve();
      }
    }));
  });

  e.waitUntil(
    Promise.all([cacheDeletePromises])
  )
})

self.addEventListener('fetch', function(e) {
  // 在此编写缓存策略, 需要根据不同文件的扩展名把不同的资源通过不同的策略缓存在caches中，各种css，js，html，图片，都需要单独搞一套缓存策略

  e.respondWith(
    // 可以通过匹配缓存中的资源返回
    caches.match(e.request)
    // 也可以从远端拉取
    fetch(e.request.url)
    // 也可以自己造
    new Response('自己造')
    // 也可以通过吧fetch拿到的响应通过caches.put方法放进chches
  )
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;workbox3&quot;&gt;workbox3&lt;/h3&gt;
&lt;p&gt;workbox3，Google官方 PWA 框架，解决的就是 Service Worker 编写太过复杂的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 首先引入workbox框架
importScripts('https://storage.googleapis.com/workbox-cdn/releases/3.3.0/workbox-sw.js');

workbox.precaching([
  // 注册成功后要立即缓存的资源列表
])

// 缓存策略: networkFirst、cacheFirst、staleWhileRevalidate
workbox.routing.registerRoute(
  new RegExp(''.*\.html'),
  workbox.strategies.networkFirst()
);

workbox.routing.registerRoute(
  new RegExp('.*\.(?:js|css)'),
  workbox.strategies.cacheFirst()
);

workbox.routing.registerRoute(
  new RegExp('https://your\.cdn\.com/'),
  workbox.strategies.staleWhileRevalidate()
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成缓存策略，可以采用&lt;code&gt;workbox-build npm 包&lt;/code&gt;或者&lt;code&gt;workbox-webpack-plugin&lt;/code&gt;方式自动生成。&lt;/p&gt;
&lt;p&gt;缓存策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;stateWhileRevalidate&lt;/code&gt;：当请求的路由有对应的 Cache 缓存结果就直接返回，在返回 Cache 缓存结果的同时会在后台发起网络请求拿到请求结果并更新 Cache 缓存，如果本来就没有 Cache 缓存的话，直接就发起网络请求并返回结果，这对用户来说是一种非常安全的策略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;networkFirst&lt;/code&gt;：当请求路由是被匹配的，就采用网络优先的策略，也就是优先尝试拿到网络请求的返回结果，如果拿到网络请求的结果，就将结果返回给客户端并且写入 Cache 缓存，如果网络请求失败，那最后被缓存的 Cache 缓存结果就会被返回到客户端，这种策略一般适用于返回结果不太固定或对实时性有要求的请求，为网络请求失败进行兜底。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cacheFirst&lt;/code&gt;：当匹配到请求之后直接从 Cache 缓存中取得结果，如果 Cache 缓存中没有结果，那就会发起网络请求，拿到网络请求结果并将结果更新至 Cache 缓存，并将结果返回给客户端。这种策略比较适合结果不怎么变动且对实时性要求不高的请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;networkOnly&lt;/code&gt;：强制使用正常的网络请求，并将结果返回给客户端，这种策略比较适合对实时性要求非常高的请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cacheOnly&lt;/code&gt;：直接使用 Cache 缓存的结果，并将结果返回给客户端，这种策略比较适合一上线就不会变的静态资源请求。&lt;/li&gt;
&lt;li&gt;如果以上策略都不满足需求，还可以自定义策略&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012353473&quot;&gt;讲讲PWA&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;What's PWA?&lt;/li&gt;
&lt;li&gt;PWA的实现
&lt;ul&gt;&lt;li&gt;Manifest实现添加至主屏幕&lt;/li&gt;
&lt;li&gt;service worker实现离线缓存&lt;/li&gt;
&lt;li&gt;serice worker实现消息推送&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总结：PWA的优势和存在的问题&lt;/li&gt;
&lt;li&gt;参考文档&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/e91705b1a8ca&quot;&gt;Vue笔记九：pwa技术在vue的使用(workbox/sw-precache)&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;历史背景&lt;/li&gt;
&lt;li&gt;sw-precache 和 workbox&lt;/li&gt;
&lt;li&gt;缓存机制&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/yelin042/article/details/79837745&quot;&gt;Workbox 3.0 – Web 站点轻松做到离线可访问&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;用法&lt;/li&gt;
&lt;li&gt;precache (预缓存)静态文件&lt;/li&gt;
&lt;li&gt;处理/和/index.html&lt;/li&gt;
&lt;li&gt;忽略请求参数&lt;/li&gt;
&lt;li&gt;生成预缓存列表
&lt;ul&gt;&lt;li&gt;workbox 命令行&lt;/li&gt;
&lt;li&gt;workbox-build npm 包&lt;/li&gt;
&lt;li&gt;workbox-webpack-plugin&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;路由请求缓存
&lt;ul&gt;&lt;li&gt;字符串方式&lt;/li&gt;
&lt;li&gt;正则表达式fangs&lt;/li&gt;
&lt;li&gt;回调函数方式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;路由请求缓存策略
&lt;ul&gt;&lt;li&gt;state while revalidate&lt;/li&gt;
&lt;li&gt;network first&lt;/li&gt;
&lt;li&gt;cache first&lt;/li&gt;
&lt;li&gt;network only&lt;/li&gt;
&lt;li&gt;cache only&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自定义策略&lt;/li&gt;
&lt;li&gt;第三方请求的缓存&lt;/li&gt;
&lt;li&gt;workbox 配置
&lt;ul&gt;&lt;li&gt;配置缓存名称&lt;/li&gt;
&lt;li&gt;指定 development 环境&lt;/li&gt;
&lt;li&gt;配置日志 level: debug、log、warning、error&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;workbox 插件&lt;/li&gt;
&lt;li&gt;自定义插件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/mjzhang1993/article/details/79584854&quot;&gt;webpack 中使用 workbox 实现 PWA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.imooc.com/article/40432&quot;&gt;Workbox3 - ServiceWorker可以如此简单&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;科普ServiceWorker&lt;/li&gt;
&lt;li&gt;一个完整的ServiceWorker&lt;/li&gt;
&lt;li&gt;workbox3&lt;/li&gt;
&lt;li&gt;经验之谈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://10tiao.com/html/558/201607/2650963560/1.html&quot;&gt;Service Worker 生命周期&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;解析成功(parsed)、正在安装(installing)、安装整个(installed)、正在激活(activating)、激活成功(activated)、废弃(redundant)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 21 Oct 2018 02:08:00 +0000</pubDate>
<dc:creator>ESnail</dc:creator>
<og:description>看到 ，似曾相识，但又感觉很模糊，于是乎，又重新翻阅文档，学习了一遍，顺便把相关知识学习了一下，比如 ,`workbox3`。 PWA 概念： 全称：Progressive Web APP, 渐进式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EnSnail/p/9824198.html</dc:identifier>
</item>
<item>
<title>我们都知道，如何不被淘汰。 - kiba518</title>
<link>http://www.cnblogs.com/kiba/p/9824191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiba/p/9824191.html</guid>
<description>&lt;p&gt;什么是技术？&lt;/p&gt;
&lt;p&gt;技术就是运用我们学习的知识。&lt;/p&gt;
&lt;p&gt;那么，技术高低的本质就是，我们学习的知识多少和运用能力的高下。&lt;/p&gt;
&lt;p&gt;技术从来都不是探索，从来都是应用。&lt;/p&gt;
&lt;p&gt;之所以我们在做技术开发的时候，有探索的感觉；是因为，我们把学习技术的新的应用，错误的感知为了探索。&lt;/p&gt;
&lt;p&gt;什么是技术更新？&lt;/p&gt;
&lt;p&gt;因为技术简单，粗暴的应用，是低效率的，所以，我们集成了公共的技术，并称之为框架。&lt;/p&gt;
&lt;p&gt;因为框架也是技术，所以，有时候，主流框架的更新换代，我们也会说技术更新了。&lt;/p&gt;
&lt;p&gt;其实，从定义上，技术更新和框架更新完全是两个概念。&lt;/p&gt;
&lt;p&gt;技术是我们个人掌握知识和运用能力，如果技术更新了，代表的应该是个人能力提升。&lt;/p&gt;
&lt;p&gt;而主流框架的更新，虽然有时候会促进我们自身拥有技术更新，但他们并不是直接联动的。&lt;/p&gt;
&lt;p&gt;跟我们技术联动的，会让我们拥有的技术直接被淘汰的，其实，是公司的决策；当公司决策使用新的框架时，才会让我们的技术被淘汰。&lt;/p&gt;
&lt;p&gt;公司使用新框架的情况，通常是新项目开发或旧项目重构。&lt;/p&gt;
&lt;p&gt;但，这都是有周期的，而这个周期内，我们完全有富余的时间去掌握新的框架。&lt;/p&gt;
&lt;p&gt;那么，为什么会有很多人的技术被淘汰了呢？&lt;/p&gt;
&lt;p&gt;很简单，那是因为，他们并不是真正的程序员，而是代码工人。&lt;/p&gt;
&lt;p&gt;什么是真正的程序员？&lt;/p&gt;
&lt;p&gt;真正的程序员，是不可能和技术绑定的，因为，他们不可能只掌握一种技术。&lt;/p&gt;
&lt;p&gt;真正的程序员，是会不断的学习新技术，不断的丰富和完善自身的技术结构的。&lt;/p&gt;
&lt;p&gt;真正的程序员眼里，团队是有前端和后端的分工的；但技术是不分前端后端的。&lt;/p&gt;
&lt;p&gt;真正的程序员，即便常年做后端开发，也是会前端的。可以在短时间内迅速掌握，并接手前端开发任务的。反之亦然。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img4.mukewang.com/5bcac27a0001488505000334.jpg&quot; alt=&quot;https://img2.mukewang.com/5bcac27a0001488505120341.jpg&quot; data-src=&quot;https://img2.mukewang.com/5bcac27a0001488505120341.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码工人&lt;/p&gt;
&lt;p&gt;在项目快速迭代的今天，程序员显然是不够用了。&lt;/p&gt;
&lt;p&gt;因为，培养一个程序员，要花三年的时间。&lt;/p&gt;
&lt;p&gt;这种周期的培养，显然是企业不能接受的。同时，很多企业发现，程序员虽然好，会很多种技术；但在项目明确分工的情况下，他们所会的，额外的技术，价值体现并不是很大。&lt;/p&gt;
&lt;p&gt;于是企业们找到了程序员的替代品——代码工人。&lt;/p&gt;
&lt;p&gt;代码工人通常只掌握一门技术，不断做重复性劳动；如果项目需要新技术，只要换一批代码工人就可以了。&lt;/p&gt;
&lt;p&gt;而培养一个代码工人，只需要三个月。所以，大力推广代码工人，显然是最符合企业利益的。&lt;/p&gt;
&lt;p&gt;因为代码工人培养周期低，而且数量众多，可替换性又强，同时也更廉价。&lt;/p&gt;
&lt;p&gt;因此，企业们纷纷开始倾向于使用代码工人。因为培养代码工人，显然是企业是最节约成本的解决方案。当然，这也促进了培训企业的发展。&lt;/p&gt;
&lt;p&gt;于是，IT时代发生了变化，技术能力精良的程序员被代码工人用【廉价的工资】淘汰了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img4.mukewang.com/5bcac28e00012a8904900427.jpg&quot; alt=&quot;https://img4.mukewang.com/5bcac28e00012a8904900427.jpg&quot; data-src=&quot;https://img4.mukewang.com/5bcac28e00012a8904900427.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，现在的程序员新人和早年的程序员新人在能力上是一样的，一样的基础。&lt;/p&gt;
&lt;p&gt;他们的区别是，面对的环境不一样。&lt;/p&gt;
&lt;p&gt;早年的程序员必须面对多种技术，受环境所迫，必须接触新知识；久而久之，大部分的人，都养成了自学的习惯和对技术知识的热情。&lt;/p&gt;
&lt;p&gt;而现在的大环境，只要求新人们掌握一种技术。&lt;/p&gt;
&lt;p&gt;所以，大多数代码工人，做了几年后，发现技术已经与自身形成了绑定。&lt;/p&gt;
&lt;p&gt;因为被绑定了，所以，技术被淘汰了，自身必然面临被淘汰。&lt;/p&gt;
&lt;p&gt;如何避免被淘汰？&lt;/p&gt;
&lt;p&gt;随着IT行业的繁荣，代码工人数量已经及其庞大了。&lt;/p&gt;
&lt;p&gt;而框架与语言的进步是必然，所以，现在的代码工人，人人都面临被淘汰的可能性。所以，空气中，充满了忧虑，焦躁，不安。&lt;/p&gt;
&lt;p&gt;其实，关于如何避免被淘汰的答案，人人都知道。&lt;/p&gt;
&lt;p&gt;学习，学习就可以不被淘汰。&lt;/p&gt;
&lt;p&gt;可是，不断的学习，不就和以前的程序员一样了吗。&lt;/p&gt;
&lt;p&gt;以前的程序员时间成本的付出，是可以拿高薪的。但现在的代码工人，即便付出了时间成本，依然无法拿高薪。因为，那些曾经的高薪程序员，都被廉价的代码工人淘汰了。现在，已经没有企业会重新设立高薪程序员的职位了。&lt;/p&gt;
&lt;p&gt;也就是说，代码工人如果想不被淘汰，必须进化成为程序员，然后继续拿着代码工人的薪水。&lt;/p&gt;
&lt;p&gt;看，答案如此简单，大家都知道，只是都不忍说出来罢了。&lt;/p&gt;

</description>
<pubDate>Sun, 21 Oct 2018 02:06:00 +0000</pubDate>
<dc:creator>kiba518</dc:creator>
<og:description>什么是技术？ 技术就是运用我们学习的知识。 那么，技术高低的本质就是，我们学习的知识多少和运用能力的高下。 技术从来都不是探索，从来都是应用。 之所以我们在做技术开发的时候，有探索的感觉；是因为，我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kiba/p/9824191.html</dc:identifier>
</item>
<item>
<title>多维数据库 Oracle Essbase 和 IBM Cogons 底层原理 - 格德米斯</title>
<link>http://www.cnblogs.com/bgo-tech/p/9824182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bgo-tech/p/9824182.html</guid>
<description>&lt;p&gt;多维数据库（Multi Dimensional Database，MDD）使用Dimension（维度）和Cube（数据立方体、数据集市）模型描述数据。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1539828142827258fdddd57&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;多维数据模型&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;关系型数据库（Relational Database，RDB）中的星型结构或雪花型结构就是模拟上述多维模型结构的，但无法提供真正意义上的多维数据分析能力，这里不做过多解释。&lt;/p&gt;
&lt;p&gt;下文讲解Oracle Essbase以及IBM Cogons这种真正的多维数据库的原理。&lt;/p&gt;
&lt;p&gt;多维数据库中模型结构与事实数据分别以概要文件（profile）和数据块（data block）的形式存在。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p99.pstatp.com/large/pgc-image/1539828226143a4d98b74c4&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;profile和data block&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;概要文件用来描述以下信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;维度和维度成员信息&lt;/li&gt;
&lt;li&gt;与维度相关的层级（Hierarchy）和级别（Level）信息&lt;/li&gt;
&lt;li&gt;Cube的描述性信息，以及Cube与维度的关联性&lt;/li&gt;
&lt;li&gt;其他描述性的信息，如实体模型属性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Cube中度量数据存放在data block中，data block可以被理解成为多维数组结构，其大小与相关维度的明细成员数量有直接关系。&lt;/p&gt;
&lt;p&gt;计算公式：data block size = 维度1明细成员总数 * 维度2明细成员总数 * …… * 维度N明细成员总数&lt;/p&gt;
&lt;p&gt;数据块容量等于相关维度明细成员数量的笛卡尔积。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/15398282572148ada60b846&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;数据块大小&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;明细度量值一般采用double类型，按8bytes算，上图所描述的Cube的数据块大小为480bytes。&lt;/p&gt;
&lt;p&gt;除了数据块中的明细度量值外，其他非明细度量值并没有直接存储，因为其可以通过对应的明细度量值计算出来。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;http://p98.pstatp.com/large/pgc-image/15398282874029959da1f14&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;非明细度量值计算方式&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;一些不存在的度量值会造成数据空洞问题，假设2018年4季度河北省B品牌手机的销售量是未知的，则会在数据块中产生一个空洞。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：数据空洞表示不存在的值，与数值0的意义不同，数值0表示一个有意义的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果数据空洞比较多，则数据块的数据密度就会下降，将造成存储空间的浪费。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p98.pstatp.com/large/pgc-image/1539828316432e356c33d83&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;数据空洞&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;除了数据空洞问题，还存在数据爆炸问题。数据块大小由全部维度明细成员数量的笛卡尔积决定，假如某个Cube关联三个维度，每个维度明细成员数量均为100，则：data block size = 100 ^ 3 = 1000000，如果度量值按double类型存储（8bytes），数据块文件大约为7.62M。如果每个维度明细成员数量增加至150，则数据块文件将膨胀到25.74M（data block size = 150 ^ 3 * 8bytes / 1024 / 1024）。&lt;/p&gt;
&lt;p&gt;当数据块极度膨胀并且存在很多数据空洞的时候，会极大地浪费存储空间，并且可能导致数据存储无法实现。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;http://p98.pstatp.com/large/pgc-image/1539828339614262c1bf0d8&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;极度膨胀和存在大量空洞的多维数组&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;为了解决数据空洞和数据膨胀问题，引入了密集维度组合和稀疏维组合的概念。&lt;/p&gt;
&lt;p&gt;判断维度组合是密集还是稀疏的原则是看其所对应的明细度量值的存在情况，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;北京地区只有ABC三种手机的销售额，天津地区只有BCD三种手机的销售额，河北地区卖出的手机只有AE两种，表明并不是每个地区对于每一种手机都有销售额，所以地区与产品属于稀疏的维度组合。&lt;/li&gt;
&lt;li&gt;2018年的四个季度都有手机销售额，所以日期维度自身可以构成密集的维度组合。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意！在其他讲解多维数据库的文章中都把维度分为稀疏维与密集维，这是非常错误的，对于维度本身来讲没有稀疏与密集之分，稀疏与密集表示的是维度之间的组合！对于有N个维度的Cube而言，如果其只有一个维度退化成索引，或者有N - 1个维度退化成索引，则此时稀疏与密集的维组合只包含一个维度，但这只是一种特例，并不代表维度本身是稀疏或密集的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在引入稀疏与密集的维度组合之后，原本由于数据空洞和数据爆炸而失控的数据块结构将变成索引和密度相对较高的小数据块结构。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1539828365306424a2a8f89&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;索引和小数据块&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;之前数据文件大小为3 * 4 * 5 = 60，结构变换之后每个小数据块大小为4（共8个），在不计算索引所占存储大小的情况下，存储容量变为原来的一半。&lt;/p&gt;
&lt;p&gt;度量值的变化可能引起稀疏维度组合和密集维度组合的改变，如下图所示。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1539828388216f626457158&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;重构&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;虽然解决了数据空洞和数据爆炸的问题，但稀疏与密集的维组合所带来的负作用是一旦度量值的变化导致了数据块密度中心的改变，相关的索引和子数据块必须重构，而这种重构的性能代价与时间成本是极为昂贵的。Cogons、Essbase等传统多维数据库以及其他MOLAP都存在此问题。&lt;/p&gt;
&lt;p&gt;基于矢量计算引擎（Vector Calculation Engine）的新型分布式多维数据库很好的解决了数据重构问题。&lt;/p&gt;
&lt;p&gt;矢量计算引擎将海量数据的运算从多维数据库核心分离出来，进而将多维分析时的逻辑运算与聚集计算解耦。多维数据库核心只负责逻辑运算，完全不需要再考虑数据量的问题。矢量计算引擎采用极为简单的数据结构存储TB、PB级数据，并且只负责进行一种算法上极为简单的聚集运算，针对此种特性，适宜采用更加接近底层的编程语言进行开发（如C语言），不仅得到了性能上的提升，也因为数据存储结构的简单而获得了更加稳定的运行效果。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1539828412982c65b40c97b&quot; alt=&quot;多维数据库 Oracle Essbase 和 IBM Cogons 底层原理&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt;基于矢量计算引擎的多维数据库&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如上图所示，在多维数据库内核角度来看，矢量计算引擎是更加底层的一种基础服务，所以可以根据各种应用场景切换不同的实现方式，而这一切对于多维数据库内核来说都是透明的，多维数据库本身对更上层的应用提供一致的数据查询能力，从而更好的支持了100%面向业务的探索式数据分析能力。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 02:02:00 +0000</pubDate>
<dc:creator>格德米斯</dc:creator>
<og:description>多维数据库（Multi Dimensional Database，MDD）使用Dimension（维度）和Cube（数据立方体、数据集市）模型描述数据。 多维数据模型 多维数据模型 关系型数据库（Re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bgo-tech/p/9824182.html</dc:identifier>
</item>
<item>
<title>责任链模式（Chain Of Responsibility） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9823497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9823497.html</guid>
<description>&lt;h4 id=&quot;chain-of-responsibility&quot;&gt;Chain Of Responsibility？&lt;/h4&gt;
&lt;p&gt;这种情况下，我们可以考虑将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理。&lt;br/&gt;通俗：她告诉我们应该去“营业窗口”。然后等我们到了“营业窗口”后，又被告知应该去“售后部门”。等我们好不容易赶到了“售后部门”，又被告知应该去“资料中心”，因此最后我们又不得不赶往“资料中心”。像这样，在找到合适的办事人之前，我们被不断地踢给一个又一个人，这就是“推卸责任”。&lt;/p&gt;
&lt;h4 id=&quot;理解职责&quot;&gt;理解职责&lt;/h4&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;理解好责任链设计模式关键在于 SolveAnswer是处理者而NoSolve、LimitSolve、OddSolve、SpcialSolve才是具体的处理者。&lt;br/&gt;在SolveAnswer用模版设计的模式定义遇到解决问题的策略办法，能解决就在当前实现的解决方法的子类进行解决，不能解决就在继续向下面的责任类继续传递。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;|名字 +++++++++++++++++++++++++++++++说明&lt;br/&gt;|Question|表示发生的问题的类。它带有问题编号（number）&lt;br/&gt;SolveAnswer用来解决问题的抽象类&lt;br/&gt;NoSolve用来解决问题的具体类（永远“不处理问题”）&lt;br/&gt;LimitSolve用来解决问题的具体类（仅解决编号小于指定编号的问题）&lt;br/&gt;OddSolve|用来解决问题的具体类（仅解决奇数编号的问题）&lt;br/&gt;SpcialSolve用来解决问题的具体类（仅解决指定编号的问题）&lt;br/&gt;MainT 制作SolveAnswer的职责链，制造问题并测试程序行为&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;比较重要的话: &lt;strong&gt;Chain of Responsibility模式的最大优点就在于它弱化了发出请求的人（Client角色）和处理请求的人（ConcreteHandler角色）之间的关系。Client角色向第一个ConcreteHandler角色发出请求，然后请求会在职责链中传播，直到某个ConcreteHandler角色处理该请求。&lt;br/&gt;如果不使用该模式，就必须有某个伟大的角色知道“谁应该处理什么请求”，这有点类似中央集权制。而让“发出请求的人”知道“谁应该处理该请求”并不明智，因为如果发出请求的人不得不知道处理请求的人各自的责任分担情况，就会降低其作为可复用的组件的独立性。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;需要知道的技术点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用Chain of Responsibility模式可以推卸请求，直至找到合适的处理请求的对象，这样确实提高了程序的灵活性，但是会有一定的处理延迟：当然你也可以通过算法来定义处理的特殊路径，但是未免太多余麻烦：所以有的时候我们不如直接显示调用来提高灵活性。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181020233639707-1683296524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181020233642534-1377568772.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Question :&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Question {

    private int question_number;

    public Question(int question_number) {
        this.question_number = question_number;
    }

    public int getQuestion_number() {
        return question_number;
    }

    @Override
    public String toString() {
        return &quot;Question{&quot; +
                &quot;question_number=&quot; + question_number +
                '}';
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;SolveAnswer&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class SolveAnswer {

    private String Solve_Name;

    // 继承链者
    private SolveAnswer next;

    public SolveAnswer(String solve_Name) {
        Solve_Name = solve_Name;
    }

    /**
     * 设置需要推卸责任的对象
     */
    public SolveAnswer setNext(SolveAnswer solveAnswer){
        this.next=solveAnswer;
        return next;
    }

    /**
     * 解决问题的步骤
     */
    public final void support(Question question){
        if(solve(question)){
            finish(question);
        }else if(next!=null){
            this.next.support(question);
        }else{
            fail(question);
        }
    }

    /**
     * 交给子类取解决
     * @param question
     * @return
     */
    protected abstract boolean solve(Question question);

    /**
     *
     * @param question
     */
    private void finish(Question question) {
        System.out.println(question+&quot;能被解决&quot;+this.toString()+&quot;.&quot;);
    }

    /**
     *
     * @param question
     */
    private void fail(Question question) {
        System.out.println(question+&quot;不能被解决.&quot;);
    }

    @Override
    public String toString() {
        return &quot;[&quot;+this.Solve_Name+ &quot;]&quot;;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;NoSolve SpcialSolve OddSolve LimitSolve&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class LimitSolve extends SolveAnswer {

    private int limit;

    public LimitSolve(String solve_Name ,int limit) {
        super(solve_Name);
        this.limit=limit;
    }

    @Override
    public boolean solve(Question question) {

        if(question.getQuestion_number()&amp;lt;limit){
            return true;
        }else{
            return false;
        }

    }
}

public class NoSolve extends SolveAnswer{


    public NoSolve(String solve_Name) {
        super(solve_Name);
    }

    @Override
    public boolean solve(Question question) {
        return false;
    }
}

public class OddSolve extends SolveAnswer {

    public OddSolve(String solve_Name) {
        super(solve_Name);
    }

    @Override
    public boolean solve(Question question) {
        if(question.getQuestion_number()%2==1){
            return  true;
        }else{
            return false;
        }
    }
}

public class SpcialSolve extends SolveAnswer {

    private int special;

    public SpcialSolve(String solve_Name,int specalNum) {
        super(solve_Name);
        this.special=specalNum;
    }

    @Override
    public boolean solve(Question question) {
        if(question.getQuestion_number()==special){
            return true;
        }else {
            return false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;MainT 测试&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class MainT {

    public static void main(String[] args) {

        SolveAnswer tom=new NoSolve(&quot;cat1&quot;);
        SolveAnswer tom2=new LimitSolve(&quot;cat2&quot;,100);
        SolveAnswer tom3=new OddSolve(&quot;cat3&quot;);
        //只能解决225问题
        SolveAnswer tom4=new SpcialSolve(&quot;cat4&quot;,225);

        tom.setNext(tom2).setNext(tom3).setNext(tom4);

        for (int i = 0; i &amp;lt; 300; i+=3) {
                tom.support(new Question(i));
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Oct 2018 15:37:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Chain Of Responsibility？ 这种情况下，我们可以考虑将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理。 通俗：她告诉我们应该去“营业窗口”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9823497.html</dc:identifier>
</item>
</channel>
</rss>