<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>开始食用grpc(之一) - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/9501353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/9501353.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;开始食用grpc(之一)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转载请注明出处：&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/funnyzpc/p/9501353.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/funnyzpc/p/9501353.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;```&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  记一次和一锅们压马路，路过一咖啡厅(某巴克)，随口就问随行的锅门：你能从那咖啡厅看到什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     当时的那家某巴克处于闹市，也正值周末，屋外屋内喝咖啡的人几近乎十分的安静，使用电脑的，刷手机的、做作业的。。。而且大都是年轻人和中年人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  锅门撂了句：一群屌丝呗 &lt;strong&gt;&lt;span&gt;(;¬_¬) &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　。。。白了他一眼&lt;strong&gt;&lt;span&gt;(￢_￢)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     ( ...其实想教唆他进去看看美女，歇歇脚来着 &lt;strong&gt;&lt;span&gt;๑乛◡乛๑&lt;/span&gt;&lt;/strong&gt; )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     许久之后，也就是最近看到诗人余秀华的一句话后忽有所感，原句是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　“&lt;strong&gt;反正是背负慢慢凋残的孤独，耀眼的孤独，义无反顾的孤独&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 这才明白他们是在消费孤独，也为孤独所消费; 他们是，周围的人是，还有 &lt;span&gt;&lt;strong&gt;( ∙̆ .̯ ∙̆ )&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 那~ 孤独的结果是什么呢 ？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;```&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这次讲下大系统通讯必备的一项组件：rpc，rpc有很多 如 &lt;span&gt;dubbo、thirft、feign、motan、grpc&lt;/span&gt; 等~,这其中有字符串方式的也有二进制流方式的；整体来说二进制方式的一般会较字符串方式的快许多，字符形式的的慢，但是简单；而二进制方式的 序列化和跨平台较为麻烦些；我个人选取rpc时一般综合考虑一下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;A&amp;gt;传输方式是否是二进制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　B&amp;gt;是否长期支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C&amp;gt;是否支持跨平台，开源组件是否丰富&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C+&amp;gt;是否支持异步调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　D&amp;gt;有无明显的bug或缺点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　E&amp;gt;维护和开发是否有好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    综合下来，个人坚定之选择grpc，这个初出茅庐(2015年发布)的东东，十分强大:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;span&gt;&amp;gt;&amp;gt; http2流方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&amp;gt;&amp;gt; 自带异步特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&amp;gt;&amp;gt; 跨平台(支持11种语言)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&amp;gt;&amp;gt; 无需zookeeper这类单独的服务中心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&amp;gt;&amp;gt; 对开发人员比较友好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &amp;gt;&amp;gt; 服务调用方可设置请求头&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然缺点也是存在的：需要单独写proto文件(生成目标语言的一套语法定义)、变量为null时会赋予默认初始值、链式调用(还好调用接口较为单一，只是语法较为怪异)...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果您在意以上缺点，可绕过本文哈~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      ok，现在开始我开始讲grpc，内容大致有四：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;A-&amp;gt;grpc的简单配置 (本节)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　A&amp;gt;简单grpc编写 (本节)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　B&amp;gt;复杂grpc proto服务文件编写 (本节)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　C&amp;gt;&lt;span&gt;双向流式调用方法及注意事项 (之二)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　D&amp;gt;&lt;span&gt;grpc安全问题及拦截器 (&lt;strong&gt;之二&lt;/strong&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;grpc的配置：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       这里我的工程是基于springboot，同时为简化开发起见，我使用 &lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/LogNet/grpc-spring-boot-starter&quot; data-pjax=&quot;#js-repo-pjax-container&quot;&gt;&lt;span&gt;grpc-spring-boot-starter&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/strong&gt;，开始之前先感谢这位开发者为简化grpc的java平台简化了太多的开发，同时也为springcloud融合做了太多共享，非常感谢~！ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 这里,首先得准备三个springboot模块，这三个模块包含:&lt;span&gt;grpc proto3文件生成模块、grpc 客户端、grpc 服务端&lt;/span&gt;，我的工程结构大致是这样子的(工程是多模块的)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201808/1161789-20180826000838996-1218511686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里面的三个模块一看就懂，就不细讲啦~，准备好这三个模块后，依次配置依赖包及参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;服务端&lt;/strong&gt;&lt;/span&gt;(&lt;strong&gt;preview-grpc-server&lt;/strong&gt;):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pom.xml中依赖包配置&lt;/span&gt;&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-autoconfigure&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.devh&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;grpc-client-spring-boot-autoconfigure&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　　　&amp;lt;!-- 由于我的工程是多模块的，若不作为jar包引入，也可以将preview-grpc-lib中的java文件拷贝到当前工程内也可 --&amp;gt;&lt;br/&gt;　　　　　&amp;lt;dependency&amp;gt;&lt;br/&gt;　　　　 &amp;lt;groupId&amp;gt;com.github.carvechris&amp;lt;/groupId&amp;gt;&lt;br/&gt;　　　　 &amp;lt;artifactId&amp;gt;preview-grpc-lib&amp;lt;/artifactId&amp;gt;&lt;br/&gt;　　　　 &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;br/&gt;　　　　　&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;配置文件yml(如果是properties文件也可参照此配置)&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;grpc:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  server:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    port: &lt;strong&gt;&lt;span&gt;2804
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    application:
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         name: &lt;strong&gt;&lt;span&gt;preview-grpc-server&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(注意:一定要定义应用名称，在调用的时候会用到应用名称的，这里是：preview-grpc-server)&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;/strong&gt;(preview-grpc-client):&lt;/p&gt;
&lt;p&gt;　　pom.xml文件依赖包配置&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.devh&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;grpc-client-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.4.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&amp;lt;!-- 由于我的工程是多模块的，若不作为jar包引入，也可以将preview-grpc-lib中的java文件拷贝到当前工程内也可 --&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;&lt;br/&gt;　&amp;lt;groupId&amp;gt;com.github.carvechris&amp;lt;/groupId&amp;gt;&lt;br/&gt;　&amp;lt;artifactId&amp;gt;preview-grpc-lib&amp;lt;/artifactId&amp;gt;&lt;br/&gt;　&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　yml配置文件参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;grpc:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  client:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    preview-grpc-server:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      host:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        - 127.0.0.1
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;      port:
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        - &lt;strong&gt;&lt;span&gt;2804
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;      enableKeepAlive: true
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;       keepAliveWithoutCalls: true
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;proto文件生成模块(preview-grpc-lib)配置:&lt;/p&gt;
&lt;p&gt;　　pom.xml文件依赖包配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;依赖配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;io.grpc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;grpc-netty&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${grpc.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;io.grpc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;grpc-protobuf&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${grpc.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;io.grpc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;grpc-stub&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${grpc.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;proto3文件生成java代码插件配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;extensions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;extension&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;kr.motd.maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;os-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${os.plugin.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;extension&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;extensions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.xolstice.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;protobuf-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${protobuf.plugin.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;protocArtifact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;protocArtifact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pluginId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;grpc-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pluginId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pluginArtifact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pluginArtifact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;span&gt;　配置完成，这里需要特别说明一下：&lt;span&gt;server模块和client模块的web服务各占一个端口，另外，server模块还会给grpc单独分配一个端口&lt;/span&gt;，就我的preview-grpc-server来说：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　服务名称(name)是:&lt;span&gt;preview-grpc-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　服务占用的端口是:&lt;span&gt;2804&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　切记，不论是web服务还是grpc服务的端口都不能重复&lt;/span&gt;，同时一定&lt;span&gt;要理清楚web服务和grpc服务所占用的端口和ip&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简单grpc服务(helloworld.proto)编写&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我先展示下我的生成模块的大致样子&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201808/1161789-20180826004150531-463693984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　需要说明的是：编写的&lt;span&gt;proto文件均在proto目录下&lt;/span&gt;，&lt;span&gt;java目录下是proto文件生成的java代码&lt;/span&gt;，这里的&lt;span&gt;java文件是从target目录总复制到java目录下的&lt;/span&gt;,&lt;span&gt;包名一定要与proto里面声明的包名一致！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　java代码生成模块proto3服务文件(&lt;strong&gt;&lt;span&gt;helloworld.proto&lt;/span&gt;&lt;/strong&gt;)的编写&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; syntax = &quot;proto3&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否拆分类文件&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; option java_multiple_files = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成的文件所在的包&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; option java_package = &quot;com.funnyzpc.xxx.grpc.lib.hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  输出类主文件(此配置可选)&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; option java_outer_classname = &quot;HelloWorldProto&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个服务&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;service Simple {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sends a greeting&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    rpc SayHello (HelloRequest) returns (HelloReply) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求体定义&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;message HelloRequest {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     string name = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 响应体定义&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;message HelloReply {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     string message = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;现在开始使用idea提供的快捷功能生成客户端和服务端java文件(当然也可以使用mvn命令手动生成)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201808/1161789-20180826004753158-1336949878.png&quot; alt=&quot;&quot; width=&quot;958&quot; height=&quot;835&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;将生成的java文件复制到应用目录&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201808/1161789-20180826005212863-1958773388.png&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;(注意:&lt;span&gt;复制后一定要清理target目录，不然文件重复会报错！&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;span&gt;客户端&lt;/span&gt;(preview-grpc-client)编写一个grpc服务请求类(&lt;span&gt;GrpcSimpleService.java&lt;/span&gt;)&lt;/span&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GrpcSimpleService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     @GrpcClient(&quot;preview-grpc-server&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Channel serverChannel;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sendMessage(String name) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         SimpleGrpc.SimpleBlockingStub stub =&lt;span&gt; SimpleGrpc.newBlockingStub(serverChannel);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         HelloReply response =&lt;span&gt; stub.sayHello(HelloRequest.newBuilder().setName(name).build());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.getMessage();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在服务端&lt;/span&gt;(preview-grpc-server)编写对应的grpc的服务类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 简单grpc服务类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@GrpcService&lt;/span&gt;(SimpleGrpc.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GrpcServerService &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SimpleGrpc.SimpleImplBase {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOG=LoggerFactory.getLogger(GrpcServerService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sayHello(HelloRequest req, StreamObserver&amp;lt;HelloReply&amp;gt;&lt;span&gt; responseObserver) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         HelloReply reply = HelloReply.newBuilder().setMessage(&quot;Hello ===&amp;gt; &quot; +&lt;span&gt; req.getName()).build();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        responseObserver.onNext(reply);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        responseObserver.onCompleted();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上面的@GrpcService是grpc组件的注解，注解中必须声明所使用的grpc(生成的类中的)服务类，同时还可以声明所使用的拦截器(可选)　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　OK，现在添加一个控制器(在preview-grpc-client中编写一个控制器)，试试看&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201808/1161789-20180826010516461-1274605486.png&quot; alt=&quot;&quot; width=&quot;1163&quot; height=&quot;559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;完美，。。。可能有人proto文件一知半解，接下来进入下一节。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复杂grpc proto服务文件编写：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　首先，我先推荐两个官方网站，若能理解官网内容，可绕过本节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　   grpc java平台api及样例&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;&lt;a href=&quot;https://grpc.io/docs/quickstart/java.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://grpc.io/docs/quickstart/java.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         protocol buffers,proto3文件语法&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般在跨应用调用时，所传递的参数有时候为复杂对象，比如这样{page_no:1,page_size:20,data:{name:XXX,type:2}},这里就写好的复杂层级对象讲解下&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(MultiObject.proto)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; syntax = &quot;proto3&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; option java_multiple_files = true;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; option java_package = &quot;com.github.carvechris.security.grpc.lib.multi&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;service MultiObjService{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    rpc queryObj (MultiObjReq) returns (MultiObjResp) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;message MultiObjReq{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     int32 page_no=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     int32 page_size=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     MultiObjDataReq data=3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;message &lt;span&gt;MultiObjDataReq&lt;/span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     string name=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     int32 type=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;message MultiObjResp{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     string req_str=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     MultiObjFirstResp first=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;message MultiObjFirstResp{
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     string f_content=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     MultiObjNextResp next=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;message MultiObjNextResp{
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     string n_content =1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;文件中定义一个服务 必须以关键字 &lt;span&gt;service&lt;/span&gt; 开始，上面的 MultiObjReq 与 MultiObjResp 分别为服务的请求和响应对象，这两个对象在生成java文件后，每个请求对象都是一个单独的类(可在一个java中也可不在，若不在需要定义：option java_multiple_files = true;)，不管是请求对象还是响应对象，都需要单独声明这个对象以及对象中的变量类型及所处的位置，就像这样&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;message MultiObjReq{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     int32 page_no=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     int32 page_size=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;MultiObjDataReq&lt;/span&gt; data=3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;自定义类型需要在单独定义，比如&quot;MultiObjDataReq&quot;;在上面这个例子中，定义的请求对象MultiObjReq的第一个字段为 page_no，第一个为page_size，第三个为定义的一个对象，每个参数开始需标明当前字段类型，如果这个字段是自定义类型时无需定义数据类型(但是一定要有参数序号，当然也可以定义一个map类型)；另外，通用字段类型同go语言的数据类型(参照以上链接)；注意，请求或响应对象定义时必须以关键字&lt;span&gt;message&lt;/span&gt;开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，请注意，如果某个字段是个列表(java中的List),需要在字段或者对象前添加关键字 &lt;span&gt;repeated&lt;/span&gt; ,这样&lt;/span&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回体数据定义&lt;/span&gt;
&lt;span&gt;message GrpcResp {

    string sign&lt;/span&gt;=3&lt;span&gt;;

    string msg&lt;/span&gt;=4&lt;span&gt;;

    &lt;strong&gt;&lt;span&gt;repeated&lt;/span&gt;&lt;/strong&gt; datas detail&lt;/span&gt;=5&lt;span&gt;;
}

message datas{

    uint64 id&lt;/span&gt;=1&lt;span&gt;;

    string address&lt;/span&gt;=2&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; isadmin=3&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在展示上面的&lt;strong&gt;MultiObject.proto文件 所编写的客户端和服务端类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;客户端&lt;/span&gt;(preview-grpc-client):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　(&lt;span&gt;GrpcMultiObjClientService.java&lt;/span&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GrpcMultiObjClientService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     @GrpcClient(&quot;preview-grpc-service&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Channel serverChannel;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Object testMultiObj() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         MultiObject.MultiObjDataReq reqData=&lt;span&gt;MultiObject.MultiObjDataReq.newBuilder()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 .setName(&quot;queryName&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 .setType(33&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                .build();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         MultiObject.MultiObjReq req=&lt;span&gt;MultiObject.MultiObjReq.newBuilder()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 .setPageNo(11&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 .setPageSize(22&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                .setData(reqData)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                .build();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         MultiObjServiceGrpc.MultiObjServiceBlockingStub stb=&lt;span&gt;MultiObjServiceGrpc.newBlockingStub(serverChannel);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         MultiObject.MultiObjResp resp=&lt;span&gt;stb.queryObj(req);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         Map&amp;lt;String,Object&amp;gt; reMap=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         reMap.put(&quot;getFContent&quot;&lt;span&gt;,resp.getFirst().getFContent());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         reMap.put(&quot;getNContent&quot;&lt;span&gt;,resp.getFirst().getNext().getNContent());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         reMap.put(&quot;getReqStr&quot;&lt;span&gt;,resp.getReqStr());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; reMap;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;服务端&lt;/strong&gt;&lt;/span&gt;(preview-grpc-server):&lt;/p&gt;
&lt;p&gt;　　(&lt;span&gt;GrpcMultiObjService.java&lt;/span&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @GrpcService(MultiObjServiceGrpc.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GrpcMultiObjService &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MultiObjServiceGrpc.MultiObjServiceImplBase{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOG=LoggerFactory.getLogger(GrpcMultiObjService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; queryObj(MultiObject.MultiObjReq request,StreamObserver&amp;lt;MultiObject.MultiObjResp&amp;gt;&lt;span&gt; responseObserver) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         LOG.info(&quot;MultiObjServiceGrpc&amp;gt;start&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Map&amp;lt;String,Object&amp;gt; reqData=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         reqData.put(&quot;getPageNo&quot;&lt;span&gt;,request.getPageNo());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         reqData.put(&quot;getPageSize&quot;&lt;span&gt;,request.getPageSize());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         reqData.put(&quot;getName&quot;&lt;span&gt;,request.getData().getName());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         reqData.put(&quot;getType&quot;&lt;span&gt;,request.getData().getType());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         MultiObject.MultiObjNextResp next=MultiObject.MultiObjNextResp.newBuilder().setNContent(&quot;n_content&quot;&lt;span&gt;).build();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         MultiObject.MultiObjFirstResp first=MultiObject.MultiObjFirstResp.newBuilder().setFContent(&quot;f_content&quot;&lt;span&gt;).setNext(next).build();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         MultiObject.MultiObjResp resp=&lt;span&gt;MultiObject.MultiObjResp.newBuilder().setReqStr(JSON.toJSONString(reqData)).setFirst(first).build();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        responseObserver.onNext(resp);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        responseObserver.onCompleted();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         LOG.info(&quot;MultiObjServiceGrpc&amp;gt;end&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;现在是 &lt;span&gt;2018-08-26 02:13:42 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　由于在双向流编写及测试环节碰到些问题，耽搁了许久，此次会将双向流和安全及拦截器放在下一篇讲，各位，晚安&lt;/span&gt; &lt;span&gt;&lt;strong&gt;（=。=）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 18:32:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<og:description>开始食用grpc(之一) 转载请注明出处：https://www.cnblogs.com/funnyzpc/p/9501353.html ``` 记一次和一锅们压马路，路过一咖啡厅(某巴克)，随口就问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/9501353.html</dc:identifier>
</item>
<item>
<title>【C语言】第一个C语言小程序 —— 日期算法和万年历 - 早起的虫儿去吃鸟</title>
<link>http://www.cnblogs.com/yeyeck/p/9536143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeyeck/p/9536143.html</guid>
<description>&lt;p&gt;1. 写了个万年历的功能练练手。还没有写交互的代码，只是把方法写完了。先给出头部和方法签名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; DAYS_PER_WEEK 7
&lt;span&gt;#define&lt;/span&gt; MONTHS 12
&lt;span&gt;#define&lt;/span&gt; DATE_HEADER &quot;   Sun   Mon   Tues  Wed   Thur  Fri   Sat&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; get_days(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回从公元元年算起，某年某月某日是第几天， 用这个数字算星期几 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_year(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回某年某月某日是当前年份第几天&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_month(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返还某年某月有几天&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; day_of_week(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回某年某月某日是星期几，星期天返回0 &lt;/span&gt;
_Bool is_leap_year(&lt;span&gt;int&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前年份是否为闰年&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; print_date_of_month(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印某年某月的日历     &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.从最简单的两个方法开始&lt;/p&gt;
&lt;p&gt;判断闰年： 能整除400的年份 或者 能整除4，但是不能整除100的年份为闰年&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是不是闰年 &lt;/span&gt;
_Bool is_leap_year(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; year)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (year % &lt;span&gt;400&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; ) || (year % &lt;span&gt;4&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; year % &lt;span&gt;100&lt;/span&gt; != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求某年莫个月份有多少天， 主要是闰年和平年在2月份的区别，闰年2月份有29天，平年2月份28天&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回这个月一共有多少天 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_month(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; month)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储平年每月的天数 &lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  month_days[MONTHS] = {&lt;span&gt;31&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt; == month &amp;amp;&amp;amp;&lt;span&gt; is_leap_year(year))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;29&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是闰年2月，返回29天 &lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; month_days[month-&lt;span&gt;1&lt;/span&gt;];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正常返回 &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从公元1年1月一日开始算，求某年某月某日是第几天。&lt;/p&gt;
&lt;p&gt;算法：1.先算整年的部分：比如2018年，完整已经过了的年份有2017个，按平年算有 2017 * 365 天，但是其中闰年是366天，每个闰年少算了一天。1至2017有几个闰年呢， 首先从闰年的定义：能整除400的年份 或者 能整除4，但是不能整除100的年份为闰年&lt;/p&gt;
&lt;p&gt;　　　　闰年的数量 =  整除4的数量 - 整除100的数量 + 整除400的数量 &lt;/p&gt;
&lt;p&gt;　　　　所以最后的结果是 2017 * 365 + 闰年的数量 + 2018年1月1日到当前日期的天数&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回这一天从公元元年算起是第几天&lt;/span&gt;
 
&lt;span&gt;int&lt;/span&gt; get_days(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt; month, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; day)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; days =&lt;span&gt; days_of_year(year, month, day);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = year-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; temp * &lt;span&gt;365&lt;/span&gt; + temp / &lt;span&gt;4&lt;/span&gt; - temp / &lt;span&gt;100&lt;/span&gt; + temp / &lt;span&gt;400&lt;/span&gt; +&lt;span&gt;  days;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从当前年份1月1日算起，某年某月某日是第几天. &lt;/p&gt;
&lt;p&gt;　　思路很简单就是累加完整月的天数 + 当月日期&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回这一天在当年是第几天 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_year(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt; month, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; day)
{
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; days = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; month; i++&lt;span&gt;)
     {
         days &lt;/span&gt;+=&lt;span&gt; days_of_month(year, i);
         
     }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; days +&lt;span&gt; day;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算某年某月某日是星际几&lt;/p&gt;
&lt;p&gt;　　因为公元元年1月1日是星期1，所以先算出从公元元年算起，当前日期是第几天，然后对7求模，星期天的时候返回 0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; day_of_week(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt; month, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; day)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; get_days(year, month, day) %&lt;span&gt; DAYS_PER_WEEK;
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印某年某个月的日历&lt;/p&gt;
&lt;p&gt;//思路就是先确定当月1号是周几，先打印1号，然后剩下的根据1号来推&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出某年某个月的日历 &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; print_date_of_month(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; month)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印月份,为了让月份显示居中， 打印一些空格（根据打印星期的那行大概估算一下） &lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(month)
    {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;January\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;February\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;March\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;April\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;June\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;July\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;August\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;September\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;October\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;November\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;December\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad input of month, please enter a right month.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先把星期打印出来 &lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DATE_HEADER);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先求出这个月第一天星期几 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; day_of_week = get_days(year, month, &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; DAYS_PER_WEEK;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为星期天是在第一个位置，所以对星期求模（求余），比如星期天，其实是第一个位置，所以它应该是 7 % 7 = 0； &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; first = day_of_week %&lt;span&gt; DAYS_PER_WEEK;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求出这个月一共有几天 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; days =&lt;span&gt; days_of_month(year, month);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先打印第一天的位置 &lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; first; i++&lt;span&gt;) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%6d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果今天是星期六，换行 &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(first == &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印剩下的日期 &lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; days; i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%6d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是星期六或者是最后一天，换行 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;((first + i) % &lt;span&gt;7&lt;/span&gt; == &lt;span&gt;6&lt;/span&gt; || i + &lt;span&gt;1&lt;/span&gt; ==&lt;span&gt; days)
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;.最后附上完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; DAYS_PER_WEEK 7
&lt;span&gt;#define&lt;/span&gt; MONTHS 12
&lt;span&gt;#define&lt;/span&gt; DATE_HEADER &quot;   Sun   Mon   Tues  Wed   Thur  Fri   Sat&quot;



&lt;span&gt;int&lt;/span&gt; get_days(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回从公元元年算起，某年某月某日是第几天， 用这个数字算星期几 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_year(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回某年某月某日是当前年份第几天&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_month(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返还某年某月有几天&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; day_of_week(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回某年某月某日是星期几，星期天返回0 &lt;/span&gt;
_Bool is_leap_year(&lt;span&gt;int&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前年份是否为闰年&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; print_date_of_month(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印某年某月的日历     &lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; days = get_days(&lt;span&gt;2018&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;) %&lt;span&gt; DAYS_PER_WEEK;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, day_of_week(&lt;span&gt;2018&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;));
    
    print_date_of_month(&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
 }



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回这一天从公元元年算起是第几天&lt;/span&gt;
 
&lt;span&gt;int&lt;/span&gt; get_days(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt; month, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; day)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; days =&lt;span&gt; days_of_year(year, month, day);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = year-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; temp * &lt;span&gt;365&lt;/span&gt; + temp / &lt;span&gt;4&lt;/span&gt; - temp / &lt;span&gt;100&lt;/span&gt; + temp / &lt;span&gt;400&lt;/span&gt; +&lt;span&gt;  days;
}
 
 

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回这一天在当年是第几天 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_year(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt; month, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; day)
{
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; days = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; month; i++&lt;span&gt;)
     {
         days &lt;/span&gt;+=&lt;span&gt; days_of_month(year, i);
         
     }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; days +&lt;span&gt; day;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回这个月一共有多少天 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; days_of_month(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; month)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储平年每月的天数 &lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  month_days[MONTHS] = {&lt;span&gt;31&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt; == month &amp;amp;&amp;amp;&lt;span&gt; is_leap_year(year))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;29&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是闰年2月，返回29天 &lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; month_days[month-&lt;span&gt;1&lt;/span&gt;];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正常返回 &lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是不是闰年 &lt;/span&gt;
_Bool is_leap_year(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; year)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (year % &lt;span&gt;400&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; ) || (year % &lt;span&gt;4&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; year % &lt;span&gt;100&lt;/span&gt; != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; day_of_week(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt; month, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; day)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; get_days(year, month, day) %&lt;span&gt; DAYS_PER_WEEK;
 } 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出某年某个月的日历 &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; print_date_of_month(&lt;span&gt;int&lt;/span&gt; year, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; month)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印月份,为了让月份显示居中， 打印一些空格（根据打印星期的那行大概估算一下） &lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(month)
    {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;January\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;February\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;March\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;April\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;June\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;July\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;August\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;September\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;October\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;November\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;December\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bad input of month, please enter a right month.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先把星期打印出来 &lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DATE_HEADER);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先求出这个月第一天星期几 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; day_of_week = get_days(year, month, &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; DAYS_PER_WEEK;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为星期天是在第一个位置，所以对星期求模（求余），比如星期天，其实是第一个位置，所以它应该是 7 % 7 = 0； &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; first = day_of_week %&lt;span&gt; DAYS_PER_WEEK;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求出这个月一共有几天 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; days =&lt;span&gt; days_of_month(year, month);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先打印第一天的位置 &lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; first; i++&lt;span&gt;) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%6d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果今天是星期六，换行 &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(first == &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印剩下的日期 &lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; days; i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%6d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是星期六或者是最后一天，换行 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;((first + i) % &lt;span&gt;7&lt;/span&gt; == &lt;span&gt;6&lt;/span&gt; || i + &lt;span&gt;1&lt;/span&gt; ==&lt;span&gt; days)
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;跑起来测试结果， 打印的日历是2018年8月的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1213881/201808/1213881-20180826021845928-1085160485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1213881/201808/1213881-20180826021951008-162166195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1213881/201808/1213881-20180826022024028-368588428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 25 Aug 2018 18:21:00 +0000</pubDate>
<dc:creator>早起的虫儿去吃鸟</dc:creator>
<og:description>1. 写了个万年历的功能练练手。还没有写交互的代码，只是把方法写完了。先给出头部和方法签名 2.从最简单的两个方法开始 判断闰年： 能整除400的年份 或者 能整除4，但是不能整除100的年份为闰年</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeyeck/p/9536143.html</dc:identifier>
</item>
<item>
<title>微信小程序学习 - 卷柏的花期</title>
<link>http://www.cnblogs.com/HCJJ/p/9536135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HCJJ/p/9536135.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;最近工作正好有闲暇时间，根据公司安排先前期学习调研一下“微信小程序”，以供后期解决相关的运营需求，而本篇文章就是我对此次学习的一次总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;什么是小程序 ？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何全面具体的学习？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册与新建小程序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;认识开发工具&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录结构与代码构成&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;JSON 配置文件&lt;/li&gt;
&lt;li&gt;WXML 模版文件&lt;/li&gt;
&lt;li&gt;WXSS 样式文件&lt;/li&gt;
&lt;li&gt;JS 脚本文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小程序的执行流程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小程序知识体系导图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小程序开发的重要说明&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;WXSS&lt;/li&gt;
&lt;li&gt;模版语法&lt;/li&gt;
&lt;li&gt;自定义模版&lt;/li&gt;
&lt;li&gt;数据绑定&lt;/li&gt;
&lt;li&gt;事件处理&lt;/li&gt;
&lt;li&gt;自定义组件&lt;/li&gt;
&lt;li&gt;行为 - Behaviors&lt;/li&gt;
&lt;li&gt;生命周期函数&lt;/li&gt;
&lt;li&gt;作用域&lt;/li&gt;
&lt;li&gt;多页面数据共享&lt;/li&gt;
&lt;li&gt;版本库兼容性&lt;/li&gt;
&lt;li&gt;用户权限&lt;/li&gt;
&lt;li&gt;WXS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开源项目参考&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下一步计划&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;什么是小程序&quot;&gt;什么是小程序 ？&lt;/h2&gt;
&lt;p&gt;个人认为在样式、功能、使用方式上接近传统APP并依赖于微信运行环境的 H5页面就是所谓的“微信小程序”。&lt;br/&gt;微信小程序对比传统的 APP，它无需安装，在微信环境中可直接运行，并且依附于微信的生态圈，所以可以被更快速，方便，高效的推广。&lt;/p&gt;
&lt;h2 id=&quot;如何全面具体的学习&quot;&gt;如何全面具体的学习？&lt;/h2&gt;
&lt;p&gt;学习“微信小程序”，可以打开“微信公众平台·小程序”平台，里面有非常详细的讲解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://developers.weixin.qq.com/miniprogram/dev/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个页面中，你可以从“介绍”、“设计”、“开发”、“运营”、“数据”等各个方面对小程序进行一个全面整体的认知。&lt;/p&gt;
&lt;p&gt;若你是位“开发者”，那么应该专注学习“设计”，“开发”这两个方面。在“设计”方面你将学会小程序的交互和更棒的用户体验方面。而在“开发”中你将从“简易教程”、“框架”、“组件”、“API”、“工具”等全方面学习如何开发一款小程序应用。&lt;/p&gt;
&lt;p&gt;如果有其它疑问，也可以在 &lt;a href=&quot;https://developers.weixin.qq.com/&quot;&gt;社区&lt;/a&gt; 中进行反馈交流。&lt;/p&gt;
&lt;h2 id=&quot;注册与新建小程序&quot;&gt;注册与新建小程序&lt;/h2&gt;
&lt;p&gt;首先，你需要有一个“微信小程序”的账号。通过下面的链接，打开“微信公众平台”，然后点击最上面的“立即注册”，接着选择“小程序”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://mp.weixin.qq.com/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前小程序的开放范围主要有“个人”、“企业”、“政府”、“媒体”、“其它组织”这几个。&lt;br/&gt;如果你是企业级应用，可以直接在企业的微信公众号中直接添加“微信小程序”，从而无需注册。&lt;br/&gt;有了小程序账号后，就可以登录“微信公众平台”，进入“微公众信平台·小程序”后台。&lt;/p&gt;
&lt;p&gt;在“微公众信平台·小程序”后台中我们便可以根据流程提示开始新建一个小程序项目，小程序项目新建完成后，可以通过左侧栏目中的 “设置” - “开发设置” 拿到该小程序的 “AppID”，这一步至关重要，因为我们后面通过开发者工具新建的项目就需要填入 “AppID”。&lt;/p&gt;
&lt;p&gt;“AppID” 相当于小程序平台的一个身份证 ，后续建立小程序项目，或者腾讯云服务都会使用到它，如果没有 “appID”，也可以使用开发工具上的测试号。&lt;/p&gt;
&lt;h2 id=&quot;认识开发工具&quot;&gt;认识开发工具&lt;/h2&gt;
&lt;p&gt;“微信小程序”的开发需要特定的开发工具，通过“微信开发者工具”我们可以编译、调试、预览、上传、发布小程序页面，同时还可以管理微信小程序的授权状态等。&lt;/p&gt;
&lt;p&gt;下载 &amp;gt; &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18082016&quot;&gt;微信开发中工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;“微信开发者工具”分为 “beta版” 与 正式版。一般我们使用的都是正式版，而像&lt;code&gt;Git&lt;/code&gt;，&lt;code&gt;NPM&lt;/code&gt; 之类新功能目前只有“beta版“才支持。&lt;br/&gt;“微信开发者工具”下载安装完成后，可以选择建立“小程序项目”，然后输入小程序的名称，路径以及 “appID”，然后点击“确定”即可。&lt;br/&gt;“微信开发者工具”不仅可以开发小程序项目，还可以开发“插件”、“代码片段”等。&lt;br/&gt;“微信开发者工具”主要有以下几个重要功能点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模拟器：可以设置网络、分辨率、缩放以及选择设备类型。&lt;/li&gt;
&lt;li&gt;编辑器：与传统的编辑器相同，进行代码的编辑。&lt;/li&gt;
&lt;li&gt;调试器：浏览器控制台，与Chrome基本相同主要新增了 appData、WXML、sensor等小程序专属的选项。&lt;/li&gt;
&lt;li&gt;编译、预览、调试、远程调试。&lt;/li&gt;
&lt;li&gt;详情：可以进行“项目设置”，“域名信息”、“腾讯云状态”。&lt;/li&gt;
&lt;li&gt;其它常用功能：社区、上传、缓存管理、场景值、腾讯云（提供了一套完整的小程序解决方案，方便新手练习）。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/debug.html (更多开发工具的介绍)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“微信开发者工具”常用快捷键：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl+B&lt;/td&gt;
&lt;td&gt;编译项目（焦点在开发工具中）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl+R&lt;/td&gt;
&lt;td&gt;编译项目（焦点不在开发工具中）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Ctrl+Shift+P&lt;/td&gt;
&lt;td&gt;预览项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Shift+Alt+F&lt;/td&gt;
&lt;td&gt;格式化代码&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;目录结构与代码构成&quot;&gt;目录结构与代码构成&lt;/h2&gt;
&lt;p&gt;下面是一个小程序完整的目录结构图 (请右击查看大图)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/shenguotao/kj7ki087ibdnjkseopkcn9f5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.png&quot; alt=&quot;微信小程序.png-333.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过观察上图的目录与文件，你会发现小程序的代码主要有以下几个文件类型构成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;.json&lt;/li&gt;
&lt;li&gt;.WXML&lt;/li&gt;
&lt;li&gt;.wxss&lt;/li&gt;
&lt;li&gt;.js&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;json-配置文件&quot;&gt;JSON 配置文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;.json&lt;/code&gt; 文件是小程序的配置文件。&lt;br/&gt;在小程序中配置文件按照应用范围又分为以下主要四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;project.config.json&lt;/li&gt;
&lt;li&gt;app.json&lt;/li&gt;
&lt;li&gt;pages.json&lt;/li&gt;
&lt;li&gt;component.json`&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;project.config.json&lt;/strong&gt;&lt;br/&gt;它是开发者工具和小程序项目的共同配置文件，它可以在多个开发者中维护统一的开发设置和开发环境。例如编辑器的颜色、ES6转ES5、上传代码时自动压缩、是否校验不合法域名、版本库等等。&lt;br/&gt;当新的开发者下载了开发者工具后，只需要将团队中的 &lt;code&gt;project.config.json&lt;/code&gt; 文件拷贝到本地小程序的根目录中即可。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html (更多关于project.config.json)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;app.json&lt;/strong&gt;&lt;br/&gt;它是整个小程序应用的全局配置文件，可以设置小程序的页面、窗口、tab栏、网络超时、debug、插件、分包、多线程等。&lt;br/&gt;其中常用到的字段是 &lt;code&gt;pages&lt;/code&gt;、&lt;code&gt;window&lt;/code&gt;以及 &lt;code&gt;tabBar&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;pages&lt;/code&gt;用于配置小程序的页面路径，其值是一个数组，数组中的第一个元素就是小程序的主页，并且在开发工具中新增一个路径时，编辑器会自动创建对应页面的目录以及文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：路径中的文件名 &quot;index&quot; 与 &quot;logs&quot; 不要加扩展名，小程序的编译工具会自动寻找对应的文件类型进行处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;window&lt;/code&gt; 用于配置窗口的样式以及标题等。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;navigationBarBackgroundColor&lt;/td&gt;
&lt;td&gt;导航栏背景颜色&lt;/td&gt;
&lt;td&gt;HEX&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;navigationBarTextStyle&lt;/td&gt;
&lt;td&gt;black / white&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;navigationBarTitleText&lt;/td&gt;
&lt;td&gt;导航栏标题文字内容&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;backgroundColor&lt;/td&gt;
&lt;td&gt;窗口的背景色&lt;/td&gt;
&lt;td&gt;HEX&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;tabBar&lt;/code&gt;也是比较常用的配置，用于设置 tab栏的位置（上、下）以及按钮的文字，样式和 icon。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE (更多关于app.json)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;pages.json&lt;/strong&gt;&lt;br/&gt;每个页面都有自己的 &lt;code&gt;pages.json&lt;/code&gt; 文件。&lt;br/&gt;&lt;code&gt;pages.json&lt;/code&gt; 文件可以在全局配置 &lt;code&gt;app.json&lt;/code&gt; 的基础上对页面进一步的进行设置。例如导航栏的颜色，标题文字等。&lt;br/&gt;另外 &lt;code&gt;pages.json&lt;/code&gt; 还可以通过 &lt;code&gt;usingComponents&lt;/code&gt; 字段来声明当前页面引用了那些自定义组件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE (更多pages.json)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;componet.json&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componet.json&lt;/code&gt; 是自定义组件的配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;component&quot;: true,        // 自定义组件声明
  &quot;usingComponents&quot;: {}     // 可选项，用于引用别的组件
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;wxml-模版文件&quot;&gt;WXML 模版文件&lt;/h3&gt;
&lt;p&gt;你可以将 &lt;code&gt;WXML&lt;/code&gt; 等同于传统 WEB开发时用到的 &lt;code&gt;html&lt;/code&gt;，他们都是用来描述页面的结构骨架，不同的是 HTML文件由一个个html标记(Tag)组成，而 WXML则是有与之类似的“组件”组成。&lt;br/&gt;除了在结构特性上与 HTML一致外，WXML 文件还支持特定的模版语法，数据绑定，事件处理、自定义模版等等。&lt;br/&gt;同样的 WXML也可以分为页面的 WXML文件，自定义模版的 WXML文件以及自定义组件中的 WXML文件。&lt;/p&gt;
&lt;h3 id=&quot;wxss-样式文件&quot;&gt;WXSS 样式文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;wxss&lt;/code&gt; 具有大部分 CSS的功能，所以你可以像 CSS一样去编写小程序的样式文件。&lt;br/&gt;对于整个小程序公用的样式，可以放置在 &lt;code&gt;app.wxss&lt;/code&gt; 文件中，而对于页面专用的样式，则写到对应页面的 &lt;code&gt;pages.wxss&lt;/code&gt;文件中，其次便是自定义组件也会含有自己的 &lt;code&gt;component.wxss&lt;/code&gt;文件。&lt;/p&gt;
&lt;h3 id=&quot;js-脚本文件&quot;&gt;JS 脚本文件&lt;/h3&gt;
&lt;p&gt;在小程序的脚本文件中，我们可以处理事件，响应用户请求，获取接口数据，改变数据状态...并且小程序的脚本文件默认支持&lt;code&gt;commonJS&lt;/code&gt;规范，可以直接通过 &lt;code&gt;require()&lt;/code&gt; 来导入模块，&lt;code&gt;module.exports&lt;/code&gt; 导出模块，就编码的角度而言，与我们普通编写脚本文件并没有什么太大的区别，如果非要说区别的话，就是小程序中的脚本可以调用小程序内置的一些API接口，例如授权，支付等。&lt;/p&gt;
&lt;p&gt;同样的&lt;code&gt;app.js&lt;/code&gt;用于存放全局的数据和方法，而 &lt;code&gt;pages.js&lt;/code&gt; 则存放每个页面自己的数据和方法，对于组件中的脚本文件而言，它保存的则是组件自己的数据和方法&lt;/p&gt;
&lt;h2 id=&quot;小程序的执行流程&quot;&gt;小程序的执行流程&lt;/h2&gt;
&lt;p&gt;(请右击查看大图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/shenguotao/p8hi5pllqkv63whwad5h836t/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;小程序执行流程.png-39.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当微信客户端打开一个小程序的时候，会将整个小程序的代码包下载到本地，然后通过读取 &lt;code&gt;app.json&lt;/code&gt;文件获取页面的路径，并将第一条路径作为首页，并根据 &lt;code&gt;app.json&lt;/code&gt; 中的配置来初始化小程序窗口的样式。&lt;/p&gt;
&lt;p&gt;紧接着，微信客户端再将 &lt;code&gt;app.js&lt;/code&gt; 装载进来，执行其中的 &lt;code&gt;App()&lt;/code&gt; 方法，实例化一个小程序对象（整个微信小程序也只有一个这样的实例对象，并且全部页面共享该对象，你可以在每个页面使用 &lt;code&gt;getApp()&lt;/code&gt;方法来获取）。&lt;/p&gt;
&lt;p&gt;当小程序实例对象创建完成后，会触发生命周期中的 &lt;code&gt;onLaunch()&lt;/code&gt; 函数，然后继续装载小程序中的每个页面（默认便是首页），在装载页面的时候，同样的会先装载 &lt;code&gt;pages.json&lt;/code&gt;的代码，用来初始化页面与窗口的样式，然后再装载 &lt;code&gt;WXML&lt;/code&gt;文件以及其使用到的资源（wxs，模版、组件）来生成页面结构，一切就绪再加载 &lt;code&gt;wxss&lt;/code&gt;获取页面样式，最后再去装载 &lt;code&gt;.js&lt;/code&gt;的脚本文件。&lt;/p&gt;
&lt;p&gt;当最后的 &lt;code&gt;.js&lt;/code&gt;文件也被装载进来后， 就会调用脚本中的&lt;code&gt;Page()&lt;/code&gt;构造函数，还回一个页面的实例对象，页面实例对象创建好后，就会根据其中的 data 数据与 WXML文件中的内容 一起渲染出最终的页面，最后页面渲染完成后，并且在这一过程中，页面实例会根据不同时期的状态触发不同的页面生命周期函数。&lt;/p&gt;
&lt;p&gt;明白小程序的基本执行流程，对后面了解小程序执行的生命周期非常有帮助。&lt;/p&gt;
&lt;h2 id=&quot;小程序知识体系导图&quot;&gt;小程序知识体系导图&lt;/h2&gt;
&lt;p&gt;(请右击查看大图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/shenguotao/xfal98qppkqv94ezpeik3euk/mp.png.png&quot; alt=&quot;mp.png.png-1344.3kB&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小程序开发的重要说明&quot;&gt;小程序开发的重要说明&lt;/h2&gt;
&lt;p&gt;小程序开发还是很简单的，像一些 API接口以及组件的使用，在开发手册上都有详细列举，所以这里我就将我个人认为小程序中比较常用或者是比较重要（跟传统web开发有点区别）的地方单独记录下来。&lt;/p&gt;
&lt;h3 id=&quot;wxss&quot;&gt;WXSS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;WXSS&lt;/code&gt; 是基于 CSS 改进而来的，所以大部分的 CSS写法也可以套用在 &lt;code&gt;WXSS&lt;/code&gt; 上，这里主要对这两者重点的区别加以说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rpx&lt;/strong&gt;&lt;br/&gt;新增的相对单位，&lt;code&gt;rpx&lt;/code&gt; 默认将屏幕划分为750个单位。&lt;br/&gt;注意的是：&lt;code&gt;px&lt;/code&gt; 在小程序中依然也可以用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择器&lt;/strong&gt;&lt;br/&gt;WXSS 支持的选择器相比 CSS要少一些，但是主流的：类、ID、元素，分组、伪类（after，before）、伪元素（:hover 这里表示元素选中）等选择器都支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块化样式&lt;/strong&gt;&lt;br/&gt;支持 &lt;code&gt;@import &quot;path&quot;&lt;/code&gt; 导入样式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内嵌样式&lt;/strong&gt;&lt;br/&gt;小程序中组件支持通过 &lt;code&gt;style&lt;/code&gt; 属性来内嵌内联样式，并且还可以通过表达式来接收绑定的数据。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view style=&quot;font-size:{{fontSize}}pt&quot;&amp;gt;&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;背景图&lt;/strong&gt;&lt;br/&gt;wxss 不支持本地图片（相对路径图片）作为背景图，对于需要内嵌在 wxss文件中的图片，请使用 &lt;code&gt;base64&lt;/code&gt; 或者是网上的图片。&lt;br/&gt;不过，image 组件支持本地图片&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html (更多关于WXSS)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模版语法&quot;&gt;模版语法&lt;/h3&gt;
&lt;p&gt;WXML文件也称之为“WXML模版”文件，它与 HTML文件结构相同，都是有许多结构标记组成，只是在小程序中，这些标记被称之为“组件”。&lt;br/&gt;WXML文件与 HTML文件的不同在于WXML模版支持特定的模版语法，可以直接再模版中进行运算处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表达式&lt;/strong&gt;&lt;br/&gt;WXML支持通过 &lt;code&gt;{{variant}}&lt;/code&gt; 表达式来获取对应页面脚本中 &lt;code&gt;data&lt;/code&gt; 定义的数据。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;#page.wxml
&amp;lt;view&amp;gt;{{names}}&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;#page.js
Page({
    data:{
        names:&quot;xiaoming&quot;
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;{{}}&lt;/code&gt; 表达式不仅可以读取变量的值，还支持一些常规的运算操作，比如“算数运算”、“三元运算”、“比较运算”、“字符串运算”等，另外还可以在表达式中定义数组、对象等类型的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{{a + b}} + {{c}}
{{flag ? true : false}}
{{length &amp;gt; 5}}
{{&quot;hellow&quot; + name}}
{{[zero, 1, 2, 3, 4]}}
{{for: a, bar: b}} | {{...obj1, ...obj2, e: 5}} | {{name,age}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;条件判断&lt;/strong&gt;&lt;br/&gt;微信小程序支持在WXML模版文件中进行条件判断。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view wx:if=&quot;{{variant &amp;gt; 70 &amp;amp;&amp;amp; variant &amp;gt;=90}}&quot;&amp;gt;...&amp;lt;/view&amp;gt;
&amp;lt;view wx:elif=&quot;{{variant &amp;lt;70 &amp;amp;&amp;amp; variant &amp;gt;=30}}&quot;&amp;gt;...&amp;lt;/view&amp;gt;
&amp;lt;view wx:else=&quot;{{variant &amp;lt; 30}}&quot;&amp;gt;...&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;循环遍历&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WXML模板同样还支持循环遍历。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view wx:for=&quot;{{arrs}}&quot;&amp;gt;
    {{item}} - {{index}}
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;arrs&lt;/code&gt; 是页面脚本 &lt;code&gt;data&lt;/code&gt; 中定义的一个数组，而 &lt;code&gt;item&lt;/code&gt; 与 &lt;code&gt;index&lt;/code&gt; 都是循环体中固定的写法，分别表示了每次循环“项”和每次循环的“索引”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表渲染&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view wx:for=&quot;{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}&quot; wx:for-item=&quot;i&quot;  wx:for-index=&quot;a&quot;&amp;gt;
  &amp;lt;view wx:for=&quot;{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}&quot; wx:for-item=&quot;j&quot; wx:for-index=&quot;b&quot;&amp;gt;
    &amp;lt;view wx:if=&quot;{{i &amp;lt;= j}}&quot;&amp;gt;
      {{i}} * {{j}} = {{i * j}}
    &amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;wx:for-item&lt;/code&gt; 与 &lt;code&gt;wx:for-index&lt;/code&gt; 用来解决多层循环嵌套&lt;code&gt;item&lt;/code&gt; 与 &lt;code&gt;index&lt;/code&gt; 重复的问题。&lt;/p&gt;
&lt;p&gt;另外，还有一个 &lt;code&gt;wx:key&lt;/code&gt; 的控制属性，它的取值有 &lt;code&gt;String&lt;/code&gt; 与 &lt;code&gt;*this&lt;/code&gt; 两种。&lt;br/&gt;&lt;code&gt;String&lt;/code&gt; 可以是 for循环中每个 item自身的 &lt;code&gt;property&lt;/code&gt; 的名称，这个 &lt;code&gt;property&lt;/code&gt; 的值要保证在整个循环遍历中，相对其它的 item &lt;code&gt;property&lt;/code&gt;的值都是唯一的。&lt;br/&gt;&lt;code&gt;*this&lt;/code&gt; 则是代表每次循环的 item本身，这种表示需要 item 本身是一个唯一的字符串或者是数值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wx:key&lt;/code&gt; 要求唯一的原因是当数据改变触发渲染时，列表中通过 &lt;code&gt;wx:key&lt;/code&gt; 指定的选项，不会被重新渲染只会改变位置顺序，也就是说不会被移出重新插入，从而能够保持一种固定的状态。这样也更加的节省性能。当然如果你非常确定你的列表是静态的并且不会发生改变，那么也无需使用该属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;block&lt;/strong&gt;&lt;br/&gt;当我们在模版中使用控制属性，总需要将其挂载到一个组件上，这往往就会让不需要组件加入到页面渲染中。&lt;br/&gt;为了解决这个问题，小程序提供了另一个特殊的组件：&lt;code&gt;&amp;lt;block&amp;gt; &amp;lt;/block&amp;gt;&lt;/code&gt;，使用 &lt;code&gt;block&lt;/code&gt; 以作为控制属性的载体，并切不会被渲染到页面上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;block wx:for=&quot;&quot; &amp;gt;
    &amp;lt;view wx:if=&quot;&quot;  &amp;gt;&amp;lt;/view&amp;gt;
&amp;lt;/block&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/ (更多关于模版以及模版语法)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;自定义模版&quot;&gt;自定义模版&lt;/h3&gt;
&lt;p&gt;WXML支持两种模版类型，一种是通过 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 组件定义的“动态模版”，我们可以向“动态模版”中传入数据，并运用表达式、模版语法、控制属性等进行运算。另一中就是“静态模版”，通过 &lt;code&gt;&amp;lt;include&amp;gt;&lt;/code&gt; 组件将静态的 wxml 文件引入到指定的位置中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态模版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义模版&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template name=&quot;example-tem&quot;&amp;gt;
    &amp;lt;view wx:for=&quot;{{arrs}}&quot;&amp;gt;&amp;lt;/view&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用模版&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;template is=&quot;example-tem&quot; data=&quot;{{arrs:[1,2,3]}}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外部导入模版并调用&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;import src=&quot;template/example-tem&quot; /&amp;gt; #引入外部模版
&amp;lt;template is=&quot;example-tem&quot; data=&quot;{{arrs:[1,2,3]}}&quot; #使用模版&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;静态模版&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br/&gt;对比 &lt;code&gt;import&lt;/code&gt; ,&lt;code&gt;include&lt;/code&gt; 只是单纯的将一个模版中的所有组件内容拷贝到你使用 &lt;code&gt;include&lt;/code&gt; 的位置处(需要注意的是模版中的 &lt;code&gt;template&lt;/code&gt; 与 &lt;code&gt;wxs&lt;/code&gt;不能被拷贝)。除此之外，&lt;code&gt;import&lt;/code&gt; 有自己的作用域，如果要传递数据到对应的 template内，须要借助 &lt;code&gt;data&lt;/code&gt; 属性。&lt;/p&gt;
&lt;h3 id=&quot;数据绑定&quot;&gt;数据绑定&lt;/h3&gt;
&lt;p&gt;微信小程序支持类似 vue的MVVM模式，即数据（逻辑层）与视图（渲染层）相互分离，当数据发生改变的时候，可自动的刷新视图。&lt;br/&gt;使用起来也非常简单，通过模版的表达式结合逻辑层的 &lt;code&gt;setData&lt;/code&gt; 方法既可以使用。&lt;br/&gt;示例:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view&amp;gt;{{names}}&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Page({
    data:{
        names:&quot;xiaoming&quot;
    },
    onLoad:function(){
        this.setData({names:&quot;xiaohong&quot;});
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;事件处理&quot;&gt;事件处理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事件绑定(支持事件冒泡)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bind:eventName&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;事件绑定(不支持事件冒泡)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;catch:eventName&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;事件捕获(可以再冒泡)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;capture-bind:eventName&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;事件捕获(不会冒泡)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;capture-catch&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义组件&quot;&gt;自定义组件&lt;/h3&gt;
&lt;p&gt;“自定义组件”可以认为是具有特定可复用功能的最小型页面，“自定义组件”与小程序内置组件一样可以定制自己的功能，数据还有属性。&lt;br/&gt;“自定义组件”的目录结构以及代码构成与普通页面完全一致，其中 &lt;code&gt;*.js&lt;/code&gt;是自定义组件的数据方法文件，&lt;code&gt;*.json&lt;/code&gt;是配置文件。&lt;code&gt;*.wxml&lt;/code&gt;是自定义组件的结构模版文件，&lt;code&gt;*.wxss&lt;/code&gt;是自定义组件的样式文件。&lt;/p&gt;
&lt;p&gt;首先建立组件的目录，然后创建以下几个文件（比如这里以assambley）为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;assembly:
    - assembly.wxml
    - assembly.wxss
    - assembly.js
    - assembly.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在 &lt;code&gt;assembly.wxml&lt;/code&gt;、&lt;code&gt;assembly.wxss&lt;/code&gt;中编写好你的结构与样式代码，在你的JS文件中调用 &lt;code&gt;Component()&lt;/code&gt;构造函数，来实例化一个组件实例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Component({
    //行为
    behaviors:[],
    //数据
    data: {
        names: Math.random()
    },
    //属性
    properties: {
        nowIn: String
    },
    //方法
    methods: {
        showData: function(e) {
            let radomNumber = Math.random();
            this.setData({ names: radomNumber });
            //自定义触发的事件
            this.triggerEvent('assmbleySignal', this.data.names);
        }
    },
    //生命周期函数
    attached: function() {
        this.triggerEvent('assmbleySignal', this.data.names);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在 &lt;code&gt;assembly.json&lt;/code&gt; 中进行组件的声明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;component&quot;:true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一个组件就定义完成了，使用的时候，只需要在用到的页面或者是其它组件中，对它们的配置文件添加以下配置即可（例如这里以index页面为例）&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;#index.json
&quot;usingComponents&quot;: {
    &quot;assembly&quot;: &quot;/pages/component/assembly/assembly&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，在 &lt;code&gt;properties&lt;/code&gt; 中自定义属性的时候要用驼峰命名，但是应用在组件上的时候要记得用小写并且采用 “-” 分割，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;properties:{
    nowIn:String
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre class=&quot;wxml&quot;&gt;
&lt;code&gt;&amp;lt;assembley now-in=&quot;index&quot; bind:assmbleySignal=&quot;onAssmbleySignal&quot;&amp;gt;&amp;lt;/assembly&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS:自定义事件方法 &lt;code&gt;onAssmbleySignal&lt;/code&gt; 在index.js中定义。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component (更多关于组件)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;行为---behaviors&quot;&gt;行为 - Behaviors&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;behaviors&lt;/code&gt;（行为）可以让多个组件之间的“属性”、“数据”、“方法”、“生命周期”实现共享。&lt;br/&gt;并且 &lt;code&gt;behavior&lt;/code&gt; 中还可以引用其它的 &lt;code&gt;behaviors&lt;/code&gt;。 属性会按照先后进行覆盖，而数据虽然也会覆盖，但是如果类型是对象则会进行合并，生命周期函数也会顺序触发，多个组件调用同一个 &lt;code&gt;behaviors&lt;/code&gt; 则生命周期函数也只会执行一次。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;module.exports = Behavior({
  behaviors:[],
  properties: {
    behavior_attr: String
  },
  data: {
    behavior_data: {}
  },
  methods: {
    behavior_method: function() {
      console.log('behavior_method')
    }
  },
  attached: function() {
    console.log('behavior-attached');
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件中调用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var myBehavior = require('./behavior');

Component({
  behaviors: [myBehavior],
  data: {
    names: Math.random()
  },
  properties: {
    nowIn: String
  },
  methods: {
    showData: function(e) {
        console.log('component showData');
    }
  },
  lifetimes: {
    attached: function() {
      console.log('component attached');

    }
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;behaviors&lt;/code&gt; 除了自定义的还有内置的 &lt;code&gt;behaviors&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
var myBehavior = require('./behavior');

Component({
  behaviors: ['wx://form-field'],
  data: {
    names: Math.random()
  },
  properties: {
    nowIn: String
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生命周期函数&quot;&gt;生命周期函数&lt;/h3&gt;
&lt;p&gt;小程序中的生命周期函数主要有以下几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用实例&lt;/li&gt;
&lt;li&gt;页面实例&lt;/li&gt;
&lt;li&gt;组件实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;小程序应用的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;onLuanch&lt;/td&gt;
&lt;td&gt;小程序实例初始化&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;onShow&lt;/td&gt;
&lt;td&gt;小程序启动，或从后台进入前台显示&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;onHide&lt;/td&gt;
&lt;td&gt;小程序隐藏，或从前台进入后台&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;onError&lt;/td&gt;
&lt;td&gt;当小程序发生脚本错误，或者 api 调用失败时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;onPageNotFound&lt;/td&gt;
&lt;td&gt;当小程序出现要打开的页面不存在的情况&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;页面的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;onLoad&lt;/td&gt;
&lt;td&gt;页面资源加载完毕&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;onShow&lt;/td&gt;
&lt;td&gt;页面显示（但不代表页面已经绘制完毕）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;onReady&lt;/td&gt;
&lt;td&gt;页面初次渲染完成&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;onHide&lt;/td&gt;
&lt;td&gt;页面隐藏&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;onUnload&lt;/td&gt;
&lt;td&gt;页面被卸载&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;PS:需要注意的是小程序中tab切换只是多个页面的显示隐藏切换，而不会重新加载，如果使用 &lt;code&gt;navigator&lt;/code&gt;等跳转则每次都会重新加载，显示，渲染。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;created&lt;/td&gt;
&lt;td&gt;创建组件实例，注意此时无法使用 &lt;code&gt;this.setData&lt;/code&gt; 方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;attached&lt;/td&gt;
&lt;td&gt;组件实例进入页面节点树时执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ready&lt;/td&gt;
&lt;td&gt;组件布局完成后执行，此时可以获取节点信息（使用 &lt;code&gt;SelectorQuery&lt;/code&gt; ）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;moved&lt;/td&gt;
&lt;td&gt;组件实例被移动到节点树另一个位置时执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;detached&lt;/td&gt;
&lt;td&gt;组件实例被从页面节点树移除时执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;生命周期函数的默认流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设一个小程序（含有页面，组件）被打开并且正常运行，那么它一般都会经过以下生命周期的改变流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/shenguotao/abdqydkqb6ztdlpc03kbt7og/life.png&quot; alt=&quot;life.png-18.3kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上小程序中还存在另一种生命周期：“行为 &lt;code&gt;Behaviors&lt;/code&gt; 的生命周期，不过其常用的也就 &lt;code&gt;attached&lt;/code&gt;，因此可以再需要的时候自己去查阅文档。&lt;/p&gt;
&lt;h3 id=&quot;作用域&quot;&gt;作用域&lt;/h3&gt;
&lt;p&gt;在小程序中，JS文件，模版文件（动态模板），wxs文件都有自己的独立作用域，模块的导入导出遵循 CommonJS 规范。&lt;/p&gt;
&lt;h3 id=&quot;多页面数据共享&quot;&gt;多页面数据共享&lt;/h3&gt;
&lt;p&gt;如果想实现多页面数据共享或者是跨页面数据交互，可以采用以下方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;app.js 定义 &lt;code&gt;golbalData&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;Storage&lt;/code&gt; 实现&lt;/li&gt;
&lt;li&gt;利用页面传参来实现页面间的数据交互。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;版本库兼容性&quot;&gt;版本库兼容性&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;canIUse&lt;/code&gt; 可以判断小程序的API，回调，参数，组件等是否在当前版本可用。&lt;br/&gt;返回值一般而言都是布尔值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wx.canIUse('openBluetoothAdapter')
wx.canIUse('getSystemInfoSync.return.screenWidth')
wx.canIUse('getSystemInfo.success.screenWidth')
wx.canIUse('showToast.object.image')
wx.canIUse('onCompassChange.callback.direction')
wx.canIUse('request.object.method.GET')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者你也可以基于能力去判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(this.setData) //....&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用户权限&quot;&gt;用户权限&lt;/h3&gt;
&lt;p&gt;开发者通常向用户发起权限授权主要是通过 &lt;code&gt;wx.authorize&lt;/code&gt;这个接口实现，但需要注意的是如果调用的是“用户信息”，则需要使用特定的按钮组件来引导用户操作，单纯的使用 &lt;code&gt;scope:scope.userinfo&lt;/code&gt; 是无法弹出授权弹窗。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button open-type=&quot;getUserInfo&quot;&amp;gt;允许获取个人信息&amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，每个权限都有对应的 API接口可以获取该权限的的状态以及详情，例如：&lt;code&gt;wx.getUserInfo、wx.getLocation&lt;/code&gt;等..&lt;br/&gt;如果想查看全部权限的状态，可以通过另一个 API接口获取当前的权限列表：&lt;code&gt;wx.getSetting&lt;/code&gt;。&lt;br/&gt;对于用户拒绝授权的接口并且短时间无法再次打开，我们可以调用 &lt;code&gt;wx.openSetting&lt;/code&gt; 来让用户自己手动操作。&lt;/p&gt;
&lt;h3 id=&quot;wxs&quot;&gt;WXS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;WXS&lt;/code&gt; 代码可以编写在 WXML 文件中的 标签内，或者保存在以 &lt;code&gt;.wxs&lt;/code&gt; 为后缀的文件里。&lt;br/&gt;&lt;code&gt;WXS&lt;/code&gt; 可以看作成小程序自己定义的一套脚本，它的语法非常类似于原生 JS，但是运行环境并不相同，所以 有些 JS的对象或方法无法使用，也不能调用小程序的 API，其主要目的还是为增强 WXML的模版处理能力。&lt;br/&gt;不论是 WXML中的 wxs内的代码，还是独立的 &lt;code&gt;*.wxs&lt;/code&gt;文件中的代码，它们都有独立的作用域。&lt;br/&gt;实例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;wxs module=&quot;mthodName&quot;&amp;gt;
    function methodName(value){ return value.split(','); }
    module.exports = methodName; //需要导出
&amp;lt;/wxs&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用模块中的方法&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view wx:for=&quot;{{methodName(names)}}&quot;&amp;gt; //names是页面JS中的data配置的。
    &amp;lt;text&amp;gt;{{item}}&amp;lt;/text&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者你可以单独将wxs中的脚本单独的保存在一个文件中，然后使用wxs引入。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;wxs src=&quot;methodName.wxs&quot; module=&quot;methodName&quot;&amp;gt;&amp;lt;/wxs&amp;gt;
&amp;lt;view wx:for=&quot;{{methodName(names)}}&quot;&amp;gt; &amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/ (更多关于WXS)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开源项目参考&quot;&gt;开源项目参考&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;https://github.com/tumobi/nideshop-mini-program (NideShop：基于Node.js+MySQL开发的开源微信小程序商城（微信小程序)&lt;br/&gt;https://github.com/EastWorld/wechat-app-mall (微信小程序商城，微信小程序微店)&lt;br/&gt;https://github.com/ecomfe/echarts-for-weixin (ECharts 的微信小程序版本)&lt;br/&gt;https://github.com/sqaiyan/NeteaseMusicWxMiniApp (仿网易云音乐APP的微信小程序)&lt;br/&gt;https://github.com/zce/weapp-demo (仿豆瓣电影微信小程序)&lt;br/&gt;https://github.com/myvin/juejin (掘金小程序)&lt;br/&gt;https://github.com/xiehui999/SmallAppForQQ (高仿手机QQ应用程序&lt;br/&gt;https&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 25 Aug 2018 18:07:00 +0000</pubDate>
<dc:creator>卷柏的花期</dc:creator>
<og:description>最近工作正好有闲暇时间，根据公司安排先前期学习调研一下“微信小程序”，以供后期解决相关的运营需求，而本篇文章就是我对此次学习的一次总结。 什么是小程序 ？ 如何全面具体的学习？ 注册与新建小程序 认识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HCJJ/p/9536135.html</dc:identifier>
</item>
<item>
<title>Cassandra 数据模型 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/9536116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/9536116.html</guid>
<description>[unable to retrieve full-text content]Cassandra 多层键值对数据结构与ALLOW FILTERING、索引、排序、聚合功能简介</description>
<pubDate>Sat, 25 Aug 2018 17:29:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>Cassandra 多层键值对数据结构与ALLOW FILTERING、索引、排序、聚合功能简介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/9536116.html</dc:identifier>
</item>
<item>
<title>Unity 移动端的复制这么写 - wuzhang</title>
<link>http://www.cnblogs.com/wuzhang/p/wuzhang20180826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuzhang/p/wuzhang20180826.html</guid>
<description>&lt;p&gt;游戏上线很久了，有些玩家慢慢就流失了，为了让刚流失的玩家再度回归所以做了召回功能！如果一个200级的玩家10天没上线且成功召回的，就会给予召回玩家丰厚的奖励！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：那如何召回这个流失的玩家呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：召回肯定得有类似召回码的东东啊，是的。服务器根据玩家ID生成一定位数的字母和数字组合，发给客户端，客户端召回界面显示召回码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：不可能让玩家一个一个在聊天框输入吧？玩家肯定会骂：“什么傻逼设计，老子不玩了，，，”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：玩家是大爷，所以做复制召回吗功能还是很有必要的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如何实现这个功能呢？Unity不支持复制吗？是的，Unity是支持，仅仅支持PC端的，就是这玩意TextEditor！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
TextEditor text = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextEditor();
text.content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GUIContent(yourText);
text.OnFocus();
text.Copy();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么就实现了PC端的复制，那么移动端的怎么做呢，别着急，小伙子，一个一个来，先看看Android是怎么复制的！&lt;/p&gt;
&lt;p&gt;首先创建安卓库工程，在MainActivity里添加这段代码就好，导出jar包在Unity中调用即可，接下来会说Unity里如何去调用！&lt;br/&gt;步骤：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;1. 在Untiy3D项目的Assets目录下创建Plugins目录。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;2. 在Plugins目录下创建Android目录。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;3. 在Android 目录下创建bin目录。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;4. 在bin 目录下放置你编写的类的jar包&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b6b36329-4a52-4be3-a278-948f652a36d5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b6b36329-4a52-4be3-a278-948f652a36d5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b6b36329-4a52-4be3-a278-948f652a36d5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.wuzhang.testandroid;
import com.unity3d.player.UnityPlayer;
import com.unity3d.player.UnityPlayerActivity;
import android.R.&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.app.Service;
import android.content.ClipData;
import android.content.ClipDescription;
import android.content.ClipboardManager;
import android.content.Context;
import android.os.Looper;
import android.support.v4.app.NotificationCompat;
import android.support.v4.content.FileProvider;
import android.view.ContextThemeWrapper;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainActivity extends UnityPlayerActivity {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Vibrator mVibrator01;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个振动器对象  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Context instance;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String TAG = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String gameObgectName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main Camera&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String methodName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OnCoderReturn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ClipboardManager clipboard = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BatteryListener listener;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        instance &lt;/span&gt;=&lt;span&gt; getApplicationContext();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Context getContext()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 向剪贴板中添加文本  
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; copyTextToClipboard(final String str) 
    throws Exception {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Looper.myLooper() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){  
                Looper.prepare();  
            }  
            clipboard &lt;/span&gt;=&lt;span&gt; (ClipboardManager) MainActivity.instance.getSystemService(Activity.CLIPBOARD_SERVICE);  
            ClipData textCd &lt;/span&gt;= ClipData.newPlainText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str);  
            clipboard.setPrimaryClip(textCd);  
    }  
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 从剪贴板中获取文本
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTextFromClipboard() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clipboard != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; clipboard.hasPrimaryClip()
        &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; clipboard.getPrimaryClipDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) {
            ClipData cdText &lt;/span&gt;=&lt;span&gt; clipboard.getPrimaryClip();
            ClipData.Item item &lt;/span&gt;= cdText.getItemAt(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item.getText().toString();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;安卓中如何调用这段代码呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 剪切文本  
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;input&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CopyToClipboard(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; input)
    {
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; UNITY_ANDROID
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对Android的调用  &lt;/span&gt;
        AndroidJavaClass jc = &lt;span&gt;new&lt;/span&gt; AndroidJavaClass(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.unity3d.player.UnityPlayer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        AndroidJavaObject activity &lt;/span&gt;= jc.GetStatic&amp;lt;AndroidJavaObject&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentActivity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (activity == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制到剪贴板  &lt;/span&gt;
        activity.Call(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;copyTextToClipboard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, input);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从剪贴板中获取文本  &lt;/span&gt;
        &lt;span&gt;string&lt;/span&gt; text = activity.Call&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getTextFromClipboard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安卓的好了，接着该是高大上的IOS了，有些人看到IOS就怂了，不知道从哪下手，不知道该怎么去写，完全没概念。不好意思，我和你们也是一样怂，我也是大姑娘上轿，头一回！不要怂，就是干，大不了第一次不会成功，就去调试呗！有这个心态，说明你还是幸运的，我们直接是线上项目，没有时间去调试的，做完时，我心里没一点底啊！超怂的那种，，，后来出iPhone的测试包，没想到一次过了，心里的大石头终于落下了！那我们看看IOS是怎么实现的吧？IOS使用的ObjectC和C语言还是有些类似的，在OC中.h文件是声明，.m文件是实现，所以需要Clipboard.h和Clipboard.mm两个文件！&lt;br/&gt;首先去声明这个Clipboard类,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@ &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Clipboard : NSObject
&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
{
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  compare the namelist with system processes  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
     &lt;span&gt;void&lt;/span&gt; _copyTextToClipboard(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;textList);
}
@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是Clipboard.mm文件，切记千万不要忘记引用 #import &lt;span&gt;&quot;&lt;span&gt;Clipboard.h&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#import&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Clipboard.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
@implementation Clipboard
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将文本复制到IOS剪贴板&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)objc_copyTextToClipboard : (NSString*&lt;span&gt;)text
{
     UIPasteboard &lt;/span&gt;*pasteboard =&lt;span&gt; [UIPasteboard generalPasteboard];
     pasteboard.&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; =&lt;span&gt; text;
}
@end

&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Clipboard *&lt;span&gt;iosClipboard;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; _copyTextToClipboard(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;textList)
    {   
        NSString &lt;/span&gt;*text =&lt;span&gt; [NSString stringWithUTF8String: textList] ;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iosClipboard ==&lt;span&gt; NULL)
        {
            iosClipboard &lt;/span&gt;=&lt;span&gt; [[Clipboard alloc] init];
        }
        [iosClipboard objc_copyTextToClipboard: text];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.h文件和.mm文件需要放在Unity项目的Assets/Plugins/下的任意路径下即可，一般程序员大多数是有洁癖的不放到Assets/Plugins/IOS/文件夹下，心里就是不舒服！再啰嗦两句.m和.mm有什么区别吗？还真有，“.m&quot;中只能编写Object-C代码，而”.mm&quot;中可以编写C代码。所以有 &lt;span&gt;extern &lt;span&gt;&quot;&lt;span&gt;C&lt;span&gt;&quot; 说明我们使用的是C代码！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Unity3D对IOS类的调用&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;1. 在Untiy3D项目的Assets目录下创建Plugins目录。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;2. 在Plugins目录下创建IOS目录。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;3. 在IOS 目录下放置&quot;.h&quot;文件和&quot;.mm&quot;文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;好了，赶紧说怎么调用呢，这会都夜里1点了，再啰嗦就天亮了！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;调用.h声明的函数即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用clipboard.h中的接口  &lt;/span&gt;
&lt;span&gt;_copyTextToClipboard (input);  
Debug.LogError (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CopyToClipboard_______&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+input); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就这么调用就OK了，是不是很失望！这个是所有平台的调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CopyToClipboard(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; input)
    {
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; UNITY_ANDROID
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对Android的调用  &lt;/span&gt;
        AndroidJavaClass jc = &lt;span&gt;new&lt;/span&gt; AndroidJavaClass(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.unity3d.player.UnityPlayer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        AndroidJavaObject activity &lt;/span&gt;= jc.GetStatic&amp;lt;AndroidJavaObject&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentActivity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (activity == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制到剪贴板  &lt;/span&gt;
        activity.Call(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;copyTextToClipboard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, input);
&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; UNITY_IPHONE
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用clipboard.h中的接口  &lt;/span&gt;
&lt;span&gt;        _copyTextToClipboard (input);  
        Debug.LogError (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CopyToClipboard_______&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;input);  
&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; UNITY_EDITOR&lt;span&gt;
        TextEditor te &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextEditor();
        te.content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GUIContent(input);
        te.OnFocus();
        te.Copy();
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，到此写完了，现在感觉熬夜写博客事件很奢侈的事情了，睡觉喽！有问题的小伙伴记得@我，共同交流，下篇写获取手机剩余存储空间的插件！&lt;br/&gt;传送门：&lt;a title=&quot;Unity剪贴板复制&quot; href=&quot;https://gitee.com/wuzhang/UnityCallClipboard.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/wuzhang/UnityCallClipboard.git&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 25 Aug 2018 17:09:00 +0000</pubDate>
<dc:creator>wuzhang</dc:creator>
<og:description>游戏上线很久了，有些玩家慢慢就流失了，为了让刚流失的玩家再度回归所以做了召回功能！如果一个200级的玩家10天没上线且成功召回的，就会给予召回玩家丰厚的奖励！ Q：那如何召回这个流失的玩家呢？ A：召</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuzhang/p/wuzhang20180826.html</dc:identifier>
</item>
<item>
<title>重新解读DDD领域驱动设计(一) - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9535982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9535982.html</guid>
<description>&lt;p&gt;&lt;strong&gt;回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;十年前，还未踏入某校时，便听闻某学长一毕业就入职北京某公司，月薪过万。对于一个名不见经传的小学院，一毕业能拿到这个薪水还是非常厉害的。听闻他学生期间参与开发了一款股票软件，股票那时正迎来一波疯涨。时也运也。我那时心里就想，只会软件也行不通吧，至少要熟悉股票规则。在还未踏入编程大门时，我就清楚的认识了软件服务于业务的本质。&lt;/p&gt;
&lt;p&gt;      等刚开始工作时，从事些较简单的工作，也是需要和使用人员讨论需求，文档编写和开发实现。性质偏向于公司内部财务人员或业务人员管理用的子系统。也许厌烦了写的代码用的人太少，于是转移到了互联网类型的公司。在日益复杂的业务与软件规模下，以前用的熟练的三板斧渐渐适应不了，知识库需要更新了。结合以前的工作实践，按自己的理解，重新解读下领域驱动设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一部分  运用领域模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照一个系统的开发步骤，除了前期招标，合同，预算，人员规划等其他项目管理的范畴外，真正执行到系统部分是从沟通业务需求开始的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一章 消化知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几年前我们要做一个院系资产管理系统，最开始理解的有人申请，管理员审核购买，分发扣库存的逻辑。实际讨论下来之后，分为很多流程。如设备提申请，教务处审批，院系审批，提交财务核账。又涉及到固定资产折旧，退货流程，又要财务核对。又有家具的申请与退货等其他。还有定期的报表功能。基于我们开发人员和校方人员，都对资产审核，退货，对账流程都有一定熟悉度，所以沟通下来业务大框架还算顺利。我理解为我们在沟通业务的过程中，有了相似的认识，并在磨合过程中，修炼完善。DDD一书中，以PCB电路板软件工具为开篇，讲述了PCB专家和开发人员沟通中从最开始的很难沟通，到最后依据流程图及PCB元件执行逻辑完成了语言上的沟通统一。很幸运，我们大部分的业务并没有如文中跨度那么大。&lt;/p&gt;
&lt;p&gt;在沟通的过程中，业务专家需要理解共同构建的业务模型，开发人员也要依据业务模型来勾思大概实现逻辑。就比如设备申请，家具申请,XX申请;设备退货，资产退货。这些有共同性，又有差异的流程，如何更好的抽象，来实现复用？如果单纯开发人员自己抽象得到概念有可能是很幼稚的，开发出来的软件只能做基本工作，无法充分反映领域专家的思考方式。&lt;/p&gt;
&lt;p&gt;领域专家和开发人员共同参与，一起来丰富抽象的模型。提炼模型，对于领域专家来说也是升华自己思考完善自己理解的过程。会更加注重概念的严谨性。&lt;/p&gt;
&lt;p&gt;模型在不断改进的同时，也称为组织项目信息的工具。模型聚焦于需求分析。它与编程和设计紧密交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识丰富的设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举一个判断是否合并账号的逻辑。一个请求中的手机，邮箱账号，根据账号的是否验证，以及数据库中手机号邮箱的是否存在是否验证来判断是否合并账号。产品列举了81条合并规则。&lt;/p&gt;
&lt;p&gt;我最开始想到了策略设计模式。根据各种状态分析出主要的几个策略来实现判断。工作量相当复杂，而且易出错。同事建议了另外一种规则式的实践。对比新账号的状态和筛选中的存在账号状态，形成一个规则，看这个规则符合那81条规则的哪一种。这样代码量指数级下降，也通用。而且其他人也更容易根据产品的文档，直接看懂代码。模型与实现一致。&lt;/p&gt;
&lt;p&gt;书中依据航线超卖为例，举了两个例子，一个是简单的if超卖判断，一个把超卖独立成一个策略类来判断超卖。并强调超卖在模型中不仅仅是一个简单的判断，而是一个让所有人看到代码都明白是一个独特的策略。&lt;/p&gt;
&lt;p&gt;经过以上对比，你会发现设计模式有它自己的适用场景，不要随便套用。第二点设计的模型和代码实现一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深层模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说到太极，外是软绵绵的一套动作。如果按软件直接开发，实现出来的是错的。因为陈家沟的领域专家们会告诉你太极每一招都是制人招。这个我信，如果有人喂招的话，分秒钟被干到地，对付普通人还是有效的。&lt;/p&gt;
&lt;p&gt;这里说的后续的制人招是深层模型，我们看到的慢腾腾的动作是表层。这样说很容易理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二章 交流与语言的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;领域专家和开发人员语言要一致。将模型作为语言的支柱。确保团队在内部的所有交流中以及代码中坚持使用这种语言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书面设计文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文档应作为代码和口头交流的补充&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档和图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用图来沟通交流，能促进头脑风暴。但模型不是图。            &lt;/p&gt;
&lt;p&gt;本篇文章主要是应用自己亲身经历的案例来重新解读领域驱动。&lt;/p&gt;
&lt;p&gt;本篇结束，谢谢观看。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 16:24:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>回顾 十年前，还未踏入某校时，便听闻某学长一毕业就入职北京某公司，月薪过万。对于一个名不见经传的小学院，一毕业能拿到这个薪水还是非常厉害的。听闻他学生期间参与开发了一款股票软件，股票那时正迎来一波疯涨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9535982.html</dc:identifier>
</item>
<item>
<title>跨域&amp;JSONP - binbinlin</title>
<link>http://www.cnblogs.com/linqb/p/9535975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linqb/p/9535975.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;1. 同源&amp;amp;跨域&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;1.1 什么是同源？什么是跨域？&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;同源：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;协议头、域名、端口完全一致就叫同源&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;跨域：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;协议头、域名、端口有一个不一样就叫跨域&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-0.59036144578313&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;判断是否同源，&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;如：&lt;a href=&quot;http://www.example.com/detail.html&quot;&gt;http://www.example.com/detail.html&lt;/a&gt; 与以下地址对比&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;







&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt; &lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;1.2 跨域的影响&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;注：根据同源和跨域的意思，跨域&lt;span&gt;&lt;span&gt;就是指不同源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;如果要在 &lt;span&gt;&lt;code&gt;localhost/test.html&lt;/code&gt; &lt;span&gt;这个网站上访问 &lt;span&gt;&lt;code&gt;http://api.douban.com/v2/movie/top250&lt;/code&gt; &lt;span class=&quot;md-expand&quot;&gt;这个接口，那么浏览器会出现以下错误：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357385/201808/1357385-20180825234350687-1684356519.png&quot; alt=&quot;&quot; width=&quot;905&quot; height=&quot;46&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-expand&quot;&gt;原因：浏览器本身从安全角度考虑，不支持跨域&lt;span&gt;&lt;span&gt;访问&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2. JSONP&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1 如何突破跨域请求限制&lt;/span&gt;&lt;/h4&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1.1 使用img标签（拿不到响应体）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;我们知道：&lt;span&gt;&lt;code&gt;img&lt;/code&gt; &lt;span&gt;标签，有个 &lt;span&gt;&lt;code&gt;href&lt;/code&gt; &lt;span&gt;属性，这个属性其实也是向服务器发送请求，我们看看这种方式是否可以跨越访问，代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://api.douban.com/v2/movie/top250&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时可以看到能正确收到响应，但拿不到响应体（返回的JSON数据），如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357385/201808/1357385-20180825234803165-2145346667.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1.2 使用link标签（拿不到响应体）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;link&lt;/code&gt; &lt;span&gt;标签，有个 &lt;span&gt;&lt;code&gt;src&lt;/code&gt; &lt;span&gt;属性，我们以前是用来外联css样式，其实它也是相当于发送请求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;http://api.douban.com/v2/movie/top250&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;看浏览器响应报文，可以发现link标签也可以跨域请求，但是一样，没办法拿到响应体&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1.3 使用script标签（曲线拿到响应体）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(json) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我被调用了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        console.log(json);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://api.douban.com/v2/movie/top250?callback=test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357385/201808/1357385-20180825235359299-1027015381.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 说明：我们可以看到，我们预先定义了一个函数叫test，再然后在src里加了一个参数callback=test，可以发现，当请求完成，会自动调用test这个函数，并且把响应体（JSON数据）当做参数传递过来&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.2 使用script标签拿到JSON数据&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.2.1 script导入外部文件作用&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
alert('你好');
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-expand&quot;&gt;新建 &lt;span&gt;&lt;code&gt;index.html&lt;/code&gt; &lt;span&gt;文件，核心代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;1.txt&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357385/201808/1357385-20180825235742360-119990391.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;99&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结论：script导入文件会默认把文件内容当JS代码执行，跟文件格式无关&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.2.2 script标签曲线拿到响应体原理&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;新建 &lt;span&gt;&lt;code&gt;index.html&lt;/code&gt; &lt;span&gt;页面，代码如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个success函数&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; success(obj){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        console.log(obj);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; script导入文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://www.demo.com/top250.php&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-expand&quot;&gt;新建 &lt;span&gt;&lt;code&gt;top250.php&lt;/code&gt; &lt;span&gt;页面，代码如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; &quot;success('hello')&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357385/201808/1357385-20180826000045710-559968131.png&quot; alt=&quot;&quot; width=&quot;125&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：请求的top250文件里，服务器最终返回的是 success('hello'); 这个当JS代码执行时，是调用函数并传递参数hello的语法，因此可以看到success函数被调用，并且打印了参数hello&lt;/p&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357385/201808/1357385-20180826000155446-382591482.png&quot; alt=&quot;&quot; width=&quot;733&quot; height=&quot;494&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;★★ 思考：如果在上例中，把success函数的参数换成json对象，会怎样？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;修改 &lt;span&gt;&lt;code&gt;top250.php&lt;/code&gt; &lt;span&gt;代码，如下:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;$data&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;('name' =&amp;gt; 'jack','age'=&amp;gt;16,'gender'=&amp;gt;'true'&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;$json&lt;/span&gt; = json_encode(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &quot;success({&lt;span&gt;$json&lt;/span&gt;})&quot;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;再次访问网页可以发现，打印的参数就变成了json对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357385/201808/1357385-20180826000453354-1411327301.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;82&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;结论：script标签拿到JSON数据的原理就是在服务器端写调用浏览器端函数的方法&lt;span&gt;&lt;span&gt; ，然后把JSON数据当参数传递过去&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span&gt;&lt;span&gt;★★ 思考：现在服务端代码这么写，如果要解决跨域问题，是不是每个浏览器端都要准备一个名叫success的函数？能让浏览器端自己指定吗？怎么指定？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;md-expand&quot;&gt;请求数据时加参数，修改 &lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;index.html&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明函数&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; myFunc(obj){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        console.log(obj);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 请求数据，并加入callback参数，值为myFunc &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://www.demo.com/top250.php?callback=myFunc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;md-expand&quot;&gt;此时，除了请求 &lt;span&gt;&lt;code&gt;top250.php&lt;/code&gt; &lt;span&gt;外，还传递了个 &lt;span&gt;&lt;code&gt;callback&lt;/code&gt; &lt;span&gt;的参数过去，修改 &lt;span&gt;&lt;code&gt;top250.php&lt;/code&gt;&lt;span&gt;，拿到这个参数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到传递过来的参数，即函数名&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;$funcName&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;['callback'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备数据&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;$data&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;('name' =&amp;gt; 'jack','age'=&amp;gt;16,'gender'=&amp;gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转化为JSON&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;$json&lt;/span&gt; = json_encode(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传过来的是什么函数名，就调用什么函数&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &quot;&lt;span&gt;$funcName&lt;/span&gt;(&lt;span&gt;$json&lt;/span&gt;)&quot;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; ?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;结果：此时就完成了指定函数名让服务器调用传参的效果了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;这就是之前跨域拿数据的原理，即服务器端调用浏览器端的函数，把参数传递过来即可&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.3 JSONP概念总结&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2.2687861271676&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot;&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span&gt;JSONP：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;它不是一套新技术，只是聪明的程序员想出的一套方案&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;能不能用这套方案，要看服务器端代码怎么写，服务器端如果写了调用函数的代码，那么就能支持JSONP方案&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;以后服务器的接口会有接口文档进行说明是否支持JSONP&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0.65467625899281&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;建议：不要随意使用别人的接口，特别是别人写的支持JSONP的接口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;例:&lt;span&gt;&lt;a href=&quot;https://developers.douban.com/wiki/?title=api_v2&quot;&gt;https://developers.douban.com/wiki/?title=api_v2&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3. CORS&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 允许远端访问&lt;/span&gt;
&lt;span&gt;header&lt;/span&gt;('Access-Control-Allow-Origin: *');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;这种方案无需客户端作出任何变化（客户端不用改代码），只是在服务端添加一个 &lt;span&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;span&gt;的响应头，表示这个资源是否允许指定域请求（*代表任何网站都可以访问）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 16:21:00 +0000</pubDate>
<dc:creator>binbinlin</dc:creator>
<og:description>1. 同源&amp;跨域 1.1 什么是同源？什么是跨域？ 同源：协议头、域名、端口完全一致就叫同源 跨域：协议头、域名、端口有一个不一样就叫跨域 判断是否同源，如：http://www.exampl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linqb/p/9535975.html</dc:identifier>
</item>
<item>
<title>逻辑回归实例 - Jin_liang</title>
<link>http://www.cnblogs.com/jin-liang/p/9534801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jin-liang/p/9534801.html</guid>
<description>&lt;p&gt;　　简介&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Logistic回归是一种机器学习分类算法，用于预测分类因变量的概率。 在逻辑回归中，因变量是一个二进制变量，包含编码为1（是，成功等）或0（不，失败等）的数据。 换句话说，逻辑回归模型预测P（Y = 1）是X的函数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　该数据集来自&lt;a href=&quot;http://archive.ics.uci.edu/ml/index.php&quot; target=&quot;_blank&quot;&gt;UCI机器学习库&lt;/a&gt;，它与葡萄牙银行机构的直接营销活动（电话）有关。 分类目标是预测客户是否将购买定期存款（变量y）。 数据集可以从&lt;a href=&quot;https://raw.githubusercontent.com/madmashup/targeted-marketing-predictive-engine/master/banking.csv&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;下载或者&lt;a href=&quot;http://archive.ics.uci.edu/ml/machine-learning-databases/00222/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; preprocessing
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt 
plt.rc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;font&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, size=14&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LogisticRegression
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.cross_validation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; seaborn as sns
sns.set(style&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
sns.set(style&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;whitegrid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, color_codes=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
data=pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:/wd.jupyter/datasets/log_data/bank.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
data&lt;/span&gt;=&lt;span&gt;data.dropna()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data.shape)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list(data.columns))

data.head()&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
(41188, 21)
['age', 'job', 'marital', 'education', 'default', 'housing', 'loan', 'contact', 'month', 'day_of_week', 'duration', 'campaign', 'pdays', 'previous', 'poutcome', 'emp.var.rate', 'cons.price.idx', 'cons.conf.idx', 'euribor3m', 'nr.employed', 'y']
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　数据集提供银行客户的信息。 它包括41,188条记录和21个字段。&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;span&gt;age (numeric)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;job : type of job (categorical: “admin”, “blue-collar”, “entrepreneur”, “housemaid”, “management”, “retired”, “self-employed”, “services”, “student”, “technician”, “unemployed”, “unknown”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;marital : marital status (categorical: “divorced”, “married”, “single”, “unknown”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;education (categorical: “basic.4y”, “basic.6y”, “basic.9y”, “high.school”, “illiterate”, “professional.course”, “university.degree”, “unknown”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;default: has credit in default? (categorical: “no”, “yes”, “unknown”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;housing: has housing loan? (categorical: “no”, “yes”, “unknown”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;loan: has personal loan? (categorical: “no”, “yes”, “unknown”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;contact: contact communication type (categorical: “cellular”, “telephone”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;month: last contact month of year (categorical: “jan”, “feb”, “mar”, …, “nov”, “dec”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;day_of_week: last contact day of the week (categorical: “mon”, “tue”, “wed”, “thu”, “fri”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;duration: last contact duration, in seconds (numeric). Important note: this attribute highly affects the output target (e.g., if duration=0 then y=’no’). The duration is not known before a call is performed, also, after the end of the call, y is obviously known. Thus, this input should only be included for benchmark purposes and should be discarded if the intention is to have a realistic predictive model&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;campaign: number of contacts performed during this campaign and for this client (numeric, includes last contact)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;pdays: number of days that passed by after the client was last contacted from a previous campaign (numeric; 999 means client was not previously contacted)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;previous: number of contacts performed before this campaign and for this client (numeric)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;poutcome: outcome of the previous marketing campaign (categorical: “failure”, “nonexistent”, “success”)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;emp.var.rate: employment variation rate — (numeric)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;cons.price.idx: consumer price index — (numeric)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;cons.conf.idx: consumer confidence index — (numeric)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;euribor3m: euribor 3 month rate — (numeric)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;nr.employed: number of employees — (numeric)&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;　　y - 客户是否订购了定期存款？ （二进制：“1”表示“是”，“0”表示“否”）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数据集的教育列有许多类别，我们需要减少类别以获得更好的建模。 教育专栏有以下几类：&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].unique()&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
array(['basic.4y', 'high.school', 'basic.6y', 'basic.9y',
       'professional.course', 'unknown', 'university.degree',
       'illiterate'], dtype=object)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　让我们将“basic.4y”，“basic.9y”和“basic.6y”组合在一起，称之为“basic”。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=np.where(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;basic.4y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;basic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=np.where(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;basic.6y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;basic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=np.where(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;basic.9y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;basic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].unique()&lt;/pre&gt;
&lt;pre&gt;
array(['basic', 'high.school', 'professional.course', 'unknown',
       'university.degree', 'illiterate'], dtype=object)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果不懂np.where函数，可以看&lt;a href=&quot;https://blog.csdn.net/oh5W6HinUg43JvRhhB/article/details/80796594&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　信息总览&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data.info()

&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pandas.core.frame.DataFrame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
Int64Index: &lt;/span&gt;41188 entries, 0 to 41187&lt;span&gt;
Data columns (total &lt;/span&gt;21&lt;span&gt; columns):
age               &lt;/span&gt;41188 non-&lt;span&gt;null int64
job               &lt;/span&gt;41188 non-&lt;span&gt;null object
marital           &lt;/span&gt;41188 non-&lt;span&gt;null object
education         &lt;/span&gt;41188 non-&lt;span&gt;null object
default           &lt;/span&gt;41188 non-&lt;span&gt;null object
housing           &lt;/span&gt;41188 non-&lt;span&gt;null object
loan              &lt;/span&gt;41188 non-&lt;span&gt;null object
contact           &lt;/span&gt;41188 non-&lt;span&gt;null object
month             &lt;/span&gt;41188 non-&lt;span&gt;null object
day_of_week       &lt;/span&gt;41188 non-&lt;span&gt;null object
duration          &lt;/span&gt;41188 non-&lt;span&gt;null int64
campaign          &lt;/span&gt;41188 non-&lt;span&gt;null int64
pdays             &lt;/span&gt;41188 non-&lt;span&gt;null int64
previous          &lt;/span&gt;41188 non-&lt;span&gt;null int64
poutcome          &lt;/span&gt;41188 non-&lt;span&gt;null object
emp.var.rate      &lt;/span&gt;41188 non-&lt;span&gt;null float64
cons.price.idx    &lt;/span&gt;41188 non-&lt;span&gt;null float64
cons.conf.idx     &lt;/span&gt;41188 non-&lt;span&gt;null float64
euribor3m         &lt;/span&gt;41188 non-&lt;span&gt;null float64
nr.employed       &lt;/span&gt;41188 non-&lt;span&gt;null float64
y                 &lt;/span&gt;41188 non-&lt;span&gt;null object
dtypes: float64(&lt;/span&gt;5), int64(5), object(11&lt;span&gt;)
memory usage: &lt;/span&gt;6.9+ MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，有5列float64数据，有5列int64数据，有11列object。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　把y变为数值型，并进行简单的统计。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
data.loc[data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=1&lt;span&gt;
data.loc[data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;0
data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].value_counts()

0    &lt;/span&gt;36548
1     4640&lt;span&gt;
Name: y, dtype: int64

sns.countplot(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data=data,palette=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825204232064-1543090140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因变量中有36548个没有，4640个是。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　让我们深入了解这两个类别&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
data.groupby(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).mean()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825213846144-249044219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　购买定期存款的客户的平均年龄高于未购买定期存款的客户的平均年龄。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　对于购买它的客户来说，pdays（自上次联系客户以来的日子）可以理解的更低。 pdays越低，最后一次通话的记忆越好，因此销售的机会就越大。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　令人惊讶的是，购买定期存款的客户的广告系列（compaign当前广告系列期间的联系人或通话次数）较低。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　我们可以计算其他分类变量（如教育和婚姻状况）的分类方法，以更详细地了解我们的数据。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
data.groupby(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).mean()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825213926492-1743264549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
data.groupby(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;marital&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).mean() 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　工作和y的关系&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pd.crosstab(data.job,data.y).plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Purchase Frequency for Job Title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency of Purchase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;plt.savefig('purchase_fre_job')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825214717876-539586728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;购买存款的频率在很大程度上取决于职位。 因此，职称可以是结果变量的良好预测因子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　婚姻状况与y的关系：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
table=&lt;span&gt;pd.crosstab(data.marital,data.y)
table.div(table.sum(axis&lt;/span&gt;=1).astype(float), axis=0).plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, stacked=&lt;span&gt;True)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Stacked Bar Chart of Marital Status vs Purchase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Marital Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Proportion of Customers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825215731368-1017578837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;婚姻状况似乎不是结果变量的强预测因子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;教育情况与y的关系&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
table=&lt;span&gt;pd.crosstab(data.education,data.y)
table.div(table.sum(axis&lt;/span&gt;=1).astype(float),axis=0).plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Stacked Bar Chart of Education Status vs Purchase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Education Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Proportion of Customers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825220528585-1316062876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;教育似乎是良好预测指标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;day_of_week与y的关系：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pd.crosstab(data.day_of_week,data.y).plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Purchase Frequency for Day of Week&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Day of Week&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency of Purchase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.savefig(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pur_dayofweek_bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825220806093-1763696035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Day of week 或许不是一个良好的预测指标。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　　month与y的关系&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pd.crosstab(data.month,data.y).plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Purchase Frequency for Month&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Month&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency of Purchase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.savefig(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pur_fre_month_bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825221006569-1095500901.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Month是一个良好的预测指标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　年龄的分布：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data.age.hist()
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Histogram of Age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825221113591-1912033134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该数据集中银行的大多数客户的年龄范围为30-40。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;poutcome与y的关系：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pd.crosstab(data.poutcome,data.y).plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Purchase Frequency for Poutcome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Poutcome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency of Purchase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825221231549-537528436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;poutcome是一个良好的预测指标。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　这是只有两个值的变量，0和1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　回顾我们数据集的信息，有11个object，其中y已经转化过来，另外有10个类别需要转化。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
cat_vars=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;marital&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;housing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;contact&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;month&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day_of_week&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;poutcome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cat_vars:
    cat_list&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;var
    cat_list &lt;/span&gt;= pd.get_dummies(data[var], prefix=&lt;span&gt;var)
    data1&lt;/span&gt;=&lt;span&gt;data.join(cat_list)
    data&lt;/span&gt;=&lt;span&gt;data1
    

data_vars&lt;/span&gt;=&lt;span&gt;data.columns.values.tolist()
to_keep&lt;/span&gt;=[i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; data_vars &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cat_vars]


data_final&lt;/span&gt;=&lt;span&gt;data[to_keep]
data_final.columns.values&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 最终的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825222928281-802207703.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　分离特征与目标变量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
data_final_vars=&lt;span&gt;data_final.columns.values.tolist()
y&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
X&lt;/span&gt;=[i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; data_final_vars &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; y]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　 &lt;span&gt;&lt;strong&gt;特征选择&lt;/strong&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　递归特征消除（&lt;a class=&quot;markup--anchor markup--p-anchor&quot; href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot; data-href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html&quot;&gt;Recursive Feature Elimination&lt;/a&gt;，RFE）基于以下思想：&lt;/span&gt;&lt;span&gt; 首先，在初始特征集上训练估计器，并且通过coef_属性或通过feature_importances_属性获得每个特征的重要性。 然后，从当前的一组特征中删除最不重要的特征。 在修剪的集合上递归地重复该过程，直到最终到达所需数量的要选择的特征。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datasets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.feature_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RFE
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LogisticRegression
logreg &lt;/span&gt;=&lt;span&gt; LogisticRegression()
rfe &lt;/span&gt;= RFE(logreg, 18&lt;span&gt;)
rfe &lt;/span&gt;=&lt;span&gt; rfe.fit(data_final[X], data_final[y] )
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(rfe.support_)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(rfe.ranking_)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825223931651-230159980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据布尔值筛选我们想要的特征(&lt;a href=&quot;http://codewenda.com/%E6%A0%B9%E6%8D%AE%E5%B8%83%E5%B0%94%E5%80%BC%E5%88%97%E8%A1%A8%E8%BF%87%E6%BB%A4%E5%88%97%E8%A1%A8/&quot; target=&quot;_blank&quot;&gt;参考&lt;/a&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; itertools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; compress

cols&lt;/span&gt;=&lt;span&gt;list(compress(X,rfe.support_))
cols

或者：
cols&lt;/span&gt;= [i &lt;span&gt;for&lt;/span&gt; index,i &lt;span&gt;in&lt;/span&gt; list(enumerate(X)) &lt;span&gt;if&lt;/span&gt; rfe.support_[index] == True]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; statsmodels.api as sm

X&lt;/span&gt;=&lt;span&gt;data_final[cols]
y&lt;/span&gt;=data_final[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]


logit_model&lt;/span&gt;=&lt;span&gt;sm.Logit(y,X)
logit_model.raise_on_perfect_prediction &lt;/span&gt;=&lt;span&gt; False
result&lt;/span&gt;=&lt;span&gt;logit_model.fit()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result.summary().as_text)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825231044854-1845698612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大多数变量的p值小于0.05，因此，大多数变量对模型都很重要。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LogisticRegression
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; metrics

X_train, X_test, y_train, y_test &lt;/span&gt;= train_test_split(X, y, test_size=0.3, random_state=&lt;span&gt;0)
logreg &lt;/span&gt;=&lt;span&gt; LogisticRegression()
logreg.fit(X_train, y_train)
y_pred &lt;/span&gt;=&lt;span&gt; logreg.predict(X_test)
y_pred &lt;/span&gt;=&lt;span&gt; logreg.predict(X_test)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accuracy of logistic regression classifier on test set: {:.2f}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(logreg.score(X_test, y_test))) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，准确率达到了0.9.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　交叉验证尝试避免过度拟合，同时仍然为每个观察数据集生成预测。 我们使用10折交叉验证来训练我们的Logistic回归模型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; model_selection
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cross_val_score

kfold &lt;/span&gt;= model_selection.KFold(n_splits=10, random_state=7&lt;span&gt;)
modelCV &lt;/span&gt;=&lt;span&gt; LogisticRegression()
scoring &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
results &lt;/span&gt;= model_selection.cross_val_score(modelCV, X_train, y_train, cv=kfold, scoring=&lt;span&gt;scoring)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10-fold cross validation average accuracy: %.3f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (results.mean()))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825231827171-313423865.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平均精度仍然非常接近Logistic回归模型的准确度; 因此，我们可以得出结论，我们的模型很好拟合了数据。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; confusion_matrix

confusion_matrix &lt;/span&gt;=&lt;span&gt; confusion_matrix(y_test, y_pred)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(confusion_matrix)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825231937194-1175469904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果告诉我们，我们有10848 + 2564个正确预测和1124 + 121个错误预测。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;精度是比率tp /（tp + fp），其中tp是真阳性的数量，fp是假阳性的数量。 精确度直观地是分类器如果是负的则不将样品标记为阳性的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;召回是比率tp /（tp + fn）其中tp是真阳性的数量，fn是假阴性的数量。 召回直观地是分类器找到所有阳性样本的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;F-beta分数可以解释为精确度和召回率的加权调和平均值，其中F-β分数在1处达到其最佳值，在0处达到最差分数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;F-beta评分对召回的重量超过精确度β因子。 beta = 1.0意味着召回和精确度同样重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持是y_test中每个类的出现次数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; classification_report

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(classification_report(y_test, y_pred))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825232517831-1025683588.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出：在整个测试集中，88％的促销定期存款是客户喜欢的定期存款。 在整个测试集中，90％的客户首选定期存款。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Macro F1 Score&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; f1_score

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f1_score(y_test, y_pred, average = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;macro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
0.6217653450907061
&lt;/pre&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; roc_auc_score
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; roc_curve

logit_roc_auc &lt;/span&gt;=&lt;span&gt; roc_auc_score(y_test, logreg.predict(X_test))
fpr, tpr, thresholds &lt;/span&gt;= roc_curve(y_test, logreg.predict_proba(X_test)[:,1&lt;span&gt;])
plt.figure()
plt.plot(fpr, tpr, label&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Logistic Regression (area = %0.2f)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; logit_roc_auc)
plt.plot([0, &lt;/span&gt;1], [0, 1],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlim([&lt;/span&gt;0.0, 1.0&lt;span&gt;])
plt.ylim([&lt;/span&gt;0.0, 1.05&lt;span&gt;])
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;False Positive Rate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True Positive Rate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Receiver operating characteristic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.legend(loc&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lower right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;plt.savefig('Log_ROC')&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201808/1345004-20180825233342766-2073548060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ROC曲线是与二元分类器一起使用的另一种常用工具。 虚线表示纯随机分类器的ROC曲线; 一个好的分类器尽可能远离该线（朝左上角）。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 15:53:00 +0000</pubDate>
<dc:creator>Jin_liang</dc:creator>
<og:description>简介 Logistic回归是一种机器学习分类算法，用于预测分类因变量的概率。 在逻辑回归中，因变量是一个二进制变量，包含编码为1（是，成功等）或0（不，失败等）的数据。 换句话说，逻辑回归模型预测P（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jin-liang/p/9534801.html</dc:identifier>
</item>
<item>
<title>SpringBoot | 第二十五章：日志管理之自定义Appender - oKong_趔趄的猿</title>
<link>http://www.cnblogs.com/okong/p/springboot-twenty-five.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okong/p/springboot-twenty-five.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前面两章节我们介绍了一些日志框架的常见配置及使用实践。一般上，在开发过程中，像&lt;code&gt;log4j2&lt;/code&gt;、&lt;code&gt;logback&lt;/code&gt;日志框架都提供了很多&lt;code&gt;Appender&lt;/code&gt;，基本上可以满足大部分的业务需求了。但在一些特殊需求或者需要将日志进行集中管理(集群部署时，日志是分拆到不同服务器上的，不可能去每一台服务器上去下载文件的，也不便于日志检索)时，就需要自定义&lt;code&gt;Appender&lt;/code&gt;，将日志集中输出或者其他一些特殊需求。所以本章节就来简单介绍下关于&lt;code&gt;log4j2&lt;/code&gt;和&lt;code&gt;logback&lt;/code&gt;的自定义&lt;code&gt;Appender&lt;/code&gt;知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一点知识&quot;&gt;一点知识&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;编写自定义&lt;code&gt;Appender&lt;/code&gt;时，我们先来看看&lt;code&gt;log4j2&lt;/code&gt;和&lt;code&gt;logback&lt;/code&gt;自带了哪些&lt;code&gt;Appender&lt;/code&gt;，了解下是否可以满足我们的个性化需求，避免重复制造轮子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;log4j2自带appender&quot;&gt;log4j2自带Appender&lt;/h3&gt;
&lt;p&gt;先看一张&lt;a href=&quot;http://logging.apache.org/log4j/2.x/manual/appenders.html&quot; title=&quot;官网&quot;&gt;官网&lt;/a&gt;提供的&lt;code&gt;Appender&lt;/code&gt;说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/3966315.jpg&quot; alt=&quot;官方Appender&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;20&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AsyncAppender&lt;/td&gt;
&lt;td&gt;使用一个单独线程记录日志，实现异步处理日志事件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CassandraAppender&lt;/td&gt;
&lt;td&gt;将日志信息输出到一个Apache的Cassandra数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ConsoleAppender&lt;/td&gt;
&lt;td&gt;将日志信息输出到控制台&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FailoverAppender&lt;/td&gt;
&lt;td&gt;包含其他appenders，按顺序尝试，直至成功或结尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FileAppender&lt;/td&gt;
&lt;td&gt;一个OutputStreamAppender，将日志输出到文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FlumeAppender&lt;/td&gt;
&lt;td&gt;将日志输出到Apache Flume系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;JDBCAppender&lt;/td&gt;
&lt;td&gt;将日志通过JDBC输出到关系型数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;JMS Appender&lt;/td&gt;
&lt;td&gt;将日志输出到JMS（Java Message Service）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;JPAAppender&lt;/td&gt;
&lt;td&gt;将日志输出到JPA框架&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;HttpAppender&lt;/td&gt;
&lt;td&gt;通过HTTP输出日志&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;KafkaAppender&lt;/td&gt;
&lt;td&gt;将日志输出到Apache Kafka&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;MemoryMappedFileAppender&lt;/td&gt;
&lt;td&gt;将日志输出到一块文件关联的内存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;OutputStreamAppender&lt;/td&gt;
&lt;td&gt;将日志输出到一个OutputStream&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RandomAccessFileAppender&lt;/td&gt;
&lt;td&gt;性能比FileAppender高20%~200%的文件输出Appender&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RewriteAppender&lt;/td&gt;
&lt;td&gt;允许对日志信息进行加工&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RollingFileAppender&lt;/td&gt;
&lt;td&gt;按log文件最大长度限度生成新文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RollingRandomAccessFA&lt;/td&gt;
&lt;td&gt;添加了缓存的RollingFileAppender&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RoutingAppender&lt;/td&gt;
&lt;td&gt;将日志事件分类，按条件分配给子appender&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SMTPAppender&lt;/td&gt;
&lt;td&gt;将日志输出到邮件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SocketAppender&lt;/td&gt;
&lt;td&gt;将日志输出到一个Socket&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SyslogAppender&lt;/td&gt;
&lt;td&gt;是一个SocketAppender，将日志输出到远程系统日志&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ZeroMQ/JeroMQ Appender&lt;/td&gt;
&lt;td&gt;使用JeroMQ库将日志输出到ZeroMQ终端&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;基本上已经覆盖了百分之九十的业务场景了。相关的详细说明或者配置大家自行搜索或者查看官网说明。&lt;br/&gt;官网地址：&lt;a href=&quot;http://logging.apache.org/log4j/2.x/manual/appenders.html&quot; class=&quot;uri&quot; title=&quot;http://logging.apache.org/log4j/2.x/manual/appenders.html&quot;&gt;http://logging.apache.org/log4j/2.x/manual/appenders.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;logback自带appender&quot;&gt;logback自带Appender&lt;/h3&gt;
&lt;p&gt;和&lt;code&gt;log4j2&lt;/code&gt;一样，自带的都差不多了。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ConsoleAppender&lt;/td&gt;
&lt;td&gt;将日志输出到控制台&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;FileAppender&lt;/td&gt;
&lt;td&gt;将日志输出到文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RollingFileAppender&lt;/td&gt;
&lt;td&gt;滚动文件生成，按条件生成不同文件，配合TriggeringPolicy使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SocketAppender&lt;/td&gt;
&lt;td&gt;输出日志到远程实例中，明文传输&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SSLSocketAppender&lt;/td&gt;
&lt;td&gt;输出日志到远程实例中，密文传输&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SMTPAppender&lt;/td&gt;
&lt;td&gt;将日志输出到邮件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DBAppender&lt;/td&gt;
&lt;td&gt;日志事件插入数据库中，需要提前创建表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SyslogAppender&lt;/td&gt;
&lt;td&gt;是一个SocketAppender，将日志输出到远程系统日志&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SiftingAppender&lt;/td&gt;
&lt;td&gt;可基于任何给定的实时属性分开（或者筛选）日志，如基于用户会话分开日志事件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AmqpAppender&lt;/td&gt;
&lt;td&gt;将日志输出到MQ服务中&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;具体可查看：&lt;a href=&quot;https://blog.csdn.net/tianyaleixiaowu/article/details/73327752&quot; class=&quot;uri&quot; title=&quot;https://blog.csdn.net/tianyaleixiaowu/article/details/73327752&quot;&gt;https://blog.csdn.net/tianyaleixiaowu/article/details/73327752&lt;/a&gt; 很详细！&lt;/p&gt;
&lt;p&gt;或者查看官网：&lt;a href=&quot;https://logback.qos.ch/manual/appenders.html&quot; class=&quot;uri&quot; title=&quot;https://logback.qos.ch/manual/appenders.html&quot;&gt;https://logback.qos.ch/manual/appenders.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义appender&quot;&gt;自定义Appender&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;自定义&lt;code&gt;Appender&lt;/code&gt;时，可以按实现的功能，适当的继承(&lt;code&gt;log4j2&lt;/code&gt;的&lt;code&gt;appender&lt;/code&gt;类基本上被设置成了&lt;code&gt;final&lt;/code&gt;无法继承)或者参考一些已有的功能，当然了也可以直接继承其基类接口的。以下就简单的示例下，没有实现特定的功能，⊙﹏⊙‖∣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;log4j2自定义appender&quot;&gt;log4j2自定义Appender&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;按官网的扩展说明，我们来简单实现一个appender。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/17214462.jpg&quot; alt=&quot;extend appender&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;http://logging.apache.org/log4j/2.x/manual/extending.html#Appenders&quot; class=&quot;uri&quot; title=&quot;http://logging.apache.org/log4j/2.x/manual/extending.html#Appenders&quot;&gt;http://logging.apache.org/log4j/2.x/manual/extending.html#Appenders&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;0.编写自定义appender类，继承&lt;code&gt;AbstractAppender&lt;/code&gt;抽象实现类：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyLog4j2Appender.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 自定义log4j2输出源，简单的输出到控制台
 * @author oKong
 *
 */
//这里的 MyLog4j2 对应就是 xml中，
/**
 * 
 *  &amp;lt;appenders&amp;gt;
 *     &amp;lt;MyLog4j2 name=&quot;customAppender&quot; printString=&quot;一枚趔趄的猿&quot;&amp;gt;
 *     &amp;lt;/MyLog4j2&amp;gt;
 *  &amp;lt;/appenders&amp;gt;
 *
 */
@Plugin(name = &quot;MyLog4j2&quot;, category = &quot;Core&quot;, elementType = &quot;appender&quot;, printObject = true)
public class MyLog4j2Appender extends AbstractAppender {

    String printString;
   /**  
     *构造函数 可自定义参数 这里直接传入一个常量并输出
     * 
    */ 
    protected MyLog4j2Appender(String name, Filter filter, Layout&amp;lt;? extends Serializable&amp;gt; layout,String printString) {
        super(name, filter, layout);
        this.printString = printString;
    }

    @Override
    public void append(LogEvent event) {
         if (event != null &amp;amp;&amp;amp; event.getMessage() != null) {
             // 此处自定义实现输出             
             // 获取输出值：event.getMessage().toString()
             // System.out.print(event.getMessage().toString());
             // 格式化输出
             System.out.print(printString + &quot;：&quot; + getLayout().toSerializable(event));
          }
        
    }
    
    /**  接收配置文件中的参数 
     * 
     * @PluginAttribute 字面意思都知道，是xml节点的attribute值，如&amp;lt;oKong name=&quot;oKong&quot;&amp;gt;&amp;lt;/oKong&amp;gt; 这里的name 就是 attribute
     * @PluginElement：表示xml子节点的元素，
     * 如
     *     &amp;lt;oKong name=&quot;oKong&quot;&amp;gt;
     *         &amp;lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n&quot;/&amp;gt;
     *     &amp;lt;/oKong&amp;gt;
     *   其中，PatternLayout就是 的 Layout，其实就是{@link Layout}的实现类。
     */ 
    @PluginFactory
    public static MyLog4j2Appender createAppender(
            @PluginAttribute(&quot;name&quot;) String name,
            @PluginElement(&quot;Filter&quot;) final Filter filter, 
            @PluginElement(&quot;Layout&quot;) Layout&amp;lt;? extends Serializable&amp;gt; layout,
            @PluginAttribute(&quot;printString&quot;) String printString) {
        
        if (name == null) {
            LOGGER.error(&quot;no name defined in conf.&quot;); 
            return null; 
        } 
        //默认使用 PatternLayout
        if (layout == null) { 
            layout = PatternLayout.createDefaultLayout(); 
        } 
        
        return new MyLog4j2Appender(name, filter, layout, printString);
    }
    
    @Override
    public void start() {
        System.out.println(&quot;log4j2-start方法被调用&quot;);
        super.start();
    }
    
    @Override
    public void stop() {
        System.out.println(&quot;log4j2-stop方法被调用&quot;);
        super.stop();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单说明下，相关注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Plugin&lt;/code&gt;注解：这个注解，是为了在之后配置&lt;code&gt;log4j2-spring.xml&lt;/code&gt;时，指定的Appender Tag。&lt;/li&gt;
&lt;li&gt;构造函数：除了使用父类的以外，也可以增加一些自己的配置。&lt;/li&gt;
&lt;li&gt;重写&lt;code&gt;append()&lt;/code&gt;方法：这里面需要实现具体的逻辑，日志的去向。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createAppender()&lt;/code&gt;方法：主要是接收&lt;code&gt;log4j2-spring.xml&lt;/code&gt;中的配置项。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.使用自定义的appender。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;log4j2-spring.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
 &amp;lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot; packages=&quot;cn.lqdev.learning&quot;&amp;gt;
     &amp;lt;!--定义appenders--&amp;gt;
     &amp;lt;appenders&amp;gt;
         &amp;lt;MyLog4j2 name=&quot;oKong&quot; printString=&quot;一枚趔趄的猿(log4j2)&quot;&amp;gt;
            &amp;lt;!--输出日志的格式--&amp;gt;
             &amp;lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n&quot;/&amp;gt;
         &amp;lt;/MyLog4j2&amp;gt;
     &amp;lt;/appenders&amp;gt;
     &amp;lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&amp;gt;
     &amp;lt;loggers&amp;gt;
         &amp;lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&amp;gt;
         &amp;lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&amp;gt;&amp;lt;/logger&amp;gt;
         &amp;lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&amp;gt;&amp;lt;/logger&amp;gt;
         &amp;lt;!-- 自定义包下设置为INFO,则可以看见输出的日志不包含debug输出了 --&amp;gt;
         &amp;lt;logger name=&quot;cn.lqdev.learning&quot; level=&quot;INFO&quot;/&amp;gt;
         &amp;lt;root level=&quot;all&quot;&amp;gt;
             &amp;lt;appender-ref ref=&quot;oKong&quot;/&amp;gt;
         &amp;lt;/root&amp;gt;
     &amp;lt;/loggers&amp;gt;
 &amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意，需要在&lt;code&gt;configuration&lt;/code&gt;中，加入属性&lt;code&gt;packages&lt;/code&gt;为自定类所在包名&lt;code&gt;cn.lqdev.learning&lt;/code&gt;才会被扫描生效，不知道是否还有其他方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.启动后，就可以看见相关输出了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...部分省略...
一枚趔趄的猿(log4j2)：[14:47:43:751] [INFO] - org.apache.juli.logging.DirectJDKLog.log(DirectJDKLog.java:180) - Using a shared selector for servlet write/read
一枚趔趄的猿(log4j2)：[14:47:43:761] [INFO] - org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer.start(TomcatEmbeddedServletContainer.java:216) - Tomcat started on port(s): 8080 (http)
一枚趔趄的猿(log4j2)：[14:47:43:764] [INFO] - org.springframework.boot.StartupInfoLogger.logStarted(StartupInfoLogger.java:57) - Started Chapter25Application in 2.03 seconds (JVM running for 3.164)
一枚趔趄的猿(log4j2)：[14:47:43:764] [INFO] - cn.lqdev.learning.springboot.chapter25.Chapter25Application.main(Chapter25Application.java:14) - Chapter25启动!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不知道如何整合&lt;code&gt;log4j2&lt;/code&gt;的，可以查看：&lt;a href=&quot;http://blog.lqdev.cn/2018/08/22/springboot/chapter-twenty-three/&quot; title=&quot;《第二十三章：日志管理之整合篇》&quot;&gt;《第二十三章：日志管理之整合篇》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;logback自定义appender&quot;&gt;logback自定义Appender&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;logback&lt;/code&gt;的自定义，也是类似的，都是基于一个基类&lt;code&gt;appender&lt;/code&gt;来实现。本身&lt;code&gt;logback&lt;/code&gt;提供了&lt;code&gt;AppenderBase&lt;/code&gt;和&lt;code&gt;UnsynchronizedAppenderBase&lt;/code&gt;两个抽象类(同步和非同步)，所以我们自定义时，只需要看实际业务继承其中的一个即可。先看下其类继承结构：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/97582640.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;0.编写自定义&lt;code&gt;appender&lt;/code&gt;类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyLogbackAppender.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Getter
@Setter
public class MyLogbackAppender extends UnsynchronizedAppenderBase&amp;lt;ILoggingEvent&amp;gt;{

    Layout&amp;lt;ILoggingEvent&amp;gt; layout;
    
    //自定义配置 
    String printString;

    
    
    @Override
    public void start(){
        //这里可以做些初始化判断 比如layout不能为null ,
        if(layout == null) {
            addWarn(&quot;Layout was not defined&quot;);
        }
        //或者写入数据库 或者redis时 初始化连接等等
         super.start();
    }
    

    @Override
    public void stop()
    {
       //释放相关资源，如数据库连接，redis线程池等等
        System.out.println(&quot;logback-stop方法被调用&quot;);
        if(!isStarted()) {
            return;
        }
        super.stop();
    }
    
    @Override
    public void append(ILoggingEvent event) {
        if (event == null || !isStarted()){
            return;
        }
             // 此处自定义实现输出             
             // 获取输出值：event.getFormattedMessage()
             // System.out.print(event.getFormattedMessage());
             // 格式化输出        
        System.out.print(printString + &quot;：&quot; + layout.doLayout(event));
          
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也简单说明下，相关注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;start&lt;/code&gt;方法：初始时调用。故在编写如数据库入库，连接缓存或者mq时，可以在这个方法里面进行初始化操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stop&lt;/code&gt;：当停止时，调用。可做些资源释放操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.使用自定义appender:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;logback-spring.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration debug=&quot;false&quot;&amp;gt;
    &amp;lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径 --&amp;gt;
    &amp;lt;property name=&quot;LOG_HOME&quot; value=&quot;/home&quot; /&amp;gt;
    &amp;lt;!-- 控制台输出 --&amp;gt;
    &amp;lt;appender name=&quot;MyLogback&quot;
        class=&quot;cn.lqdev.learning.springboot.chapter25.config.MyLogbackAppender&quot;&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt;
            &amp;lt;!-- 日志收集最低日志级别 --&amp;gt;
            &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;layout
            class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&amp;gt;
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
        &amp;lt;!-- 自定义参数 --&amp;gt;
        &amp;lt;printString&amp;gt;一枚趔趄的猿(logback)&amp;lt;/printString&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 自定义包下设置为INFO,则可以看见输出的日志不包含debug输出了 --&amp;gt;
    &amp;lt;logger name=&quot;cn.lqdev.learning&quot; level=&quot;INFO&quot; /&amp;gt;

    &amp;lt;!-- 日志输出级别 --&amp;gt;
    &amp;lt;root level=&quot;INFO&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;MyLogback&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
    
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.应用启动，查看控制台输出，效果是一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...部分省略...
一枚趔趄的猿(logback)：2018-08-25 15:01:57.486 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler [&quot;http-nio-8080&quot;]
一枚趔趄的猿(logback)：2018-08-25 15:01:57.497 [main] INFO  org.apache.tomcat.util.net.NioSelectorPool - Using a shared selector for servlet write/read
一枚趔趄的猿(logback)：2018-08-25 15:01:57.520 [main] INFO  o.s.b.c.e.tomcat.TomcatEmbeddedServletContainer - Tomcat started on port(s): 8080 (http)
一枚趔趄的猿(logback)：2018-08-25 15:01:57.523 [main] INFO  c.l.l.springboot.chapter25.Chapter25Application - Started Chapter25Application in 54.349 seconds (JVM running for 55.377)
一枚趔趄的猿(logback)：2018-08-25 15:01:57.524 [main] INFO  c.l.l.springboot.chapter25.Chapter25Application - Chapter25启动!&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于shutdownhook&quot;&gt;关于ShutdownHook&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当你运行了以上的自定义&lt;code&gt;appender&lt;/code&gt;后，停止应用时，你会发现定义的&lt;code&gt;stop&lt;/code&gt;方法并没有被执行。还需要配置一个&lt;code&gt;ShutdownHook&lt;/code&gt;系统钩子，使得在&lt;code&gt;jvm&lt;/code&gt;在退出时之前会调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一点知识-1&quot;&gt;一点知识&lt;/h4&gt;
&lt;p&gt;我们知道，在&lt;code&gt;java&lt;/code&gt;中，注册一个关闭钩子是很简单的，使用&lt;code&gt;Runtime&lt;/code&gt;类即可，具体用法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {

            @Override
            public void run() {
                // 执行资源释放操作

            }
        }));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在&lt;code&gt;SpringBoot&lt;/code&gt;中，只需要配置&lt;code&gt;logging.register-shutdown-hook&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;logging.register-shutdown-hook=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;logback&lt;/code&gt;而言，也可以在&lt;code&gt;logback-spring.xml&lt;/code&gt;中配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;shutdownHook class=&quot;ch.qos.logback.core.hook.DelayingShutdownHook&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也是可以的。再或者在启动类手动注册这个&lt;code&gt;DelayingShutdownHook&lt;/code&gt;也是可以的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里有个坑，&lt;code&gt;log4j2&lt;/code&gt;而言，配置失效了。谷歌了一圈也没有发现解决方法，网上的方案试了一遍都是不行。。很尴尬。要是使用&lt;code&gt;log4j2&lt;/code&gt;的话，可以取巧下，在&lt;code&gt;start()&lt;/code&gt;方法里面，注册钩子之后调用&lt;code&gt;stop&lt;/code&gt;方法。希望有知道的大神分享下如何解决！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/zhoucheng05_13/article/details/78494458&quot; class=&quot;uri&quot; title=&quot;https://blog.csdn.net/zhoucheng05_13/article/details/78494458&quot;&gt;https://blog.csdn.net/zhoucheng05_13/article/details/78494458&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://logging.apache.org/log4j/2.x/manual/appenders.html&quot; class=&quot;uri&quot; title=&quot;http://logging.apache.org/log4j/2.x/manual/appenders.html&quot;&gt;http://logging.apache.org/log4j/2.x/manual/appenders.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://logging.apache.org/log4j/2.x/manual/extending.html#Appenders&quot; class=&quot;uri&quot; title=&quot;http://logging.apache.org/log4j/2.x/manual/extending.html#Appenders&quot;&gt;http://logging.apache.org/log4j/2.x/manual/extending.html#Appenders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://logback.qos.ch/manual/appenders.html&quot; class=&quot;uri&quot; title=&quot;https://logback.qos.ch/manual/appenders.html&quot;&gt;https://logback.qos.ch/manual/appenders.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hupoling/article/details/75353854&quot; class=&quot;uri&quot; title=&quot;https://blog.csdn.net/hupoling/article/details/75353854&quot;&gt;https://blog.csdn.net/hupoling/article/details/75353854&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本文主要是简单介绍了&lt;code&gt;log4j2&lt;/code&gt;和&lt;code&gt;logback&lt;/code&gt;自定义&lt;code&gt;appender&lt;/code&gt;相关知识。实现起来是相对简单的，&lt;strong&gt;需要注意当涉及需要关闭释放相关资源时，需要确认下关闭前是否有被调用，不然可能造成连接未关闭等行为，避免不必要的问题。&lt;/strong&gt;关于最后使用&lt;code&gt;log4j2&lt;/code&gt;关闭钩子未生效问题，由于现在都默认使用&lt;code&gt;logback&lt;/code&gt;了，这个问题就不深究了，还望有知道的同学分享下解决方案！谢谢！同时由于没有对两个框架有过多的深入了解，只能点到为止了，若文中有误，还望指出！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目前互联网上很多大佬都有&lt;code&gt;SpringBoot&lt;/code&gt;系列教程，如有雷同，请多多包涵了。&lt;strong&gt;原创不易，码字不易&lt;/strong&gt;，还希望大家多多支持。若文中有所错误之处，还望提出，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老生常谈&quot;&gt;老生常谈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;个人QQ：&lt;code&gt;499452441&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;公众号：&lt;code&gt;lqdevOps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/default/wxgzh8cm.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://blog.lqdev.cn/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn&quot;&gt;http://blog.lqdev.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-25&quot; class=&quot;uri&quot; title=&quot;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-25&quot;&gt;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-25&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.lqdev.cn/2018/08/25/springboot/chapter-twenty-five/&quot; class=&quot;uri&quot;&gt;http://blog.lqdev.cn/2018/08/25/springboot/chapter-twenty-five/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 15:53:00 +0000</pubDate>
<dc:creator>oKong_趔趄的猿</dc:creator>
<og:description>前言 前面两章节我们介绍了一些日志框架的常见配置及使用实践。一般上，在开发过程中，像 、`logback Appender Appender log4j2 logback Appender`知识。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okong/p/springboot-twenty-five.html</dc:identifier>
</item>
<item>
<title>开源项目推荐 Databot:  Python高性能数据驱动开发框架--爬虫案例 - kkyong</title>
<link>http://www.cnblogs.com/codemind/p/9535491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codemind/p/9535491.html</guid>
<description>&lt;p&gt;多年一直从事数据相关工作。对数据开发存在的各种问题深有体会。数据处理工作主要有： 爬虫，ETL,机器学习。开发过程是构建数据处理的管道Pipeline的过程.  将各种模块拼接起来。总结步骤有：获取数据，转化，合并，存储，发送。数据研发工作和业务系统研发有着很多的差别。数据项目更多是铺管道过程，各模块通过数据依赖，而业务系统开发是建大楼过程。很多情况爬虫工程师，算法工程师，写出来的数据处理代码，非常混乱。因为在看到真实数据前，无法做准确的设计，更不用说性能上的要求。  前段时间花了大量时间对Asyncio库深入研究。决定开发了数据驱动框架，从模块化，灵活度，性能方面来解决数据处理工作的问题。这就我创立Databot开源框架的初衷。&lt;/p&gt;
&lt;p&gt;花大半个月时间框架基本完成，能够解决处理数据处理工作，爬虫，ETL，量化交易。并有非常好的性能表现。欢迎大家使用和提意见。&lt;/p&gt;
&lt;p&gt;项目地址：https://github.com/kkyon/databot&lt;/p&gt;
&lt;p&gt;安装方法：pip3 install -U databot&lt;/p&gt;
&lt;p&gt;代码案例：https://github.com/kkyon/databot/tree/master/examples &lt;/p&gt;
&lt;h2&gt;多线程 VS 异步协程：&lt;/h2&gt;
&lt;p&gt;总的来说高并发的数据IO使用异步协程更具有优势。因为线程占用资源多，线程切换时候代价很大，所以建议的线程数都是cpu*2. Python由于GIL限制，通过多线程很难提升性能。&lt;/p&gt;
&lt;p&gt;而通过asyncio可以达到非常的吞吐量。并发数几乎没有限制。&lt;/p&gt;
&lt;p&gt;具体可以参考这篇文章：&lt;/p&gt;
&lt;p&gt;https://pawelmhm.github.io/asyncio/python/aiohttp/2016/04/22/asyncio-aiohttp.html&lt;/p&gt;
&lt;p&gt;在普通笔记本上 python asyncio 在9分钟 完成100万个网页请求。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;Databot性能测试结果：&lt;/h2&gt;
&lt;p&gt;使用百度爬虫案例来作出：&lt;/p&gt;
&lt;p&gt;有一批关键词，需要在百度搜索引擎。记录前十页的文章标题。在SEO，舆情等场景经常要做类似事情。测试中使用了100个关键字（需要抓取1000个网页）大概三分钟就能完成。测试环境结果如下：&lt;/p&gt;
&lt;pre readability=&quot;11&quot;&gt;
# ---run result----&lt;br/&gt;&lt;strong&gt;HTTP返回在1秒左右&lt;/strong&gt;&lt;br/&gt;#post man test result for a page requrest ;1100ms&lt;p&gt;&lt;strong&gt;ping的是时间42ms&lt;/strong&gt;&lt;br/&gt;# PING www.a.shifen.com (180.97.33.108): 56 data bytes&lt;br/&gt;# 64 bytes from 180.97.33.108: icmp_seq=0 ttl=55 time=41.159 ms&lt;br/&gt;&lt;strong&gt;&lt;br/&gt;Databot测试结果：每秒能抓取50个条目，每秒能处理6个网页。&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;# got len item 9274 speed:52.994286 per second,total cost: 175s&lt;br/&gt;# got len item 9543 speed:53.016667 per second,total cost: 180s&lt;br/&gt;# got len item 9614 speed:51.967568 per second,total cost: 185s&lt;/p&gt;&lt;/pre&gt;


&lt;h2&gt;&lt;strong&gt;Python Asyncio 的问题：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;asyncio本身，比如概念复杂，futrue,task,区别，ensure futer,crate_task。&lt;/p&gt;
&lt;p&gt;协程编写要求对工程师高，特别在数据项目中。&lt;/p&gt;
&lt;p&gt;asyncio支持的三方库有限，需要结合多线程和多进程来开发。&lt;/p&gt;

&lt;h2&gt;Databot理念和&lt;/h2&gt;
&lt;p&gt;数据工程师只关注核心逻辑，编写模块化函数，不需要考虑asyncio的特性。Databot将处理外部IO,并发，调度问题。&lt;/p&gt;

&lt;h2&gt;Databot基本概念：&lt;/h2&gt;
&lt;p&gt;Databot设计非常简洁，一共只有三个概念：Pipe,Route,Node&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pipe是主流程&lt;/strong&gt;，一个程序可以有多个Pipe，相互联系或独立。Route,Node,都是包含在pipe内部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Route是路由器&lt;/strong&gt;，主要起数据路由，汇总合并作用。有Branch, Return,Fork,Join,BlockedJoin。其中Branch,Fork,不会改变主流程数据。Return,Join，会将处理后的数据放回到主流程中。可以通过嵌套Route，组合出复杂的数据网络。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Node是数据驱动节点&lt;/strong&gt;。 处理数据逻辑节点，一些HTTP,Mysql,AioFile ，客户自定义函数，Timer,Loop都是属于Node.&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/818151/201808/818151-20180825225810266-1555712659.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;如何安装Databot:&lt;/h2&gt;
&lt;p&gt;pip3 install -U databot&lt;/p&gt;

&lt;p&gt;github地址：https://github.com/kkyon/databot&lt;/p&gt;

&lt;h2&gt;爬虫代码解析：&lt;/h2&gt;
&lt;p&gt;更多例子参照：https://github.com/kkyon/databot/tree/master/examples&lt;/p&gt;

&lt;p&gt;针对百度爬虫例子，主流程代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;get_all_items，是客户编写函数用于解析网页上的条目。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;get_all_page_url 是自定义编写函数用于获取网页上的翻页链接。&lt;/span&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Loop通过循环列表把，链接发送到pipe中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HTTPLoader将读入URL,下载HTML.生成HTTP response对象放入Pipe中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Branch会拷贝一份数据(Httpresponse)导入分支中，然后get_all_items会解析成最终结果，存入文件中。此时主流程数据不受影响。仍然有一份HTTP response&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Branch拷贝pipe中的Httpresponse到分支，然后通过get_all_page_url解析全部翻页链接。然后通过HTTPloader下载相应的网页，解析保持。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上每个步骤都会通过Databot框架调用和并发。&lt;/p&gt;
&lt;pre&gt;
BotFrame.render('baiduspider')函数可以用于生产pipe的结构图。需要安装https://www.graphviz.org/download/
&lt;/pre&gt;
&lt;pre&gt;
主函数代码：
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     words = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;贸易战&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;世界杯&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     baidu_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com/s?wd=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     urls = [baidu_url % (word) &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; words]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     outputfile=aiofile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    Pipe(
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        Loop(urls),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        HttpLoader(),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        Branch(get_all_items,outputfile),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        Branch(get_all_page_url, HttpLoader(), get_all_items, outputfile),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成流程图&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     BotFrame.render(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baiduspider&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    BotFrame.run()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; main()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;下列是生成的流程图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/818151/201808/818151-20180825214157020-164663094.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; databot.flow &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pipe, Branch, Loop
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; databot.botframe &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BotFrame
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; databot.http.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpLoader
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; databot.db.aiofile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; aiofile
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; logging.basicConfig(level=&lt;span&gt;logging.DEBUG)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义解析结构&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ResultItem:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         self.id: str = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         self.name: str = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         self.url: str = &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         self.page_rank: int =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         self.page_no: int =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s,%s,%d,%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(str(self.id),self.name,self.page_no,self.page_rank)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解析具体条目&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_all_items(response):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     soup = BeautifulSoup(response.text, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     items = soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div.result.c-container&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     result =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; rank, item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(items):
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         id =&lt;span&gt; uuid.uuid4()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         r =&lt;span&gt; ResultItem()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         r.id =&lt;span&gt; id
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         r.page_rank =&lt;span&gt; rank
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         r.name =&lt;span&gt; item.h3.get_text()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        result.append(r)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解析分页链接&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_all_page_url(response):
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     itemList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     soup = BeautifulSoup(response.text, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     page = soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div#page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; page[0].find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         href = item.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         no =&lt;span&gt; item.get_text()
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;下一页&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; no:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;         itemList.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; href)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; itemList
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     words = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;贸易战&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;世界杯&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     baidu_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com/s?wd=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     urls = [baidu_url % (word) &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; words]
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;     outputfile=aiofile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    Pipe(
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        Loop(urls),
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        HttpLoader(),
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        Branch(get_all_items,outputfile),
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        Branch(get_all_page_url, HttpLoader(), get_all_items, outputfile),
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成流程图&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt;     BotFrame.render(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baiduspider&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    BotFrame.run()
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt; main()
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 25 Aug 2018 15:34:00 +0000</pubDate>
<dc:creator>kkyong</dc:creator>
<og:description>推荐我的开源项目， Databot :Python高性能数据驱动开发框架--爬虫案例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codemind/p/9535491.html</dc:identifier>
</item>
</channel>
</rss>