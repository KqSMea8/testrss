<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Thrift 基础(C++ rpc ) - karllen</title>
<link>http://www.cnblogs.com/Forever-Kenlen-Ja/p/9649724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Forever-Kenlen-Ja/p/9649724.html</guid>
<description>&lt;h2 id=&quot;一thrift简介&quot;&gt;一、thrift简介&lt;/h2&gt;
&lt;p&gt;thrift是Facebook开源的一套rpc框架，目前被许多公司使用&lt;br/&gt;我理解的特点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用IDL语言生成多语言的实现代码，程序员只需要实现自己的业务逻辑&lt;/li&gt;
&lt;li&gt;支持序列化和反序列化操作，底层封装协议，传输模块&lt;/li&gt;
&lt;li&gt;以同步rpc调用为主，使用libevent evhttp支持http形式的异步调用&lt;/li&gt;
&lt;li&gt;rpc服务端线程安全，客户端大多数非线程安全&lt;/li&gt;
&lt;li&gt;相比protocol buffer效率差些，protocol buffer不支持rpc，需要自己实现rpc扩展，目前有grpc可以使用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于thrift支持序列化和反序列化，并且支持rpc调用，其代码风格较好并且使用方便，对效率要求不算太高的业务，以及需要rpc的场景，可以选择thrift作为基础库&lt;/p&gt;
&lt;p&gt;层次图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524932/201809/524932-20180915020117562-1191051189.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二编译thrift-for-c-centos7&quot;&gt;二、编译(thrift for c++ &amp;amp;&amp;amp; centos7)&lt;/h2&gt;
&lt;p&gt;1、官网获取源码包 thrift-0.11.0.tar.gz 解压&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;tar zxvf thrift-0.11.0.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、安装依赖&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;yum -y install automake libtool flex bison pkgconfig gcc-c++ boost-devel libevent-devel zlib-devel python-devel ruby-devel openssl-devel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、编译boost&lt;br/&gt;使用boost_1_63_0.tar.gz&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;./bootstrap.sh
./b2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、编译thrift&lt;br/&gt;源码根目录运行&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;./configure &amp;amp;&amp;amp; make
sudo make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、验证安装&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;thrift -version
显示 Thrift version 0.11.0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三编写使用idl编写.thrift文件&quot;&gt;三、编写使用IDL编写.thrift文件&lt;/h2&gt;
&lt;p&gt;这里给出一个thrift的IDL基本语法列表，详细用法可以去官网查找&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;namespace cpp thrift.Test
//typedef 用法
typedef i32 MyInt32;
typedef string MyString;
typedef i32 UserId;
//struct 结构定义
struct TypedefTestStruct
{
    1: MyInt32 field_MyInt32;
    2: MyString field_MyString;
    3: i32 field_Int32;
    4: string filed_string;
}
//enum 枚举定义
enum Numberz
{
    ONE = 1,
    TWO,
    THREE,
    FIVE = 5,
    SIX,
    EIGHT = 8
}
//const 用法
const Numberz myNumberz = Numberz.ONE;
struct Bonk
{
    1: string message,
    2: i32 type
}
//类型嵌套
struct Xtruct
{
    1: string string_thing,
    2: i8 byte_thing,
    3: i32 i32_thing,
    4: i64 i64_thing
}
struct Xtruct2
{
    1: i8 byte_thing,
    2: Xtruct struct_thing,
    3: i32 i32_thing
}
//支持map list set类型分别对应C++中的 map = stl::map list = stl::vector set = stl::set
typedef map&amp;lt;string, Bonk&amp;gt; MapType
struct Insanity
{
    1: map&amp;lt;Numberz, UserId&amp;gt; userMap;
    2: list&amp;lt;Xtruct&amp;gt; xtructs;
}
struct CrazyNesting
{
    1: string string_field,
    2: optional set&amp;lt;Insanity&amp;gt; set_field;
    3: required list&amp;lt;map&amp;lt;set&amp;lt;i32&amp;gt;, map&amp;lt;i32,set&amp;lt;list&amp;lt;map&amp;lt;Insanity,string&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; list_field,
    4: binary binary_field
}
//union用法
union SomeUnion
{
    1: map&amp;lt;NumberZ, UserId&amp;gt; map_thing,
    2: string string_thing,
    3: i32 i32_thing,
    4: Xtruct3 xtruct_thing,
    5: Insanity insanity_thing
}
//exception 异常
exception Xception
{
    1: i32 errorCode,
    2: string message
}
exception Xception2
{   
    1: i32 errorCode,
    2: Xtruct struct_thing
}
// empty struct
struct EmptyStruct{}
struct OneField
{
    1: EmptyStruct field;
}
//service 定义的一组rpc服务,一般是抽象出来的接口调用
service ThriftTest
{
    void testVoid(),
    string testString(1: string thing),
    bool testBool(1: bool thing),
    i8 testByte(1: i8 thing),
    i32 testI32(1: i32 thing),
    i64 testI64(1: i64 thing),
    Xtruct testStruct(1: Xtruct thing),
    Xtruct2 testNest(1: Xtruct2 thing),
    map&amp;lt;string, string&amp;gt; testStringMap(1: map&amp;lt;string, string&amp;gt; thing),
    set&amp;lt;i32&amp;gt; testSet(1: set&amp;lt;i32&amp;gt; thing),
    list&amp;lt;i32&amp;gt; testList(1: list&amp;lt;i32&amp;gt; thing),
    Numberz testEnum(1: Numberz thing),
    map&amp;lt;i32, map&amp;lt;i32,i32&amp;gt;&amp;gt; testMapMap(1: i32 hello),
    map&amp;lt;UserId, map&amp;lt;Numberz,Insanity&amp;gt;&amp;gt; testInsanity(1: Insanity argument),
    Xtruct testMulti(1: i8 arg0, 2: i32 arg1, 3: i64 arg2, 4: map&amp;lt;i16, string&amp;gt; arg3, 5: Numberz arg4, 6: UserId arg5),
    void testException(1: string arg) throws(1: Xception err1),
    Xtruct testMultiException(1: string arg0, 2: string arg1) throws(1: Xception err1, 2: Xception2 err2),
    oneway void testOneway(1:i32 secondsToSleep)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四使用thrift文件生成c代码&quot;&gt;四、使用thrift文件生成C++代码&lt;/h2&gt;
&lt;p&gt;1、生成同步调用的C++代码&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;thrift -r --gen cpp xxx.thrift&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、生成异步调用的C++代码(同时同步调用的代码也被生成)&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;thrift --gen cpp:cob_style xxx.thrift &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五thrfit同步调用&quot;&gt;五、thrfit同步调用&lt;/h2&gt;
&lt;p&gt;1、StressTest.thrift文件&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;namespace cpp test.stress
service Service {
  void echoVoid(),
  i8 echoByte(1: i8 arg),
  i32 echoI32(1: i32 arg),
  i64 echoI64(1: i64 arg),
  string echoString(1: string arg),
  list&amp;lt;i8&amp;gt;  echoList(1: list&amp;lt;i8&amp;gt; arg),
  set&amp;lt;i8&amp;gt;  echoSet(1: set&amp;lt;i8&amp;gt; arg),
  map&amp;lt;i8, i8&amp;gt;  echoMap(1: map&amp;lt;i8, i8&amp;gt; arg),
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、使用thrift -r --gen cpp StressTest.thrift 生成代码&lt;br/&gt;gen-cpp目录有&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;StressTest_types.h StressTest_types.cpp StressTest_constants.h StressTest_constants.cpp Service.h Service.cpp Service_server.skeleton.cpp &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成&lt;br/&gt;StressTest_types.h StressTest_constants.h 为相关类型定义文件&lt;br/&gt;Service_server.skeleton为服务端需要的实现文件&lt;/p&gt;
&lt;p&gt;3、代码实现&lt;br/&gt;服务端:&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;#include &amp;lt;thrift/concurrency/ThreadManager.h&amp;gt;
#include &amp;lt;thrift/concurrency/PlatformThreadFactory.h&amp;gt;
#include &amp;lt;thrift/concurrency/Thread.h&amp;gt;
#include &amp;lt;thrift/protocol/TBinaryProtocol.h&amp;gt;
#include &amp;lt;thrift/server/TSimpleServer.h&amp;gt;
#include &amp;lt;thrift/server/TNonblockingServer.h&amp;gt;
#include &amp;lt;thrift/transport/TServerSocket.h&amp;gt;
#include &amp;lt;thrift/transport/TNonblockingServerSocket.h&amp;gt;
#include &amp;lt;thrift/transport/TNonblockingServerTransport.h&amp;gt;
#include &amp;lt;thrift/transport/TBufferTransports.h&amp;gt;
#include &quot;Service.h&quot;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace  ::test::stress;
class ServiceHandler : virtual public ServiceIf {
 public:
  ServiceHandler() {
  }
  void echoVoid() {
    // Your implementation goes here
    printf(&quot;echoVoid\n&quot;);
  }
  int8_t echoByte(const int8_t arg) {
    printf(&quot;echoByte %c\n&quot;, arg);
    return arg;
  }
  int32_t echoI32(const int32_t arg) {
    printf(&quot;echoI32\n&quot;);
    return arg;
  }
  int64_t echoI64(const int64_t arg) {
    printf(&quot;echoI64\n&quot;);
    return arg;
  }
  void echoString(std::string&amp;amp; _return, const std::string&amp;amp; arg) {
    printf(&quot;echoString\n&quot;);
  }
  void echoList(std::vector&amp;lt;int8_t&amp;gt; &amp;amp; _return, const std::vector&amp;lt;int8_t&amp;gt; &amp;amp; arg) {
    printf(&quot;echoList\n&quot;);
  }
  void echoSet(std::set&amp;lt;int8_t&amp;gt; &amp;amp; _return, const std::set&amp;lt;int8_t&amp;gt; &amp;amp; arg) {
    printf(&quot;echoSet\n&quot;);
  }
  void echoMap(std::map&amp;lt;int8_t, int8_t&amp;gt; &amp;amp; _return, const std::map&amp;lt;int8_t, int8_t&amp;gt; &amp;amp; arg) {
    printf(&quot;echoMap\n&quot;);
  }
};

int main(int argc, char **argv) {
  int port = 9090;
  stdcxx::shared_ptr&amp;lt;ServiceHandler&amp;gt; handler(new ServiceHandler());
  stdcxx::shared_ptr&amp;lt;TProcessor&amp;gt; processor(new ServiceProcessor(handler));
  stdcxx::shared_ptr&amp;lt;TProtocolFactory&amp;gt; protocolFactory(new TBinaryProtocolFactory());
  stdcxx::shared_ptr&amp;lt;TNonblockingServerTransport&amp;gt; serverTransport(new TNonblockingServerSocket(port));
  stdcxx::shared_ptr&amp;lt;PlatformThreadFactory&amp;gt; threadFactory = std::shared_ptr&amp;lt;PlatformThreadFactory&amp;gt;(new PlatformThreadFactory());
  stdcxx::shared_ptr&amp;lt;ThreadManager&amp;gt; threadManager = ThreadManager::newSimpleThreadManager(10);

  threadManager-&amp;gt;threadFactory(threadFactory);
  threadManager-&amp;gt;start();

  stdcxx::shared_ptr&amp;lt;TNonblockingServer&amp;gt; server(new TNonblockingServer(processor, protocolFactory, serverTransport, threadManager));

  server-&amp;gt;serve();
  
  return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要实现ServiceHandler继承ServiceIf的相关接口，ServiceHandler是负责相关rpc调用业务的功能实现，&lt;br/&gt;thrift服务器模型基本模型有四种、SimpleServer ThreadedServer ThreadPoolServer NoBlockingServer&lt;br/&gt;SimpleServer 简单的单线程模型&lt;br/&gt;ThreadedServer 一个线程一个连接&lt;br/&gt;ThreadPoolServer 线程池&lt;br/&gt;NoBlockingServer 基于libevent的IO复用模型 libevent在linux平台是基于epoll的reactor模型&lt;br/&gt;还有一个异步Server模型TEvhttpServer 基于libevent的evhttp&lt;br/&gt;这里服务端使用了非阻塞epoll实现的thrift服务端模型&lt;/p&gt;
&lt;p&gt;客户端:&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;thrift/transport/TTransportUtils.h&amp;gt;
#include &amp;lt;thrift/transport/TSocket.h&amp;gt;
#include &amp;lt;thrift/protocol/TBinaryProtocol.h&amp;gt;
#include &quot;Service.h&quot;

using namespace  ::test::stress;
using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;

int main()
{
    ::apache::thrift::stdcxx::shared_ptr&amp;lt;TSocket&amp;gt; socket(new TSocket(&quot;localhost&quot;, 9090));
    ::apache::thrift::stdcxx::shared_ptr&amp;lt;TTransport&amp;gt; transport(new TFramedTransport(socket));
    ::apache::thrift::stdcxx::shared_ptr&amp;lt;TProtocol&amp;gt; protocol(new TBinaryProtocol(transport));
    ServiceClient client(protocol);
    transport-&amp;gt;open();
    std::cout &amp;lt;&amp;lt; &quot;client echoByte byte=&quot; &amp;lt;&amp;lt; client.echoByte('A') &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;send_echoByte('B')&quot; &amp;lt;&amp;lt; std::endl;
    client.send_echoByte('B');
    std::cout &amp;lt;&amp;lt; &quot;send_echoByte('C')&quot; &amp;lt;&amp;lt; std::endl;
    client.send_echoByte('C');
    std::cout &amp;lt;&amp;lt; &quot;recv_echoByte()&quot; &amp;lt;&amp;lt; client.recv_echoByte() &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;recv_echoByte()&quot; &amp;lt;&amp;lt; client.recv_echoByte() &amp;lt;&amp;lt; std::endl;
    transport-&amp;gt;close();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端使用则比较简单，Service.h定义了相关接口，ServiceClient则是rpc客户类&lt;br/&gt;TTransport new TFramedTransport(socket) 这里创建基于socket的传输层&lt;br/&gt;TProtocol 协议层，序列化后的数据存储方式，这里以TBinaryProtocol 二进制存储&lt;/p&gt;
&lt;h2 id=&quot;六thrift异步调用&quot;&gt;六、thrift异步调用&lt;/h2&gt;
&lt;p&gt;1、thrift文件同同步调用一致&lt;br/&gt;2、使用thrift --gen cpp:cob_style StressTest.thrift 生成代码&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;StressTest_types.h StressTest_types.cpp StressTest_constants.h StressTest_constants.cpp Service.h Service.cpp Service_server.skeleton.cpp Service_async_server.skeleton.cpp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Service_server.skeleton.cpp 同步代码用不到&lt;br/&gt;Service_async_server.skeleton.cpp则为http的异步实现&lt;br/&gt;服务端：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;#include &amp;lt;thrift/protocol/TBinaryProtocol.h&amp;gt;
#include &amp;lt;thrift/async/TAsyncProtocolProcessor.h&amp;gt;
#include &amp;lt;thrift/async/TEvhttpServer.h&amp;gt;
#include &amp;lt;event.h&amp;gt;
#include &amp;lt;evhttp.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &quot;Service.h&quot;

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::async;

using namespace  ::test::stress;

class ServiceHandler : virtual public ServiceIf {
public:
    ServiceHandler() {
    }

    void echoVoid() {
        printf(&quot;echoVoid\n&quot;);
    }

    int8_t echoByte(const int8_t arg) {
        printf(&quot;echoByte %c\n&quot;, arg);
        return arg;
    }

    int32_t echoI32(const int32_t arg) {
        printf(&quot;echoI32\n&quot;);
        return arg;
    }

    int64_t echoI64(const int64_t arg) {
        printf(&quot;echoI64\n&quot;);
        return arg;
    }

    void echoString(std::string&amp;amp; _return, const std::string&amp;amp; arg) {
        printf(&quot;echoString %s\n&quot;, arg.c_str());
        _return = arg;
    }

    void echoList(std::vector&amp;lt;int8_t&amp;gt; &amp;amp; _return, const std::vector&amp;lt;int8_t&amp;gt; &amp;amp; arg) {
        printf(&quot;echoList\n&quot;);
    }

    void echoSet(std::set&amp;lt;int8_t&amp;gt; &amp;amp; _return, const std::set&amp;lt;int8_t&amp;gt; &amp;amp; arg) {
        printf(&quot;echoSet\n&quot;);
    }

    void echoMap(std::map&amp;lt;int8_t, int8_t&amp;gt; &amp;amp; _return, const std::map&amp;lt;int8_t, int8_t&amp;gt; &amp;amp; arg) {
        printf(&quot;echoMap\n&quot;);
    }

};

class ServiceAsyncHandler : public ServiceCobSvIf {
 public:
  ServiceAsyncHandler() {
    syncHandler_ = std::auto_ptr&amp;lt;ServiceHandler&amp;gt;(new ServiceHandler);
    // Your initialization goes here
  }
  virtual ~ServiceAsyncHandler(){}

  void echoVoid(::apache::thrift::stdcxx::function&amp;lt;void()&amp;gt; cob) {
    syncHandler_-&amp;gt;echoVoid();
    return cob();
  }

  void echoByte(::apache::thrift::stdcxx::function&amp;lt;void(int8_t const&amp;amp; _return)&amp;gt; cob, const int8_t arg) {
    int8_t _return = 0;
    _return = syncHandler_-&amp;gt;echoByte(arg);
    return cob(_return);
  }

  void echoI32(::apache::thrift::stdcxx::function&amp;lt;void(int32_t const&amp;amp; _return)&amp;gt; cob, const int32_t arg) {
    int32_t _return = 0;
    _return = syncHandler_-&amp;gt;echoI32(arg);
    return cob(_return);
  }

  void echoI64(::apache::thrift::stdcxx::function&amp;lt;void(int64_t const&amp;amp; _return)&amp;gt; cob, const int64_t arg) {
    int64_t _return = 0;
    _return = syncHandler_-&amp;gt;echoI64(arg);
    return cob(_return);
  }

  void echoString(::apache::thrift::stdcxx::function&amp;lt;void(std::string const&amp;amp; _return)&amp;gt; cob, const std::string&amp;amp; arg) {
    std::string _return;
    syncHandler_-&amp;gt;echoString(_return, arg);
    return cob(_return);
  }

  void echoList(::apache::thrift::stdcxx::function&amp;lt;void(std::vector&amp;lt;int8_t&amp;gt;  const&amp;amp; _return)&amp;gt; cob, const std::vector&amp;lt;int8_t&amp;gt; &amp;amp; arg) {
    std::vector&amp;lt;int8_t&amp;gt;  _return;
    syncHandler_-&amp;gt;echoList(_return, arg);
    return cob(_return);
  }

  void echoSet(::apache::thrift::stdcxx::function&amp;lt;void(std::set&amp;lt;int8_t&amp;gt;  const&amp;amp; _return)&amp;gt; cob, const std::set&amp;lt;int8_t&amp;gt; &amp;amp; arg) {
    std::set&amp;lt;int8_t&amp;gt;  _return;
    syncHandler_-&amp;gt;echoSet(_return, arg);
    return cob(_return);
  }

  void echoMap(::apache::thrift::stdcxx::function&amp;lt;void(std::map&amp;lt;int8_t, int8_t&amp;gt;  const&amp;amp; _return)&amp;gt; cob, const std::map&amp;lt;int8_t, int8_t&amp;gt; &amp;amp; arg) {
    std::map&amp;lt;int8_t, int8_t&amp;gt;  _return;
    syncHandler_-&amp;gt;echoMap(_return, arg);
    return cob(_return);
  }
  
 protected:
  std::auto_ptr&amp;lt;ServiceHandler&amp;gt; syncHandler_;
};

int main()
{
    ::apache::thrift::stdcxx::shared_ptr&amp;lt;ServiceAsyncProcessor&amp;gt; asynProcessor(new ServiceAsyncProcessor(
                            ::apache::thrift::stdcxx::shared_ptr&amp;lt;ServiceCobSvIf&amp;gt;(new ServiceAsyncHandler())));

    ::apache::thrift::stdcxx::shared_ptr&amp;lt;TAsyncProtocolProcessor&amp;gt; asynProtocolProcessor(new TAsyncProtocolProcessor(asynProcessor,
                            ::apache::thrift::stdcxx::shared_ptr&amp;lt;TProtocolFactory&amp;gt;(new TBinaryProtocolFactory())));

    TEvhttpServer server(asynProtocolProcessor, 9999);
    server.serve();
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里实现ServiceHandler的相关业务接口即可实现rpc服务端的相关功能&lt;/p&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;#include &quot;Service.h&quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;thrift/concurrency/ThreadManager.h&amp;gt;
#include &amp;lt;thrift/concurrency/PlatformThreadFactory.h&amp;gt;
#include &amp;lt;thrift/concurrency/Thread.h&amp;gt;
#include &amp;lt;thrift/async/TAsyncChannel.h&amp;gt;
#include &amp;lt;thrift/async/TEvhttpClientChannel.h&amp;gt;
#include &amp;lt;thrift/transport/TSocket.h&amp;gt;
#include &amp;lt;thrift/transport/TTransportUtils.h&amp;gt;
#include &amp;lt;thrift/transport/TBufferTransports.h&amp;gt;
#include &amp;lt;thrift/protocol/TBinaryProtocol.h&amp;gt;
#include &amp;lt;thrift/protocol/TProtocol.h&amp;gt;
#include &amp;lt;event.h&amp;gt;

using namespace  ::apache::thrift;
using namespace  ::apache::thrift::transport;
using namespace  ::apache::thrift::protocol;
using namespace  ::apache::thrift::async;
using namespace  ::apache::thrift::concurrency;
using namespace  ::test::stress;

class MyClient : public ServiceCobClient
{
public:
    MyClient(stdcxx::shared_ptr&amp;lt;TAsyncChannel&amp;gt; channel, TProtocolFactory* protocolFactory)
        : ServiceCobClient(channel, protocolFactory)
    {

    }
    virtual ~MyClient(){}

    virtual void completed__(bool success)
    {
        if (success)
        {
            std::cout &amp;lt;&amp;lt; &quot;completed&quot; &amp;lt;&amp;lt; std::endl;
        }
        else
        {
            std::cout &amp;lt;&amp;lt; &quot;completed failed&quot; &amp;lt;&amp;lt; std::endl;
        }
    }

    void my_send_byte()
    {
        std::cout &amp;lt;&amp;lt; &quot;begin my_send_byte&quot; &amp;lt;&amp;lt; std::endl;
        stdcxx::function&amp;lt;void(ServiceCobClient*)&amp;gt; cob = stdcxx::bind(&amp;amp;MyClient::recv_byte_callback, this, stdcxx::placeholders::_1);
        echoByte(cob, 'A');
        std::cout &amp;lt;&amp;lt; &quot;end my_send_byte&quot; &amp;lt;&amp;lt; std::endl;
    }

    void my_send_string()
    {
        std::cout &amp;lt;&amp;lt; &quot;begin my_send_string&quot; &amp;lt;&amp;lt; std::endl;
        stdcxx::function&amp;lt;void(ServiceCobClient*)&amp;gt; cob = stdcxx::bind(&amp;amp;MyClient::recv_string_callback, this, stdcxx::placeholders::_1);
        echoString(cob, &quot;test asynclient&quot;);
        std::cout &amp;lt;&amp;lt; &quot;end my_send_string&quot; &amp;lt;&amp;lt; std::endl;
    }

    void recv_byte_callback(ServiceCobClient* client)
    {
        std::cout &amp;lt;&amp;lt; &quot;recv_byte_callback&quot; &amp;lt;&amp;lt; std::endl;
        _res_byte = recv_echoByte();
        std::cout &amp;lt;&amp;lt; &quot;_res_byte =&quot; &amp;lt;&amp;lt; _res_byte &amp;lt;&amp;lt; std::endl;
    }

    void recv_string_callback(ServiceCobClient* client)
    {
        std::cout &amp;lt;&amp;lt; &quot;recv_string_callback&quot; &amp;lt;&amp;lt; std::endl;
        recv_echoString(_res_string);
        std::cout &amp;lt;&amp;lt; &quot;_res_string=&quot; &amp;lt;&amp;lt; _res_string &amp;lt;&amp;lt; std::endl;
    }
private:
    char _res_byte;
    std::string _res_string;
};

class ClientThread : public Runnable
{
public:
    ClientThread(event_base* base, std::string &amp;amp; host, int port)
        : _base(base), _host(host), _port(port)
    {
    }
    virtual ~ClientThread(){}
    virtual void run()
    {
        stdcxx::shared_ptr&amp;lt;TAsyncChannel&amp;gt;  channel1(new TEvhttpClientChannel(_host, &quot;/&quot;, _host.c_str(), _port, _base));
        stdcxx::shared_ptr&amp;lt;TAsyncChannel&amp;gt;  channel2(new TEvhttpClientChannel(_host, &quot;/&quot;, _host.c_str(), _port, _base));

        MyClient client1(channel1, new TBinaryProtocolFactory());
        MyClient client2(channel2, new TBinaryProtocolFactory());

        client1.my_send_byte();
        client1.my_send_string();

        client2.my_send_byte();
        client2.my_send_string();

        while (1)
        {
            client1.my_send_byte();
            sleep(1);
        }
    }
protected:
private:
    event_base* _base;
    std::string _host;
    int _port;
};

int main()
{
    std::string host = &quot;192.168.119.129&quot;;
    int port = 9999;

    event_base* base = event_base_new();

    stdcxx::shared_ptr&amp;lt;PlatformThreadFactory&amp;gt; threadFactory = std::shared_ptr&amp;lt;PlatformThreadFactory&amp;gt;(new PlatformThreadFactory());
    stdcxx::shared_ptr&amp;lt;ThreadManager&amp;gt; threadManager = ThreadManager::newSimpleThreadManager(10);

    threadManager-&amp;gt;threadFactory(threadFactory);
    threadManager-&amp;gt;start();

    stdcxx::shared_ptr&amp;lt;Thread&amp;gt; thread = threadFactory-&amp;gt;newThread(std::shared_ptr&amp;lt;ClientThread&amp;gt;(new ClientThread(base, host, port)));
    thread-&amp;gt;start();

    event_base_dispatch(base);
    event_base_free(base);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端则实现了MyClient，MyClient继承公共的rpc服务接口，提供了异步回调的recv_byte_callback，recv_string_callback函数， ClientThread的线程函数的实现则对MyClient异步客户端进了测试&lt;/p&gt;
&lt;h2 id=&quot;七简单总结&quot;&gt;七、简单总结&lt;/h2&gt;
&lt;p&gt;通过这两天的学习，简单总结一下这个库&lt;br/&gt;1、thrift的C++代码实现很漂亮，很规范，适合学习阅读&lt;br/&gt;2、thrift可以满足很多基本的rpc调用场景&lt;br/&gt;3、本文只是简单写了thrift的用法，想深入了解这个库的，其内部实现还是需要化时间好好研究&lt;/p&gt;
&lt;p&gt;作者 [@karllen][3]&lt;br/&gt;2018 年 09月 15日&lt;br/&gt;QQ群: 347769318&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 18:05:00 +0000</pubDate>
<dc:creator>karllen</dc:creator>
<og:description>一、thrift简介 thrift是Facebook开源的一套rpc框架，目前被许多公司使用 我理解的特点 1. 使用IDL语言生成多语言的实现代码，程序员只需要实现自己的业务逻辑 2. 支持序列化和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Forever-Kenlen-Ja/p/9649724.html</dc:identifier>
</item>
<item>
<title>Java集合系列（一）List集合 - qingshanli</title>
<link>http://www.cnblogs.com/qingshanli/p/9572038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingshanli/p/9572038.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;List的几种实现的区别与联系&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;List主要有ArrayList、LinkedList与Vector几种实现。 &lt;/p&gt;
&lt;p&gt;ArrayList底层数据结构是数组, 增删慢、查询快; 线程不安全, 效率高; 不可以设置扩展容量, 默认增长1.5倍; 无参构造器初始化时, 初始容量为0。 &lt;/p&gt;
&lt;p&gt;LInkedList底层数据结构是链表, 增删快、查询慢; 线程不安全, 效率高。 &lt;/p&gt;
&lt;p&gt;Vector底层数据结构是数组, 增删慢、查询快; 线程安全, 效率低; 可以设置扩展容量, 默认增长2倍; 无参构造器初始化时, 初始容量为10。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;List转换及删除元素&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;数组转List 集合&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;对于一个数组, 可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;Arrays.asList(T... a)&lt;/span&gt; 方法转换成List集合, 需要注意的是, 此方法得到的ArrayList对象是基于Arrays内部类 &lt;span class=&quot;cnblogs_code&quot;&gt;java.util.Arrays$ArrayList&lt;/span&gt; 来创建的, 而非 &lt;span class=&quot;cnblogs_code&quot;&gt;java.util.ArrayList&lt;/span&gt; 。这就涉及到了一个问题, 通过 &lt;span class=&quot;cnblogs_code&quot;&gt;asList(T... a)&lt;/span&gt; 转换得到的List集合是不允许进行增删操作的, 我们先看如下代码: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; convertList() {
    List&lt;/span&gt;&amp;lt;String&amp;gt; list = Arrays.asList(&quot;张小凡&quot;, &quot;陆雪琪&quot;, &quot;碧瑶&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;list.add(&quot;qingshanli&quot;);&lt;/span&gt;
    list.remove(0&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行时会报异常 &lt;span class=&quot;cnblogs_code&quot;&gt;java.lang.UnsupportedOperationException&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201809/1278884-20180905115135923-395089872.png&quot; alt=&quot;&quot; width=&quot;780px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先来看看 &lt;span class=&quot;cnblogs_code&quot;&gt;java.util.Arrays$ArrayList&lt;/span&gt; 的方法层次结构: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201809/1278884-20180905145746927-502187948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出,  &lt;span class=&quot;cnblogs_code&quot;&gt;java.util.Arrays$ArrayList&lt;/span&gt; 并没有覆写父类&lt;/span&gt;AbstractList的 &lt;span class=&quot;cnblogs_code&quot;&gt;add()&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;remove()&lt;/span&gt; 方法, 根据Java的三大特性之多态性可知, 上面代码中的增删操作实际调用的是父类AbstractList的方法, 我们再来看看AbstractList的部分源代码: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此, 可以得知其实通过 &lt;span class=&quot;cnblogs_code&quot;&gt;Arrays.asList(T... a)&lt;/span&gt; 转换得到的List集合是一个固定长度的集合, 所以不能进行增删操作。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;如何在遍历时删除ArrayList中元素&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式一: 普通循环&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(List&amp;lt;Integer&amp;gt;&lt;span&gt; list) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.size(); i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.get(i) % 2 == 0&lt;span&gt;) {
            list.remove(list.get(i));
            i&lt;/span&gt;--; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 索引改变!&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式在删除操作时, 会改变集合的索引和size大小, 遍历时可能会产生角标越界异常, 因此不是特别推荐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式二: 高级for循环&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    List&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;){
        list.add(i);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Integer num : list) {
        System.out.print(&lt;/span&gt;&quot;value=&quot;+&lt;span&gt;num);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num % 2 == 0&lt;span&gt;) {
            list.remove(num);
            System.out.println(&lt;/span&gt;&quot; delete&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot; not delete&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果如下, 第一个元素删除正常, 后面继续遍历删除则抛异常 &lt;span class=&quot;cnblogs_code&quot;&gt;java.util.ConcurrentModificationException&lt;/span&gt; &lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201809/1278884-20180911223115267-190570545.png&quot; alt=&quot;&quot; width=&quot;780px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下, 反编译上述代码, 可以看出高级for循环底层其实就是使用iterator迭代器来进行遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    ArrayList&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; ++&lt;span&gt;i) {
        list.add(Integer.valueOf((&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)i));
    }
    Iterator i &lt;/span&gt;=&lt;span&gt; list.iterator();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (i.hasNext()) {
        Integer num &lt;/span&gt;=&lt;span&gt; (Integer)i.next();
        System.out.print((String)&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StringBuilder().append((String)&quot;value=&quot;&lt;span&gt;).append((Object)num).toString());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num.intValue() % 2 == 0&lt;span&gt;) {
            list.remove((Object)num);
            System.out.println((String)&lt;/span&gt;&quot; delete&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        System.out.println((String)&lt;/span&gt;&quot; not delete&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看iterator迭代器实现类的部分源代码: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b1cb2511-0b94-4f57-a17b-e89f231f906c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b1cb2511-0b94-4f57-a17b-e89f231f906c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b1cb2511-0b94-4f57-a17b-e89f231f906c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b1cb2511-0b94-4f57-a17b-e89f231f906c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b1cb2511-0b94-4f57-a17b-e89f231f906c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cursor;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of next element to return&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; lastRet = -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of last element returned; -1 if no such&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;

    Itr() {}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor !=&lt;span&gt; size;
    }

    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
        checkForComodification();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        Object[] elementData &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        cursor &lt;/span&gt;= i + 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) elementData[lastRet =&lt;span&gt; i];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
        checkForComodification();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ArrayList.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
            cursor &lt;/span&gt;=&lt;span&gt; lastRet;
            lastRet &lt;/span&gt;= -1&lt;span&gt;;
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; consumer) {
        Objects.requireNonNull(consumer);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object[] elementData = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i != size &amp;amp;&amp;amp; modCount ==&lt;span&gt; expectedModCount) {
            consumer.accept((E) elementData[i&lt;/span&gt;++&lt;span&gt;]);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; update once at end of iteration to reduce heap write traffic&lt;/span&gt;
        cursor =&lt;span&gt; i;
        lastRet &lt;/span&gt;= i - 1&lt;span&gt;;
        checkForComodification();
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;可以看出, 迭代器内部的每次遍历操作 &lt;span class=&quot;cnblogs_code&quot;&gt;next()&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;remove()&lt;/span&gt; 方法都会记录List集合内部的modCount当做预期值expectedModCount, 然后在每次循环中判断预期值expectedModCount与List的成员变量modCount是否相等。但是因为上面 &lt;span class=&quot;cnblogs_code&quot;&gt;list.remove()&lt;/span&gt; 调用的是List集合的 &lt;span class=&quot;cnblogs_code&quot;&gt;remove()&lt;/span&gt; 方法, 继续跟踪源代码发现每次调用该方法就会 &lt;span class=&quot;cnblogs_code&quot;&gt;modCount++;&lt;/span&gt; , 但是迭代器内记录的预期值expectedModCount并没有跟着改变, 所以当第二次删除操作时就会发生异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式三: iterator迭代器遍历&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(List&amp;lt;Integer&amp;gt; list) {&lt;/span&gt;&lt;span&gt;
    Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; it =&lt;span&gt; list.iterator();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; it.next();
        System.out.print(&lt;/span&gt;&quot;value=&quot;+&lt;span&gt;num);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num % 2 == 0&lt;span&gt;) {
            it.remove();
            System.out.println(&lt;/span&gt;&quot; delete&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot; not delete&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原理与方式二基本类似, 但是这里使用的是迭代器iterator的 &lt;span class=&quot;cnblogs_code&quot;&gt;remove()&lt;/span&gt; 方法, 我们再回顾之前迭代器实现类的源代码, 发现 &lt;span class=&quot;cnblogs_code&quot;&gt;remove()&lt;/span&gt; 方法中有 &lt;span class=&quot;cnblogs_code&quot;&gt;expectedModCount = modCount;&lt;/span&gt; 这个操作, 即调用迭代器的 &lt;span class=&quot;cnblogs_code&quot;&gt;remove()&lt;/span&gt; 方法时会同步List集合的modCount到迭代器的预期值expectedModCount当中, 所以迭代器方式删除才不会产生。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;什么是快速失败, 安全失败机制&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;快速失败(fail-fast)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;fail-fast机制是java集合中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。&lt;/p&gt;
&lt;p&gt;使用迭代器遍历一个集合对象时，如果遍历过程中对集合进行了增删改, 则会抛出 &lt;span class=&quot;cnblogs_code&quot;&gt;ConcurrentModificationException&lt;/span&gt; 。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Integer id : list) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id == 2&lt;span&gt;) {
        list.remove(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在前面我们已经介绍过, 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量来作为预期值expectedmodCount。集合在被遍历期间如果内容发生变化，就会改变集合内部的modCount值。每当迭代器使用而而迭代遍历调用 &lt;span class=&quot;cnblogs_code&quot;&gt;next()&lt;/span&gt; 方法时每次都会检测  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;if&lt;/span&gt;(modCount==expectedmodCount)&lt;/span&gt;  ，符合条件就返回遍历；否则将抛出异常终止遍历。&lt;/p&gt;
&lt;p&gt;如果集合发生变化时修改modCount值, 并且又同步到expectedmodCount预期值, 比如前文中提到的iterator迭代器的 &lt;span class=&quot;cnblogs_code&quot;&gt;remove()&lt;/span&gt; 方法, 异常则不会抛出。因此, 不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。另外, 在java.util包下的集合类都是快速失败的, 是不能在多线程下发生并发修改的(即迭代过程中被修改)。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安全失败(fail-safe)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是在开始遍历时先复制原有集合内容，在拷贝的集合上进行遍历, 即在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。java.util.concurrent包下的容器都是安全失败的, 可以在多线程下并发修改。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;对象排序&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实体类自身具备排序能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Comparable接口用于使某个类具备可排序能力。实体类实现该接口后覆写其 &lt;span class=&quot;cnblogs_code&quot;&gt;compareTo()&lt;/span&gt; 方法，即可使实体类自身具备可排序的能力 。代码清单如下: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;implements&lt;/span&gt; Comparable&amp;lt;Student&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Student o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flag = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.compareTo(o.name);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag == 0&lt;span&gt;) {
            flag &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.age -&lt;span&gt; o.age;
        } 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实体类具备了排序能力后, 调用List集合的 &lt;span class=&quot;cnblogs_code&quot;&gt;sort(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt; c)&lt;/span&gt; 或者Collections工具类的 &lt;span class=&quot;cnblogs_code&quot;&gt;sort(List&amp;lt;T&amp;gt; list)&lt;/span&gt; 方法即可实现排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
List&amp;lt;Student&amp;gt; list = new ArrayList&amp;lt;Student&amp;gt;();&lt;br/&gt;list.sort(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Collections.sort(list);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;使用比较器排序&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Comparator是一个比较器接口，可以用来给不具备排序能力的对象进行排序。实现该比较器需覆写其 &lt;span class=&quot;cnblogs_code&quot;&gt;compare()&lt;/span&gt; 方法即可进行排序, 代码清单如下:&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
｝

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StudentComparator &lt;span&gt;implements&lt;/span&gt; Comparator&amp;lt;Student&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Student o1, Student o2) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flag =&lt;span&gt; o1.getName().compareTo(o2.getName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag == 0&lt;span&gt;) {
            flag &lt;/span&gt;= o1.getAge() -&lt;span&gt; o2.getAge();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sortTest() {
        List&lt;/span&gt;&amp;lt;student&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Student&amp;gt;&lt;span&gt;();
　      list.sort(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StudentComparator());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Collections.sort(list, new StudentComparator());&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/1776&quot; target=&quot;_blank&quot;&gt;java中的增强for循环的实现原理与坑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/33&quot; target=&quot;_blank&quot;&gt;Java中的fail-fast机制&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 17:30:00 +0000</pubDate>
<dc:creator>qingshanli</dc:creator>
<og:description>List的几种实现的区别与联系 List主要有ArrayList、LinkedList与Vector几种实现。 ArrayList底层数据结构是数组, 增删慢、查询快; 线程不安全, 效率高; 不可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingshanli/p/9572038.html</dc:identifier>
</item>
<item>
<title>HBase Region合并分析 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/9649673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/9649673.html</guid>
<description>&lt;p&gt;HBase中表的基本单位是Region，日常在调用HBase API操作一个表时，交互的数据也会以Region的形式进行呈现。一个表可以有若干个Region，今天笔者就来和大家分享一下Region合并的一些问题和解决方法。&lt;/p&gt;

&lt;p&gt;在分析合并Region之前，我们先来了解一下Region的体系结构，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201809/666745-20180914233752662-2123317375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可知，能够总结以下知识点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HRegion：一个Region可以包含多个Store；&lt;/li&gt;
&lt;li&gt;Store：每个Store包含一个Memstore和若干个StoreFile；&lt;/li&gt;
&lt;li&gt;StoreFile：表数据真实存储的地方，HFile是表数据在HDFS上的文件格式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果要查看HFile文件，HBase有提供命令，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
hbase hfile -p -f /hbase/data/default/ip_login/d0d7d881bb802592c09d305e47ae70a5/_d/7ec738167e9f4d4386316e5e702c8d3d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出结果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201809/666745-20180914235115801-1827247421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.1 为什么需要合并Region&lt;/h2&gt;
&lt;p&gt;那为什么需要合并Region呢？这个需要从Region的Split来说。当一个Region被不断的写数据，达到Region的Split的阀值时（由属性hbase.hregion.max.filesize来决定，默认是10GB），该Region就会被Split成2个新的Region。随着业务数据量的不断增加，Region不断的执行Split，那么Region的个数也会越来越多。&lt;/p&gt;
&lt;p&gt;一个业务表的Region越多，在进行读写操作时，或是对该表执行Compaction操作时，此时集群的压力是很大的。这里笔者做过一个线上统计，在一个业务表的Region个数达到9000+时，每次对该表进行Compaction操作时，集群的负载便会加重。而间接的也会影响应用程序的读写，一个表的Region过大，势必整个集群的Region个数也会增加，负载均衡后，每个RegionServer承担的Region个数也会增加。&lt;/p&gt;
&lt;p&gt;因此，这种情况是很有必要的进行Region合并的。比如，当前Region进行Split的阀值设置为30GB，那么我们可以对小于等于10GB的Region进行一次合并，减少每个业务表的Region，从而降低整个集群的Region，减缓每个RegionServer上的Region压力。&lt;/p&gt;
&lt;h2&gt;2.2 如何进行Region合并&lt;/h2&gt;
&lt;p&gt;那么我们如何进行Region合并呢？HBase有提供一个合并Region的命令，具体操作如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 合并相邻的两个Region
hbase&lt;/span&gt;&amp;gt; merge_region &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ENCODED_REGIONNAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ENCODED_REGIONNAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
# 强制合并两个Region
hbase&lt;/span&gt;&amp;gt; merge_region &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ENCODED_REGIONNAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ENCODED_REGIONNAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，这种方式会有一个问题，就是只能一次合并2个Region，如果这里有几千个Region需要合并，这种方式是不可取的。&lt;/p&gt;
&lt;h3&gt;2.2.1 批量合并&lt;/h3&gt;
&lt;p&gt;这里有一种批量合并的方式，就是通过编写脚本（merge_small_regions.rb）来实现，实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Test Mode:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; hbase org.jruby.Main merge_empty_regions.rb namespace.tablename &amp;lt;skip_size&amp;gt; &amp;lt;batch_regions&amp;gt; &amp;lt;merge?&amp;gt;&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; Non Test - ie actually do the merge:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; hbase org.jruby.Main merge_empty_regions.rb namespace.tablename &amp;lt;skip_size&amp;gt; &amp;lt;batch_regions&amp;gt; merge&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; Note: Please replace namespace.tablename with your namespace and table, eg NS1.MyTable. This value is case sensitive.&lt;/span&gt;
&lt;span&gt;
require &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;digest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
require &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
java_import org.apache.hadoop.hbase.HBaseConfiguration
java_import org.apache.hadoop.hbase.client.HBaseAdmin
java_import org.apache.hadoop.hbase.TableName
java_import org.apache.hadoop.hbase.HRegionInfo;
java_import org.apache.hadoop.hbase.client.Connection
java_import org.apache.hadoop.hbase.client.ConnectionFactory
java_import org.apache.hadoop.hbase.client.Table
java_import org.apache.hadoop.hbase.util.Bytes

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; list_bigger_regions(admin, table, low_size)
  cluster_status &lt;/span&gt;=&lt;span&gt; admin.getClusterStatus()
  master &lt;/span&gt;=&lt;span&gt; cluster_status.getMaster()
  biggers &lt;/span&gt;=&lt;span&gt; []
  cluster_status.getServers.each do &lt;/span&gt;|s|&lt;span&gt;
    cluster_status.getLoad(s).getRegionsLoad.each do &lt;/span&gt;|r|
      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; getRegionsLoad returns an array of arrays, where each array&lt;/span&gt;
      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; is 2 elements&lt;/span&gt;

      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Filter out any regions that don't match the requested&lt;/span&gt;
      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; tablename&lt;/span&gt;
      next unless r[1].get_name_as_string =~ /&lt;span&gt;#&lt;/span&gt;&lt;span&gt;{table}\,/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; r[1].getStorefileSizeMB() &amp;gt;&lt;span&gt; low_size
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; r[1].get_name_as_string =~ /\.([^\.]+)\.$/&lt;span&gt;
          biggers.push $&lt;/span&gt;1
        &lt;span&gt;else&lt;/span&gt;
          &lt;span&gt;raise&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed to get the encoded name for #{r[1].get_name_as_string}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        end
      end
    end
  end
  biggers
end

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Handle command line parameters&lt;/span&gt;
table_name =&lt;span&gt; ARGV[0]
low_size &lt;/span&gt;= 1024
&lt;span&gt;if&lt;/span&gt; ARGV[1].to_i &amp;gt;=&lt;span&gt; low_size
  low_size&lt;/span&gt;=ARGV[1&lt;span&gt;].to_i
end

limit_batch &lt;/span&gt;= 1000
&lt;span&gt;if&lt;/span&gt; ARGV[2].to_i &amp;lt;=&lt;span&gt; limit_batch
  limit_batch &lt;/span&gt;= ARGV[2&lt;span&gt;].to_i
end
do_merge &lt;/span&gt;=&lt;span&gt; false
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ARGV[3] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;merge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  do_merge &lt;/span&gt;=&lt;span&gt; true
end

config &lt;/span&gt;=&lt;span&gt; HBaseConfiguration.create();
connection &lt;/span&gt;=&lt;span&gt; ConnectionFactory.createConnection(config);
admin &lt;/span&gt;=&lt;span&gt; HBaseAdmin.new(connection);

bigger_regions &lt;/span&gt;=&lt;span&gt; list_bigger_regions(admin, table_name, low_size)
regions &lt;/span&gt;=&lt;span&gt; admin.getTableRegions(Bytes.toBytes(table_name));

puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Total Table Regions: #{regions.length}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Total bigger regions: #{bigger_regions.length}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

filtered_regions &lt;/span&gt;= regions.reject do |r|&lt;span&gt;
  bigger_regions.include?(r.get_encoded_name)
end

puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Total regions to consider for Merge: #{filtered_regions.length}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

filtered_regions_limit &lt;/span&gt;=&lt;span&gt; filtered_regions

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; filtered_regions.length &amp;lt; 2&lt;span&gt;
  puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;There are not enough regions to merge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  filtered_regions_limit &lt;/span&gt;=&lt;span&gt; filtered_regions
end

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; filtered_regions.length &amp;gt;&lt;span&gt; limit_batch
   filtered_regions_limit &lt;/span&gt;=&lt;span&gt; filtered_regions[0,limit_batch]
   puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;But we will merge : #{filtered_regions_limit.length} regions because limit in parameter!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
end


r1, r2 &lt;/span&gt;=&lt;span&gt; nil
filtered_regions_limit.each do &lt;/span&gt;|r|
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; r1.nil?
    r1 &lt;/span&gt;=&lt;span&gt; r
    next
  end
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; r2.nil?
    r2 &lt;/span&gt;=&lt;span&gt; r
  end
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Skip any region that is a split region&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; r1.is_split()
    r1 &lt;/span&gt;=&lt;span&gt; r2
    r2 &lt;/span&gt;=&lt;span&gt; nil
  puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Skip #{r1.get_encoded_name} bcause it in spliting!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    next
  end
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; r2.is_split()
    r2 &lt;/span&gt;=&lt;span&gt; nil
 puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Skip #{r2.get_encoded_name} bcause it in spliting!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    next
  end
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; HRegionInfo.are_adjacent(r1, r2)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; only merge regions that are adjacent&lt;/span&gt;
    puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{r1.get_encoded_name} is adjacent to #{r2.get_encoded_name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; do_merge
      admin.mergeRegions(r1.getEncodedNameAsBytes, r2.getEncodedNameAsBytes, false)
      puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Successfully Merged #{r1.get_encoded_name} with #{r2.get_encoded_name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      sleep &lt;/span&gt;2&lt;span&gt;
    end
    r1, r2 &lt;/span&gt;=&lt;span&gt; nil
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    puts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Regions are not adjacent, so drop the first one and with the #{r2.get_encoded_name} to  iterate again&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    r1 &lt;/span&gt;=&lt;span&gt; r2
    r2 &lt;/span&gt;=&lt;span&gt; nil
  end
end
admin.close&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该脚本默认是合并1GB以内的Region，个数为1000个。如果我们要合并小于10GB，个数在4000以内，脚本（merging-region.sh）如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /bin/bash&lt;/span&gt;
&lt;span&gt;
num&lt;/span&gt;=$1&lt;span&gt;

echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[`date &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+%Y-%m-%d %H:%M:%S&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`] INFO : RegionServer Start Merging...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ ! -n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]; then
    echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[`date &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+%Y-%m-%d %H:%M:%S&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`] INFO : Default Merging 10 Times.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    num&lt;/span&gt;=10
&lt;span&gt;elif&lt;/span&gt; [[ $num == *[!0-9]*&lt;span&gt; ]]; then
    echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[`date &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+%Y-%m-%d %H:%M:%S&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`] INFO : Input [$num] Times Must Be Number.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    exit &lt;/span&gt;1
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[`date &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+%Y-%m-%d %H:%M:%S&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`] INFO : User-Defined Merging [$num] Times.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
fi

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (( i=1; i&amp;lt;=$num; i++&lt;span&gt; ))
do
    echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[`date &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+%Y-%m-%d %H:%M:%S&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`] INFO : Merging [$i] Times,Total [$num] Times.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    hbase org.jruby.Main merge_small_regions.rb namespace.tablename &lt;/span&gt;10240  4000&lt;span&gt; merge
    sleep &lt;/span&gt;5&lt;span&gt;
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在merging-region.sh脚本中，做了参数控制，可以循环来执行批量合并脚本。可能在实际操作过程中，批量执行一次Region合并，合并后的结果Region还是有很多（可能此时又有新的Region生成），这是我们可以使用merging-region.sh这个脚本多次执行批量合并Region操作，具体操作命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认循环10次，例如本次循环执行5次&lt;/span&gt;
sh merging-region.sh 5
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3 如果在合并Region的过程中出现永久RIT怎么办&lt;/h2&gt;
&lt;p&gt;在合并Region的过程中出现永久RIT怎么办？笔者在生产环境中就遇到过这种情况，在批量合并Region的过程中，出现了永久MERGING_NEW的情况，虽然这种情况不会影响现有集群的正常的服务能力，但是如果集群有某个节点发生重启，那么可能此时该RegionServer上的Region是没法均衡的。因为在RIT状态时，HBase是不会执行Region负载均衡的，即使手动执行balancer命令也是无效的。&lt;/p&gt;
&lt;p&gt;如果不解决这种RIT情况，那么后续有HBase节点相继重启，这样会导致整个集群的Region验证不均衡，这是很致命的，对集群的性能将会影响很大。经过查询HBase JIRA单，发现这种MERGING_NEW永久RIT的情况是触发了&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-17682&quot; target=&quot;_blank&quot;&gt;HBASE-17682&lt;/a&gt;的BUG，需要打上该Patch来修复这个BUG，其实就是HBase源代码在判断业务逻辑时，没有对MERGING_NEW这种状态进行判断，直接进入到else流程中了。源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RegionState state : regionsInTransition.values()) {
        HRegionInfo hri &lt;/span&gt;=&lt;span&gt; state.getRegion();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (assignedRegions.contains(hri)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Region is open on this region server, but in transition.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This region must be moving away from this server, or splitting/merging.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SSH will handle it, either skip assigning, or re-assign.&lt;/span&gt;
          LOG.info(&quot;Transitioning &quot; + state + &quot; will be handled by ServerCrashProcedure for &quot; +&lt;span&gt; sn);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sn.equals(state.getServerName())) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Region is in transition on this region server, and this
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; region is not open on this server. So the region must be
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; moving to this server from another one (i.e. opening or
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pending open on this server, was open on another one.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Offline state is also kind of pending open if the region is in
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; transition. The region could be in failed_close state too if we have
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tried several times to open it while this region server is not reachable)&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (state.isPendingOpenOrOpening() || state.isFailedClose() ||&lt;span&gt; state.isOffline()) {
            LOG.info(&lt;/span&gt;&quot;Found region in &quot; + state +
              &quot; to be reassigned by ServerCrashProcedure for &quot; +&lt;span&gt; sn);
            rits.add(hri);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(state.isSplittingNew()) {
            regionsToCleanIfNoMetaEntry.add(state.getRegion());
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            LOG.warn(&lt;/span&gt;&quot;THIS SHOULD NOT HAPPEN: unexpected &quot; +&lt;span&gt; state);
          }
        }
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修复之后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RegionState state : regionsInTransition.values()) {
        HRegionInfo hri &lt;/span&gt;=&lt;span&gt; state.getRegion();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (assignedRegions.contains(hri)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Region is open on this region server, but in transition.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This region must be moving away from this server, or splitting/merging.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SSH will handle it, either skip assigning, or re-assign.&lt;/span&gt;
          LOG.info(&quot;Transitioning &quot; + state + &quot; will be handled by ServerCrashProcedure for &quot; +&lt;span&gt; sn);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sn.equals(state.getServerName())) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Region is in transition on this region server, and this
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; region is not open on this server. So the region must be
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; moving to this server from another one (i.e. opening or
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pending open on this server, was open on another one.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Offline state is also kind of pending open if the region is in
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; transition. The region could be in failed_close state too if we have
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tried several times to open it while this region server is not reachable)&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (state.isPendingOpenOrOpening() || state.isFailedClose() ||&lt;span&gt; state.isOffline()) {
            LOG.info(&lt;/span&gt;&quot;Found region in &quot; + state +
              &quot; to be reassigned by ServerCrashProcedure for &quot; +&lt;span&gt; sn);
            rits.add(hri);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(state.isSplittingNew()) {
            regionsToCleanIfNoMetaEntry.add(state.getRegion());
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isOneOfStates(state, State.SPLITTING_NEW, State.MERGING_NEW)) {
             regionsToCleanIfNoMetaEntry.add(state.getRegion());
           }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            LOG.warn(&lt;/span&gt;&quot;THIS SHOULD NOT HAPPEN: unexpected &quot; +&lt;span&gt; state);
          }
        }
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，这里有一个问题，目前该JIRA单只是说了需要去修复BUG，打Patch。但是，实际生产情况下，面对这种RIT情况，是不可能长时间停止集群，影响应用程序读写的。那么，有没有临时的解决办法，先临时解决当前的MERGING_NEW这种永久RIT，之后在进行HBase版本升级操作。&lt;/p&gt;
&lt;p&gt;办法是有的，在分析了MERGE合并的流程之后，发现HBase在执行Region合并时，会先生成一个初始状态的MERGING_NEW。整个Region合并流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201809/666745-20180915005012866-810082209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从流程图中可以看到，MERGING_NEW是一个初始化状态，在Master的内存中，而处于Backup状态的Master内存中是没有这个新Region的MERGING_NEW状态的，那么可以通过对HBase的Master进行一个主备切换，来临时消除这个永久RIT状态。而HBase是一个高可用的集群，进行主备切换时对用户应用来说是无感操作。因此，面对MERGING_NEW状态的永久RIT可以使用对HBase进行主备切换的方式来做一个临时处理方案。之后，我们在对HBase进行修复BUG，打Patch进行版本升级。&lt;/p&gt;

&lt;p&gt;HBase的RIT问题，是一个比较常见的问题，在遇到这种问题时，可以先冷静的分析原因，例如查看Master的日志、仔细阅读HBase Web页面RIT异常的描述、使用hbck命令查看Region、使用fsck查看HDFS的block等。分析出具体的原因后，我们在对症下药，做到大胆猜想，小心求证。&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《Hadoop大数据挖掘从入门到进阶实战》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 16:59:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<og:description>1.概述 HBase中表的基本单位是Region，日常在调用HBase API操作一个表时，交互的数据也会以Region的形式进行呈现。一个表可以有若干个Region，今天笔者就来和大家分享一下Reg</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smartloli/p/9649673.html</dc:identifier>
</item>
<item>
<title>IDEAL葵花宝典：java代码开发规范插件 checkstyle、visualVM、PMD 插件 - 果冻不丁</title>
<link>http://www.cnblogs.com/mlq2017/p/9649584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mlq2017/p/9649584.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;visualVM：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;运行&lt;/span&gt;java程序的时候启动visualvm，方便查看jvm的情况 比如堆内存大小的分配；&lt;span&gt;某个对象占用了多大的内存，&lt;/span&gt;jvm调优必备工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;checkstyle：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;CheckStyle是SourceForge下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　它能够自动化代码规范检查过程，从而使得开发人员从这项重要，但是枯燥的任务中解脱出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;CheckStyle检验的主要内容：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;span&gt;1）：Javadoc注释；   2）：&lt;/span&gt;&lt;span&gt;命名约定；   3）：&lt;/span&gt;&lt;span&gt;·标题      4）： &lt;/span&gt;&lt;span&gt;Import语句 ；  5）：&lt;/span&gt;&lt;span&gt;体积大小；    &lt;/span&gt;&lt;span&gt;6）：空白；   7）：&lt;/span&gt;&lt;span&gt;修饰符；   8）：&lt;/span&gt;&lt;span&gt;块；   9）：&lt;/span&gt;&lt;span&gt;代码问题；   10）：&lt;/span&gt;&lt;span&gt;类设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　混合检查（包括一些有用的比如非必须的System.out和printstackTrace）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从上面可以看出，CheckStyle提供了大部分功能都是对于代码规范的检查，而没有提供像PMD和Jalopy那么多的增强代码质量和修改代码的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是，对于团队开发，尤其是强调代码规范的公司来说，它的功能已经足够强大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PMD：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　&lt;strong&gt;&lt;span&gt;　PMD是扫描 Java 源码并查找以下潜在问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;　　1）：从未用过的局部变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  2）：空捕捉块（catch block）　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  3）：从未用过的参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　     4）：空if声明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　     5）：重复的导入声明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　     6）：从未用过的私有方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            7）：孤立的类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　     8）：短型或长型变量及方法名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　PMD 具有下列软件的插件：JEdit, JBuilder, NetBeans/Sun ONE Studio, IntelliJ IDEA, TextPad, Maven, Ant, Eclipse, Gel, Emacs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　PMD 的含义：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　坦率地说，我们其实也不知道PMD的真正意义所在 (我们只是认为这三个字母拼在一起较为好听) 。但是，我们提出了计算行业的几种解释以供参考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　PMD:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Pretty Much Done （几乎无所不能）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Project Mess Detector （项目故障探测器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Project Monitoring Directives （项目监视器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Protein Mutant Database （基因突变数据库）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Project Meets Deadline （项目到期）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Programming Mistake Detector （程序错误检测器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Pounds Mistakes Dead （彻底纠错）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　PMD Meaning Discovery （PMD含义探索）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　PMD运行机制：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　PMD 根据规则核对源码并产生一个报告。具体如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　有文件名和RuleSet传入PMD ；&lt;/span&gt;&lt;span&gt;PMD将通过该文件的InputStream传递给由JavaCC-生成的解析器 ；&lt;/span&gt;&lt;span&gt;PMD 从解析器取得指向抽象语法树（AST）的引用；&lt;/span&gt;&lt;span&gt;RuleSet 中的每个规则都遍历AST 并检查错误 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　   报告内容包括RuleViolations以及符合XML 、HTML 或其它格式的代码/文件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915001317108-2070695712.png&quot; alt=&quot;&quot; width=&quot;927&quot; height=&quot;530&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里我们默认已经完成了3个插件的安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;checkstyle,PMD,都可以直接使用，但VsiualVM需要配合客户端来完成配置和使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面先去官网下载VisualVM的客户端。&lt;/span&gt;&lt;/strong&gt;&lt;a href=&quot;https://visualvm.github.io/download.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;VisualVM官网链接&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置连接过程如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915001429763-842983149.png&quot; alt=&quot;&quot; width=&quot;746&quot; height=&quot;555&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在打开的页面内选择已经解压好的文件夹中的bin文件夹内的&quot;VisualVM.exe&quot;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1）：在代码编辑区点击右键，如图选择&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915001554191-825162064.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;487&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 这时会触发VisualVM客户端，可以观察项目内的性能使用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915002119453-1468637006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915002623330-1642591629.png&quot; alt=&quot;&quot; width=&quot;820&quot; height=&quot;540&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1）：.安装完之后，我们打开checkstyles，点击绿色箭头&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915002954939-408750491.png&quot; alt=&quot;&quot; width=&quot;1059&quot; height=&quot;329&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）：出现提示&quot;No rules file has been configured&quot;，这是提醒我们没有为其指定配置文件，它不知道应该按照什么标准来评判代码的风格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）：解决办法：打开settings-&amp;gt;Other Settings-&amp;gt;Checkstyle ，选定默认的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; ----------------------  后续补全  ----------------------&lt;/p&gt;



&lt;p&gt;&lt;span&gt; 1）：在代码编辑区点击右键，根据项目不同选择不同的检查规则集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915004405850-38831711.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;525&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2）：在下方按照不同规则集显示出不同位置的错误，通过规则名就可以得知代码的问题类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201809/1216893-20180915004633934-1894865699.png&quot; alt=&quot;&quot; width=&quot;958&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;--------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上内容若有不足之处：请多多请教&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如要转载请注明小编本站地址：（https://www.cnblogs.com/mlq2017/）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 14 Sep 2018 16:48:00 +0000</pubDate>
<dc:creator>果冻不丁</dc:creator>
<og:description>前言： visualVM： 运行java程序的时候启动visualvm，方便查看jvm的情况 比如堆内存大小的分配；某个对象占用了多大的内存，jvm调优必备工具。 checkstyle： CheckS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mlq2017/p/9649584.html</dc:identifier>
</item>
<item>
<title>残差网络（Residual Networks, ResNets） - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/9560205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/9560205.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1. 什么是残差（residual）？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　“残差在数理统计中是指实际观察值与估计值（拟合值）之间的差。”“如果回归模型正确的话， 我们可以将残差看作误差的观测值。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更准确地，假设我们想要找一个 $x$，使得 $f(x) = b$，给定一个 $x$ 的估计值 $x_0$，残差（residual）就是 $b-f(x_0)$，同时，误差就是 $x-x_0$。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　即使 $x$ 不知道，我们仍然可以计算残差，只是不能计算误差罢了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2. 什么是残差网络（Residual Networks，ResNets）？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在了解残差网络之前，先了解下面这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Q1：神经网络越深越好吗？（Deeper is better？）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　A1：如图 1 所示，在训练集上，传统神经网络越深效果不一定越好。而 &lt;/span&gt;&lt;a href=&quot;https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/He_Deep_Residual_Learning_CVPR_2016_paper.pdf&quot; target=&quot;_blank&quot;&gt;Deep Residual Learning for Image Recognition&lt;/a&gt; 这篇论文认为，理论上，可以训练一个 shallower 网络，然后在这个训练好的 shallower 网络上堆几层 identity mapping（恒等映射） 的层，即输出等于输入的层，构建出一个 deeper 网络。这两个网络（shallower 和 deeper）得到的结果应该是一模一样的，因为堆上去的层都是 identity mapping。这样可以得出一个结论：&lt;strong&gt;理论上，在训练集上，&lt;/strong&gt;&lt;strong&gt;Deeper 不应该比 shallower 差，即越深的网络不会比浅层的网络效果差&lt;/strong&gt;。但为什么会出现图 1 这样的情况呢，随着层数的增多，训练集上的效果变差？这被称为&lt;strong&gt;退化问题（degradation problem）&lt;/strong&gt;，原因是随着网络越来越深，训练变得原来越难，网络的优化变得越来越难。理论上，越深的网络，效果应该更好；但实际上，由于训练难度，过深的网络会产生退化问题，效果反而不如相对较浅的网络。而残差网络就可以解决这个问题的，残差网络越深，训练集上的效果会越好。（测试集上的效果可能涉及过拟合问题。过拟合问题指的是测试集上的效果和训练集上的效果之间有差距。）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180830145321253-738009854.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;278&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 1 不同深度的传统神经网络效果对比图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（“plain” network指的是没有使用 shortcut connection 的网络）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　残差网络通过加入 shortcut connections，变得更加容易被优化。包含一个 shortcut connection 的几层网络被称为一个残差块（residual block），如图 2 所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201809/1351564-20180914164307733-889668964.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 2 残差块&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　2.1 残差块（residual block）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　如图 2 所示，$x$ 表示输入，$F(x)$ 表示残差块在第二层激活函数之前的输出，即 $F(x) = W_2\sigma(W_1x)$，其中 $W_1$ 和 $W_2$ 表示第一层和第二层的权重，$\sigma$ 表示 ReLU 激活函数。（这里省略了 bias。）最后残差块的输出是 $\sigma(F(x) + x)$。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当没有 shortcut connection（即图 2 右侧从 $x$ 到 $\bigoplus$ 的箭头）时，残差块就是一个普通的 2 层网络。残差块中的网络可以是全连接层，也可以是卷积层。设第二层网络在激活函数之前的输出为 $H(x)$。如果在该 2 层网络中，最优的输出就是输入 $x$，那么对于没有 shortcut connection 的网络，就需要将其优化成 $H(x) = x$；对于有 shortcut connection 的网络，即残差块，最优输出是 $x$，则只需要将 $F(x) = H(x) - x$ 优化为 0 即可。后者的优化会比前者简单。这也是残差这一叫法的由来。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　2.2 残差网络举例&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　图 3 最右侧就是就是一个残差网络。34-layer 表示含可训练参数的层数为34层，池化层不含可训练参数。图 3 右侧所示的残差网络和中间部分的 plain network 唯一的区别就是 shortcut connections。这两个网络都是当 feature map 减半时，filter 的个数翻倍，这样保证了每一层的计算复杂度一致。&lt;/p&gt;
&lt;p&gt;　　ResNet 因为使用 identity mapping，在 shortcut connections 上没有参数，所以图 3 中 plain network 和 residual network 的计算复杂度都是一样的，都是 3.6 billion FLOPs.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201809/1351564-20180914215730350-1510947672.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;1169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 3  VGG-19、plain network、ResNet&lt;/p&gt;
&lt;p&gt;　　残差网络可以不是卷积神经网络，用全连接层也可以。当然，残差网络在被提出的论文中是用来处理图像识别问题。&lt;/p&gt;
&lt;h3&gt;　　2.3 为什么残差网络会work？&lt;/h3&gt;
&lt;p&gt;　　我们给一个网络不论在中间还是末尾加上一个残差块，并给残差块中的 weights 加上 L2 regularization（weight decay），这样图 1 中 $F(x) = 0$ 是很容易的。这种情况下加上一个残差块和不加之前的效果会是一样，所以加上残差块不会使得效果变得差。如果残差块中的隐藏单元学到了一些有用信息，那么它可能比 identity mapping（即 $F(x) = 0$）表现的更好。&lt;/p&gt;
&lt;p&gt;　　&quot;The main reason the residual network works is that it's so easy for these extra layers to learn the identity function that you're kind of guaranteed that it doesn't hurt performance. And then lot of time you maybe get lucky and even helps performance, or at least is easier to go from a decent baseline of not hurting performance, and then creating the same can only improve the solution from there.&quot;&lt;/p&gt;

</description>
<pubDate>Fri, 14 Sep 2018 16:20:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>在训练集上，神经网络越深，效果会越好吗？理论上是的，但传统神经网络做不到这一点。在神经网络的深度达到一定时，在训练集上，越深的网络效果可能越差，这就是退化问题。而ResNet可以处理这个问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/9560205.html</dc:identifier>
</item>
<item>
<title>细说移动端 经典的REM布局 与 新秀VW布局 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/9648233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/9648233.html</guid>
<description>&lt;p&gt;和以往一样，本次项目也放到了 &lt;a href=&quot;https://github.com/imwtr/rem-vw-layout&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt; 中，欢迎围观 star ~&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s1&quot; target=&quot;_parent&quot;&gt;1. 前言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s2&quot; target=&quot;_parent&quot;&gt;2. 基本概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s3&quot; target=&quot;_parent&quot;&gt;3. REM布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s4&quot; target=&quot;_parent&quot;&gt;4. VW布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s4-1&quot; target=&quot;_parent&quot;&gt;实现单边边框1px&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s4-1&quot; target=&quot;_parent&quot;&gt;实现多边边框1px&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s4-1&quot; target=&quot;_parent&quot;&gt;实现边框圆角&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s4-2&quot; target=&quot;_parent&quot;&gt;实现容器固定纵横比&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s5&quot; target=&quot;_parent&quot;&gt;5. REM + VW布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s6&quot; target=&quot;_parent&quot;&gt;6. 对比选择&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s6-1&quot; target=&quot;_parent&quot;&gt;方案选择&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9648233.html#s6-2&quot; target=&quot;_parent&quot;&gt;食用方式&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;说到前端页面的布局方案，可以从远古时代的Table布局说起，然后来到 DIV+CSS布局，之后有了Float布局，Flex布局，Column布局，Grid布局等等。&lt;/p&gt;
&lt;p&gt;而另一方面，还有一些 &lt;a href=&quot;https://www.cnblogs.com/zhuzhenwei918/p/7147303.html&quot; target=&quot;_blank&quot;&gt;布局概念&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 静态布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用px作为单位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 流式布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;宽度使用%百分比，高度使用px作为单位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 自适应布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。使用 @media媒体查询来切换多个布局&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 响应式布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 弹性布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常指的是rem或em布局。rem是相对于html元素的font-size大小而言的，而em是相对于其父元素（非font-size的是相对于自身的font-size）&lt;/p&gt;

&lt;p&gt;本文不对这些概念做太多的解释说明，主要记录一下整理过程中比较重要的点&lt;/p&gt;
&lt;p&gt;如今移动端布局中免不了要支持高清设备，机型也比较复杂，需要一套比较完善的布局方案来支持（在整体结构上解决多设备宽的适配问题）。&lt;/p&gt;
&lt;p&gt;淘宝的 &lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot;&gt;Flexible&lt;/a&gt; 让REM布局得以流行开来，而此Flexible实现也有一些不足，此外，也涌现出了多种实现REM布局的方案&lt;/p&gt;
&lt;p&gt;比如直接使用  html{ font-size:625%; } 基准值，配合JS来设置根元素字体大小&lt;/p&gt;
&lt;p&gt;或者使用媒体查询来设置根元素字体大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　@media screen and (min-width: 320px) &lt;/span&gt;{&lt;span&gt;
        html,body,button,input,select,textarea {
            font-size&lt;/span&gt;:&lt;span&gt;12px!important&lt;/span&gt;;
        }&lt;span&gt;
    }

    @media screen and (min-width: 374px) &lt;/span&gt;{&lt;span&gt;
        html,body,button,input,select,textarea {
            font-size&lt;/span&gt;:&lt;span&gt;14px!important&lt;/span&gt;;
        }&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但使用rem来布局的方案并不太正统，它有一些hack的特点&lt;/p&gt;
&lt;p&gt;比较规范的方式是使用vw单位，随之而来的就是后起之秀 VW布局&lt;/p&gt;

&lt;p&gt;花了一些时间整理了REM布局和VW布局在实际页面中是如何运用的，如果你有兴趣，就往下看吧~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/imwtr/rem-vw-layout&quot; target=&quot;_blank&quot;&gt;项目地址&lt;/a&gt;，欢迎围观~&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、基本概念&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;物理像素(physical pixel)&lt;/h4&gt;
&lt;p&gt;物理像素又被称为设备像素，它是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。&lt;/p&gt;
&lt;h4&gt;设备独立像素(density-independent pixel)&lt;/h4&gt;
&lt;p&gt;设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。&lt;/p&gt;
&lt;h4&gt;CSS像素&lt;/h4&gt;
&lt;p&gt;CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。&lt;/p&gt;
&lt;h4&gt;屏幕密度&lt;/h4&gt;
&lt;p&gt;屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。&lt;/p&gt;
&lt;h4&gt;设备像素比(device pixel ratio)&lt;/h4&gt;
&lt;p&gt;设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
设备像素比 ＝ 物理像素 / 设备独立像素
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Javascript中，可以通过 &lt;code&gt;window.devicePixelRatio &lt;/code&gt;获取到当前设备的dpr。&lt;/p&gt;
&lt;p&gt;在css中，可以通过 &lt;code&gt;-webkit-device-pixel-ratio&lt;/code&gt;，&lt;code&gt;-webkit-min-device-pixel-ratio&lt;/code&gt;和 &lt;code&gt;-webkit-max-device-pixel-ratio&lt;/code&gt;进行媒体查询，对不同dpr的设备，做一些样式适配。&lt;/p&gt;
&lt;p&gt;或者使用 resolution | min-resolution | max-resolution 这些比较新的标准方式&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914163705231-1744908517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中， Retina为高清设备屏幕，它的一个css像素对应 了4个物理像素&lt;/p&gt;

&lt;h5&gt;位图像素&lt;/h5&gt;
&lt;p&gt;一个位图像素是栅格图像(如：png, jpg, gif等)最小的数据单元。每一个位图像素都包含着一些自身的显示信息(如：显示位置，颜色值，透明度等)。&lt;/p&gt;
&lt;p&gt;理论上，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914164215349-710953104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图：对于dpr=2的retina屏幕而言，1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，从而导致图片模糊(注意上述的几个颜色值)。&lt;/p&gt;
&lt;p&gt;所以，对于图片高清问题，比较好的方案就是&lt;code&gt;两倍图片&lt;/code&gt;(@2x)。&lt;/p&gt;
&lt;p&gt;如：200×300(css pixel)img标签，就需要提供400×600的图片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缩放比 scale&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缩放比：scale = 1/dpr&lt;/p&gt;
&lt;h4&gt;视窗 viewport&lt;/h4&gt;
&lt;p&gt;简单的理解，viewport是严格等于浏览器的窗口。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。&lt;/p&gt;
&lt;p&gt;移动端的viewport太窄，为了能更好为CSS布局服务，所以提供了两个viewport:虚拟的visualviewport和布局的layoutviewport。&lt;/p&gt;
&lt;p&gt;viewport的内容比较深，推荐阅读&lt;a href=&quot;https://www.quirksmode.org/mobile/viewports.html&quot; target=&quot;_blank&quot;&gt;PPK写的文章&lt;/a&gt;，以及&lt;a href=&quot;http://www.w3cplus.com/css/viewports.html&quot; target=&quot;_blank&quot;&gt;中文翻译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视窗缩放 viewport scale&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开发移动端页面，我们可以设置&lt;code&gt;meta&lt;/code&gt;标签的viewport scale来对视窗的大小进行缩放定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;rem单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;font size of the root element.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rem&lt;/code&gt;就是相对于根元素&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的&lt;code&gt;font-size&lt;/code&gt;来做计算&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视窗单位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;vw : 1vw 等于视窗宽度的1%&lt;/li&gt;
&lt;li&gt;vh : 1vh 等于视窗高度的1%&lt;/li&gt;
&lt;li&gt;vmin : 选取 vw 和 vh 中最小的那个&lt;/li&gt;
&lt;li&gt;vmax : 选取 vw 和 vh 中最大的那个&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914165155356-1738175829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;兼容性：在移动端 iOS 8 以上以及 Android 4.4 以上获得支持&lt;/p&gt;
&lt;p&gt;可以去 &lt;a href=&quot;http://caniuse.com&quot; target=&quot;_blank&quot;&gt;Can I use&lt;/a&gt; 或 &lt;a href=&quot;https://airen.github.io/css3test/&quot; target=&quot;_blank&quot;&gt;css3test&lt;/a&gt; 查看兼容情况&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、REM布局&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;讲的太乱了？&lt;a href=&quot;https://github.com/imwtr/rem-vw-layout/tree/master/rem&quot; target=&quot;_blank&quot;&gt;自己去看代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;rem布局的核心是设置好根html元素的font-size&lt;/p&gt;
&lt;p&gt;一般来说，为了防止在高清屏幕下像素不够用导致模糊，我们拿到的设计稿是640px（iphone5 设备宽为320px）或750px的两倍稿（iphone6 设备宽为375px），按照设备宽度做了两倍的大小。&lt;/p&gt;
&lt;p&gt;那开发的时候在CSS中要设置什么尺寸呢，如何做到一份设计稿适配到不同机型中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最佳方案是：&lt;/strong&gt;在photoshop或其他工具中量出某个元素或图片或文字的尺寸，然后直接写到代码中。额外的适配不需要理会。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;width: px2rem(200);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于此，可以使用SCSS来提供一系列的基础支持&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-width: 750;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿dpr基准值 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-dpr: 2;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 将移动端页面分为10块 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$blocks: 10;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 缩放所支持的设备最小宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$min-device-width: 320px;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 缩放所支持的设备最大宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$max-device-width: 540px;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    rem与px对应关系，1rem代表在JS中设置的html font-size值（为一块的宽度），$rem即为$px对应占多少块

        $px                     $rem
    -------------    ===    ------------
    $design-width              $blocks
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 单位px转化为rem &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@function px2rem($px) &lt;/span&gt;{&lt;span&gt;
    @return #{$px / $design-width * $blocks&lt;/span&gt;}&lt;span&gt;rem;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 单位rem转化为px，可用于根据rem单位快速计算原px &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@function rem2px($rem) &lt;/span&gt;{&lt;span&gt;
    @return #{$rem / $blocks * $design-width&lt;/span&gt;}&lt;span&gt;px;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了便于计算，我们将页面分为10个块，根据映射关系，我们只需要计算某个元素在页面中占了多少块（$rem），结合html中font-size的大小，就能在页面上设置好正确的元素大小&lt;/p&gt;
&lt;p&gt;在对应的JS文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; docElem =&lt;span&gt; document.documentElement,
        metaElem &lt;/span&gt;= document.querySelector('meta[name=&quot;viewport&quot;]'&lt;span&gt;),
        dpr &lt;/span&gt;= window.devicePixelRatio || 1&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将页面分为10块&lt;/span&gt;
        blocks = 10&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要限制的最小宽度&lt;/span&gt;
        defaultMinWidth = 320&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要限制的最大宽度&lt;/span&gt;
        defaultMaxWidth = 540&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算的基准值&lt;/span&gt;
        calcMaxWidth = 9999999;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将页面按照clientWidth进行分割成块，和CSS对应起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置docElem字体大小&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setFontSize() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clientWidth =&lt;span&gt; docElem.clientWidth;

        clientWidth &lt;/span&gt;= Math.max(clientWidth, defaultMinWidth *&lt;span&gt; dpr)

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调整计算基准值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (calcMaxWidth ===&lt;span&gt; defaultMaxWidth) {
            clientWidth &lt;/span&gt;= Math.min(clientWidth, defaultMaxWidth *&lt;span&gt; dpr);
        }

        docElem.style.fontSize &lt;/span&gt;= clientWidth / blocks + 'px'&lt;span&gt;;
    }

    setFontSize();

    window.addEventListener(window.orientationchange &lt;/span&gt;? 'orientationchange' : 'resize', setFontSize, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1px在高清屏幕中的显示问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914174251075-1756575104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图左边设置了css为1px的效果，实际上我们需要的是右边的效果&lt;/p&gt;
&lt;p&gt;明显左边的粗了一些，因为此时1个css像素包含了4个（dpr为2）物理像素，实际需要的是1px的物理像素，而非css像素&lt;/p&gt;
&lt;p&gt;为了解决这个问题，有&lt;a href=&quot;https://www.w3cplus.com/css/fix-1px-for-retina.html&quot; target=&quot;_blank&quot;&gt;很多方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在REM布局中普遍采用的是viewport scale 视窗缩放的方式&lt;/p&gt;
&lt;p&gt;视窗缩放很简单，其实就是直接将meta标签中的scale进行更改。比如dpr为3，则scale为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914174816409-2033101474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但缩放在某些安卓设备中支持度不太好，我们还需要做其他检测（检测了现用的一些机型，应该还不完整哈）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 大部分dpr为2以下的安卓机型不识别scale，需设置不缩放&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (navigator.appVersion.match(/android/gi) &amp;amp;&amp;amp; dpr &amp;lt;= 2&lt;span&gt;) {
        dpr &lt;/span&gt;= 1&lt;span&gt;;
    }

    setScale(dpr);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 企业QQ设置了scale后，不能完全识别scale（此时clientWidth未收到缩放的影响而翻倍），需设置不缩放&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (navigator.appVersion.match(/qq\//gi) &amp;amp;&amp;amp; docElem.clientWidth &amp;lt;= 360&lt;span&gt;) {
        dpr &lt;/span&gt;= 1&lt;span&gt;;
        setScale(dpr);
    }

    docElem.setAttribute(&lt;/span&gt;'data-dpr'&lt;span&gt;, dpr);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置缩放&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setScale(dpr) {
        metaElem.setAttribute(&lt;/span&gt;'content', 'initial-scale=' + 1 / dpr + ',maximum-scale=' + 1 / dpr + ',minimum-scale=' + 1 / dpr + ',user-scalable=no'&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时将最终计算的dpr放到html中，供css做一些特殊适配。看看页面效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914175156705-1647663446.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置容器的最大最小宽度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上图中，随着拉伸，内容区越来越大，各元素尺寸也越来越大。已经进行了最小宽度的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要控制缩放的程度，关键有两个点：尺寸计算基准、容器宽度&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;REM布局&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; data-content-max content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./rem.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./rem.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;data-content-max&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尺寸计算基准位于 meta标签中的 data-content-max，容器宽度位于 body标签中&lt;/p&gt;
&lt;p&gt;在JS中进行匹配控制，需要注意的是，因为我们已经进行了视窗的缩放，clientWidth将会比设备宽度大，要记得以dpr进行翻倍&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要限制的最小宽度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; defaultMinWidth = 320&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要限制的最大宽度&lt;/span&gt;
        defaultMaxWidth = 540&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算的基准值&lt;/span&gt;
        calcMaxWidth = 9999999&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (metaElem.getAttribute('data-content-max') !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        calcMaxWidth &lt;/span&gt;=&lt;span&gt; defaultMaxWidth;
    }


    ...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置docElem字体大小&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setFontSize() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clientWidth =&lt;span&gt; docElem.clientWidth;

        clientWidth &lt;/span&gt;= Math.max(clientWidth, defaultMinWidth *&lt;span&gt; dpr)

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调整计算基准值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (calcMaxWidth ===&lt;span&gt; defaultMaxWidth) {
            clientWidth &lt;/span&gt;= Math.min(clientWidth, defaultMaxWidth *&lt;span&gt; dpr);
        }

        docElem.style.fontSize &lt;/span&gt;= clientWidth / blocks + 'px'&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在CSS中，简单地调用一下，核心方法已经抽离&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;html &lt;/span&gt;{&lt;span&gt;
    @include root-width();
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; html根的宽度定义 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin root-width() &lt;/span&gt;{&lt;span&gt;
    body {
        @include container-min-width();

        &amp;amp;[data-content-max] {
            @include container-max-width();
        &lt;/span&gt;}&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 某些机型虽然设备dpr大于1，但识别不了scale缩放，这里需要重新设置最小宽度防止出现横向滚动条 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    &amp;amp;[data-dpr=&quot;1&quot;] body &lt;/span&gt;{&lt;span&gt;
        min-width&lt;/span&gt;:&lt;span&gt; $min-device-width&lt;/span&gt;;
    }&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置容器拉伸的最小宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin container-min-width() &lt;/span&gt;{&lt;span&gt;
    margin-right&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    min-width&lt;/span&gt;:&lt;span&gt; $min-device-width&lt;/span&gt;;&lt;span&gt;

    @media (-webkit-device-pixel-ratio&lt;/span&gt;:&lt;span&gt; 2) {
        min-width: $min-device-width * 2&lt;/span&gt;;
    }&lt;span&gt;

    @media (-webkit-device-pixel-ratio: 3) &lt;/span&gt;{&lt;span&gt;
        min-width&lt;/span&gt;:&lt;span&gt; $min-device-width * 3&lt;/span&gt;;
    }&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置容器拉伸的最大宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin container-max-width() &lt;/span&gt;{&lt;span&gt;
    margin-right&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    max-width&lt;/span&gt;:&lt;span&gt; $max-device-width&lt;/span&gt;;&lt;span&gt;

    @media (-webkit-device-pixel-ratio&lt;/span&gt;:&lt;span&gt; 2) {
        max-width: $max-device-width * 2&lt;/span&gt;;
    }&lt;span&gt;

    @media (-webkit-device-pixel-ratio: 3) &lt;/span&gt;{&lt;span&gt;
        max-width&lt;/span&gt;:&lt;span&gt; $max-device-width * 3&lt;/span&gt;;
    }&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要注意的是，这里的max-width也要配上dpr系数&lt;/p&gt;
&lt;p&gt;看看成果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914180446341-161224086.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果仅仅限制计算基准值，容器不限制（将body标签中的属性去掉），就可以实现某种流式效果（另一种方案）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914180653230-1695611614.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;文本大小是否用rem单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时我们不希望文本在Retina屏幕下变小，另外，我们希望在大屏手机上看到更多文本，以及，现在绝大多数的字体文件都自带一些点阵尺寸，通常是16px和24px，所以我们不希望出现13px和15px这样的奇葩尺寸。&lt;/p&gt;
&lt;p&gt;我们可以选择使用px直接定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置字体大小，不使用rem单位， 根据dpr值分段调整 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin font-size($fontSize) &lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; $fontSize / $design-dpr&lt;/span&gt;;&lt;span&gt;

    [data-dpr=&quot;2&quot;] &amp;amp; {
        font-size&lt;/span&gt;:&lt;span&gt; $fontSize / $design-dpr * 2&lt;/span&gt;;
    }&lt;span&gt;

    [data-dpr=&quot;3&quot;] &amp;amp; &lt;/span&gt;{&lt;span&gt;
        font-size&lt;/span&gt;:&lt;span&gt; $fontSize / $design-dpr * 3&lt;/span&gt;;
    }&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@include font-size(30px);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，如果要求不严格，也可以直接使用rem单位&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、VW布局&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;讲的太乱了？&lt;a href=&quot;https://github.com/imwtr/rem-vw-layout/tree/master/vw&quot; target=&quot;_blank&quot;&gt;自己去看代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REM布局中用到了JS来动态设置html的font-size，可能造成页面的抖动。&lt;/p&gt;
&lt;p&gt;可以考虑比较新的VW布局，无需使用JS，虽说在移动端 iOS 8 以上以及 Android 4.4 以上才获得支持，不过还是值得一用的。如果需要兼容，可以尝试 &lt;a href=&quot;https://github.com/rodneyrehm/viewport-units-buggyfill&quot; target=&quot;_blank&quot;&gt;viewport-units-buggyfill&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在REM布局中处理1px问题是用了视窗缩放的方案，在VW布局中就不用了，转而使用容器缩放（transform）的方案&lt;/p&gt;

&lt;p&gt;调用方式形如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;height: px2vw(300);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的，我们需要写个转换方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-width: 750;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿dpr基准值 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-dpr: 2;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    vw与px对应关系，100vw为视窗宽度，$vw即为$px对应占多宽

        $px                    $vw
    -------------    ===    ------------
    $design-width              100vw
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 单位px转化为vw &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@function px2vw($px) &lt;/span&gt;{&lt;span&gt;
    @return ($px / $design-width) * 100vw;
&lt;/span&gt;}

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 单位vw转化为px，可用于根据vw单位快速计算原px &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@function vw2px($vw) &lt;/span&gt;{&lt;span&gt;
    @return #{($vw / 100) * $design-width&lt;/span&gt;}&lt;span&gt;px;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对于高清屏幕边框1px问题，有三个方面需要考虑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 单边边框&lt;/p&gt;
&lt;p&gt;2. 多边边框&lt;/p&gt;
&lt;p&gt;3. 边框的圆角&lt;/p&gt;

&lt;p&gt;1. 单边边框比较简单，本质是在目标元素上加个伪类，设置宽度（左|右边框）或高度（上|下边框）为1px，然后在高清屏幕下对齐进行缩放&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transform-origin: 0 0;
transform: scaleY(.5);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914222914402-440121862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 要让伪类支持设置多边边框，已经不能仅仅使用宽度或高度，而应该在这个伪类上设置多边边框，然后设置dpr倍的宽高，再进行缩放（自左上方）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;width: 200%;
height: 200%;

transform-origin: top left;
transform: scale(.5, .5);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914222938443-1351369456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3. 边框圆角一般作用于多边边框，使用了伪类设置边框之后，元素本身并没有边框，所以我们需要对伪类设置圆角，此外，也需要对元素本身设置圆角&lt;/p&gt;
&lt;p&gt;否则就会出现这种尴尬的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914222812949-1754784645.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914223054697-1615684432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果只是需要设置圆角，其实也可以不设置边框，可以使用背景颜色来营造出这种“边框”的分界，在VW布局中，显示地设置边框可能会造成代码量太多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914223318065-679492898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外要注意的是，圆角如果设置为像素值（比如50px），在不同的dpr下它产生的圆角效果还是有区别的，所以最好也把dpr作为系数放在圆角中&lt;/p&gt;

&lt;p&gt;针对上面三种情况，我们需要写好一个scss的1px边框生成器&lt;/p&gt;
&lt;p&gt;先来看看怎么调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 底部单个边框 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.f-border-bottom &lt;/span&gt;{&lt;span&gt;
    @include border(
        $direction&lt;/span&gt;:&lt;span&gt; bottom,
        $size: 1px,
        $color: #ddd,
        $style: solid
    )&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 常规多边边框 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.f-border &lt;/span&gt;{&lt;span&gt;
    @include border(
        $direction&lt;/span&gt;:&lt;span&gt; all,
        $size: 1px,
        $color: #ddd,
        $style: solid
    )&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 多个边框不同的属性 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    &amp;amp;.hover &lt;/span&gt;{&lt;span&gt;
        @include border(
            $direction&lt;/span&gt;:&lt;span&gt; (top, right, bottom, left),
            $size: (3px, 2px, 1px),
            $color: (#0f0, #ddd),
            $style: dotted
        )&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 圆角边框百分比 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.f-border-radius &lt;/span&gt;{&lt;span&gt;
    @include border(
        $direction&lt;/span&gt;:&lt;span&gt; all,
        $radius: 50%
    )&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 圆角边框自定义多个角，顺序 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.f-border-radius &lt;/span&gt;{&lt;span&gt;
    @include border(
        $radius&lt;/span&gt;:&lt;span&gt; (10px, 20px, 30px, 40px)
    )&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 多个边框调用 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    &amp;amp;:not(.info-item__tel) &lt;/span&gt;{&lt;span&gt;
        @include border(
            $direction&lt;/span&gt;:&lt;span&gt; all,
            $size: 1px,
            $color: #ddd,
            $style: solid,
            $radius: 50px
        )&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来调用方式还是有点复杂的，不过应该也还好吧，实在是实现不了像scale缩放那样直接写原生border属性，除非使用构建工具了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个 &lt;a href=&quot;https://github.com/imwtr/rem-vw-layout/blob/master/vw/scss/_border.scss&quot; target=&quot;_blank&quot;&gt;border生成器&lt;/a&gt; 是怎么实现的呢？ Show you the code ..&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 元素边框
 * @param  {string|list} $direction: all           为all或列表时表示多个方向的边框，否则为单个边框
 * @param  {string|list} $size:      1px           边框尺寸，为列表时表将按照direction的顺序取值
 * @param  {string|list} $style:     solid         边框样式，高清设备下仅支持solid，同上
 * @param  {string|list} $color:     #ddd          边框颜色，同上
 * @param  {string}      $position:  relative      元素定位方式，一般为relative即可
 * @param  {string}      $radius:    0             边框圆角
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin border(
    $direction: all,
    $size: 1px,
    $style: solid,
    $color: #ddd,
    $position: relative,
    $radius: 0
) &lt;/span&gt;{
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 多个边框 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @if $direction == all or type-of($direction) == list {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 普通设备 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @media not screen and (-webkit-min-device-pixel-ratio&lt;/span&gt;:&lt;span&gt; 2) {
            @include border-radius($radius)&lt;/span&gt;;&lt;span&gt;

            @if $direction == all {
                border&lt;/span&gt;:&lt;span&gt; $size $style $color&lt;/span&gt;;
            }&lt;span&gt;
            @else &lt;/span&gt;{&lt;span&gt;
                @for $i from 1 through length($direction) {
                    $item&lt;/span&gt;:&lt;span&gt; nth($direction, $i)&lt;/span&gt;;&lt;span&gt;

                    border-#{$item&lt;/span&gt;}&lt;span&gt;: getBorderItemValue($size, $i) getBorderItemValue($style, $i) getBorderItemValue($color, $i);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 高清设备 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @media only screen and (-webkit-min-device-pixel-ratio: 2) &lt;/span&gt;{&lt;span&gt;
            @include border-multiple(
                $direction&lt;/span&gt;:&lt;span&gt; $direction,
                $size: $size,
                $color: $color,
                $position: $position,
                $radius: $radius
            )&lt;/span&gt;;
        }&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 单个边框 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @else &lt;/span&gt;{
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 普通设备 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @media not screen and (-webkit-min-device-pixel-ratio&lt;/span&gt;:&lt;span&gt; 2) {
            border-#{$direction&lt;/span&gt;}&lt;span&gt;: $size $style $color;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 高清设备 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @media only screen and (-webkit-min-device-pixel-ratio: 2) &lt;/span&gt;{&lt;span&gt;
            @include border-single(
                $direction&lt;/span&gt;:&lt;span&gt; $direction,
                $size: $size,
                $color: $color,
                $position: $position
            )&lt;/span&gt;;
        }&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;入口 mixin 判断设备的dpr，然后选择直接生成border代码，或者分发到 border-single 和 border-multiple 中进行高清屏幕的处理&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 实现1物理像素的单条边框线 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin border-single(
    $direction: bottom,
    $size: 1px,
    $color: #ddd,
    $position: relative
) &lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; $position&lt;/span&gt;;&lt;span&gt;

    &amp;amp;&lt;/span&gt;:&lt;span&gt;after {
        content: &quot;&quot;&lt;/span&gt;;&lt;span&gt;
        position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
        #{$direction&lt;/span&gt;}&lt;span&gt;: 0;

        pointer-events: none;
        background-color: $color;

        @media only screen and (-webkit-min-device-pixel-ratio: 2) &lt;/span&gt;{&lt;span&gt;
            -webkit-transform-origin&lt;/span&gt;:&lt;span&gt; 0 0&lt;/span&gt;;&lt;span&gt;
                    transform-origin&lt;/span&gt;:&lt;span&gt; 0 0&lt;/span&gt;;
        }

        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 上下 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @if ($direction == top or $direction == bottom) &lt;/span&gt;{&lt;span&gt;
            left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; $size&lt;/span&gt;;&lt;span&gt;

            @media only screen and (-webkit-device-pixel-ratio&lt;/span&gt;:&lt;span&gt; 2) {
                -webkit-transform: scaleY(.5)&lt;/span&gt;;&lt;span&gt;
                        transform&lt;/span&gt;:&lt;span&gt; scaleY(.5)&lt;/span&gt;;
            }&lt;span&gt;

            @media only screen and (-webkit-device-pixel-ratio: 3) &lt;/span&gt;{&lt;span&gt;
                -webkit-transform&lt;/span&gt;:&lt;span&gt; scaleY(.333333333333)&lt;/span&gt;;&lt;span&gt;
                        transform&lt;/span&gt;:&lt;span&gt; scaleY(.333333333333)&lt;/span&gt;;
            }&lt;span&gt;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 左右 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @elseif ($direction == left or $direction == right) &lt;/span&gt;{&lt;span&gt;
            top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; $size&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;

            @media only screen and (-webkit-device-pixel-ratio&lt;/span&gt;:&lt;span&gt; 2) {
                -webkit-transform: scaleX(.5)&lt;/span&gt;;&lt;span&gt;
                        transform&lt;/span&gt;:&lt;span&gt; scaleX(.5)&lt;/span&gt;;
            }&lt;span&gt;

            @media only screen and (-webkit-device-pixel-ratio: 3) &lt;/span&gt;{&lt;span&gt;
                -webkit-transform&lt;/span&gt;:&lt;span&gt; scaleX(.333333333333)&lt;/span&gt;;&lt;span&gt;
                        transform&lt;/span&gt;:&lt;span&gt; scaleX(.333333333333)&lt;/span&gt;;
            }&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 实现1物理像素的多条边框线 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin border-multiple(
    $direction: all,
    $size: 1px,
    $color: #ddd,
    $position: relative,
    $radius: 0
) &lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; $position&lt;/span&gt;;&lt;span&gt;

    @include border-radius($radius);

    &amp;amp;&lt;/span&gt;:&lt;span&gt;after {
        content: &quot;&quot;&lt;/span&gt;;&lt;span&gt;
        position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
        top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        pointer-events&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
        box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;&lt;span&gt;
        -webkit-transform-origin&lt;/span&gt;:&lt;span&gt; top left&lt;/span&gt;;&lt;span&gt;

        @media only screen and (-webkit-device-pixel-ratio&lt;/span&gt;:&lt;span&gt; 2) {
            width: 200%&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 200%&lt;/span&gt;;&lt;span&gt;

            @include border-radius($radius, 2);

            -webkit-transform&lt;/span&gt;:&lt;span&gt; scale(.5, .5)&lt;/span&gt;;&lt;span&gt;
                    transform&lt;/span&gt;:&lt;span&gt; scale(.5, .5)&lt;/span&gt;;
        }&lt;span&gt;

        @media only screen and (-webkit-device-pixel-ratio: 3) &lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 300%&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 300%&lt;/span&gt;;&lt;span&gt;

            @include border-radius($radius, 3);

            -webkit-transform&lt;/span&gt;:&lt;span&gt; scale(.333333333333, .333333333333)&lt;/span&gt;;&lt;span&gt;
                    transform&lt;/span&gt;:&lt;span&gt; scale(.333333333333, .333333333333)&lt;/span&gt;;
        }&lt;span&gt;

        @if $direction == all &lt;/span&gt;{&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; $size solid $color&lt;/span&gt;;
        }&lt;span&gt;
        @else &lt;/span&gt;{&lt;span&gt;
            @for $i from 1 through length($direction) {
                $item&lt;/span&gt;:&lt;span&gt; nth($direction, $i)&lt;/span&gt;;&lt;span&gt;

                border-#{$item&lt;/span&gt;}&lt;span&gt;: getBorderItemValue($size, $i) solid getBorderItemValue($color, $i);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在多边边框中，&lt;span&gt;pointer-events: none&lt;/span&gt; 的使用属于核心。为了能够看到伪类的边框，伪类将会被置于元素上方，如此便导致了元素被覆盖不可点击，这个css属性就解除了这个障碍。&lt;/p&gt;
&lt;p&gt;圆角如果使用了百分比，就不需要设置dpr系数了&lt;/p&gt;
&lt;p&gt;可以看到，不过这么一来，会造成代码比较冗余的问题，特别是当我们需要再次覆盖之前的边框属性时。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现容器固定纵横比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;纵横比其实还是第一次听说，做方案调研设计就一并整合过来了&lt;/p&gt;
&lt;p&gt;它主要是用于响应式设计中的iframe、img 和video之类的元素，实现纵横比有&lt;a href=&quot;https://www.w3cplus.com/css/aspect-ratio.html&quot; target=&quot;_blank&quot;&gt;很多方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 这里使用 padding-top 百分比的方法，实现一下容器内文本区的固定纵横比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914225604763-666270818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914225621223-1925253043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 实现固定宽高比
 * @param  {string} $position: relative      定位方式
 * @param  {string} $width:    100%          容器宽度
 * @param  {string} $sub:      null          容器的目标子元素
 * @param  {number} $aspectX:  1             容器宽
 * @param  {number} $aspectY:  1             容器高
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin aspect-ratio(
    $position: relative,
    $width: 100%,
    $sub: null,
    $aspectX: 1,
    $aspectY: 1
) &lt;/span&gt;{&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; $position&lt;/span&gt;;&lt;span&gt;
    padding-top&lt;/span&gt;:&lt;span&gt; percentage($aspectY / $aspectX)&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; $width&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;

    @if $sub == null {
        $sub&lt;/span&gt;:&lt;span&gt; &quot;*&quot;&lt;/span&gt;;
    }&lt;span&gt;

    &amp;amp; &amp;gt; #&lt;/span&gt;{&lt;span&gt;$sub&lt;/span&gt;} {&lt;span&gt;
        position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
        left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
    }&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 容器宽高比 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.header &lt;/span&gt;{&lt;span&gt;
    @include aspect-ratio(
        // $width&lt;/span&gt;:&lt;span&gt; px2vw(600),
        // $sub: &quot;.header-content&quot;,
        $aspectX: 375,
        $aspectY: 150
    )
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;padding的百分比是基于元素宽度的，将容器高度设为0，根据盒子模型，则整个元素最终的高度有padding-top来决定&lt;/p&gt;
&lt;p&gt;子元素设置绝对定位防止被挤压，同时撑满父级容器，即可实现&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914225916588-1942516861.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从效果图能够看出，美中不足是无法设置容器最大最小宽度，vw是根据设备宽度进行计算的，所以无法解决。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、REM + VW布局&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;讲的太乱了？&lt;a href=&quot;https://github.com/imwtr/rem-vw-layout/tree/master/vw-rem&quot; target=&quot;_blank&quot;&gt;自己去看代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了解决纯VW布局不能设置最大最小宽度的问题，我们引入REM。&lt;/p&gt;
&lt;p&gt;通过配置html根元素的font-size为vw单位，并且配置最大最小的像素px值，在其他css代码中可以直接使用rem作为单位&lt;/p&gt;
&lt;p&gt;调用方式炒鸡简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;html &lt;/span&gt;{&lt;span&gt;
    @include root-font-size();
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;line-height: px2rem(300);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而scss里面的实现，同样是先定义一个映射关系。将页面宽度进行分块（只是为了防止值太大）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-width: 750;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿dpr基准值 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-dpr: 2;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 将移动端页面分为10块 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$blocks: 10;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 缩放所支持的设备最小宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$min-device-width: 320px;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 缩放所支持的设备最大宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$max-device-width: 540px;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    rem与px对应关系，1rem代表html font-size值（为一块的宽度），$rem即为$px对应占多少块

        $px                    $rem
    -------------    ===    ------------
    $design-width              $blocks
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; html根元素的font-size定义，简单地将页面分为$blocks块，方便计算 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin root-font-size() &lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 100vw / $blocks&lt;/span&gt;;&lt;span&gt;

    body {
        @include container-min-width();
    &lt;/span&gt;}

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 最小宽度定义 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @media screen and (max-width: $min-device-width) &lt;/span&gt;{&lt;span&gt;
        font-size&lt;/span&gt;:&lt;span&gt; $min-device-width / $blocks&lt;/span&gt;;
    }

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 最大宽度定义 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    &amp;amp;[data-content-max] &lt;/span&gt;{&lt;span&gt;
        body[data-content-max] {
            @include container-max-width();
        &lt;/span&gt;}&lt;span&gt;

        @media screen and (min-width: $max-device-width) &lt;/span&gt;{&lt;span&gt;
            font-size&lt;/span&gt;:&lt;span&gt; $max-device-width / $blocks&lt;/span&gt;;
        }&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置容器拉伸的最小宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin container-min-width() &lt;/span&gt;{&lt;span&gt;
    margin-right&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    min-width&lt;/span&gt;:&lt;span&gt; $min-device-width&lt;/span&gt;;
}

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置容器拉伸的最大宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@mixin container-max-width() &lt;/span&gt;{&lt;span&gt;
    margin-right&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;&lt;span&gt;
    max-width&lt;/span&gt;:&lt;span&gt; $max-device-width&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的max-width直接使用宽度值，因为使用的是vw，视窗未缩放&lt;/p&gt;
&lt;p&gt;而在页面标签（html和body）中，简单地配上属性代表是否需要限制宽度即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;data-content-max&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;VW-REM布局&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./vw-rem.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;data-content-max&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样是计算基准值和容器宽度两个方面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914231316261-765043488.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果仅仅限制计算的基准值，也能实现“流式效果”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914231341611-808520747.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;六、对比选择&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 方案选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方案是挺多的，可能也不够完善。要选哪种方案呢？&lt;/p&gt;
&lt;p&gt;每个方案都能保证在不同机型下做到一定的适配。&lt;/p&gt;
&lt;p&gt;1. 一般来说，可用直接考虑使用REM布局&lt;/p&gt;
&lt;p&gt;2. 因REM使用了JS动态设置html的font-size，且scale对安卓机型不太友好，要求极致的可以选用VW&lt;/p&gt;
&lt;p&gt;3. 纯VW布局不支持设置容器最大最小宽高，如果需要此功能则选用 REM + VW布局&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180914234729446-209909253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 食用方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;怎么使用呢？&lt;/p&gt;
&lt;p&gt;可在Github中对应目录的 html，js，css文件，看看是怎么调用的&lt;/p&gt;
&lt;p&gt;常规方式是引入公共基础代码，然后在业务代码中调用&lt;/p&gt;
&lt;p&gt;在html文件中可以配置 &lt;span&gt;data-content-max&lt;/span&gt; 参数来限制最大最小宽度&lt;/p&gt;
&lt;p&gt;在scss基础部分还可以自定义这几个值（如果是REM布局的，修改这些值还需要在rem.js 文件中同步修改）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-width: 750;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 移动端页面设计稿dpr基准值 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$design-dpr: 2;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 将移动端页面分为10块 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$blocks: 10;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 缩放所支持的设备最小宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$min-device-width: 320px;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 缩放所支持的设备最大宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$max-device-width: 540px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 14 Sep 2018 16:01:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<og:description>和以往一样，本次项目也放到了 Github 中，欢迎围观 star ~ 1. 前言 2. 基本概念 3. REM布局 4. VW布局 实现单边边框1px 实现多边边框1px 实现边框圆角 实现容器固定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/9648233.html</dc:identifier>
</item>
<item>
<title>.Net Core SignalR 初体验 - 丶Pz</title>
<link>http://www.cnblogs.com/panzi/p/9649315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panzi/p/9649315.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　Asp.Net SignalR已经出来很久了，但是一直没有静下心来好好看看。昨天花了几个小时的时间看了下。首先借鉴了官方文档，如何搭建一个SignalR的Demo。&lt;/p&gt;
&lt;p&gt;　　参考文章：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/signalr?view=aspnetcore-2.1&amp;amp;tabs=visual-studio&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/signalr?view=aspnetcore-2.1&amp;amp;tabs=visual-studio&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;　　SignalR地址：&lt;a href=&quot;https://github.com/aspnet/SignalR&quot; target=&quot;_blank&quot;&gt;https://github.com/aspnet/SignalR&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　所以为了快速搭建和体验.Net Core版本的SignalR，我选择了下载官方的Demo和参考官方给的教程。所以具体的搭建过程我就不再本文中写了。&lt;/p&gt;
&lt;h2&gt;体验效果&lt;/h2&gt;
&lt;p&gt;　　官网给出的DEMO运行如下图：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914223526794-466631285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击connect，查看一下network。可以发现，它在当前浏览器支持三种方式。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914223715706-28944197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而且和.NET Framework版本不同的是，新版SignalR中的Hub类型也是蛮丰富的。Demo中给出了 普通Hub，DynamicHub，Hub&amp;lt;T&amp;gt; 三种类型。我们去看看其中的区别吧。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;普通Hub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;查看定义，可以看到普通Hub中的Clients类型是 &lt;strong&gt;IHubCallerClients &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
namespace Microsoft.AspNetCore.SignalR
{
    //
    // 摘要:
    //     A base class for a SignalR hub.
    public abstract class Hub : IDisposable
    {
        protected Hub();

        //
        // 摘要:
        //     Gets or sets an object that can be used to invoke methods on the clients connected
        //     to this hub.
        public IHubCallerClients Clients { get; set; }
        //
        // 摘要:
        //     Gets or sets the hub caller context.
        public HubCallerContext Context { get; set; }
        //
        // 摘要:
        //     Gets or sets the group manager.
        public IGroupManager Groups { get; set; }

        //
        public void Dispose();
        //
        // 摘要:
        //     Called when a new connection is established with the hub.
        //
        // 返回结果:
        //     A System.Threading.Tasks.Task that represents the asynchronous connect.
        public virtual Task OnConnectedAsync();
        //
        // 摘要:
        //     Called when a connection with the hub is terminated.
        //
        // 返回结果:
        //     A System.Threading.Tasks.Task that represents the asynchronous disconnect.
        public virtual Task OnDisconnectedAsync(Exception exception);
        //
        // 摘要:
        //     Releases all resources currently used by this Microsoft.AspNetCore.SignalR.Hub
        //     instance.
        //
        // 参数:
        //   disposing:
        //     true if this method is being invoked by the Microsoft.AspNetCore.SignalR.Hub.Dispose
        //     method, otherwise false.
        protected virtual void Dispose(bool disposing);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　IHubCallerClients 定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public interface IHubCallerClients : IHubCallerClients&amp;lt;IClientProxy&amp;gt;, IHubClients&amp;lt;IClientProxy&amp;gt;
    {
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而框架又给IClientProxy增加了扩展方法：SendAsync&lt;/p&gt;
&lt;p&gt;　　所以在普通Hub中，定义客户端方法的时候，需要把方法名当作参数传入SendAsync方法中。例如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public Task Send(string message)
        {
            return Clients.All.SendAsync(&quot;Receive&quot;, $&quot;{Context.ConnectionId}: {message}&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;DynamicHub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;DynamicHub我是比较喜欢的，因为他和 Framework版的是一样（或者说看起来是一样的）的。动态Hub我们就可以不必拘泥于只能调用SendAsync方法了。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public Task SendToOthers(string message)
        {
            return Clients.Others.ThisIsMyReceiveMethod($&quot;{Context.ConnectionId}: {message}&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　DynamicHub的Clients类型为：&lt;strong&gt;DynamicHubClients ，&lt;/strong&gt;它的内部变量全都是dynamic类型的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914225214997-63517270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Hub&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;泛型Hub就把规约交给开发者制定。在Demo中 Hub&amp;lt;IChatClient&amp;gt; 中的IChatClient接口定义了Receive方法，因此Clients中的对象可以调用Receive方法。同理，我们可以根据业务需要定义自己的方法。至少从代码上看会显得更加通俗易懂一些。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public interface IChatClient
    {
        Task Receive(string message);
        Task LoginSuccess(long userId);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
     public Task Login(long userId)
        {
            return Clients.Caller.LoginSuccess(userId);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实从代码上来看的话，他们都是Hub，只不过是不同的扩展实现而已。而泛型Hub不过是用户自定义泛型接口，而默认Hub中的默认泛型接口为：&lt;strong&gt;IClientProxy.&lt;/strong&gt;所以看到这里，如果我就想使用原生的Hub而又想自定义方法怎么办呢？很简单，加扩展就可以了。&lt;/p&gt;
&lt;p&gt;　　为什么自己加就可以呢，其实 SendAsync 就是扩展方法，它内部也是调用了SendCoreAsync方法。于是乎，写下自己的扩展方法，那这样子就很灵活了。我们把method参数去掉，直接写死试试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public static Task LoginAsync(this IClientProxy clientProxy, string message, CancellationToken cancellationToken = default(CancellationToken))
        {
            return clientProxy.SendCoreAsync(&quot;LoginSuccess&quot;, new object[] { message}, cancellationToken);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实说白了，这个扩展方法还是需要传入method参数的，只不过封装了一层（似乎感觉这么做有意义吗？哈哈，还是老老实实用泛型吧），那么我们在去看Hub中的方法，修改Send方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public Task Send(string message)
        {
            return Clients.All.LoginAsync($&quot;{Context.ConnectionId}: {message}&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　是不是这样子就实现了自己自定义方法了呢？个人觉得这么写还绕了一圈，不如用泛型或者Dynamic了。&lt;/p&gt;
&lt;p&gt;　　运行一下，看看效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914231333034-715982704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实我也是抱着试试的态度，没想到还真是这样，和新方法就是SendCoreAsync，而其他方法只不过是上层封装使得代码更加通俗易懂。&lt;/p&gt;
&lt;h2&gt;使用Redis&lt;/h2&gt;
&lt;p&gt;　　Demo中的其他例子就不再演示了。广播，一对一，一对多，加入组，退出组等基本和之前一样。这里在演示一下使用Redis做不同实例之间的通信效果。&lt;/p&gt;
&lt;p&gt;　　首先程序集是不能少的：Microsoft.AspNetCore.SignalR.Redis，然后在Startup中补充代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914231827667-2057780583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开Redis客户端，使用MONITOR命令监听一下，从程序启动，到连接，在发送一条广播消息：hello redis。  redis 监听结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914232013627-257213017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以，PUB/SUB还是立了大功呢。&lt;/p&gt;
&lt;p&gt;　　这里用CMD运行了两个实例，端口分别为 8881，8882来模拟两个站点。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914232656753-561781680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　演示效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914232929976-158374628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　没问题的哦，其实仔细想想，虽然运行了两个网站实例，但是连接信息都保存在同一个Redis上，那肯定通信是木的问题的啦。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　只是简单的运行了一下DEMO，大致了解了一下 .Net Core SignalR的表层，至少跑Demo是跑起来了，并且使用Redis也是没有问题的。不过好像会出现运行一旦时间，程序自动停掉的问题，不知道是不是我电脑的问题。。今天就到这里吧，希望大家能有所收获。 本文代码地址：&lt;a href=&quot;https://github.com/fanpan26/LayIM.AspNetCore/tree/master/src/LayIM.AspNetCore.Demo/SignalRSamples&quot; target=&quot;_blank&quot;&gt;https://github.com/fanpan26/LayIM.AspNetCore/tree/master/src/LayIM.AspNetCore.Demo/SignalRSamples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fanpan26/LayIM.AspNetCore/tree/master/src/LayIM.AspNetCore.Demo/SignalRSamples&quot; target=&quot;_blank&quot;&gt;　&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 15:35:00 +0000</pubDate>
<dc:creator>丶Pz</dc:creator>
<og:description>.NET CORE SignalR</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/panzi/p/9649315.html</dc:identifier>
</item>
<item>
<title>Spring系列(五) 容器初始化过程源码 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9649415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9649415.html</guid>
<description>&lt;h2 id=&quot;iocdi-的概念&quot;&gt;IoC/DI 的概念&lt;/h2&gt;
&lt;p&gt;容器是Spring的核心之一(另一个核心是AOP). 有了容器, IOC才可能实现.&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;什么使IoC? IoC就是将类自身管理的与其由依赖关系的对象的创建/关联和管理交予容器实现, 容器按照配置(比如xml文件)来组织应用对象的创建和关联.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;什么使DI? DI是IoC的实现方式, 由容器在程序初始化的时候将类的依赖对象注入进去.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;IoC和DI的关系? IoC(Inversion of Control)是一种设计原则, 可以减少代码的耦合度, DI(Dependency Injection)是IOC的具体实现方式, 还有其他的实现方式如 DL(Dependency Lookup).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-容器&quot;&gt;Spring 容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;类应该都比较熟悉, 从熟悉的事物开始寻找线索.&lt;/p&gt;
&lt;p&gt;下载Spring源码后用idea打开, 找到类&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;, idea可以使用 &lt;code&gt;ctrl+N&lt;/code&gt; 输入类名搜索, 打开源文件, 按 &lt;code&gt;ctrl+Alt+U&lt;/code&gt; 可以生成类图.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201809/794700-20180914230257650-1174502810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;和&lt;code&gt;ResourceLoader&lt;/code&gt;是两个顶层接口. &lt;code&gt;BeanFactory&lt;/code&gt;是Bean的工厂,定义了IoC基本的功能. &lt;code&gt;ResourceLoader&lt;/code&gt;是资源加载的策略接口,定义了加载资源的基本规范, &lt;code&gt;ApplicationContext&lt;/code&gt;需要此接口的功能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;提供了容器最基本的功能, 其中定义的方法会频繁使用, 接口定义如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanFactory {
    // 一个标记, 带有此标记开头的类不是bean, 而是工厂本身
    String FACTORY_BEAN_PREFIX = &quot;&amp;amp;&quot;;
    // 下面几个方法是各种获取bean的方式
    Object getBean(String name) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(String name, @Nullable Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
    Object getBean(String name, Object... args) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) throws BeansException;
    // 判断bean是否存在
    boolean containsBean(String name);
    // bean作用域是否单例
    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
    // bean作用域是否原型
    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
    // bean是否与给定解析类型匹配
    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
    boolean isTypeMatch(String name, @Nullable Class&amp;lt;?&amp;gt; typeToMatch) throws NoSuchBeanDefinitionException;
    // 获取bean类型
    @Nullable
    Class&amp;lt;?&amp;gt; getType(String name) throws NoSuchBeanDefinitionException;
    //获取bean别名数组
    String[] getAliases(String name);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt; 扩展了&lt;code&gt;BeanFactory&lt;/code&gt;的功能, 除了作为工厂外, 它还提供了消息国际化(&lt;code&gt;MessageSource&lt;/code&gt;), 获取环境bean(&lt;code&gt;EnvironmentCapable&lt;/code&gt;), 容器消息发布(&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;)等功能. 因为它包含了容器以外的这些功能, 所以对了解容器来说多少会产生干扰. 事实上, 查看&lt;code&gt;BeanFactory&lt;/code&gt;的子类(在类图上选中类,或者在源代码视图中按&lt;code&gt;Ctrl+Alt+B&lt;/code&gt;)能从它的实现中找到&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;, 从名称上二者在继承该关系上应该比较近, 功能也比较纯粹, 没有类似ApplicationContext的其他干扰.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 类是最基本的容器实现类, 它的继承关系如下图. 作为bean的工厂, 它的职责就是生产bean, 基本功能正是顶级接口&lt;code&gt;BeanFactory&lt;/code&gt;定义的那些方法. 它上级的接口扩展了自动装配的能力(&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;), 注册和获取等操作&lt;code&gt;BeanDefinition&lt;/code&gt;实例的能力(&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201809/794700-20180914230347312-962792398.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;beandefinition&quot;&gt;BeanDefinition&lt;/h2&gt;
&lt;p&gt;BeanDefinition 用来抽象bean定义在spring中的抽象, 最终spring将外部配置的bean转化为&lt;code&gt;BeanDefinition&lt;/code&gt;的实例存储.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201809/794700-20180914230405534-1633823476.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;容器初始化过程&quot;&gt;容器初始化过程&lt;/h2&gt;
&lt;p&gt;容器初始化过程分为三步, 资源Resource定位, 解析加载, 注册.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;是工厂, 继承它的子类只有一个&lt;code&gt;XmlBeanFactory&lt;/code&gt;, 它被标注为&lt;code&gt;@Deprecated&lt;/code&gt;.所以不应该在应用中使用该类, 但它可以作为了解源码的入口. 它有个&lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;的私有变量直接new初始化, 参数this将工厂实例传给这个对象, 这样它就有了工厂的引用, 方便内部处理.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class XmlBeanFactory extends DefaultListableBeanFactory {

    private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


    public XmlBeanFactory(Resource resource) throws BeansException {
        this(resource, null);
    }

    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
        super(parentBeanFactory);
        // 这个是调用实际加载资源的方法
        this.reader.loadBeanDefinitions(resource);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大概串一下初始化的执行流程:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获得一个&lt;code&gt;Resource&lt;/code&gt;实例resource, 其实就是xml文件生成的输入流&lt;/li&gt;
&lt;li&gt;实例化&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;工厂beanFactory, 将resource作为构造参数传入&lt;/li&gt;
&lt;li&gt;beanFactory实例化, 生成&lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;的实例reader, 并将beanFactory的引用传递给他&lt;/li&gt;
&lt;li&gt;在beanFactory构造函数中调用reader的方法加载resource, 解析生成一系列&lt;code&gt;BeanDefinition&lt;/code&gt;的实例, 因为readere有工厂的实例, 所以这些实例可以注册到工厂中&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;加载xml-bean的关键代码&quot;&gt;加载XML Bean的关键代码&lt;/h2&gt;
&lt;p&gt;下面按照调用关系跟踪代码, 忽略其他的xml元素, 最终目标是找到加载注册bean的机制.&lt;/p&gt;
&lt;p&gt;XmlBeanDefinitionReader&lt;br/&gt;--&amp;gt; loadBeanDefinitions&lt;br/&gt;--&amp;gt; doLoadBeanDefinitions&lt;br/&gt;--&amp;gt; registerBeanDefinitions&lt;br/&gt;DefaultBeanDefinitionDocumentReader: BeanDefinitionDocumentReader&lt;br/&gt;--&amp;gt; registerBeanDefinitions&lt;br/&gt;--&amp;gt; doRegisterBeanDefinitions&lt;br/&gt;--&amp;gt; parseBeanDefinitions&lt;br/&gt;--&amp;gt; parseDefaultElement / processBeanDefinition&lt;br/&gt;BeanDefinitionParserDelegate&lt;br/&gt;--&amp;gt; parseBeanDefinitionElement&lt;br/&gt;BeanDefinitionReaderUtils&lt;br/&gt;--&amp;gt; registerBeanDefinition&lt;br/&gt;DetaultListableBeanFactory&lt;br/&gt;--&amp;gt; registerBeanDefinition&lt;/p&gt;
&lt;p&gt;一. &lt;code&gt;XmlBeanDefinitionReader.loadBeanDefinitions(EncodedResource encodedResource)&lt;/code&gt; 生成InputSource对象(用来初始化XML Dom对象)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;InputStream inputStream = encodedResource.getResource().getInputStream();
try {
    // 生成实例, 后面用来加载dom
    InputSource inputSource = new InputSource(inputStream);
    if (encodedResource.getEncoding() != null) {
        inputSource.setEncoding(encodedResource.getEncoding());
    }
    // 生成InputSource后,调用这个方法
    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
}
finally {
    inputStream.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二. &lt;code&gt;XmlBeanDefinitionReader.doLoadBeanDefinitions(InputSource inputSource, Resource resource)&lt;/code&gt; 加载生成Xml Document对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 生成doc实例
Document doc = doLoadDocument(inputSource, resource);
return registerBeanDefinitions(doc, resource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三. &lt;code&gt;XmlBeanDefinitionReader.registerBeanDefinitions(Document doc, Resource resource)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 生成BeanDefinitionDocumentReader的实例, 默认实现为生成DefaultBeanDefinitionDocumentReader类的实例, 通过BeanUtil工具的实例化方法生成
BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
int countBefore = getRegistry().getBeanDefinitionCount();
// 传入doc和资源的上下文对象, 注册bean
documentReader.registerBeanDefinitions(doc, createReaderContext(resource));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;四. &lt;code&gt;registerBeanDefinitions(Document doc, XmlReaderContext readerContext)&lt;/code&gt; &lt;code&gt;BeanDefinitionDocumentReader&lt;/code&gt;是接口, 实现类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    logger.debug(&quot;Loading bean definitions&quot;);
    // 获取根节点
    Element root = doc.getDocumentElement();
    // 从根节点开始, 调用的这个方法会递归子节点
    doRegisterBeanDefinitions(root);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;五. &lt;code&gt;doRegisterBeanDefinitions(Element root)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void doRegisterBeanDefinitions(Element root) {
    //任何嵌套的&amp;lt;beans&amp;gt;元素都将导致此方法的递归。为了正确传播和保留&amp;lt;beans&amp;gt; default- *属性，请跟踪当前（父）委托，该委托可以为null。创建新的（子）委托，引用父项以进行回退，然后最终将this.delegate重置为其原始（父）引用。此行为模拟了一堆代理，而实际上并不需要一个代理。
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    if (this.delegate.isDefaultNamespace(root)) {
        // 下面这一块代码主要是做profile检查, 没有启用profile的bean不加载, 将直接return
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isInfoEnabled()) {
                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
                            &quot;] not matching: &quot; + getReaderContext().getResource());
                }
                return;
            }
        }
    }

    preProcessXml(root);
    // 具体解析的方法, pre和post的在这个类中为空方法
    parseBeanDefinitions(root, this.delegate);
    postProcessXml(root);

    this.delegate = parent;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;六. &lt;code&gt;parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 解析文档中的根节点
* &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.
*/
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    // 是根节点,就获取子节点, 遍历,如果是根&quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;, 就调用parseDefaultElement, 否则parseCustomElement
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i &amp;lt; nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                else {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        delegate.parseCustomElement(root);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;七. &lt;code&gt;parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
            // 解析&quot;import&quot;元素, 这个方法会定位import的资源位置并重复第一步开始的步骤
            importBeanDefinitionResource(ele);
        }
        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
            // 别名&quot;alias&quot;注册
            processAliasRegistration(ele);
        }
        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
            // 前方高能... 处理bean元素
            processBeanDefinition(ele, delegate);
        }
        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
            // 递归&quot;beans&quot;
            doRegisterBeanDefinitions(ele);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;八. &lt;code&gt;processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
*  处理bean元素的定义, 并且注册
*/
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 获取bean的包装对象,代码见第九步
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // 注册最终的bean装饰对象
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
                    bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;九. &lt;code&gt;parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean)&lt;/code&gt; 类为 &lt;code&gt;BeanDefinitionParserDelegate&lt;/code&gt; 关注两个实例化过程,一个是&lt;code&gt;BeanDefinition&lt;/code&gt;, 一个是其装饰对象&lt;code&gt;BeanDefinitionHolder&lt;/code&gt;的实例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 解析bean元素, 可能会返回null, 如果有错误则报告给
* {@link org.springframework.beans.factory.parsing.ProblemReporter}.
*/
@Nullable
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
    String id = ele.getAttribute(ID_ATTRIBUTE);
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    String beanName = id;
    if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) {
        beanName = aliases.remove(0);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;No XML 'id' specified - using '&quot; + beanName +
                    &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
        }
    }

    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }
    // 实例化一个 BeanDefination 实例
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    if (beanDefinition != null) {
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &amp;amp;&amp;amp;
                            beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        aliases.add(beanClassName);
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Neither XML 'id' nor 'name' specified - &quot; +
                            &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }

    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;十. &lt;code&gt;registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)&lt;/code&gt; 是类的静态方法&lt;code&gt;BeanDefinitionReaderUtils&lt;/code&gt; ;给registry对象调用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 注册bean的最终方法
public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {

    // 使用首要名称注册bean
    String beanName = definitionHolder.getBeanName();
    // 注册bean, 具体实现在类DetaultListableBeanFactory中
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // 注册bean的别名
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;十一. &lt;code&gt;registerBeanDefinition(String beanName, BeanDefinition beanDefinition)&lt;/code&gt; 在类&lt;code&gt;DetaultListableBeanFactory&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {
    ....

    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    if (existingDefinition != null) {
        ....
        // 存到map里面
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                if (this.manualSingletonNames.contains(beanName)) {
                    Set&amp;lt;String&amp;gt; updatedSingletons = new LinkedHashSet&amp;lt;&amp;gt;(this.manualSingletonNames);
                    updatedSingletons.remove(beanName);
                    this.manualSingletonNames = updatedSingletons;
                }
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            this.manualSingletonNames.remove(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到目前为止, bean就注册到工厂里面去了, 实际上工厂里面保存了BeanDefinition的一个映射Map, 这样有助于Spring做一些验证, 当获取bean的时候也可以方便实现懒加载.&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 15:05:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>IoC/DI 的概念 容器是Spring的核心之一(另一个核心是AOP). 有了容器, IOC才可能实现. 什么使IoC? IoC就是将类自身管理的与其由依赖关系的对象的创建/关联和管理交予容器实现,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9649415.html</dc:identifier>
</item>
<item>
<title>.NetCore实践篇：分布式监控系统zipkin踩坑之路（二） - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9649192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9649192.html</guid>
<description>&lt;div id=&quot;main&quot; readability=&quot;118.07919847328&quot;&gt;
&lt;div id=&quot;mainContent&quot; readability=&quot;32.31221719457&quot;&gt;
&lt;div class=&quot;forFlow&quot; readability=&quot;8.5756327251324&quot;&gt;
&lt;div id=&quot;post_detail&quot; readability=&quot;34.625941136208&quot;&gt;
&lt;div id=&quot;topics&quot; readability=&quot;14.135802469136&quot;&gt;
&lt;div class=&quot;post&quot; readability=&quot;26.796341463415&quot;&gt;


&lt;div class=&quot;postBody&quot; readability=&quot;31.08064516129&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;58&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;《牧神记》有一句话说的好，破心中神。当不再对分布式，微服务，CLR畏惧迷茫的时候，你就破了心中神。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;zipkin复习&lt;/h2&gt;
&lt;p&gt;第一篇: &lt;a href=&quot;https://www.cnblogs.com/fancunwei/p/9625841.html&quot; title=&quot;.Net架构篇:思考如何设计一款实用的分布式监控系统？&quot;&gt;.Net架构篇:思考如何设计一款实用的分布式监控系统？&lt;/a&gt; &lt;/p&gt;

&lt;h4&gt;zipkin作用&lt;/h4&gt;

&lt;p&gt;全链路追踪工具（根据依赖关系）&lt;/p&gt;
&lt;p&gt;查看每个接口、每个service的执行速度（定位问题发生点或者寻找性能瓶颈）&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;zipkin工作原理&lt;/h4&gt;

&lt;p&gt;创造一些追踪标识符（tracingId，spanId，parentId），最终将一个request的流程树构建出来&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;zipkin架构&lt;/h4&gt;

&lt;p&gt;Collector接收各service传输的数据；&lt;/p&gt;
&lt;p&gt;Cassandra作为Storage的一种，默认存储在内存中，也支持ElasticSearch和mysql用于生产落库；&lt;/p&gt;
&lt;p&gt;Query负责查询Storage中存储的数据,提供简单的JSON API获取数据，主要提供给web UI使用；&lt;/p&gt;
&lt;p&gt;Web 提供简单的web界面；&lt;/p&gt;
&lt;/div&gt;
&lt;h5&gt;zipkin分布式跟踪系统的目的&lt;/h5&gt;

&lt;p&gt;zipkin为分布式链路调用监控系统，聚合各业务系统调用延迟数据，达到链路调用监控跟踪；&lt;/p&gt;
&lt;p&gt;zipkin通过采集跟踪数据可以帮助开发者深入了解在分布式系统中某一个特定的请求时如何执行的；&lt;/p&gt;
&lt;p&gt;参考如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/5570258.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;zipkin参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zipkin.io/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;zipkin官网&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;zipkin4net简介&lt;/h2&gt;

&lt;p&gt;zipkin4net是.NET客户端库。&lt;/p&gt;
&lt;p&gt;它为您提供：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Zipkin 原语（跨度，注释，二进制注释，......）【Zipkin primitives (spans, annotations, binary annotations, ...)】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步跟踪发送&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟踪传输抽象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt;简单用法&lt;/h4&gt;

&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; logger = CreateLogger(); 
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; sender = CreateYourTransport(); 
TraceManager.SamplingRate = &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;f; 
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; tracer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ZipkinTracer(sender);
TraceManager.RegisterTracer(tracer);
TraceManager.Start(logger);


TraceManager.Stop();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简介到此为止，剩余您可参考&lt;a href=&quot;https://github.com/openzipkin/zipkin4net&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;zipkin4net&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Show me the Code&lt;/h2&gt;

&lt;p&gt;废话少说，一杯代码为敬。&lt;/p&gt;
&lt;p&gt;进入代码之前，我先来演示下代码结构。这个结构对应我之前的代码实践。内存队列，爬虫在我的博客内都能找到博客对应。&lt;/p&gt;
&lt;br/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;400&quot; data-height=&quot;444&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-062d3b5f6243c4f4.png&quot; data-original-width=&quot;400&quot; data-original-height=&quot;444&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;26963&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-062d3b5f6243c4f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;演示结构图&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;今天我们只说zipkin4Net的实践。为了测试查看zipkin是否能够汇集不同的站点,我特意建立了两个站点Demo.ZipKinWeb和Demo.ZipKinWeb2。类似下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;image-container&quot; readability=&quot;7&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;642&quot; data-height=&quot;138&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-51a77a199069b15e.png&quot; data-original-width=&quot;642&quot; data-original-height=&quot;138&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;16262&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-51a77a199069b15e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;为了能真实落库，我创建了FanQuick.Repository,用于提供mongodb存储帮助。IRepository泛型接口声明如下&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; FanQuick.Repository
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; interface IRepository&amp;lt;TDocument&amp;gt; where TDocument:EntityBase
{
IQueryable&amp;lt;TDocument&amp;gt; Queryable { get; }
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;





&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Delete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;





IEnumerable&amp;lt;TDocument&amp;gt; Find(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter);




&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(TDocument document)&lt;/span&gt;&lt;/span&gt;;




&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IEnumerable&amp;lt;TDocument&amp;gt; documents)&lt;/span&gt;&lt;/span&gt;;





&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;hljs-function&quot;&gt;TDocument &lt;span class=&quot;hljs-title&quot;&gt;FindOneAndDelete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;hljs-function&quot;&gt;TDocument &lt;span class=&quot;hljs-title&quot;&gt;FindOneAndUpdate&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(FilterDefinition&amp;lt;TDocument&amp;gt; filter, UpdateDefinition&amp;lt;TDocument&amp;gt; update)&lt;/span&gt;&lt;/span&gt;;
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了两个站点能够复用调用zipkin4net的通知，我将代码抽离出来放到了 Demo.ZipkinCommon。&lt;br/&gt;可复用的抽象类CommonStartUp，代码如下：重点关注下调用zipkin4net的代码。并将抽象Run方法暴漏给了子类，需要子类实现。要特别注意，appsettings.json需要设置&lt;span&gt;applicationName&lt;/span&gt;,不然发送到zipkin就是未命名服务，这就不能区分站点了!&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;namespace Demo.ZipkinCommon
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CommonStartup&lt;/span&gt;
&lt;/span&gt;{


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&lt;/span&gt;
&lt;/span&gt;{
var config = ConfigureSettings.CreateConfiguration();
var applicationName = config[&lt;span class=&quot;hljs-string&quot;&gt;&quot;applicationName&quot;&lt;/span&gt;];









var lifetime = app.ApplicationServices.GetService&amp;lt;IApplicationLifetime&amp;gt;();
lifetime.ApplicationStarted.Register(() =&amp;gt;
{
TraceManager.SamplingRate = &lt;span class=&quot;hljs-number&quot;&gt;1.0f&lt;/span&gt;;
var logger = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TracingLogger(loggerFactory, &lt;span class=&quot;hljs-string&quot;&gt;&quot;zipkin4net&quot;&lt;/span&gt;);
var httpSender = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HttpZipkinSender(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://weixinhe.cn:9411&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/json&quot;&lt;/span&gt;);
var tracer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ZipkinTracer(httpSender, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JSONSpanSerializer());
TraceManager.RegisterTracer(tracer);
TraceManager.Start(logger);
});
lifetime.ApplicationStopped.Register(() =&amp;gt; TraceManager.Stop());
app.UseTracing(applicationName);
Run(app, config);
}
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IConfiguration configuration)&lt;/span&gt;&lt;/span&gt;;
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取配置类，也独立了出来，可支持读取appsettings.json，&lt;span&gt;每个站点需要把appsettings.json设置允许复制&lt;/span&gt;，不然会找不到文件！！&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; Demo.ZipkinCommon
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureSettings&lt;/span&gt;
{&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IConfiguration &lt;span class=&quot;hljs-title&quot;&gt;CreateConfiguration&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
var builder = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ConfigurationBuilder()
.AddJsonFile(&lt;span class=&quot;hljs-string&quot;&gt;&quot;appsettings.json&quot;&lt;/span&gt;, optional: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;, reloadOnChange: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)
.AddEnvironmentVariables();
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; builder.Build();
}
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公用部分完成了。我们看看站点Demo.ZipKinWeb代码。Startup继承抽象类CommonStartup，并利用.netCore内置依赖注入，将Service和仓储注入进来。由于不支持直接注入泛型，但支持type类型的注入，间接也解决了泛型注入问题。关于依赖注入的讲解，你可以参考上篇文中依赖注入部分，加深理解。&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; Demo.ZipKinWeb
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Startup&lt;/span&gt; :&lt;/span&gt; CommonStartup
{
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Startup&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IConfiguration configuration)&lt;/span&gt;
&lt;/span&gt;{
Configuration = configuration;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IConfiguration Configuration { get; }
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; override &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;
&lt;/span&gt;{
services.Configure&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;
{

options.CheckConsentNeeded = context =&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;
options.MinimumSameSitePolicy = SameSiteMode.None;
});
services.AddScoped(typeof(IRepository&amp;lt;&amp;gt;), typeof(BaseRepository&amp;lt;&amp;gt;));
services.AddScoped&amp;lt;IUserService, UserService&amp;gt;();
services.AddScoped&amp;lt;IAddressService, AddressService&amp;gt;();
services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; override &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IConfiguration configuration)&lt;/span&gt;
&lt;/span&gt;{
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseCookiePolicy();
app.UseMvc(routes =&amp;gt;
{
routes.MapRoute(
name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;default&quot;&lt;/span&gt;,
&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;{controller=Home}/{action=Index}/{id?}&quot;&lt;/span&gt;);
});
}
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了实现聚合两个站点的效果，在Add的方法内，特意调用一下另外个站点的get&lt;/p&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt; [HttpPost]
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IActionResult Add([FromBody]User user)
{
_userService.AddUser(user);

&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; client = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RestClient($&lt;span class=&quot;hljs-string&quot;&gt;&quot;{ConfigEx.WebSite}&quot;&lt;/span&gt;);
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; request = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RestRequest($&lt;span class=&quot;hljs-string&quot;&gt;&quot;/user/get&quot;&lt;/span&gt;, Method.POST);
request.AddParameter(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;, user.Id); 
IRestResponse response = client.Execute(request);
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; content = response.Content;

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Content(content+_addressService.Test());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建好必要的Controller和Action后，将两个站点都设为已启动。就可以查看效果了。&lt;br/&gt;postman是个测试接口的好工具，点击Send。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;710&quot; data-height=&quot;403&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-52c5045a738d73b7.png&quot; data-original-width=&quot;710&quot; data-original-height=&quot;403&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27919&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-52c5045a738d73b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/710/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;postman接口测试&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;打开我们的zipkin服务器链接，在WebUI上，可以看到两条请求数据。这是正确的，一条是Add,里面又调了另外一个站点的get,也能看到消耗的时间。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;778&quot; data-height=&quot;567&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-bed01fda6fc38fe0.png&quot; data-original-width=&quot;778&quot; data-original-height=&quot;567&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;29868&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-bed01fda6fc38fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;span&gt;&lt;span&gt;监测数据&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;span&gt;点击去查看详情，我们能看到更多数据。&lt;/span&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;806&quot; data-height=&quot;627&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-4daef21a3ea31540.png&quot; data-original-width=&quot;806&quot; data-original-height=&quot;627&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;47349&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-4daef21a3ea31540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/806/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;请求详情&lt;/p&gt;
&lt;/div&gt;
&lt;span&gt;然后继续点击 菜单中的&lt;/span&gt;&lt;span&gt;Dependencies&lt;/span&gt;&lt;span&gt;，确发现是空值，按道理来讲，请求了两个站点，又访问了数据库。怎么会是空值呢？？？&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1177&quot; data-height=&quot;223&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-7d8bc31cd0cdc510.png&quot; data-original-width=&quot;1177&quot; data-original-height=&quot;223&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;19549&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-7d8bc31cd0cdc510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;/div&gt;
&lt;span&gt;这个时候，我只能又求助bing了。&lt;/span&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;zipkin Dependencies no data&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;果然网友是万能的。&lt;a href=&quot;https://github.com/openzipkin/zipkin/issues/2016&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;elasticsearch存储,zipkin依赖没有数据&lt;/a&gt;&lt;br/&gt;里面有位外国同仁提到了&lt;/p&gt;
&lt;blockquote readability=&quot;4.4845360824742&quot;&gt;
&lt;p&gt;当你用你elasticsearch 或 Cassandra的时候，需要执行zipkin-dependencies&lt;br/&gt;（you need to run &lt;a href=&quot;https://github.com/openzipkin/zipkin-dependencies&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;https://github.com/openzipkin/zipkin-dependencies&lt;/a&gt; when using elasticsearch or Cassandra）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;p&gt;这是一个Spark作业，它将从您的数据存储区收集跨度，分析服务之间的链接，并存储它们以供以后在&lt;a href=&quot;https://github.com/openzipkin/zipkin/tree/master/zipkin-ui&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Web UI中&lt;/a&gt;呈现（例如&lt;a href=&quot;http://localhost:8080/dependency&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8080/dependency&lt;/a&gt;)。&lt;br/&gt;什么是Spark?&lt;br/&gt;Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。&lt;/p&gt;&lt;p&gt;此作业以UTC时间分析当天的所有跟踪。这意味着您应该将其安排在UTC午夜之前运行。&lt;/p&gt;&lt;p&gt;&lt;span&gt;这真是一个弱鸡的设计，作为内存运行的演示，竟然不提供及时汇总分析，还要跑定时任务&lt;/span&gt;&lt;br/&gt;依据官方提示，按最快的方式进行。&lt;/p&gt;</description>
<pubDate>Fri, 14 Sep 2018 13:57:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>前言 《牧神记》有一句话说的好，破心中神。当不再对分布式，微服务，CLR畏惧迷茫的时候，你就破了心中神。 《牧神记》有一句话说的好，破心中神。当不再对分布式，微服务，CLR畏惧迷茫的时候，你就破了心中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9649192.html</dc:identifier>
</item>
<item>
<title>Plasma Cash合约解读 - baizx</title>
<link>http://www.cnblogs.com/baizx/p/9649153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baizx/p/9649153.html</guid>
<description>&lt;p&gt;每条 Plasma 链都会将有关交易顺序的消息换算成一个哈希值存储在根链上。比特币和以太坊都属于根链——这两条区块链具有很高的安全性，并且通过去中心化保证了（安全性和活性）。&lt;/p&gt;
&lt;p&gt;Plasma 设计模型有两个主要的分支：Plasma MVP 和 Plasma Cash 。这里我们来研究 SmartPlasma 实现的 Plasma Cash 合约,并通过合约分析来回答大家关于 Plasma Cash 的一系列疑问.&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;1. 合约代码&lt;/h2&gt;
&lt;p&gt;SmartPlasma的合约代码肯定会不断升级,我针对他们在今天(2018-09-14)最新版本进行分析,这份代码目前保存在我的 github 上 &lt;a href=&quot;https://github.com/nkbai/blog/tree/master/smartplasma/contracts&quot;&gt;plasma cash&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;2. 合约文件简单介绍&lt;/h2&gt;
&lt;p&gt;文件夹中有不少与 Plasma Cash 无关的合约,这里只关注直接与 Plasma Cash 相关合约,像 ERC20Token 相关合约就忽略,自行查看.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mediator.sol 是 Plasma Cash 链中资产的进出口&lt;/li&gt;
&lt;li&gt;RootChain.sol 处理 Plasma Cash 子链(相对于以太坊而言)中的交易以及打包等&lt;/li&gt;
&lt;li&gt;libraries/MerkleProof.sol 是子链中交易用到的默克尔树,用于子链参与方进行欺诈证明 fraud proof.&lt;/li&gt;
&lt;li&gt;libraris/RLP.sol RLP编码支持,可以暂时忽略,子链中所有的交易都是用RLP 编码的.&lt;/li&gt;
&lt;li&gt;libraries/PlasmaLib.sol 生成 uid 的辅助函数&lt;/li&gt;
&lt;li&gt;ECRecovery.sol 签名验证&lt;/li&gt;
&lt;li&gt;datastructures/Transaction.sol 描述交易的数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;plasma-cash-1&quot;&gt;3. Plasma Cash 的基础数据结构&lt;/h2&gt;
&lt;p&gt;Plasma Cash 是一种子链结构,可以认为 Plasma Cash 是以太坊的一个是基于 =一种简化的UTXO模型的子链.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-2&quot;&gt;3.1 Plasma Cash 中的资产&lt;/h3&gt;
&lt;p&gt;Plasma Cash 中的资产都来自于以太坊,但是一旦进入 Plasma Cash 就会拥有唯一的 ID,并且不可分割. 可以参考 &lt;a href=&quot;https://github.com/nkbai/blog/blob/master/smartplasma/contracts/Mediator.sol&quot;&gt;Mediator.sol&lt;/a&gt;的deposit函数. Mediator就是 Plasma Cash 资产存放的地方.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;        /** @dev Adds deposits on Smart Plasma.
     *  @param currency Currency address.
     *  @param amount Amount amount of currency.
     */
    function deposit(address currency, uint amount) public {
        require(amount &amp;gt; 0);

        Token token = Token(currency);
        token.transferFrom(msg.sender, this, amount); /// deposit test1

        bytes32 uid = rootChain.deposit(msg.sender, currency, amount); /// deposit test2
        cash[uid] = entry({
            currency: currency,
            amount: amount
        });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过合约可以看出进入 Plasma Cash 的资产必须是 ERC20 Token,这些资产实际上是存在 Mediator 这个合约上,然后由 RootChain 为其分配一个唯一的 ID, 也就是 uid. 这个 uid 代表着什么 token, 有多少个.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-3&quot;&gt;3.2 Plasma Cash中的交易&lt;/h3&gt;
&lt;p&gt;关键代码在 &lt;a href=&quot;https://github.com/nkbai/blog/blob/master/smartplasma/contracts/libraries/datastructures/Transaction.sol&quot;&gt;Transaction.sol&lt;/a&gt;中.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;    struct Tx {
        uint prevBlock;
        uint uid;
        uint amount;
        address newOwner;
        uint nonce;
        address signer;
        bytes32 hash;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可能不太明显,需要解释才能看出来这是一个 UTXO 交易的模型. 这里面的amount 和 hash 实际上都有点啰唆,可以忽略. 那么剩下的成员需要来解释.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prevBlock&lt;/code&gt;就是 UTXO 中的输入,来自于哪块. 至于为什么没有像比特币一样的OutPoint 结构,也就是 TxHash+Index, 后续会讲到. &lt;code&gt;uid&lt;/code&gt; 就是交易的资产 ID &lt;code&gt;newOwner&lt;/code&gt; 交易输出给谁, 这里也不支持像 比特币一样的脚本. &lt;code&gt;nonce&lt;/code&gt; 是这笔资产的第多少次交易,在双花证明中有重要作用. &lt;code&gt;signer&lt;/code&gt;必须由资产原拥有者的签名.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;amount&lt;/code&gt; 不重要,是因为资产不可分割,导致这里的 Amount 不会随交易发生而发生变化. 而 &lt;code&gt;hash&lt;/code&gt; 则是可以直接计算出来.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-block&quot;&gt;3.3 Plasma Cash 中的 Block&lt;/h3&gt;
&lt;p&gt;如果一般区块链中的 Block 一样,他是交易的集合.但是不同于一般链的是,这里面的矿工(不一定是 Operator)不仅需要维护好子链,还需要周期性的将每一个 Block 对应的默克尔树根保存到以太坊中,这个工作只能有 Operator 来完成. 具体代码可见 &lt;a href=&quot;https://github.com/nkbai/blog/blob/master/smartplasma/contracts/RootChain.sol&quot;&gt;RootChain.sol&lt;/a&gt;的.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;    function newBlock(bytes32 hash) public onlyOperator {
        blockNumber = blockNumber.add(uint256(1));
        childChain[blockNumber] = hash;

        NewBlock(hash);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;交易证据提交者只能是 Operator, 也就是合约的创建者. 这个 Operator 既可以是普通账户,这时他就是这个子链的管理员.也可以是一份合约,那么就可以通过合约来规定子链的出块规则.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-4&quot;&gt;3.4 Plasma Cash 中资产的回归主链以太坊&lt;/h3&gt;
&lt;p&gt;当资产在 Plasma 中交易一段时间以后,持有者Bob如果想退出Plasma Cash 子链,那么就需要向以太坊合约也就是 RootChain证明,他确实拥有这一笔资产.&lt;/p&gt;
&lt;h4 id=&quot;section-2&quot;&gt;3.4.1 资产拥有证明&lt;/h4&gt;
&lt;p&gt;这个思路和 UTXO 的思路是一样的,Bob能证明这笔资产是从哪里转给我的即可.具体见&lt;a href=&quot;http://www.cnblogs.com/baizx/p/9649153.html&quot;&gt;RootChain.sol&lt;/a&gt;中的&lt;code&gt;startExit&lt;/code&gt;函数. 其思路非常简单,证明&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这笔资产来自哪里(在哪 M块中转移到了 Alice 手中)&lt;/li&gt;
&lt;li&gt;经过 Alice 签名转移给了Bob(在N块中 Alice 做了签名给我) 具体看代码 startExit&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;/** @dev Starts the procedure for withdrawal of the deposit from the system.
     *  @param previousTx Penultimate deposit transaction.
     *  @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param previousTxBlockNum The number of the block in which the penultimate transaction is included.
     *  @param lastTx Last deposit transaction.
     *  @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param lastTxBlockNum The number of the block in which the last transaction is included.
     */
    function startExit(
        bytes previousTx,
        bytes previousTxProof,
        uint256 previousTxBlockNum,
        bytes lastTx,
        bytes lastTxProof,
        uint256 lastTxBlockNum
    )
        public
    {
        Transaction.Tx memory prevDecodedTx = previousTx.createTx();
        Transaction.Tx memory decodedTx = lastTx.createTx();
        // 证明在 prevBlock的时候 Alice 拥有资产 uid
        require(previousTxBlockNum == decodedTx.prevBlock);
        require(prevDecodedTx.uid == decodedTx.uid);
        //amount 不变,证明资产不可分割
        require(prevDecodedTx.amount == decodedTx.amount);
        //Alice 确实签名转移给了我,并且交易是相邻的两笔交易
        require(prevDecodedTx.newOwner == decodedTx.signer);
        require(decodedTx.nonce == prevDecodedTx.nonce.add(uint256(1))); //紧挨着的两笔交易
        //我是 Bob, 我要来拿走这笔资产
        require(msg.sender == decodedTx.newOwner);
        require(wallet[bytes32(decodedTx.uid)] != 0);

        bytes32 prevTxHash = prevDecodedTx.hash;
        bytes32 prevBlockRoot = childChain[previousTxBlockNum];
        bytes32 txHash = decodedTx.hash;
        bytes32 blockRoot = childChain[lastTxBlockNum];

        require(
            prevTxHash.verifyProof(
                prevDecodedTx.uid,
                prevBlockRoot,
                previousTxProof
            )
        );
        require(
            txHash.verifyProof(
                decodedTx.uid,
                blockRoot,
                lastTxProof
            )
        );

        /// Record the exit tx.
        require(exits[decodedTx.uid].state == 0);
        require(challengesLength(decodedTx.uid) == 0);

        exits[decodedTx.uid] = exit({
            state: 2,
            exitTime: now.add(challengePeriod),
            exitTxBlkNum: lastTxBlockNum,
            exitTx: lastTx,
            txBeforeExitTxBlkNum: previousTxBlockNum,
            txBeforeExitTx: previousTx
        });

        StartExit(prevDecodedTx.uid, previousTxBlockNum, lastTxBlockNum);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码的前一半都是在用来证明在&lt;code&gt;lastTxBlockNum&lt;/code&gt;的时候,资产 uid 归Bob所有. 然后后一半就是提出来,Bob想把资产 uid 提走. 我的这个想法会暂时保存在合约中,等待别人来挑战.&lt;/p&gt;
&lt;h4 id=&quot;section-3&quot;&gt;3.4.2 等待其他人来挑战我&lt;/h4&gt;
&lt;p&gt;有了以上信息, 就可以证明在 N 块时,这笔资产归Bob所用.但是这肯定不够,无法证明现在资产仍然属于Bob,也无法证明Alice 没有在 M 块以后再给别人. 更加不能证明在 M 块的时候 Alice 真的是 uid 的拥有者? 这些问题,看起来很难回答,其实思路也很简单. 这个思路和雷电网络中解决问题的办法是一样的, 让这笔资产的利益攸关者站出来举证. 比如: 如果 Carol能够举证这笔资产Bob 后来又转移给了 Carol, 那么实际上 Bob 就是在双花. 具体的挑战以及迎战代码比较复杂,但是这也是 Plasma Cash 的核心安全性所在.如果没有这些,所有的参与者都将无法保证自己的权益.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//challengeExit 挑战资产uid 其实不属于 Bob
  /** @dev Challenges a exit.
     *  @param uid Unique identifier of a deposit.
     *  @param challengeTx Transaction that disputes an exit.
     *  @param proof Proof of inclusion of the transaction in a Smart Plasma block.
     *  @param challengeBlockNum The number of the block in which the transaction is included.
     */
    function challengeExit(
        uint256 uid,
        bytes challengeTx,
        bytes proof,
        uint256 challengeBlockNum
    )
        public
    {
        require(exits[uid].state == 2);

        Transaction.Tx memory exitDecodedTx = (exits[uid].exitTx).createTx();
        Transaction.Tx memory beforeExitDecodedTx = (exits[uid].txBeforeExitTx).createTx();
        Transaction.Tx memory challengeDecodedTx = challengeTx.createTx();

        require(exitDecodedTx.uid == challengeDecodedTx.uid);
        require(exitDecodedTx.amount == challengeDecodedTx.amount);

        bytes32 txHash = challengeDecodedTx.hash;
        bytes32 blockRoot = childChain[challengeBlockNum];

        require(txHash.verifyProof(uid, blockRoot, proof));

        // test challenge #1 &amp;amp; test challenge #2 最后一笔交易后面又进行了其他交易, Bob 在进行双花
        if (exitDecodedTx.newOwner == challengeDecodedTx.signer &amp;amp;&amp;amp;
        exitDecodedTx.nonce &amp;lt; challengeDecodedTx.nonce) {
            delete exits[uid];
            return;
        }

        // test challenge #3, 双花了,  Alice 给了两个人,并且挑战者 Carol的BlockNumer 更小,也就是发生的更早.
        if (challengeBlockNum &amp;lt; exits[uid].exitTxBlkNum &amp;amp;&amp;amp;
            (beforeExitDecodedTx.newOwner == challengeDecodedTx.signer &amp;amp;&amp;amp;
            challengeDecodedTx.nonce &amp;gt; beforeExitDecodedTx.nonce)) {
            delete exits[uid];
            return;
        }

        // test challenge #4   在 M块之前,还有一笔交易,Alice 需要证明自己在 M 块确实拥有 uid
        if (challengeBlockNum &amp;lt; exits[uid].txBeforeExitTxBlkNum ) {
            exits[uid].state = 1;
            addChallenge(uid, challengeTx, challengeBlockNum);
        }

        require(exits[uid].state == 1);

        ChallengeExit(uid);
    }

//Bob应战,再次举证,实际上这个过程就是要不断的追加证据,将所有的交易连起来,最终证明 Alice 在 M块确实拥有 uid
 /** @dev Answers a challenge exit.
     *  @param uid Unique identifier of a deposit.
     *  @param challengeTx Transaction that disputes an exit.
     *  @param respondTx Transaction that answers to a dispute transaction.
     *  @param proof Proof of inclusion of the respond transaction in a Smart Plasma block.
     *  @param blockNum The number of the block in which the respond transaction is included.
     */
    function respondChallengeExit(
        uint256 uid,
        bytes challengeTx,
        bytes respondTx,
        bytes proof,
        uint blockNum
    )
        public
    {
        require(challengeExists(uid, challengeTx));
        require(exits[uid].state == 1);

        Transaction.Tx memory challengeDecodedTx = challengeTx.createTx();
        Transaction.Tx memory respondDecodedTx = respondTx.createTx();

        require(challengeDecodedTx.uid == respondDecodedTx.uid);
        require(challengeDecodedTx.amount == respondDecodedTx.amount);
        require(challengeDecodedTx.newOwner == respondDecodedTx.signer);
        require(challengeDecodedTx.nonce.add(uint256(1)) == respondDecodedTx.nonce);
        require(blockNum &amp;lt; exits[uid].txBeforeExitTxBlkNum);

        bytes32 txHash = respondDecodedTx.hash;
        bytes32 blockRoot = childChain[blockNum];

        require(txHash.verifyProof(uid, blockRoot, proof));

        removeChallenge(uid, challengeTx);

        if (challengesLength(uid) == 0) {
            exits[uid].state = 2;
        }

        RespondChallengeExit(uid);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bob-uid&quot;&gt;3.4.3 挑战期过了, Bob 拿回资产 uid&lt;/h4&gt;
&lt;p&gt;挑战期过后,Bob 在Mediator.sol 中提出将资产退回到以太坊中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt; /** @dev withdraws deposit from Smart Plasma.
     *  @param prevTx Penultimate deposit transaction.
     *  @param prevTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param prevTxBlkNum The number of the block in which the penultimate transaction is included.
     *  @param txRaw lastTx Last deposit transaction.
     *  @param txProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param txBlkNum The number of the block in which the last transaction is included.
     */
    function withdraw(
        bytes prevTx,
        bytes prevTxProof,
        uint prevTxBlkNum,
        bytes txRaw,
        bytes txProof,
        uint txBlkNum
    )
        public
    {
        bytes32 uid = rootChain.finishExit(
            msg.sender,
            prevTx,
            prevTxProof,
            prevTxBlkNum,
            txRaw,
            txProof,
            txBlkNum
        );

        entry invoice = cash[uid];

        Token token = Token(invoice.currency);
        token.transfer(msg.sender, invoice.amount); /// 真正的资产转移

        delete(cash[uid]); 
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RootChain 再次验证&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt; /** @dev Finishes the procedure for withdrawal of the deposit from the system.
     *       Can only call the owner. Usually the owner is the mediator contract.
     *  @param account Account that initialized the deposit withdrawal.
     *  @param previousTx Penultimate deposit transaction.
     *  @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param previousTxBlockNum The number of the block in which the penultimate transaction is included.
     *  @param lastTx Last deposit transaction.
     *  @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param lastTxBlockNum The number of the block in which the last transaction is included.
     */
    function finishExit(
        address account,
        bytes previousTx,
        bytes previousTxProof,
        uint256 previousTxBlockNum,
        bytes lastTx,
        bytes lastTxProof,
        uint256 lastTxBlockNum
    )
        public
        onlyOwner
        returns (bytes32)
    {
        Transaction.Tx memory prevDecodedTx = previousTx.createTx();
        Transaction.Tx memory decodedTx = lastTx.createTx();

        require(previousTxBlockNum == decodedTx.prevBlock);
        require(prevDecodedTx.uid == decodedTx.uid);
        require(prevDecodedTx.amount == decodedTx.amount);
        require(prevDecodedTx.newOwner == decodedTx.signer);
        require(account == decodedTx.newOwner);

        bytes32 prevTxHash = prevDecodedTx.hash;
        bytes32 prevBlockRoot = childChain[previousTxBlockNum];
        bytes32 txHash = decodedTx.hash;
        bytes32 blockRoot = childChain[lastTxBlockNum];

        require(
            prevTxHash.verifyProof(
                prevDecodedTx.uid,
                prevBlockRoot,
                previousTxProof
            )
        );

        require(
            txHash.verifyProof(
                decodedTx.uid,
                blockRoot,
                lastTxProof
            )
        );

        require(exits[decodedTx.uid].exitTime &amp;lt; now); //挑战期过了
        require(exits[decodedTx.uid].state == 2); //并且没有人挑战或者我都给出了合适的证据
        require(challengesLength(decodedTx.uid) == 0);

        exits[decodedTx.uid].state = 3;

        delete(wallet[bytes32(decodedTx.uid)]);

        FinishExit(decodedTx.uid);

        return bytes32(decodedTx.uid);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;plasma-cash-5&quot;&gt;4. Plasma Cash 中的退出示例&lt;/h2&gt;
&lt;p&gt;sequenceDiagram participant o as operator participant u1 as alice participant u2 as bob participant u3 as carol participant u4 as david u1-&amp;gt;&amp;gt;rootchain: deposit asset to RootChain, get unique id asset1 o-&amp;gt;&amp;gt;rootchain: 生成 NewBlock 3, 记录此笔资产 u1-&amp;gt;&amp;gt;u2: transfer asset1 to bob o-&amp;gt;&amp;gt;rootchain: 生成 NewBlock 7, 记录此笔交易 u1-&amp;gt;&amp;gt;u3: transfer asset1 to carol o-&amp;gt;&amp;gt;rootchain: 生成 Newblock 11 记录此笔交易 u3-&amp;gt;&amp;gt;rootchain: 我要提现asset1到主链,提供asset1来自 alice,由 alice签名,发生在 11 u2-&amp;gt;&amp;gt;rootchain: 提出挑战,asset1应该属于我,提供 asset1 来自 alice,由 aice签名,发生在 7,rootchain 判定bob证据有效,拒绝carol提现 u2-&amp;gt;&amp;gt;u4: transfer asset1 to devid o-&amp;gt;&amp;gt;rootchain:生成 Newblock 27, 记录此笔交易 u4-&amp;gt;&amp;gt;rootchain:提现 asset1,来自 bob,有 bob的签名,发生在 27 loop david wait for challenge u4-&amp;gt;&amp;gt;u4:等待挑战期两周时间 end u4-&amp;gt;&amp;gt; rootchain: withdraw,提现,将asset1从rootchain 转走&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;5. 其他问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;为什么 Plasma Cash 中的资产是不可分割的?&lt;br/&gt;进入 rootchain 的资产类似于比特币的 UTXO 模型,但是是不可分割的,这个可以通过交易验证时每次都要求 amount 不变可以得出.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;operator 的作用是什么?&lt;br/&gt;operator 负责将子链中的交易证据(默克尔树)提交证明到以太坊主链中.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;operator 是否必须可信任的?&lt;br/&gt;是的. 虽然 operator 不能将他人资产随意转移,但是却可以阻止他人资产转移.也就是说无法从 Plasma 子链中退回到以太坊中. 当然这部分是可以改进,降低 operator 作恶带来的风险.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;operator 是否可以是一个合约呢?&lt;br/&gt;是的. 如果 operator 是一个 Pos 共识合约,那么可以降低问题3中的风险&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 14 Sep 2018 13:46:00 +0000</pubDate>
<dc:creator>baizx</dc:creator>
<og:description>Plasma Cash合约解读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baizx/p/9649153.html</dc:identifier>
</item>
</channel>
</rss>