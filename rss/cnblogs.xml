<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>量化投资与Python之pandas - Fugui</title>
<link>http://www.cnblogs.com/yifugui/p/8385444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifugui/p/8385444.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;title&gt;量化投资与Python之pandas - Fugui - 博客园&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=ON3Mxdo4-HlSMqbNDBZXhFIcGLon3eZDvU8zBESgwkk1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/BlueSky/bundle-BlueSky.css?v=_lYRTG5SjWWADGcuS8G-fWWj62fg5g8s6xd9-hRa-g01&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/blog/customcss/366451.css?v=RMoQHJ3wWXQA4PrmrZpq21pI5gE%3d&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/BlueSky/bundle-BlueSky-mobile.css?v=xpys-unA3grq_TeWJ40iCbv3xpRibOcl8nliujozjeY1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;http://www.cnblogs.com/yifugui/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;http://www.cnblogs.com/yifugui/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;http://www.cnblogs.com/yifugui/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;
&lt;h2&gt;&lt;span&gt;pandas：数据分析&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;pandas是一个强大的Python数据分析的工具包。&lt;br/&gt;pandas是基于NumPy构建的。&lt;/h4&gt;
&lt;h4&gt;pandas的主要功能&lt;br/&gt;具备对其功能的数据结构DataFrame、Series&lt;br/&gt;集成时间序列功能&lt;br/&gt;提供丰富的数学运算和操作&lt;br/&gt;灵活处理缺失数据&lt;/h4&gt;
&lt;h4&gt;安装方法：pip install pandas&lt;br/&gt;引用方法：import pandas as pd&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;pandas：Series&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;Series是一种类似于一位数组的对象，由一组数据和一组与之相关的数据标签（索引）组成。&lt;/h4&gt;
&lt;h4&gt;创建方式：&lt;/h4&gt;
&lt;h4&gt;&lt;em id=&quot;__mceDel&quot;&gt;pd.Series([4,7,-5,3])&lt;br/&gt;pd.Series([4,7,-5,3],index=['a','b','c','d'])&lt;br/&gt;pd.Series({'a':1, 'b':2})&lt;br/&gt;pd.Series(0, index=['a','b','c','d’])&lt;/em&gt;&lt;/h4&gt;
&lt;h4&gt;获取值数组和索引数组：values属性和index属性&lt;br/&gt;Series比较像列表（数组）和字典的结合体。&lt;br/&gt;Series支持数组的特性：&lt;br/&gt;从ndarray创建Series：Series(arr)&lt;br/&gt;与标量运算：sr*2&lt;br/&gt;两个Series运算：sr1+sr2&lt;br/&gt;索引：sr[0], sr[[1,2,4]]&lt;br/&gt;切片：sr[0:2]（切片依然是视图形式）&lt;br/&gt;通用函数：np.abs(sr)&lt;br/&gt;布尔值过滤：sr[sr&amp;gt;0]&lt;br/&gt;统计函数：mean() sum() cumsum()&lt;br/&gt;Series支持字典的特性（标签）：&lt;br/&gt;从字典创建Series：Series(dic),&lt;br/&gt;in运算：’a’ in sr、for x in sr&lt;br/&gt;键索引：sr['a'], sr[['a', 'b', 'd']]&lt;br/&gt;键切片：sr['a':'c']&lt;br/&gt;其他函数：get('a', default=0)等&lt;br/&gt;pandas：Series数据对齐&lt;br/&gt;pandas在运算时，会按索引进行对齐然后计算。如果存在不同的索引，则结果的索引是两个操作数索引的并集。&lt;/h4&gt;
&lt;h4&gt;例：&lt;br/&gt;sr1 = pd.Series([12,23,34], index=['c','a','d'])&lt;br/&gt;sr2 = pd.Series([11,20,10], index=['d','c','a',])&lt;br/&gt;sr1+sr2&lt;br/&gt;sr3 = pd.Series([11,20,10,14], index=['d','c','a','b'])&lt;br/&gt;sr1+sr3&lt;/h4&gt;
&lt;h4&gt;如何在两个Series对象相加时将缺失值设为0？&lt;br/&gt;sr1.add(sr2, fill_value=0)&lt;br/&gt;灵活的算术方法：add, sub, div, mul&lt;/h4&gt;
&lt;h4&gt;缺失数据：使用NaN（Not a Number）来表示缺失数据。其值等于np.nan。内置的None值也会被当做NaN处理。&lt;br/&gt;处理缺失数据的相关方法：&lt;br/&gt;dropna() 过滤掉值为NaN的行&lt;br/&gt;fillna() 填充缺失数据&lt;br/&gt;isnull() 返回布尔数组，缺失值对应为True&lt;br/&gt;notnull() 返回布尔数组，缺失值对应为False&lt;/h4&gt;
&lt;h4&gt;过滤缺失数据：sr.dropna() 或 sr[data.notnull()]&lt;br/&gt;填充缺失数据：fillna(0)&lt;/h4&gt;

&lt;h2&gt;&lt;span&gt;pandas：整数索引&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;整数索引的pandas对象往往会使新手抓狂。&lt;br/&gt;例：&lt;br/&gt;sr = np.Series(np.arange(4.))&lt;br/&gt;sr[-1]&lt;/h4&gt;
&lt;h4&gt;如果索引是整数类型，则根据整数进行数据操作时总是面向标签的。&lt;br/&gt;loc属性 以标签解释&lt;br/&gt;iloc属性 以下标解释&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;pandas：DataFrame&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;查看数据常用属性及方法：&lt;br/&gt;index 获取索引&lt;br/&gt;T 转置&lt;br/&gt;columns 获取列索引&lt;br/&gt;values 获取值数组&lt;br/&gt;describe() 获取快速统计&lt;/h4&gt;
&lt;h4&gt;DataFrame各列name属性：列名&lt;br/&gt;rename(columns={})&lt;br/&gt;查看数据常用属性及方法：&lt;br/&gt;index 获取索引&lt;br/&gt;T 转置&lt;br/&gt;columns 获取列索引&lt;br/&gt;values 获取值数组&lt;br/&gt;describe() 获取快速统计&lt;/h4&gt;
&lt;h4&gt;DataFrame各列name属性：列名&lt;br/&gt;rename(columns={})&lt;/h4&gt;
&lt;h4&gt;DataFrame有行索引和列索引。&lt;/h4&gt;
&lt;h4&gt;&lt;em id=&quot;__mceDel&quot;&gt;DataFrame同样可以通过标签和位置两种方法进行索引和切片。&lt;/em&gt;&lt;/h4&gt;
&lt;h4&gt;DataFrame使用索引切片：&lt;br/&gt;方法1：两个中括号，先取列再取行。 df['A'][0]&lt;br/&gt;方法2（推荐）：使用loc/iloc属性，一个中括号，逗号隔开，先取行再取列。&lt;br/&gt;loc属性：解释为标签&lt;br/&gt;iloc属性：解释为下标&lt;br/&gt;向DataFrame对象中写入值时只使用方法2&lt;br/&gt;行/列索引部分可以是常规索引、切片、布尔值索引、花式索引任意搭配。（注意：两部分都是花式索引时结果可能与预料的不同）&lt;br/&gt;通过标签获取：&lt;br/&gt;df['A']&lt;br/&gt;df[['A', 'B']]&lt;br/&gt;df['A'][0]&lt;br/&gt;df[0:10][['A', 'C']]&lt;br/&gt;df.loc[:,['A','B']]&lt;br/&gt;df.loc[:,'A':'C']&lt;br/&gt;df.loc[0,'A']&lt;br/&gt;df.loc[0:10,['A','C']]&lt;br/&gt;通过位置获取：&lt;br/&gt;df.iloc[3]&lt;br/&gt;df.iloc[3,3]&lt;br/&gt;df.iloc[0:3,4:6]&lt;br/&gt;df.iloc[1:5,:]&lt;br/&gt;df.iloc[[1,2,4],[0,3]]&lt;/h4&gt;
&lt;h4&gt;通过布尔值过滤：&lt;br/&gt;df[df['A']&amp;gt;0]&lt;br/&gt;df[df['A'].isin([1,3,5])]&lt;br/&gt;df[df&amp;lt;0] = 0&lt;br/&gt;DataFrame对象在运算时，同样会进行数据对齐，行索引与列索引分别对齐。&lt;br/&gt;结果的行索引与列索引分别为两个操作数的行索引与列索引的并集。&lt;/h4&gt;
&lt;h3&gt;DataFrame处理缺失数据的相关方法：&lt;/h3&gt;
&lt;h4&gt;dropna(axis=0,where='any',…)&lt;br/&gt;fillna()&lt;br/&gt;isnull()&lt;br/&gt;notnull()&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;pandas：其他常用方法&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;pandas常用方法（适用Series和DataFrame）：&lt;br/&gt;mean(axis=0,skipna=False)&lt;br/&gt;sum(axis=1)&lt;br/&gt;sort_index(axis, …, ascending) 按行或列索引排序&lt;br/&gt;sort_values(by, axis, ascending) 按值排序&lt;br/&gt;NumPy的通用函数同样适用于pandas&lt;/h4&gt;
&lt;h4&gt;apply(func, axis=0) 将自定义函数应用在各行或者各列上 ，func可返回标量或者Series&lt;br/&gt;applymap(func) 将函数应用在DataFrame各个元素上&lt;br/&gt;map(func) 将函数应用在Series各个元素上&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;pandas：时间对象处理&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;时间序列类型：&lt;br/&gt;时间戳：特定时刻&lt;br/&gt;固定时期：如2017年7月&lt;br/&gt;时间间隔：起始时间-结束时间&lt;br/&gt;Python标准库：datetime&lt;br/&gt;date time datetime timedelta&lt;br/&gt;dt.strftime()&lt;br/&gt;strptime()&lt;br/&gt;灵活处理时间对象：dateutil包&lt;br/&gt;dateutil.parser.parse()&lt;br/&gt;成组处理时间对象：pandas&lt;br/&gt;pd.to_datetime(['2001-01-01', '2002-02-02'])&lt;br/&gt;产生时间对象数组：date_range&lt;br/&gt;start 开始时间&lt;br/&gt;end 结束时间&lt;br/&gt;periods 时间长度&lt;br/&gt;freq 时间频率，默认为'D'，可选H(our),W(eek),B(usiness),S(emi-)M(onth),(min)T(es), S(econd), A(year),…&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;pandas：时间序列&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;时间序列就是以时间对象为索引的Series或DataFrame。&lt;/h4&gt;
&lt;h4&gt;datetime对象作为索引时是存储在DatetimeIndex对象中的。&lt;/h4&gt;
&lt;h4&gt;时间序列特殊功能：&lt;/h4&gt;
&lt;h4&gt;传入“年”或“年月”作为切片方式&lt;br/&gt;传入日期范围作为切片方式&lt;br/&gt;丰富的函数支持：resample(), strftime(), ……&lt;br/&gt;批量转换为datetime对象：to_pydatetime()&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;pandas：从文件读取&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;读取文件：从文件名、URL、文件对象中加载数据&lt;br/&gt;read_csv 默认分隔符为csv&lt;br/&gt;read_table 默认分隔符为\t&lt;br/&gt;read_excel 读取excel文件&lt;br/&gt;读取文件函数主要参数：&lt;br/&gt;sep 指定分隔符，可用正则表达式如'\s+'&lt;br/&gt;header=None 指定文件无列名&lt;br/&gt;name 指定列名&lt;br/&gt;index_col 指定某列作为索引&lt;br/&gt;skip_row 指定跳过某些行&lt;br/&gt;na_values 指定某些字符串表示缺失值&lt;br/&gt;parse_dates 指定某些列是否被解析为日期，布尔值或列表&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;pandas：写入到文件&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;写入到文件：&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;to_csv&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;写入文件函数的主要参数：&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;sep&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;na_rep 指定缺失值转换的字符串，默认为空字符串&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;header=False 不输出列名一行&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;index=False 不输出行索引一列&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;cols 指定输出的列，传入列表&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;其他文件类型：json, XML, HTML, 数据库&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;pandas转换为二进制文件格式（pickle）:&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;save&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;load&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2018-01-30 15:58&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/yifugui/&quot;&gt;Fugui&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=8385444&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/yifugui/p/8385444.html#&quot; onclick=&quot;AddToWz(8385444);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Tue, 30 Jan 2018 07:58:00 +0000</pubDate>
<dc:creator>Fugui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yifugui/p/8385444.html</dc:identifier>
</item>
<item>
<title>Java进阶篇（五）——Java的I/O技术 - 0o霏霏o0</title>
<link>http://www.cnblogs.com/adamjwh/p/8379903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adamjwh/p/8379903.html</guid>
<description>&lt;p&gt;　　程序中，为了永久的保存创建的数据，需要将其保存在磁盘文件中，以便在其它程序中使用它们。Java的I/O技术可以将数据保存到文本文件、二进制文件甚至是ZIP压缩文件中，以达到永久性保存数据的要求。&lt;/p&gt;
&lt;p&gt;　　本篇我们要介绍的内容就是Java的I/O技术，即输入/输出。&lt;/p&gt;
&lt;h2&gt;一、输入/输出流&lt;/h2&gt;
&lt;p&gt;　　流是一组有序的数据序列，根据操作的类型，可分为输入流和输出流。&lt;/p&gt;
&lt;p&gt;　　而专门负责各种方式的输入、输出的类，都被放在java.io包中。所有输入流都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类；所有输出流都是抽象类OutputStream（字节输出流）或抽象类Writer（字符输出流）的子类。&lt;/p&gt;
&lt;h3&gt;　　1. 字节输入/输出流&lt;/h3&gt;
&lt;p&gt;　　下面是一个字节输入/输出流的实例。其中，第14行为从输入流中读取字节并存入buffer数组中，最长读取2500个字节，返回值b为实际读取的长度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;  
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;  
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IOExample {  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             File file = &lt;span&gt;new&lt;/span&gt; File(&quot;E:\\test.txt&quot;);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个文件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            
&lt;span&gt;11&lt;/span&gt;             FileInputStream readfile = &lt;span&gt;new&lt;/span&gt; FileInputStream(file);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建输入流     &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt; buffer[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[2500];        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字节数组  &lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             b = readfile.read(buffer, 1, 2000);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1为buffer数组中的起始偏移量  &lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             String str = &lt;span&gt;new&lt;/span&gt; String(buffer, 0, b, &quot;Default&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            System.out.println(str);  
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             readfile.close();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭流  &lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             FileOutputStream writefile = &lt;span&gt;new&lt;/span&gt; FileOutputStream(file, &lt;span&gt;true&lt;/span&gt;);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个输出流，true为保留原有数据，新数据追加至结尾&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             writefile.write(buffer, 0&lt;span&gt;, b);  
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            writefile.close();  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {  
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            e.printStackTrace();  
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　上述代码中的FileInputStream类和FileOutputStream类属于文件输入输出流，该类分别继承自InputStream类和OutputStream类。&lt;/p&gt;
&lt;p&gt;　　InputStream类常用方法需了解read()、close()、reset()等方法；OutputStream类常用方法需了解write()、flush()、close()等方法。具体可参照API。&lt;/p&gt;
&lt;h3&gt;　　2. 字符输入/输出流&lt;/h3&gt;
&lt;p&gt;　　下面是一个字符输入/输出流的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileReader;  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileWriter;  
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IOExample {  
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             FileReader fileread = &lt;span&gt;new&lt;/span&gt; FileReader(&quot;E:\\test.txt&quot;);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符输入流，读取文件信息    &lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;char&lt;/span&gt;[] cbuf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[500&lt;span&gt;];  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; b = fileread.read(cbuf, 0, 500&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            System.out.println(String.valueOf(cbuf));  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            fileread.close();  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;             FileWriter filewriter = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;E:\\test.txt&quot;, &lt;span&gt;true&lt;/span&gt;);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符输出流，向输出流中写入信息，并且保留原有数据，追加数据值末尾处 &lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            filewriter.write(cbuf);  
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            filewriter.close();  
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {  
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();  
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码中的FileReader类和FileWriter类也属于文件输入输出流。&lt;/p&gt;
&lt;h3&gt;　　3. 文件输入/输出流&lt;/h3&gt;
&lt;p&gt;　　上面的代码中出现了一个新的名词叫文件输入/输出流，也就是FileInputStream、FileOutputStream和FileReader、FileWriter。它们的作用是与指定的文件建立连接，将需要的数据永久保存到文件中。&lt;/p&gt;
&lt;p&gt;　　FileInputStream类和FileOutputStream类都是用来操作磁盘文件的，如果用户的文件读取比较简单，则可使用该类。但由于汉字在文件中占用两个字节，读取不好可能出现乱码现象。&lt;/p&gt;
&lt;p&gt;　　FileReader类和FileWriter类可避免乱码现象，分别对应了FileInputStream类和FileOutputStream类。&lt;/p&gt;
&lt;h2&gt;二、File类&lt;/h2&gt;
&lt;p&gt;　　File类是io包中唯一代表磁盘文件本身的对象，可以通过调用File类中的方法，实现创建、删除、重命名文件等。&lt;/p&gt;
&lt;h3&gt;　　1. 文件的创建与删除&lt;/h3&gt;
&lt;p&gt;　　可以使用File类创建一个文件对象，三种构造方法的语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(String pathname)
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(String parent, String child)
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; File(File f, String child)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　pathname是路径名称，parent是父路径字符串，child是子路径字符串，f是父路径对象。如下例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(&quot;E:/test.txt&quot;&lt;span&gt;);
File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;E:/myword&quot;,&quot;word.txt&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果E:/myword目录下没有名称为word的文件，File类对象可通过createNewFile()方法创建一个名称为word.txt的文件；如果存在，可通过delete()方法将其删除。&lt;/p&gt;
&lt;h3&gt;　　2. 获取文件信息&lt;/h3&gt;
&lt;p&gt;　　File类提供了许多方法用于获取文件本身的一些信息，下表是一些常用方法。&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getName()&lt;/td&gt;
&lt;td&gt;获取文件的名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;canRead()&lt;/td&gt;
&lt;td&gt;判断文件是否可读&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;canWrite()&lt;/td&gt;
&lt;td&gt;判断文件是否可以被写入&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;exist()&lt;/td&gt;
&lt;td&gt;判断文件是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;length()&lt;/td&gt;
&lt;td&gt;获取文件的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getAbsolutePath()&lt;/td&gt;
&lt;td&gt;获取文件的绝对路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getParent()&lt;/td&gt;
&lt;td&gt;获取文件的父路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;isFile()&lt;/td&gt;
&lt;td&gt;判断文件是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;isDirectory()&lt;/td&gt;
&lt;td&gt;判断文件是否是一个目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;isHidden()&lt;/td&gt;
&lt;td&gt;判断文件是否是隐藏文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;lastModifed()&lt;/td&gt;
&lt;td&gt;获取文件最后修改时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　如我们创建一个文件，获取文件长度等信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileTest {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         File file = &lt;span&gt;new&lt;/span&gt; File(&quot;E:/myword&quot;, &quot;word.txt&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建文件对象&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(file.exists()) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断文件是否存在&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             String name = file.getName();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取文件名称&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; length = file.length();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取文件长度&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; hidden = file.isHidden();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断文件是否是隐藏文件&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             
&lt;span&gt;12&lt;/span&gt;             System.out.println(&quot;文件名称：&quot; +&lt;span&gt; name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             System.out.println(&quot;文件长度是：&quot; +&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             System.out.println(&quot;是否是隐藏文件：&quot; +&lt;span&gt; hidden);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             System.out.println(&quot;文件不存在&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、带缓存的输入/输出流&lt;/h2&gt;
&lt;p&gt;　　缓存是I/O的一种性能优化。缓存流为I/O流增加了内存缓存区。&lt;/p&gt;
&lt;h3&gt;　　1. BufferedInputStream类与BufferedOutoutStream类&lt;/h3&gt;
&lt;p&gt;　　构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BufferedInputStream(InputStream in)
BufferedInputStream(InputStream in, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size)
BufferedOutputStream(OutputStream in)
BufferedOutputStream(OutputStream in, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2. BufferedReader类与BufferedWriter类&lt;/h3&gt;
&lt;p&gt;　　常用方法如下：&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read()&lt;/td&gt;
&lt;td&gt;读取单个字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;readLine()&lt;/td&gt;
&lt;td&gt;读取一个文本行，返回为字符串；若无数据则返回为null&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;write(String s, int off, int len)&lt;/td&gt;
&lt;td&gt;写入字符串的某一部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;flush()&lt;/td&gt;
&lt;td&gt;刷新该流的缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;newLine()&lt;/td&gt;
&lt;td&gt;写入一个行分隔符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　这里要注意，在使用BufferedWriter类的write()方法时，数据并没有立刻被写入到输出流时，而是首先进入缓存区中，如果想立刻将缓冲区中的数据写入输出流中，一定要调用flush()方法。 &lt;/p&gt;
&lt;h2&gt;四、数据输入/输出流&lt;/h2&gt;
&lt;p&gt;　　数据输入/输出流为DataInputStream类与DateOutputStream类，允许应用程序以与机器无关的方式从底层输入流中读取基本Java数据类型。&lt;/p&gt;
&lt;p&gt;　　构造方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DataInputStream(InputStream in)
DataOutputStream(OutputStream out)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　DataOutputStream类提供了以下三种写入字符串的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;writeBytes(String s)
writeChars(String s)
writeUTF(String s)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、ZIP压缩输入/输出流&lt;/h2&gt;
&lt;p&gt;　　利用ZipOutputStream类对象，可将文件压缩为.zip文件。&lt;/p&gt;
&lt;p&gt;　　构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ZipOutputStream(OutputStream out);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ZipInputStream类可读取ZIP压缩格式的文件，包括对已压缩和未压缩条目的支持。&lt;/p&gt;
&lt;p&gt;　　构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ZipInputStream(InputStream out);
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 30 Jan 2018 07:53:00 +0000</pubDate>
<dc:creator>0o霏霏o0</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adamjwh/p/8379903.html</dc:identifier>
</item>
<item>
<title>H5+混合移动app应用开发——坑我太甚 - 邹琼俊</title>
<link>http://www.cnblogs.com/jiekzou/p/8384863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiekzou/p/8384863.html</guid>
<description>&lt;p&gt;用了MUI之后，才发现，那坑比我想象之中的要多得多，有些是H5的坑，有些是plus的坑，接下来我一一来吐槽一番。&lt;/p&gt;
&lt;h2&gt;IOS下面，上拉的时候，速度稍微快一点，表头自动隐藏，等你不拉的时候又自动显示&lt;/h2&gt;
&lt;p&gt;这种情况，在Android下面是正常的。why？&lt;/p&gt;
&lt;p&gt;因为mui框架的头部header和底部nav都是采用的fixed布局&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;header &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-bar mui-bar-nav action-head&quot;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/413851/201801/413851-20180130141601625-1148580541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而IOS下面压根就不支持fixed布局，所以喽就杯具了，这个问题还体现在另一种情况下。那就是当页面中的内容很长超出了一屏，而且页面中存在文本框，这个时候如果我们文本框一聚焦，在ios下面会自动滚动，软键盘会弹出来，这时如果你上拉下拉操作，fixed布局的部分就漂浮了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抛弃mui中旧的openWindow和openWindowWithTitle，采用最新的titleNView&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
    owner.openWindowWithTitle = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (WebviewOptions, title) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _styles = {                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 窗口参数 参考5+规范中的WebviewStyle,也就是说WebviewStyle下的参数都可以在此设置&lt;/span&gt;
            titleNView: {                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 窗口的标题栏控件&lt;/span&gt;
                titleText: title,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标题栏文字,当不设置此属性时，默认加载当前页面的标题，并自动更新页面的标题&lt;/span&gt;
                titleColor: &quot;#fff&quot;,             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体颜色,颜色值格式为&quot;#RRGGBB&quot;,默认值为&quot;#000000&quot;&lt;/span&gt;
                titleSize: &quot;17px&quot;,                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体大小,默认17px&lt;/span&gt;
                backgroundColor: &quot;#449DED&quot;,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 控件背景颜色,颜色值格式为&quot;#RRGGBB&quot;,默认值为&quot;#F7F7F7&quot;&lt;/span&gt;
                progress: {                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标题栏控件的进度条样式&lt;/span&gt;
                    color: &quot;#56CF87&quot;,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进度条颜色,默认值为&quot;#00FF00&quot;  &lt;/span&gt;
                    height: &quot;2px&quot;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进度条高度,默认值为&quot;2px&quot;         &lt;/span&gt;
&lt;span&gt;                },
                splitLine: {                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标题栏控件的底部分割线，类似borderBottom&lt;/span&gt;
                    color: &quot;#CCCCCC&quot;,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分割线颜色,默认值为&quot;#CCCCCC&quot;  &lt;/span&gt;
                    height: &quot;0px&quot;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分割线高度,默认值为&quot;2px&quot;&lt;/span&gt;
&lt;span&gt;                },
                autoBackButton: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            },
        };
        WebviewOptions.styles &lt;/span&gt;=&lt;span&gt; _styles;
        mui.openWindow(WebviewOptions);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么官方提供的Demo没有这样的现象，说到这里，心里就火，官方提供的demo，限制了上拉下拉的速度，很慢的，所以自然无法出现表头在ios下面自动隐藏的情况，而且也没有这个长屏幕输入文本框的情况。可是官方没有给出任何说明，这才是最坑的。&lt;/p&gt;
&lt;p&gt;其它问题：这里的返回图标的大小无法设置。H5+文档中没有找到相关设置的地方，我晕。&lt;/p&gt;
&lt;h2&gt;设置状态栏颜色IOS下面无效&lt;/h2&gt;
&lt;p&gt;一开始，我直接是通过修改manifest.json的配置来进行修改的，怎知Android下面是可以了，但是ios下面无效。plus节点下面添加如下配置，将状态栏设置为蓝色背景。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&quot;plus&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;launchwebview&quot;:{&quot;statusbar&quot;:{&quot;background&quot;:&quot;#449DED&quot;&lt;span&gt;}},
        &lt;/span&gt;&quot;statusbar&quot;:{&quot;background&quot;:&quot;#449DED&quot;},&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;状态栏&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了在IOS中所有页面中修改状态栏颜色，我在一个公共的js文件中添加了如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
document.addEventListener('plusready', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    plus.navigator.setStatusBarBackground(&lt;/span&gt;&quot;#449DED&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置系统状态栏背景为蓝色&lt;/span&gt;
    plus.navigator.setStatusBarStyle(&quot;UIStatusBarStyleBlackOpaque&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置系统状态栏样式为浅色文字&lt;/span&gt;
}, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK，问题解决。&lt;/p&gt;
&lt;h2&gt;单WebView下面的上拉下拉问题&lt;/h2&gt;
&lt;p&gt;为什么官网给的Demo没问题？因为那Demo太简单了，实在是无法模拟真实的应用场景。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/413851/201801/413851-20180130144259593-242830957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我目前的解决办法：判断当主界面的数据大于2条时，这是因为我这里大于2条时会出现滚动条，我自动设置主界面的高度+1px，这样做是为了产生垂直滚动条，然后在所有触发这个滚动弹出层的地方，添加如下代码：（比如说点击状态、或者点击报修部门的时候）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
isEmptyScroll = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
window.scrollTo(&lt;/span&gt;1, 1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载数据列表的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;if&lt;/span&gt; (app.$data.list.length &amp;lt;= 2&lt;span&gt;) {&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEmptyScroll) {&lt;/span&gt;
                    g.id(&quot;pullrefresh&quot;).style.height = g.getScreenInfo('height') +1 + 'px'&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                g.id(&lt;/span&gt;&quot;pullrefresh&quot;).style.height = 'auto'&lt;span&gt;;
            }
            isEmptyScroll &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;公共js代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 获得屏幕的高度
     * @param {Object} element
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    owner.getScreenInfo &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (element) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element == 'width'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; document.documentElement.clientWidth ||&lt;span&gt; document.body.clientWidth;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; document.documentElement.clientHeight ||&lt;span&gt; document.body.clientHeigth;
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;据说采用双webview的话不会出现这种问题，我暂时没有去实验过，可是官方又推荐使用单webview的方式，说双webview太耗性能而且使用没那么方便。很操蛋啊，我自然是优先采用官方推荐的方式哇！&lt;/p&gt;
&lt;h2&gt;获取App缓存大小并清除缓存Android无效&lt;/h2&gt;
&lt;p&gt;按照H5+的方式去操作，IOS下面能取到值，但是Android无效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除缓存&lt;/span&gt;
                document.getElementById('clearCache').addEventListener('tap', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                    mui.confirm(&lt;/span&gt;'图片及离线缓存的内容将会被删除', '确定删除所有缓存？', btnArray, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.index == 1&lt;span&gt;) {
                            plus.cache.clear(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                                mui.toast(&lt;/span&gt;&quot;应用缓存清除成功!&quot;&lt;span&gt;);
                            });
                        }
                    });
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取缓存大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    mui.plusReady(function() {&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取缓存大小&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; _result = ''&lt;span&gt;;
                plus.cache.calculate(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(size) {
                    _result &lt;/span&gt;=&lt;span&gt; g.bytesToSize(size);
                    console.log(_result)
                    document.getElementById(&lt;/span&gt;&quot;cacheSize&quot;).innerText =&lt;span&gt;_result;
                });&lt;br/&gt;});&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;公共方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字节转换为KB等大小&lt;/span&gt;
    owner.bytesToSize = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (bytes) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bytes === 0) &lt;span&gt;return&lt;/span&gt; '0 B'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; k = 1024&lt;span&gt;;
        sizes &lt;/span&gt;= ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'&lt;span&gt;];
        i &lt;/span&gt;= Math.floor(Math.log(bytes) /&lt;span&gt; Math.log(k));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _size = (bytes /&lt;span&gt; Math.pow(k, i));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _size.toFixed(2) + ' ' +&lt;span&gt; sizes[i];&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前暂时没有想到什么好的办法解决。&lt;/p&gt;
&lt;h2&gt;波浪效果在部分Android机型下无效&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/413851/201801/413851-20180130152532187-935831136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于我这个动画特效是采用的css3，所以很容易想到是浏览器样式不兼容引起的。其实就是添加&lt;span&gt;-webkit-&lt;/span&gt;前缀来指定。因为移动端许多浏览器都是&lt;span&gt;webkit&lt;/span&gt;内核。&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;portrait-clockin fr&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt; v-on:tap&lt;/span&gt;&lt;span&gt;=&quot;doPunchCard()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dot2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dot3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;one fl&quot;&lt;/span&gt;&lt;span&gt; v-text&lt;/span&gt;&lt;span&gt;=&quot;nowTime&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;打卡&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;css样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;129&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.portrait-clockin&lt;/span&gt;{&lt;span&gt;width&lt;/span&gt;:&lt;span&gt; 3rem&lt;/span&gt;;&lt;span&gt;height&lt;/span&gt;:&lt;span&gt; 3rem&lt;/span&gt;;&lt;span&gt;margin&lt;/span&gt;:&lt;span&gt; 0 15px 0px 0px&lt;/span&gt;;}&lt;span&gt;
.fr &lt;/span&gt;{&lt;span&gt;
    float&lt;/span&gt;:&lt;span&gt; right&lt;/span&gt;;
}
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;上班打卡 水波纹效果&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
a.dot:active,a.dot2:active,a.dot3:active&lt;/span&gt;{&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; #70a236&lt;/span&gt;;}&lt;span&gt;
.dot &lt;/span&gt;{&lt;span&gt;
  animation&lt;/span&gt;:&lt;span&gt; sploosh 1.5s cubic-bezier(0.165, 0.84, 0.44, 1)&lt;/span&gt;;&lt;span&gt;
  -webkit-animation&lt;/span&gt;:&lt;span&gt;sploosh 1.5s cubic-bezier(0.165, 0.84, 0.44, 1)&lt;/span&gt;;
}&lt;span&gt;
.dot2 &lt;/span&gt;{&lt;span&gt;
  animation&lt;/span&gt;:&lt;span&gt; sploosh2 1.5s cubic-bezier(0.165, 0.84, 0.44, 1)&lt;/span&gt;;&lt;span&gt;
   -webkit-animation&lt;/span&gt;:&lt;span&gt;sploosh2 1.5s cubic-bezier(0.165, 0.84, 0.44, 1)&lt;/span&gt;;
}&lt;span&gt;
.dot3 &lt;/span&gt;{&lt;span&gt;
  animation&lt;/span&gt;:&lt;span&gt; sploosh3 1.5s cubic-bezier(0.165, 0.84, 0.44, 1)&lt;/span&gt;;&lt;span&gt;
  -webkit-animation&lt;/span&gt;:&lt;span&gt;sploosh3 1.5s cubic-bezier(0.165, 0.84, 0.44, 1)&lt;/span&gt;;
}&lt;span&gt;
.dot ul&lt;/span&gt;{&lt;span&gt;margin&lt;/span&gt;:&lt;span&gt; 0px&lt;/span&gt;;&lt;span&gt;padding&lt;/span&gt;:&lt;span&gt; 0px&lt;/span&gt;;&lt;span&gt;width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;margin&lt;/span&gt;:&lt;span&gt; 0.65rem 0px&lt;/span&gt;;}&lt;span&gt;
.dot li&lt;/span&gt;{&lt;span&gt;width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;font-size&lt;/span&gt;:&lt;span&gt; 0.48rem&lt;/span&gt;;&lt;span&gt;line-height&lt;/span&gt;:&lt;span&gt; 0.5rem&lt;/span&gt;;&lt;span&gt;height&lt;/span&gt;:&lt;span&gt; 0.5rem&lt;/span&gt;;}&lt;span&gt;
.dot li.one&lt;/span&gt;{&lt;span&gt;font-size&lt;/span&gt;:&lt;span&gt; 0.4rem&lt;/span&gt;;&lt;span&gt;line-height&lt;/span&gt;:&lt;span&gt; 0.8rem&lt;/span&gt;;&lt;span&gt;height&lt;/span&gt;:&lt;span&gt; 0.8rem&lt;/span&gt;;}&lt;span&gt;
.dot,.dot2,.dot3&lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 96px&lt;/span&gt;;&lt;span&gt;width&lt;/span&gt;:&lt;span&gt; 96px&lt;/span&gt;;&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt;line-height&lt;/span&gt;:&lt;span&gt; 96px&lt;/span&gt;;&lt;span&gt;text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;border-radius&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;z-index&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;animation-iteration-count&lt;/span&gt;:&lt;span&gt;infinite&lt;/span&gt;;&lt;span&gt;
  -webkit-animation-iteration-count&lt;/span&gt;:&lt;span&gt;infinite&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; transparent&lt;/span&gt;;
}&lt;span&gt;
@keyframes sploosh &lt;/span&gt;{&lt;span&gt;
  0% {box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 0px rgba(158, 203, 244, 0.7)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.7)&lt;/span&gt;;}&lt;span&gt;
  100% &lt;/span&gt;{&lt;span&gt;box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 10px rgba(158, 203, 244, 0)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0)&lt;/span&gt;;}&lt;span&gt;
}
@keyframes sploosh2 &lt;/span&gt;{&lt;span&gt;
  0% { box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 0px rgba(110, 179, 243, 0.7)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.7)&lt;/span&gt;;}&lt;span&gt;
  100% &lt;/span&gt;{&lt;span&gt;box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 6px rgba(110, 179, 243, 0)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.3)&lt;/span&gt;;}&lt;span&gt;
}
@keyframes sploosh3 &lt;/span&gt;{&lt;span&gt;
  0% {box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 0px rgba(255, 255, 255, 0.7)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.7)&lt;/span&gt;;}&lt;span&gt;
  100% &lt;/span&gt;{&lt;span&gt;box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 2px rgba(255, 255, 255, 0)&lt;/span&gt;;&lt;span&gt; background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 1)&lt;/span&gt;;}&lt;span&gt;
}

@-webkit-keyframes sploosh &lt;/span&gt;{&lt;span&gt;
  0% {-webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 0px rgba(158, 203, 244, 0.7)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.7)&lt;/span&gt;;}&lt;span&gt;
  100% &lt;/span&gt;{&lt;span&gt;-webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 10px rgba(158, 203, 244, 0)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0)&lt;/span&gt;;}&lt;span&gt;
}
@-webkit-keyframes sploosh2 &lt;/span&gt;{&lt;span&gt;
  0% {-webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 0px rgba(110, 179, 243, 0.7)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.7)&lt;/span&gt;;}&lt;span&gt;
  100% &lt;/span&gt;{&lt;span&gt;-webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 6px rgba(110, 179, 243, 0)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.3)&lt;/span&gt;;}&lt;span&gt;
}
@-webkit-keyframes sploosh3 &lt;/span&gt;{&lt;span&gt;
  0% {-webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 0px rgba(255, 255, 255, 0.7)&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 0.7)&lt;/span&gt;;}&lt;span&gt;
  100% &lt;/span&gt;{&lt;span&gt;-webkit-box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 2px rgba(255, 255, 255, 0)&lt;/span&gt;;&lt;span&gt; background&lt;/span&gt;:&lt;span&gt; rgba(84, 166, 240, 1)&lt;/span&gt;;}&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;波纹结束&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 关于圆点在IOS下面显示的问题&lt;/h2&gt;
&lt;p&gt;圆点效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/413851/201801/413851-20180130153352703-682566643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我之前的做法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;item.rad&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;round&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;span&gt;●&lt;/span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;小圆点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.round &lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;&lt;span&gt;height&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;&lt;span&gt;display&lt;/span&gt;:&lt;span&gt; -webkit-inline-box&lt;/span&gt;;&lt;span&gt;font-size&lt;/span&gt;:&lt;span&gt; 7px&lt;/span&gt;;&lt;span&gt;margin-left&lt;/span&gt;:&lt;span&gt; -2px&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;&lt;span&gt;text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;color&lt;/span&gt;:&lt;span&gt; #FD7777&lt;/span&gt;;&lt;span&gt;text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;top&lt;/span&gt;:&lt;span&gt; 5px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果我发现，在IOS下面这个小圆点是在是太小了，而且无论你怎么修改样式的宽和高都无效。&lt;/p&gt;
&lt;p&gt;后来的做法：&lt;/p&gt;
&lt;p&gt;HTML代码结构如下， &lt;span&gt;class&lt;span&gt;=&quot;round&quot;&lt;/span&gt;&lt;/span&gt;部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(item,index) in menus&quot;&lt;/span&gt;&lt;span&gt; v-on:tap&lt;/span&gt;&lt;span&gt;=&quot;getTaskList(item.name)&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-control-item&quot;&lt;/span&gt;&lt;span&gt; v-bind:id&lt;/span&gt;&lt;span&gt;=&quot;item.id&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;{'mui-active': !index}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;item.title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;(&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;item.taskNum&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;item.rad&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;round&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;小圆点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.round &lt;/span&gt;{&lt;span&gt;
    border-radius&lt;/span&gt;:&lt;span&gt;50%&lt;/span&gt;;&lt;span&gt;width&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;&lt;span&gt;height&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;&lt;span&gt;display&lt;/span&gt;:&lt;span&gt; -webkit-inline-box&lt;/span&gt;;&lt;span&gt;font-size&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;&lt;span&gt;margin-left&lt;/span&gt;:&lt;span&gt; -2px&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;&lt;span&gt;text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;background-color&lt;/span&gt;:&lt;span&gt; #FD7777&lt;/span&gt;;&lt;span&gt;text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;top&lt;/span&gt;:&lt;span&gt; 5px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;HBuilder更新有风险&lt;/h2&gt;
&lt;p&gt;HBuilder隔三差五的就会发布新的补丁，然后你每天打开的时候，它就会自动弹出提示框，提示你是否更新，如果你一不小心点击了更新，那你最好先看看补丁解决了哪些问题，看一下它的更新日志。&lt;/p&gt;
&lt;p&gt;然后一定要记得的是，要去更新你项目中mui.js、mui.css等等这些你项目中引用了的文件。如何更新呢？可以在最新的HBuilder中新建一个mui项目，然后把项目中的js和css文件拷贝过来。因为每一次打补丁，你很难确定它是否只修改了基座，还是其它mui相关的css或者js都有修改，所以保险的做法就是一起更新。还有个问题需要注意的是，每一次补丁升级，都有可能改出新的问题，所以在更新之前，建议先备份所有代码，或者给代码打一个标签。&lt;/p&gt;
&lt;h2&gt;使用图片缩放要注意&lt;/h2&gt;
&lt;p&gt;mui官方demo中提供了图片缩放功能，其实这里有需要注意的地方，如果需要用到图片缩放的界面中，存在文本框等需要输入和编辑的地方，会让你输入和编辑无效。也就是说你图片缩放只能在详情这种只需要展示的场景下使用，而官方是不会告诉你这些的，只有你被碰得头破血流，才会感到多么痛的领悟！&lt;/p&gt;
&lt;p&gt;暂时就先吐槽这么多，其它的问题还有很多....&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 07:43:00 +0000</pubDate>
<dc:creator>邹琼俊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiekzou/p/8384863.html</dc:identifier>
</item>
<item>
<title>Go语言是我见过最简洁的语言（除了lua） - 大萝卜卜</title>
<link>http://www.cnblogs.com/HelliX/p/8385209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HelliX/p/8385209.html</guid>
<description>&lt;h3&gt;写在前面：题目就是个标题党，在这里先道歉，其次撸主学过很多语言（基本上是个语言都要上一下的那种人，但是不会太深入，只做了解，因为很多用不到），但主要使用C#语言（不过已经开始恶心C#的臃肿，不要打我），还有一点：&lt;span&gt;这只是一篇记录我对go语言观后感的博客，只是肤浅的走马观花，并不是go语言的教程！&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;好了，前戏完了，进入正题&lt;/h3&gt;
&lt;p&gt;　　背景故事：今天上班略闲（你每天都很闲好嘛！所以钱包很可怜，唉），然后用PHP的时候有点恶心它的全局变量和闭包，又想起了前几天看大神帖子说C已经都快不行了，go和Rust很屌，于是看了下Rust，感觉有点复杂（毕竟是可以编写操作系统的语言。。。），相比之下go则精简许多，然后抽了上午浏览了一遍网上的教程，虽然只是照着写了几个例子，但确实惊叹于语法的简洁（前提是有C语言基础，不然一个指针可能就要被卡死。。。如果有动态脚本语言基础，也能加速理解其中某些部分），一下子喜欢上了这门简洁而有强大的语言，&lt;span&gt;感觉这是一门融合了很多语言特色的混合语言。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一部分，C语言过程式风格（过程式与函数式风格是两个对立的编程模型）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大概因为go语言的设计者，跟C语言有点渊源，所以基本的变量，函数定义这些，还是有着很浓重的C风格，还有struct，变量的作用域跟C语言保持一致，基本的流程控制也大致相同，顺便吐槽下，为什么博客园的编辑器的代码编辑里没有go语言！有一个比较重要的点，学过C的人都知道，C语言的强大，很大部分源于指针，可以直接操作硬件地址！go里面也有指针，虽然跟C里的虽然用法差不多，但是总感觉少了点什么（没错，好像不需要自己分配释放内存！），因为有垃圾回收（良心啊！）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
c : &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 声明实际变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ip *&lt;span&gt;int&lt;/span&gt;        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 声明指针变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
ip &lt;/span&gt;= &amp;amp;a  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 指针变量的存储地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体&lt;/span&gt;
type Books &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
   title &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
   author &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
   subject &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
   book_id &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第二部分，基础的数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;跟其他语言类似，支持数组，列表（序列），字典（map）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; balance = [&lt;span&gt;5&lt;/span&gt;]float32{&lt;span&gt;1000.0&lt;/span&gt;, &lt;span&gt;2.0&lt;/span&gt;, &lt;span&gt;3.4&lt;/span&gt;, &lt;span&gt;7.0&lt;/span&gt;, &lt;span&gt;50.0&lt;/span&gt;}  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个float数组
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字典&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; countryCapitalMap map[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;
   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建集合 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   countryCapitalMap &lt;/span&gt;= make(map[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
   
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; map 插入 key-value 对，各个国家对应的首都 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   countryCapitalMap[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;France&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Paris&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
   countryCapitalMap[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Italy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Rome&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
   countryCapitalMap[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Japan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tokyo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
   countryCapitalMap[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;India&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;New Delhi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;第三部分，面向对像&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这部分语法和普通语言（C#,JAVA）区别有点大，但本质是一个东西，是在struct上额外的添加函数（叫方法），比较特别的是它有一个interface，了解不深，请看管自行研究&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定义函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
type Circle &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
  radius float64
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该 method 属于 Circle 类型对象中的方法&lt;/span&gt;
&lt;span&gt;func (c Circle) getArea() float64 {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;c.radius 即为 Circle 类型对象中的属性&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3.14&lt;/span&gt; * c.radius *&lt;span&gt; c.radius
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;第四部分，脚本语言特色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PHP，js这类脚本语言都会有闭包这个概念（这个其实是函数式编程风格的特色），匿名函数（好吧，C#里面也有，Lamdba表达式），go语言里面也有，也支持多值操作，还有函数可以返回多个值（大概是放在类似于元组之类的里面）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
a, b = b, a&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接交换两个值，是不是很眼熟，很多脚本语言是可以这样的！！！
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;闭包&lt;/span&gt;
func getSequence() func() &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
   i:&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; func() &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
      i&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i  
   }
}

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 声明函数变量 ，函数可以直接复制给变量&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   getSquareRoot :&lt;/span&gt;=&lt;span&gt; func(x float64) float64 {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; math.Sqrt(x)
   }

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 使用函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   fmt.Println(getSquareRoot(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;第五部分，语言独特部分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;go从语法层次支持了goroutine + channel生产者-消费者模式，实现高并发模型！我不知道这一部分是不是和Erlang语言有类似。一般支持高并发的语言都有函数式风格的影子，函数式风格的很多概念非常适合高并发的并行运算。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//一个最基本的例子&lt;br/&gt;func main() {
    chan1 :&lt;/span&gt;= make(chan &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)//生成一个channel，相当于一个消息队列
    go func() {　　//运行一个goroutine，大概类似于线程，但不是一个东西
        chan1 &lt;/span&gt;&amp;lt;- &lt;span&gt;1 //放入数据&lt;/span&gt;&lt;span&gt;
    }()
    fmt.Println(&lt;/span&gt;&amp;lt;-&lt;span&gt;chan1) //读取显示数据，会等待上面那个函数执行完毕
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为只是大致的浏览了一遍，很多细节部分并没有太深入，然后也没什么实用经验，只是一个大致的感觉，思维比较混乱，可能会有很多错误的地方，但是我觉得go还是很不错的一门语言，简洁，性能不错，值得学习！（不要吐槽屎一样的排版），&lt;span&gt;&lt;strong&gt;&lt;span&gt;因为比较激动的想要把这门不错的语言推荐给大家，所以写的很匆忙（你就是懒得想好嘛！），不足之处，还请不要吹毛求逼，谢谢观看，祝您身体健康（笑）！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 07:28:00 +0000</pubDate>
<dc:creator>大萝卜卜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HelliX/p/8385209.html</dc:identifier>
</item>
<item>
<title>Python 3 生成手写体数字数据集 - TimeStamp</title>
<link>http://www.cnblogs.com/AdaminXie/p/8379749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AdaminXie/p/8379749.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;0.引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　平时上网干啥的基本上都会接触验证码，或者在机器学习学习过程中，大家或许会接触过手写体识别/验证码识别之类问题，会用到手写体的数据集；&lt;/p&gt;
&lt;p&gt;　　自己尝试写了一个生成手写体图片的python程序，在此分享下生成单张 &lt;strong&gt;&lt;span&gt;30*30像素的手写体数字1-9图像 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的一种实现方法&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;　　我是利用random生成随机数1-9，然后PIL写到图像上，然后经过&lt;strong&gt;旋转&lt;/strong&gt;、&lt;strong&gt;扭曲&lt;/strong&gt;处理，得到“手写体”，这里没有加干扰线和干扰点；&lt;/p&gt;
&lt;p&gt;　　得到的手写体数字图像如图1所示；&lt;/p&gt;
&lt;p&gt;　　实现比较简单，用了PIL库，不需要额外安装opencv啥的，有兴趣可以自己试试。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180129212909953-255240771.png&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　图1 生成的手写体数字1-9&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180130122448906-1137497246.png&quot; alt=&quot;&quot; width=&quot;940&quot; height=&quot;431&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;图2 利用&lt;/strong&gt;generate_pngs.py写入到文件夹3的数字3图像&lt;/p&gt;

&lt;p&gt;　　如果你想生成手写体的字母/汉字也可以：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180130131825296-1625223624.png&quot; alt=&quot;&quot; width=&quot;89&quot; height=&quot;89&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180130131912359-1219076157.png&quot; alt=&quot;&quot; width=&quot;94&quot; height=&quot;91&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;图3 利用generate_single_png.py生成汉字的手写体&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　源码上传到了我的GitHub&lt;strong&gt;:&lt;/strong&gt; &lt;a title=&quot;Github_generate_handwritten_number&quot; href=&quot;https://github.com/coneypo/Generate_handwritten_number&quot; target=&quot;_blank&quot;&gt;https://github.com/coneypo/Generate_handwritten_number&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.设计流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180129211913515-28787315.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　图4 整体设计流程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180130151535500-1270683998.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;89&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;图5 生成的图像经过的处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1 新建一个空白图像img_50，尺寸大小为50*50&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; img_50_blank = Image.new(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, (50, 50), (255, 255, 255))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;为什么我这里要先生成50*50的空白图像？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　因为图像背景（50*50像素的画布）初始化的时候设置为白色（颜色数组（255, 255, 255)），而背景色之外的其实是黑色；&lt;/p&gt;
&lt;p&gt;　　之后需要进行旋转处理，如果直接新建30*30像素的画布，旋转之后边上会出现黑边，如图6所示；&lt;/p&gt;
&lt;p&gt;　　所以我新建了一个50*50，然后旋转之后从中间裁出来一个30*30的图像出来；&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180129214409875-1355107155.png&quot; alt=&quot;&quot; width=&quot;213&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;图6 直接用30*30像素的画布写字旋转（会出现黑边）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 利用PIL在图像上写文字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　利用PIL的ImageDraw，创建画笔，然后利用draw.text在指定位置写字；&lt;/p&gt;
&lt;p&gt;　　xy=（18，11）是从图像左上角开始的坐标，取值自己根据需求调整；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建画笔&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  draw =&lt;span&gt; ImageDraw.Draw(img_50_blank)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成随机数1-9&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; num = str(random.randint(1, 9&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置字体，这里选取字体大小25&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; font = ImageFont.truetype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;simsun.ttc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; xy是左上角开始的位置坐标&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; draw.text(xy=(18, 11), font=font, text=num, fill=(0, 0, 0))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3 将图像随机旋转一定角度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;利用 rotate(angel) 进行旋转图像，angel取的是度数，这里让它随机旋转-10到+10度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 随机旋转-10-10角度&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; random_angle = random.randint(-10, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; img_50_rotated = img_50_blank.rotate(random_angle)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.4 图像扭曲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　这里是生成“手写体”数字的&lt;strong&gt;核心&lt;/strong&gt;步骤，一个正常的图像经过扭曲之后就可以得到想要的验证码了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图形扭曲参数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; params = [1 - float(random.randint(1, 2)) / 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            0,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            0,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            0,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             1 - float(random.randint(1, 10)) / 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             float(random.randint(1, 2)) / 500&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             0.001&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             float(random.randint(1, 2)) / 500&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建扭曲&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; img_50_transformed = img_50_rotated.transform((50, 50), Image.PERSPECTIVE, params)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;2.py源码介绍&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2.1 generate_folders_1to9.py&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为我们要将指定的图像分类放入指定文件夹，所以我们需要先在项目目录下面新建9个文件夹：&lt;/p&gt;
&lt;p&gt;　（当然你也可以自己新建，新建9个文件夹工作量还不大，但是如果要生成的验证码包含英文字母那就比较多了，大写A-Z共24个+小写a-z共24个+数字1-9共9个=57个子文件夹）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-01-9&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; generate_folders_1to9.py&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在目录下生成用来存放数字1-9的9个文件夹，分别用1-9命名&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; path_folders = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/***/P_generate_handwritten_number/data_pngs/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1-9&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(49,58&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (os.path.isdir(path_folders +&lt;span&gt; chr(i))):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(i,&quot;: &quot;,path_1+chr(i))&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成目录&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         os.mkdir(path_folders+chr(i))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1152352/201801/1152352-20180130114534343-1398734842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;图7 自动生成的用来存放指定图像的文件夹&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;strong&gt;2.2 &lt;/strong&gt;&lt;span&gt;generate_pngs.py&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;根据给定随机次数samples,&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;生成samples个手写体数字1-9，然后存放到本地文件夹1-9生成数据集；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在49行可以修改生成图像的大小，我这里取的是30*30像素；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-01-9&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; generate_pngs.py&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成手写体数字&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image, ImageDraw, ImageFilter, ImageFont
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; random.seed(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成单张扭曲的数字图像&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; generate_single():
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先绘制一个50*50的空图像&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     img_50_blank = Image.new(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, (50, 50), (255, 255, 255&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建画笔&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     draw =&lt;span&gt; ImageDraw.Draw(img_50_blank)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成随机数1-9&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     num = str(random.randint(1, 9&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置字体，这里选取字体大小25&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     font = ImageFont.truetype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;simsun.ttc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; xy是左上角开始的位置坐标&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     draw.text(xy=(18, 11), font=font, text=num, fill=&lt;span&gt;(0, 0, 0))
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 随机旋转-10-10角度&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     random_angle = random.randint(-10, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     img_50_rotated =&lt;span&gt; img_50_blank.rotate(random_angle)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图形扭曲参数&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     params = [1 - float(random.randint(1, 2)) / 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;              0,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;              0,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;              0,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;               1 - float(random.randint(1, 10)) / 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;               float(random.randint(1, 2)) / 500&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;               0.001&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;               float(random.randint(1, 2)) / 500&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建扭曲&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     img_50_transformed = img_50_rotated.transform((50, 50&lt;span&gt;), Image.PERSPECTIVE, params)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成新的30*30空白图像，（在此处可以更改生成的图像大小）&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     img_30 = img_50_transformed.crop([10, 10, 40, 40&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; img_30, num
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; path_pic = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/***/P_generate_handwritten_number/data_pngs/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成手写体数字1-9存入指定文件夹1-9&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用cnt_num[1]-cnt_num[9]来计数数字1-9生成的个数，方便之后进行命名&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; cnt_num =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    cnt_num.append(0)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成次数&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; samples = 200
&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; m &lt;span&gt;in&lt;/span&gt; range(1, samples+1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用生成图像文件函数&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;     img, generate_num =&lt;span&gt; generate_single()
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取灰度&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;     imgray = img.convert(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计数生成的数字1-9的个数,用来命名图像文件&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1, 10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(generate_num ==&lt;span&gt; str(j)):
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             cnt_num[j] = cnt_num[j]+1
&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 路径如 &quot;F:/code/***/P_generate_handwritten_number/data_pngs/1/1_231.png&quot;&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出显示路径&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(path_pic + str(j) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(j) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(cnt_num[j]) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将图像保存在指定文件夹中&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;             imgray.save(path_pic + str(j) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(j) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(cnt_num[j]) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出显示1-9的分布&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成的1-9的分布：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; range(9&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(k+1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cnt_num[k+1], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;output：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
D:\***\anaconda\python.exe F:/***/P_generate_handwritten_number/&lt;span&gt;generate_pngs.py
F:&lt;/span&gt;/***/P_generate_handwritten_number/data_pngs/4/&lt;span&gt;4_1.png
F:&lt;/span&gt;/***/P_generate_handwritten_number/data_pngs/1/&lt;span&gt;1_1.png
F:&lt;/span&gt;/***/P_generate_handwritten_number/data_pngs/8/&lt;span&gt;8_1.png
F:&lt;/span&gt;/***/P_generate_handwritten_number/data_pngs/3/&lt;span&gt;3_1.png
F:&lt;/span&gt;/***/P_generate_handwritten_number/data_pngs/1/&lt;span&gt;1_2.png
...

 生成的1&lt;/span&gt;-&lt;span&gt;9的分布：
&lt;/span&gt;1 : 25&lt;span&gt; 张
&lt;/span&gt;2 : 17&lt;span&gt; 张
&lt;/span&gt;3 : 21&lt;span&gt; 张
&lt;/span&gt;4 : 19&lt;span&gt; 张
&lt;/span&gt;5 : 20&lt;span&gt; 张
&lt;/span&gt;6 : 22&lt;span&gt; 张
&lt;/span&gt;7 : 25&lt;span&gt; 张
&lt;/span&gt;8 : 24&lt;span&gt; 张
&lt;/span&gt;9 : 27 张
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 修改 &lt;strong&gt;generate_pngs.py中的&lt;/strong&gt;&lt;strong&gt;samples&lt;/strong&gt;， 你就可以生成指定大小的数据集；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 generate_single_png.py&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　更改27行的char=&quot; &quot;（可以是数字/字母/汉字），生成单张手写体扭曲图像：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-01-9&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; generate_single_png.py&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成手写体数字/字母/汉字&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image, ImageDraw, ImageFilter, ImageFont
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; random.seed(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成单张扭曲的数字图像&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; generate_single():
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先绘制一个50*50的空图像&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     img_50_blank = Image.new(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, (50, 50), (255, 255, 255&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建画笔&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     draw =&lt;span&gt; ImageDraw.Draw(img_50_blank)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置字体，这里选取字体大小25&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     font = ImageFont.truetype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;simsun.ttc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; xy是左上角开始的位置坐标&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; text是你想要显示的内容，数字/字母/汉字&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     char =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;呵&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     draw.text(xy=(12, 11), font=font, text=char, fill=&lt;span&gt;(0, 0, 0))
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 随机旋转-10-10角度&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     random_angle = random.randint(-10, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     img_50_rotated =&lt;span&gt; img_50_blank.rotate(random_angle)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图形扭曲参数&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     params = [1 - float(random.randint(1, 2)) / 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;              0,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;              0,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;              0,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;               1 - float(random.randint(1, 10)) / 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;               float(random.randint(1, 2)) / 500&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;               0.001&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;               float(random.randint(1, 2)) / 500&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建扭曲&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     img_50_transformed = img_50_rotated.transform((50, 50&lt;span&gt;), Image.PERSPECTIVE, params)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成新的30*30空白图像&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     img_30 = img_50_transformed.crop([10, 10, 40, 40&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; img_30, char
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; path_pic = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/code/python/P_generate_handwritten_number/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用生成图像文件函数&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; img, generated_char =&lt;span&gt; generate_single()
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; imgray = img.convert(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(path_pic + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将图像保存在指定文件夹中&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; imgray.save(path_pic + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.4 del_pngs.py&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　删除指定目录下子文件夹1-9中的所有图片：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-01-9&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; del_pngs.py&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除路径下生成的图像文件&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; path_pic = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/***/P_generate_handwritten_number/data_pngs/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除路径下的图片&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; del_pic():
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;   print(path_png+chr(i))&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         namedir = os.listdir(path_pic+&lt;span&gt;str(i))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; tmppng &lt;span&gt;in&lt;/span&gt;&lt;span&gt; namedir:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;( tmppng &lt;span&gt;in&lt;/span&gt;&lt;span&gt; namedir):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;               &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  print(tmppng)&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 os.remove(path_pic+str(i)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;tmppng)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; del_pic()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　自己动手丰衣足食，有兴趣可以自己做手写体数字数据集，字母和汉字的数据集稍加修改也可以做；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;# GitHub:&lt;/strong&gt; &lt;a title=&quot;Github_generate_handwritten_number&quot; href=&quot;https://github.com/coneypo/Generate_handwritten_number&quot; target=&quot;_blank&quot;&gt;https://github.com/coneypo/Generate_handwritten_number&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;# 请尊重他人劳动成果，转载或者使用源码请注明出处&lt;/strong&gt;（&lt;a title=&quot;xie&quot; href=&quot;http://www.cnblogs.com/AdaminXie/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie/&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;# 交流学习可以联系邮箱 coneypo@foxmail.com&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jan 2018 05:01:00 +0000</pubDate>
<dc:creator>TimeStamp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AdaminXie/p/8379749.html</dc:identifier>
</item>
<item>
<title>闲聊cassandra - 卿哥聊技术</title>
<link>http://www.cnblogs.com/huashao1985/p/8376695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huashao1985/p/8376695.html</guid>
<description>&lt;p&gt;原创，转载请注明出处&lt;/p&gt;
&lt;p&gt;今天聊聊cassandra，里面用了不少分布式系统设计的经典算法比如consistent hashing, bloom filter, merkle tree, sstable, CAP trade off, replication, etc.(笔者已然泪流满面) 总之就是经典中的经典，我只能是仰视一下巨人的设计理念和应用。&lt;/p&gt;
&lt;p&gt;cassandra起源于Facebook，据说是dynamo的设计师跑到了Facebook写的（其实也借鉴了谷歌的bigtable）。所以可以知道亚麻的dynamo真的是革命性的突破。dynamo应该是当代流行的布式数据库的开山鼻祖。不过后来Facebook自己不用了。。。但是在硅谷的其它公司可是火到不行。另一个相关数据库是riak，是一波程序员读了dynamo的paper用erlang搞出来的open source。笔者安装过riak, 貌似它能每次query都能设定R，W的值（不过时间有点久，印象有点模糊，反正当时我就惊了）后来发现Cassandra也是每次query可以设consistency level我才明白原来都这样。后来bisho（维护riak的公司，于riak应该就像datastax和Cassandra，confluent和kafka的关系差不多）的CTO走了，不知道riak前景如何，我是觉得懂erlang的人太少(当然不能否认erlang并发的牛逼)，所以大家如果学习了Cassandra，就不用了解riak了。&lt;/p&gt;
&lt;p&gt;本文内容是基于Cassandra 3 btw 。&lt;/p&gt;
&lt;h2&gt;Tables&lt;/h2&gt;
&lt;p&gt;用cql shell写table，让人有一种操控relational database的感觉有木有。然并卵，原理完全不同呀亲。它的shape应该说是瘦高个，宽度会较窄，长度会任意长（horizontally scale，想要更多行，加机器就行）。没有join。没有foreign key。需要有keyspace，keyspace相当于是tables的container， 相当于relational database里的database, 会定义replication strategy, replication factor。在keyspace里面就可以create table了。&lt;/p&gt;
&lt;p&gt;table里面有primary key, 用来识别row，primary key 由(paritition key) 和 clustering key组成。对于partition key，相同key的row会存在同一台物理机器上。clustering key则可以用在where后面用来与threshold啥的做比较或者排个序啥的。&lt;/p&gt;
&lt;h2&gt;Data Types&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;text, int, bigint, float, double, boolean&lt;/li&gt;
&lt;li&gt;decimal, varint&lt;/li&gt;
&lt;li&gt;uuid, timeuuid(sorted by time, 牛逼)&lt;/li&gt;
&lt;li&gt;inet&lt;/li&gt;
&lt;li&gt;tuple&lt;/li&gt;
&lt;li&gt;timestamp&lt;/li&gt;
&lt;li&gt;counter (distributed counter, 除了key之外，如果有一个column是counter，其它column都要是counter，初始为0)&lt;/li&gt;
&lt;li&gt;set (unique set)&lt;/li&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;li&gt;map (k/v pair, k is unique)&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Secondary Index&lt;/h2&gt;
&lt;p&gt;在relational database中，相当于加index给其它column。加了有减慢写的速度的可能性。Cassandra在设计的时候会避免一切减慢scalable的可能性。SASI(SSTable Attached Secondary Index)是Cassandra的实现。可以通过以下方式添加SASI：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; custom &lt;span&gt;index&lt;/span&gt; XXX &lt;span&gt;on&lt;/span&gt; X_table(XXX) using &quot;org.apache.cassandra.&lt;span&gt;index&lt;/span&gt;.sasi.SASIIndex&quot; &lt;span&gt;with&lt;/span&gt; options &lt;span&gt;=&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mode&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;CONTAINS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外两种mode分别是（prefix和sparse），prefix就是“prefix%”如果这就是唯一的pattern，那么效率比contains要高。&lt;/p&gt;
&lt;p&gt;SASI在下文中有详细的介绍： http://www.doanduyhai.com/blog/?p=2058&lt;/p&gt;
&lt;p&gt;Secondary index怎么用？可以应用于非常大的partition（同一个node）来加速rows filter。应用的时候注意使用相同的partition key，也就意味着在同一个node。当然它也支持多node，也就是不同的partition key，不过要小心出问题。&lt;/p&gt;
&lt;h2&gt;Query First Modeling&lt;/h2&gt;
&lt;p&gt;这里要注意Cassandra的table设计理念是de-normalize，（恰好和relational database的normalize相反）。Entity model（domain） still the same， 比如movies。 知道你的program要干什么，需要什么query，然后设计table。table的创建是由query的需求决定的。当然也会因为新query的需求而要进行schema revolution，这个在relational database中也是常见的无法避免的问题，毕竟没有完美的schema，是一个动态平衡的问题。所以只能通过create new talbes, migration old data to new table来满足新的query。&lt;/p&gt;
&lt;p&gt;更多信息参见：https://academy.datastax.com/resources/ds220-data-modeling&lt;/p&gt;
&lt;p&gt;基本的理念就是现想都有哪几个query需要解决，然后根据query想partition key和clustering key，最后计算partition大小不能超过2 billion cells，大概就是(num_of_column - partition_key) * num_of_rows。如果parititon过大，要么加新的cluster key减少partition size，要么用materiel view替代query.&lt;/p&gt;
&lt;h2&gt;Materialized Views&lt;/h2&gt;
&lt;p&gt;如果有几个denormalized table，有相同的信息，现在需要加入新的信息，听起来好像要插入好几个table，由于没有transaction，会出现一个table update了，剩下的还没动静的问题，感觉好像会有race condition存在而且好像无法避免。笔者的理解是materialized view正是要来解决这个问题，有一个比较wide的table，然后通过定义material view来回答query，这样当这个table被update了，casandra 会guarantee view也就被update了，问题就解决了。否则application端要相办法加transaction。&lt;/p&gt;
&lt;h2&gt;Nodes and Clusters&lt;/h2&gt;
&lt;p&gt;如果你的问题可以用一台电脑解决，用postgres就好了，不要用Cassandra，cassandra就是要解决一台电脑搞不定的问题。每一个Node都是peer, 没有master/controller，cluster是ring structure，去中心化结构。Parition key is hashed to go to a particlar machine. 基本上就是应用了consistent hashing。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1321773/201801/1321773-20180130120611906-1555977843.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Replication&lt;/h2&gt;
&lt;p&gt;replication factor决定了每次写复制几次，比如如果是3（通常production会选择3个，当然我也见过一共7台机器就把copy定义为7的），就意味着写的结果会存3个copy。replication strategy会决定怎么找到copy。在keyspace会定义这两个parameter。&lt;/p&gt;
&lt;h2&gt;Consistency&lt;/h2&gt;
&lt;p&gt;通常有3种选择，all/quorum/one，tunable at every query level(of course also at table level), 假设replication factor是3，那么quorum写就是2，quorum读也是2，all写／读是3，one写／读是1。 每个node都有coordinator的角色，能够帮助redirect找到真正的node。client往coordinator写的时候，block多久取决于consistency level，如果是quorum，那么两个成功写入就会返回了。&lt;/p&gt;
&lt;p&gt;R+W &amp;gt; N，决定了strong consistency, E.g. 2+2 &amp;gt; 3。读总是能读到最新写的内容。&lt;/p&gt;
&lt;h2&gt;Multiple Data Center&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1321773/201801/1321773-20180130115254687-365638889.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;client端何时返回取决于each_quorum还是local_quorum，如果是local_quorum，那么另一个data center就是asyncrhonous, 效率比较高。each_quorum由于牵扯WAN latency会很高。&lt;/p&gt;
&lt;p&gt;multiple data center同时适用于支持both transaction heavy job和analytical job。transaction heavy job比较容易caching，因为总会有一些hot data去某几个server。而analytical job是每个row都要读所以不适合caching，这样这两种job就不适合运行在同一台machine。所以可以一个data center进行transsaction job，另一个data center运行analysis job。&lt;/p&gt;
&lt;h2&gt;Gossip&lt;/h2&gt;
&lt;p&gt;想象一下coordinator redirect的时候需要知道哪些node up or down或者哪台机器latency最低，所以每隔一段时间比如每秒钟，random node就会把自己知道的other nodes status／metadata随机发送出去，information could propagate pretty efficiently。每个node就通过这种方式维持每个成员的metadata。&lt;/p&gt;
&lt;h2&gt;Write Path&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1321773/201801/1321773-20180130120755796-232280834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，data会先写入commit log，append only，每个node有一个global commit log，每个table都是望着里面写。然后会写入memtable，memtable是每个table会有自己的memtable。写完之后write就可以返回给coordinator了。memtable写到一定程度会flush到SSTable（sorted string table）。cassandra的write是非常efficient，可能比读还快。对于update，只是会重新写一个新的，不会改旧的，读的时候会读最新的。delete的时候是写新row加tombstone。SSTable合并的时候会把这个row删除掉。&lt;/p&gt;
&lt;h2&gt;Read Path&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1321773/201801/1321773-20180130121613656-1061535734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读的时候先读memtable，如果没有的话找SSTable，通过bloomfilter来加速查询，如果bloomfilter说没有，那就真没有，如果bloomfilter说有，就继续查。file will be sorted by partition key。在bloom filter之后还会有一个key cache，如果key cache里有就可以直接读了，没有再从index／file去找，找到后把location／path放到key cache，不用cache具体的内容，操作系统的cache比如page cache会更高效。&lt;/p&gt;
&lt;h2&gt;Compaction&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1321773/201801/1321773-20180130122450765-405027358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为SSTable是sorted by partition key，所以合并的时候value in new partition 会overwrite value in old partition，tombstone的会被删除掉。&lt;/p&gt;
&lt;p&gt;compaction也有不同的strategy可供选择，比如write heavy和read heavy的strategy就不一样。这里就不详细解读了。&lt;/p&gt;
&lt;p&gt;cassandra支持很多种不同语言的driver，比如java，python，c++。方便developer选择最适合自己的。今天就先聊到这，happy cassandra！&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 04:31:00 +0000</pubDate>
<dc:creator>卿哥聊技术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huashao1985/p/8376695.html</dc:identifier>
</item>
<item>
<title>【WebApi系列】详解WebApi如何传递参数 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/8378108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/8378108.html</guid>
<description>&lt;p&gt;&lt;span&gt;WebApi系列文章&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.74907063197026&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8359181.html&quot;&gt;【01】浅谈HTTP在WebApi开发中的运用&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【02】聊聊WebApi体系结构&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html&quot;&gt;【03】详解WebApi参数的传递&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【04】详解WebApi测试和PostMan&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【05】浅谈WebApi Cores&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【06】详解WebApi 异常处理&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【07】用WebAPI写个基于EF的CURD&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【08】浅谈WebAPI身份认证&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【09】详解系列化和模型绑定&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【10】浅谈WebApi如何配合Mvc有效工作&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【11】浅谈API Reference&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【12】浅谈接口在软件架构中的作用&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【13】浅谈WebApi和WebService的比较&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a&gt;【14】浅谈如何设计一个良好的接口&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;                                                                     &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180127123414725-579685317.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;阅读目录&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.8650693568726&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#1&quot;&gt;&lt;span&gt;一     概述&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2&quot;&gt;&lt;span&gt;二    Get&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-1&quot;&gt;&lt;span&gt;1   基础数据类型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-1.1&quot;&gt;&lt;span&gt;1.1  方法只含一个形参&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-1.2&quot;&gt;&lt;span&gt;1.2  方法含多个形参&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-2&quot;&gt;&lt;span&gt;2   实体对象类型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-3&quot;&gt;&lt;span&gt;3   实体对象和基础数据类型混合&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-4&quot;&gt;&lt;span&gt;4   最小满足原则&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-5&quot;&gt;&lt;span&gt;5   url长度限制&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-6&quot;&gt;&lt;span&gt;6   Get规范化&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-7&quot;&gt;&lt;span&gt;7    关于实体作为参数传递的拓展&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-7.1&quot;&gt;&lt;span&gt;7.1   借助[FromUri]特性传递实体&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#2-7.2&quot;&gt;&lt;span&gt;7.2   系列化和反系列化传递实体&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3&quot;&gt;&lt;span&gt;三    Post&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3-1&quot;&gt;&lt;span&gt;1   基本数据类型传递&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         1.1&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3-1.1&quot;&gt;&lt;span&gt;   [FromBody]单个参数传递&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3-1.2&quot;&gt;&lt;span&gt;1.2  Dynamic单个参数传递&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3-2&quot;&gt;&lt;span&gt;2   实体作为参数传递&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3-3&quot;&gt;&lt;span&gt;3   实体集合作为参数传递&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3-4&quot;&gt;&lt;span&gt;4   数组作为参数传递&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    5&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#3-5&quot;&gt;&lt;span&gt;   小结&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8378108.html#4&quot;&gt;&lt;span&gt;四   总结&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;div&gt;
&lt;p&gt;&lt;span&gt; 一 概述&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般地，我们在研究一个问题时，常规的思路是为该问题建模；我们在研究相似问题时，常规思路是找出这些问题的共性和异性。基于该思路，我们如何研究WebApi参数传递问题呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，从参数本身来说，种类较为多(如int，double，float，string，array，Object等)，且有些类型较为复杂(如值类型和引用类型的机制等)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，从基于WebApi的Http请求方法来说，种类多且不尽相同(如Get,post,Delete,put,head等)，在上一篇文章 ：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/wangjiming/p/8359181.html&quot;&gt;【WebApi系列】浅谈HTTP在WebApi开发中的运用&lt;/a&gt;  中，我们简要描述了Http请求的20个方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..........&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此复杂且不尽相同，关于WebApi参数传递，我们该选择什么作为切入点来研究呢？基于我们上面提到的研究思路，我们想到了.NET Framework框架，那么，我们来看看基于.NET Framework框架的的WebApi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模板是怎样的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请按图中步骤操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130112008281-343654863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来看看Values控制器是怎样的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ApiController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values/5&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST api/values&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Post([FromBody]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PUT api/values/5&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Put(&lt;span&gt;int&lt;/span&gt; id, [FromBody]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE api/values/5&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从Values控制器，我们不难得出如下几个结论：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)WebApi常规方法为四个：Get,Post，Put和Delete;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)四种方法的参数可归结为两大类：url传递(Request-url)和Body(Request-body)传递;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3)基于(2)，我们将四种方法的参数传递归为两大类，而这两大类又集中在Get和Post中体现了(Put是Get和Post的组合，Delete与Get类似)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实，分析到现在，我们很容易找得到了研究WebApi参数传递的切入点？研究Get和Post方法参数传递即可。是的，没错，我们本篇文章就是基于Get和Post方法的参数传递，前者对应Request-url，后者对应Reqeust-Body。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;1  基础数据类型&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;1.1  方法只含一个形参&lt;span&gt;(参数传得进去)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
       $.ajax({
               type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;url: &quot;/api/Default/GetProductDetails?ProductCode=JX80869&quot;&lt;/span&gt;
               url: &quot;/api/Default/GetProductDetails&quot;&lt;span&gt;,
               data: { &lt;/span&gt;&quot;ProductCode&quot;:&quot;JX80869&quot;&lt;span&gt;}
            })
        })           
   })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129193429328-237488141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)当Get方法形参为一个且为基本数据类型时，Get方法能接受外部传递的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)Get传值的本质是通过&lt;span&gt;url字符串拼接&lt;/span&gt;，如上两两种url形式的传递的结果都是一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;url形式1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
url: &quot;/api/Default/GetProductDetails?ProductCode=JX80869&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;url形式2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
url: &quot;/api/Default/GetProductDetails&quot;&lt;span&gt;,
data: { &quot;ProductCode&quot;:&quot;JX80869&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们用Goole Chrome来看看结果，发现url形式1和url形式2均一致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129194626890-2112532684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(3)Get传递参数本质是url字符串拼接，Request-Head头部传递，Request-Body中不能传递(&lt;span&gt;这是与Post方法的本质区别&lt;/span&gt;)，我们举两个例子&lt;/p&gt;
&lt;p&gt;例子1：我们将形参添加[FromBody]属性后，值传递不进去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129195536453-1209821247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子2：我们用PostMan来测试，发现PostMan中，Get方法参数Body为灰色，是不能选中的&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129195833609-305155289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.2  方法含有多个形参&lt;span&gt;(参数传得进去)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      $.ajax({
               type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
               url: &lt;/span&gt;&quot;/api/Default/GetProductDetails&quot;&lt;span&gt;,
               data: { &lt;/span&gt;&quot;ProductCode&quot;: &quot;JX80869&quot;,&quot;ProductName&quot;:&quot;YaGao&quot;&lt;span&gt;}
            })
        })
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129200421156-1739294476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;2   实体对象类型&lt;/span&gt;&lt;span&gt;(参数传不进去)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; model&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt; public class ProductDetail
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品编码&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        [Required]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        public string ProductCode { get; set; }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品名称&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        [Required]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        public string ProductName { get; set; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品价格&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        [Required]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         public &lt;span&gt;double&lt;/span&gt;&lt;span&gt;  ProductPrice{ get; set; }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; productDetail = { &quot;ProductName&quot;: &quot;YaGao&quot;, &quot;ProductCode&quot;: &quot;JX80869&quot;, &quot;ProductPrice&quot;: 40.5&lt;span&gt;};
        $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $.ajax({
                    type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
                    url: &lt;/span&gt;&quot;/api/Default/ProductDetails&quot;&lt;span&gt;,
                    data: productDetail
                })
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;result:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130001859625-1117818966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129204036062-1978407741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;3   实体对象和基础数据类型混合&lt;/span&gt;&lt;span&gt;(实体传不进去，基础数据能传递进去)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    $(&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;       $.ajax({
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 type: &quot;Get&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 url: &quot;/api/Default/GetProductDetails&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                 data: { &quot;_productDetail&quot;: &quot;ObjectEntity&quot;,&quot;ProductName&quot;:&quot;YaGao&quot;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;             })
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130003232281-1901030757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;4  最小满足原则&lt;/span&gt;&lt;span&gt;(参数传得进去)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 所谓“最小满足原则”，指外部参数必须至少满足被调用方法的形参(形参个数，形参类型和形参名字)，换句话说，被调用方法具有的形参，外部参数必须传递进来，被调用方法没有&lt;/p&gt;
&lt;p&gt;的形参，外部参数传递与否都可以，否则将会产生状态码404错误，用数学集合的思路来理解的话，被调用方法的形参相当于外部参数的子集。如下例子，我们举一个真子集的例子,&lt;/p&gt;
&lt;p&gt;即外部传递参数的个数大于被调方法的的形参个数。&lt;/p&gt;
&lt;p&gt;Ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 $(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
       $.ajax({
                type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
                url: &lt;/span&gt;&quot;/api/Default/GetProductDetails&quot;&lt;span&gt;,
                data: {&lt;/span&gt;&quot;ProductCode&quot;: &quot;JX00034&quot;, &quot;ProductName&quot;: &quot;YaGao&quot;, &quot;ProductPrice&quot;: 20.5, &quot;PrudcutType&quot;: &quot;Daily Necessities&quot;&lt;span&gt;}
                })
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130002753812-1610741118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 分析：主要原因是路由规则，路由从url里面取参数与aciton参数匹配，直到匹配满足为止，具体详细深入内容，在【WebApi系列】路由章节分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130003104390-1564514912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5  url长度限制&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; url参数长度是有一定限制的，当超过一定长度，会报404错误&lt;/p&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 $(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                $.ajax({
                    type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
                    url: &lt;/span&gt;&quot;/api/Default/GetProductDetails&quot;&lt;span&gt;,
                    data: {
                        &lt;/span&gt;&quot;ProductCode&quot;&lt;span&gt;:
                        &lt;/span&gt;&quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; +
                        &quot;JX00034xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;&lt;span&gt; 
                    }
                })
            })
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129224639062-183049714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6  Get规范化&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 关于Get类型规范化，应注意两点，避免不必要的错误或异常：(1)方法的命名尽量采用：“Get+方法名”的形式 (2)在每个方法上加上特性[HttpGet]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129231823406-2033747105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子:我们去掉[HttpGet]特性和方法前的Get，看看情况什么怎样的&lt;/p&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $.ajax({
                 type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
                 url: &lt;/span&gt;&quot;/api/Default/ProductDetails&quot;&lt;span&gt;,
                 data: {&lt;/span&gt;&quot;ProductCode&quot;: &quot;JX00034 &quot;&lt;span&gt;}
             })
         })
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultController : ApiController
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[HttpGet]&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ProductDetails(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; ProductCode)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129232614390-1394143048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7  关于实体作为参数传递的拓展&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;7.1  借助[FromUri]特性传递实体&lt;/p&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; GetEntityParam = { &quot;ProductName&quot;: &quot;YaGao&quot;, &quot;ProductCode&quot;: &quot;JX80869&quot;, &quot;ProductPrice&quot;: 40.5&lt;span&gt;};
      $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $.ajax({
                 type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
                 url: &lt;/span&gt;&quot;/api/Default/ProductDetails&quot;&lt;span&gt;,
                 data: GetEntityParam
               })
           })
      })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180129234834703-331731758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7.2  系列化与反系列化传递实体&lt;/p&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
       $.ajax({
                type: &lt;/span&gt;&quot;Get&quot;&lt;span&gt;,
                url: &lt;/span&gt;&quot;/api/Default/ProductDetails&quot;&lt;span&gt;,
                data: { &lt;/span&gt;&quot;productDetail&quot;: JSON.stringify({ &quot;ProductName&quot;: &quot;YaGao&quot;, &quot;ProductCode&quot;: &quot;JX80869&quot;, &quot;ProductPrice&quot;: 40.5&lt;span&gt; }) }
             })
         })
     })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130000258531-713702687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;8  小结&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;(1)Get参数传递的本质是url字符串拼接；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; (2)url字符串长度受限制；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; (3)Get参数传递在Http请求头部传递，而不支持Request-Body传递；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; (4)Get类型的方法支持参数为基本类型，不支持实体类型；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; (5)Get类型的方法命名，应尽量采用“Get+方法名”的命名方式，且习惯性地在方法前加上[HttpGet特性]；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; (6)实参与形参的匹配，遵循路由规则；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(7)Get对应DB的Select操作，从这一点来理解，就知道为什么Http不支持实体对象传递的合理性了，因为一般情况，我们都是通过简单的字段查询信息(对应基本类型)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如ID号，用户名等，而不会通过一个实体查询数据；&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;p&gt;&lt;span&gt; 三    Post &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1  基本数据类型传递&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;1.1  [FromBody]单个参数传递&lt;/p&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130082148640-267452093.png&quot; alt=&quot;&quot; width=&quot;818&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130081523625-1736155342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.2 dynamic单个参数传递&lt;/p&gt;
&lt;p&gt; ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      $.ajax({
               type: &lt;/span&gt;&quot;Post&quot;&lt;span&gt;,
               contentType: &lt;/span&gt;'application/json'&lt;span&gt;,
               url: &lt;/span&gt;&quot;/api/Default/PostParamToProducts&quot;&lt;span&gt;,
               data: JSON.stringify({&lt;/span&gt;&quot;ProductCode&quot;:&quot;JX00039&quot;&lt;span&gt;})
           })
       })
   })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130102806734-1895031856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Googel Chrome查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130103024406-1518055997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2 实体作为参数传递&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      $.ajax({
               type: &lt;/span&gt;&quot;Post&quot;&lt;span&gt;,
               url: &lt;/span&gt;&quot;/api/Default/PostParamToProducts&quot;&lt;span&gt;,
               data: { &lt;/span&gt;&quot;ProductCode&quot;: &quot;JX00036&quot;,&quot;ProductName&quot;:&quot;YaGao&quot;,&quot;ProductPrice&quot;:20.5&lt;span&gt;}
            })
        })
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130092233734-498436747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们用Googel  Chrome看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130092848750-842148530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3 实体集合作为参数传递&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list_ProductDetail =&lt;span&gt; [
       { &lt;/span&gt;&quot;ProductCode&quot;: &quot;JX00031&quot;, &quot;ProductName&quot;: &quot;ToothPaste&quot;, &quot;ProductPrice&quot;: &quot;20.5&quot;&lt;span&gt; },
       { &lt;/span&gt;&quot;ProductCode&quot;: &quot;JX00032&quot;, &quot;ProductName&quot;: &quot;ToothBrush &quot;, &quot;ProductPrice&quot;: &quot;18.9&quot;&lt;span&gt; },
       { &lt;/span&gt;&quot;ProductCode&quot;: &quot;JX00033&quot;, &quot;ProductName&quot;: &quot;Pen&quot;, &quot;ProductPrice&quot;: &quot;199.9&quot;&lt;span&gt; },
       { &lt;/span&gt;&quot;ProductCode&quot;: &quot;JX00034&quot;, &quot;ProductName&quot;: &quot;computer&quot;, &quot;ProductPrice&quot;: &quot;15000.5&quot;&lt;span&gt; }
       ]
   $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   $.ajax({
             type: &lt;/span&gt;&quot;Post&quot;&lt;span&gt;,
             contentType: &lt;/span&gt;'application/json'&lt;span&gt;,
             url: &lt;/span&gt;&quot;/api/Default/PostParamToProducts&quot;&lt;span&gt;,
              data: JSON.stringify(list_ProductDetail)
          })
      })
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130101310484-974311561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Google Chrome 查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130101654609-680631132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4  数组作为参数传递&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; ajax&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&lt;span&gt;];
   $(&lt;/span&gt;&quot;#FindProdcutDetail&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      $.ajax({
               type: &lt;/span&gt;&quot;Post&quot;&lt;span&gt;,
               contentType: &lt;/span&gt;'application/json'&lt;span&gt;,
               url: &lt;/span&gt;&quot;/api/Default/PostParamToProducts&quot;&lt;span&gt;,
               data: JSON.stringify(arr)
            })
       })
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130095047484-1279677295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们用Google Chrome看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180130095324828-174423464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5  小结&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;(1)Post参数传递本事是在Request-Body内传递，而Get参数传递本质是url拼接；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)Post参数传递不是key/value形式，而Get参数是key/value形式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3)Post传递参数时，无论是单个参数还是对象，均借助[FromBody]特性(当然，某些情况去掉[FromBody]特性也可把值传递进去，但未了规范化，尽量加上该特性)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4)Post没长度限制，而Get有长度限制(一般为1024b);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(5)Post相对Get，较安全；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(6)Post操作相当于DB的Insert操作；&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;p&gt;&lt;span&gt;四  总结&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1.虽然HTTP请求方法有20多种，常用的大致为4种，即Get，Post，Put，Delete（当然，像Trace，Head等也常用）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.Get，Post，Put，Delete分别对应DB的Select,Insert，Update和Delete操作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.WebApi参数类型，大致分为基本数据类类型和对象数据类型(当然你也可以理解为抽象数据类型)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.研究WebApi参数传递，只需研究Get和Post即可，因为其他http方法参数传递基本都是有这两种组合而成(如Put有Get和Post组合而成)，或者相似（如Delete与Get相似)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.对于控制器方法，尽量参照规范格式写，如在相应控制器方法上加上对应的htt请求(Get对应[HttpGet]，Post对应[HttpPost])，方法名尽量采用“Http请类型+方法名”格式(如Get请求，建议采用Get+MethodName；Post请求对应Post+MethodName);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.WebApi参数请求，大致分为两大类型，即Request-url和Request-body;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.文中我们还简要分析了Get和Post区别；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.关于如何设计一个良好的接口，在文章中，我们触及了一下，但未研究，会在后续的文章中单独分析；&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;span&gt;五   版权区&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 30 Jan 2018 04:20:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/8378108.html</dc:identifier>
</item>
<item>
<title>自己动手搭建一个简易的SpringBoot环境 - 队长给我球。</title>
<link>http://www.cnblogs.com/JJJ1990/p/8384386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JJJ1990/p/8384386.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是springboot？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot俗称微服务。Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1， 新建一个maven工程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先选择workspace&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1063420/201801/1063420-20180130110641781-1822836913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击【next】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1063420/201801/1063420-20180130111434796-169867536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接默认，再点击【next】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1063420/201801/1063420-20180130111545421-133617182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写groupid等~然后【finish】，到这里整个新建工程结束。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2，引入相关的jar包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;parent&amp;gt;
&lt;span&gt; 2&lt;/span&gt;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 3&lt;/span&gt;        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;        &amp;lt;version&amp;gt;1.5.8.RELEASE&amp;lt;/version&amp;gt;
&lt;span&gt; 5&lt;/span&gt;    &amp;lt;/parent&amp;gt;
&lt;span&gt; 6&lt;/span&gt;    &amp;lt;dependencies&amp;gt;
&lt;span&gt; 7&lt;/span&gt;        &amp;lt;dependency&amp;gt;
&lt;span&gt; 8&lt;/span&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 9&lt;/span&gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&lt;span&gt;10&lt;/span&gt;        &amp;lt;/dependency&amp;gt;
&lt;span&gt;11&lt;/span&gt;    &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里说明下看似我们只引用了2个jar包其实里面包含了很多东西，像&lt;/span&gt;spring-boot-starter-web 我们通过压缩包打开后&lt;/p&gt;
&lt;p&gt;查看里面的pom文件可以看到如下所示的内容，它引用了很多jar像spring的web，还有json的jar包都包含在内了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &amp;lt;dependencies&amp;gt;
&lt;span&gt; 2&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt; 3&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt; 6&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt; 7&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 8&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;10&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;11&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
&lt;span&gt;12&lt;/span&gt;             &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;
&lt;span&gt;13&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;14&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;15&lt;/span&gt;             &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
&lt;span&gt;16&lt;/span&gt;             &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
&lt;span&gt;17&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;18&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;19&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&lt;span&gt;20&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;22&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;23&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&lt;span&gt;24&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
&lt;span&gt;25&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;26&lt;/span&gt;     &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3，编写程序入口类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springbooot2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Hello world!
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         SpringApplication.run(App.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里说明下， @SpringBootApplication 就是为了让spring扫描识别，告诉他我是一个程序入口类。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4，编写请求响应类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springbooot2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.ResponseBody;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FristBlood {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     @RequestMapping(&quot;/FristBlood&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @ResponseBody
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;dont worry，be happy！&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt; &amp;lt;input type=\&quot;submit\&quot; value=\&quot;ok\&quot; /&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里说明下&lt;/p&gt;
&lt;p&gt;@Controller 请求处理控制器类。&lt;/p&gt;
&lt;p&gt;@RequestMapping 熟悉spring的都应该不陌生，这是spring的东西，url映射。&lt;/p&gt;
&lt;p&gt;@ResponseBody 响应方法，我们的响应信息都会被自动转化为json信息返回给前台页面&lt;/p&gt;
&lt;p&gt;到这里整个代码就撸完了，比起我们之前搭建一个ssh或者ssm之类的框架简单了不少，如果我们有那种只需要发送一个邮件啊。或者简单的服务，用springboot可以说很方便了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5，测试代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;启动程序，打开浏览器，输入：&lt;strong&gt;http://localhost:8080/FristBlood&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;请求页面响应结果如下图&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1063420/201801/1063420-20180130113751609-890500808.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jan 2018 03:57:00 +0000</pubDate>
<dc:creator>队长给我球。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JJJ1990/p/8384386.html</dc:identifier>
</item>
<item>
<title>Nodejs的运行原理-生态篇 - peiyu1988</title>
<link>http://www.cnblogs.com/peiyu1988/p/8384357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peiyu1988/p/8384357.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141038/201801/1141038-20180130111459468-1690912733.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;502&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里是重点&lt;/strong&gt;：Nodejs 是由v8 engine，libuv和内置模块组成，可以将v8 engine和 libuv看成一个库，两者是以源码的方式直接编译执行node中去的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个广泛的介绍，后面会详细介绍Nodejs的生态圈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;V8 engine&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V8官方文档 &lt;a href=&quot;https://developers.google.com/v8/intro&quot;&gt;&lt;span&gt;&lt;span&gt;https://developers.google.com/v8/intro&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
        #include &quot;include/v8.h&quot;
        #include &quot;include/libplatform/libplatform.h&quot;

        using namespace v8;

        int main(int argc, char* argv[]) {
        // V8初试化.
        V8::InitializeICU();
        Platform* platform = platform::CreateDefaultPlatform();
        V8::InitializePlatform(platform);
        V8::Initialize();

        // 创建isolate.
        Isolate* isolate = Isolate::New();
        {
                Isolate::Scope isolate_scope(isolate);

                // 创建HandleScope.
                HandleScope handle_scope(isolate);

                // 创建context 环境.
                Local&amp;lt;Context&amp;gt; context = Context::New(isolate);
  
                // 引入环境.
                Context::Scope context_scope(context);
  
                // 创建字符串.
                Local&amp;lt;String&amp;gt; source = String::NewFromUtf8(isolate, &quot;'Hello' + ', World!'&quot;);
  
                // 编译字符串.
                Local&amp;lt;Script&amp;gt; script = Script::Compile(source);
  
                // Run，并且获取返回值.
                Local&amp;lt;Value&amp;gt; result = script-&amp;gt;Run();
  
                // 转换为utf8，并且打印出来.
                String::Utf8Value utf8(result);
                printf(&quot;%s\n&quot;, *utf8);
        }

        // 关掉v8.
        isolate-&amp;gt;Dispose();
        V8::Dispose();
        V8::ShutdownPlatform();
        delete platform;
        return 0;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 上面代码展示了一个典型的V8使用例。&lt;/p&gt;
&lt;p&gt;1.isolate 代表一个V8实例，各个isolate是独立的（隔绝的），isolate中的obj无法再另一个isolate中被使用。&lt;/p&gt;
&lt;p&gt;2.context 代表执行js代码的虚拟机，在这个虚拟机中，集成了一些功能，例如math，json，date(),RegExp()等。一个isolate可以同时存在多个context，这些context可以自由切换。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141038/201801/1141038-20180130113252656-1745884484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.在V8 engine中，通过handle访问存在与heap上的js obj，如local，persistent，eternal，在V8中，有一个handle stack用于管理这些handles，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141038/201801/1141038-20180130113435265-1722315710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;libuv&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;libuv主要用于处理事件驱动的异步IO模型，官方文档 &lt;a href=&quot;http://nikhilm.github.io/uvbook/&quot;&gt;&lt;span&gt;&lt;span&gt;http://nikhilm.github.io/uvbook/&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141038/201801/1141038-20180130113549593-528380167.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;libuv通过epoll，kqueue，event ports和IOCP来实现异步network IO。file，dns的操作则依赖于thread pool 来实现，正如上图所示。&lt;/p&gt;
&lt;p&gt;libuv的重点是IO和event loop，loop负责调度callback，运行idle function，执行轮询等操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141038/201801/1141038-20180130113855500-988286822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Nodejs&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了V8 engine和libuv ，Nodejs本身也做了很多的工作，它提供了js模块，c++模块等核心模块供开发者使用。&lt;/p&gt;
&lt;p&gt;Nodejs 将这些核心js模块命名为native module，c++模块命名为builtin module，內建的c++模块则安放于node源码lib目录下。&lt;/p&gt;
&lt;p&gt;下图为native module和builtin module编译及加载到内存的全过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141038/201801/1141038-20180130114303281-323725270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当 node test.js 执行时，node_main.cc首先被调用，这一步初始化了V8 engine和libuv执行环境。&lt;/p&gt;
&lt;p&gt;uv_run(env-&amp;gt;event_loop,UV_RUN_ONCE)用于启动libuv event loop，而我们的js代码则会被传递到creatEnvironment()，最后交由V8处理。&lt;/p&gt;
&lt;p&gt;查看Node.cc代码，可以看到一些函数与V8交互的工作，例如context，handle等的创建。&lt;/p&gt;
&lt;p&gt;在js中，类似基于prototype继承的方式来实现的，通过V8提供的c++ API来完成这些操作。&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jan 2018 03:49:00 +0000</pubDate>
<dc:creator>peiyu1988</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peiyu1988/p/8384357.html</dc:identifier>
</item>
<item>
<title>Spring的RestTemplata使用 - 快乐的小乐</title>
<link>http://www.cnblogs.com/zzw-blog/p/8360512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzw-blog/p/8360512.html</guid>
<description>&lt;p&gt;spring-web的RestTemplata是对java底层http的封装，使用RestTemplata用户可以不再关注底层的连接建立，并且RestTemplata不仅支持Rest规范，还可以定义返回值对象类型。&lt;/p&gt;
&lt;p&gt;在使用中可以直接new一个RestTemplate对象，在我们创建的RestTemplate对象中会有一些返回消息的消息转换器，可以根据返回数据的&lt;strong&gt;MediaType&lt;/strong&gt;寻找对应的转换器并进行&lt;strong&gt;MediaType&lt;/strong&gt;转换。自己也可以创建消息转换器，创建一个类继承AbstractGenericHttpMessageConverter&amp;lt;T&amp;gt;类或者实现HttpMessageConverter&amp;lt;T&amp;gt;接口，需要注意的是canRead方法和canWrite方法最好自己做判断，在writeInternal或write方法中将参数写入到流，在readInternal或read方法中将返回结果从流的body中获取并进行类型映射。&lt;/p&gt;
&lt;p&gt;RestTemplate对象在底层通过使用java.net包下的实现创建HTTP 请求，可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式。&lt;br/&gt;ClientHttpRequestFactory接口主要提供了两种实现方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是SimpleClientHttpRequestFactory，使用J2SE提供的方式（既java.net包提供的方式）创建底层的Http请求连接。&lt;/li&gt;
&lt;li&gt;一种方式是使用HttpComponentsClientHttpRequestFactory方式，底层使用HttpClient访问远程的Http服务，使用HttpClient可以配置连接池和证书等信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RestTemplate默认是使用SimpleClientHttpRequestFactory，内部是调用jdk的HttpConnection，默认超时为-1，我们可以自己定义超时时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
SimpleClientHttpRequestFactory factory = new&lt;span&gt; SimpleClientHttpRequestFactory();
//设置连接超时，单位毫秒
factory.setConnectTimeout(5000&lt;span&gt;);
//设置读取超时，单位毫秒
factory.setReadTimeout(10000&lt;span&gt;);
RestTemplate &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;restTemplate = new RestTemplate(factory);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用GET请求： &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　String url = &quot;http://localhost:80/mandy/login.json?account=123456&amp;amp;password=123456&quot;&lt;span&gt;;
　　Result res &lt;/span&gt;= restTemplate.getForObject(url, Result.&lt;span&gt;class&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RestTemplate源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Object... urlVariables) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {
        RequestCallback requestCallback &lt;/span&gt;=&lt;span&gt; acceptHeaderRequestCallback(responseType);
        HttpMessageConverterExtractor&lt;/span&gt;&amp;lt;T&amp;gt; responseExtractor =
                &lt;span&gt;new&lt;/span&gt; HttpMessageConverterExtractor&amp;lt;T&amp;gt;&lt;span&gt;(responseType, getMessageConverters(), logger);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; execute(url, HttpMethod.GET, requestCallback, responseExtractor, urlVariables);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用get请求直接将参数拼接到地址上最好，不知道什么原因如果使用第三个参数，即便是MultiValueMap类型也不行（网上有人说用MultiValueMap类型可以，我试了不行）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用POST请求： &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;p&gt;HashMap&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();&lt;br/&gt;map.put(&quot;name&quot;, &quot;测试&quot;);&lt;br/&gt;map.put(&quot;account&quot;, &quot;qwer&quot;);&lt;br/&gt;map.put(&quot;password&quot;, &quot;qwer&quot;);&lt;br/&gt;ObjectMapper mapper = new ObjectMapper();&lt;br/&gt;String jsonStr = null;&lt;br/&gt;try {&lt;br/&gt;　　jsonStr = mapper.writeValueAsString(map);&lt;br/&gt;} catch (Exception e) {&lt;br/&gt;　　e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;//创建HTTP头部实体，填充头部信息，比如数据格式&lt;br/&gt;HttpHeaders httpHeaders = new HttpHeaders();&lt;br/&gt;httpHeaders.setContentType(MediaType.APPLICATION_JSON_UTF8);&lt;/p&gt;
&lt;p&gt;//创建HTTP实体，可以直接利用构造方法将请求体和请求头放进去&lt;br/&gt;HttpEntity&amp;lt;String&amp;gt; httpEntity = new HttpEntity&amp;lt;String&amp;gt;(jsonStr2, httpHeaders);&lt;/p&gt;
&lt;p&gt;String url = &quot;http://localhost:80/mandy/user_enable.json&quot;;&lt;/p&gt;
&lt;p&gt;//调用方法进行请求&lt;br/&gt;Result res2 = restTemplate.postForObject(url, httpEntity, Result.class);&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; RestTemplate源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T postForObject(String url, Object request, Class&amp;lt;T&amp;gt;&lt;span&gt; responseType, Object... uriVariables)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {

        RequestCallback requestCallback &lt;/span&gt;=&lt;span&gt; httpEntityCallback(request, responseType);
        HttpMessageConverterExtractor&lt;/span&gt;&amp;lt;T&amp;gt; responseExtractor =
                &lt;span&gt;new&lt;/span&gt; HttpMessageConverterExtractor&amp;lt;T&amp;gt;&lt;span&gt;(responseType, getMessageConverters(), logger);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;使用PUT请求：&lt;/span&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
HashMap&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();&lt;/span&gt;&lt;span&gt;
map.put(&lt;/span&gt;&quot;user_id&quot;, &quot;1&quot;&lt;span&gt;);
map.put(&lt;/span&gt;&quot;enable&quot;, 0&lt;span&gt;);&lt;br/&gt;ObjectMapper mapper = new ObjectMapper();
String jsonStr &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    jsonStr &lt;/span&gt;=&lt;span&gt; mapper.writeValueAsString(map);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JsonProcessingException e) {
    e.printStackTrace();
}&lt;br/&gt;//创建HTTP头部实体，填充头部信息，比如数据格式
HttpHeaders httpHeaders &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpHeaders();
httpHeaders.setContentType(MediaType.APPLICATION_JSON_UTF8);&lt;br/&gt;//创建HTTP实体，可以直接利用构造方法将请求体和请求头放进去
HttpEntity&lt;/span&gt;&amp;lt;String&amp;gt; httpEntity = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;String&amp;gt;&lt;span&gt;(jsonStr, httpHeaders);       
String url &lt;/span&gt;= &quot;http://localhost:80/mandy/user_enable.json&quot;&lt;span&gt;;
restTemplate.put(url , httpEntity);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; RestTemplate源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put(String url, Object request, Object... urlVariables) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {
        RequestCallback requestCallback &lt;/span&gt;=&lt;span&gt; httpEntityCallback(request);
        execute(url, HttpMethod.PUT, requestCallback, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, urlVariables);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个方法有个小的缺点就是没有请求结果的返回值，如果需要用到返回值，就不能用这个方法。&lt;/p&gt;
&lt;p&gt;如果要使用delete类型的请求，RestTemplate的put方法的参数列中只有下面几种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete(String url, Object... urlVariables) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {
　　execute(url, HttpMethod.DELETE, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, urlVariables);
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete(String url, Map&amp;lt;String, ?&amp;gt; urlVariables) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {
　　execute(url, HttpMethod.DELETE, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, urlVariables);
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete(URI url) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {
　　execute(url, HttpMethod.DELETE, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些方法并没有给我们参数让我们放请求体内容，所以如果要直接使用RestTemplate提供的Delete方法，接口必须使用restful风格，将参数放在地址中，通过@PathVariable(value=&quot;&quot;)注解将参数获取到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;重点：&lt;/strong&gt;&lt;/span&gt;其实我们可以直接使用RestTemplate的&lt;span&gt;exchange&lt;/span&gt;方法，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt;&lt;span&gt; exchange(String url, HttpMethod method,
　　HttpEntity&lt;/span&gt;&amp;lt;?&amp;gt; requestEntity, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {

　　RequestCallback requestCallback &lt;/span&gt;=&lt;span&gt; httpEntityCallback(requestEntity, responseType);
　　ResponseExtractor&lt;/span&gt;&amp;lt;ResponseEntity&amp;lt;T&amp;gt;&amp;gt; responseExtractor =&lt;span&gt; responseEntityExtractor(responseType);
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; execute(url, method, requestCallback, responseExtractor, uriVariables);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只列举了一个方法，其他的可以看源码，这个方法可以进行所有类型的请求。&lt;/p&gt;
&lt;p&gt;在这个方法中，method参数可以通过HTTPMethod枚举来进行获取，requestEntity参数是自己封装的HttpEntity实体，包含请求体和请求头，responseType参数是返回结果的映射类，uriVariables这个参数给我的印象就是鸡肋（个人看法），获取请求返回接口可以通过方法返回值的getBody()方法获取。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 03:35:00 +0000</pubDate>
<dc:creator>快乐的小乐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzw-blog/p/8360512.html</dc:identifier>
</item>
</channel>
</rss>