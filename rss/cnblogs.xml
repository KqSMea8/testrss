<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java核心技术第五章——2.Object类 - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/9404966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/9404966.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Object类：所有类的超类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。但是并不需要这样写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
public class Emloyee extends Object
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果没有明确的指出超类，Object就被认为是这个类的超类。在Java中，只有基本数据类型不是对象，所有数组类型，不管是对象数组还是基本类型的数组都扩展（继承）了Object类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.equals方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Object类中的equals方法用于检车一个对象是否等于另外一个对象。也就是说是否具有相同的引用。当时这种判断相同引用一般来说并没有什么luan用。一般只需要两个对象的状态相等，就认为这两个对象时相等的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; Employee{

    private double&lt;span&gt; salary;

    private&lt;span&gt; LocalDate hireDay;

    public boolean&lt;span&gt; equals(Object otherObject){
        if(this == otherObject) return true; //是否为相同引用

        if(otherObject==null) return false&lt;span&gt;;

        if(this.getClass() != otherObject.getClass()) return false; //是否属于同一个类
&lt;span&gt;
        Employee other = (Employee)otherObject;//实例化同一个类则强转
        
        return salary==other.salary&amp;amp;&amp;amp;hireDay.equals(other.hireDay);//判断值是否一致。&lt;span&gt;
    }

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.相等测试与继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java语言规范要求equals方法具有下面的特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.自反性：对于任何非空引用x，x.equals(x)返回true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.对称性：对于任何引用x和y，当且仅当y.equals（x）返回true，x.equals(y)也应该返回true.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.传递性：对于任何引用x、y和z，如果x.equals（y）返回true，y.equals（z）返回true，x.equals（z）也应该返回true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.一致性：如果x和y引用的对象没有发生任何改变，返回调用x.equals（y）应该返回同样的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.对于任何的非空引用x，x.equals(null)应该返回false。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;然而利用只getClass检测，是不符合置换原则的。这是因为没有任何一个子类需要重新定义集合是否相等的语义（重新定义equals方法）。在Object中的equals方法没有被声明为final，这样做，可以让子类选择更加有效的算法对集合进行是否相等的检测（重写equals方法）。&lt;/p&gt;
&lt;p&gt;如果子类能够拥有自己的相等概念（equals方法在子类中定义），则对称性需求将强制采用getClass进行检测。&lt;/p&gt;
&lt;p&gt;如果由超类决定相等的概念（equals方法在父类中定义），那么久可以使用instanceof进行检测。这样就可以在不同子类的对象之间进行相等的比较。（比较的域只能是父类的数据域）&lt;/p&gt;

&lt;p&gt;一个比较完善的equals方法：&lt;/p&gt;
&lt;p&gt;1.方法参数命名为otherObject 类型为Object，稍后用到。&lt;/p&gt;
&lt;p&gt;2.判断是否为同一引用，如果相同返回true。&lt;/p&gt;
&lt;p&gt;3.判断是否为Null，如果为Null则返回false;&lt;/p&gt;
&lt;p&gt;4.判断是否为同一个类或同一个父类，判断是否为同一个类时则需要在每个子类中定义equals方法（使用getClass方法判断）。&lt;/p&gt;
&lt;p&gt;如果判断是否为同一个父类，那么相等时只能使用到父类的equals方法（使用instanceof方法）。&lt;/p&gt;
&lt;p&gt;5.强制类型转换otherObject引用为需要判断的类型。&lt;/p&gt;
&lt;p&gt;6.判断基本数据类型域和对象域是否都一致。一致返回true.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.hashCode方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode（）和y.hashCode（）基本上不会相同。例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        String s = &quot;OK&quot;&lt;span&gt;;
        StringBuilder sb = new&lt;span&gt; StringBuilder(s);
        System.out.println(s.hashCode() + &quot;  &quot; +&lt;span&gt; sb.hashCode());

        String t = new String(&quot;OK&quot;&lt;span&gt;);
        StringBuilder tb = new&lt;span&gt; StringBuilder(t);
        System.out.println(t.hashCode() + &quot;   &quot; + tb.hashCode());&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2524  1376400422
2524   418304857
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处s和t拥有相同的散列码，这是因为字符串的散列码是由内容导出的。即内容相同，hashCode值相同。&lt;/p&gt;
&lt;p&gt;而StringBuffer类中没有定义hashCode方法，是因为它的散列码是由Object类的默认hashCode方法导出的对象存储地址。所以即对象不同，则hashCode值不同。&lt;/p&gt;

&lt;p&gt;注意：如果重新定义Equals方法后，hashCode也必须重新定义。保证x.equals(y)返回true，x.hashCode就必须和y.hashCode（）的值一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.toString方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Objcet中有一个重要的方法，就是toString方法，它用于返回表示对象值得字符串。而Objcet中的toString方法打印的是类名和散列码值。一般比较少用。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　 public&lt;span&gt; String toString() {
        return getClass().getName() + &quot;@&quot; +&lt;span&gt; Integer.toHexString(hashCode());
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而自定义的实体类，一般都会重写toString方法。而重写的toString方法用方括号把域值括起来。例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    public&lt;span&gt; String toString() {
        return getClass().getName()+&quot;{&quot; +
                &quot;salary=&quot; + salary +
                &quot;, hireDay=&quot; + hireDay +
                '}'&lt;span&gt;;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是子类的程序员定义自己的toString方法，并将子域添加进去。那么子类增加super.toString即可。&lt;/p&gt;
&lt;p&gt;若类域包含数组类型的。那么使用toString方法将会把数组打印成类名@散列码。是因为数组继承了Object的toString方法。&lt;/p&gt;
&lt;p&gt;解决方法：一维数组使用Arrays.toString(数组引用)，多维数组使用Arrays.deepToString（数组引用）。&lt;/p&gt;
&lt;p&gt;个人提倡使用lombok插件。不需要写set、get、toString方法。更详细的lombok插件解释请自行上网搜索。&lt;/p&gt;

&lt;p&gt;若小弟写的有什么不足之处，请在评论区评论或至邮箱821312534@qq.com。Thanks♪(･ω･)ﾉ&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 22:59:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Johnson-lin/p/9404966.html</dc:identifier>
</item>
<item>
<title>每天叫醒你的不是闹钟，而是“爱词霸每日一句”——Python实现将每日一句定时推送至微信 - ngle</title>
<link>http://www.cnblogs.com/connect/p/python-wechat-iciba.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/connect/p/python-wechat-iciba.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前几天在网上看到一篇文章《教你用微信每天给女票说晚安》，感觉很神奇的样子，随后研究了一下，构思的确是巧妙。好，那就开始动工吧！服务器有了，Python环境有了，IDE打开了...然而...然而...我意识到了一个非常严重的问题...没有女朋友 (T＿T)...&lt;/p&gt;
&lt;p&gt;微信开发已经活跃了很长时间了，在微信开发中有一个神奇的接口它叫&lt;strong&gt;模板消息接口&lt;/strong&gt;，它可以根据用户的openid从服务端给用户推送自定义的模板消息，正因如此，我们可以利用这个特征在服务器端随时向用户推送消息（前提是该用户关注了该公众号）。&lt;/p&gt;
&lt;p&gt;总结出3点，1.模板消息的格式可以自定义，2.模板消息的内容可以自定义，3.模板消息发送的时间可以自定义。那么我们可以利用这些性质为自己做一款说&lt;strong&gt;早安&lt;/strong&gt;的程序啦！&lt;/p&gt;
&lt;h2 id=&quot;实验环境&quot;&gt;实验环境&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;阿里云Linux服务器&lt;/li&gt;
&lt;li&gt;Python 2.7&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;爱词霸每日一句api介绍&quot;&gt;爱词霸每日一句API介绍&lt;/h2&gt;
&lt;p&gt;调用地址：&lt;code&gt;http://open.iciba.com/dsapi/&lt;/code&gt;&lt;br/&gt;请求方式：GET&lt;br/&gt;请求参数：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;格式为：&lt;code&gt;2013-05-06&lt;/code&gt;；如果&lt;code&gt;date&lt;/code&gt;为，则默认取当天&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;可选值为&lt;code&gt;last&lt;/code&gt;和&lt;code&gt;next&lt;/code&gt;；以&lt;code&gt;date&lt;/code&gt;日期为准的，&lt;code&gt;last&lt;/code&gt;返回前一天的，&lt;code&gt;next&lt;/code&gt;返回后一天的&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;请求示例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/python
#coding=utf-8
import json
import urllib2
def get_iciba():
  url = 'http://open.iciba.com/dsapi/'
  request = urllib2.Request(url)
  response = urllib2.urlopen(request)
  json_data = response.read()
  data = json.loads(json_data)
  return data
print get_iciba()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PHP示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
function https_request($url, $data = null){
  $curl = curl_init();
  curl_setopt($curl, CURLOPT_URL, $url);
  curl_setopt($curl, CURLOPT_HEADER, 0);
  curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);
  curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 0);
  if (!empty($data)) {
    curl_setopt($curl, CURLOPT_POST, 1);
    curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
  }
  curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
  $output = curl_exec($curl);
  curl_close($curl);
  return $output;
}
function get_iciba(){
  $url = 'http://open.iciba.com/dsapi/'
  $result = https_request($url);
  $data = json_decode($result);
  return $data;
}
echo get_iciba();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回类型：JSON&lt;br/&gt;JSON字段解释：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;sid&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;每日一句ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;tts&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;音频地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;content&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;英文内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;note&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;中文内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;love&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;每日一句喜欢个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;translation&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;词霸小编&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;picture&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;图片地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;picture2&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;大图片地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;caption&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;dateline&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;s_pv&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;浏览数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;sp_pv&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;语音评测浏览数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;tags&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;相关标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;fenxiang_img&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;合成图片，建议分享微博用的&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;正常返回示例：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;sid&quot;: &quot;3080&quot;,
  &quot;tts&quot;: &quot;http://news.iciba.com/admin/tts/2018-08-01-day.mp3&quot;,
  &quot;content&quot;: &quot;No matter how hard we try to be mature, we will always be a kid when we all get hurt and cry. &quot;,
  &quot;note&quot;: &quot;不管多努力蜕变成熟，一旦受伤哭泣时，我们还是像个孩子。&quot;,
  &quot;love&quot;: &quot;1966&quot;,
  &quot;translation&quot;: &quot;小编的话：这句话出自小说《彼得·潘》。岁月永远年轻，我们慢慢老去。不管你如何蜕变，最后你会发现：童心未泯，是一件值得骄傲的事情。长大有时很简单，但凡事都能抱着一颗童心去快乐享受却未必容易。&quot;,
  &quot;picture&quot;: &quot;http://cdn.iciba.com/news/word/20180801.jpg&quot;,
  &quot;picture2&quot;: &quot;http://cdn.iciba.com/news/word/big_20180801b.jpg&quot;,
  &quot;caption&quot;: &quot;词霸每日一句&quot;,
  &quot;dateline&quot;: &quot;2018-08-01&quot;,
  &quot;s_pv&quot;: &quot;0&quot;,
  &quot;sp_pv&quot;: &quot;0&quot;,
  &quot;tags&quot;: [
    {
      &quot;id&quot;: null,
      &quot;name&quot;: null
    }
  ],
  &quot;fenxiang_img&quot;: &quot;http://cdn.iciba.com/web/news/longweibo/imag/2018-08-01.jpg&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本接口（每日一句）官方文档：&lt;a href=&quot;http://open.iciba.com/?c=wiki&quot; class=&quot;uri&quot;&gt;http://open.iciba.com/?c=wiki&lt;/a&gt;&lt;br/&gt;参考资料：&lt;a href=&quot;http://open.iciba.com/?c=wiki&quot;&gt;金山词霸 · 开发平台&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;登录微信公众平台接口测试账号&quot;&gt;登录微信公众平台接口测试账号&lt;/h2&gt;
&lt;p&gt;扫描登录公众平台测试号&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&quot;&gt;申请测试号的地址 https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001829278-1923495176.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;手机上确认登录&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001834438-98300541.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到&lt;code&gt;新增测试模板&lt;/code&gt;，添加模板消息&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001839619-1135914488.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写模板标题&lt;code&gt;每日一句&lt;/code&gt;，填写如下模板内容&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;{{content.DATA}}

{{note.DATA}}

{{translation.DATA}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001845221-1785026324.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提交保存之后，记住该&lt;code&gt;模板ID&lt;/code&gt;，一会儿会用到&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001849583-1248996138.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到&lt;code&gt;测试号信息&lt;/code&gt;，记住&lt;code&gt;appid&lt;/code&gt;和&lt;code&gt;appsecret&lt;/code&gt;，一会儿会用到&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001853944-1298462007.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到&lt;code&gt;测试号二维码&lt;/code&gt;。手机扫描此二维码，关注之后，你的昵称会出现在右侧列表里，记住该微信号，一会儿会用到（注：此微信号非你真实的微信号）&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001858036-1194920342.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;发送微信模板消息的程序&quot;&gt;发送微信模板消息的程序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本程序您只需要修改4个地方即可，请看注释&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/python
#coding=utf-8
import json
import urllib2

class iciba:
    # 初始化
    def __init__(self, wechat_config):
        self.appid = wechat_config['appid']
        self.appsecret = wechat_config['appsecret']
        self.template_id = wechat_config['template_id']
        self.access_token = ''

    # 获取access_token
    def get_access_token(self, appid, appsecret):
        url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=%s&amp;amp;secret=%s' % (appid, appsecret)
        request = urllib2.Request(url)
        response = urllib2.urlopen(request)
        json_data = response.read()
        data = json.loads(json_data)
        access_token = data['access_token']
        self.access_token = access_token
        return self.access_token

    # 发送消息
    def send_msg(self, openid, template_id, iciba_everyday):
        msg = {
            'touser': openid,
            'template_id': template_id,
            'url': iciba_everyday['fenxiang_img'],
            'data': {
                'content': {
                    'value': iciba_everyday['content'],
                    'color': '#0000CD'
                    },
                'note': {
                    'value': iciba_everyday['note'],
                },
                'translation': {
                    'value': iciba_everyday['translation'],
                }
            }
        }
        json_data = json.dumps(msg)
        if self.access_token == '':
            self.get_access_token(self.appid, self.appsecret)
        access_token = self.access_token
        url = 'https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=%s' % str(access_token)
        request = urllib2.Request(url, data=json_data)
        response = urllib2.urlopen(request)
        result = response.read()
        return json.loads(result)

    # 获取爱词霸每日一句
    def get_iciba_everyday(self):
        url = 'http://open.iciba.com/dsapi/'
        request = urllib2.Request(url)
        response = urllib2.urlopen(request)
        json_data = response.read()
        data = json.loads(json_data)
        return data

    # 为设置的用户列表发送消息
    def send_everyday_words(self, openids):
        everyday_words = self.get_iciba_everyday()
        for openid in openids:
            result = self.send_msg(openid, self.template_id, everyday_words)
            if result['errcode'] == 0:
                print ' [INFO] send to %s is success' % openid
            else:
                print ' [ERROR] send to %s is error' % openid

    # 执行
    def run(self, openids):
        self.send_everyday_words(openids)


if __name__ == '__main__':
    # 微信配置
    wechat_config = {
        'appid': 'xxxxxx', #此处填写你的appid
        'appsecret': 'xxxxxxx', #此处填写你的appsecret
        'template_id': 'xxxxx' #此处填写你的模板消息ID
    }
    # 用户列表
    openids = [
        'xxxxx', #此处填写你的微信号
        #'xxxx', #如果有多个用户也可以
    #'xxxx',
    ]
    # 执行
    icb = iciba(wechat_config)
    icb.run(openids)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试程序&quot;&gt;测试程序&lt;/h2&gt;
&lt;p&gt;在Linux上执行程序&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802001906633-791250923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在手机上查看，已经收到了每日一句的消息&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802002321405-74749091.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署程序&quot;&gt;部署程序&lt;/h2&gt;
&lt;p&gt;在Linux上设置定时任务&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;crontab -e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;pre class=&quot;crontab&quot;&gt;
&lt;code&gt;0 6 * * *    python /root/python/iciba/main-v1.0.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注：以上内容的含义是，在每天&lt;code&gt;6:00&lt;/code&gt;的时候，执行这个Python程序&lt;/em&gt;&lt;br/&gt;查看定时任务是否设置成功&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;crontab -l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，程序部署完成，请您明天&lt;code&gt;6:00&lt;/code&gt;查收吧！&lt;br/&gt;效果图如下&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222343/201808/1222343-20180802061420747-1818912766.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 22:13:00 +0000</pubDate>
<dc:creator>ngle</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/connect/p/python-wechat-iciba.html</dc:identifier>
</item>
<item>
<title>依赖注入[7]: .NET Core DI框架[服务注册] - Artech</title>
<link>http://www.cnblogs.com/artech/p/net-core-di-07.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/net-core-di-07.html</guid>
<description>&lt;p&gt;包含服务注册信息的IServiceCollection对象最终被用来创建作为DI容器的IServiceProvider对象。服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、ServiceDescriptor&lt;br/&gt;二、IServiceCollection&lt;br/&gt;     Add&lt;br/&gt;     Add{Lifetime}&lt;br/&gt;     TryAdd&lt;br/&gt;     TryAdd{Lifetime}&lt;br/&gt;     TryAddEnumerable&lt;br/&gt;     RemoveAll &amp;amp; Replace&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-06.html&quot;&gt;依赖注入[6]: .NET Core DI编程体验&lt;/a&gt;》的实例演示我们知道作为DI容器的IServiceProvider对象是通过调用IServiceCollection接口的扩展方法BuildServiceProvider创建的，IServiceCollection对象是一个存放服务注册信息的集合。Cat中的服务注册是通过一个类型为ServiceRegistry的对象表示的，在IServiceCollection/IServiceProvider为核心的DI框架中，与之对应的类型为ServiceDescriptor。&lt;/p&gt;
&lt;p&gt;DI框架将服务注册存储在一个通过IServiceCollection接口表示的集合之中。如下面的代码片段所示，一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表。在默认情况下我们使用的是实现该接口的ServiceCollection类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceDescriptor
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type                 ServiceType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceLifetime             Lifetime { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type                 ImplementationType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;     ImplementationFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;                 ImplementationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceDescriptor(Type serviceType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; instance);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceDescriptor(Type serviceType, Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; factory, ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServiceDescriptor(Type serviceType, Type implementationType, ServiceLifetime lifetime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
ServiceDescriptor的其他三个属性体现了服务实例的三种提供方式，并对应着三个构造函数。如果我们指定了服务的实现类型（对应于ImplementationType属性），那么最终的服务实例将通过调用定义在实现类型中某一个构造函数来创建。如果指定的是一个Func对象（对应于ImplementationFactory属性），那么IServiceProvider对象将会将自身作为输入参数调用该委托对象来提供服务实例。如果我们直接指定一个现有的对象（对应的属性为ImplementationInstance），那么该对象就是最终提供的服务实例。
&lt;p&gt;如果我们采用直接提供服务实例的形式来创建ServiceDescriptor对象，意味着服务注册默认采用Singleton生命周期模式。对于通过其他两个构造函数创建创建的ServiceDescriptor对象来说，则需要显式指定采用的生命周期模式。相较于ServiceDescriptor，我们在Cat框架中定义的ServiceRegistry显得更加精炼，因为我们直接提供了一个类型为Func&amp;lt;Cat,Type[], object&amp;gt;的属性来提供对应的服务实例。&lt;/p&gt;
&lt;p&gt;除了调用上面介绍的三个构造函数来创建对应的ServiceDescriptor对象之外，我们还可以提供定义在ServiceDescriptor类型中一系列静态方法来创建该对象。如下面的代码片段所示，ServiceDescriptor提供了如下两个名为Describe的方法重载来创建对应的ServiceDescriptor对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceDescriptor
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Describe(Type serviceType, Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory, ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ServiceDescriptor Describe(Type serviceType, Type implementationType, ServiceLifetime lifetime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
当我们调用上面两个Describe方法来创建ServiceDescriptor对象的时候总是需要指定采用的生命周期模式，为了让对象创建变得更加简单，ServiceDescriptor中还定义了一系列针对三种生命周期模式的静态工厂方法。如下所示的是针对Singleton模式的一组Singleton方法重载的定义，针对其他两种模式的Scoped和Transient方法具有类似的定义。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceDescriptor
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton&amp;lt;TService, TImplementation&amp;gt;() &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton&amp;lt;TService, TImplementation&amp;gt;(Func&amp;lt;IServiceProvider, TImplementation&amp;gt; implementationFactory) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton&amp;lt;TService&amp;gt;(Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton&amp;lt;TService&amp;gt;(TService implementationInstance) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton(Type serviceType, Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton(Type serviceType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; implementationInstance);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ServiceDescriptor Singleton(Type service, Type implementationType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;

&lt;p&gt;DI框架将服务注册存储在一个通过IServiceCollection接口表示的集合之中。如下面的代码片段所示，一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表。在默认情况下我们使用的是实现该接口的ServiceCollection类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IServiceCollection : IList&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt;
{}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollection : IServiceCollection
{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Add&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们在应用启动的时候所做的服务注册就是创建出现相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程。考虑到服务注册是一个高频调用的操作，所以DI框架为IServiceCollection接口定义了一系列扩展方法完成服务注册的工作，比如下面的这两个Add方法可以将指定的一个或者多个ServiceDescriptor对象添加到IServiceCollection集合中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection, ServiceDescriptor descriptor);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Add(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection, IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; descriptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Add{Lifetime}&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;DI框架还针对具体生命周期模式为IServiceCollection接口定义了一系列的扩展方法，它们会根据提供的输入创建出对应的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中。如下所示的是针对Singleton模式的AddSingleton方法重载的定义，针对其他两个生命周期模式的AddScoped和AddTransient方法具有类似的定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionServiceExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services) &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, TService implementationInstance)  &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Func&amp;lt;IServiceProvider, TImplementation&amp;gt;&lt;span&gt; implementationFactory)  &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Func&amp;lt;IServiceProvider, TService&amp;gt;&lt;span&gt; implementationFactory)  &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Type serviceType, Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Type serviceType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; implementationInstance);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;TryAdd&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;虽然针对同一个服务类型可以添加多个ServiceDescriptor，但这情况只有在应用需要使用到同一类型的多个服务实例的情况下才有意义，比如我们可以注册多个ServiceDescriptor来提供同一个主题的多个订阅者。如果我们总是根据指定的服务类型来提取单一的服务实例，这种情况下一个服务类型只需要一个ServiceDescriptor对象就够了。对于这种场景我们可能会使用如下两个名为TryAdd的扩展方法，该方法会根据指定ServiceDescriptor提供的服务类型判断对应的服务注册是否存在，只有不存在指定类型的服务注册情况下，我们提供的ServiceDescriptor才会被添加到指定的IServiceCollection对象中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAdd(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection, ServiceDescriptor descriptor);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAdd(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection, IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; descriptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;TryAdd{Lifetime}&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;扩展方法TryAdd同样具有基于三种生命周期模式的版本，如下所示的针对Singleton模式的TryAddSingleton方法的定义。在指定服务类型对应的ServiceDescriptor不存在的情况下，它们会采用提供的实现类型、服务实例创建工厂以及服务实例来创建生命周期模式为Singleton的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中。针对其他两种生命周期模式的TryAddScoped和TryAddTransient方法具有类似的定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  Type service);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection,  TService instance) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services,  Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection,  Type service, Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  Type service, Type implementationType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;TryAddEnumerable&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;除了上面介绍的扩展方法TryAdd和TryAdd{Lifetime}之外，IServiceCollection接口还具有如下两个名为TryAddEnumerable的扩展方法。当TryAddEnumerable方法在决定将指定的ServiceDescriptor添加到IServiceCollection对象之前，它也会做存在性检验。与TryAdd和TryAdd{Lifetime}方法不同的是，该方法在判断执行的ServiceDescriptor是否存在是会同时考虑服务类型和实现类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddEnumerable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, ServiceDescriptor descriptor);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddEnumerable(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; descriptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被TryAddEnumerable方法用来判断存在性的实现类型不只是ServiceDescriptor的ImplementationType属性。如果ServiceDescriptor是通过一个指定的服务实例创建的，那么该实例的类型会作为用来判断存在与否的实现类型。如果ServiceDescriptor是通过提供的服务实例工厂来创建的，那么代表服务实例创建工厂的Func&amp;lt;in T, out TResult&amp;gt;对象的第二个参数类型将被用于判断ServiceDescriptor的存在性。扩张方法TryAddEnumerable的实现逻辑可言通过如下这段程序来验证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection();

services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Foo&amp;gt;&lt;span&gt;());
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Foo&amp;gt;&lt;span&gt;());
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo()));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
Func&lt;/span&gt;&amp;lt;IServiceProvider, Foo&amp;gt; factory4Foo = _ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo();
services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;&lt;span&gt;(factory4Foo));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Bar&amp;gt;&lt;span&gt;());
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Baz()));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
Func&lt;/span&gt;&amp;lt;IServiceProvider, Gux&amp;gt; factory4Gux = _ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Gux();
services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;&lt;span&gt;(factory4Gux));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;4&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果通过上述策略得到的实现类型为Object，那么TryAddEnumerable会因为实现类型不明确而抛出一个ArgumentException类型的异常。这种情况主要发生在提供的ServiceDescriptor对象是由服务实例工厂创建的情况，所以上面实例中用来创建ServiceDescriptor的工厂类型分别为Func&amp;lt;IServiceProvider, Foo&amp;gt;和Func&amp;lt;IServiceProvider, Gux&amp;gt;，而不是Func&amp;lt;IServiceProvider, object&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; service = ServiceDescriptor.Singleton&amp;lt;IFoobarbazgux&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo());
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ServiceCollection().TryAddEnumerable(service);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设我们采用如上所示的方式利用一个Lamda表达式来创建一个ServiceDescriptor对象，对于创建的ServiceDescriptor来说，其服务实例工厂是一个Func&amp;lt;IServiceProvider, object&amp;gt;对象，所以当我们将它作为参数调用TryAddEnumerable方法的会抛出如图1所示的ArgumentException异常，并提示“Implementation type cannot be 'App.IFoobarbazgux' because it is indistinguishable from other services registered for 'App.IFoobarbazgux'.”&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot;/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180802060200234-1798495900.png&quot;&gt;&lt;img width=&quot;502&quot; height=&quot;215&quot; title=&quot;4-4&quot; alt=&quot;4-4&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180802060201254-1296013708.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图1实现类型不明确导致的异常&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;RemoveAll &amp;amp; Replace&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面介绍的这些方法最终的目的都是添加新的ServiceDescriptor到指定的IServiceCollection对象中，有的时候我们还希望删除或者替换现有的某个ServiceDescriptor，这种情况下通常发生在需要对当前使用框架中由某个服务提供的功能进行定制的时候。由于IServiceCollection实现了IList&amp;lt;ServiceDescriptor&amp;gt;接口，所以我们可以调用其Clear、Remove和RemoveAt方法来清除或者删除现有的ServiceDescriptor。除此之外，我们还可以选择如下这些扩展方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection RemoveAll&amp;lt;T&amp;gt;( &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection RemoveAll(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  Type serviceType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Replace(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  ServiceDescriptor descriptor);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
RemoveAll和RemoveAll方法帮助我们针对指定的服务类型来删除添加的ServiceDescriptor。Replace方法会使用指定的ServiceDescriptor去替换第一个具有相同服务类型（对应ServiceType属性）的ServiceDescriptor，实际操作是先删除后添加。如果从目前的IServiceCollection中找不到服务类型匹配的ServiceDescriptor，指定的ServiceDescriptor会直接添加到IServiceCollection对象中，这一逻辑也可以利用如下的程序来验证。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection();
services.Replace(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Foo&amp;gt;&lt;span&gt;());
Debug.Assert(services.Any(it &lt;/span&gt;=&amp;gt; it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Foo)));

services.AddSingleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Bar&amp;gt;&lt;span&gt;();
services.Replace(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Baz&amp;gt;&lt;span&gt;());
Debug.Assert(&lt;/span&gt;!services.Any(it=&amp;gt;it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Foo)));
Debug.Assert(services.Any(it &lt;/span&gt;=&amp;gt; it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Bar)));
Debug.Assert(services.Any(it &lt;/span&gt;=&amp;gt; it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;(Baz)));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;依赖注入[1]: 控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;依赖注入[2]: 基于IoC的设计模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;依赖注入[3]: 依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-04.html&quot;&gt;依赖注入[4]: 创建一个简易版的DI框架[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-05.html&quot;&gt;依赖注入[5]: 创建一个简易版的DI框架[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-06.html&quot;&gt;依赖注入[6]: .NET Core DI框架[编程体验]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-07.html&quot;&gt;依赖注入[7]: .NET Core DI框架[服务注册]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-08html&quot;&gt;依赖注入[8]: .NET Core DI框架[服务消费]&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 22:02:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/net-core-di-07.html</dc:identifier>
</item>
<item>
<title>Mybatis原理初探 - lzj123</title>
<link>http://www.cnblogs.com/lzj123/p/9404845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzj123/p/9404845.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;开篇略谈&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　谈到Mybatis，对于我们猿们来说是熟悉不过了。但是有没有兴趣去探一下其实现原理呢？是的，请往下看 ↓  come on...&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Mybatis综述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Mybatis一个数据持久层轻量级框架，回顾我们原始的开发即没有持久层框架的年代。话不多说上代码 ↓&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Connection con = DriverManager.getConnection(url, &quot;...&quot;, &quot;...&quot;&lt;span&gt;); // 首先我们得获得一个数据库连接
Statement stmt &lt;/span&gt;= con.createStatement(); // 不管你是获得statement还是preparedStatement，总之在项目越来越大得时候这些代码会有点累赘&lt;br/&gt;// PreparedStatement prestmt = con.prepareStatement(...);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　而我们得Mybatis则将其封装了起来，构成持久层框架，我们只要按照它的规定去配置就可以了，而无需在关注上面得代码，只需关注sql就行了，接下来入正题&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Mybatis源码解析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;提到Mybatis我们总会想起那个耳熟能详的东西sqlSession,是的，这是Mybatis的核心所在，sqlSession是由单例sqlSessionFactory创建而来的，而sqlSessionFactory又是由sqlSessionFactoryBuilder创建而来的，因此sqlSession得老祖宗就是它。在这里不管它的父辈，我们就来研究一下sqlSession的默认defaultSqlSession，多说无益看代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以看到 DefaultSqlSession 实现了SqlSession,这很容易让我们想起模板方法模式，请往下看&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultSqlSession &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; SqlSession {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面是一些变量&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; Configuration configuration; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个东西是核心关注点也是此次重点讲解点，它包含了Mybatis的所有配置信息，我们此次所要研究的就是configuration是如何将sql获取到的&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Executor executor;

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; autoCommit;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dirty;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Cursor&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; cursorList;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下是对SqlSession方法的实现    &lt;/span&gt;
&lt;span&gt;  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T selectOne(String statement) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.&amp;lt;T&amp;gt;selectOne(statement, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T selectOne(String statement, Object parameter) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Popular vote was to return null on 0 results and throw exception on too many.&lt;/span&gt;
    List&amp;lt;T&amp;gt; list = &lt;span&gt;this&lt;/span&gt;.&amp;lt;T&amp;gt;&lt;span&gt;selectList(statement, parameter);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.size() == 1&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list.get(0&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (list.size() &amp;gt; 1&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; +&lt;span&gt; list.size());
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个是获取configuration的mapper的，也就是获取sql语句的，这是重点讲解的&lt;/span&gt;
&lt;span&gt;  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; configuration.&amp;lt;T&amp;gt;getMapper(type, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }&lt;/span&gt;public &amp;lt;T&amp;gt; void addMapper(Class&amp;lt;T&amp;gt; type) {&lt;br/&gt;mapperRegistry.addMapper(type); &lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;  }  &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数据库连接&lt;/span&gt; &lt;span&gt; @Override &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection getConnection() { &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; executor.getTransaction().getConnection(); } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) { &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; ExceptionFactory.wrapException(&quot;Error getting a new connection. Cause: &quot; +&lt;span&gt; e, e); } } } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而SqlSession又继承了Closeable，很明显Closeable就是关闭connection的，这里就不详细说明&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; SqlSession &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Closeable { &lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; T selectOne(String statement); &lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; T selectOne(String statement, Object parameter); .......此处省略，详情可自己看源码 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是DefaultSqlSession的方法介绍，此次要从addMapper方法入手弄明白Mybatis它是如何获取我们写的SQL语句的，come on&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下是mapperRegistry&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapperRegistry {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt; addMapper(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (type.isInterface()) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasMapper(type)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; loadCompleted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        knownMappers.put(type, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MapperProxyFactory&amp;lt;T&amp;gt;&lt;span&gt;(type));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's important that the type is added before the parser is run
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherwise the binding may automatically be attempted by the
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mapper parser. If the type is already known, it won't try.&lt;/span&gt;
        MapperAnnotationBuilder parser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperAnnotationBuilder(config, type);
        parser.parse(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是使用了MapperAnnotationBuilder的parse方法进行了解析，那么它是如何解析的呢，解析的又是什么？&lt;/span&gt;
        loadCompleted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }

   ..... 其他代码就省略了
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们看它是如何解析的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapperAnnotationBuilder {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parse() {
    String resource &lt;/span&gt;=&lt;span&gt; type.toString();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!configuration.isResourceLoaded(resource)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先会判断这个接口即Mapper是否加载过了&lt;/span&gt;
      loadXmlResource(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是对mapper的xml文件进行解析&lt;/span&gt;
      configuration.addLoadedResource(resource); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载进去&lt;/span&gt;
&lt;span&gt;      assistant.setCurrentNamespace(type.getName());
      parseCache();
      parseCacheRef();
      Method[] methods &lt;/span&gt;= type.getMethods(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得当前Mapper接口的所有方法&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #237&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;method.isBridge()) {
            parseStatement(method); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对方法进行解析&lt;/span&gt;
&lt;span&gt;          }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IncompleteElementException e) {
          configuration.addIncompleteMethod(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MethodResolver(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, method));
        }
      }
    }
    parsePendingMethods();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个方法也是MapperAnotationBuilder的&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseStatement(Method method) {
    Class&lt;/span&gt;&amp;lt;?&amp;gt; parameterTypeClass = getParameterType(method); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得参数类型&lt;/span&gt;
    LanguageDriver languageDriver =&lt;span&gt; getLanguageDriver(method); 
    SqlSource sqlSource &lt;/span&gt;= getSqlSourceFromAnnotations(method,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是获取sqlSource parameterTypeClass, languageDriver);&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (sqlSource != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      Options options &lt;/span&gt;= method.getAnnotation(Options.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String mappedStatementId = type.getName() + &quot;.&quot; +&lt;span&gt; method.getName();
      Integer fetchSize &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      Integer timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      StatementType statementType &lt;/span&gt;=&lt;span&gt; StatementType.PREPARED;
      ResultSetType resultSetType &lt;/span&gt;=&lt;span&gt; ResultSetType.FORWARD_ONLY;
      SqlCommandType sqlCommandType &lt;/span&gt;=&lt;span&gt; getSqlCommandType(method);
      &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isSelect = sqlCommandType ==&lt;span&gt; SqlCommandType.SELECT;
      &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flushCache = !&lt;span&gt;isSelect;
      &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; useCache =&lt;span&gt; isSelect;

      KeyGenerator keyGenerator;
      String keyProperty &lt;/span&gt;= &quot;id&quot;&lt;span&gt;;
      String keyColumn &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SqlCommandType.INSERT.equals(sqlCommandType) ||&lt;span&gt; SqlCommandType.UPDATE.equals(sqlCommandType)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; first check for SelectKey annotation - that overrides everything else&lt;/span&gt;
        SelectKey selectKey = method.getAnnotation(SelectKey.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selectKey != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          keyGenerator &lt;/span&gt;=&lt;span&gt; handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);
          keyProperty &lt;/span&gt;=&lt;span&gt; selectKey.keyProperty();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (options == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          keyGenerator &lt;/span&gt;= configuration.isUseGeneratedKeys() ?&lt;span&gt; Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          keyGenerator &lt;/span&gt;= options.useGeneratedKeys() ?&lt;span&gt; Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
          keyProperty &lt;/span&gt;=&lt;span&gt; options.keyProperty();
          keyColumn &lt;/span&gt;=&lt;span&gt; options.keyColumn();
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        keyGenerator &lt;/span&gt;=&lt;span&gt; NoKeyGenerator.INSTANCE;
      }

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (options != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (FlushCachePolicy.TRUE.equals(options.flushCache())) {
          flushCache &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (FlushCachePolicy.FALSE.equals(options.flushCache())) {
          flushCache &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        useCache &lt;/span&gt;=&lt;span&gt; options.useCache();
        fetchSize &lt;/span&gt;= options.fetchSize() &amp;gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;issue #348&lt;/span&gt;
        timeout = options.timeout() &amp;gt; -1 ? options.timeout() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        statementType &lt;/span&gt;=&lt;span&gt; options.statementType();
        resultSetType &lt;/span&gt;=&lt;span&gt; options.resultSetType();
      }

      String resultMapId &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      ResultMap resultMapAnnotation &lt;/span&gt;= method.getAnnotation(ResultMap.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resultMapAnnotation != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        String[] resultMaps &lt;/span&gt;=&lt;span&gt; resultMapAnnotation.value();
        StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String resultMap : resultMaps) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sb.length() &amp;gt; 0&lt;span&gt;) {
            sb.append(&lt;/span&gt;&quot;,&quot;&lt;span&gt;);
          }
          sb.append(resultMap);
        }
        resultMapId &lt;/span&gt;=&lt;span&gt; sb.toString();
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSelect) {
        resultMapId &lt;/span&gt;=&lt;span&gt; parseResultMap(method);
      }

      assistant.addMappedStatement(
          mappedStatementId,
          sqlSource,
          statementType,
          sqlCommandType,
          fetchSize,
          timeout,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ParameterMapID&lt;/span&gt;
          &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
          parameterTypeClass,
          resultMapId,
          getReturnType(method),
          resultSetType,
          flushCache,
          useCache,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO gcode issue #577&lt;/span&gt;
          &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
          keyGenerator,
          keyProperty,
          keyColumn,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DatabaseID&lt;/span&gt;
          &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
          languageDriver,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ResultSets&lt;/span&gt;
          options != &lt;span&gt;null&lt;/span&gt; ? nullOrEmpty(options.resultSets()) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SqlSource getSqlSourceFromAnnotations(Method method, Class&amp;lt;?&amp;gt;&lt;span&gt; parameterType, LanguageDriver languageDriver) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt; sqlAnnotationType = getSqlAnnotationType(method); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里会判断方法是否使用了select等注解&lt;/span&gt;
      Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否使用了provider注解&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (sqlAnnotationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sqlProviderAnnotationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;You cannot supply both a static SQL and SqlProvider to method named &quot; +&lt;span&gt; method.getName());
        }
        Annotation sqlAnnotation &lt;/span&gt;=&lt;span&gt; method.getAnnotation(sqlAnnotationType);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&quot;value&quot;&lt;span&gt;).invoke(sqlAnnotation);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buildSqlSourceFromStrings(strings, parameterType, languageDriver);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sqlProviderAnnotationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        Annotation sqlProviderAnnotation &lt;/span&gt;=&lt;span&gt; method.getAnnotation(sqlProviderAnnotationType);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation);
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&quot;Could not find value method on SQL annotation.  Cause: &quot; +&lt;span&gt; e, e);
    }
  }  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SqlSource getSqlSourceFromAnnotations(Method method, Class&amp;lt;?&amp;gt;&lt;span&gt; parameterType, LanguageDriver languageDriver) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt; sqlAnnotationType =&lt;span&gt; getSqlAnnotationType(method);
      Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt; sqlProviderAnnotationType =&lt;span&gt; getSqlProviderAnnotationType(method);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sqlAnnotationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sqlProviderAnnotationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;You cannot supply both a static SQL and SqlProvider to method named &quot; +&lt;span&gt; method.getName());
        }
        Annotation sqlAnnotation &lt;/span&gt;=&lt;span&gt; method.getAnnotation(sqlAnnotationType);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&quot;value&quot;&lt;span&gt;).invoke(sqlAnnotation);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buildSqlSourceFromStrings(strings, parameterType, languageDriver);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sqlProviderAnnotationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        Annotation sqlProviderAnnotation &lt;/span&gt;=&lt;span&gt; method.getAnnotation(sqlProviderAnnotationType);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation);
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&quot;Could not find value method on SQL annotation.  Cause: &quot; +&lt;span&gt; e, e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面两个方法我们可以解释为什么我们使用provider和直接在mapper接口方法上加select语句会有效&lt;/p&gt;

</description>
<pubDate>Wed, 01 Aug 2018 17:32:00 +0000</pubDate>
<dc:creator>lzj123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzj123/p/9404845.html</dc:identifier>
</item>
<item>
<title>MySQL的binlog恢复（Windows下） - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9404773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9404773.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;　　在最近的工作中，由于自己粗（zuo）心（si）误update操作导致几百行的数据出现错误，在心急如焚的同时（那时候我竟然不知道除了备份之后还有binlog日志恢复）立马查资料学习binlog的恢复，随后立马进行了恢复。虽然可以假装自己没出错（emmmmm......最后还是得承认的！），但下班之后心情不能久久平复，立马打开电脑进行一次实验记录才能对得起自己犯的错误。&lt;/p&gt;
&lt;p&gt;　　注：此次实验是在Wnidows下进行的（网上Linux挺多，但是Windows的甚少，加上本身我的电脑也是Win7就简单做一次实验吧！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;h2&gt;1、初识binlog&lt;/h2&gt;
&lt;p&gt;（1）MySQL的binlog就是大家经常所说的Binary Log，即bin-log，&lt;strong&gt;是MySQL存储对数据库改动的二进制文件，也就是记录了所有DDL与DML（select除外）语句&lt;/strong&gt;，利用它主要可以做两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据恢复&lt;/strong&gt;：通过mysqlbinog工具进行恢复；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据复制&lt;/strong&gt;：MySQL Replication在Master端开启binlog，Mster把它的二进制日志传递给slaves来达到master-slave数据一致的目的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）&lt;strong&gt;如何查看MySQL的日志情况（是否开启等）&lt;/strong&gt;，当MySQL还没开启时候，通过命令：show variables like ‘log_bin%'查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; show variables &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;log_bin%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------------------------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Variable_name                   &lt;span&gt;|&lt;/span&gt; Value &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------------------------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; log_bin                         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;OFF&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; log_bin_basename                &lt;span&gt;|&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; log_bin_index                   &lt;span&gt;|&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; log_bin_trust_function_creators &lt;span&gt;|&lt;/span&gt; &lt;span&gt;OFF&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; log_bin_use_v1_row_events       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;OFF&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------------------------+-------+&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）&lt;strong&gt;如何在Wnidows在修改log_bin状态为ON开启呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找到C:\ProgramData\MySQL\MySQL Server 5.7\my.ini文件（&lt;strong&gt;注意：是C盘下隐藏文件夹ProgramData，而不是Program Files下&lt;/strong&gt;）　　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180801220948581-198155148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加/修改常用的配置属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASkAAABeCAYAAAB/yeJPAAAWEUlEQVR4nO2dTWgbybaAjy737d7SP7MMg2WQI++yGFpkAl5ckGKCCUGLQPCuFZgBiwvamUw8eGcYWjAhkXZmIAuRMSYkEryFIQk2s8guHgkscckysb18u7fod071X3Wru9Wt37ZzPmhsqbqqTlV3nzp1qnQ6pSPn5+ewsLAA1l+GYZik8A9WUAzDJJl/yAqK/jIMwyQJtqQYhkk0bEkxDJNo2JJiGCbRsCXFMEyiYUuKYZhEw5YUwzCJhi0phmESTbgldVmF3EELoFOC3IfebCRkGOabJpIl1bs8hezcUuRCex9ykNpJeY4cVC/7z20dpK6eAkSl7W5bCVozEuVK9h/DxCAV+ts9ehg7G9Cd34W9uWOoZaIXTIrKlYfKercC+uOtsTZglrQOcnD24zFszc1aEoa5vgRaUjRCpxp1gE8FSB+dQL2Bn19UR6ttYdn+V7a2vJaAlVY6KAVbKx5rxltG9YXzvVOXWQZNYz3WnX3OqG30kcHf2mpBSbYyP5Q87QhPH7n/BtbPMAmBLKmvX7/q8l+btqor77t6809F1y70WHTfKzo8BelQ9WbAeVSHf34nT9957aarPO056GrbUwjKL+p+rtmf7XPMtsloz/1lDCKsX0get7yqI4dX3gtNV566zx+UbjFs/0Utn2FmTahPinxRo6AWddB/MY8iQCHALxWcvwZ58/+luaw7cf4MdiVLqvzVvwxlretMMTM1Z/qJ/xf/3nOsC7TMGjcrdn0jgZZaY6EJx7clPx7W11xoGO2ndNAcWea2YH9NcecPS49IYP+NqXyGmQYBq3vGVICmeSdHaSh8OoHysxGnAviQdtcA2hfjEBvle9aA4k+OEuwO8ZBt3QHYNdtUfQewfTv64oAfNM0qdYbL26eEY6aPyqTLZ5hhCbCk8lAzH3yyhrRFFZr4+Xikh7gFe0cAK/NjkPryDE4Xi47DGi2DTVSosbGsqXFaUQRaJsXzXY/V2ILDc1NmSoeGK736ru7OH5Y+DvkilW/5rWa3eskw//RaUvKUr4tWz0qMFT0LsijSQmmkQL71aepVE4qFbv6ClJaG1BH9JWVYg7SUH1BJ1qBkOPExRw66qCxxenKTnMNlq2RQVxXh3BfnZ+Ty62bZxvTTu0JJ1lSqAVhvDAXcseRBPuFUU0pSi2a5D4qQe+ZN0516PenKotsSDE8ftf+WBtbPMEkhRc7yIJ+UscS+De1XZ1C7RlsHXNBG1cvKiFbi6JBi34T9QDkGpU+6foaZFeH7pK4xtMWi8Mn57GdlTRraomA7/Be1vj1kg9InXT/DJIFQS4phGGbWcBQEhmESDUdBYBgm0bAlxTBMomFLimGYRMPxpBiGSTQTiScl8oT8Sn/SiAgOEX8nyPGYGCbZhFtSF20Y4scmgqXbx0P/pm5U8vfppzzRz+UNjAyTXKYbT8rDaPGWInBhxY3qt6xGj8fEMMxUoB3nk4gnZREU72jUeEuDoPzwVJJblNEfL2roeFYMw0yFicaTCmTUeEsuKyvYGlOLUmhfUcYpHMYIpRIaz4phmKkQEAVB/pV9Ggr051MKGmvdmflvhJKwp2tGKJlaaA5lPGFhGIaZKVOMJyUxarylSJxA+ZXkQxMxp7KwMeUfETMMMxoTiSc1KN4RTaFGjbcUWvsB/bqfYkw1XDGntJ+Ozenb6PGYGIaZDlcmnhTHO2KYb5NEx5PieEcMw3A8KYZhEg1HQWAYJtFwFASGYRINW1IMwyQatqQYhkk0bEkxDJNoAi2pXjUHqVRKHLnqlONBlajeHESpls6dtnxXgVGuH/c/kyQG7pOim11sotya7ibKai4HsH8MU6722jHs9eP+Z5LCSD6pai5lj9aplE88KDsNR+VqKf6o3q1CTi5DyhpmKVhppVIpRL4J0TNlxoe8ZNXbKrllsM6R2mS3J+f83tDVv1heLueO5yWnl1pmf+fGGPPrKvY/c/0gSyownhTS1RRd0XziQSng/r6p6qBornTVDsak6QqAbzlBUH4ARbeziDJ84kEFyEffg3R+0Hn94DlYtw4Bh9TG4CKM9or2U7+YcpAMdp/g9155NCVY3qYKff3rpDd1Fdzpcj/E6Xe5/Nn0P8O4Gc6SQkugkW26pxD5GjSzDWO07ZnxoOxgTFuwr8UPI6w2pemGKOMUDmMMx2pTige1HDUeFFZ4HKiiMC3iT3MUqf3qhi2HDfZXsbHnWBdobTWKFUferW3IltO2JVKoq9C06jb71+n/PNRQi42b2fQ/w7iZ2upe/JtUgZX0REQZAGpZnEahZvA/xjidQj0Eu+ZUqboLsO1yAKHiQaWoW0cToBBWd3oFxhtNflb9zzBuhrOkcFQtnu56Vn9acHhaNEbeJTMelJRe3R0iHtSm9FCi9bBZzsJGn0kybsZkSUXBsqY8VhRBjus+91122RSxv39be+WhX5rhz6z6n2E80Jyv3ydl+jj6DsknYfpd5HRVdlh40hUluk9C+F9A0VVVkcqX/CMD5DP8IZJMwi9kyjFpv4jcbqrcrJvqteRy9ZPks5IxfEIBfe+tR9Sl6qrtk4pw/UK40v3PXDumFgVhVlsZEg9aUbmzyhj6pQWl3BnUxmnpMUwCmKhPSl4iTzeKrKAkjA2TeBTqcFJOQ2mE9XmjrALUT8rj3YLAMAmA40kxDJNopv/bvZ68QdDv4E1/E4X7n7liTD8KwtIWHMtL631HrX9P0QRpdQY8kpdVqMZ4Vx90SuJNz9H21fdEiGTvG5TF26MPRlAVJIN4Y3MLqt43Po+p/3uX/S3sfahKCs5oWyms71C+1qV/UutgSGVpt32YzEwSCX1bzDdBpwCpxqCT2rD8S3Tlqdy8C9G9bypsu14uQa/20qD72KmNFGk+E0N1z6+AsroBW3N5VBX0yngQb8qxX5Q6DjqbkDrq3/Sgzm2hrPYn2MjQm3l2YcWv/rk0nKEi273p9waeOhQONkC/H9ZuUoRpKC807fPEC21Xt8fbVmam/PObVlAm9CqtWtCru2hk7vjsGI9BnDfd9D7sildtne7I+57odVz5oR68pdvH0IUSbL4qwfLj8Vqp6qomXnnWvlyGlb93oQF+7zWkdzgCKiq0jPoU/RJsPdCg8WwPWrfltB6cnWP5dwZJi/kf67B8QNaoo+iUed6Fep0It6RwqpN7vwzHmUPIXVau5euk0vPD7tP2vrtPpm6+x89AWeuiitrDKUjNUDTUr88kJbRjlKKsqpCd3wf9zluozh/D8RxZCpsAD/qtkJ79bsBgUp/cnwtoUTVjWIQDmUcF1WkDnLeFjNvvSwEnoqL6Ke0/BUbL6/iX0cTI/9iF9Jxxb3YvTiCbuX736bdMJEuKTOjsnHPhyWdS+KREmkLQubvz8V+oKT+Eygxf7x5MwKve0fLyV+iooKx/xYNJn0jRHcKGUByokA7ewl2R7y7AQRVa8w1o3EQLzKePyULSbwfJhuW+OIPK460Y08741I+kV7s+I0Wr4AQvh/eGpDx3ZDWuxlCSNHiQWgtoQcd6YasPn1IBg4e7ftcr03CAUM9XxPslgwcA6573DFCe160Nyn+3E5Auylk2y/Y8X1Z78ZzuzUZI/i3z+XSeG5c8Yfm9dSYF2tEZGAWhrerwZ1Pvvld0te1O0p4runYxsU2mNlS38n5yu5T92ubC7IPI4PkueS80XQsqn8p+Cjo81/TuRVNvXnjS4tQr6Orae7HFW1efRttdPjLYPtX3+qAMz1Vsu08a5lGo3ebRf32NvOr7uC0Iabfnunjvq+afxnXwptH31v3Rd89TOzBP80/391Hy993XZln2/9Q30vWnOpTnUlSJsPw+58vpkduXEAJX98QKE2nuTwWhdeuNlFi1cnGB05Yd/F4c7hUV0t4pM827emWllQ5K9jmpnfirOTQSBuen0U6S7UPJVxZCtG0n4Agara1aDjzndzZwarfpfH6FJ3X8V5taHSobR/cHAJvPDtHCkvoHy9Fxmh3YL52Sj7w4NYRDKHXSsLJ4CmdTXeGi/va2cwWPbv+pwpLUQcejuapA0Ts9uzyDU8y7AmcRV0lNOodQX93Av/09JhzqIeTv67Y1RFaqn+W+9dhtZfQ6DcjeoYWCLDQ6jqRR8xuQ1Vs1+kR++e1qE7TzQ+PaX1ZhF7ah6Ct5QH6keBOn+D6rxPHkmz2BPilx0TLG1GX7YhPOfvQ24ATKDVo10o3piPCzlOxVMGs6YjiN3RjOXDJByUeii/PFeahA8hGndaSgGje7eGOZ55tL/9aNVn1RwKtEbQDbBxQ0bRzsOA+WQ/TTffOD8OH5TcX8fqrSQnWigbbYlvwyxjTiFOXU75OceXyQDWVb8MqaqWFazZbRO8XsobLYuwBb8Y0ba0phUMapH02l9iFtKSlSNAvLUMG/LWxHLD/YBfbJzQreb2+F0ov24OB0+d0paA/w/rsgBV4QD7q16uf1VdE1KtIgZ/kOh3hD9tu/s7DxmP7bgOyLtwC34+U/OUob9WPdfW4DZOsOGIPqRRll1wFQacXJT/dI84IGjrzvHXhVCN0nNWj0UYuS4sIHbX/tFA5j7ClSi1K8obkYoVxQGTQWmm6FQxdkoWGM5JdmPCtL8QjZxhvIxAWO3C2znuMw60ei9+EMNu7ftT6ZViHehKvmzWdbR5Z/wrA8ApWpB+rP+qA9YCMglDNZQz9poJJSLZJjfhPeWieQoplPoxztyPdED61dun5kYQofqHDMR7SlOntQXjC3HggFrkN3fjd0zxqtDOqmRUd+mr6ZQmh9JazPWvXNw8ZCOXxPmA80aOq/NCEwElgGlR/eC4Vzzfe6D8xPkv1YhMarq/1TqYAd58boTdM8emDIEVp+5p0qKbAyPwuRhyOWEoyI9VDRFKtgKaZMBa0j+wyxx0koINfD0sKH+a5jXVx2YfmBLiyjDUkhGQfehItFuBvXIiI5zndd0y/3xtWePV32mwKHI02lX5EdsWlMT4tZaF9YdZ0a07iM//Srr0S0zDYBrSfAqQ0+lBV6KFHpb6AVP3hjJsqDVn3Ts6dq6fY+aDeXYUlsaQi/X5dub4P6tR3Z5SCm6p8K9mBCVuVwg0JeOOsD04pNaIZaeGH5wRigUQHHVaBJIsCSMlauumh90PRCW1TFtMw9VULFJWtotF42j/z2yUwA7Pii5wE0NkEWjZF0zoy3JKVX3/n7lmgaMBwt2ENTe9lSHqvWqEp7d+QVrLQYscWKiqWoLtPmKp7VHpwOjTwt60o+OlKYKMedrLhGhgrqeXxUxh4jusbyym00jPtD/6ULzTuobEkZkP8IFePKO5xedKpwOL9vWtloZeBkNfghMQbAwwzdX3idXjWg+MBZlbQsgWA1SsqWNov6rRpiG2/nRd+0v2ada+XnP6Pp6WrU/XDGhltnIDEO24c0JNUXPhZ4JvpU2Tc/GAoYjsYdb2x6hO6T6uKouOKjdGjUK39FBbaKJvKOtQxtLF8aHerdQ2TOnc0l4LS9JJoSfqMaWMvJdcgB+Y26ofmpjq0HRcjhzS0tgguFauFNVxaDp3vkOA91j5Mz1kVP+Lzqq01/X4DF5VvYfYfSZ7bEjaJhO8TDh0ph1K0BrmVllKM7fwhvyRqTlR1Oe7qXeN5OG/ttA9p/oyLBh1baTAJ7F9tQC9zKEAJOd0rY+gqWX+ocQ2W+AXudLRzVt83tD04t+R812H2GSqFvedvctCn8bAF7wnDA2V5ImW3wKqLgfWRuWQ+hvriCdpqMoRyd+8e4f+2S5f4VWxrMe0/a41bfafRvSdg57d9mIOd3lZ127acT97dUfsra5gPSvjr69cDaKZSD8oPkL8R6G8IPSxaZCvV3Us8FtS+kG2dG2EsYjKVVWg6O8PKBhBO0lUFegvUl4lYAsYT9tP9Q/tTcWwvcUnmWfemzTzm0RcGTr0nlDpRKaoMoS16eH2WbgiT3RVeSLbhM6n+Soa+v7e0IYcvfVr9YZVM9YXn6+zH0GjOJZuB7964yrs16Q6zeMDEQFkAbtpM6GjNXFo4nxTBMopl+PCmGYZgY+P527+vXAbkYhmGmBFtSDMMkmulH5mQYhokBW1IMwyQaX0vqqJKC777LQf3z4ALo3PV63J9VAHyu57COlDiGyT8ujLY6R+VocJ5rz1HJ1SfiWO///Zer7+z0FlTsfOY9JJdX4dc8MPHw3SdFjvP6eg7g92NQb0xWAFJWP8M+vFFnENTucxXWfwZ48yaZ+6fq6yVYelODtRnU7b0upJB+S3ddnx9CE77s5e3zf3hdhC/Ul6iU1nuVvms6rXuKuV6E+6T+gw+xd1Q0CbOErLRKRR6RSxDXSKmvp0Lye0bseimWVSasgB/K8PFjOdBaCKvfSqP6nL7Acz6bfYYPZMX6zrYkpDI81opLbrOMJx/r8DAhVt7aTxpAt2vL91tHsxUUcUM9hpeZsiHj9yv2udRPTtuysHRjqmIz14AQn9QJPHnYgHt/6fDlCx5/FeH1D85DRjclff/Xr/2/iaM0+v6PPwBeftHN807htxjTOrq5X9/rGnXT8RLgoaRE6usFLFyS7Ukdbv3ajWyRre1RPg1u3dKcOiSLalD96hv6ToWPT9KGBWGe0/rPFryhcj+eGPJRvodGP1AftGxFs2H3DR33XqcdJXQDy8Dvfr2lus7Zi2RS9eC/UfbF7wIObMN/ReohN/Wfy5DJm1bT/zQA7t3tO2ctr0KnZ17jzhnQQNIFBTKv35r/r8zEKmSuNqGW1KOXkmmOD87vrodsMI9eOlOVG0sxQqXgSP0603QrnLUajtQNw5qjdNCch1bINsZ4UYPqlyDFaCs3PMeW6ZYk36ON/ofz+zP4TbKSnnwcl/BL8L+oQL9+CThQ1v+LWBIpYEs+UtjRlCRyYxnE79KPDqFzbx/S0N9vDBOVEEtKgfT3M5MrNrGU4MzBqeoPkpUaYJEOx/gsKaGAv1gW455jRf+rCPD6bd/5R606ZJaMiKJpaEPF/Pyve3j6M1RYmeUxtZH5lgixpHC697Pko0Hr4ucnWchPw15Hy+heZ9cz+rag1Skalh2le0bn+m/hscjHWv+ofD6Dzi2pLNG3ftF+TqFnySB8WFH8euOzpGzQQqSp6kNrZQ7759+ZsmuljvxyDzuS9YiydzqquF+EUvsDr0+a34fHxMc3nhQ5lZ98VODRowY+GE68qF//OjanLeS0LsAfdjE4LXhCf8mHUoPvaaXniRkv6qUOe4AP2EMjXtQ6kN+oG5qf6lB/L8L6DyiHJOyjl068KG/6rVvxLBHyOVlTLLuNj5zVqvD65fbXTdmN9L3vq5ivDFT0d5Vl+ELF/VGA9XQXfqd/Hxp98vu9nKtvHz1S7DTrQVf/nYXvbBmcvpk4qBCN64fX5bUmprPkZ/yVFgvWjc/k03sptiCYeW5pLp/eUuYE+2DbkJeU/q0yTtEZJj6+URCu4m/3ZrqVgWGYiXGld5zLWwRohY0VFMNcP66NJcUwzPXkSltSvnyWN6D6HfE3lTIMMzs4MifDMInm+llSDMNcKzieFMMwiYYtKYZhEg1bUgzDJBq2pBiGSTRsSTEMk2j+HxDhkAOe1CV1AAAAAElFTkSuQmCCAA==&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）常用简单属性说明：除了以上log_bin、binlog_format两个简单的配置外，还可以有其他的属性配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;log-bin = /xxx/xxx/mysql_bin &lt;span&gt;#binlog日志文件,以mysql_bin开头，六个数字结尾的文件：mysql_bin.000001，并且会将文件存储在相应的xxx/xxx路径下，如果只配置mysql_bin的话默认在C:\ProgramData\MySQL\MySQL Server 5.7\Data下；&lt;/span&gt;&lt;/code&gt; &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;binlog_format = ROW &lt;span&gt;#binlog日志格式，默认为STATEMENT：每一条SQL语句都会被记录；ROW：仅记录哪条数据被修改并且修改成什么样子，是binlog开启并且能恢复数据的关键；&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;expire_logs_days= 7 &lt;span&gt;#binlog过期清理时间；&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;max_binlog_size = 100m &lt;span&gt;#binlog每个日志文件大小；&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;binlog_cache_size = 4m &lt;span&gt;#binlog缓存大小；&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;&lt;code&gt;max_binlog_cache_size = 512m &lt;span&gt;#最大binlog缓存大小。&lt;/span&gt;&lt;/code&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2、恢复数据测试&lt;/h2&gt;
&lt;p&gt;（1）准备表user&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt; password                         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Zhangsan &lt;span&gt;|&lt;/span&gt; 2d7284808e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Lisi     &lt;span&gt;|&lt;/span&gt; 2d73641c8e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Wangwu   &lt;span&gt;|&lt;/span&gt; 2d73670c8e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------------------------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （2）误update恢复，比如我在update user set name = 'Lijian' where id = 1;的时候忘写where id = 1重要条件，结果导致全部数据被更新&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lijian&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; rows affected
Rows matched: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  Changed: &lt;span&gt;3&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------+----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name   &lt;span&gt;|&lt;/span&gt; password                         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------+----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Lijian &lt;span&gt;|&lt;/span&gt; 2d7284808e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Lijian &lt;span&gt;|&lt;/span&gt; 2d73641c8e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Lijian &lt;span&gt;|&lt;/span&gt; 2d73670c8e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------+----------------------------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个时候你肯定很慌，但是先不要慌（实际上慌也没用），先看没有备份，如果没有再看是否开启binlog（show variables like ‘log_bin%'），如果两者都没有（我相信大家都会定时备份+binlog）从数据库这个层面是无法恢复的了，如果binlog开启的话，一切都好说。就开始执行下面几步恢复吧！&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第一步：找到当前mysql记录的binlog文件，执行show master status;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　第二步：查看binlog，定位误操作的pos或者时间段。执行show binlog events in 'mysql_bin.000001';&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; show binlog events &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql_bin.000001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------------+-----+----------------+-----------+-------------+---------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Log_name         &lt;span&gt;|&lt;/span&gt; Pos &lt;span&gt;|&lt;/span&gt; Event_type     &lt;span&gt;|&lt;/span&gt; Server_id &lt;span&gt;|&lt;/span&gt; End_log_pos &lt;span&gt;|&lt;/span&gt; Info                                  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------------+-----+----------------+-----------+-------------+---------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; mysql_bin.&lt;span&gt;000001&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Format_desc    &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;123&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Server ver: &lt;span&gt;5.7&lt;/span&gt;.&lt;span&gt;12&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;, Binlog ver: &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; mysql_bin.&lt;span&gt;000001&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;123&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Previous_gtids &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;154&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;                                       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; mysql_bin.&lt;span&gt;000001&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;154&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Anonymous_Gtid &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;219&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@@SESSION&lt;/span&gt;.GTID_NEXT&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ANONYMOUS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; mysql_bin.&lt;span&gt;000001&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;219&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Query          &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;291&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;BEGIN&lt;/span&gt;                                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; mysql_bin.&lt;span&gt;000001&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;291&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Table_map      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;344&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; table_id: &lt;span&gt;108&lt;/span&gt; (test.&lt;span&gt;user&lt;/span&gt;)             &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; mysql_bin.&lt;span&gt;000001&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;344&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Update_rows    &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;650&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; table_id: &lt;span&gt;108&lt;/span&gt; flags: STMT_END_F       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; mysql_bin.&lt;span&gt;000001&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;650&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Xid            &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;681&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; xid=22 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;                   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------------+-----+----------------+-----------+-------------+---------------------------------------+&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;第三步：进入&lt;code&gt;C:\ProgramData\MySQL\MySQL Server 5.7\Data执行mysqlbinlog --start-position=219 --stop-position=681 mysql-bin.000001 &amp;gt; e:\\update.sql将update部分单独备份出来到E盘下为update.sql&lt;/code&gt;　&lt;/span&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;第四步：登录mysql（mysql -uroot -p123）&lt;/span&gt;&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第五步：执行source e:update.sql恢复数据&lt;/strong&gt;&lt;/span&gt;，部分截图如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180802000814235-1429751652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;第六步：查看结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt; password                         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Zhangsan &lt;span&gt;|&lt;/span&gt; 2d7284808e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Lisi     &lt;span&gt;|&lt;/span&gt; 2d73641c8e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Wangwu   &lt;span&gt;|&lt;/span&gt; 2d73670c8e5111e8af74201a060059ce &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------------------------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、总结&lt;/h2&gt;
&lt;p&gt;　　（1）&lt;strong&gt;&lt;span&gt;使用binlog只能针对针对数据量不是很多的情况，真正的生产环境每个几个G的日志文件，不止是光靠binlog恢复的&lt;/span&gt;&lt;/strong&gt;，还有更多的办法，在此只是做一个简单的学习记录！&lt;/p&gt;
&lt;p&gt;　　（2）判断时间binlog日志的时间阶段与pos位置很重要，但是需要知道关于binlog的很多参数！&lt;/p&gt;
&lt;p&gt;　　（3）之前天真的以为开发人员就不需要太了解数据库相关的运维，但是今天经历过才知道&lt;strong&gt;&lt;span&gt;数据库的相关知识也是开发人员必须了解的！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 01 Aug 2018 16:25:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9404773.html</dc:identifier>
</item>
<item>
<title>【java代码之美】---guava之Immutable(不可变)集合 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9404654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9404654.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      guava是google的一个库，弥补了java语言的很多方面的不足，很多在java8中已有实现，暂时不展开。Collections是jdk提供的一个工具类。&lt;/p&gt;
&lt;p id=&quot;h3_5&quot;&gt;      Guava中不可变对象和Collections工具类的unmodifiableSet/List/Map/etc的区别：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当Collections创建的不可变集合的wrapper类改变的时候，不可变集合也会改变&lt;/span&gt;，&lt;span&gt;而Guava的Immutable集合保证确实是不可变的&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、&lt;strong&gt;JDK中实现immutable集合&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 在JDK中提供了Collections.unmodifiableXXX系列方法来实现不可变集合, 但是存在一些问题，下面我们先看一个具体实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImmutableTest {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testJDKImmutable(){
        List&lt;/span&gt;&amp;lt;String&amp;gt; list=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;b&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;c&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过list创建一个不可变的unmodifiableList集合&lt;/span&gt;
        List&amp;lt;String&amp;gt; unmodifiableList=&lt;span&gt;Collections.unmodifiableList(list);
        System.out.println(unmodifiableList);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过list添加元素&lt;/span&gt;
        list.add(&quot;ddd&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;往list添加一个元素:&quot;+&lt;span&gt;list);
        System.out.println(&lt;/span&gt;&quot;通过list添加元素之后的unmodifiableList:&quot;+&lt;span&gt;unmodifiableList);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过unmodifiableList添加元素&lt;/span&gt;
        unmodifiableList.add(&quot;eee&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;往unmodifiableList添加一个元素:&quot;+&lt;span&gt;unmodifiableList);

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180801234704766-349782753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过运行结果我们可以看出：虽然unmodifiableList不可以直接添加元素，但是我的list是可以添加元素的，而list的改变也会使unmodifiableList改变。&lt;/p&gt;
&lt;p&gt;所以说&lt;span&gt;Collections.unmodifiableList实现的不是真正的不可变集合。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;span&gt;2、Guava的immutable集合&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;      Guava提供了对JDK里标准集合类里的immutable版本的简单方便的实现，以及Guava自己的一些专门集合类的immutable实现。当你不希望修改一个集合类，&lt;/p&gt;
&lt;p&gt;或者想做一个常量集合类的时候，使用immutable集合类就是一个最佳的编程实践。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;：每个Guava immutable集合类的实现都拒绝null值。我们做过对Google内部代码的全面的调查，并且发现只有5%的情况下集合类允许null值，而95%的情况下&lt;/p&gt;
&lt;p&gt;都拒绝null值。万一你真的需要能接受null值的集合类，你可以考虑用Collections.unmodifiableXXX。&lt;/p&gt;
&lt;p&gt;immutable集合可以有以下几种方式来创建：&lt;/p&gt;
&lt;p&gt;　　1、用copyOf方法, 譬如, ImmutableSet.copyOf(set)&lt;/p&gt;
&lt;p&gt;　　2、使用of方法，譬如，ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)或者ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2)&lt;/p&gt;
&lt;p&gt;　　3、使用Builder类&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGuavaImmutable(){

        List&lt;/span&gt;&amp;lt;String&amp;gt; list=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;b&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;c&quot;&lt;span&gt;);

        ImmutableList&lt;/span&gt;&amp;lt;String&amp;gt; imlist=&lt;span&gt;ImmutableList.copyOf(list);
        System.out.println(&lt;/span&gt;&quot;imlist：&quot;+&lt;span&gt;imlist);

        ImmutableList&lt;/span&gt;&amp;lt;String&amp;gt; imOflist=ImmutableList.of(&quot;peida&quot;,&quot;jerry&quot;,&quot;harry&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;imOflist：&quot;+&lt;span&gt;imOflist);

        ImmutableSortedSet&lt;/span&gt;&amp;lt;String&amp;gt; imSortList=ImmutableSortedSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;b&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;imSortList：&quot;+&lt;span&gt;imSortList);

        list.add(&lt;/span&gt;&quot;baby&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键看这里是否imlist也添加新元素了&lt;/span&gt;
        System.out.println(&quot;list添加新元素之后看imlist:&quot;+&lt;span&gt;imlist);

        ImmutableSet&lt;/span&gt;&amp;lt;Color&amp;gt; imColorSet =&lt;span&gt;
                ImmutableSet.&lt;/span&gt;&amp;lt;Color&amp;gt;&lt;span&gt;builder()
                        .add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Color(0, 255, 255&lt;span&gt;))
                        .add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Color(0, 191, 255&lt;span&gt;))
                        .build();

        System.out.println(&lt;/span&gt;&quot;imColorSet:&quot;+&lt;span&gt;imColorSet);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：发现imlist并未改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180802000044703-2043936975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于排序的集合来说有例外，因为元素的顺序在构建集合的时候就被固定下来了。譬如，ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;b&quot;)，对于这个集合的遍历顺序来说就是&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;更智能的copyOf&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;copyOf方法比你想象的要智能，ImmutableXXX.copyOf会在合适的情况下避免拷贝元素的操作－先忽略具体的细节，但是它的实现一般都是很“智能”的。譬如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Test
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCotyOf(){
            ImmutableSet&lt;/span&gt;&amp;lt;String&amp;gt; imSet=ImmutableSet.of(&quot;peida&quot;,&quot;jerry&quot;,&quot;harry&quot;,&quot;lisa&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;imSet：&quot;+&lt;span&gt;imSet);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set直接转list&lt;/span&gt;
            ImmutableList&amp;lt;String&amp;gt; imlist=&lt;span&gt;ImmutableList.copyOf(imSet);
            System.out.println(&lt;/span&gt;&quot;imlist：&quot;+&lt;span&gt;imlist);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;list直接转SortedSet&lt;/span&gt;
            ImmutableSortedSet&amp;lt;String&amp;gt; imSortSet=&lt;span&gt;ImmutableSortedSet.copyOf(imSet);
            System.out.println(&lt;/span&gt;&quot;imSortSet：&quot;+&lt;span&gt;imSortSet);

            List&lt;/span&gt;&amp;lt;String&amp;gt; list=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=10;i++&lt;span&gt;){
                list.add(i&lt;/span&gt;+&quot;x&quot;&lt;span&gt;);
            }
            System.out.println(&lt;/span&gt;&quot;list：&quot;+&lt;span&gt;list);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;截取集合部分元素&lt;/span&gt;
            ImmutableList&amp;lt;String&amp;gt; imInfolist=ImmutableList.copyOf(list.subList(2, 8&lt;span&gt;));
            System.out.println(&lt;/span&gt;&quot;imInfolist：&quot;+&lt;span&gt;imInfolist);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180802001121658-1322286517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Guava集合和不可变对应关系&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;table class=&quot;wikitable&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;可变集合类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;可变集合源：JDK or Guava?&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Guava不可变集合&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;Collection&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableCollection&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;List&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableList&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;Set&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableSet&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;SortedSet&lt;/tt&gt;/&lt;tt&gt;NavigableSet&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableSortedSet&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;Map&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableMap&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;SortedMap&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableSortedMap&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Multiset&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableMultiset&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;SortedMultiset&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableSortedMultiset&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Multimap&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableMultimap&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;ListMultimap&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableListMultimap&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;SetMultimap&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableSetMultimap&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BiMap&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableBiMap&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ClassToInstanceMap&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableClassToInstanceMap&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Table&lt;/td&gt;
&lt;td&gt;Guava&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;ImmutableTable&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;














&lt;p&gt;本文参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/peida/p/Guava_ImmutableCollections.html&quot;&gt;Guava学习笔记：Immutable(不可变)集合&lt;/a&gt; 感谢！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。中校【12】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 01 Aug 2018 16:18:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9404654.html</dc:identifier>
</item>
<item>
<title>基于kafka rest实现资源访问服务化（实战） - xnchall</title>
<link>http://www.cnblogs.com/xnchll/p/9404705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xnchll/p/9404705.html</guid>
<description>&lt;ul&gt;&lt;li&gt;问题引出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;新产品的体系架构包含多个模块，模块集特点是数量多、模块间交互复杂。那么统一接口是一个很好的解决方案，为了实现统一接口打算采用微服务的核心思想，设计了采用restful service的数据交互方式技术架构。这里记录一下kafka资源访问的服务化搭建，后续记录api和实战。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;restful api的出现在很大程度上降低了模块/系统数据交互的难度（开发和使用），特别是对前后端数据访问上。于是基于此，找到了confluent。confluent是kafka的创始团队离开Linkin后研发出来的产品，所以是一个很强大的产品级工具平台。confluent开源版本中包含了kafka rest proxy，具体如下：&lt;/p&gt;
&lt;ol readability=&quot;-0.49680571213829&quot;&gt;&lt;li readability=&quot;0&quot;&gt;下载confluent:
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://www.confluent.io/download/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注：下载包过程中需要填写email信息，尽管填就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;zk集群、kafka集群启动，这里就不介绍，具体请参考&lt;a title=&quot;kafka集群搭建&quot; href=&quot;https://www.cnblogs.com/xnchll/p/7495711.html&quot; target=&quot;_blank&quot;&gt;kafka集群搭建&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;由于confluent中包含了zk和kafka，这里就不用去处理。直接配置kafka rest proxy, 配置文件位置：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/Users/xnchall/Software/confluent/confluent-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/etc/kafka-rest/kafka-rest.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;p&gt;id=kafka-rest-test-server&lt;/p&gt;
&lt;p&gt;schema.registry.url=http://192.168.X.100:8081&lt;/p&gt;
&lt;p&gt;zookeeper.connect=192.168.X.100:2181,192.168.X.100:2182&lt;/p&gt;
&lt;p&gt;bootstrap.servers=PLAINTEXT://192.168.X.100:9092&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;schema.registry.url这个参数是为数据序列化avor服务的，建议配置上，说不定将来就用上了呢。其余两个分别是zookeeper和kafka集群配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;配置schema-registry:
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
路径：/Users/xnchall/Software/confluent/confluent-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/etc/schema-&lt;span&gt;registry
配置如下：
# The address the socket server listens on.
#   FORMAT:
#     listeners &lt;/span&gt;= listener_name:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;host_name:port&lt;/span&gt;
&lt;span&gt;#   EXAMPLE:
#     listeners &lt;/span&gt;= PLAINTEXT:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;your.host.name:9092&lt;/span&gt;
listeners=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0.0.0.0:8088&lt;/span&gt;
&lt;span&gt;
# Zookeeper connection &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the Zookeeper cluster used by your Kafka cluster
# (see zookeeper docs &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; details).
# This &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; a comma separated host:port pairs, each corresponding to a zk
# server. e.g. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.
kafkastore.connection.url&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.x&lt;span&gt;.100&lt;/span&gt;:&lt;span&gt;2181&lt;/span&gt;,&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;x.100&lt;/span&gt;:&lt;span&gt;2182&lt;/span&gt;&lt;span&gt;

# Alternatively, Schema Registry can now operate without Zookeeper, handling all coordination via
# Kafka brokers. Use &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; setting to specify the bootstrap servers &lt;span&gt;for&lt;/span&gt;&lt;span&gt; your Kafka cluster and it
# will be used both &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; selecting the master schema registry instance and &lt;span&gt;for&lt;/span&gt; storing the data &lt;span&gt;for&lt;/span&gt;&lt;span&gt;
# registered schemas.
# (Note that you cannot mix the two modes; use &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; mode only on &lt;span&gt;new&lt;/span&gt;&lt;span&gt; deployments or by shutting down
# all instances, switching to the &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; configuration, and then starting the schema registry
# instances again.)
#kafkastore.bootstrap.servers&lt;/span&gt;=PLAINTEXT:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9092&lt;/span&gt;
&lt;span&gt;
# The name of the topic to store schemas &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt;
kafkastore.topic&lt;/span&gt;=&lt;span&gt;_schemas

# If &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, API requests that fail will include extra debugging information, including stack traces
debug&lt;/span&gt;=True
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;启动kafka rest服务
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
路径：/Users/xnchall/Software/confluent/confluent-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
启动命令：&lt;br/&gt;./kafka-rest-start ../etc/kafka-rest/kafka-rest.properties&lt;p&gt;注意：前提是kafka和zk已经全部正常启动
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;启动schema-registry(可以不启动)
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
路径：同kafka-rest
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;启动命令：
.&lt;/span&gt;/schema-registry-start ../etc/schema-registry/schema-registry.properties 
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;检查kafka-rest否正常启动
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方式一：jps
方式二：&lt;/span&gt;http://192.168.X.100:8082/topics
&lt;/pre&gt;
&lt;pre&gt;
建议使用方式二直观明了
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，kafka-restful service算是搭建和启动完成，接下来就是具体通过kafka rest proxy访问kafka资源了，核心包括生产消息、各类消费消息、资源释放与本身负载均衡、以及存在问题等，请见待更新 &lt;span&gt;&lt;span&gt;&lt;strong&gt;kafka rest api介绍与实战&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考：https://www.confluent.io&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 15:52:00 +0000</pubDate>
<dc:creator>xnchall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xnchll/p/9404705.html</dc:identifier>
</item>
<item>
<title>初识 Java-监听器 - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/9404697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/9404697.html</guid>
<description>&lt;p&gt;使用Listener类&lt;br/&gt;当java  web应用程序在web容器中运行时，在java web应用程序内部会不断发生各种事件，例如web应用的启动，暂停，销毁等。以及web应用中session开始和结束&lt;br/&gt;这些web应用对开发者来说通常是看不见的。其实在servletapi中。提供了大量的监听器来监听web应用事件，其中Listener类是最为常用的。此类允许当web内部事件发生时回掉事件&lt;br/&gt;监听器的方法。&lt;br/&gt;2.Listener基础。&lt;br/&gt;在java  web应用程序中使用listener时，需要先定义Listener实现类，然后通过Annoation或在web.xml文件中进行配置Listener&lt;br/&gt;与AWT事件编程是完全相同的。如下是web事件监听器的接口。&lt;br/&gt;1）ServletContextListener监听web应用的启动和关闭&lt;br/&gt;2）ServletContextAttributeListener监听ServletContext范围内属性的改变&lt;br/&gt;3）ServletRequestListener监听用户的请求&lt;br/&gt;4）ServletRequestAttributeListener监听ServletRequest范围内（request）内属性的变化&lt;br/&gt;5）HttpSessionListener监听用户session的开始和结束&lt;br/&gt;6）HttpSessionAttributeListener监听HttpSession范围内session内属性的改变。&lt;br/&gt;Filter过滤器，如果有一个页面配置了多个Filter,其执行顺序为，在web.xml中配置的顺序，首先执行完成的过滤器是，最后配置的那个过滤器。&lt;br/&gt;实例一、创建一个ServletContex的监听器。&lt;br/&gt;ServletContextListener是最常用的Listener，可以在当前web应用被加载&lt;br/&gt;时对web应用的相关资源进行初始化操作：创建数据库连接池，创建spring的ioc容器，读取当前web应用的初始化参数&lt;br/&gt;步骤如下:&lt;br/&gt;1.创建一个类HelloServletContextListener实现ServletContextListener接口&lt;br/&gt;晚上两个接口中所包含的两个方法。&lt;br/&gt;2.配置该监听器。&lt;br/&gt;&amp;lt;!-- 配置Listener --&amp;gt;&lt;/p&gt;
&lt;p&gt;一，上下文监听（&lt;span&gt;ServletContext对象监听器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.上下文创建销毁监听：*（在服务器启动时，即Servlet容器（Tomcat）会执行创建的方法，也就是在服务器启动时application对象被创建）&lt;/p&gt;
&lt;p&gt;（服务器关闭时，Servlet容器（Tomcat）会执行销毁的方法，application对象被销毁）&lt;/p&gt;
&lt;p&gt;用途：如：可以在服务器启动时加载想要首先被加载的内容&amp;lt;但如果在这个时候加载的东西太多，服务器压力非常大，启动速度会变慢&amp;gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801231057841-23031933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.上下文容器监听（当向application中存放，添加，删除东西时，会分别触发监听器里面的三个方法）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801230507213-1227683050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 配置监听器:(后面两个配置与这个相同)&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801234431684-1477262504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二，会话监听（&lt;span&gt;HttpSession对象监听器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.会话创建销毁监听：*（在浏览器启动时会创建会话（session容器被创建））（在浏览器启动时会销毁会话（session容器被销毁））&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801230554519-2031903469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;.2.会话容器监听&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801230645500-1224085625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;3会话绑定监听&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801230716823-786992442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三，请求监听（&lt;span&gt;ServletRequest对象监听器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.请求创建销毁监听：**（当第二次访问某个request容器里面的东西时，因为容器已经被销毁，所以访问不存在）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801230750142-449487968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;.2.请求容器监听&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201808/1398504-20180801230815653-1559712331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 01 Aug 2018 15:48:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/9404697.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（26）——定制ORM（二） - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/9404658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/9404658.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　弄完底层数据库操作模块后，接下来要做的是ORM的正式设计。在开始之前，我们需要思考一下怎么来设计一个ORM呢？这个类它能帮助我们处理什么样的问题？需要有哪些功能模块？怎么做到针对不同的数据库与表单进行操作？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在前面我们知道，ORM它简单的理解就是将我们写的一些参数值转变为对应的sql语句，来对数据表进行增删改查的操作。它可以帮助我们整合重复的代码，让我们对数据库操作变的更加简单。也就是说，只需要将参数存储到对应的字典、列表或元组中，并将它们做为参数提交给ORM，ORM就会自动分析并处理，然后生成对应的sql语句。对于Pythoner来说，字典、列表和元组是我们最熟悉的变量，操作它们会更加的熟悉，而不是sql语句。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么ORM应该拥有哪些功能模块？我们可以从对数据库操作的角度进行思考，我们对数据库的操作无非就是增删改查，那么分解下来，实际上就是我们所要实现的功能了。比如说：新增记录、修改记录、删除记录、按指定条件查询、查询指定主键记录、判断记录是否存在、查询数量统计、查询指定值合计数、获取指定字段最大值、获取指定字段最小值......可以看到我们常用的查询还是挺多的，只要将它们一一实现，那么以后操作起这些功能就会变得更加的简单方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而对于有多数据库时，我们只需要将ORM进行抽象创建一个ORM基类，所有的数据表操作类继承它（每个数据表我们都需要独立创建一个对应的类，它需要继承ORM基类来获取基类的所有能力），在实例化数据表操作类时，像上一章所讲到的那样通过参数注入方式处理，即不同的数据库我们注入不同的数据库连接配置，这样我们在实例化数据表操作类时，就不必考虑它到底是属于那个数据库，我们只需要知道每个表对于每个数据库来说都是唯一的，在实例化时该操作类就会进行初始化操作，然后自动载入对应的数据库配置，当对这个表进行操作时，它也会自动连接对应的数据库执行相关的操作了。（如下图）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/129385/201808/129385-20180801224158868-1094728312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据上面的理解，我们先创建一个ORM基类：_logic_base.py（也可以称为逻辑层父类）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; common &lt;span&gt;import&lt;/span&gt;&lt;span&gt; db_helper
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogicBase():
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;逻辑层基础类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, db, table_name, column_name_list=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pk_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;类初始化&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据库参数&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         self.&lt;span&gt;__db&lt;/span&gt; =&lt;span&gt; db
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表名称&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         self.&lt;span&gt;__table_name&lt;/span&gt; =&lt;span&gt; str(table_name).lower()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询的列字段名称，*表示查询全部字段，多于1个字段时用逗号进行分隔，除了字段名外，也可以是表达式&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         self.&lt;span&gt;__column_name_list&lt;/span&gt; =&lt;span&gt; str(column_name_list).lower()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主健名称&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         self.&lt;span&gt;__pk_name&lt;/span&gt; = str(pk_name).lower()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　子类在继承该类时，通过对__init__()进行初始化，将相关的参数注入进来，在后续执行相关操作时，就可以直接调用这些参数进行设置了。例如我们创建一个manager表对应的操作类ManagerLogic()：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; logic &lt;span&gt;import&lt;/span&gt;&lt;span&gt; _logic_base
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; config &lt;span&gt;import&lt;/span&gt;&lt;span&gt; db_config
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取数据库参数&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; _db =&lt;span&gt; db_config.DB
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ManagerLogic(_logic_base.LogicBase):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用户管理表逻辑类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表名称&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;__table_name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;manager&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         _logic_base.LogicBase.&lt;span&gt;__init__&lt;/span&gt;(self, _db, &lt;span&gt;__table_name&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　通过from logic import _logic_base来导入父类，被ManagerLogic类所继承。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后导入配置文件db_config，获取数据库配置参数db_config.DB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ManagerLogic类在执行__init__()初始化时，在第18行中绑定好该类对应的数据库（不同类可以绑定不同的配置文件，即不同的数据库），以及设置该类绑定的数据表名称（通过这里绑定，在后续操作时就不会因为复制粘贴时不小时弄错表名了，当然在创建数据表子类时也要小心不要绑错表名称了）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　column_name_list是用于查询时，如果不设置输出字段名，则会默认使用这个变量做为参数，方便有些表在操作时可以直接在这里设置好输出字段名的限制。默认值为*，表示输出所有字段内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pk_name是数据表的主键名称，默认为id，对于一些不以id为默认值的，可以在这里进行设置为该表指定的主键名称。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　做好这些，ManagerLogic类就拥有了父类所有的能力（方法）了——当然需要后面将父类的功能实现后才行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如父类拥有get_model()方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_model(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;通过条件获取一条记录&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;获取一条记录&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　那么我们可以写个测试用例，通过下面方式来进行调用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/evn python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; logic &lt;span&gt;import&lt;/span&gt;&lt;span&gt; manager_logic

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbHelperTest(unittest.TestCase):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;数据库操作包测试类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化测试环境&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------ini------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;清理测试环境&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------clear------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只需要看这里，其他代码是测试用例的模板代码        #&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化manager表操作类ManagerLogic&lt;/span&gt;
        _manager_logic =&lt;span&gt; manager_logic.ManagerLogic()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行get_model()方法，获取记录实体&lt;/span&gt;
        model =&lt;span&gt; _manager_logic.get_model()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(model)
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
------ini------&lt;span&gt;
获取一条记录
&lt;/span&gt;------clear------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　看起来是不是很简单。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;版权声明：本文原创发表于 &lt;a href=&quot;http://www.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;博客园&lt;/span&gt;&lt;/a&gt;，作者为 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/EmptyFS/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;AllEmpty&lt;/span&gt;&lt;/a&gt; &lt;/strong&gt;本文欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python开发QQ群：669058475    作者博客：http://www.cnblogs.com/EmptyFS/&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 15:35:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/9404658.html</dc:identifier>
</item>
<item>
<title>观察者模式和发布订阅模式（上） - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/9404627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/9404627.html</guid>
<description>&lt;p&gt;定义：观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。&lt;br/&gt;其中有两个定义需要明确，被观察者和观察者。通常来说，这两者是一对多的，也有多对多的情景。&lt;br/&gt;在网页开发中，被观察者通常是数据源，不论是内存数据，还是持久化数据，又或者是接口返回的数据，都可以作为被观察者。它一旦改变，就去改变依赖于它的节点。&lt;br/&gt;观察者有很多可能，针对于网页开发，我们常常认为dom节点是观察者，一旦节点的监视的数据源发生变化，节点也执行更新方法。当然不限于此，也有可能是一个事件，一次计数等等。&lt;br/&gt;接下来用js写一个简单的观察者模式的例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 发布类
class Subject {
  constructor (data) {
    this.obList = [];
    this.data = data;
  }
  add (ob) {
    if (arguments.length &amp;gt;= 1) {
      Array.from(arguments).forEach(item =&amp;gt; this.obList.push(item));
    }
  }
  remove (ob) {
    let i = this.obList.findIndex(ele =&amp;gt; ele === ob);
    if (i &amp;gt;= 0) {
      this.obList.splice(i, 1);
    }
  }
  notify () {
    this.obList.forEach((item) =&amp;gt; {
      item.update(this.data);
    })
  }
}

// 观察者类
class Observer {
  constructor (id) {
    this.id = id;
  }
  update (data) {
    console.log('observer ' + this.id + ': ' + data + ';');
  }
}

function test() {
  let sub = new Subject('test');

  let ob1 = new Observer(1);
  let ob2 = new Observer(2);
  let ob3 = new Observer(3);

  sub.add(ob1, ob2, ob3);

  sub.notify();

  sub.remove(ob2);

  sub.notify();
}

test();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;observer 1: test;
observer 2: test;
observer 3: test;
observer 1: test;
observer 3: test;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里简单定义了一个发布类和一个观察类，发布者维护一个观察者列表，每次数据变化后，依次通知所有在观察者列表里的观察者。&lt;br/&gt;代码很简单，可以执行在控制台或者node里跑一下。&lt;br/&gt;但是这样的耦合很深，观察者和发布者不能有其他的表现，很死板，我们可以继续抽象一下。&lt;br/&gt;先画个类图：&lt;br/&gt;&lt;img src=&quot;http://img30.360buyimg.com/mobilecms/jfs/t23902/230/1500739281/31627/5fe11ead/5b61cc13Ndfa470fc.jpg&quot; alt=&quot;类图&quot;/&gt;&lt;br/&gt;借助于TypeScript，我们可以有如下的发布者和观察者定义。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;abstract class Observer {
    abstract update();
}

abstract class Subject {
    protected obList: ObserverList;
    abstract notify();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ObserverList则可以实现如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class ObserverList {
    private list: Array&amp;lt;Observer&amp;gt;;
    constructor () {
        this.list = [];
    }
    add (ob: Observer) {
        this.list.push(ob);
    }

    remove (ob: Observer) {
        if (this.list.indexOf(ob) &amp;gt; -1) {
            this.list.splice(this.list.indexOf(ob), 1);
        }
    }

    empty () {
        this.list = [];
    }

    public each () {
        this.list.forEach(item =&amp;gt; {
            item.update();
        })
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来实现两个实体类：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 实体发布类
class ConcreteSubject extends Subject {
    protected obList = new ObserverList();

    private _data: string;

    constructor (defaultData: string) {
        super();
        this._data = defaultData;
    }

    set data (newVaule) {
        this._data = newVaule;
    }
    get data () {
        return this._data;
    }

    add (ob: Observer) {
        this.obList.add(ob);
    }
    remove (ob: Observer) {
        this.obList.remove(ob);
    }
    notify () {
        this.obList.each()
    }
}

// 可以指定发布者的观察者类
class ConcreteObserver extends Observer {
    readonly _id;
    private sub;

    constructor (id, sub) {
        super();
        this._id = id;
        this.sub = sub;
    }

    get id () {
        return this._id;
    }

    update () {
        console.log('concrete observer ' + this.id + ': ' + this.sub.data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跑一下测试代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let sub = new ConcreteSubject('test');

let ob1 = new ConcreteObserver(1, sub);
let ob2 = new ConcreteObserver(2, sub);
let ob3 = new ConcreteObserver(3, sub);

sub.add(ob1)
sub.add(ob2)
sub.add(ob3)

sub.notify();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的发布类，使用add、remove等方法来处理观察者列表，通过notify方法，则去通知观察者们，可以去执行update方法了。&lt;br/&gt;观察者和被观察者，仍然耦合比较深，所以又有人提出来发布订阅模式，维护一个事件中心，来处理多个观察者和被观察者的关系，不让他们直接耦合在一起。下一篇对发布订阅做解析。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 15:28:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/9404627.html</dc:identifier>
</item>
</channel>
</rss>