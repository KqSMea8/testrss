<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>大数据技术——数据获取 - hzuCode</title>
<link>http://www.cnblogs.com/hzuCode/p/9465560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hzuCode/p/9465560.html</guid>
<description>&lt;p&gt;&lt;span&gt;主要介绍大数据获取的应用和场景，组件和技术不做详述，之后介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1. 网络爬虫&lt;/h2&gt;
&lt;p&gt;根据URL，并按照一定规则爬取网页内容，存储进库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PYTHON（Scrapy）: 适用小型爬虫项目&lt;br/&gt;JAVA（Nutch）：适用高并发下的爬虫项目&lt;br/&gt;假如对性能和效率有很高的要求，推荐C++，但开发代价略高。&lt;/p&gt;
&lt;h2&gt;2. 数据埋点&lt;/h2&gt;
&lt;p&gt;根据用户的特定请求，触发采集事件，从而获取用户行为数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/36411025&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关技术：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;网站平台：JS前端埋点+任意一种后端语言&lt;br/&gt;安卓平台：JAVA开发SDK&lt;br/&gt;根据平台的开发语言选择不同的技术实现埋点&lt;/p&gt;
&lt;h2&gt;3. 数据集成&lt;/h2&gt;
&lt;h3&gt;3.1 日志收集&lt;/h3&gt;
&lt;p&gt;利用FLUME将日志存储进库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/pelick/article/details/18193527&lt;/p&gt;
&lt;h3&gt;3.2 其他平台的数据源接入&lt;/h3&gt;
&lt;p&gt;利用sqoop将不同的数据源接入至HDFS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/dashujuedu/article/details/53669546&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4. 数据接入&lt;br/&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;实时流数据先接入KAFKA，以提供实时处理。&lt;br/&gt;再接入进HIVE（HDFS）中，以提供离线分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/BYRans/p/6054930.html http://lxw1234.com/archives/2015/06/238.htm&lt;br/&gt;例如：&lt;br/&gt;日志采集系统的数据流：&lt;br/&gt;日志数据--&amp;gt;FLUME--&amp;gt;KAFKA--&amp;gt;HIVE&lt;br/&gt;用户行为采集系统的数据流：&lt;br/&gt;行为数据--&amp;gt;KAFKA--&amp;gt;HIVE&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MAPREDUCE、STROM、SPARK STEAMING。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/amuseme_lu/article/details/4788820&lt;br/&gt;http://xinklabi.iteye.com/blog/2175661&lt;br/&gt;https://www.cnblogs.com/shenh062326/p/3530092.html&lt;/p&gt;

&lt;p&gt;&lt;span&gt;归纳: 一般的数据源为网络爬虫，数据埋点，数据集成。当获取数据后对接自己的数据平台（HIVE HDFS）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文章提及较多HADOOP生态圈的组件，但只是工具。可以不深究其技术原理，能掌握其特点和应用场景即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如数据平台之所以用HIVE搭建。是因为列存储和分布式存储为大数据处理提供高效的优势，&lt;/span&gt;&lt;span&gt;类SQL的语法为大数据分析提供低成本的开发环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读者也可以想想为啥实时流数据先进KAFKA，再进入HIVE。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 Aug 2018 15:45:00 +0000</pubDate>
<dc:creator>hzuCode</dc:creator>
<og:description>主要介绍大数据获取的应用和场景，组件和技术不做详述，之后介绍。 1. 网络爬虫 根据URL，并按照一定规则爬取网页内容，存储进库。 相关概念： https://baike.baidu.com/item</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hzuCode/p/9465560.html</dc:identifier>
</item>
<item>
<title>Django contenttypes 框架详解 - 天王盖地虎宝塔镇河妖</title>
<link>http://www.cnblogs.com/ManyQian/p/9463796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/9463796.html</guid>
<description>&lt;h2&gt;一、什么是Django ContentTypes？&lt;/h2&gt;
&lt;p&gt;Django ContentTypes是由Django框架提供的一个核心功能，它对当前项目中所有基于Django驱动的model提供了更高层次的抽象接口。 &lt;strong&gt;当然我们不是说的是http中的content-type！完全没有任何关系！&lt;/strong&gt;&lt;br/&gt;下面将一步一步解释Django ContentTypes在Django框架中做了什么，以及如何使用Django ContentTypes。 &lt;br/&gt;当然，如果对于ContentTypes有了初步了解而只是不了解它的应用场景，可以直接查阅一下原文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/1.10/ref/contrib/contenttypes/&quot; target=&quot;_blank&quot;&gt;https://docs.djangoproject.com/en/1.10/ref/contrib/contenttypes/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;二、Django ContentTypes做了什么？&lt;/h2&gt;
&lt;p&gt;当使用django-admin初始化一个django项目的时候，可以看到在默认的INSTALL_APPS已经包含了django.contrib.contenttypes:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.contenttypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.staticfiles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且注意django.contrib.contenttypes是在django.contrib.auth之后，这是因为auth中的permission系统是根据contenttypes来实现的。&lt;/p&gt;
&lt;p&gt;我们来查询查阅了一下django.contrib.contenttypes.models文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ContentType(models.Model):
    app_label &lt;/span&gt;= models.CharField(max_length=100&lt;span&gt;)
    model &lt;/span&gt;= models.CharField(_(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python model class name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), max_length=100&lt;span&gt;)
    objects &lt;/span&gt;=&lt;span&gt; ContentTypeManager()

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        verbose_name &lt;/span&gt;= _(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        verbose_name_plural &lt;/span&gt;= _(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content types&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        db_table &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django_content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        unique_together &lt;/span&gt;= ((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app_label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家可以看到ContentType就是一个简单的django model，而且它在数据库中的表的名字为django_content_type。 &lt;/p&gt;
&lt;p&gt;这个表的名字一般都不会陌生，在第一次对Django的model进行migrate之后，就可以发现在数据库中出现了一张默认生成的名为django_content_type的表。 &lt;br/&gt;如果没有建立任何的model，默认django_content_type是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180811113026502-881216759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，django_content_type记录了当前的Django项目中所有model所属的app（即app_label属性）以及model的名字（即model属性）。 &lt;br/&gt;当然，django_content_type并不只是记录属性这么简单，contenttypes是对model的一次封装，&lt;/p&gt;
&lt;p&gt;因此可以通过contenttypes动态的访问model类型，而不需要每次import具体的model类型。&lt;/p&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;ContentType实例提供的接口 &lt;br/&gt;&lt;ul&gt;&lt;li&gt;ContentType.model_class() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;获取当前ContentType类型所代表的模型类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ContentType.get_object_for_this_type() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;使用当前ContentType类型所代表的模型类做一次get查询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ContentType管理器（manager）提供的接口 &lt;br/&gt;&lt;ul&gt;&lt;li&gt;ContentType.objects.get_for_id() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;通过id寻找ContentType类型，这个跟传统的get方法的区别就是它跟get_for_model共享一个缓存，因此更为推荐。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ContentType.objects.get_for_model() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;通过model或者model的实例来寻找ContentType类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2&gt;三、Django ContentTypes的使用场景&lt;/h2&gt;
&lt;p&gt;在我们这个项目中各种商品的优惠卷就运用到了这个知识点：&lt;/p&gt;
&lt;p&gt;假使我们models下有这几张表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Electrics(models.Model):  #电器类
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    price&lt;/span&gt;= models.IntegerField(default=100&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foods(models.Model):     #食物类
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    price &lt;/span&gt;= models.IntegerField(default=100&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Clothes(models.Model):   #衣服类
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    price&lt;/span&gt;= models.IntegerField(default=100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coupon(models.Model):    #优惠券
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们先来考虑一个问题，如何把这些商品和优惠卷相关联？&lt;/p&gt;
&lt;p&gt;一种商品一个优惠卷，那我们就在表中加入一种商品的优惠券，就是一个一对多的ForeignKey,那么多个商品就有各种优惠卷，&lt;/p&gt;
&lt;p&gt;但是一种商品的特定优惠卷在表结构中，就那个字段有值，别的不相关的记录为null,而且每增加一个商品，又要手动的去添加外键，&lt;/p&gt;
&lt;p&gt;这是繁琐的！&lt;/p&gt;
&lt;p&gt;所以我们就使用contenttypes 应用中提供的特殊字段GenericForeignKey，我们可以解决上面的问题：&lt;/p&gt;
&lt;p&gt;只需要以下三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在model中定义ForeignKey字段，并关联到ContentType表。通常这个字段命名为“content_type”&lt;/li&gt;
&lt;li&gt;在model中定义PositiveIntegerField字段，用来存储关联表中的主键。通常这个字段命名为“object_id”&lt;/li&gt;
&lt;li&gt;在model中定义GenericForeignKey字段，传入上述两个字段的名字。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体实例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coupon(models.Model):
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)

    content_type &lt;/span&gt;= models.ForeignKey(to=ContentType) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; step 1&lt;/span&gt;
    object_id = models.PositiveIntegerField() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; step 2&lt;/span&gt;
    content_object = GenericForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; step 3&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话不管表的数据都可以查询出来，而且添加新的商品的商品，也不需要动优惠券的源码。&lt;/p&gt;
&lt;p&gt;但我们在查询的过程中，用ORM实在太繁琐了，所以还有一个反向查询的方法：&lt;/p&gt;
&lt;p&gt;就是在每个商品中关联 绑定一个关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
coupons = GenericRelation(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Coupon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于反向查询，不会生成表字段&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以直接ORM的.coupons找相应的字段！&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 15:11:00 +0000</pubDate>
<dc:creator>天王盖地虎宝塔镇河妖</dc:creator>
<og:description>一、什么是Django ContentTypes？ Django ContentTypes是由Django框架提供的一个核心功能，它对当前项目中所有基于Django驱动的model提供了更高层次的抽象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/9463796.html</dc:identifier>
</item>
<item>
<title>python3中的真值测试 - 翻书</title>
<link>http://www.cnblogs.com/sword03/p/9465296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sword03/p/9465296.html</guid>
<description>&lt;h2 id=&quot;真值测试&quot;&gt;1. 真值测试&lt;/h2&gt;
&lt;p&gt;所谓真值测试，是指当一种类型对象出现在if或者while条件语句中时，对象值表现为True或者False。弄清楚各种情况下的真值对我们编写程序有重要的意义。&lt;/p&gt;
&lt;p&gt;对于一个对象a，其真值定义为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;True ： 如果函数truth_test(a)返回True。&lt;/li&gt;
&lt;li&gt;False：如果函数truth_test(a)返回False。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以if为例（while是等价的，不做赘述），定义函数truth_test(x)为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def truth_test(x):
    if x:
        return True
    else:
        return False&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象的真值测试&quot;&gt;2.对象的真值测试&lt;/h2&gt;
&lt;p&gt;一般而言，对于一个对象，在满足以下条件之一时，真值测试为False；否则真值测试为True。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其内置函数__bool__()返回False&lt;/li&gt;
&lt;li&gt;其内置函数__len__()返回0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）以下类型对象真值测试为真：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class X:
     pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）以下真值测试为假：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Y:
     def __bool__(self):
         return False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）以下真值测试为假：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Z:
     def __len__(self):
         return 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入python3脚本环境，测试过程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class X:
...      pass
... 
&amp;gt;&amp;gt;&amp;gt; class Y:
...      def __bool__(self):
...          return False
... 
&amp;gt;&amp;gt;&amp;gt; class Z:
...      def __len__(self):
...          return 0
... 
&amp;gt;&amp;gt;&amp;gt; def truth_test(x):
...     if x:
...         return True
...     else:
...         return False
... 
&amp;gt;&amp;gt;&amp;gt; x = X()
&amp;gt;&amp;gt;&amp;gt; y = Y()
&amp;gt;&amp;gt;&amp;gt; z = Z()
&amp;gt;&amp;gt;&amp;gt; truth_test(x)
True
&amp;gt;&amp;gt;&amp;gt; truth_test(y)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(z)
False
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常见对象的真值&quot;&gt;3. 常见对象的真值&lt;/h2&gt;
&lt;p&gt;下面是常见的真值为False的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常量：None and False.&lt;/li&gt;
&lt;li&gt;数值0值: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)&lt;/li&gt;
&lt;li&gt;序列或者集合为空：'', (), [], {}, set(), range(0)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进入python3脚本环境，测试过程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; truth_test(None)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(False)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(0)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(0.0)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(0j)   #复数
False
&amp;gt;&amp;gt;&amp;gt; truth_test(Decimal(0))  #十进制浮点数
False
&amp;gt;&amp;gt;&amp;gt; truth_test(Fraction(0,1))  #分数
False
&amp;gt;&amp;gt;&amp;gt; truth_test(Fraction(0,2)) #分数
False
&amp;gt;&amp;gt;&amp;gt; truth_test('')
False
&amp;gt;&amp;gt;&amp;gt; truth_test(())
False
&amp;gt;&amp;gt;&amp;gt; truth_test({})
False
&amp;gt;&amp;gt;&amp;gt; truth_test(set())
False
&amp;gt;&amp;gt;&amp;gt; truth_test(range(0))  #序列
False
&amp;gt;&amp;gt;&amp;gt; truth_test(range(2,2)) #序列
False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外的其它取值，真值测试应当为True。&lt;/p&gt;
&lt;h2 id=&quot;一些有意思的例子&quot;&gt;4.一些有意思的例子&lt;/h2&gt;
&lt;p&gt;下面是一些有意思的例子，原理不超出前面的解释。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; if 1 and Fraction(0,1):
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1 and ():
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1 and range(0):
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1 and None:
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1+2j and None:
...     print(True)
... else:
...     print(False)
... 
False
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引用&quot;&gt;5.引用&lt;/h2&gt;
</description>
<pubDate>Sun, 12 Aug 2018 14:32:00 +0000</pubDate>
<dc:creator>翻书</dc:creator>
<og:description>1. 真值测试 所谓真值测试，是指当一种类型对象出现在if或者while条件语句中时，对象值表现为True或者False。弄清楚各种情况下的真值对我们编写程序有重要的意义。 对于一个对象a，其真值定义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sword03/p/9465296.html</dc:identifier>
</item>
<item>
<title>《ServerSuperIO Designer IDE使用教程》-2.与硬件网关数据交互，并进行数据级联转发，直到云端。发布：v4.2.1版本 - 唯笑志在</title>
<link>http://www.cnblogs.com/lsjwq/p/9465050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/9465050.html</guid>
<description>&lt;blockquote readability=&quot;9.6511627906977&quot;&gt;
&lt;p class=&quot;a&quot;&gt;&lt;strong&gt;&lt;span&gt;v4.2.1 更新内容：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;1.重新定义数据转发文本协议，使网关与ServerSuperIO以及之间能够相关交互数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.扩展ServerSuperIO动态数据类的方法，更灵活。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.修复Designer增加转发任务的一个BUG。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.修改数据转发客户端和服务端。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.增加硬件网关驱动。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;&lt;span&gt;&lt;strong&gt;v4.2.1 下载地址：&lt;a href=&quot;http://www.bmpj.net/article-12-1.html&quot; target=&quot;_blank&quot;&gt;官方下载&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p class=&quot;a&quot;&gt; &lt;span&gt;目       录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 与硬件网关数据交互，以及进行数据转发... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1           概述... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2           演示的框架结构... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3           Modbus Slave模拟传感器数据... 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4           硬件网关SuperLink采集和转发数据... 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.5           ServerSuperIO Designer采集数据... 5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.6           ServerSuperIO Designer转发数据... 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.7           实现的全景效果... 8&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.1    概述&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       工业现场（物联网）使用硬件网关（SuperLink）的场景比较广泛，主要考虑多区域场景和网络条件限制情况下的应用和部署，具体根据现场的应用场景。网关两大基本职能：数据采集和数据转发，在项目体系建设中起到承上启下的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       ServerSuperIO现在集成了硬件网关（SuperLink）,完成了在项目建设过程中任何节点的数据采集与转发，并且形成级连部署。可以方便的与工业互联网平台或工业大数据平台对接；或者承建自己的云端平台，整合行业资源，形成以公司产品为主的生态建设。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.2    演示的框架结构&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      演示大体包括3部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （1）传感器层，使用Modbus Slave进行模拟，相然可以是任何PLC、传感器等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （2）硬件网关（SuperLink）实时采集传感器层的数据信息，并且进行数据转发、汇聚；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （3）ServerSuperIO实时接收网关层的数据信息，相当于数据交互中心，ServerSuperIO同样具备转发能力，可以进一步转发给上一层数据中心的ServerSuperIO，形成级连数据传递。结构如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212650511-1103790907.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.3    Modbus Slave模拟传感器数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;        为了方便起见，现在模拟2个数据点，相当可以更多。操作过程不具体介绍，请参见《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/9225566.html&quot;&gt;标准Modbus和非标准协议的使用、测试以及驱动开发&lt;/a&gt;》。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212712956-938454766.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.4    硬件网关SuperLink采集和转发数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       网关支持100多种协议，包括国际标准协议和国内行业标准协议，涉及到：电力、煤矿、钢铁、智能楼宇、环保等。硬件外观如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212737103-1712575234.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          网关通过C/S结构的软件进行配置，方便、易用。数据采集配置可以单点配置和批量导入。采集Modbus Slave数据的配置，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212845438-1230366822.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          网关采集上来的数据，可以实时通过有线网络或3G/4G进行数据转发，具体配置信息和自定义转发的数据点，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212907035-633000541.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212956946-2023143424.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.5    ServerSuperIO Designer采集数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       Designer是在ServerSuperIO的基础上开发的，是一个配置和调试环境，正式生产环境的运行可以使用Host控制台程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      增加运行的服务实例，相当于运行设备驱动的容器，因为网关是按统一标准协议主动上传数据。在配置参数的时候选择DeviceCode数据分发模式，与网关配置的“站点编号”相对应；另外选择Self（自控模式）控制模式，在代码二次开发层面可以选择主动发送请求数据或被动接收数据，没有实现主动发送请求数据，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213016382-950105141.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;          增加设备驱动的时候，“设备编码”对应的是“站点编号”，选择NET通讯类型，选择SuperLink网关通讯驱动，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213039327-572807952.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          数据采集之后，通过设备驱动保存到mysql数据库中，实际运行效果，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213056720-987090282.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.6    ServerSuperIO Designer转发数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       ServerSuperIO同样支持客户端和服务端模式的数据转发功能，支持SuperLink与ServerSuperIO之间数据传递的协议，也就是ServerSuperIO与ServerSuperIO之间可以无限级的对接数据，在项目建设中进行灵活部署。数据转发配置，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213144153-1415667886.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.7    实现的全景效果&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;        按演示的框架结构最终实现的效果，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213218331-278213837.png&quot; alt=&quot;&quot; width=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;v4.2.1 下载地址：&lt;a href=&quot;http://www.bmpj.net/article-12-1.html&quot; target=&quot;_blank&quot;&gt;官方下载&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1.&lt;a id=&quot;post_title_link_4978884&quot; href=&quot;http://www.cnblogs.com/lsjwq/p/4978884.html&quot;&gt;[连载]《C#通讯（串口和网络）框架的设计与实现》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.[&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5316577.html&quot; target=&quot;_blank&quot;&gt;开源]C#跨平台物联网通讯框架ServerSuperIO（SSIO）介绍&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5359907.html&quot; target=&quot;_blank&quot;&gt;应用SuperIO（SIO）和开源跨平台物联网框架ServerSuperIO（SSIO）构建系统的整体方案&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5122612.html&quot;&gt;C#工业物联网和集成系统解决方案的技术路线（数据源、数据采集、数据上传与接收、ActiveMQ、Mongodb、WebApi、手机App）&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5.github地址：&lt;a href=&quot;https://github.com/wxzz/ServerSuperIO&quot; target=&quot;_blank&quot;&gt;https://github.com/wxzz/ServerSuperIO&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/8531046.html&quot; target=&quot;_blank&quot;&gt;6.助力中小企业级连云端，促进工业互联网平台蓬勃发展，全套解决方案。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物联网&amp;amp;集成技术 QQ群：&lt;span&gt;54256083 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 13:36:00 +0000</pubDate>
<dc:creator>唯笑志在</dc:creator>
<og:description>v4.2.1 更新内容：1.重新定义数据转发文本协议，使网关与ServerSuperIO以及之间能够相关交互数据。2.扩展ServerSuperIO动态数据类的方法，更灵活。3.修复Designer增</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsjwq/p/9465050.html</dc:identifier>
</item>
<item>
<title>java泛型理解。代码更明了。 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/9465040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/9465040.html</guid>
<description>&lt;p&gt;泛型数据java基础，但真正理解需要悉心品尝。毕竟在工作中用到的是在是太多了。&lt;/p&gt;
&lt;p&gt;不要以为new ArrayList&amp;lt;&amp;gt;这就是泛型，这只能属于会使用。&lt;/p&gt;
&lt;p&gt;在工作中，相对于现有的项目源码的数据库操作层，无论是mybatis，hibernate或者是自己封装的baseModel层，都会使用到泛型。&lt;/p&gt;
&lt;p&gt;以及&lt;span&gt;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T&amp;gt;&lt;/span&gt;这个屌东西。&lt;/p&gt;
&lt;p&gt;泛型使用情况分为三类&lt;/p&gt;
&lt;p&gt;　　1. 泛型类。 &lt;br/&gt;　　2. 泛型方法。 &lt;br/&gt;　　3. 泛型接口。&lt;/p&gt;
&lt;p&gt;出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如： &lt;br/&gt;　　1. &lt;span&gt;T 代表一般的任何类&lt;/span&gt;。 &lt;br/&gt;　　2. E 代表 Element 的意思，或者 Exception 异常的意思。 &lt;br/&gt;　　3. K 代表 Key 的意思。 &lt;br/&gt;　　4. V 代表 Value 的意思，通常与 K 一起配合使用。 &lt;br/&gt;　　5. S 代表 Subtype 的意思，文章后面部分会讲解示意。&lt;/p&gt;
&lt;p&gt;最直接的一段代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
List&amp;lt;String&amp;gt; l1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; l2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        System.out.println(l1.getClass() &lt;/span&gt;== l2.getClass());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 打印的判断为TRUE，因为&lt;span&gt;&lt;span&gt;泛型信息被擦除&lt;/span&gt;了&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;泛型擦除实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
List&amp;lt;String&amp;gt; listErasure = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接初始化，这也是一种方式。直接传入一个collection。&lt;/span&gt;
            {add(&quot;aaa&quot;);add(&quot;bbb&quot;&lt;span&gt;);}
        };
        listErasure.add(&lt;/span&gt;&quot;ccc&quot;&lt;span&gt;);
        Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; List&amp;gt; class1 =&lt;span&gt; listErasure.getClass();
        Method method &lt;/span&gt;= class1.getMethod(&quot;add&quot;,Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        method.invoke(listErasure, &lt;/span&gt;123&lt;span&gt;);
        System.out.println(listErasure)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果　　[aaa, bbb, ccc, 123]&lt;/p&gt;
&lt;p&gt;明明是接收String类型，但是却可以通过反射对其进行Integer类型的操作。 &lt;/p&gt;
&lt;p&gt;可见&lt;span&gt;泛型只是在编译期间有效&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 代表着类型未知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T&amp;gt;这个东西经常见到，但是并没有字面意义那么简单。&lt;/p&gt;
&lt;p&gt;通配符有 3 种形式。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 被称作无限定的通配符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; 被称作有上限的通配符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; 被称作有下限的通配符。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; B &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C &lt;span&gt;extends&lt;/span&gt; B{}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt; listExtends = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new A()); 全部编译错误。因为使用的是extends，丧失了写的操作能力。跟f3方法一样，是未知类型，只是确定了里面对象的范围。是B的子类。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new C());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 能进行对B以及B的子类操作。这是super的神奇之处。&lt;/span&gt;
        List&amp;lt;? &lt;span&gt;super&lt;/span&gt; B&amp;gt; listSuper = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listSuper.add(new A());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会编译错误。&lt;/span&gt;
        listSuper.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B());
        listSuper.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; C());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及方法泛型的返回&lt;/p&gt;
&lt;p&gt;泛型作为参数的传递。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;TTT&amp;gt;&lt;span&gt;TTT f1(TTT t) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传递指定的A类型，对应的list可以进行对应的list应有的方法。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f2(List&amp;lt;A&amp;gt;&lt;span&gt; list) {
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; A());
        System.out.println(list.size());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f3(List&amp;lt;?&amp;gt;&lt;span&gt; list) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        list.add(new A()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当传入的是?通配符的话表示只能进行跟?无关的操作，类似于size方法，增加代码的可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(list.size());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f4(List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt;&lt;span&gt; listExtends) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能进行写做操，因为是?,增加了可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(listExtends.size());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;借鉴文章：&lt;a href=&quot;https://blog.csdn.net/briblue/article/details/76736356&quot; target=&quot;_blank&quot;&gt;泛型，一个孤独的守门者。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试代码，很全面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.javaSE.fanxing;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationTargetException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; B &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; B{}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Demo&amp;lt;T,TT&amp;gt;&lt;span&gt; {
    T value; 
    TT value2;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TT getValue2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value2;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue2(TT value2) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value2 =&lt;span&gt; value2;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(T value) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;TTT&amp;gt;&lt;span&gt;TTT f1(TTT t) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传递指定的A类型，对应的list可以进行对应的list应有的方法。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f2(List&amp;lt;A&amp;gt;&lt;span&gt; list) {
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; A());
        System.out.println(list.size());
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f3(List&amp;lt;?&amp;gt;&lt;span&gt; list) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        list.add(new A()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当传入的是?通配符的话表示只能进行跟?无关的操作，类似于size方法，增加代码的可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(list.size());
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f4(List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt;&lt;span&gt; listExtends) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能进行写做操，因为是?,增加了可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(listExtends.size());
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印的判断为TRUE，因为泛型信息被擦除了。&lt;/span&gt;
        List&amp;lt;String&amp;gt; l1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; l2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        System.out.println(l1.getClass() &lt;/span&gt;==&lt;span&gt; l2.getClass());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 泛型擦除实例。&lt;/span&gt;
        List&amp;lt;String&amp;gt; listErasure = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接初始化，这也是一种方式。直接传入一个collection。&lt;/span&gt;
            {add(&quot;aaa&quot;);add(&quot;bbb&quot;&lt;span&gt;);}
        };
        listErasure.add(&lt;/span&gt;&quot;ccc&quot;&lt;span&gt;);
        Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; List&amp;gt; class1 =&lt;span&gt; listErasure.getClass();
        Method method &lt;/span&gt;= class1.getMethod(&quot;add&quot;,Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        method.invoke(listErasure, &lt;/span&gt;123&lt;span&gt;);
        System.out.println(listErasure);&lt;p&gt;Demo&lt;/p&gt;&lt;/span&gt;&amp;lt;String,Integer&amp;gt; demo = &lt;span&gt;new&lt;/span&gt; Demo&amp;lt;String,Integer&amp;gt;&lt;span&gt;();
        demo.setValue(&lt;/span&gt;&quot;string&quot;&lt;span&gt;);
        System.out.println(demo.getValue());
        
        
        Demo&lt;/span&gt;&amp;lt;Integer,String&amp;gt; demo2 = &lt;span&gt;new&lt;/span&gt; Demo&amp;lt;Integer,String&amp;gt;&lt;span&gt;();
        demo2.setValue(&lt;/span&gt;100&lt;span&gt;);
        System.out.println(demo2.getValue());
        
        
        System.out.println(f1(&lt;/span&gt;123&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        List&amp;lt;A&amp;gt; listA = new ArrayList&amp;lt;A&amp;gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        List&amp;lt;B&amp;gt; listB = listA;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new ArrayList&amp;lt;B&amp;gt;();虽然B是A的子类，并不代表泛型之间也具备继承关系。&lt;/span&gt;
&lt;span&gt;        
        
        ArrayList&lt;/span&gt;&amp;lt;A&amp;gt; listA = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;A&amp;gt;&lt;span&gt;();
        listA.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; A());
        f3(listA); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不对f3方法进行任何操作，是1.&lt;/span&gt;
        f2(listA); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2对应的方法实现还进行了一次插入操作。&lt;/span&gt;
        f3(listA); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; static ，对应的listA的集合数量是引用值。&lt;/span&gt;
&lt;span&gt;        
        
        ArrayList&lt;/span&gt;&amp;lt;B&amp;gt; listB = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
        listB.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B()); 
        f3(listB); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; f3方法传递的是通配符?，不能进行add操作。
        
         
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T&amp;gt;&lt;/span&gt;
        List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt; listExtends = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new A()); 全部编译错误。因为使用的是extends，丧失了写的操作能力。跟f3方法一样，是未知类型，只是确定了里面对象的范围。是B的子类。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new C());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 能进行对B以及B的子类操作。这是super的神奇之处。&lt;/span&gt;
        List&amp;lt;? &lt;span&gt;super&lt;/span&gt; B&amp;gt; listSuper = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listSuper.add(new A());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会编译错误。&lt;/span&gt;
        listSuper.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B());
        listSuper.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; C());
        
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没毛病。&lt;/span&gt;
        List&amp;lt;B&amp;gt; listBS = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;(); 
        listBS.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B());
        f4(listBS);   
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 12 Aug 2018 13:34:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<og:description>泛型数据java基础，但真正理解需要悉心品尝。毕竟在工作中用到的是在是太多了。 不要以为new ArrayList&lt;&gt;这就是泛型，这只能属于会使用。 在工作中，相对于现有的项目源码的数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/9465040.html</dc:identifier>
</item>
<item>
<title>Angular6封装http请求 - _marven</title>
<link>http://www.cnblogs.com/zhouyangla/p/9465008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouyangla/p/9465008.html</guid>
<description>&lt;p&gt;最近抽空学习了一下Angular6，之前主要使用的是vue，所以免不了的也想对Angular6提供的工具进行一些封装，今天主要就跟大家讲一下这个http模块。&lt;br/&gt;之前使用的ajax库是axios，可以设置baseurl，公共头部；集中捕捉错误等，由于Angular6的依赖注入机制，是不能通过直接修改http模块暴露的变量来封装的，但是通过官方文档我们知道可以通过拦截器（HttpInterceptor）来实现这一功能。&lt;/p&gt;
&lt;p&gt;拦截器可以拦截请求，也可以拦截响应，那么通过拦截请求就可以实现 设置baseurl，公共头部；而通过拦截响应就可以实现 集中捕获错误 。废话不多说，上代码吧。&lt;/p&gt;
&lt;h3 id=&quot;第一步准备工作导入-httpclientmodule&quot;&gt;第一步：准备工作，导入 HttpClientModule&lt;/h3&gt;
&lt;p&gt;在app.module.ts中导入 HttpClientModule，然后在imports数组中将 HttpClientModule 加入到 BrowserModule 之后，具体代码为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [
    BrowserModule,
    // import HttpClientModule after BrowserModule.
    HttpClientModule,
  ],
  declarations: [
    AppComponent,
  ],
  bootstrap: [ AppComponent ]
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步新建有关拦截器的文件&quot;&gt;第二步：新建有关拦截器的文件&lt;/h3&gt;
&lt;p&gt;在app文件夹下新建http-interceptors文件夹，在其内新建base-interceptor.ts，index.ts两个文件。其中，base-interceptor.ts是用于设置拦截器的注入器文件，index.ts则为扩展拦截器的提供商。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;### base-interceptor.ts

import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest,
  HttpErrorResponse
} from '@angular/common/http';
import { throwError } from 'rxjs'
import { catchError, retry } from 'rxjs/operators';

/*设置请求的基地址，方便替换*/
const baseurl = 'http://localhost:8360';

@Injectable()
export class BaseInterceptor implements HttpInterceptor {

  constructor() {}

  intercept(req, next: HttpHandler) {

    let newReq = req.clone({
      url: req.hadBaseurl ? `${req.url}` : `${baseurl}${req.url}`,
    });
    /*此处设置额外的头部，token常用于登陆令牌*/
    if(!req.cancelToken) {
      /*token数据来源自己设置，我常用localStorage存取相关数据*/
      newReq.headers =
      newReq.headers.set('token', 'my-new-auth-token')
    }

    // send cloned request with header to the next handler.
    return next.handle(newReq)
      .pipe(
        /*失败时重试2次，可自由设置*/
        retry(2),
        /*捕获响应错误，可根据需要自行改写，我偷懒了，直接用的官方的*/
        catchError(this.handleError)
      )
  }
  
  private handleError(error: HttpErrorResponse) {
    if (error.error instanceof ErrorEvent) {
      // A client-side or network error occurred. Handle it accordingly.
      console.error('An error occurred:', error.error.message);
    } else {
      // The backend returned an unsuccessful response code.
      // The response body may contain clues as to what went wrong,
      console.error(
        `Backend returned code ${error.status}, ` +
        `body was: ${error.error}`);
    }
    // return an observable with a user-facing error message
    return throwError(
      'Something bad happened; please try again later.');
  };
}


### index.ts

import { HTTP_INTERCEPTORS } from '@angular/common/http';

import { BaseInterceptor } from './base-interceptor';

/** Http interceptor providers in outside-in order */
export const httpInterceptorProviders = [
  { provide: HTTP_INTERCEPTORS, useClass: BaseInterceptor, multi: true },

];

/*
Copyright 2017-2018 Google Inc. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过克隆修改 req 对象即可拦截请求，而操作 &lt;strong&gt;next.handle(newReq)&lt;/strong&gt;的结果即可拦截响应。如果需要修改，可直接扩展 base-interceptor.ts或 参考 base-interceptor.ts 文件新建其他文件，然后在 index.ts 中正确引入该拦截器，并将其添加到 httpInterceptorProviders 数组中即可。&lt;/p&gt;
&lt;h3 id=&quot;第三步注册提供商&quot;&gt;第三步：注册提供商&lt;/h3&gt;
&lt;p&gt;在app.module.ts中加入以下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { httpInterceptorProviders } from './http-interceptors/index'

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [
    httpInterceptorProviders
  ],
  bootstrap: [AppComponent]
})

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第四步提取baseurl&quot;&gt;第四步，提取baseurl&lt;/h3&gt;
&lt;p&gt;为了方便后台修改baseurl，我们可以将baseurl提取为全局变量，在index.html中进行设置，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# index.html 增加
&amp;lt;script&amp;gt;
  window.baseurl = &quot;http://localhost:8360&quot;
&amp;lt;/script&amp;gt;

# base-interceptor.ts 修改
const baseurl = window.baseurl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来，如果后台要修改的话，只需修改index.html中的变量即可，无需再次编译。还有，像这些后期可能更改的变量，建议是直接放在index.html中，因为缓存的原因，如果放在js文件中再引入的话，文件并不能及时更新或是每次都需要更改文件名，会导致不必要的麻烦。&lt;/p&gt;
&lt;p&gt;至此，Angular6的http模块封装已经基本完成，如果有需要可以自行扩展，可参考第二步。如果看完以后不明白或者我有写的不对的地方，欢迎大家在下方进行评论。&lt;/p&gt;
&lt;p&gt;文章参考：&lt;a href=&quot;https://juejin.im/post/5b59c89de51d45190a4336d8#comment&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5b59c89de51d45190a4336d8#comment&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 13:29:00 +0000</pubDate>
<dc:creator>_marven</dc:creator>
<og:description>最近抽空学习了一下Angular6，之前主要使用的是vue，所以免不了的也想对Angular6提供的工具进行一些封装，今天主要就跟大家讲一下这个http模块。 之前使用的ajax库是axios，可以设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouyangla/p/9465008.html</dc:identifier>
</item>
<item>
<title>mysql及python交互 - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/9464988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/9464988.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;mysql在之前写过一次，那时是我刚刚进入博客，今天介绍一下mysql的python交互，当然前面会把mysql基本概述一下。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:as3;gutter:false;&quot;&gt;
&lt;span&gt;　　&lt;span&gt;目录：&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;一、命令脚本（mysql）
    1、基本命令
    2、数据库操作命令
    3、表操作命令
    4、数据操作命令
    5、查
    6、关联
二、python交互
    1、数据库连接
    2、创建数据库表
    3、插入数据
    4、更新数据库
    5、删除数据
    6、数据库查询
三、mysql封装（方便使用）
    1、python封装的my_sql类
    2、案例（调用my_sql类）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;1、基本命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）启动服务&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以管理员身份运行cmd&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;net start 服务名称&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（2）停止服务&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以管理员身份运行cmd&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;net stop 服务名称&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（3）连接数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;格式：mysql - u root - p -&amp;gt;输入密码&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（4）退出登录（断开连接）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;exit或quit&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（5）查看版本（连接后可以执行）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;select version()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（6）显示当前时间（连接后可以执行）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;select now()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（7）远程连接&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;mysql - h ip地址 - u 用户名 - p ---&amp;gt;输入对方mysql密码&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2、数据库操作命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）创建数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;create database 数据库名 charset = utf8&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（2）删除数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;drop database 数据库名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（3）切换数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;use 数据库名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（4）查看当前选择的数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;select database()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3、表操作命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）查看数据库中所有表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;show tables&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（2）创建表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;create table 表名（列及类型）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　eg：create table student(id int auto_increment primary key,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　　　　name varchar(20) not null)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　注：auto_increment 自增长      primary key 主键     not null 非空&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（3）删除表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;drop table 表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（4）查看表结构&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;desc 表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（5）查看建表语句&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;show create table 表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（6）重命名表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;rename table 原表名 to 新表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（7）修改表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;alter table 表名 add | change | drop 列名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4、数据操作命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）增&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　a、全列插入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into 表名 values(...)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　eg:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into student values(0, &quot;tom&quot;, &quot;北京&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　主键列是自动增长，但是在全列插入时需要占位，通常使用0，插入成功以后以实际数据为准&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、缺省插入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into 表名(列1，列2..) values(值1，值2..)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、同时插入多条数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into 表名 values(...), (...), ...&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　&lt;span&gt;（2）删&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　delete from 表名 where 条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　不写条件则全删&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　&lt;span&gt;（3）改&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　update 表名 set 列1 = 值1, 列2 = 值2, ... where 条件&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（4）查&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　查询表中的全部数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　select * from 表名&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5、查&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）基本语法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　select * from 表名&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;from关键字后面是表名，表示数据来源于这张表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;select后面写表中的列名，如果是 * 表示在结果集中显示表中额所有列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在select后面的列名部分，可以使用as为列名起别名，这个别名显示在结果集中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果要查询多个列，之间使用逗号分隔&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　# eg：select name as a,age from student;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（2）消除重复行&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　在select后面列前面使用distinct可以消除重复的行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　eg：select distinct gender from student&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（3）条件查询&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　a、语法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　select * from 表名 where 条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、比较运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　等于（=） 大于（&amp;gt;） 小于（&amp;lt;） 大于等于（&amp;gt;=） 小于等于（&amp;lt;=） 不等于（!= 或 &amp;lt;&amp;gt;）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、逻辑运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　and or not&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d、模糊查询&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　like&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　% 表示任意多个任意字符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　_ 表示一个任意字符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　e、范围查询&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　in 表示在一个非连续的范围内&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　between。。。and。。。 表示在一个连续的范围内&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　eg：where id in (8, 10, 13)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　f、空判断&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　注意：null与&quot;&quot;是不同的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　判断空：is null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　判断非空：is not null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　g、优先级&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　小括号，not，比较运算符，逻辑运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　and比or优先级高，同时出现并希望先选or，需要结合括号来使用&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（4）聚合&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　为了快速得到统计数，提供了5个聚合函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a、count(*) 表示计算总行数，括号中可以写 * 或列名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、max(列) 表示求此列的最大值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、min(列) 表示求此列的最小值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d、sum(列) 表示求此列的和&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　e、avg(列) 表示求此列的平均值&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（5）分组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　按照字段分组，表示此字段相同的数据会被放到一个集合中。&lt;/span&gt;&lt;span&gt;分组后，只能查询出相同的数据列，对于有差异的数据列无法显示在结果集中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　可以对分组后的数据进行统计，做聚合运算&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　select 列1, 列2, 聚合... from 表名 group by 列1, 列2 having 列1, 列2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　eg:  &lt;/span&gt;&lt;span&gt;查询男女生总数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　select gender, count(*) from student group by gender&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　where与having的区别：where是对from后面指定的表进行筛选，属于对原始数据的筛选；having是对group by的结果进行筛选。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（6）排序&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　select * from 表名 order by 列1 asc | desc, 列2 asc | desc, ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a、将数据按照列1进行排序，如果某些列1的值相同则按照列2排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、默认按照从小到大的顺序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、asc升序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d、desc降序&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（7）分页&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　select * from 表名 limit start, count&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　从start开始，看count条&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6、关联&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;建表语句&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　（1）create table class(id int auto_increment primary key, name varchar(20) not null, stuNum int not null)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（2）create table students(id int auto_increment primary key, name varchar(20) not null, gender bit default 1, classid int not bull, foreign key(classid) references class(id))&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;插入一些数据：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　（1）insert into class values(0, &quot;python1&quot;, 50), (0, &quot;python2&quot;, 60), (0, &quot;python3&quot;, 70)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）insert into students values(0, &quot;tom&quot;, 1, 1)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;关联查询：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　（1）select students.name, class.name from class inner join students on class.id = students.classid&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（1）表A inner join 表B&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　表A与表B匹配的行会出现在结果集中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（2）表A left join 表B&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　表A与表B匹配的行会出现在结果集中，外加表A中独有的数据，未对应的数据使用null填充&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（3）表A right join 表B&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　表A与表B匹配的行会出现在结果集中，外加表B中独有的数据，未对应的数据使用null填充&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1、连接数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接数据库&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数一：mysql服务所在主机的IP&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数二：用户名&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数三：密码&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数四：要连接的数据库名&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; db = pymysql.connect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个cursor对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; cursor =&lt;span&gt; db.cursor()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; -----------------------------------------------------------------------------------------
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 要执行的sql语句&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select version()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行sql语句&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取返回的信息&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; data =&lt;span&gt; cursor.fetchone()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; ----------------------------------------------------------------------------------------
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断开&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;cursor.close()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; db.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这里我选择的是pymysql，其实这个和MySQLdb相差无几，命令也很像。连接时，主机IP如果是在本机，直接使用localhost即可，也可以写IP地址，这样可以实现远程的连接。虚线中间部分是要进行不同操作时需要更改的部分。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2、创建数据库表&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;上面给出了连接数据库的代码，其实后面的操作就简单多了，外部框架不变，只需要改内部的sql语句，以及个别的一些操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查表是否存在，如果有则删除&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; cursor.execute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;drop table if exists bancard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 建表&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create table bandcard(id int auto_increment primary key, money int not null)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; cursor.execute(sql)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、插入数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert into bandcard values(0, 300)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     db.commit() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行这条语句才插入&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、更新数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update bandcard set money=1000 where id=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    db.commit()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;可以看到，后面的操作基本上以及回归mysql本身，大家记住这样一个流程就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5、删除数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete from bandcard where money=200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    db.commit()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     db.rollback()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6、数据库查询操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;fetchone()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　功能：获取下一个查询结果集，结果集是一个对象&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;fetchall()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　功能：接收全部的返回的行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　是一个只读属性，返回execute()方法影响的行数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from bandcard where money&amp;gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回查询结果&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     reslist =&lt;span&gt; cursor.fetchall()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reslist:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d--%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (row[0], row[1&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; my_sql():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, host, user, passwd, dbName):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.host =&lt;span&gt; host
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.user =&lt;span&gt; user
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.passwd =&lt;span&gt; passwd
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.dbName =&lt;span&gt; dbName
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.db =&lt;span&gt; pymysql.connect(
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            self.host, self.user, self.passwd, self.dbName)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         self.cursor =&lt;span&gt; self.db.cursor()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        self.cursor.close()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        self.db.close()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_one(self, sql):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         res =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            self.connect()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            self.cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             res =&lt;span&gt; self.cursor.fetchone()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            self.close()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_all(self, sql):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         res =&lt;span&gt; ()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            self.connect()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            self.cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             res =&lt;span&gt; self.cursor.fetchall()
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            self.close()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; insert(self, sql):
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; update(self, sql):
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delete(self, sql):
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(self, sql):
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            self.connect()
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             count =&lt;span&gt; self.cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            self.db.commit()
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            self.close()
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;事务提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             self.db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上面的类中封装了用python封装了对mysql的连接，增，删，改，查等功能，在今后使用的时候，完全可以直接调用其中的方法，避免重复造轮子嘛。下面给一个使用的案例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; my_sql &lt;span&gt;import&lt;/span&gt;&lt;span&gt; my_sql
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个是连接mysql的参数，前面有解释到，使用时候连接上自己的数据库就好&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; s = my_sql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx.xxx.xx.x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; res = s.get_all(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from bandcard where money&amp;gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; res:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d--%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (row[0], row[1]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;当然在你使用的时候要写完整调用的类的路径，我这里是在同一个目录下写的。新建一个自己的文件，引入my_sql中的my_sql类，然后就可以使用了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 Aug 2018 13:25:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<og:description>mysql在之前写过一次，那时是我刚刚进入博客，今天介绍一下mysql的python交互，当然前面会把mysql基本概述一下。 一、命令脚本 1、基本命令 （1）启动服务 以管理员身份运行cmd ne</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/9464988.html</dc:identifier>
</item>
<item>
<title>Java并发编程-看懂AQS的前世今生 - lingjiango</title>
<link>http://www.cnblogs.com/iou123lg/p/9464385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iou123lg/p/9464385.html</guid>
<description>&lt;p&gt;　　在具备了&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9280639.html&quot; target=&quot;_blank&quot;&gt;volatile&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9314826.html&quot; target=&quot;_blank&quot;&gt;CAS&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9350108.html&quot; target=&quot;_blank&quot;&gt;模板方法设计模式&lt;/a&gt;的知识之后，我们可以来深入学习下AbstractQueuedSynchronizer（AQS），本文主要想从AQS的产生背景、设计和结构、源代码实现及AQS应用这4个方面来学习下AQS，文章耗时一个月，所以篇幅有点长，需要一点耐心。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、AQS产生背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过JCP的JSR166规范，Jdk1.5开始引入了j.u.c包，这个包提供了一系列支持并发的组件。这些组件是一系列的同步器，这些同步器主要维护着以下几个功能：内部同步状态的管理(例如表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。可以看下&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9280639.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;的4.2的图便能理解j.u.c包的组件构成。&lt;/p&gt;
&lt;p&gt;　　几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性、开销及不灵活使j.u.c最多只能是一个二流工程，且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。因此，JSR166基于AQS类建立了一个小框架，这个框架为构造同步器提供一种通用的机制，并且被j.u.c包中大部分类使用，同时很多用户也可以用它来定义自己的同步器。这个就是j.u.c的作者Doug Lea大神的初衷，通过提供AQS这个基础组件来构建j.u.c的各种工具类，至此就可以理解AQS的产生背景了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2&lt;/strong&gt;&lt;strong&gt;、AQS的设计和结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1&lt;/strong&gt; &lt;strong&gt;设计思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　同步器的核心方法是acquire和release操作，其背后的思想也比较简洁明确。acquire操作是这样的：&lt;/p&gt;
&lt;p&gt;　　while (&lt;strong&gt;当前同步器的状态&lt;/strong&gt;不允许获取操作) {&lt;/p&gt;
&lt;p&gt;        　　如果当前&lt;strong&gt;线程&lt;/strong&gt;不在&lt;strong&gt;队列&lt;/strong&gt;中，则将其插入队列&lt;/p&gt;
&lt;p&gt;        　　&lt;strong&gt;阻塞&lt;/strong&gt;当前线程&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　如果线程位于队列中，则将其移出队列&lt;/p&gt;

&lt;p&gt;　　release操作是这样的：&lt;/p&gt;
&lt;p&gt;　　更新&lt;strong&gt;同步器的状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　if (新的状态允许某个被阻塞的线程获取成功)&lt;/p&gt;
&lt;p&gt;         　　&lt;strong&gt;解除队列&lt;/strong&gt;中一个或多个&lt;strong&gt;线程&lt;/strong&gt;的&lt;strong&gt;阻塞&lt;/strong&gt;状态&lt;/p&gt;
&lt;p&gt;　　从这两个操作中的思想中我们可以提取出三大关键操作：&lt;strong&gt;同步器的状态变更、线程阻塞和释放、插入和移出队列&lt;/strong&gt;。所以为了实现这两个操作，需要协调三大关键操作引申出来的三个基本组件：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;·同步器状态的原子性管理；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　·线程阻塞与解除阻塞；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　·队列的管理；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由这三个基本组件，我们来看j.u.c是怎么设计的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.1&lt;/strong&gt; &lt;strong&gt;同步状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AQS类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSet操作来读取和更新这个同步状态。其中属性state被声明为volatile，并且通过使用CAS指令来实现compareAndSetState，使得当且仅当同步状态拥有一个一致的期望值的时候，才会被原子地设置成新值，这样就达到了同步状态的原子性管理，确保了同步状态的原子性、可见性和有序性。&lt;/p&gt;
&lt;p&gt; 　　基于AQS的具体实现类（如锁、信号量等）必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.2&lt;/strong&gt; &lt;strong&gt;阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　直到JSR166，阻塞线程和解除线程阻塞都是基于Java的内置管程，没有其它非基于Java内置管程的API可以用来达到阻塞线程和解除线程阻塞。唯一可以选择的是Thread.suspend和Thread.resume，但是它们都有无法解决的竞态问题，所以也没法用，目前该方法基本已被抛弃。具体不能用的原因可以&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html&quot; target=&quot;_blank&quot;&gt;官方给出的答复&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　j.u.c.locks包提供了LockSupport类来解决这个问题。方法LockSupport.park阻塞当前线程直到有个LockSupport.unpark方法被调用。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可以有多余的unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地取消多余的unpark调用，但并不值得这样做。在需要的时候多次调用park会更高效。park方法同样支持可选的相对或绝对的超时设置，以及与JVM的Thread.interrupt结合 ，可通过中断来unpark一个线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.3&lt;/strong&gt; &lt;strong&gt;队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　整个框架的核心就是如何管理线程阻塞队列，该队列是严格的FIFO队列，因此不支持线程优先级的同步。同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，业界主要有两种选择，一种是MCS锁，另一种是CLH锁。其中CLH一般用于自旋，但是相比MCS，CLH更容易实现取消和超时，所以同步队列选择了CLH作为实现的基础。&lt;/p&gt;
&lt;p&gt;　　CLH队列实际并不那么像队列，它的出队和入队与实际的业务使用场景密切相关。它是一个链表队列，通过AQS的两个字段head（头节点）和tail（尾节点）来存取，这两个字段是volatile类型，初始化的时候都指向了一个空节点。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812201948093-418701167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　入队操作：CLH队列是FIFO队列，故新的节点到来的时候，是要插入到当前队列的尾节点之后。试想一下，当一个线程成功地获取了同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个CAS方法，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。入队操作示意图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202051742-1948605021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　出队操作：因为遵循FIFO规则，所以能成功获取到AQS同步状态的必定是首节点，首节点的线程在释放同步状态时，会唤醒后续节点，而后续节点会在获取AQS同步状态成功的时候将自己设置为首节点。设置首节点是由获取同步成功的线程来完成的，由于只能有一个线程可以获取到同步状态，所以设置首节点的方法不需要像入队这样的CAS操作，只需要将首节点设置为原首节点的后续节点同时断开原节点、后续节点的引用即可。出队操作示意图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202637706-938220186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这一小节只是简单的描述了队列的大概，目的是为了表达清楚队列的设计框架，实际上CLH队列已经和初始的CLH队列已经发生了一些变化，具体的可以看查看资料中Doug Lea的那篇论文中的3.3 Queues。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.4&lt;/strong&gt; &lt;strong&gt;条件队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上一节的队列其实是AQS的同步队列，这一节的队列是条件队列，队列的管理除了有同步队列，还有条件队列。AQS只有一个同步队列，但是可以有多个条件队列。AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。&lt;/p&gt;
&lt;p&gt;　　ConditionObject类实现了Condition接口，Condition接口提供了类似Object管程式的方法，如await、signal和signalAll操作，还扩展了带有超时、检测和监控的方法。ConditionObject类有效地将条件与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，当且仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的。这样，一个ConditionObject关联到一个ReentrantLock上就表现的跟内置的管程（通过Object.wait等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。&lt;/p&gt;
&lt;p&gt;　　ConditionObject类和AQS共用了内部节点，有自己单独的条件队列。signal操作是通过将节点从条件队列转移到同步队列中来实现的，没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。signal操作大致示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202850477-387948953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　await操作就是当前线程节点从同步队列进入条件队列进行等待，大致示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202959032-1029783103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　实现这些操作主要复杂在，因超时或Thread.interrupt导致取消了条件等待时，该如何处理。await和signal几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在signal操作之前，await方法必须在重新获取到锁后，抛出InterruptedException。但是，如果中断发生在signal后，await必须返回且不抛异常，同时设置线程的中断状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.2&lt;/strong&gt; &lt;strong&gt;方法结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果我们理解了上一节的设计思路，我们大致就能知道AQS的主要数据结构了。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;组件&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;数据结构&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;volatile int state&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;阻塞&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;LockSupport类&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;队列&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;条件队列&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;ConditionObject&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　进而再来看下AQS的主要方法及其作用。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;61.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;属性、方法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;描述、作用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;int getState()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;获取当前同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void setState(int newState)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;设置当前同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;boolean compareAndSetState(int expect, int update)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;通过CAS设置当前状态，此方法保证状态设置的原子性&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean tryAcquire(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;钩子方法，独占式获取同步状态，AQS没有具体实现，具体实现都在子类中，实现此方法需要查询当前同步状态并判断同步状态是否符合预期，然后再CAS设置同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean tryRelease(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;钩子方法，独占式释放同步状态，AQS没有具体实现，具体实现都在子类中，等待获取同步状态的线程将有机会获取同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;int tryAcquireShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;钩子方法，共享式获取同步状态，AQS没有具体实现，具体实现都在子类中，返回大于等于0的值表示获取成功，反之失败&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean tryReleaseShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;钩子方法，共享式释放同步状态，AQS没有具体实现，具体实现都在子类中&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean isHeldExclusively()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;钩子方法，AQS没有具体实现，具体实现都在子类中，当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void acquire(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;模板方法，独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则会进入同步队列等待，此方法会调用子类重写的tryAcquire方法&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void acquireInterruptibly(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法，与acquire相同，但是此方法可以响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，此方法会抛出InterruptedException并返回&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;boolean tryAcquireNanos(int arg, long nanosTimeout)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法，在acquireInterruptibly基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，则会返回false,如果获取到了则会返回true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;boolean release(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;模板方法，独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中的第一个节点包含的线程唤醒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void acquireShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法，共享式的获取同步状态，如果当前系统未获取到同步状态，将会进入同步队列等待，与acquire的主要区别在于同一时刻可以有多个线程获取到同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void acquireSharedInterruptibly(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，与acquireShared一致，但是可以响应中断&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;boolean tryAcquireSharedNanos(int arg, long nanosTimeout)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，在acquireSharedInterruptibly基础上增加了超时限制&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean releaseShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，共享式的释放同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Collection&amp;lt;Thread&amp;gt; getQueuedThreads()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，获取等待在同步队列上的线程集合&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node int waitStatus&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;等待状态&lt;/p&gt;
&lt;p&gt;1、 CANCELLED，值为1，在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态后将不会变化；&lt;/p&gt;
&lt;p&gt;2、 SIGNAL，值为-1，后续节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后续节点，使后续节点的线程得以运行；&lt;/p&gt;
&lt;p&gt;3、 CONDITION，值为-2，节点在条件队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点将会从条件队列中转移到同步队列中，加入到对同步状态的获取中；&lt;/p&gt;
&lt;p&gt;4、 PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地传播下去&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node prev&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;前驱节点，当节点加入同步队列时被设置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node next&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;后续节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Thread thread&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;获取同步状态的线程&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node nextWaiter&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;条件队列中的后续节点，如果当前节点是共享的，那么这个字段将是一个SHARED变量，也就是说节点类型（独占和共享）和条件队列中的后续节点共用同一个字段&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;LockSupport void park()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;阻塞当前线程，如果调用unpark方法或者当前线程被中断，才能从park方法返回&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;LockSupport void unpark(Thread thread)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;唤醒处于阻塞状态的线程&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;ConditionObject Node firstWaiter&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;条件队列首节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;ConditionObject Node lastWaiter&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;条件队列尾节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void await()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;当前线程进入等待状态直到signal或中断，当前线程将进入运行状态且从await方法返回的情况，包括：&lt;/p&gt;
&lt;p&gt;其他线程调用该Condition的signal或者signalAll方法，且当前线程被选中唤醒；&lt;/p&gt;
&lt;p&gt;其他线程调用interrupt方法中断当前线程；&lt;/p&gt;
&lt;p&gt;如果当前线程从await方法返回表明该线程已经获取了Condition对象对应的锁&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void awaitUninterruptibly()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;和await方法类似，但是对中断不敏感&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;long awaitNanos(long nanosTimeout)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;当前线程进入等待状态直到被signal、中断或者超时。返回值表示剩余的时间。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean awaitUntil(Date deadline)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;当前线程进入等待状态直到被signal、中断或者某个时间。如果没有到指定时间就被通知，方法返回true，否则表示到了指定时间，返回false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void signal()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void signalAll()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　看到这，我们对AQS的数据结构应该基本上有一个大致的认识，有了这个基本面的认识，我们就可以来看下AQS的源代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3&lt;/strong&gt;&lt;strong&gt;、AQS的源代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　主要通过独占式同步状态的获取和释放、共享式同步状态的获取和释放来看下AQS是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.1&lt;/strong&gt; &lt;strong&gt;独占式同步状态的获取和释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　独占式同步状态调用的方法是acquire，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：首先调用子类实现的tryAcquire方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造独占式同步节点（同一时刻只能有一个线程成功获取同步状态）并通过addWaiter方法将该节点加入到同步队列的尾部，最后调用acquireQueued方法，使得该节点以自旋的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。&lt;/p&gt;
&lt;p&gt;　　下面来首先来看下节点构造和加入同步队列是如何实现的。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程构造成Node节点&lt;/span&gt;
        Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(Thread.currentThread(), mode);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try the fast path of enq; backup to full enq on failure
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试快速在尾节点后新增节点 提升算法效率 先将尾节点指向pred&lt;/span&gt;
        Node pred =&lt;span&gt; tail;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾节点不为空  当前线程节点的前驱节点指向尾节点&lt;/span&gt;
            node.prev =&lt;span&gt; pred;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并发处理 尾节点有可能已经不是之前的节点 所以需要CAS更新&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(pred, node)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CAS更新成功 当前线程为尾节点 原先尾节点的后续节点就是当前节点&lt;/span&gt;
                pred.next =&lt;span&gt; node;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个入队的节点或者是尾节点后续节点新增失败时进入enq&lt;/span&gt;
&lt;span&gt;        enq(node);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            Node t &lt;/span&gt;=&lt;span&gt; tail;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must initialize
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾节点为空  第一次入队  设置头尾节点一致 同步队列的初始化&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node()))
                    tail &lt;/span&gt;=&lt;span&gt; head;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的线程节点在构造完成第一个节点后 依次加入到同步队列中&lt;/span&gt;
                node.prev =&lt;span&gt; t;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
                    t.next &lt;/span&gt;=&lt;span&gt; node;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　节点进入同步队列之后，就进入了一个自旋的过程，每个线程节点都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中并会阻塞节点的线程，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程节点的前驱节点&lt;/span&gt;
                &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱节点为头节点且成功获取同步状态&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置当前节点为头节点&lt;/span&gt;
&lt;span&gt;                    setHead(node);
                    p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                    failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; interrupted;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否阻塞&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                    interrupted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
                cancelAcquire(node);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再来看看shouldParkAfterFailedAcquire和parkAndCheckInterrupt是怎么来阻塞当前线程的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldParkAfterFailedAcquire(Node pred, Node node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱节点的状态决定后续节点的行为&lt;/span&gt;
　　　　 &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; pred.waitStatus;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL)
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;前驱节点为-1 后续节点可以被阻塞
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                node.prev &lt;/span&gt;= pred =&lt;span&gt; pred.prev;
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; 0&lt;span&gt;);
            pred.next &lt;/span&gt;=&lt;span&gt; node;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;前驱节点是初始或者共享状态就设置为-1 使后续节点阻塞
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; parkAndCheckInterrupt() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞线程&lt;/span&gt;
        LockSupport.park(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Thread.interrupted();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　节点自旋的过程大致示意图如下，其实就是对图二、图三的补充。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812203804425-1737346642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　图六  节点自旋获取队列同步状态&lt;/p&gt;
&lt;p&gt;　　整个独占式获取同步状态的流程图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812203910106-196358265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　图七  独占式获取同步状态&lt;/p&gt;
&lt;p&gt;　　当同步状态获取成功之后，当前线程从acquire方法返回，对于锁这种并发组件而言，就意味着当前线程获取了锁。有获取同步状态的方法，就存在其对应的释放方法，该方法为release，现在来看下这个方法的实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tryRelease(arg)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步状态释放成功&lt;/span&gt;
            Node h =&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接释放头节点&lt;/span&gt;
&lt;span&gt;                unparkSuccessor(h);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unparkSuccessor(Node node) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; node.waitStatus;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws &amp;lt; 0&lt;span&gt;)
            compareAndSetWaitStatus(node, ws, &lt;/span&gt;0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;寻找符合条件的后续节点
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Node s &lt;/span&gt;=&lt;span&gt; node.next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; 0&lt;span&gt;) {
            s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t =&lt;span&gt; t.prev)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= 0&lt;span&gt;)
                    s &lt;/span&gt;=&lt;span&gt; t;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后续节点&lt;/span&gt;
&lt;span&gt;            LockSupport.unpark(s.thread);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　独占式释放是非常简单而且明确的。&lt;/p&gt;
&lt;p&gt;　　总结下独占式同步状态的获取和释放：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后唤醒头节点的后继节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.2&lt;/strong&gt; &lt;strong&gt;共享式同步状态的获取和释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　共享式同步状态调用的方法是acquireShared，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取同步状态的返回值大于等于0时表示可以获取同步状态
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小于0时表示可以获取不到同步状态  需要进入队列等待&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; 0&lt;span&gt;)
            doAcquireShared(arg);
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;和独占式一样的入队操作&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.SHARED);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自旋&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r &amp;gt;= 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱结点为头节点且成功获取同步状态 可退出自旋&lt;/span&gt;
&lt;span&gt;                        setHeadAndPropagate(node, r);
                        p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interrupted)
                            selfInterrupt();
                        failed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                    interrupted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
                cancelAcquire(node);
        }
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeadAndPropagate(Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; propagate) {
        Node h &lt;/span&gt;= head; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Record old head for check below
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出自旋的节点变成首节点&lt;/span&gt;
&lt;span&gt;        setHead(node);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Try to signal next queued node if:
         *   Propagation was indicated by caller,
         *     or was recorded (as h.waitStatus either before
         *     or after setHead) by a previous operation
         *     (note: this uses sign-check of waitStatus because
         *      PROPAGATE status may transition to SIGNAL.)
         * and
         *   The next node is waiting in shared mode,
         *     or we don't know, because it appears null
         *
         * The conservatism in both of these checks may cause
         * unnecessary wake-ups, but only when there are multiple
         * racing acquires/releases, so most need signals now or soon
         * anyway.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (propagate &amp;gt; 0 || h == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0 ||&lt;span&gt;
            (h &lt;/span&gt;= head) == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0&lt;span&gt;) {
            Node s &lt;/span&gt;=&lt;span&gt; node.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; s.isShared())
                doReleaseShared();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared方法可以释放同步状态，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放同步状态&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后续等待的节点&lt;/span&gt;
&lt;span&gt;            doReleaseShared();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自旋&lt;/span&gt;
　　　　&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            Node h &lt;/span&gt;=&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, 0&lt;span&gt;))
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后续节点&lt;/span&gt;
　　　　　　　　　　　　&lt;span&gt;unparkSuccessor(h);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == 0 &amp;amp;&amp;amp;
                         !compareAndSetWaitStatus(h, 0&lt;span&gt;, Node.PROPAGATE))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　unparkSuccessor方法和独占式是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4&lt;/strong&gt;&lt;strong&gt;、AQS应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AQS被大量的应用在了同步工具上。&lt;/p&gt;
&lt;p&gt;　　ReentrantLock：ReentrantLock类使用AQS同步状态来保存锁重复持有的次数。当锁被一个线程获取时，ReentrantLock也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。ReentrantLock也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。&lt;/p&gt;
&lt;p&gt;　　ReentrantReadWriteLock：ReentrantReadWriteLock类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。WriteLock的构建方式同ReentrantLock。ReadLock则通过使用acquireShared方法来支持同时允许多个读线程。&lt;/p&gt;
&lt;p&gt;　　Semaphore：Semaphore类（信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；tryRelease方法会增加计数，在计数为正值时还要解除线程的阻塞。&lt;/p&gt;
&lt;p&gt;　　CountDownLatch：CountDownLatch类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（对应到CountDownLatch中就是await方法）才能通过。&lt;/p&gt;
&lt;p&gt;　　FutureTask：FutureTask类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（FutureTask的set方法）或取消（FutureTask的cancel方法）一个FutureTask时会调用AQS的release操作，等待计算结果的线程的阻塞解除是通过AQS的acquire操作实现的。&lt;/p&gt;
&lt;p&gt;　　SynchronousQueues：SynchronousQueues类使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。&lt;/p&gt;
&lt;p&gt;       除了这些j.u.c提供的工具，还可以基于AQS自定义符合自己需求的同步器。&lt;/p&gt;

&lt;p&gt;       AQS就学习到这，如果有描述不当的地方，还请留言交流。了解了AQS后下一步准备详细学习基于AQS的工具类。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lingjiango/ConcurrentProgramPractice&quot;&gt;https://github.com/lingjiango/ConcurrentProgramPractice&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&quot;&gt;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《Java并发编程的艺术》&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 13:03:00 +0000</pubDate>
<dc:creator>lingjiango</dc:creator>
<og:description>在具备了volatile、CAS和模板方法设计模式的知识之后，我们可以来深入学习下AbstractQueuedSynchronizer（AQS），本文主要想从AQS的产生背景、设计和结构、源代码实现及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iou123lg/p/9464385.html</dc:identifier>
</item>
<item>
<title>Deno下一代Nodejs？Deno初体验 - peiyu1988</title>
<link>http://www.cnblogs.com/peiyu1988/p/9428882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peiyu1988/p/9428882.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ryan Dahl之父发布了新的项目Deno，很多IT媒体都使用了标题“下一代Nodejs”，首先我们看一下Deno的特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.支持typescript (nodejs目前也支持)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.无package.json，无npm，不兼容nodejs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.通过URL的方式引入依赖而非引入本地模块，并在第一次运行的时候进行加载和缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.可以控制文本系统和网络访问权限以运行沙盒代码，默认访问只读文件系统可访问，无网络权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.发生未捕捉错误时自动终止运行（这一点与nodejs一样）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.支持top-level的await。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.最终创建单一可执行文件（go语言特性）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.可以作为库引入，用于建立自己的Javascript Runtime。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8项特性中，有好几个都是针对Node的痛点，包括无package.json，依赖包的引入，针对的就是被广泛吐槽的过大node_module。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 附赠Deno Github地址：&lt;a href=&quot;https://github.com/ry/deno&quot; target=&quot;_blank&quot;&gt;https://github.com/ry/deno&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Deno详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先上一张图来看一下javascript的发展简史。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141038/201808/1141038-20180812201110042-658024715.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;目前Deno只是一个demo，我花了一段时间，读了一下deno的源码，整个源码并没有提到nodejs。&lt;/p&gt;
&lt;p&gt;在 high-level 层面，Deno 提供了一个尽可能简单的 V8 到系统 API 的绑定。为什么使用 Golang 替代 C++ 呢，因为相比 Node 而言，Golang 让我们&lt;strong&gt;更加容易的添加新特性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们再对比一下两者的启动性能。分别运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log('Hello world')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;node vs deno&quot; src=&quot;https://static.studygolang.com/180604/98de120643b17d9f36767f0dc13a5255.jpg&quot; alt=&quot;node vs deno&quot; data-src=&quot;/img/remote/1460000015159734?w=600&amp;amp;h=371&quot; data-action=&quot;zoom&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;deno vs node(without-snapshot)&quot; src=&quot;https://static.studygolang.com/180604/15bdd65c7fb9b91aa49cca58c0a472ba.jpg&quot; alt=&quot;deno vs node(without-snapshot)&quot; data-src=&quot;/img/remote/1460000015159735?w=600&amp;amp;h=371&quot; data-action=&quot;zoom&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依然是相差悬殊，毕竟 deno 需要加载一个 TypeScript 编译器。毕竟是一个 demo 版本，希望以后用力优化。&lt;/p&gt;
&lt;p&gt;对于性能提升还有一个思路就是，可以使用 LLVM 作为后端编译器把 TypeScript 代码编译为 WebAssembly 然后在 V8 里面运行，甚至可以直接把源码编译成二进制代码运行。Ryan Dahl 表示 deno 只需要一个编译器，那就是 TS。但是既然 deno 要兼容浏览器，那么 WebAssembly 应该也会被支持。&lt;/p&gt;
&lt;p&gt;Deno 可以对 ts 的编译结果进行缓存（&lt;code&gt;~/.deno/cache&lt;/code&gt;），所以目前关注的就是启动速度和初次编译速度。&lt;/p&gt;
&lt;p&gt;要么就是在发布前先行编译，如此一来 deno 就脱离了开发的初衷了。deno 是一个 ts 的运行时，那么就应该可以直接运行 ts 代码，如果提前把 ts 编译成 js，那么 deno 就回退到 js 运行时了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;初学者应该学习Node还是Deno&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于这个问题，Ryan Dahl 的回答干净利落：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Use Node. Deno is a prototype / experiment.&lt;/p&gt;
&lt;p&gt;使用 Node。Deno 只是一个原型或实验性产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从介绍可以看到，Deno 的目标是不兼容 Node，而是兼容浏览器。&lt;/p&gt;
&lt;p&gt;所以，Deno 不是要取代 Node.js，也不是下一代 Node.js，也不是要放弃 npm 重建 Node 生态。deno 的目前是要拥抱浏览器生态。&lt;/p&gt;
&lt;p&gt;不得不说这个目标真伟大。Ryan Dahl 开发了 Node.js，社区构建出了整个 npm 生态。并且“Node.js 是前端工程化的重要支柱之一”。&lt;/p&gt;
&lt;p&gt;虽然后来 Ryan Dahl 离开 Node.js 去了 Golang 社区，但是现在 Ryan Dahl 又回来了，为 JavaScript 社区带来了 Golang，开发出了 Deno，然后拥抱浏览器生态。&lt;/p&gt;
&lt;p&gt;我们看看 deno 的关于 Web API 的目标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;High level&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Console √&lt;/li&gt;
&lt;li&gt;File/FileList/FileReader/Blob&lt;/li&gt;
&lt;li&gt;XMLHttpRequest&lt;/li&gt;
&lt;li&gt;WebSocket&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Middle level&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AudioContext/AudioBuffer&lt;/li&gt;
&lt;li&gt;Canvas&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;甚至还会包括 webGL 和 GPU 等的支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Deno的架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Parsa Ghadimi 绘制了一张关于 Deno 的&lt;a href=&quot;https://user-images.githubusercontent.com/13242052/40822567-1011df28-6582-11e8-8d77-a7fa422093eb.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;架构图&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;Deno‘s architecture&quot; src=&quot;https://static.studygolang.com/180604/244482e5715dec383a1dc9988d8d53b9.png&quot; alt=&quot;Deno‘s architecture&quot; data-src=&quot;/img/remote/1460000015159736?w=1336&amp;amp;h=474&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;底层使用了作者开发的 &lt;a href=&quot;https://github.com/ry/v8worker2&quot; rel=&quot;nofollow noreferrer&quot;&gt;v8worker2&lt;/a&gt;，而 event-loop 则基于 pub/sub 模型。&lt;/p&gt;
&lt;p&gt;我比较好奇的是 deno 使用了 protobuf，而没有使用 Mojo。既然目标是要兼容浏览器，却不使用 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mojo&lt;/a&gt;，而是要在 protobuf 上重新造轮子，可见 Ryan Dahl 是真正的“轮子哥”啊。但是从 issue 中可以看出，Ryan Dahl 之前是没有听说过 Mojo 的，但是他看完 mojo 之后，依然觉得 protobuf 的选择是正确的。&lt;/p&gt;
&lt;p&gt;Mojo 是 Google 开发的新一代 IPC 机制，用以替换旧的 Chrome IPC。目前 Chrome 的最新版本是 67，而 Google 的计划是在 2019 年的 75 版本用 mojo 替换掉所有的旧的 IPC。&lt;/p&gt;
&lt;p&gt;Mojo 的思路确实和 protobuf 毕竟像，毕竟都是 Google 家的。旧的 IPC 系统是基于在 2 个进程(线程)之间的命名管道(IPC::Channel)实现的。这个管道是一个队列，进程间的 IPC 消息按照先进先出的顺序依次传递，所以不同的 IPC 消息之间有先后次序的依赖。相比之下，Mojo 则为每一个接口创建了一个独立的消息管道，确保不同接口的 IPC 是独立的。而且为接口的创建独立的消息管道的代价也并不昂贵，只需分配少量的堆内存。&lt;/p&gt;
&lt;p&gt;Mojo 的架构设计：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;https://static.studygolang.com/180604/91866e89e844cbad685776db6e9bbcc9.png&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000015159737?w=568&amp;amp;h=324&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以看一下 Chrome 引入 Mojo 之后的架构变化。&lt;/p&gt;
&lt;p&gt;之前：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;https://static.studygolang.com/180604/3a55a2fcd63b74c7f6e3b112306cbd4d.png&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000015159738?w=720&amp;amp;h=540&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之后：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;https://static.studygolang.com/180604/34ce29874b14a897d49b5a4318e4a636.png&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000015159739?w=720&amp;amp;h=428&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;是不是有点微服务的感觉。&lt;/p&gt;
&lt;p&gt;熟悉 Java 的 Spring 的可以明显看出这个&lt;strong&gt;依赖倒置&lt;/strong&gt;。Blink 本来是浏览器最底层的排版引擎，通过 Mojo，Blink 变成了要给中间模块。最近大热的 Flutter 也是基于 Mojo 架构的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TypeScript &amp;amp; Javascript&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;deno 的介绍是一个安全的 TypeScript 运行环境。但是我们看源码就会发现，deno 集成进了一个 TypeScript 编译器，而入口文件中 &lt;a href=&quot;https://github.com/ry/deno/blob/b723ab126f5cc37b27d914e6cbdba9a4f9ce1c71/main.go#L94-L97&quot; rel=&quot;nofollow noreferrer&quot;&gt;ry/deno：main.go&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;go&quot;&gt;// It's up to library users to call 
// deno.Eval(&quot;deno_main.js&quot;, &quot;denoMain()&quot;) 
func Eval(filename string, code string) { 
    err := worker.Load(filename, code) 
    exitOnError(err) 
} // It's up to library users to call
// deno.Eval(&quot;deno_main.js&quot;, &quot;denoMain()&quot;)
func Eval(filename string, code string) {
    err := worker.Load(filename, code)
    exitOnError(err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 V8 运行的 deno_main.js 文件。是 JavaScript 而不是 TypeScript 。&lt;/p&gt;
&lt;p&gt;在前面的分析中我们知道这会影响 deno 的初次启动速度。那么对于执行速度呢？从理论上，TypeScript 作为一种静态类型语言，编译完成的 JavaScript 代码会有更快的执行速度。我之前在《前端程序员应该懂点V8 知识》曾经提到过 V8 对于 JavaScript 性能提升有一项是 &lt;strong&gt;Type feedback&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当 V8 执行一个函数时，会基于函数传入的实参（注意是实参，而不是形参，因为 JavaScript 的形参是没有类型的）进行即时编译（JIT）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;https://static.studygolang.com/180604/98915e3d87c7e834617639db9a0b7c4f.png&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000015159740?w=720&amp;amp;h=386&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是当后面再次以不同的类型调用函数时，V8 会进行&lt;strong&gt;去优化(Deopt)&lt;/strong&gt;操作。&lt;/p&gt;
&lt;p&gt;（将之前优化完的结果去掉，称为“去优化”）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;https://static.studygolang.com/180604/9ccc5b1aa7faaaec87a1704bee92c863.png&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000015159741?w=720&amp;amp;h=402&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是如果我们使用 TypeScript ，所有的参数都是由类型标注的，因此可以防止 V8 引擎内部执行去优化操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对deno性能的展望&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然 TypeScript 可以避免 V8 引擎的去优化操作，但是 V8 执行的是 ts 编译后的结果，我们通过字节码或者机器码可以看到，V8 依然生成了 Type Check 的代码，每次调用函数之前，V8 都会对实参的类型进行检查。也就是说，虽然 TypeScript 保证了函数的参数类型，但是编译成 JavaScript 之后，V8 并不能确定函数的参数类型，只能通过每次调用前的检查来保证参数的类型。&lt;/p&gt;
&lt;p&gt;其次，当 V8 遇到函数定义时，并不知道参数的类型，而只有函数被调用后，V8 才能判断函数的类型，才对函数进行 Typed 即时编译。这里又有一个矛盾了，typescript 在函数定义时就已经知道了形参的类型，而 V8 只有在函数调用时才根据实参的类型进行优化。&lt;/p&gt;
&lt;p&gt;所以，目前 deno 的架构还存在很多问题，毕竟只是一个 demo。未来还有很多方向可以优化。&lt;/p&gt;
&lt;p&gt;V8 是一个 JavaScript 运行时，而 deno 如果定义为“安全的 TypeScript 运行时”，至少在目前的架构上，性能是有很大损失的。但是目前还不存在一个 TypeScript 运行时，退而求其次只能在 V8 前面放一个 TypeScript 编译器了。&lt;/p&gt;
&lt;p&gt;执行流程是这样的：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;https://static.studygolang.com/180604/86ad944dd131e1e4c755b88ae100507f.png&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000015159742?w=720&amp;amp;h=169&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;https://static.studygolang.com/180604/746bf9c6961ceec20ca6796525468534.png&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000015159743?w=720&amp;amp;h=271&quot; data-action=&quot;zoom&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然我在项目中没有使用过 TypeScript ，但是基本上我在项目里面写的第三方库都会提供一d.ts 文件。目前 TypeScript 最大的用途还是体现在开发和维护过程中。&lt;/p&gt;
&lt;p&gt;我们想到的一个方式就是 fork 一份 V8 的源码，然后把编译流程整合进去。TypeScript 在编译为 JavaScript 的过程中也需要一份 AST，然后生成 js 代码。V8 执行 js 代码是再 parse 一份 AST，基于 AST 生成中间代码（ByteCode）。如果 TypeScript 可以直接生成对用的字节码则会提升运行时的性能。&lt;/p&gt;
&lt;p&gt;不过 Ryan Dahl 大概不会这么干。但是也未必，毕竟社区已经把 TypeScript 的一个子集编译为 WebAssembly 了。&lt;/p&gt;
&lt;p&gt;之前微软的 JScript 和 VBScript 在和 JavaScript 的竞争中败下阵来，而现在 TypeScript 势头正猛。虽然对 ES 规范的兼容束缚了 TypeScript 的发展，但很期待微软可以提供一个 TS 运行时，或者在 Chakra 引擎增加对 TS 运行时的支持。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 12:41:00 +0000</pubDate>
<dc:creator>peiyu1988</dc:creator>
<og:description>前言 Ryan Dahl之父发布了新的项目Deno，很多IT媒体都使用了标题“下一代Nodejs”，首先我们看一下Deno的特性： 1.支持typescript (nodejs目前也支持)。 2.无p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peiyu1988/p/9428882.html</dc:identifier>
</item>
<item>
<title>强化学习（三）用动态规划（DP）求解 - 刘建平Pinard</title>
<link>http://www.cnblogs.com/pinard/p/9463815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinard/p/9463815.html</guid>
<description>&lt;p&gt;　　　　在&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/9426283.html&quot;&gt;强化学习（二）马尔科夫决策过程(MDP)&lt;/a&gt;中，我们讨论了用马尔科夫假设来简化强化学习模型的复杂度，这一篇我们在马尔科夫假设和贝尔曼方程的基础上讨论使用动态规划(Dynamic Programming, DP)来求解强化学习的问题。&lt;/p&gt;
&lt;p&gt;　　　　动态规划这一篇对应Sutton书的第四章和UCL强化学习课程的第三讲。&lt;/p&gt;

&lt;p&gt;　　　　对于动态规划，相信大家都很熟悉，很多使用算法的地方都会用到。就算是机器学习相关的算法，使用动态规划的也很多，比如之前讲到的&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_10&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/pinard/p/6955871.html&quot;&gt;隐马尔科夫模型HMM（二）前向后向算法评估观察序列概率&lt;/a&gt;，&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_8&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/pinard/p/6991852.html&quot;&gt;隐马尔科夫模型HMM（四）维特比算法解码隐藏状态序列&lt;/a&gt;， 都是动态规划的典型例子。&lt;/p&gt;
&lt;p&gt;　　　　动态规划的关键点有两个：一是问题的最优解可以由若干小问题的最优解构成，即通过寻找子问题的最优解来得到问题的最优解。第二是可以找到子问题状态之间的递推关系，通过较小的子问题状态递推出较大的子问题的状态。而强化学习的问题恰好是满足这两个条件的。&lt;/p&gt;
&lt;p&gt;　　　　我们先看看强化学习的两个基本问题。&lt;/p&gt;
&lt;p&gt;　　　　第一个问题是预测，即给定强化学习的6个要素：状态集$S$, 动作集$A$, 模型状态转化概率矩阵$P$, 即时奖励$R$，衰减因子$\gamma$,  给定策略$\pi$， 求解该策略的状态价值函数$v(\pi)$&lt;/p&gt;
&lt;p&gt;　　　　第二个问题是控制，也就是求解最优的价值函数和策略。给定强化学习的5个要素：状态集$S$, 动作集$A$, 模型状态转化概率矩阵$P$, 即时奖励$R$，衰减因子$\gamma$, 求解最优的状态价值函数$v_{*}$和最优策略$\pi_{*}$　&lt;/p&gt;
&lt;p&gt;　　　　那么如何找到动态规划和强化学习这两个问题的关系呢？&lt;/p&gt;
&lt;p&gt;　　　　回忆一下上一篇&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/9426283.html&quot;&gt;强化学习（二）马尔科夫决策过程(MDP)&lt;/a&gt;中状态价值函数的贝尔曼方程：$$v_{\pi}(s) = \sum\limits_{a \in A} \pi(a|s)(R_s^a + \gamma \sum\limits_{s' \in S}P_{ss'}^av_{\pi}(s'))$$&lt;/p&gt;
&lt;p&gt;　　　　从这个式子我们可以看出，我们可以定义出子问题求解每个状态的状态价值函数，同时这个式子又是一个递推的式子, 意味着利用它，我们可以使用上一个迭代周期内的状态价值来计算更新当前迭代周期某状态$s$的状态价值。可见，使用动态规划来求解强化学习问题是比较自然的。&lt;/p&gt;

&lt;p&gt;　　　　首先，我们来看如何使用动态规划来求解强化学习的预测问题，即求解给定策略的状态价值函数的问题。这个问题的求解过程我们通常叫做策略评估(Policy Evaluation)。&lt;/p&gt;
&lt;p&gt;　　　　策略评估的基本思路是从任意一个状态价值函数开始，依据给定的策略，结合贝尔曼期望方程、状态转移概率和奖励同步迭代更新状态价值函数，直至其收敛，得到该策略下最终的状态价值函数。&lt;/p&gt;
&lt;p&gt;　　　　假设我们在第$k$轮迭代已经计算出了所有的状态的状态价值，那么在第$k+1$轮我们可以利用第$k$轮计算出的状态价值计算出第$k+1$轮的状态价值。这是通过贝尔曼方程来完成的，即：$$v_{k+1}(s) = \sum\limits_{a \in A} \pi(a|s)(R_s^a + \gamma \sum\limits_{s' \in S}P_{ss'}^av_{k}(s'))$$&lt;/p&gt;
&lt;p&gt;　　　　和上一节的式子唯一的区别是由于我们的策略$\pi$已经给定，我们不再写出，对应加上了迭代轮数的下标。我们每一轮可以对计算得到的新的状态价值函数再次进行迭代，直至状态价值的值改变很小(收敛)，那么我们就得出了预测问题的解，即给定策略的状态价值函数$v(\pi)$。&lt;/p&gt;
&lt;p&gt;　　　　下面我们用一个具体的例子来说明策略评估的过程。&lt;/p&gt;

&lt;p&gt;　　　　这是一个经典的Grid World的例子。我们有一个4x4的16宫格。只有左上和右下的格子是终止格子。该位置的价值固定为0，个体如果到达了该2个格子，则停止移动，此后每轮奖励都是0。个体在16宫格其他格的每次移动，得到的即时奖励$R$都是-1。注意个体每次只能移动一个格子，且只能上下左右4种移动选择，不能斜着走, 如果在边界格往外走，则会直接移动回到之前的边界格。衰减因子我们定义为$\gamma=1$。由于这里每次移动，下一格都是固定的，因此所有可行的的状态转化概率$P=1$。这里给定的策略是随机策略，即每个格子里有25%的概率向周围的4个格子移动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1042406/201808/1042406-20180812184148124-1485684702.jpg&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;638&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　首先我们初始化所有格子的状态价值为0，如上图$k=0$的时候。现在我们开始策略迭代了。由于终止格子的价值固定为0，我们可以不将其加入迭代过程。在$k=1$的时候，我们利用上面的贝尔曼方程先计算第二行第一个格子的价值：$$v_1^{(21)} = \frac{1}{4}[(-1+0) +(-1+0)+(-1+0)+(-1+0)] = -1$$&lt;/p&gt;
&lt;p&gt;　　　　第二行第二个格子的价值是：$$v_1^{(22)} = \frac{1}{4}[(-1+0) +(-1+0)+(-1+0)+(-1+0)] = -1$$&lt;/p&gt;
&lt;p&gt;　　　　其他的格子都是类似的，第一轮的状态价值迭代的结果如上图$k=1$的时候。现在我们第一轮迭代完了。开始动态规划迭代第二轮了。还是看第二行第一个格子的价值：$$v_2^{(21)} = \frac{1}{4}[(-1+0) +(-1-1)+(-1-1)+(-1-1)] = -1.75$$&lt;/p&gt;
&lt;p&gt;　　　　第二行第二个格子的价值是：$$v_2^{(22)} = \frac{1}{4}[(-1-1) +(-1-1)+(-1-1)+(-1-1)] = -2$$&lt;/p&gt;
&lt;p&gt;　　　　最终得到的结果是上图$k=2$的时候。第三轮的迭代如下：&lt;/p&gt;
&lt;p&gt;$$v_3^{(21)} = \frac{1}{4}[(-1-1.7) +(-1-2)+(-1-2)+(-1+0)] = -2.425$$$$v_3^{(22)} = \frac{1}{4}[(-1-1.7) +(-1-1.7)+(-1-2)+(-1-2)] = -2.85$$&lt;/p&gt;
&lt;p&gt;　　　　最终得到的结果是上图$k=3$的时候。就这样一直迭代下去，直到每个格子的策略价值改变很小为止。这时我们就得到了所有格子的基于随机策略的状态价值。&lt;/p&gt;
&lt;p&gt;　　　　可以看到，动态规划的策略评估计算过程并不复杂，但是如果我们的问题是一个非常复杂的模型的话，这个计算量还是非常大的。&lt;/p&gt;

&lt;p&gt;　　　　上面我们将了使用策略评估求解控制问题，现在我们再来看如何使用动态规划求解强化学习的第二个问题控制问题。一种可行的方法就是根据我们之前基于任意一个给定策略评估得到的状态价值来及时调整我们的动作策略，这个方法我们叫做策略迭代(Policy Iteration)。&lt;/p&gt;
&lt;p&gt;　　　　如何调整呢？最简单的方法就是贪婪法。考虑一种如下的贪婪策略：个体在某个状态下选择的行为是其能够到达后续所有可能的状态中状态价值最大的那个状态。还是以第三节的例子为例，如上面的图右边。当我们计算出最终的状态价值后，我们发现，第二行第一个格子周围的价值分别是0,-18,-20，此时我们用贪婪法，则我们调整行动策略为向状态价值为0的方向移动，而不是随机移动。也就是图中箭头向上。而此时第二行第二个格子周围的价值分别是-14,-14,-20, -20。那么我们整行动策略为向状态价值为-14的方向移动，也就是图中的向左向上。&lt;/p&gt;
&lt;p&gt;　　　　如果用一副图来表示策略迭代的过程的话，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1042406/201808/1042406-20180812191537706-1156414836.jpg&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在策略迭代过程中，我们循环进行两部分工作，第一步是使用当前策略$\pi_{*}$评估计算当前策略的最终状态价值$v_{*}$，第二步是根据状态价值$v_{*}$根据一定的方法（比如贪婪法）更新策略$\pi_{*}$，接着回到第一步，一直迭代下去，最终得到收敛的策略$\pi_{*}$和状态价值$v_{*}$。&lt;/p&gt;

&lt;p&gt;　　　　观察第三节的图发现，我们如果用贪婪法调整动作策略，那么当$k=3$的时候，我们就已经得到了最优的动作策略。而不用一直迭代到状态价值收敛才去调整策略。那么此时我们的策略迭代优化为价值迭代。&lt;/p&gt;
&lt;p&gt;　　　　还是以第三节的例子为例，如上面的图右边。比如当$k=2$时，第二行第一个格子周围的价值分别是0,-2,-2，此时我们用贪婪法，则我们调整行动策略为向状态价值为0的方向移动，而不是随机移动。也就是图中箭头向上。而此时第二行第二个格子周围的价值分别是-1.7,-1.7,-2, -2。那么我们整行动策略为向状态价值为-1.7的方向移动，也就是图中的向左向上。&lt;/p&gt;
&lt;p&gt;　　　　和上一节相比，我们没有等到状态价值收敛才调整策略，而是随着状态价值的迭代及时调整策略, 这样可以大大减少迭代次数。此时我们的状态价值的更新方法也和策略迭代不同。现在的贝尔曼方程迭代式子如下：$$v_{k+1}(s) = \max_{a \in A}(R_s^a + \gamma \sum\limits_{s' \in S}P_{ss'}^av_{k}(s'))$$&lt;/p&gt;
&lt;p&gt;　　　　可见由于策略调整，我们现在价值每次更新倾向于贪婪法选择的最优策略对应的后续状态价值，这样收敛更快。&lt;/p&gt;

&lt;p&gt;　　　　在前几节我们讲的都是同步动态规划算法，即每轮迭代我会计算出所有的状态价值并保存起来，在下一轮中，我们使用这些保存起来的状态价值来计算新一轮的状态价值。&lt;/p&gt;
&lt;p&gt;　　　　另一种动态规划求解是异步动态规划算法，在这些算法里，每一次迭代并不对所有状态的价值进行更新，而是依据一定的原则有选择性的更新部分状态的价值，这类算法有自己的一些独特优势，当然有额会有一些额外的代价。&lt;/p&gt;
&lt;p&gt;　　　　常见的异步动态规划算法有三种：&lt;/p&gt;
&lt;p&gt;　　　　第一种是原位动态规划 (in-place dynamic programming)， 此时我们不会另外保存一份上一轮计算出的状态价值。而是即时计算即时更新。这样可以减少保存的状态价值的数量，节约内存。代价是收敛速度可能稍慢。&lt;/p&gt;
&lt;p&gt;　　　　第二种是优先级动态规划 (prioritised sweeping)：该算法对每一个状态进行优先级分级，优先级越高的状态其状态价值优先得到更新。通常使用贝尔曼误差来评估状态的优先级，贝尔曼误差即新状态价值与前次计算得到的状态价值差的绝对值。这样可以加快收敛速度，代价是需要维护一个优先级队列。&lt;/p&gt;
&lt;p&gt;　　　　第三种是实时动态规划 (real-time dynamic programming)：实时动态规划直接使用个体与环境交互产生的实际经历来更新状态价值，对于那些个体实际经历过的状态进行价值更新。这样个体经常访问过的状态将得到较高频次的价值更新，而与个体关系不密切、个体较少访问到的状态其价值得到更新的机会就较少。收敛速度可能稍慢。&lt;/p&gt;

&lt;p&gt;　　　　动态规划是我们讲到的第一个系统求解强化学习预测和控制问题的方法。它的算法思路比较简单，主要就是利用贝尔曼方程来迭代更新状态价值，用贪婪法之类的方法迭代更新最优策略。&lt;/p&gt;
&lt;p&gt;　　　　动态规划算法使用全宽度（full-width）的回溯机制来进行状态价值的更新，也就是说，无论是同步还是异步动态规划，在每一次回溯更新某一个状态的价值时，都要回溯到该状态的所有可能的后续状态，并利用贝尔曼方程更新该状态的价值。这种全宽度的价值更新方式对于状态数较少的强化学习问题还是比较有效的，但是当问题规模很大的时候，动态规划算法将会因贝尔曼维度灾难而无法使用。因此我们还需要寻找其他的针对复杂问题的强化学习问题求解方法。&lt;/p&gt;
&lt;p&gt;　　　　下一篇我们讨论用蒙特卡罗方法来求解强化学习预测和控制问题的方法。&lt;/p&gt;

&lt;p&gt; （欢迎转载，转载请注明出处。欢迎沟通交流： liujianping-ok@163.com） 　　　　&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 12:36:00 +0000</pubDate>
<dc:creator>刘建平Pinard</dc:creator>
<og:description>在强化学习（二）马尔科夫决策过程(MDP)中，我们讨论了用马尔科夫假设来简化强化学习模型的复杂度，这一篇我们在马尔科夫假设和贝尔曼方程的基础上讨论使用动态规划(Dynamic Programming,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pinard/p/9463815.html</dc:identifier>
</item>
</channel>
</rss>