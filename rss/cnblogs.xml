<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Visual Studio 2017 for Mac  快捷键 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/8454328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/8454328.html</guid>
<description>&lt;p&gt;格式化代码:  ^I&lt;/p&gt;
&lt;p&gt;转到定义:&lt;code&gt;⌘D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注释/反注释: &lt;code&gt;⌘/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成:&lt;code&gt;⌘B&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重新生成:^&lt;code&gt;⌘B&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调试运行:&lt;code&gt;⌘↩&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不调试运行:&lt;code&gt;⌥&lt;/code&gt;&lt;code&gt;⌘↩&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加/删除断点:⌘\&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看所有断点:&lt;code&gt;⌥&lt;/code&gt;&lt;code&gt;⌘↩&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;放大:&lt;code&gt;⌘+&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;缩小:&lt;code&gt;⌘-&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;正常大小:&lt;code&gt;⌘0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全屏/取消全屏:^&lt;code&gt;⌘F&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;页内搜索:&lt;code&gt;⌘F&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;文件/项目内搜索:&lt;code&gt;⇧⌘F&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上一步操作光标:&lt;code&gt;⌃⌘←&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下一步操作光标:⌃⌘→&lt;/p&gt;

&lt;p&gt;mac通用符号说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;⌘&lt;/code&gt; : &lt;code&gt;Command&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇧&lt;/code&gt; : &lt;code&gt;Shift&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⇪&lt;/code&gt; : &lt;code&gt;Caps Lock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌥&lt;/code&gt; : &lt;code&gt;Option&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⌃&lt;/code&gt; : &lt;code&gt;Control&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;↩&lt;/code&gt; :&lt;code&gt;Enter&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 19 Feb 2018 22:20:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/8454328.html</dc:identifier>
</item>
<item>
<title>一个Windows下线程池的实现（C++） - TanGuoying</title>
<link>http://www.cnblogs.com/tanguoying/p/8454637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanguoying/p/8454637.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本文配套代码：&lt;a href=&quot;https://github.com/TTGuoying/ThreadPool&quot; target=&quot;_blank&quot;&gt;https://github.com/TTGuoying/ThreadPool&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先看看几个概念：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt; 线程：进程中负责执行的执行单元。一个进程中至少有一个线程。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 多线程：一个进程中有多个线程同时运行，根据cpu切换轮流工作，在多核cpu上可以几个线程同时在不同的核心上同时运行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 线程池：基本思想还是一种对象池思想，开辟一块内存空间，里面存放一些休眠（挂起Suspend）的线程。当有任务要执行时，从池中取一个空闲的线程执行任务，执行完成后线程休眠放回池中。这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　我们为什么要使用线程池呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　简单来说就是线程本身存在开销，我们利用多线程来进行任务处理，单线程也不能滥用，无止禁的开新线程会给系统产生大量消耗，而线程本来就是可重用的资源，不需要每次使用时都进行初始化，因此可以采用有限的线程个数处理无限的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本文的线程池是在Windows上实现的。主要思路是维护一个&lt;span&gt;空闲线程队列&lt;/span&gt;、一个&lt;span&gt;忙碌线程队列&lt;/span&gt;和一个&lt;span&gt;任务队列&lt;/span&gt;，一开始建立一定数量的空闲线程放进&lt;span&gt;空闲线程队列&lt;/span&gt;，当有任务进入&lt;span&gt;任务队列&lt;/span&gt;时，从&lt;span&gt;空闲线程队列&lt;/span&gt;中去一个线程执行任务，线程变为忙碌线程移入&lt;span&gt;忙碌线程队列&lt;/span&gt;，任务执行完成后，线程到&lt;span&gt;任务队列&lt;/span&gt;中取任务继续执行，如果&lt;span&gt;任务队列&lt;/span&gt;中没有任务线程休眠后从&lt;span&gt;忙碌线程队列&lt;/span&gt;回到&lt;span&gt;空闲线程队列&lt;/span&gt;。下面是线程池的工作原理图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/832024/201802/832024-20180219231421765-1436093126.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;639&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本线程池类实现了自动调节池中线程数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　废话少说，直接上代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;==========================================================================
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;* 类ThreadPool是本代码的核心类，类中自动维护线程池的创建和任务队列的派送
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;* 其中的TaskFun是任务函数
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;* 其中的TaskCallbackFun是回调函数
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;*用法：定义一个ThreadPool变量，TaskFun函数和TaskCallbackFun回调函数，然后调用ThreadPool的QueueTaskItem()函数即可
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;Author: TTGuoying
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;Date: 2018/02/19 23:15
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;==========================================================================
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; once
&lt;span&gt; 17&lt;/span&gt; #include &amp;lt;Windows.h&amp;gt;
&lt;span&gt; 18&lt;/span&gt; #include &amp;lt;list&amp;gt;
&lt;span&gt; 19&lt;/span&gt; #include &amp;lt;queue&amp;gt;
&lt;span&gt; 20&lt;/span&gt; #include &amp;lt;memory&amp;gt;
&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::list;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::queue;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::shared_ptr;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; THRESHOLE_OF_WAIT_TASK  20
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; typedef &lt;span&gt;int&lt;/span&gt;(*TaskFun)(PVOID param);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务函数&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; typedef &lt;span&gt;void&lt;/span&gt;(*TaskCallbackFun)(&lt;span&gt;int&lt;/span&gt; result);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调函数&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程类(内部类)&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         Thread(ThreadPool *&lt;span&gt;threadPool);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         ~&lt;span&gt;Thread();
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         BOOL isBusy();                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否有任务在执行&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; ExecuteTask(TaskFun task, PVOID param, TaskCallbackFun taskCallback);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行任务&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         ThreadPool *threadPool;                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所属线程池&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         BOOL    busy;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否有任务在执行&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         BOOL    exit;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否退出&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         HANDLE  thread;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程句柄&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         TaskFun    task;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要执行的任务&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;         PVOID    param;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务参数&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         TaskCallbackFun taskCb;                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调的任务&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; __stdcall ThreadProc(PVOID pM);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程函数&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IOCP的通知种类&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; WAIT_OPERATION_TYPE
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        GET_TASK,
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        EXIT
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 待执行的任务类&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitTask
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        WaitTask(TaskFun task, PVOID param, TaskCallbackFun taskCb, BOOL bLong)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;task =&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;param =&lt;span&gt; param;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;taskCb =&lt;span&gt; taskCb;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;bLong =&lt;span&gt; bLong;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         ~WaitTask() { task = NULL; taskCb = NULL; bLong = FALSE; param =&lt;span&gt; NULL; }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;         TaskFun    task;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要执行的任务&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         PVOID param;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务参数&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         TaskCallbackFun taskCb;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调的任务&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         BOOL bLong;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否时长任务&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从任务列表取任务的线程函数&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; __stdcall GetTaskThreadProc(PVOID pM)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         ThreadPool *threadPool = (ThreadPool *&lt;span&gt;)pM;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         BOOL bRet =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         DWORD dwBytes = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        WAIT_OPERATION_TYPE opType;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         OVERLAPPED *&lt;span&gt;ol;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (WAIT_OBJECT_0 != WaitForSingleObject(threadPool-&amp;gt;stopEvent, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             BOOL bRet = GetQueuedCompletionStatus(threadPool-&amp;gt;completionPort, &amp;amp;dwBytes, (PULONG_PTR)&amp;amp;opType, &amp;amp;&lt;span&gt;ol, INFINITE);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收到退出标志&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (EXIT ==&lt;span&gt; (DWORD)opType)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GET_TASK ==&lt;span&gt; (DWORD)opType)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 threadPool-&amp;gt;&lt;span&gt;GetTaskExcute();
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程临界区锁&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CriticalSectionLock
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         CRITICAL_SECTION cs;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;临界区&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         CriticalSectionLock() { InitializeCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         ~CriticalSectionLock() { DeleteCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; Lock() { EnterCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; UnLock() { LeaveCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     ThreadPool(size_t minNumOfThread = &lt;span&gt;2&lt;/span&gt;, size_t maxNumOfThread = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     ~&lt;span&gt;ThreadPool();
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;     BOOL QueueTaskItem(TaskFun task, PVOID param, TaskCallbackFun taskCb = NULL, BOOL longFun = FALSE);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务入队&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     size_t getCurNumOfThread() { &lt;span&gt;return&lt;/span&gt; getIdleThreadNum() + getBusyThreadNum(); }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的当前线程数&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;     size_t GetMaxNumOfThread() { &lt;span&gt;return&lt;/span&gt; maxNumOfThread - numOfLongFun; }            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的最大线程数&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; SetMaxNumOfThread(size_t size)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程池中的最大线程数&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;    { 
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size &amp;lt;&lt;span&gt; numOfLongFun)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             maxNumOfThread = size +&lt;span&gt; numOfLongFun;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;             maxNumOfThread =&lt;span&gt; size; 
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;    }                    
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     size_t GetMinNumOfThread() { &lt;span&gt;return&lt;/span&gt; minNumOfThread; }                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的最小线程数&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; SetMinNumOfThread(size_t size) { minNumOfThread = size; }                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程池中的最小线程数&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;     size_t getIdleThreadNum() { &lt;span&gt;return&lt;/span&gt; idleThreadList.size(); }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的线程数&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;     size_t getBusyThreadNum() { &lt;span&gt;return&lt;/span&gt; busyThreadList.size(); }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的线程数&lt;/span&gt;
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; CreateIdleThread(size_t size);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建空闲线程&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; DeleteIdleThread(size_t size);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除空闲线程&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;     Thread *GetIdleThread();                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取空闲线程&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; MoveBusyThreadToIdleList(Thread *busyThread);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忙碌线程加入空闲列表&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; MoveThreadToBusyList(Thread *thread);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程加入忙碌列表&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; GetTaskExcute();                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从任务队列中取任务执行&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;     WaitTask *GetTask();                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从任务队列中取任务&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt;     CriticalSectionLock idleThreadLock;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空闲线程列表锁&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt;     list&amp;lt;Thread *&amp;gt; idleThreadList;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空闲线程列表&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt;     CriticalSectionLock busyThreadLock;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忙碌线程列表锁&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt;     list&amp;lt;Thread *&amp;gt; busyThreadList;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忙碌线程列表&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;    CriticalSectionLock waitTaskLock;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;     list&amp;lt;WaitTask *&amp;gt; waitTaskList;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务列表&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt;     HANDLE                    dispatchThrad;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分发任务线程&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;     HANDLE                    stopEvent;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知线程退出的时间&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;     HANDLE                    completionPort;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完成端口&lt;/span&gt;
&lt;span&gt;160&lt;/span&gt;     size_t                    maxNumOfThread;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池中最大的线程数&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;     size_t                    minNumOfThread;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池中最小的线程数&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;     size_t                    numOfLongFun;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池中最小的线程数&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadPool.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;process.h&amp;gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;ThreadPool::ThreadPool(size_t minNumOfThread, size_t maxNumOfThread)
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (minNumOfThread &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread =&lt;span&gt; minNumOfThread;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (maxNumOfThread &amp;lt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;maxNumOfThread = &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;maxNumOfThread =&lt;span&gt; maxNumOfThread;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     stopEvent =&lt;span&gt; CreateEvent(NULL, TRUE, FALSE, NULL);
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     completionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    idleThreadList.clear();
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     CreateIdleThread(&lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;minNumOfThread);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;    busyThreadList.clear();
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;     dispatchThrad = (HANDLE)_beginthreadex(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, GetTaskThreadProc, &lt;span&gt;this&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     numOfLongFun = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; ThreadPool::~&lt;span&gt;ThreadPool()
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    SetEvent(stopEvent);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     PostQueuedCompletionStatus(completionPort, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, (DWORD)EXIT, NULL);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;    CloseHandle(stopEvent);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;BOOL ThreadPool::QueueTaskItem(TaskFun task, PVOID param, TaskCallbackFun taskCb, BOOL longFun)
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    waitTaskLock.Lock();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     WaitTask *waitTask = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitTask(task, param, taskCb, longFun);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    waitTaskList.push_back(waitTask);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    waitTaskLock.UnLock();
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     PostQueuedCompletionStatus(completionPort, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, (DWORD)GET_TASK, NULL);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::CreateIdleThread(size_t size)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         idleThreadList.push_back(&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::DeleteIdleThread(size_t size)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     size_t t =&lt;span&gt; idleThreadList.size();
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (t &amp;gt;=&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             auto thread =&lt;span&gt; idleThreadList.back();
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            idleThreadList.pop_back();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; t; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             auto thread =&lt;span&gt; idleThreadList.back();
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            idleThreadList.pop_back();
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; ThreadPool::Thread *&lt;span&gt;ThreadPool::GetIdleThread()
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     Thread *thread =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (idleThreadList.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         thread =&lt;span&gt; idleThreadList.front();
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        idleThreadList.pop_front();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (thread == NULL &amp;amp;&amp;amp; getCurNumOfThread() &amp;lt;&lt;span&gt; maxNumOfThread)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (thread == NULL &amp;amp;&amp;amp; waitTaskList.size() &amp;gt;&lt;span&gt; THRESHOLE_OF_WAIT_TASK)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         InterlockedIncrement(&amp;amp;&lt;span&gt;maxNumOfThread);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ThreadPool::MoveBusyThreadToIdleList(Thread *&lt;span&gt; busyThread)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    idleThreadList.push_back(busyThread);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    busyThreadLock.Lock();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (auto it = busyThreadList.begin(); it != busyThreadList.end(); it++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (*it ==&lt;span&gt; busyThread)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            busyThreadList.erase(it);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    busyThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (maxNumOfThread != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; idleThreadList.size() &amp;gt; maxNumOfThread * &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         DeleteIdleThread(idleThreadList.size() / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt;     PostQueuedCompletionStatus(completionPort, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, (DWORD)GET_TASK, NULL);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ThreadPool::MoveThreadToBusyList(Thread *&lt;span&gt; thread)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;    busyThreadLock.Lock();
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;    busyThreadList.push_back(thread);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;    busyThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::GetTaskExcute()
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     Thread *thread =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     WaitTask *waitTask =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;     waitTask =&lt;span&gt; GetTask();
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (waitTask ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (waitTask-&amp;gt;&lt;span&gt;bLong)
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (idleThreadList.size() &amp;gt;&lt;span&gt; minNumOfThread)
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;             thread =&lt;span&gt; GetIdleThread();
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;             InterlockedIncrement(&amp;amp;&lt;span&gt;numOfLongFun);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             InterlockedIncrement(&amp;amp;&lt;span&gt;maxNumOfThread);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         thread =&lt;span&gt; GetIdleThread();
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (thread !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;         thread-&amp;gt;ExecuteTask(waitTask-&amp;gt;task, waitTask-&amp;gt;param, waitTask-&amp;gt;&lt;span&gt;taskCb);
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; waitTask;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;        MoveThreadToBusyList(thread);
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;        waitTaskLock.Lock();
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;        waitTaskList.push_front(waitTask);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        waitTaskLock.UnLock();
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;     
&lt;span&gt;178&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; 
&lt;span&gt;180&lt;/span&gt; ThreadPool::WaitTask *&lt;span&gt;ThreadPool::GetTask()
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;     WaitTask *waitTask =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;    waitTaskLock.Lock();
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (waitTaskList.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;         waitTask =&lt;span&gt; waitTaskList.front();
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;        waitTaskList.pop_front();
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;    waitTaskLock.UnLock();
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; waitTask;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt; 
&lt;span&gt;194&lt;/span&gt; ThreadPool::Thread::Thread(ThreadPool *&lt;span&gt;threadPool) :
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;    busy(FALSE),
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;    thread(INVALID_HANDLE_VALUE),
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;    task(NULL),
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;    taskCb(NULL),
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;    exit(FALSE),
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;    threadPool(threadPool)
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;     thread = (HANDLE)_beginthreadex(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, ThreadProc, &lt;span&gt;this&lt;/span&gt;, CREATE_SUSPENDED, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; 
&lt;span&gt;205&lt;/span&gt; ThreadPool::Thread::~&lt;span&gt;Thread()
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     exit =&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;     task =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;     taskCb =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;    ResumeThread(thread);
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;    WaitForSingleObject(thread, INFINITE);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;    CloseHandle(thread);
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; 
&lt;span&gt;215&lt;/span&gt; &lt;span&gt;BOOL ThreadPool::Thread::isBusy()
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; busy;
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::Thread::ExecuteTask(TaskFun task, PVOID param, TaskCallbackFun taskCallback)
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;     busy =&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;task =&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;param =&lt;span&gt; param;
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;taskCb =&lt;span&gt; taskCallback;
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;    ResumeThread(thread);
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; 
&lt;span&gt;229&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ThreadPool::Thread::ThreadProc(PVOID pM)
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;     Thread *pThread = (Thread*&lt;span&gt;)pM;
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pThread-&amp;gt;&lt;span&gt;exit)
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程退出&lt;/span&gt;
&lt;span&gt;237&lt;/span&gt; 
&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pThread-&amp;gt;task == NULL &amp;amp;&amp;amp; pThread-&amp;gt;taskCb ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;             pThread-&amp;gt;busy =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;             pThread-&amp;gt;threadPool-&amp;gt;&lt;span&gt;MoveBusyThreadToIdleList(pThread);
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;             SuspendThread(pThread-&amp;gt;&lt;span&gt;thread);
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; 
&lt;span&gt;246&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; resulst = pThread-&amp;gt;task(pThread-&amp;gt;&lt;span&gt;param);
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(pThread-&amp;gt;&lt;span&gt;taskCb)
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;             pThread-&amp;gt;&lt;span&gt;taskCb(resulst);
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;         WaitTask *waitTask = pThread-&amp;gt;threadPool-&amp;gt;&lt;span&gt;GetTask();
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (waitTask !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;             pThread-&amp;gt;task = waitTask-&amp;gt;&lt;span&gt;task;
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;             pThread-&amp;gt;taskCb = waitTask-&amp;gt;&lt;span&gt;taskCb;
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;             &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; waitTask;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;             pThread-&amp;gt;task =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;             pThread-&amp;gt;param =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;             pThread-&amp;gt;taskCb =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;             pThread-&amp;gt;busy =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;             pThread-&amp;gt;threadPool-&amp;gt;&lt;span&gt;MoveBusyThreadToIdleList(pThread);
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;             SuspendThread(pThread-&amp;gt;&lt;span&gt;thread);
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; 
&lt;span&gt;268&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ThreadPool.cpp: 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadPool.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Task
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Task1(PVOID p) 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Sleep(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             i--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskCallback
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TaskCallback1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     ThreadPool threadPool(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;30&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        threadPool.QueueTaskItem(Task::Task1, NULL, TaskCallback::TaskCallback1);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    threadPool.QueueTaskItem(Task::Task1, NULL, TaskCallback::TaskCallback1, TRUE);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    getchar();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 19 Feb 2018 15:23:00 +0000</pubDate>
<dc:creator>TanGuoying</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanguoying/p/8454637.html</dc:identifier>
</item>
<item>
<title>------ 解析因内核栈溢出导致的 “double fault” 蓝屏 ------ - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8454533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8454533.html</guid>
<description>&lt;p&gt;——————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前一篇指出 tail_recursivef_factorial() 会递归调用自身来计算某个正整数的阶乘。当要计算的目标数值过大，经历多次调用后，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就会耗尽可用的内核栈，引发一次页错误异常，而转移控制到错误处理程序前再次向无效的内存地址压入“陷阱帧”则会让原本可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以&lt;/span&gt;&lt;span&gt;处理的异常升级为“double fault”，致使系统崩溃。&lt;/span&gt;&lt;span&gt;本篇通过试图计算 &lt;span&gt;685!&lt;/span&gt; 来触发“double fault”并进行分析。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;将编译好的驱动拷贝到被调试机器上，利用 sc.exe 把它加载至内核空间，源码中（参见上一篇）设置的初始断点被激活从而断入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调试机上的 WinDbg.exe，观察驱动入口点“DriverEntry()”内的局部变量，其中“Number”的值 0x2ad 正是要计算阶乘的数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;685：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219214914318-279441032.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;按下“g”键恢复执行，没多久就让系统崩溃了，这在我们的意料之中，如果没有连接宿主机上的调试器，目标系统就会直接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;蓝屏，并且显示“bug check”代码——0000007F：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215025292-871208570.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在 MSDN 网站上搜索该错误码，它对应于“&lt;span&gt;UNEXPECTED_KERNEL_MODE_TRAP&lt;/span&gt;”，官方给出的解释如下：&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;The UNEXPECTED_KERNEL_MODE_TRAP bug check has a value of 0x0000007F.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;This bug check indicates that the Intel CPU generated a trap and the kernel failed to catch this trap.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;This trap could be a bound trap (a trap the kernel is not permitted to catch) or a double fault&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(a fault that occurred while processing an earlier fault, which always results in a system failure).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种错误是由于 Intel CPU 生成了一个陷阱（trap），而内核未能捕获这个陷阱。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;此陷阱可能是一个受困陷阱（内核不允许捕获的陷阱），或一个“double fault”（当处理一个早先的错误时又出现一个错误，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这样就总是会导致系统故障）。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;原文描述中的后一种情况（处理错误时又发生另一个错误）就是我们此刻的处境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UNEXPECTED_KERNEL_MODE_TRAP 有四个参数，你可以从上一张图看到，首个参数值为“0x00000008（陷阱编号）”，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方对该值的解释为：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;34&quot;&gt;
&lt;p&gt;&lt;span&gt;0x00000008, or Double Fault, indicates that an exception occurs during a call to the handler for a prior exception.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Typically, the two exceptions are handled serially.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;However, there are several exceptions that cannot be handled serially,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;and in this situation the processor signals a double fault. There are two common causes of a double fault:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A kernel stack overflow. This overflow occurs when a guard page is hit, and the kernel tries to push a trap frame.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Because there is no stack left, a stack overflow results, causing the double fault.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;If you think this overview has occurred, use !thread to determine the stack limits, and then use kb&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(Display Stack Backtrace) with a large parameter (for example, kb 100) to display the full stack.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A hardware problem.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“Double Fault”，指明在调用前一个异常处理程序期间，又出现了一个异常。一般而言，两个异常是顺序处理的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然而，有一些异常无法顺序处理，在这种情况下处理器就会发出一个“double fault”信号。有两种常见情况会导致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“double fault”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1。一次内核栈溢出。当接触到一个保护页时就会发生此类溢出，然后内核试图向其中压入一个陷阱帧。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为已经没有剩余栈可用了，导致又一次栈溢出，造成“double fault”。如果你认为发生了这种溢出，利用“!thread”调试器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;命令确定栈界限，然后使用“kb”（显示栈回溯）命令，并带着较大的参数（比如 kb 100）来显示完整的栈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2。硬件问题&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;遵循原文的指示，我们先检查当前线程的栈界限，然后执行栈回溯看是否真的越界了，如下图所示，内核栈边界在 8bf47000 处，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而发生异常前的最后一次递归调用的帧指针（&lt;span&gt;ChildEBP&lt;/span&gt;）为 8bf47008 ，已经快要出界了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215346599-1941129028.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;“&lt;span&gt;nt!KiTrap08&lt;/span&gt;”是实际的陷阱处理程序，有趣的是前面的陷阱编号（0x00000008）就在这个例程的名字中，这绝不是巧合，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上“nt!KiTrap08”就是“double fault”专用的异常处理程序！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传递给它的第三个参数“801d8940”同时也就是 UNEXPECTED_KERNEL_MODE_TRAP 的第二个参数，它是一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个“&lt;span&gt;nt!_NT_TIB&lt;/span&gt;”结构的&lt;/span&gt;&lt;span&gt;“&lt;span&gt;SubSystemTib&lt;/span&gt;”字段值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215505470-1343190109.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实这个字段中包含的信息对于我们此刻的故障排查而言并不那么重要，只是怕有人好奇它的来龙去脉，才略作说明罢了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中的 nt!KiTrap08 栈帧名称后面给出了一个 &lt;strong&gt;&lt;span&gt;TSS（任务状态段）&lt;/span&gt;&lt;/strong&gt;的段选择符为 28。这才是关键的信息，通过它可会回到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事故现场，分析异常发生时的上下文。这个段选择符存储在“&lt;span&gt;nt!_KTSS&lt;/span&gt;”结构的首个字段（&lt;span&gt;Backlink&lt;/span&gt;）内：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215651128-1629080340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看到这里应该能够稍稍体会出内核中相关数据结构设计的多么用心良苦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放下我们的多愁善感，利用调试器的“.tss”命令，后接段选择符，即可回到事故现场，如下所示，异常发生时，EIP 指向即将执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的指令地址为 977bd06f，换言之是该地址处的“前一条”指令（push ecx）导致的异常，为啥这条压栈指令会导致异常呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你看“那时”的 esp 已经指向了内核栈的边界点（8bf47000），而压栈指令需要先把 esp 值减去 4 字节，然后再把 ecx 的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写入 8BF46FFC 地址处，该地址已经位于边界之外。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还记得前一篇我们计算出每次递归调用都会消耗掉 16 字节的内核栈空间吗？这出错前的最后一次调用中，试图消耗的最后 4 字节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就在边界之外！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215757020-176204568.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;低于 8bf47000 的虚拟内存没有分配实际的物理页，而且我们模拟对 8BF46FFC 执行物理地址转译也失败，证实是由于访问到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无效&lt;/span&gt;&lt;span&gt;地址引发异常的（CR2 寄存器存储导致页错误的访问地址）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215848136-1145881044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215917981-2048059349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如前所述，页错误发生后，在控制权转移到 nt!KiTrap08 之前，再次向这个无效的地址压入一张“陷阱帧”，导致再度出现错误，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 nt!KiTrap08 通过传递给它的首个参数（0x0000007f）明白了这是一个“double fault”，所以调用 nt!KiBugCheck，后者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;探测调试器是否存在，决定是要绘制蓝屏还是断入调试器。这就是前面那张栈回溯输出的由来！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;执行“kv 1000”回溯大范围的栈帧，你可以看到 683 次（栈帧编号 0x2b0 - 5）对 tail_recursivef_factorial() 的调用，在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的预测点（685 号栈帧）之前就发生了溢出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219220029413-340818351.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后介绍一个强大的命令“&lt;span&gt;!analyze -v&lt;/span&gt;”，它会自动分析内核崩溃的原因，并给出所有对故障排除有帮助的信息，对于本例而言，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有价值的信息截图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219220108171-938955032.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219220137505-247403330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;—————————————————————————————————————————————————————&lt;/span&gt;&lt;br/&gt;&lt;span&gt;小结：本篇以源码+调试+在线文档等综合手段排除了“double fault”蓝屏故障；编写驱动并上机调试是理解内核设计思想&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的最佳途经！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;—————————————————————————————————————————————————————&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Feb 2018 14:03:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8454533.html</dc:identifier>
</item>
<item>
<title>Language Modeling with Gated Convolutional Networks - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8454498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8454498.html</guid>
<description>

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所谓的语言模型，即是指在得知前面的若干个单词的时候，下一个位置上出现的某个单词的概率。&lt;/p&gt;
&lt;p&gt;最朴素的方法是N-gram语言模型，即当前位置只和前面N个位置的单词相关。如此，问题便是，N小了，语言模型的表达能力不够。N大了，遇到稀疏性问题，无法有效的表征上下文。&lt;/p&gt;
&lt;p&gt;LSTM模型一般会将单词embedding到连续空间，然后输入进LSTM，从而有效的表征上下文。但LSTM的问题在于，作为递归模型，当前状态依赖于上一状态，并行化受到限制。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/2.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所谓的门限卷积，其核心在于为卷积的激活值添加一个门限开关，来决定其有多大的概率传到下一层去。下面一步步对上图进行解析。&lt;/p&gt;
&lt;p&gt;首先，将单词embedding到连续空间；即上图中的第二部分Lookup Table。这样，单词序列就能表现为矩阵了。&lt;/p&gt;
&lt;p&gt;然后就是卷积单元了（上图中的第三部分），与普通卷积不同，门限卷积在这里分为两部分，一部分是卷积激活值，即B，该处于普通卷积的不同在于没有用Tanh，而是直接线性。另一部分是门限值，即A，A也是直接线性得到，但会经过一个sigmoid运算符。&lt;/p&gt;
&lt;p&gt;之后就是门限单元，A和B进行element-wise的相乘，得到卷积后的结果。卷积单元和门限单元加起来形成一个卷积层。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过多个这样的卷积层之后，再将其输入到SoftMax中，得到最后的预测。&lt;/p&gt;
&lt;h2 id=&quot;细节&quot;&gt;细节&lt;/h2&gt;
&lt;p&gt;在做卷积层的时候，需要不让第i个输出值看到i以后的输入值。这是由语言模型的特性决定的，需要用i之前的信息来预测i。为了达到这样的效果，需要将输入层进行偏移，偏移k/2个单位，其中k是卷积的宽度，偏移后开头空缺的部分就用0进行padding。&lt;/p&gt;
&lt;p&gt;由于residual network的强大能力，在真正的实现里，会把卷积单元和门限单元包在一个residual block里。&lt;/p&gt;
&lt;p&gt;在最后的softmax层，普通的softmax会因为词表巨大而非常低效。因而选用adaptive softmax。adaptive softmax可以为高频词分配更多的空间而给低频次分配比较少的空间。&lt;/p&gt;

&lt;p&gt;LSTM中有input门和forget门两种，这两种缺一则会导致有些信息的缺失。而卷积中，经过实验，不需要forget gate。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而LSTM中使用的input门，如上。这种在卷积上却容易导致vanishing问题。因为tanh‘和σ’都是小于1的值。&lt;/p&gt;
&lt;p&gt;因而，在卷积上，使用：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方法存在一路使得X的导数可以不被downscale的传下去。&lt;/p&gt;

&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用Google Billion Word和WikiText-103两种数据集。&lt;/li&gt;
&lt;li&gt;使用perplexity来进行衡量结果。&lt;/li&gt;
&lt;li&gt;使用Nesterov’s momentum算法来训练，momentum设为0.99。&lt;/li&gt;
&lt;li&gt;weight normalization.&lt;/li&gt;
&lt;li&gt;gradient clipping to 0.1&lt;/li&gt;
&lt;li&gt;使用Kaiming initialization&lt;/li&gt;
&lt;li&gt;learning rate 从[1., 2.]中uniformly选取&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;效果测试&quot;&gt;效果测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/8.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单GPU上效果最好。&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;性能测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Throughput是指在并行化条件下最大输出。 &lt;br/&gt;Responsiveness是指序列化的处理输入。 &lt;br/&gt;由表可知，CNN本身的处理速度非常快。而LSTM在并行化后也能拥有很高的速度。究其原因，是在cuDNN中对LSTM有特别的优化，而对1-D convolution却没有。但即便如此，CNN仍然完胜。&lt;/p&gt;
&lt;h2 id=&quot;不同门限测试&quot;&gt;不同门限测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/11.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GTU: tanh(X*W+b)⊗σ(X*V+c)&lt;/li&gt;
&lt;li&gt;GLU: (X*W+b)⊗σ(X*V+c)&lt;/li&gt;
&lt;li&gt;ReLU: X⊗(X&amp;gt;0)&lt;/li&gt;
&lt;li&gt;Tanh: tanh(X*W+b)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;非线性模型测试&quot;&gt;非线性模型测试&lt;/h2&gt;
&lt;p&gt;上一个实验证明了Gated linear unit深受Linear unit的好处。这里评测一下GLU和纯线性模型的比较。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/12.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bilinear: (X*W+b)⊗(X*V+c)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;纯Linear模型同5-gram模型效果类似。&lt;/p&gt;
&lt;h2 id=&quot;模型深度测试&quot;&gt;模型深度测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/13.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;context-size测试&quot;&gt;Context Size测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/14.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;训练测试&quot;&gt;训练测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;卷积不似LSTM那样灵活，输入只能是定长。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 19 Feb 2018 13:39:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8454498.html</dc:identifier>
</item>
<item>
<title>JDBC【数据库连接池、DbUtils框架、分页】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8454470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8454470.html</guid>
<description>&lt;h2 id=&quot;什么是数据库连接池&quot;&gt;什么是数据库连接池&lt;/h2&gt;
&lt;p&gt;简单来说：&lt;strong&gt;数据库连接池就是提供连接的。。。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么我们要使用数据库连接池&quot;&gt;为什么我们要使用数据库连接池&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据库的连接的建立和关闭是非常消耗资源的&lt;/li&gt;
&lt;li&gt;频繁地打开、关闭连接造成系统性能低下&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编写连接池&quot;&gt;编写连接池&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;编写连接池需&lt;strong&gt;实现java.sql.DataSource接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建批量的Connection用LinkedList保存&lt;/strong&gt;【既然是个池，当然用集合保存、、LinkedList底层是链表，对增删性能较好】&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现getConnetion()&lt;/strong&gt;，让getConnection()每次调用，都是&lt;strong&gt;在LinkedList中取一个Connection返回给用户&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用Connection.close()方法，Connction返回给LinkedList&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;


    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; LinkedList&amp;lt;Connection&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();
    
    &lt;span class=&quot;co&quot;&gt;//获取连接只需要一次就够了，所以用static代码块&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;//读取文件配置&lt;/span&gt;
        InputStream inputStream = Demo1.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;);

        Properties properties = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Properties();
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            properties.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(inputStream);
            String url = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;url&quot;&lt;/span&gt;);
            String username = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;);
            String driver = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;driver&quot;&lt;/span&gt;);
            String password = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;);

            &lt;span class=&quot;co&quot;&gt;//加载驱动&lt;/span&gt;
            Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(driver);

            &lt;span class=&quot;co&quot;&gt;//获取多个连接，保存在LinkedList集合中&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {
                Connection connection = DriverManager.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(url, username, password);
                list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(connection);
            }
            
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }

    }

    &lt;span class=&quot;co&quot;&gt;//重写Connection方法，用户获取连接应该从LinkedList中给他&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list);

       &lt;span class=&quot;co&quot;&gt;//先判断LinkedList是否存在连接&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ? list.&lt;span class=&quot;fu&quot;&gt;removeFirst&lt;/span&gt;() : &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; 
    }

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们已经完成前三步了，现在问题来了&lt;strong&gt;。我们调用Conncetion.close()方法，是把数据库的物理连接关掉，而不是返回给LinkedList的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写一个Connection子类，覆盖close()方法&lt;/li&gt;
&lt;li&gt;写一个Connection包装类，增强close()方法&lt;/li&gt;
&lt;li&gt;用动态代理，返回一个代理对象出去，拦截close()方法的调用，对close()增强&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析第一个思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Connection是通过数据库驱动加载的，保存了数据的信息&lt;/strong&gt;。写一个子类Connection，new出对象，&lt;strong&gt;子类的Connction无法直接继承父类的数据信息，也就是说子类的Connection是无法连接数据库的&lt;/strong&gt;，更别谈覆盖close()方法了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析第二个思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写一个Connection包装类。
&lt;ol&gt;&lt;li&gt;写一个类，实现与被增强对象的相同接口【Connection接口】&lt;/li&gt;
&lt;li&gt;定义一个变量，指向被增强的对象&lt;/li&gt;
&lt;li&gt;定义构造方法，接收被增强对象&lt;/li&gt;
&lt;li&gt;覆盖想增强的方法&lt;/li&gt;
&lt;li&gt;对于不想增强的方法，直接调用被增强对象的方法&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;这个思路本身是没什么毛病的，就是&lt;strong&gt;实现接口时，方法太多了！&lt;/strong&gt;，所以我们也不使用此方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析第三个思路代码实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Connection connection = list.&lt;span class=&quot;fu&quot;&gt;removeFirst&lt;/span&gt;();

            &lt;span class=&quot;co&quot;&gt;//看看池的大小&lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());

            &lt;span class=&quot;co&quot;&gt;//返回一个动态代理对象&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Connection) Proxy.&lt;span class=&quot;fu&quot;&gt;newProxyInstance&lt;/span&gt;(Demo1.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;(), connection.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInterfaces&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InvocationHandler() {

                &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {

                    &lt;span class=&quot;co&quot;&gt;//如果不是调用close方法，就按照正常的来调用&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;close&quot;&lt;/span&gt;)) {
                        method.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(connection, args);
                    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {

                        &lt;span class=&quot;co&quot;&gt;//进到这里来，说明调用的是close方法&lt;/span&gt;
                        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(connection);

                        &lt;span class=&quot;co&quot;&gt;//再看看池的大小&lt;/span&gt;
                        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());

                    }
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                }

            });
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;我们上面已经能够简单编写一个线程池了。下面我们来使用一下开源数据库连接池&lt;/p&gt;
&lt;h2 id=&quot;dbcp&quot;&gt;DBCP&lt;/h2&gt;
&lt;p&gt;使用DBCP数据源的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;导入两个jar包【Commons-dbcp.jar和Commons-pool.jar】&lt;/li&gt;
&lt;li&gt;读取配置文件&lt;/li&gt;
&lt;li&gt;获取BasicDataSourceFactory对象&lt;/li&gt;
&lt;li&gt;创建DataSource对象&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; DataSource dataSource = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;//读取配置文件&lt;/span&gt;
            InputStream inputStream = Demo3.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;dbcpconfig.properties&quot;&lt;/span&gt;);
            Properties properties = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Properties();
            properties.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(inputStream);

            &lt;span class=&quot;co&quot;&gt;//获取工厂对象&lt;/span&gt;
            BasicDataSourceFactory basicDataSourceFactory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BasicDataSourceFactory&lt;/span&gt;();
            dataSource = basicDataSourceFactory.&lt;span class=&quot;fu&quot;&gt;createDataSource&lt;/span&gt;(properties);

        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dataSource.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();

    }

    &lt;span class=&quot;co&quot;&gt;//这里释放资源不是把数据库的物理连接释放了，是把连接归还给连接池【连接池的Connection内部自己做好了】&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(Connection conn, Statement st, ResultSet rs) {

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (rs != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                rs.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
            rs = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (st != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                st.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }

        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (conn != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                conn.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }

        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;c3p0&quot;&gt;C3P0&lt;/h2&gt;
&lt;p&gt;C3P0数据源的性能更胜一筹，并且它可以&lt;strong&gt;使用XML配置文件配置信息！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;导入开发包【c3p0-0.9.2-pre1.jar】和【mchange-commons-0.2.jar】&lt;/li&gt;
&lt;li&gt;导入XML配置文件【可以在程序中自己一个一个配，C3P0的doc中的Configuration有XML文件的事例】&lt;/li&gt;
&lt;li&gt;new出ComboPooledDataSource对象&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ComboPooledDataSource comboPooledDataSource = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;//如果我什么都不指定，就是使用XML默认的配置，这里我指定的是oracle的&lt;/span&gt;
        comboPooledDataSource = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ComboPooledDataSource&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;oracle&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; comboPooledDataSource.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;tomcat数据源&quot;&gt;Tomcat数据源&lt;/h2&gt;
&lt;p&gt;Tomcat服务器也给我们提供了连接池，内部其实就是DBCP&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在META-INF目录下配置context.xml文件【文件内容可以在tomcat默认页面的 JNDI Resources下Configure Tomcat's Resource Factory找到】&lt;/li&gt;
&lt;li&gt;导入Mysql或oracle开发包到tomcat的lib目录下&lt;/li&gt;
&lt;li&gt;初始化JNDI-&amp;gt;获取JNDI容器-&amp;gt;检索以XXX为名字在JNDI容器存放的连接池&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;context.xml文件的配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&amp;lt;Context&amp;gt;

  &amp;lt;Resource name=&lt;span class=&quot;st&quot;&gt;&quot;jdbc/EmployeeDB&quot;&lt;/span&gt;
            auth=&lt;span class=&quot;st&quot;&gt;&quot;Container&quot;&lt;/span&gt;
            type=&lt;span class=&quot;st&quot;&gt;&quot;javax.sql.DataSource&quot;&lt;/span&gt;
            
            username=&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;
            password=&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;
            driverClassName=&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;
            url=&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql://localhost:3306/zhongfucheng&quot;&lt;/span&gt;
            maxActive=&lt;span class=&quot;st&quot;&gt;&quot;8&quot;&lt;/span&gt;
            maxIdle=&lt;span class=&quot;st&quot;&gt;&quot;4&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/Context&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

            &lt;span class=&quot;co&quot;&gt;//初始化JNDI容器&lt;/span&gt;
            Context initCtx = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InitialContext();

            &lt;span class=&quot;co&quot;&gt;//获取到JNDI容器&lt;/span&gt;
            Context envCtx = (Context) initCtx.&lt;span class=&quot;fu&quot;&gt;lookup&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;java:comp/env&quot;&lt;/span&gt;);

            &lt;span class=&quot;co&quot;&gt;//扫描以jdbc/EmployeeDB名字绑定在JNDI容器下的连接池&lt;/span&gt;
            DataSource ds = (DataSource)
                    envCtx.&lt;span class=&quot;fu&quot;&gt;lookup&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jdbc/EmployeeDB&quot;&lt;/span&gt;);

            Connection conn = ds.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(conn);

        } 
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;dbutils它是对JDBC的简单封装，极大简化jdbc编码的工作量&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;dbutils类&quot;&gt;DbUtils类&lt;/h2&gt;
&lt;p&gt;提供了&lt;strong&gt;关闭连接，装载JDBC驱动，回滚提交事务等方法&lt;/strong&gt;的工具类【比较少使用，因为我们学了连接池，就应该使用连接池连接数据库】&lt;/p&gt;
&lt;h2 id=&quot;queryrunner类&quot;&gt;QueryRunner类&lt;/h2&gt;
&lt;p&gt;该类&lt;strong&gt;简化了SQL查询，配合ResultSetHandler使用，可以完成大部分的数据库操作&lt;/strong&gt;，重载了许多的查询，更新，批处理方法。大大减少了代码量&lt;/p&gt;
&lt;h2 id=&quot;resultsethandler接口&quot;&gt;ResultSetHandler接口&lt;/h2&gt;
&lt;p&gt;该接口&lt;strong&gt;规范了对ResultSet的操作&lt;/strong&gt;，要对结果集进行什么操作，传入ResultSetHandler接口的实现类即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayHandler：把结果集中的第一行数据转成对象数组。&lt;/li&gt;
&lt;li&gt;ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。&lt;/li&gt;
&lt;li&gt;BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。&lt;/li&gt;
&lt;li&gt;BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。&lt;/li&gt;
&lt;li&gt;ColumnListHandler：将结果集中某一列的数据存放到List中。&lt;/li&gt;
&lt;li&gt;KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。&lt;/li&gt;
&lt;li&gt;MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。&lt;/li&gt;
&lt;li&gt;MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List&lt;/li&gt;
&lt;li&gt;ScalarHandler 将ResultSet的一个列到一个对象中。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;使用DbUtils框架对数据库的CRUD&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;* 使用DbUtils框架对数据库的CRUD&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;* 批处理&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;* */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Test {

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;INSERT INTO student (id,name) VALUES(?,?)&quot;&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;//我们发现query()方法有的需要传入Connection对象，有的不需要传入&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//区别：你传入Connection对象是需要你来销毁该Connection，你不传入，由程序帮你把Connection放回到连接池中&lt;/span&gt;
        queryRunner.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{&lt;span class=&quot;st&quot;&gt;&quot;100&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;zhongfucheng&quot;&lt;/span&gt;});

    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;()&lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT * FROM student&quot;&lt;/span&gt;;

        List list = (List) queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanListHandler&lt;/span&gt;(Student.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());

    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;DELETE FROM student WHERE id='100'&quot;&lt;/span&gt;;

        queryRunner.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql);
    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE student SET name=? WHERE id=?&quot;&lt;/span&gt;;

        queryRunner.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{&lt;span class=&quot;st&quot;&gt;&quot;zhongfuchengaaa&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;});
    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;batch&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;INSERT INTO student (name,id) VALUES(?,?)&quot;&lt;/span&gt;;

        Object[][] objects = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;][];
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {
            objects[i] = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{&lt;span class=&quot;st&quot;&gt;&quot;aaa&quot;&lt;/span&gt;, i + &lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;};
        }
        queryRunner.&lt;span class=&quot;fu&quot;&gt;batch&lt;/span&gt;(sql, objects);
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;分页技术是非常常见的，&lt;strong&gt;在搜索引擎下搜索页面，不可能把全部数据都显示在一个页面里边&lt;/strong&gt;。所以我们用到了分页技术。&lt;/p&gt;
&lt;h2 id=&quot;oracle实现分页&quot;&gt;Oracle实现分页&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      Oracle分页语法：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        @lineSize---每页显示数据行数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        @currentPage----当前所在页&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; *FROM (
        &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; 列名,列名,&lt;span class=&quot;kw&quot;&gt;ROWNUM&lt;/span&gt; rn
        &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; 表名
        &lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; ROWNUM&amp;lt;=(currentPage*lineSize)) temp
    
    &lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; temp.rn&amp;gt;(currentPage&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;)*lineSize;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Oracle分页原理简单解释&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      Oracle分页：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        Oracle的分页依赖于ROWNUM这个伪列，ROWNUM主要作用就是产生行号。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      分页原理：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：子查询查出前n行数据，ROWNUM产生前N行的行号&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2：使用子查询产生ROWNUM的行号，通过外部的筛选出想要的数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      例子：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        我现在规定每页显示5行数据【lineSize=5】，我要查询第2页的数据【currentPage=2】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        注：【对照着语法来看】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      实现：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：子查询查出前10条数据【ROWNUM&amp;lt;=10】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2：外部筛选出后面5条数据【ROWNUM&amp;gt;5】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        3：这样我们就取到了后面5条的数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;mysql实现分页&quot;&gt;Mysql实现分页&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      Mysql分页语法：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      @start---偏移量，不设置就是从0开始【也就是(currentPage-1)*lineSize】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      @length---长度，取多少行数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; *
    &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; 表名
    &lt;span class=&quot;kw&quot;&gt;LIMIT&lt;/span&gt; [&lt;span class=&quot;kw&quot;&gt;START&lt;/span&gt;], &lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      例子：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        我现在规定每页显示5行数据，我要查询第2页的数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      分析：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：第2页的数据其实就是从第6条数据开始，取5条&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      实现：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：start为5【偏移量从0开始】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2：length为5&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mysql从(currentPage-1)*lineSize开始取数据，取lineSize条数据&lt;/li&gt;
&lt;li&gt;Oracle先获取currentPage&lt;em&gt;lineSize条数据，从(currentPage-1)&lt;/em&gt;lineSize开始取数据&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;使用jdbc连接数据库实现分页&quot;&gt;使用JDBC连接数据库实现分页&lt;/h2&gt;
&lt;p&gt;下面是常见的分页图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/XiVdAWv.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;配合图片，看下我们的需求是什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;算出有多少页的数据，显示在页面上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据页码，从数据库显示相对应的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;算出有多少页数据这是非常简单的【在数据库中查询有多少条记录，你每页显示多少条记录，就可以算出有多少页数据了】&lt;/li&gt;
&lt;li&gt;使用Mysql或Oracle的分页语法即可&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过上面分析，我们会发现需要用到4个变量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;currentPage--当前页【由用户决定的】&lt;/li&gt;
&lt;li&gt;totalRecord--总数据数【查询表可知】&lt;/li&gt;
&lt;li&gt;lineSize--每页显示数据的数量【由我们开发人员决定】&lt;/li&gt;
&lt;li&gt;pageCount--页数【totalRecord和lineSize决定】&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;//每页显示3条数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;//总记录数&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; totalRecord = &lt;span class=&quot;fu&quot;&gt;getTotalRecord&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//假设用户指定的是第2页&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; currentPage = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;//一共有多少页&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pageCount = &lt;span class=&quot;fu&quot;&gt;getPageCount&lt;/span&gt;(totalRecord, lineSize);

        &lt;span class=&quot;co&quot;&gt;//使用什么数据库进行分页，记得要在JdbcUtils中改配置&lt;/span&gt;
        List&amp;lt;Person&amp;gt; list = &lt;span class=&quot;fu&quot;&gt;getPageData2&lt;/span&gt;(currentPage, lineSize);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Person person : list) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(person);
        }

    }

    &lt;span class=&quot;co&quot;&gt;//使用JDBC连接Mysql数据库实现分页&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Person&amp;gt; &lt;span class=&quot;fu&quot;&gt;getPageData&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; currentPage, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//从哪个位置开始取数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; start = (currentPage - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) * lineSize;

        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT name,address  FROM person LIMIT ?,?&quot;&lt;/span&gt;;

        List&amp;lt;Person&amp;gt; persons = (List&amp;lt;Person&amp;gt;) queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanListHandler&lt;/span&gt;(Person.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{start, lineSize});
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; persons;

    }

    &lt;span class=&quot;co&quot;&gt;//使用JDBC连接Oracle数据库实现分页&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Person&amp;gt; &lt;span class=&quot;fu&quot;&gt;getPageData2&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; currentPage, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//从哪个位置开始取数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; start = (currentPage - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) * lineSize;

        &lt;span class=&quot;co&quot;&gt;//读取前N条数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; end = currentPage * lineSize;

        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  name, &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  address &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;FROM ( &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  SELECT &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;    name, &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;    address , &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;    ROWNUM rn &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  FROM person &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  WHERE ROWNUM &amp;lt;= ? &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;)temp WHERE temp.rn&amp;gt;?&quot;&lt;/span&gt;;

        List&amp;lt;Person&amp;gt; persons = (List&amp;lt;Person&amp;gt;) queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanListHandler&lt;/span&gt;(Person.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{end, start});
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; persons;

    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getPageCount&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; totalRecord, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize) {

        &lt;span class=&quot;co&quot;&gt;//简单算法&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//return (totalRecord - 1) / lineSize + 1;&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;//此算法比较好理解，把数据代代进去就知道了。&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; totalRecord % lineSize == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ? (totalRecord / lineSize) : (totalRecord / lineSize) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;

    }


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;getTotalRecord&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//使用DbUtils框架查询数据库表中有多少条数据&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT COUNT(*) FROM person&quot;&lt;/span&gt;;

        Object o = queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ScalarHandler&lt;/span&gt;());

        String ss = o.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;  s = Integer.&lt;span class=&quot;fu&quot;&gt;parseInt&lt;/span&gt;(ss);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; s;
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，&lt;strong&gt;可以关注微信公众号:Java3y。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 19 Feb 2018 13:27:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8454470.html</dc:identifier>
</item>
<item>
<title>ORM规约变更经典案例---mysql军规 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8454209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8454209.html</guid>
<description>&lt;p&gt;　　先介绍一下《&lt;span id=&quot;doc-tittle-0&quot;&gt;MySQL数据库开发的三十六条军规》，这里只介绍核心的，具体内容大家可以自行百度，这是从底层开发人员到管理者必须知道规范。出自58赶集。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
写在前面的话：
　　总是在灾难发生后，才想起容灾的主要性；
　　总是在吃过亏后，才记得有人提醒过。&lt;br/&gt;核心军规：
      不在数据库做计算，CPU计算务必移至业务层；
      控制单表数据量，单表记录控制在千万级；
      控制列数量，字段数控制在20以内；
      平衡范式与冗余，为提高效率可以牺牲范式设计，冗余数据；
      拒绝3B(big)，大SQL、大数据、大批量
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　介绍两个例子。这个适合用STAR法则。STAR法则是情境(situation)、任务(task)、行动(action)、结论(result)四项的缩写。STAR法则是一种常常被面试官使用的工具。一般常说的开放性的问题，就是设立一个场景怎样解决问题基本用的是这种工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;案例1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是我们组发生的一个真实例子，具体操作和调研是由我两个同事实施的。&lt;/p&gt;
&lt;p&gt;情境：&lt;/p&gt;
&lt;p&gt;　　核心交易目前在进行代码重构，数据模型的重构是其中重要的一个环节。一天我们同事在进行DDL(Data Defination Lauguage)的变更，由于两个字段比较相近，但是其中一个是原有字段不可为空，另外一个是新增字段，允许为空，结果空字段被赋值给了非空字段，DDL执行导致大量异常。DDL变更回滚后日志恢复正常。&lt;/p&gt;
&lt;p&gt;任务：&lt;/p&gt;
&lt;p&gt;　　从java程序到连接mysql数据库用到了atlas、mybatis、数据库驱动到达mysql数据。而字段的映射是mybatis这样的ORM(Object Ralational Mapping)框架来处理的，我们的任务就是分析mybatis的源码和配置，找到问题的根源和以后要注意的事项。　&lt;/p&gt;
&lt;p&gt;行动：&lt;/p&gt;
&lt;p&gt;　　下载mybatis源码进行调试、分析。当前生产环境中，Mybatis版本是3.2.8.&lt;/p&gt;
&lt;p&gt;　　在使用mybatis时，有时可以不定义resultMap，直接在&amp;lt;select&amp;gt;语句上指定resultType。此时涉及到Mybatis的结果集自动映射。Mybatis的自动映射。Mybatis的自动映射默认开启。分析源码理解mybatis结果自动映射原理：&lt;/p&gt;
&lt;p&gt;　　1. mybatis自动映射预处理流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201802/1112728-20180219194440616-1159301287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.自动映射流程(applyAutomaticMappings方法)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201802/1112728-20180219195108894-783525886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　  就是说applyAutomaticMappings要用到两个配置参数：mapUnderscoreToCamelCase和callSettersOnNulls。&lt;/p&gt;
&lt;p&gt;　　mapUnderscoreToCamelCase:是否开启驼峰命名。开启后会对大小写、下划线均不敏感。&lt;/p&gt;
&lt;p&gt;      callSettersOnNulls:是否在该字段值为null时将结果同时反射set赋值方法进行赋值。&lt;/p&gt;
&lt;p&gt;　　3. 自动驼峰命名规则测试实验&lt;/p&gt;
&lt;table class=&quot;wrapped fixed-table confluenceTable&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th class=&quot;confluenceTh&quot;&gt;实体属性&lt;/th&gt;
&lt;th class=&quot;confluenceTh&quot;&gt;字段名&lt;/th&gt;
&lt;th class=&quot;confluenceTh&quot;&gt;是否自动驼峰命名&lt;/th&gt;
&lt;th class=&quot;confluenceTh&quot;&gt;是否可以赋值&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;deviceId&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;device_id&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;赋值给deviceId&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;deviceId&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;device_id&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;false&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;没有赋值给deviceId&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;
&lt;p&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;traceNo&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;赋值给traceNo&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;
&lt;p&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;traceNo&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;trace_no&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;false&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;都没有进行赋值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;
&lt;p&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;traceNo&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;trace_no&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;赋值给traceNo&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;　　在映射时会先把没有在resultMap中定义字段映射的字段按照名称相同的方式自动映射到返回类型的对应属性上。自动映射会忽略下划线和大小写。&lt;/p&gt;
&lt;p&gt;　　Mybatis settings配置项说明应该仔细研读。&lt;/p&gt;
&lt;p&gt;　　字段定义各个字段之间的区分要尽可能的大，严禁使用只有大小写和下划线不同的两个字段。&lt;/p&gt;

&lt;p&gt;　　我们现在在做分享会和读书会，我的想法是这些学习活动要尽量贴近项目，做有深度的学习。代码是随便找个人培训一下就可以写的，但是写出代码的效率和可维护性等代码质量的要求决定了大公司对初级程序员要求的门槛。而对所有技术研究的深度决定了突发问题的解决能力，对后续的建设提出的指导和建议。&lt;/p&gt;

&lt;p&gt;案例2：&lt;/p&gt;
&lt;p&gt;　　《逆流而上》里介绍的一个案例。&lt;/p&gt;
&lt;p&gt;情境：&lt;/p&gt;
&lt;p&gt;　　在某次项目发布阶段（数据库使用了分库分表），因为业务需要新增表字段，从SQL的代码逻辑来看，使用了select *，新增字段应该是兼容的，但在做线上数据库DDL操作后，立即出现了日志错误数飙升报警。当回滚还未执行，日志错误就已经自动恢复。&lt;/p&gt;
&lt;p&gt;任务：&lt;/p&gt;
&lt;p&gt;　　从问题的现象来看，这个问题只有在变更过程中才出现，不太像是结果集映射问题，如果是映射问题，不执行回滚时无法自动恢复的。DBA反馈，可能是TDDL(Taobao Dustributed Data Layer分布式数据访问引擎)层对Select * 的解析逻辑引起DDL变更的不兼容。我们的任务就是确认问题发生的真正原因和对以后的指导意义。&lt;/p&gt;
&lt;p&gt;行动（分析过程）：&lt;/p&gt;
&lt;p&gt;　　1. TDDL在执行的时候，碰到select *,会从数据库表中解决出对应的全部字段：取第一个库的第一个表进行解析，解析之后，会缓存结果。替换*，然后在吧解析后的SQL语句交到目标数据库执行。&lt;/p&gt;
&lt;p&gt;　　2. 在第一个库变更后，TDDL拿到最新的字段列表，后续一段时间内的查询，都直接用带有新增字段的SQL语句提交到数据库执行；由于有部分数据库还没执行变更，没有新的字段，导致数据库执行出错，无法查询数据。&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt; 　　对于此问题是分库分表中，持久层框架无对select *的兼容逻辑导致。&lt;/p&gt;
&lt;p&gt;　　但是使用select *的弊端不限于此，比如select * 查询非必需字段，会造成资源浪费甚至影响服务器性能；增加SQL的解析成本；表结构变更可能会引起字段映射问题；不会使用覆盖索引，不利于查询的性能优化等。&lt;/p&gt;
&lt;p&gt;　　《阿里巴巴编程规约》中对于ORM规范，有明确一条强制规约：在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明。&lt;/p&gt;

&lt;p&gt;　　很多人问过我学习方法的问题，我觉得把这些基本规约和军规仔细研读，在平时的工作中多总结实践，也可以算作一个初级或者中级程序员的亮点了。技术追求体现在解决不了的问题追究到底，了解不了的问题研究到底。项目中问题不是天天有，但是这些理论怎样和实际结合确是天天要面对的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跑题时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　周末，男神在看电视，我照例在旁边垫子上一边做瑜伽一边陪看电视。看的是一部很老的电影《叶问前传》。看完之后我就跟男神分享心得：“你看叶问看起来正直厚道的一个人，做起事情来很讲究方法。想搞定女友，人家先搞定女友他爹。最后女友舍身救叶问，也得到了他爹实际上的支持。”&lt;/p&gt;
&lt;p&gt;　　女孩子和男孩子真的是来自两个星球。我看一个片子通常会想很多。但是我说出来的必定和实际发生的事情有一定的联系。但是男孩子通常是看不出来的。比如我跟男神说的上面的心得。是因为前一天晚上我俩聊天，他说看到一个姑娘比我还要超凡脱俗。&lt;/p&gt;
&lt;p&gt;　　我说你真要和她在一起，知道了她每月要买多少化妆品你就不这么想了。女孩子多半人前人后不一样。&lt;/p&gt;
&lt;p&gt;      男神说如果在外面见到我，可能没有那么喜欢我。我在外面看起来滑头滑脑的。&lt;/p&gt;
&lt;p&gt;　　我心想自己在外人看来基本上算是老年痴呆，但是职业习惯，见什么人说什么话。不然男神不爱吱声，我又不说话，我俩在别人看来简直一对怪胎。我也不点破，只对男神说：“你用词不当，这个词应该是‘古灵精怪’”。&lt;/p&gt;
&lt;p&gt;　　后来他说想找个小尼姑当小老婆。看样子他还是不太认同，觉得还是应该自己是一根木头，外面看起来就应该是一根木头，也不顾及别人跟你这根木头打交道到底会不会尴尬。&lt;/p&gt;
&lt;p&gt;　　所以我会有机会就旁敲侧击一下：做人要遵从本心，做事要灵活。&lt;/p&gt;
</description>
<pubDate>Mon, 19 Feb 2018 12:47:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8454209.html</dc:identifier>
</item>
<item>
<title>画与软件项目 - draculav</title>
<link>http://www.cnblogs.com/saaav/p/6486532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saaav/p/6486532.html</guid>
<description>&lt;p&gt; 　　这篇博客开始写很久了，都已经在我随笔列表的第三页了，然而因为各种原因一直拖着没有写完，所以下面可能出现的最近未必是真的最近。还有最喜欢的两幅画没放进来，有些遗憾，分别是现藏于中国美术馆的万山红遍层林尽染和常熟田。因为一个意外的契机开始，很长时间以来不断的去各种画展，有美术馆、画院，也会去私人的画廊。虽然看不懂，但是毕竟好看的不好看还是能看出来的、赏心悦目，懂不懂什么的......。艺术可以触动人的感性思维，我就属于感性思维有缺陷的，期望能被艺术品感染一下，弥补点这方面的缺陷，或许也能借他山之石在技术方面有所感悟也未可知......吧，总之既然能感受其中的美目前也就足够了，就像某个段子说的，喜欢吃冰淇淋并不需要先学会制冷。看的时间长了就会有一些与自己工作相关的感触。另外，在听一些数学、力学课的时候，偶尔会意外得听到一些关于艺术的认识，我觉得很适合先给大家看一下。&lt;/p&gt;
&lt;p&gt;　　莱布尼茨：音乐，是人类精神通过无意识计算而获得的愉悦享受。&lt;/p&gt;
&lt;p&gt;　　下面这张图是我听清华力学课的时候，截下来的一张截图：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180218153626608-2120122215.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　别的不多说，只说经常在美术馆听到的一类评价，这画画的真像。我个人是觉得画得像应该是相机出现以前的事，之后更多的应该是画家在画中表现出的感悟，或者某些画面对画家的触动，这类甚至在有些摄影艺术中也难以展现出来的令人&quot;愉悦&quot;的&quot;无意识计算&quot;。&lt;/p&gt;
&lt;p&gt;　　画家以画展示所思所感，观者因画中感性被画家心境引导出自己的心境。其实我们做需求的时候多数也是这样的，让客户提需求，很难能提出什么来，但是你做出点东西以后，他就会有这样那样的想法，这样那样的改法，相对这句话我们就是画作者，客户就是观者，我们需要引导出客户的真实需求，是想提高办公效率还是辅助标准化办公流程，我真实遇到过一个项目，客户提出的需求和最终的目的有一定冲突，事实上多数项目都有这种问题，只是有时候不难么明显，不过频繁修改的需求很多都是这种原因。&lt;/p&gt;
&lt;p&gt;　　关于开头的第一句话：“画家以画展示所思所感，观者因画中感性被画家心境引导出自己的心境”。太宗以史为鉴，我现在有机会以画为鉴，品味被画家引导出的自己的心境。以观者的角度体味能被画引导出的对自己的认识，凡事需先认清自己，方能择一适自己所行之路。有了需求就需要开始选型，能从画中发现自己有什么能与之共鸣，我们要使用什么样的技术和框架帮助自己完成项目，选择之前就要首先认清自己，擅长什么、能多大程度上使用从未接触的技术、团队的技术组成、人员性格、配合的默契程度等等。&lt;/p&gt;
&lt;p&gt;　　明确了自身的情况，也更容易设计出自己团队可以完成的业务模型，并在期限内完成它。由于接连不断的去看画，总是有新的想法，所以改了很多次，原本打算在博客最后引出的我对贴在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/saaav/p/4548019.html&quot;&gt;DDD初学指南&lt;/a&gt;&lt;span class=&quot;postTitle2&quot;&gt;的对评论的回答，但是由于某天看了王衍成先生的画，于是我决定在这部分写了。关于“&lt;code class=&quot;csharp plain&quot;&gt;业务模型更接近现实&lt;/code&gt;”这回事，其实早几年我也是这么想的，但是逐渐改变了看法，业务模型应该是为了更好完成我们的系统而设计的。粗略的看上去似乎并不冲突，但目的不同，结果也会有很大不同。首先，业务模型是抽象的，是为了表达系统最终目的而做出的只为完成系统的目的抽象。相对的”更接近现实“这种说法更贴近于实现。并且现实方方面面就像米特奥拉说的“这个世界的信息是多层次的，无论多无聊的信息都不会用单一的表达形式，存在这样的复杂性”，而好的业务模型一定是以最精简的抽象来表达系统所要完成的目标，比如王先生的这幅画：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201704/445166-20170426165359709-439519654.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实开始没什么感觉，只觉得是水边倒影，直到走到这个角度：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170501145337679-2064396635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说句实在话，走到这个角度，其实我也完全不知道他在画什么，但是这时这幅画突然给我一种林间小路的感觉，虽然本来觉得更像是水面，不过感觉到了上午紧张工作的大脑突然放松了，不管作者究竟想表达什么，看画人有所触动也就够了，就像某些阅读理解的答案中常说的：留给读者无限的想象空间。画通过画家对所画之物的抽象来表达画的核心，软件通过业务逻辑的抽象来体现软件的核心价值。&lt;/p&gt;
&lt;p&gt;　　王先生的画几乎画名都是无题，他应该只是想传达他的一种感性，一种体会到的感觉，并不想说明白那是什么，其实感性很多时候是没法说明白的，所以才说是无意识的计算，只要目的达到了，究竟画的是什么不太重要。软件模型也是，最重要的不是设计出了什么，而是是否完成了目标，模型是手段，手段通常是不应该喧宾夺主的。当然，这并不是说手段不重要，画的名字本身就是落在画之外的一种手段：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170501150802007-948220095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　画名很多时候是核心概念的表达，相对于软件是系统的核心价值，业务方的表达倾向于描述现实他们需要的功能，而这可能并不是软件真正的需求，有时候在需求说明书的不起眼套路段落中，有时候甚至不会出现。他们的目的或许是加快工作效率，或许是限制职能权限，或许是调整业务方向，如果不确认好真正的目的，只按他们对现实的描述去做，绝大多数时候会导致后期大幅调整，这一点不只是业务，在技术理论中也是一样的，某一处差之毫厘，整个系统谬以千里。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201707/445166-20170713165448259-1531570608.png&quot; alt=&quot;由于总是在看画，所以这博客写的不免有些臃肿，然而忍不住啊，这画说实在初看没什么感觉，然而一看名字，乾坤一草堂，再看画面，以草堂为中心顿感草堂之简与画面自然映照，一种我描述不好的美感与心中产生。&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这画说实在初看时没什么感觉，然而一看名字，乾坤一草堂，再看画面，以草堂为中心顿感草堂之简与画面自然映照，其草堂当为诗人画家观湖光山色之处，满幅乾坤图尽收与草堂之中，顿感豪气，令人精神振奋。名字之重要程度可见一斑。而做需求的时候也不能仅仅关注系统之内的功能，系统之外的主题更是核心。&lt;/p&gt;
&lt;p&gt;　　王先生的画对我们来说可能有些太抽象了，我们来看一个不那么抽象的，并且有名字的：&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170501145421351-1851263875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这幅画也是在中国美术馆看到的，时间由点长了，没记错的话画名叫蓝天，作者是张立国先生。这幅画最重要的部分很显然左上角的一小块蓝天，能说明它是蓝天模型的也只有一小块云，或者还有它的位置，然而已经足够表现出它作为核心子领域的业务概念了；这幅画的架构清晰，表达出来的业务对象也非常明确，但并没有去逐渐贴近现实去建模；三面围墙（姑且认为是墙吧）和墙下之人以及一点蓝天就是整幅画，画中之人或许在望天或许是渴望轻松自然；墙的颜色不同，也或许是现代化的生活筑起的高墙隔开了人与人之间的关系，然而他们或许都是向往着同一片蓝天，当然三人也可能在同一件屋子中。至于究竟如何，或许不重要，每个人的触动或许也是如人饮水冷暖自知，看懂画家在画什么并不重要，只要对画有所触动，便也算没有白看，画的价值也在与此。清晰的架构和业务模型，更利于表达相对清晰的感情，至少我的感想被限定在了一个小范围内，而王先生那副画，有时看着像林间小路，有时候又觉得草树池塘，偶尔还会春绿秋黄，但一切都是为了最终目的，无题亦是主题，不能因为技术洁癖或对模型本身的最求而使目标有所偏差。一幅画要想感染人，我想画家并不是单纯的只想画得像，不然照照片就可以了；软件同样如此，我们开发软件目的并不是要让它做出现实人做的事，而是让用户借助它更好的完成工作。&lt;/p&gt;
&lt;p&gt;　　刚刚提到了，好的模型一定是最简化的模型，大家都明白这个道理，但是做的时候，经常会不自觉的为了让模型看起来逻辑上更完整，更“合理”而增加些东西，例如群里曾经讨论过论坛帖子的回复是否要作为帖子聚合的对象，因为帖子删了，回复的存在可能就没有意义了，但是这个看起来逻辑上更完整的约束是否有价值就未必了。1+1=2，是因为抽象出了现实中的数量这一属性，但是如果一个1是男人，另外一个是女性，这1+1极有可能结果会是3，然而数学可不能这么算，所以业务模型的抽象与真实的现实，并不一定要统一。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201703/445166-20170321211356221-1901870290.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是在一家私人画廊看的，虽然不是画，不过也差不多，关于这件作品的讲解：http://www.vart.cc/guides/1141?fragment=9799，我也不多介绍了。此作品的作者农西奥的一句名言，大家有没有觉得比较熟悉。。。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201703/445166-20170321211100580-922909301.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到这可以先小结一下开篇的那个问题了，模型未必应该贴近现实，而是抽象出现实的某一部分，其实这也并不是很贴切，模型的目的是为了更好的实现整个系统，只是一般情况下这样更容易开发而已，关于部分抽象这事可以看一下下面的作品与现实的对比，我就不多说了，更何况一个完全不按现实去抽象的模型就一定不利于系统开发么，面向对象出现以前就没有好的软件系统么？&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201707/445166-20170709173050493-1218178171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图为潘天寿先生的画与原型对比。其实前些天公司组织去长城拓展，我拍的照片总觉得不好看，一度非常怀疑我莱卡的镜头，后来想明白了：之所以看着很好看，但拍出来效果不好是因为人会选择性忽略一些不重要的东西，相机不会，所以有电线等东西照进来，所以会感觉没看到的好看，经常在美术馆拍的画也是，现场看很漂亮，但是很多画是在玻璃保护中，玻璃的反光导致照下来的根本看不出效果。所以画也好我们的模型也好，如果想要满意，该忽略的东西无论在现实中多重要都是要忽略的。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170531184936383-1370704254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个问题我的看法大概就是这样了，似乎这个结并不怎么小，不过就不要在意这些细节了。&lt;/p&gt;
&lt;p&gt;　　开篇就是一张抽象画可能不是很容易找到方向欣赏画。其实小学就学过，万物都是有联系的。画和程序都是人创作出来的，既然不懂美术，可以试着从软件的角度来欣赏一副画，即使和原作者想表达的不同，只要能有所得就不算白看了，就像nginx，本来是个静态服务器，但是有几个人真是从静态服务器的角度用的。&lt;/p&gt;
&lt;p&gt;　　最容易看明白的画当属素描了（其他如静物画和油画也多包涵浓重的感情色彩），我之所以觉得素描的传达的感情色彩少，主要是因为它多是一种记录写实，是真正作品创作前的一个标记，用来引导艺术家回忆起当时的感觉（不算学生练笔的），毕竟直接在荒山野岭画出成品来即使有素描版，多半也不会展出，我反正是没见过。也不是说素描一点感情色彩都没有，当然是有一定倾向的，但是我看不出来（极个别除外），手里画的图片太多了，常见的铅笔素描没翻到，但是找到了几张水墨写生：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180219105932517-401248640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　素描很多时候看不出，我个人觉得可能也不需要看出画家想表达什么，多是对应成品来欣赏的，虽然这两幅也不是完全没有韵味。在软件中，这类还比较多，比如一些通用的开源框架，如Spring Boot，它没有业务含义，但作为一个可以拿过来就用组件也是非常不错的，本身也是相当不错的架构。&lt;/p&gt;
&lt;p&gt;　　基础设施在有一定的业务倾向，甚至于需求讨论之前就可以进行，但可能是伴随着业务的开发才逐步完成的。关于业务模型的建立和落实到开发上，多数现在还是一个并列的过程，一次性设计一个完整的模型，之后再按着模型按部就班的开发。但是这种方式其实是几十年前的经典，在一定规模下，还是成功的。而现在已经不再是那个时代了，市场瞬息万变，政策也总在调整，需求无法一成不变。若是一个工期一年以上的项目，按第一版出的模型去做，股市可能都差了几千点了。其实，画画也是需要一遍一遍迭代的。&lt;/p&gt;
&lt;p&gt;                                              &lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201704/445166-20170425162813928-149375049.jpg&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　先有一个大体方向，然后从主要部分开始，一点一点的丰满，再细化迭代。我试验过一些建模和落地的理论，其中在项目中最成功的应该属于测试驱动+T型功能导向集成（在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/saaav/p/3936902.html&quot;&gt;功能构建&lt;/a&gt;中描述过）。比如人像，脸当然是最重要的部分，于是先构造出头部轮廓，再以头部轮廓为基础，逐渐延展开来。对于开发，我们就先开发最核心、稳定的模型和功能，以此为基础，逐渐开展相关的模型和功能，并根据实际情况逐渐调整，比如今天碳...不够...黑，就多图两笔...什么的。测试驱动开发也是一个非常好的实践，很适合辅助功能导向的集成。以单元测试组成业务的结构，也就是画的轮廓组成，最初的被测试方法内部可能只是返回了个伪造的结果，过程中也不一定时时刻刻都是完善的，脸第一次上色的第四幅看上去并不怎么好看，集成测试开始后，结合整个画面也可以看出到了第五幅脸似乎颜色有些过重了，就根据当时的具体情况对功能做一定的调整，为了项目的顺利完成，对需求和功能甚至于模型进行适当的删减调整也是必要的。当集成测试完成，色彩填充画的各部分的精神被联结起来，被单元测试过的代码内部实现丰满连通，画就完成了。&lt;/p&gt;

&lt;p&gt;                           &lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180219111104767-1364046702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　                           　&lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180219111218314-246837475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实，我本来是想用齐白石老先生的草稿来着，那一系列草稿更明显更丰富，然而我没找到，那些草稿在画院，偶尔会展出，碰到的时候再说吧。对于上面这画，人像应该就属于核心子域，但是只有一个核心是不成的，其实经常也能看到一些不错的话，但是画面不够丰满，给人的感觉总想缺了什么的。 对这幅画来说，画面上的题字恰到好处。软件架构通常也是围绕着业务核心，延展出各个通用子领域，各部分相互独立，但并不能缺少。一旦某部分的业务膨胀，也可以将其独立为一个上下文，它对于原有系统是一个支持子域，对于自身也是一个核心子域。也有遇到过这种情况，一幅画上的题字特别漂亮，大家都不去关心主要部分的画，而是看字了，而既然被展出了，就说明了其艺术价值。这种情况也并不是坏事，比如互联网企业本身就是随着市场发展而变化，比如只去京东和亚马逊自营买东西，大家也少不了用支付宝。&lt;/p&gt;
&lt;p&gt;　　核心子域和非核心子域在开发中投入的比重也未必一定是核心最重，比如上面的乾坤一草堂。我们在做项目的时候，每一层面都是在找一个平衡，因为平衡并不是有固定规律的，所以很多书才会说，软件是门艺术。我在网上听清华大学数学建模课程的时候，姜启源教授曾讲过，技术大致有章可循，而艺术无法归纳成普遍使用的准则。虽然姜教授是在讲数学建模，但我认为贯穿整个项目的每一个部分都是这样的，无论是需求与开发团队资源之间的平衡、模型距离现实远近之间的平衡，还是开发时实现的优雅与性能之间的平衡（当然，个别时候未必不可兼得）。这些平衡并无一定之规。比如下面这幅环保题材的画，小姑娘、彩色的气球、小狗、后面的烟囱、以及看不清后面是工厂还是废墟的影影绰绰，无处不是模糊与清晰之间平衡的体现，清晰一点或再模糊一些都未必能有如此效果。&lt;/p&gt;
&lt;p&gt;　　                            　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201706/445166-20170616144053165-976921226.jpg&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也不必为框框架架约束，不一定实现的要华丽。极有可能很简单的实现也能恰到好处，当然，恰到好处说起来容易，既然无法规定普适的规则怎么办呢，我的经验是，当模型或实现等可以让自己觉得不别扭、或者念头通畅就可以了。开头莱布尼茨的名言暗示了一点，我们的无意识计算或者直觉可以帮助我们找到自己根据现有资源所能达到的最好平衡。&lt;/p&gt;
&lt;p&gt;　　最后再看一幅画，这幅画非常简单，但传达的感性非常丰满。我们做软件也是一样，只要有合适的数据结构，体会画的动与静，抽象程度未必需要非常精细，特地强调这点因为说起来容易，其实很多人，尤其是有代码洁癖的人非常容易把数据结构设计的非常精致，下手之前还在想要把握分寸，但是一旦开始就一发不可收拾，我以前就经常这样。下面这幅画中核心部分是一个出门迎接阳光的人，这人看起来只是随便画了些轮廓阴影，但是恰到好处，线条并不觉得乱，而大面积的房间简约而不简单，墙上一幅树叶既使画面丰满，也能突出主人向往春天，我初看时还有一种在家临渊慕鱼不如出门享受阳关，退而结网脚踏实地一步一步走出去的感觉。&lt;/p&gt;
&lt;p&gt; 　　　　　                　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201703/445166-20170305085648485-857751910.jpg&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;公众号：&lt;/p&gt;

&lt;p&gt;                                                                                &lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dLzFictDamzbKZpj5nOwxClXmOMElzyXXc2BVQcBzoLjicwzZYyq4ZSEe4fH1sPVp5ibeO5GJwOVsO8KW4tojQ9fw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dLzFictDamzbKZpj5nOwxClXmOMElzyXXc2BVQcBzoLjicwzZYyq4ZSEe4fH1sPVp5ibeO5GJwOVsO8KW4tojQ9fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;





</description>
<pubDate>Mon, 19 Feb 2018 08:57:00 +0000</pubDate>
<dc:creator>draculav</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saaav/p/6486532.html</dc:identifier>
</item>
<item>
<title>Office 365 机器人（Bot）开发入门指南 (新篇) - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8453915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8453915.html</guid>
<description>&lt;p&gt;最近在整理书稿时，发现我在2017年7月份写的这篇 &lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/botframeworkquickstart.md&quot;&gt;Office 365 机器人（Bot）开发入门&lt;/a&gt; 的内容，因为相关平台的升级，已经完全不能体现当前的开发过程，所以我再专门写一篇新的开发入门指南给有兴趣的大家参考。&lt;/p&gt;
&lt;p&gt;这次平台升级的具体开始时间我不得而知，但是如果你现在继续访问 &lt;a href=&quot;https://dev.botframework.com/&quot;&gt;https://dev.botframework.com/&lt;/a&gt; ，你将会看到一个明确的提示，要求将早先创建好的Bot在2018年3月31日之前迁移到新的Azure Bot Service：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-13-39-09.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-13-39-09.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你此时点击了“Create a bot”按钮的话，你也将被要求通过Azure Portal来操作：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-13-40-58.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-13-40-58.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这将意味着，现在要进行机器人的开发，你必须首先拥有一个Azure的订阅，不管是试用版的，还是正式版的。本文将假定你已经拥有这些条件。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;值得注意的是，目前Azure的国内版还没有Bot Service的功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可以在Azure Portal中搜索Bot Service，或者快速通过 &lt;a href=&quot;https://portal.azure.com/?l=zh-hans.zh-cn#blade/Microsoft_Azure_Marketplace/GalleryResultsListBlade/selectedSubMenuItemId/%7B%22menuItemId%22%3A%22gallery%2FCognitiveServices_MP%2FBotService%22%2C%22resourceGroupId%22%3A%22%22%2C%22resourceGroupLocation%22%3A%22%22%2C%22dontDiscardJourney%22%3Afalse%2C%22launchingContext%22%3A%7B%22source%22%3A%5B%22GalleryFeaturedMenuItemPart%22%5D%2C%22menuItemId%22%3A%22CognitiveServices_MP%22%2C%22subMenuItemId%22%3A%22BotService%22%7D%7D&quot;&gt;这个地址&lt;/a&gt; 定位到目前支持的三种Bot Service类型，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-13-48-58.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-13-48-58.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它们分别的使用场景如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Web App Bot。这种类型将在Azure中创建一个App Service来运行你的Bot，并且通过模板和自动化的配置极大地简化你的开发过程。&lt;/li&gt;
&lt;li&gt;Function Bot。这种类型将在Azure中创建一个Azure Function App来运行你的Bot，同样也是会有模板和自动化配置来简化开发，它与Web App Bot的区别在于，它的计费是按照具体的使用次数，而不是虚拟机的启用时间——事实上，这也正是Azure Function App和web App的本质区别。我个人觉得，这种形式应该是更加符合机器人的特点的——它是按需调用的，并不见得要一直运行在后台。&lt;/li&gt;
&lt;li&gt;Bot Channels Registration。这种类型是支持你将Bot应用部署到你自己选择的其他位置（可能是你的数据中心，也可以是其他的云平台），然后通过Azure来做Channel的注册和对接。如果你看过我上一篇文章，你应该会对Bot，Bot Framework，Channel有一些概念，如果还不太明白，我下面会继续做一些解释。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在开发阶段，不管是上述哪一种类型的Bot，我们都可以选择“免费”的价格进行开发和调试（普通信道无限量消息，高级信道每月10000次消息调用）。&quot;免费”的服务是没有SLA保障的，但对于开发阶段来说已经足够了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽然我们知道创建Bot并不难，本文后半部分也将再次以一个实例来介绍如何开发和测试基于Azure Bot Service的机器人。但在此之前，我还是摘录三种常见的Azure机器人服务方案给大家参考，了解这些业界流行的做法和流程，可能会对你后续开发有借鉴意义。&lt;/p&gt;
&lt;h2&gt;商务聊天机器人&lt;/h2&gt;
&lt;p&gt;Azure 机器人服务和语言理解服务结合可使开发人员能够创建针对各种场景的对话接口，如银行、旅游和娱乐。例如，酒店礼宾员可以使用机器人增强传统的电子邮件和电话呼叫交互，方法是通过 Azure Active Directory 验证客户，并使用认知服务更好地根据实际情景利用文字和语音处理客户请求。可以添加语音识别服务来支持语音命令。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-07-23.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-07-23.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;信息聊天机器人&lt;/h2&gt;
&lt;p&gt;此信息机器人可回答知识集中定义的问题或使用认知服务 QnA Maker 回答常见问题，以及使用 Azure 搜索回答更加开放的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-08-00.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-08-00.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;企业效率聊天机器人&lt;/h2&gt;
&lt;p&gt;Azure 机器人服务可轻松与语言理解结合以生成强大的企业效率机器人，让组织可以通过集成外部系统（如 Office 365 日历、Dynamics CRM 中存储的客户事例等）来简化常见工作活动。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-08-30.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-08-30.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面我将以一个实例来演示如何开发和调试Function Bot。在下图的向导中，你需要指定一个唯一的名称，并且选择存储位置，定价层（我选择F0，是指免费的定价），宿主计划我选择的是“消耗计划”指的是按调用次数付费，Application insights选择“打开”以便后期可以通过一个仪表盘来看到机器人被调用的统计数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-23-44.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-23-44.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你已经看到了，Azure Bot Service默认提供了两种语言（C#和Node.js）的五种模板。我先以Basic为例创建一个应用。创建成功后，请在下面的界面中点击“Test in Web Chat”来进行测试。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-40-31.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-40-31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;在线修改代码并且进行测试&lt;/h2&gt;
&lt;p&gt;这就是Basic模板默认提供的功能，它就像是一个回声筒一样，将你发送过去的话再返回过来。如果你觉得这样太无聊了，你当然可以修改代码让它变得有趣一些。请点击“机器人管理”中的“内部版本”这个菜单。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-42-10.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-42-10.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击“在Azure Functions中打开此机器人”链接，在接下来的界面中，找到EchoDialog.csx这个文件，按照下面红色框示意修改代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-45-09.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-45-09.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击“保存”按钮，然后回到此前的&quot;Test in Web Chat”页面，再次输入你的消息，观察其返回的内容，现在在回复消息中多了一个时间戳了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-47-51.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-47-51.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;本地修改机器人代码并实现持续整合&lt;/h2&gt;
&lt;p&gt;以上演示了如何在线修改代码并进行测试的方法。只要你愿意，你随时可以将代码下载到本地，然后使用你喜欢的编辑器进行本地开发，最后提交给Azure Bot Service。请在下图中点击“下载zip文件”链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-51-45.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-51-45.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你需要使用Visual Studio 2017打开这个解决方案文件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-14-54-39.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-14-54-39.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将上面这一行代码稍作修改，例如：&lt;code&gt;await context.PostAsync($&quot;{this.count++}: You said {message.Text} at {DateTime.Now},Modify by Visual Studio&quot;);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来，我们要将本地这个目录进行git配置，以便后续可以跟Azure Bot Service 进行持续整合（通过git的代码提交，自动替换Azure Bot Serivce代码并触发编译，更新Bot应用）。请确保你的本地计算机上面安装了git工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-07-20.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-07-20.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上通过&lt;code&gt;git init&lt;/code&gt;命令初始化当前目录的git仓库。然后通过&lt;code&gt;git add .&lt;/code&gt;命令和&lt;code&gt;git commit -m&lt;/code&gt;命令提交本地更新。接下来我们配置Bot Service以便它能使用本地git仓库进行持续整合。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-10-21.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-10-21.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请点击上图的“所有应用服务设置”菜单，并且接下来的“部署选项”中选择“本地Git存储库”选项&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-13-43.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-13-43.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击“保存”按钮后，设置“部署凭据”。请牢记这个用户名和密码，并且不要泄露给其他人。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-15-16.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-15-16.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在“概述”页面中，此时会多出来一个Git的克隆Url，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-17-08.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-17-08.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请将这个地址复制下来，接下来回到git bash的窗口。通过&lt;code&gt;git remote add origin 你的url&lt;/code&gt; 命令添加远程存储库绑定，并且通过&lt;code&gt;git push origin master&lt;/code&gt;命令来完成代码推送。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-19-32.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-19-32.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推送成功后稍等片刻，再次回到Azure Bot Service的“Test in Web Chat”菜单，你会发现刚才我们在Visual Studio中进行的代码修改已经起了作用，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-21-12.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-21-12.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;使用Bot Framework Emulator进行调试&lt;/h2&gt;
&lt;p&gt;如果你想进行更加细节的调试，我推荐你下载和安装 &lt;a href=&quot;https://aka.ms/bf-emulator&quot;&gt;Bot Framework Emulator&lt;/a&gt;。通过它来进行调试的好处是可以清晰地看到消息发送和接收的细节，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-30-42.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-30-42.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;在你的业务应用中整合这个机器人&lt;/h2&gt;
&lt;p&gt;上面我们演示了如何开发、测试和调试机器人，默认情况下，Azure Bot Service会将这个机器人连接到一个Web Chat的信道（Channel），这样的话，我们既可以通过之前多次演示的“Test in web chat”界面进行使用，但也可以将这个界面整合到自己的业务应用中来，为此我们需要获取机器人嵌入代码，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-37-09.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-37-09.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可以配置多个站点，并且为每个站点都生成一个单独的密钥以进行区分，然后点击“复制”按钮，实际上你会得到一串HTML代码，里面是一个iframe。请注意用你的密钥替换掉代码中的“使用此处的密钥”，请将代码保存为一个HTML文件，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-42-47.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-42-47.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请注意，我这里添加了一个Style的设置，这是为了让它在浏览器中看起来更加美观一些。接下来你可以在任意浏览器中打开这个本地网页，输入消息后你会得到跟此前一致的使用体验。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-43-43.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-43-43.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;将机器人连接到Microsoft Teams&lt;/h2&gt;
&lt;p&gt;既然这篇文章讲的是“Office 365 机器人（Bot）开发入门”，自然要提到如何跟Office 365的结合。这个话题有两层含义，首先在Bot Service中可以通过Microsoft Graph调用Office 365的服务来完成一些工作，其次是我们可以将机器人连接到Office 365的组件中来，目前支持Microsoft Teams和Skype for Business两个信道，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-49-00.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-49-00.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加到Microsoft Teams相对容易一些，你只需要点击上图中的Microsoft Teams图标，并且接受协议，在下图中点击“完成”即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-50-23.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-50-23.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到信道主界面，点击“Microsoft Teams”的链接，即可为自己的Microsoft Teams客户端添加当前这个机器人。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-15-51-17.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-15-51-17.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果不出意外的话，你的联系人中会出现一个机器人，你可以像跟同事聊天一样与它进行互动了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-01-13.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-01-13.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你的同事也需要使用这个机器人，在你没有将这个应用提交给微软官方的市场之前，他们需要通过机器人的编号进行搜索，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-06-40.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-06-40.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加联系人后，后续的聊天形式是一样的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-07-54.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-07-54.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于如何将你开发的这个机器人提交到微软的官方市场，请参考 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/microsoftteams/platform/publishing/apps-publish&quot;&gt;https://docs.microsoft.com/zh-cn/microsoftteams/platform/publishing/apps-publish&lt;/a&gt; 的说明。&lt;/p&gt;
&lt;h2&gt;将机器人连接到Skype for Business&lt;/h2&gt;
&lt;p&gt;与Microsoft Teams相比，将机器人连接到Skype for Business的体验正好相反——它的安装配置过程比较复杂（需要Office 365管理员权限），但一旦配置完成，则整个公司的用户都能直接搜索到这个机器人，而无需发布到微软的应用市场。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-11-43.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-11-43.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加Skype for Business这个信道只是第一步，接下来要根据一个文档的说明，使用Office 365管理员身份以及几个PowerShell的命令来完成这个机器人的注册和配置。通常的指令形式如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-13-18.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-13-18.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在我的Office 365测试环境中，我执行的命令如下图所示（请注意，第二个命令的执行可能需要几分钟时间）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-26-16.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-26-16.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完成上面的配置后，任何一个用户，都可以直接在Skype for Business中搜索中这个机器人并且跟它聊天了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-30-15.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-30-15.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请注意，我前面已经提到了，因为当前这个机器人是托管在免费的模式下，所以可能你在测试过程中偶尔会遇到一些错误。&lt;/p&gt;

&lt;p&gt;新年新气象，这篇文章给大家完整地介绍了全新的Azure Bot Service提供的服务。我们可以利用它快速地完成机器人的开发、测试，根据自己的需要将其连接到包括Microsoft Teams和Skype for Business在内的多个信道中去，真正实现“一次编写、处处运行”，我相信这种平台级别的创新，结合Office 365的庞大用户群体，以及海量的有价值的信息，使得机器人(Bot)不再是一个实验室中的花骨朵，而是我们现实工作和生活中可以触手可及的应用。&lt;/p&gt;
&lt;p&gt;顺便预告一下，第三届Office 365开发者大会将于3月17-18日在北京将隆重举办，我将做关于机器人开发的主题演讲。这一届大会规模比之前两届大，精彩内容除了Office 365, 还有Windows 10的最新开发场景。欢迎踊跃报名，希望现场可以看到你。活动详情和报名请访问 &lt;a href=&quot;https://aka.ms/M365DevDays&quot;&gt;https://aka.ms/M365DevDays&lt;/a&gt;, 你也可以通过扫描以下二维码进行访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-02-19-16-36-15.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-02-19-16-36-15.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Feb 2018 08:42:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8453915.html</dc:identifier>
</item>
<item>
<title>Scrapy框架实战-妹子图爬虫 - K‘e0llm</title>
<link>http://www.cnblogs.com/Eivll0m/p/8453842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Eivll0m/p/8453842.html</guid>
<description>&lt;p&gt;Scrapy这个成熟的爬虫框架，用起来之后发现并没有想象中的那么难。即便是在一些小型的项目上，用scrapy甚至比用requests、urllib、urllib2更方便，简单，效率也更高。废话不多说，下面详细介绍下如何用scrapy将妹子图爬下来，存储在你的硬盘之中。关于Python、Scrapy的安装以及scrapy的原理这里就不作介绍，自行google、百度了解学习。&lt;/p&gt;
&lt;p&gt;一、开发工具&lt;br/&gt;Pycharm 2017&lt;br/&gt;Python 2.7&lt;br/&gt;Scrapy 1.5.0&lt;br/&gt;requests&lt;/p&gt;
&lt;p&gt;二、爬取过程&lt;/p&gt;
&lt;p&gt;1、创建mzitu项目&lt;/p&gt;
&lt;p&gt;进入&quot;E:\Code\PythonSpider&amp;gt;&quot;目录执行scrapy startproject mzitu命令创建一个爬虫项目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; scrapy startproject mzitu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完成后，生产目录文件结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;├── mzitu
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;│   ├── mzitu
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; │   │   ├── &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;│   │   ├── items.py
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;│   │   ├── middlewares.py
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;│   │   ├── pipelines.py
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;│   │   ├── settings.py
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;│   │   └── spiders
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; │   │       ├── &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;│   │       └── Mymzitu.py
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; │   └── scrapy.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、进入mzitu项目，编写修改items.py文件&lt;/p&gt;
&lt;p&gt;定义titile，用于存储图片目录的名称&lt;br/&gt;定义img，用于存储图片的url&lt;br/&gt;定义name，用于存储图片的名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Define here the models for your scraped items&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; See documentation in:&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; https://doc.scrapy.org/en/latest/topics/items.html&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MzituItem(scrapy.Item):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; define the fields for your item here like:&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     title =&lt;span&gt; scrapy.Field()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     img =&lt;span&gt; scrapy.Field()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     name = scrapy.Field()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、编写修改spiders/Mymzitu.py文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; mzitu.items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MzituItem
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;reload(sys)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; sys.setdefaultencoding(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MymzituSpider(scrapy.Spider):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_urls():
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mzitu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         headers =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         r = requests.get(url,headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         html =&lt;span&gt; etree.HTML(r.text)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         urls = html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;pins&quot;]/li/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; urls
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mymzitu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     allowed_domains = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.mzitu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     start_urls =&lt;span&gt; get_urls()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         item =&lt;span&gt; MzituItem()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;item['title'] = response.xpath('//h2[@class=&quot;main-title&quot;]/text()')[0].extract()&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//h2[@class=&quot;main-title&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0].extract().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;main-image&quot;]/p/a/img/@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].extract()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;main-image&quot;]/p/a/img/@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0].extract().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         next_url = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;pagenavi&quot;]/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[-1&lt;span&gt;].extract()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; next_url:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; scrapy.Request(next_url, callback=self.parse)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们要爬取的是妹子图网站“最新”的妹子图片，对应的主url是http://www.mzitu.com，通过查看网页源代码发现每一个图片主题的url在&amp;lt;li&amp;gt;标签中，通过上面代码中get_urls函数可以获取，并且返回一个url列表，这里必须说明一下，用python写爬虫，像re、xpath、Beautiful Soup之类的模块必须掌握一个，否则根本无法下手。这里使用xpath工具来获取url地址，在lxml和scrapy中，都支持使用xpath。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/611088/201802/611088-20180219153323234-137191972.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_urls():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mzitu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         headers =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         r = requests.get(url,headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         html =&lt;span&gt; etree.HTML(r.text)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         urls = html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;pins&quot;]/li/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; urls
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;name定义爬虫的名称，allowed_domains定义包含了spider允许爬取的域名(domain)列表(list)，start_urls定义了爬取了url列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mymzitu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; allowed_domains = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.mzitu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; start_urls = get_urls()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析图片详情页，获取图片主题、图片url和图片名称，同时获取下一页，循环爬取：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         item =&lt;span&gt; MzituItem()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;item['title'] = response.xpath('//h2[@class=&quot;main-title&quot;]/text()')[0].extract()&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//h2[@class=&quot;main-title&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0].extract().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;main-image&quot;]/p/a/img/@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].extract()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;main-image&quot;]/p/a/img/@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0].extract().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         next_url = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;pagenavi&quot;]/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[-1&lt;span&gt;].extract()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; next_url:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; scrapy.Request(next_url, callback=self.parse)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4、编写修改pipelines.py文件，下载图片&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Define your item pipelines here&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Don't forget to add your pipeline to the ITEM_PIPELINES setting&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MzituPipeline(object):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Referer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mzitu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         local_dir = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\data\\mzitu\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         local_file = local_dir + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.exists(local_dir):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            os.makedirs(local_dir)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         with open(local_file,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             f.write(requests.get(item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],headers=&lt;span&gt;headers).content)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、middlewares.py文件中新增一个RotateUserAgentMiddleware类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RotateUserAgentMiddleware(UserAgentMiddleware):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, user_agent=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.user_agent =&lt;span&gt; user_agent
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request, spider):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         ua =&lt;span&gt; random.choice(self.user_agent_list)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ua:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             request.headers.setdefault(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, ua)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;the default user_agent_list composes chrome,IE,firefox,Mozilla,opera,netscape&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;for more user agent strings,you can find it in http://www.useragentstring.com/pages/useragentstring.php&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     user_agent_list =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、settings.py设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Obey robots.txt rules&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; ROBOTSTXT_OBEY =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Configure maximum concurrent requests performed by Scrapy (default: 16)&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; CONCURRENT_REQUESTS = 100
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Disable cookies (enabled by default)&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; COOKIES_ENABLED =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; DOWNLOADER_MIDDLEWARES =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mzitu.middlewares.MzituDownloaderMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 543&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mzitu.middlewares.RotateUserAgentMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 400&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、运行爬虫&lt;/p&gt;
&lt;p&gt;进入E:\Code\PythonSpider\mzitu目录，运行scrapy crawl Mymzitu命令启动爬虫：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/611088/201802/611088-20180219162852093-1695097358.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果及完整代码详见：&lt;a title=&quot;https://github.com/Eivll0m/PythonSpider/tree/master/mzitu&quot; href=&quot;https://github.com/Eivll0m/PythonSpider/tree/master/mzitu&quot; target=&quot;_blank&quot;&gt;https://github.com/Eivll0m/PythonSpider/tree/master/mzitu&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Feb 2018 08:32:00 +0000</pubDate>
<dc:creator>K‘e0llm</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Eivll0m/p/8453842.html</dc:identifier>
</item>
<item>
<title>C语言实现简易2048小游戏 - Andrew_qian</title>
<link>http://www.cnblogs.com/qsyll0916/p/8447481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qsyll0916/p/8447481.html</guid>
<description>&lt;p&gt;一直很喜欢玩这个小游戏，简单的游戏中包含运气与思考与策略，喜欢这种简约又不失内涵的游戏风格。于是萌生了用C语言实现一下的想法。&lt;/p&gt;
&lt;p&gt;具体代码是模仿这个：&lt;a href=&quot;https://www.cnblogs.com/judgeyoung/p/3760515.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/judgeyoung/p/3760515.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;博主分析的都很到位，很多算法技巧都值得借鉴，C语言实现2048的主要思想已经在那个博客中详细的分析了，但是我觉得在博主的代码中还是有很多很好的思想是值得我借鉴学习的。&lt;/p&gt;
&lt;p&gt;比如这个生成随机数，顺便规定随机数的概率：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 生成随机数 函数定义 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; add_rand_num()
{
    srand(time(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = rand() % get_null_count();&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确定在何处空位置生成随机数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;4&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (board[i][j] == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; n-- == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定位待生成的位置 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            {
                board[i][j] &lt;/span&gt;= (rand() % &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;2&lt;/span&gt; : &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确定生成何值，设定生成2的概率是4的概率的两倍 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 首先是 srand() 函数，他是一个随机数发生器的初始化函数。&lt;/p&gt;
&lt;p&gt;原型为：void srand(unsigned seed)&lt;/p&gt;
&lt;p&gt;用法是：程序员需要为这个函数提供一个随机数的种子：srand（随机数），如果使用相同的种子，那么后面的rand（）函数就会每次运行都是生成一样的随机数，即伪随机数。&lt;/p&gt;
&lt;p&gt;如：srand（1），直接用1来初始化种子，后面都是一样的随机数 。&lt;/p&gt;
&lt;p&gt;为了生成真正的随机数，我们一般采用系统时间来作为随机数初始化函数的种子。使用time（）函数来获取系统时间：&lt;/p&gt;
&lt;p&gt;它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数，然后将time_t型数据转化为(unsigned)型再传给srand函数，即： srand((unsigned) time(&amp;amp;t));&lt;/p&gt;
&lt;p&gt;还有一个经常用法，不需要定义 time_t 型 t 变量,即： srand((unsigned) time(NULL)); 直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的 t 数据。&lt;/p&gt;
&lt;p&gt;第二句是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; n = rand() % get_null_count();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在空余格中生成一个随机位置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用随机数对剩余空格数目进行取余运算，得到小于剩余格数的随机数。&lt;/p&gt;
&lt;p&gt;最后一句是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (board[i][j] == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; n-- == &lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机位置处为0时填入一个随机数，但是如果随机位置处不为0呢？&lt;/span&gt;
&lt;span&gt;            {
                board[i][j] &lt;/span&gt;= (rand() % &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;2&lt;/span&gt; : &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在随机生成的空白格处填上一个2或者4，利用三项表达式对3取余，得到1/3，2/3的概率。&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束函数&lt;/span&gt;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是在格子中没有数字时并且在刚刚生成的随机数的位置处，填入一个数字2或者4，并且为了降低难度，固定生成2是生成4的概率的2倍。&lt;/p&gt;
&lt;p&gt;利用三目运算符和对3取余的特点，产生概率分布。&lt;/p&gt;
&lt;p&gt;rand（）随机数对3取余只有可能是0/1/2，而在三目运算符中，当第一个数不为0时，运算符的值就取中间那个数的值，否则取最后一个数。所以取2的可能性为2/3，取4的可能性为1/3，这样就产生了不同的概率。但是这种方法只能产生  n:1 的概率分布，如果要产生      4:5,    8:17  的概率时，这种方法就不在适用了。&lt;/p&gt;
&lt;p&gt;上面这些代码还是有一些漏洞的，因为游戏刚开始是需要有两个数的，一个数必为2，另一个数就是上面生成的那个数，但是如果第二个数恰好生成的随机位置处是第一个数，那么根据这儿代码，就什么也没有执行，最终导致出现刚开始界面就一个数字的情况。&lt;/p&gt;
&lt;p&gt;解决办法就是在刚开始生成的两个数的程序中不使用  get_null_count（），而是获取第一个数字2的准确位置，然后生成第二个数字时，在排除第一个数字的地方生成数字即可。&lt;/p&gt;
&lt;p&gt;程序的主体就是数字的上下左右移动，go_left（）和其他三个函数，他们的思想都是相似的，就拿go_left（）函数来分析一下：&lt;/p&gt;
&lt;p&gt;按照原作者的思想，移动的时候一共有三种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1083998/201802/1083998-20180219130431611-492713948.png&quot; alt=&quot;&quot; width=&quot;328&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果相邻的两个数一样，就合并，数字相加。&lt;/p&gt;
&lt;p&gt;如果相邻的数字不一样，简单的说，又分两种情况：数字需要移动和不需要移动。&lt;/p&gt;
&lt;p&gt;具体代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;左移函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; go_left(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;i遍历行下标&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;j为列下标，k为待比较项列下标，循环进入时k &amp;lt; j&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;,k = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;4&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;找出k后面第一个不为0的项&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (board[i][j] &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;情况1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (board[i][j] == board[i][k])        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个数相同就合并&lt;/span&gt;
&lt;span&gt;                {
                    scoer &lt;/span&gt;+= board[i][k++] &amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    board[i][j] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    if_need_add_num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并之后需要生成随机数和刷新界面&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;情况2&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (board[i][k] == &lt;span&gt;0&lt;/span&gt;)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;k项为空，则把j格移到k格&lt;/span&gt;
&lt;span&gt;                {
                    board[i][k] &lt;/span&gt;=&lt;span&gt; board[i][j];
                    board[i][j] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    if_need_add_num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;情况3&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;k项不为空，也不等于j项，此时两个都不需要动，只是下标需要变换&lt;/span&gt;
                    board[i][++k] = board[i][j];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把j项移到k项的紧挨着的右边&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (j != k)                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动过之后不相等说明之前他们不是紧挨着的&lt;/span&gt;
&lt;span&gt;                {
                    board[i][j] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    if_need_add_num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时移动虽然没有消去一个数，但是也要添加一个随机数出来&lt;/span&gt;
&lt;span&gt;                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项目完整代码在原博客中已经给出。&lt;/p&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1083998/201802/1083998-20180219131919423-1944249600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Feb 2018 05:21:00 +0000</pubDate>
<dc:creator>Andrew_qian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qsyll0916/p/8447481.html</dc:identifier>
</item>
</channel>
</rss>