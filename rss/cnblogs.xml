<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发系列[1]----AbstractQueuedSynchronizer源码分析之概要分析 - 劳夫子</title>
<link>http://www.cnblogs.com/liuyun1995/p/8400663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyun1995/p/8400663.html</guid>
<description>&lt;p&gt;学习Java并发编程不得不去了解一下java.util.concurrent这个包，这个包下面有许多我们经常用到的并发工具类，例如：ReentrantLock, CountDownLatch, CyclicBarrier, Semaphore等。而这些类的底层实现都依赖于AbstractQueuedSynchronizer这个类，由此可见这个类的重要性。所以在Java并发系列文章中我首先对AbstractQueuedSynchronizer这个类进行分析，由于这个类比较重要，而且代码比较长，为了尽可能分析的透彻一些，我决定用四篇文章对该类进行一个比较完整的介绍。本篇文章作为概要介绍主要是让读者们对该类有个初步了解。为了叙述简单，后续有些地方会用AQS代表这个类。&lt;/p&gt;
&lt;p&gt;1. AbstractQueuedSynchronizer这个类是干嘛的？&lt;/p&gt;
&lt;p&gt;相信要许多读者使用过ReentrantLock，但是却不知道AbstractQueuedSynchronizer的存在。其实ReentrantLock实现了一个内部类Sync，该内部类继承了AbstractQueuedSynchronizer，所有锁机制的实现都是依赖于Sync内部类，也可以说ReentrantLock的实现就是依赖于AbstractQueuedSynchronizer类。于此类似，CountDownLatch, CyclicBarrier, Semaphore这些类也是采用同样的方式来实现自己对于锁的控制。可见，AbstractQueuedSynchronizer是这些类的基石。那么AQS内部到底实现了什么以至于所以这些类都要依赖于它呢？可以这样说，AQS为这些类提供了基础设施，也就是提供了一个密码锁，这些类拥有了密码锁之后可以自己来设置密码锁的密码。此外，AQS还提供了一个排队区，并且提供了一个线程训导员，我们知道线程就像一个原始的野蛮人，它不懂得讲礼貌，它只会横冲直撞，所以你得一步一步去教它，告诉它什么时候需要去排队了，要到哪里去排队，排队前要做些什么，排队后要做些什么。这些教化工作全部都由AQS帮你完成了，从它这里教化出来的线程都变的非常文明懂礼貌，不再是原始的野蛮人，所以以后我们只需要和这些文明的线程打交道就行了，千万不要和原始线程有过多的接触！&lt;/p&gt;
&lt;p&gt;2. 为何说AbstractQueuedSynchronizer提供了一把密码锁？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步队列的头结点&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node head; 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步队列的尾结点&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node tail;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步状态&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; state;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取同步状态&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getState() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置同步状态&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setState(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newState) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     state =&lt;span&gt; newState;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以CAS方式设置同步状态&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSetState(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; update) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, stateOffset, expect, update);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码列出了AQS的所有成员变量，可以看到AQS的成员变量只有三个，分别是同步队列头结点引用，同步队列尾结点引用以及同步状态。注意，这三个成员变量都使用了volatile关键字进行修饰，这就确保了多个线程对它的修改都是内存可见的。整个类的核心就是这个同步状态，可以看到同步状态其实就是一个int型的变量，大家可以把这个同步状态看成一个密码锁，而且还是从房间里面锁起来的密码锁，state具体的值就相当于密码控制着密码锁的开合。当然这个锁的密码是多少就由各个子类来规定了，例如在ReentrantLock中，state等于0表示锁是开的，state大于0表示锁是锁着的，而在Semaphore中，state大于0表示锁是开的，state等于0表示锁是锁着的。&lt;/p&gt;
&lt;p&gt;2. AbstractQueuedSynchronizer的排队区是怎样实现的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201370/201802/1201370-20180201190608843-1621014148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AbstractQueuedSynchronizer内部其实有两个排队区，一个是同步队列，一个是条件队列。从上图可以看出，同步队列只有一条，而条件队列可以有多条。同步队列的结点分别持有前后结点的引用，而条件队列的结点只有一个指向后继结点的引用。图中T表示线程，每个结点包含一个线程，线程在获取锁失败后首先进入同步队列排队，而想要进入条件队列该线程必须持有锁才行。接下来我们看看队列中每个结点的结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步队列的结点&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node SHARED = &lt;span&gt;new&lt;/span&gt; Node(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前线程以共享模式持有锁&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span&gt;null&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前线程以独占模式持有锁&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED =  1;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前结点已经取消获取锁&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL    = -1;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示后继结点的线程需要运行&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CONDITION = -2;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前结点在条件队列中排队&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PROPAGATE = -3;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示后继结点可以直接获取锁&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; waitStatus; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前结点的等待状态&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;    
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;volatile&lt;/span&gt; Node prev;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示同步队列中的前继结点&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;volatile&lt;/span&gt; Node next;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示同步队列中的后继结点  &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;volatile&lt;/span&gt; Thread thread;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前结点持有的线程引用&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt;     Node nextWaiter;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示条件队列中的后继结点
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前结点状态是否是共享模式&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isShared() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; nextWaiter ==&lt;span&gt; SHARED;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前结点的前继结点&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node predecessor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NullPointerException {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         Node p =&lt;span&gt; prev;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器1&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    Node() {}
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器2, 默认用这个构造器&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    Node(Thread thread, Node mode) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意持有模式是赋值给nextWaiter&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.nextWaiter =&lt;span&gt; mode;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.thread =&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器3, 只在条件队列中用到&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;     Node(Thread thread, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; waitStatus) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.waitStatus =&lt;span&gt; waitStatus;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.thread =&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Node代表同步队列和条件队列中的一个结点，它是AbstractQueuedSynchronizer的内部类。Node有很多属性，比如持有模式，等待状态，同步队列中的前继和后继，以及条件队列中的后继引用等等。可以把同步队列和条件队列看成是排队区，每个结点看成是排队区的座位，将线程看成是排队的客人。客人刚来时会先去敲敲门，看看锁有没有开，如果锁没开它就会去排队区领取一个号码牌，声明自己想要以什么样的方式来持有锁，最后再到队列的末尾进行排队。&lt;/p&gt;
&lt;p&gt;3. 怎样理解独占模式和共享模式？&lt;/p&gt;
&lt;p&gt;前面讲到每个客人在排队前会领取一个号码牌，声明自己想要以什么样的方式来占有锁，占有锁的方式分为独占模式和共享模式，那么怎样来理解独占模式和共享模式呢？实在找不到什么好的比喻，大家可以联想一下公共厕所，独占模式的人比较霸道，老子要么就不进，进来了就不许别人再进了，自己一个人独自占用整个厕所。共享模式的人就没那么讲究了，当它发现这个厕所已经可以用了之后，它自己进来还不算，还得热心的问下后面的人介不介意一起用，如果后面的人不介意一起使用那就不用再排队了大家一起上就是了， 当然如果后面的人介意那就只好留在队列里继续排队了。&lt;/p&gt;
&lt;p&gt;4. 怎样理解结点的等待状态？&lt;/p&gt;
&lt;p&gt;我们还看到每个结点都有一个等待状态，这个等待状态分为CANCELLED，SIGNAL，CONDITION，PROPAGATE四种状态。可以将这个等待状态看作是挂在座位旁边的牌子，标识当前座位上的人的等待状态。这个牌子的状态不仅自己可以修改，其他人也可以修改。例如当这个线程在排队过程中已经打算放弃了，它就会将自己座位上的牌子设置为CANCELLED，这样其他人看到了就可以将它清理出队列。还有一种情况是，当线程在座位上要睡着之前，它怕自己睡过了头，就会将前面位置上的牌子改为SIGNAL，因为每个人在离开队列前都会回到自己座位上看一眼，如果看到牌子上状态为SIGNAL，它就会去唤醒下一个人。只有保证前面位置上的牌子为SIGNAL，当前线程才会安心的睡去。CONDITION状态表示该线程在条件队列中排队，PROPAGATE状态提醒后面来的线程可以直接获取锁，这个状态只在共享模式用到，后面单独讲共享模式的时候会讲到。&lt;/p&gt;
&lt;p&gt;5. 结点进入同步队列时会进行哪些操作？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结点入队操作, 返回前一个结点&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取同步队列尾结点引用&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         Node t =&lt;span&gt; tail;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果尾结点为空说明同步队列还没有初始化&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化同步队列&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node())) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 tail =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.指向当前尾结点&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             node.prev =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.设置当前结点为尾结点&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.将旧的尾结点的后继指向新的尾结点&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 t.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环唯一的出口&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，入队操作使用一个死循环，只有成功将结点添加到同步队列尾部才会返回，返回结果是同步队列原先的尾结点。下图演示了整个操作过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201370/201802/1201370-20180201190926046-468129747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读者需要注意添加尾结点的顺序，分为三步：指向尾结点，CAS更改尾结点，将旧尾结点的后继指向当前结点。在并发环境中这三步操作不一定能保证完成，所以在清空同步队列所有已取消的结点这一操作中，为了寻找非取消状态的结点，不是从前向后遍历而是从后向前遍历的。还有就是每个结点进入队列中时它的等待状态是为0，只有后继结点的线程需要挂起时才会将前面结点的等待状态改为SIGNAL。&lt;/p&gt;
&lt;p&gt;注：以上全部分析基于JDK1.7，不同版本间会有差异，读者需要注意&lt;/p&gt;
</description>
<pubDate>Fri, 02 Feb 2018 07:21:00 +0000</pubDate>
<dc:creator>劳夫子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyun1995/p/8400663.html</dc:identifier>
</item>
<item>
<title>(纯代码)快速创建wcf rest 服务 - YSWALLE</title>
<link>http://www.cnblogs.com/yswenli/p/8405165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yswenli/p/8405165.html</guid>
<description>&lt;p&gt;因为有一个小工具需要和其它的业务对接数据，所以就试一下看能不能弄一个无需配置快速对接的方法出来，百（以）度（讹）过（传）后（讹），最后还是对照wcf配置对象调试出来了：&lt;/p&gt;
&lt;p&gt;1.创建WebHttpBinding&lt;/p&gt;
&lt;p&gt;2.添加ServiceMetadataBehavior&lt;/p&gt;
&lt;p&gt;3.获取一个serverendpoint&lt;/p&gt;
&lt;p&gt;4.指定WebHttpBehavior格式&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快速创建一个WCF http服务
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;contractType&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceType&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;url&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;timeout&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;bufferSize&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isDebug&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceHost CreateWebService(Type contractType, Type serviceType, &lt;span&gt;string&lt;/span&gt; url, TimeSpan timeout, &lt;span&gt;long&lt;/span&gt; bufferSize = &lt;span&gt;2147483647&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt; isDebug = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Uri baseAddress = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(url);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; serviceHost = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceHost(serviceType, baseAddress);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//1.创建WebHttpBinding&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; binding = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHttpBinding(WebHttpSecurityMode.None);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             binding.Security = &lt;span&gt;new&lt;/span&gt; WebHttpSecurity() { Mode = WebHttpSecurityMode.None, Transport = &lt;span&gt;null&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             binding.MaxBufferPoolSize = binding.MaxReceivedMessageSize =&lt;span&gt; bufferSize;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             binding.OpenTimeout = binding.CloseTimeout = binding.SendTimeout = binding.ReceiveTimeout =&lt;span&gt; timeout;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             binding.UseDefaultWebProxy = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             binding.ProxyAddress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; readerQuotas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Xml.XmlDictionaryReaderQuotas();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;             readerQuotas.MaxArrayLength = readerQuotas.MaxBytesPerRead = readerQuotas.MaxDepth = 
&lt;span&gt;34&lt;/span&gt;                 readerQuotas.MaxNameTableCharCount = readerQuotas.MaxStringContentLength = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)bufferSize;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             binding.ReaderQuotas =&lt;span&gt; readerQuotas;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//2.添加ServiceMetadataBehavior&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (serviceHost.Description.Behaviors.Find&amp;lt;ServiceMetadataBehavior&amp;gt;() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 ServiceMetadataBehavior behavior = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceMetadataBehavior();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;                 behavior.HttpGetEnabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;behavior.HttpsGetEnabled = false;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                serviceHost.Description.Behaviors.Add(behavior);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (serviceHost.Description.Behaviors.Find&amp;lt;ServiceThrottlingBehavior&amp;gt;() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 ServiceThrottlingBehavior behavior = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceThrottlingBehavior();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;                 behavior.MaxConcurrentCalls = behavior.MaxConcurrentInstances = behavior.MaxConcurrentSessions = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)bufferSize;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                serviceHost.Description.Behaviors.Add(behavior);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             &lt;span&gt;//3.获取一个serverendpoint&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; serviceEndpoint =&lt;span&gt; serviceHost.AddServiceEndpoint(contractType, binding, baseAddress);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;//4.指定WebHttpBehavior格式&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需引用System.ServiceModel.Web.dll&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;             WebHttpBehavior webHttpBehavior = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHttpBehavior()
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 AutomaticFormatSelectionEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 DefaultBodyStyle =&lt;span&gt; System.ServiceModel.Web.WebMessageBodyStyle.Bare,
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 DefaultOutgoingResponseFormat =&lt;span&gt; System.ServiceModel.Web.WebMessageFormat.Json,
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 DefaultOutgoingRequestFormat =&lt;span&gt; System.ServiceModel.Web.WebMessageFormat.Json,
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                 FaultExceptionEnabled =&lt;span&gt; isDebug,
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                 HelpEnabled =&lt;span&gt; isDebug
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            serviceEndpoint.Behaviors.Add(webHttpBehavior);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;             serviceHost.Opened += &lt;span&gt;delegate&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}已启动！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, serviceType.Name);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; serviceHost;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发布一个wcf  rest 服务只需要&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  WCFServiceFactory.CreateWebService(&lt;span&gt;typeof&lt;/span&gt;(ITestContract),&lt;span&gt;typeof&lt;/span&gt;(TestService),&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:39654/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; TimeSpan(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;),true).Open();
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 02 Feb 2018 06:53:00 +0000</pubDate>
<dc:creator>YSWALLE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yswenli/p/8405165.html</dc:identifier>
</item>
<item>
<title>python---进程与线程 - ﹏亦°洛轩づ</title>
<link>http://www.cnblogs.com/charles8866/p/8402291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charles8866/p/8402291.html</guid>
<description>&lt;hr/&gt;&lt;h3&gt;什么是线程（thread）什么是进程&lt;/h3&gt;
&lt;p&gt;线程：操作系统能够进行运算调度的最小单位。它被包含在进程中，是进程中的实际运作单位。是一串指令的集合&lt;/p&gt;
&lt;p&gt;　　一个线程指的是进程中一个单一顺序的控制流，一个进程是中可以并发多个线程，每个线程并行执行不同的任务&lt;/p&gt;
&lt;p&gt;进程：以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，内存的管理，网络接口的调用等，对各种资源管理的集合，就可以称为进程&lt;/p&gt;
&lt;p&gt;　　进程要操作cpu，必须先创建一个线程，所有在同一个进程里的线程是共享同一块内存空间的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：1.进程本身不能够执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　2.进程和线程不能比较谁快谁慢，两个没有可比性，进程是资源的集合，线程是真正执行任务的，进程要执行任务也要通过线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　3.启动一个线程比启动一个进程快&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;进程和线程的区别&lt;/h3&gt;
&lt;p&gt;1.线程共享内存空间，进程的内存是独立的&lt;/p&gt;
&lt;p&gt;2.thread have direct access to data segment of its process;process have their own copy of  the data segment of the parent process&lt;/p&gt;
&lt;p&gt;3.同一个进程之间线程可以互相交流，两个进程想要通信，必须通过一个中间代理来实现&lt;/p&gt;
&lt;p&gt;4.创建一个线程很简单，创建一个新进程需要对其父进程做一次克隆&lt;/p&gt;
&lt;p&gt;5.一个线程可以控制和操作同一个进程里的其他的线程，但是进程只能操作子进程&lt;/p&gt;
&lt;p&gt;6.改变一个主线程可能会影响到其他线程的运行，对父进程的修改不会影响到子进程&lt;/p&gt;
&lt;h3&gt;Python GIL（全局解释器锁）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在python中无论你启用多少个线程，你有多少个cpu，在python执行的时候都会在同一时刻只准许一个线程运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原因：python的线程是调用操作系统的原生线程&lt;/p&gt;
&lt;h3&gt;线程锁：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(n):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    lock.acquire()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; num
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     num += 1
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;time.sleep(1)在上锁的情况不要使用sleep，不然会等50s才会完成&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    lock.release()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; lock =&lt;span&gt; threading.Lock()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; num =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; t_objs =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     t = threading.Thread(target = run,args = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t-%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;i,))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    t_objs.append(t)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t_objs:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    t.join()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----all threads has finished....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,threading.current_thread(),threading.active_count())
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,num)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;给线程上锁，使程序变成串行，保证num在+1的时候能够准确无误，不然可能会导致，一个线程正在执行+1还没有结束，另外一个线程也开始+1，最后达不到准确结果&lt;/p&gt;
&lt;h3&gt;递归锁：在一个大锁中包含一个小锁&lt;/h3&gt;
&lt;p&gt;场景：学校放学，学生离校了，突然发现自己的文具盒落在了教师中，学校每次只准许一个人进学校（其他东西丢了就是这个人干的），进教室拿的时候也要开教室门（防止有其他人在学校没有走），最后拿到文具盒，离开学校。这个期间学校大门相当于一把锁，教室的门相当于另一把锁。保证了整个过程没有其他人的干扰&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run1():
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grab the first part data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    lock.acquire()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; num
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     num += 1
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    lock.release()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run2():
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grab the second part data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    lock.acquire()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; num2
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     num2 += 1
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    lock.release()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; num2
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run3():
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    lock.acquire()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     res =&lt;span&gt; run1()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------between run1 and run2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     res2 =&lt;span&gt; run2()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    lock.release()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(res,res2)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; num,num2 =&lt;span&gt; 0,0
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; lock =&lt;span&gt; threading.RLock()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     t = threading.Thread(target=&lt;span&gt;run3)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; threading.active_count() != 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(threading.active_count())
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----all threads done---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(num,num2)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;相当于先进入run3这个大门，然后在进入run1和run2这个两个小门，然后进行num1和num2的加1，保证了每个线程的执行都是串行的&lt;/p&gt;
&lt;h3&gt;Python threading模块&lt;/h3&gt;
&lt;p&gt;线程有2中调用方式&lt;/p&gt;
&lt;p&gt;直接调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(n):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt; t1 = threading.Thread(target = run,args = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; t2 = threading.Thread(target = run,args = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;t1.start()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; t2.start()
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;&lt;span&gt;运行结果：一下子出来两个结果，但是程序还会等待2s才会结束，一共两秒，因为他们是并行的&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;继承式调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用类的方式启动线程&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread(threading.Thread):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,n):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         super(MyThread,self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.n =&lt;span&gt; n
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running task &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self.n)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; t1 = MyThread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; t2 = MyThread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;t1.start()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; t2.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面只启动了2个线程，我们下面启动50个线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(n):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     t = threading.Thread(target = run,args = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t-%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;i,))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cost : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,time.time()-start_time)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202003402843-282475279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题：创建了50个进程之后只用了这点时间，主程序没有等其他的子线程就往下走&lt;/p&gt;
&lt;p&gt;原因：是多线程的原因，一个程序至少有一个线程，程序本身就是一个线程，主线程，主线程启动了子线程之后，子线程就和主线程没有关系了，两个互不影响&lt;/p&gt;
&lt;p&gt;解决方法：join()方法，等子线程运行完成之后，主程序才往下走&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(n):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n)
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task has done.... &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n)
start_time &lt;/span&gt;=&lt;span&gt; time.time()
t_objs &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):

    t &lt;/span&gt;= threading.Thread(target = run,args = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t-%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;i,))
    t.start()
    t_objs.append(t)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t_objs:
    t.join()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------all threads has finished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cost : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,time.time()-start_time)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　先自己创建一个临时列表，然后存储创建的线程，然后一个一个的用join()方法　　&lt;/p&gt;
&lt;p&gt; 创建了50个线程，主线程就是程序的本身，也就是说上面一共有51个线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#threading.current_thread()显示当前线程是主线程还是子线程
#threading.active_count()显示当前程序运行的线程的个数
print(&quot;-----all threads has finished....&quot;,threading.current_thread(),threading.active_count())
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　守护进程&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;t.setDaemon(True) &lt;/span&gt;    #把当前线程设置成守护线程，&lt;span&gt;要在start()之前&lt;/span&gt;&lt;br/&gt;非守护线程结束，所有守护线程就退出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(n):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task has done.... &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; t_objs =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     t = threading.Thread(target = run,args = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t-%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;i,))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     t.setDaemon(True)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把当前线程设置成守护线程，要在start()之前&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    t_objs.append(t)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----all threads has finished....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,threading.current_thread(),threading.active_count())
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cost : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,time.time()-start_time)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 运行结果：task has done都没有运行，主线程结束之后，所有子线程都强制结束&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202004824953-2513321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; Semaphore(信号量)&lt;/h3&gt;
&lt;p&gt;互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据，如有3个座位，最多允许3个人同时在座位上，后面的人只能等到有人起来才能够坐进去&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(n):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    semaphore.acquire()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run the thread:%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;n)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    semaphore.release()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;10&lt;/span&gt;     semaphore = threading.BoundedSemaphore(5)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;最多允许5个线程同时运行&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;  range(20&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         t = threading.Thread(target = run,args=&lt;span&gt;(i,))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        t.start()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; threading.active_count() != 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(threading.active_count())&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----all threads done---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;一次性执行了5个线程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;和线程锁差不多，都要acquire()和release(),区别就是&lt;span&gt;信号量有多把锁，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;threading.BoundedSemaphore(5)最多允许5个线程同时运行，那运行结果就是5个结果一起出来，但是实质是这5个要是有3个先完成就会立刻再送进去3个，它不会等5个都完成，它是每出来一个就放进去一个&lt;/p&gt;
&lt;p&gt;这5个如果同时改数据就有可能改错，这个&lt;span&gt;主要用于：&lt;/span&gt;链接池 ，线程池。mysql链接有链接池的概念，同一时刻最多有几个并发；socketserver，为了保证系统不会被太多线程拉慢，可以用信号量弄同一时刻最多有100个链接进来&lt;/p&gt;
&lt;h3&gt;事件（event）&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;a events is a simple synchronization object;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;the event represents an internal flag,and threads can wait for the flag to be set,or set or clear the flag themselves&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;事件是一个简单的同步对象，事件就相当于设置一个全部变量，然后线程不断的检测这个变量的变化然后进行不同的操作&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;p&gt;　　event = threading.Event()生成一个event对象&lt;/p&gt;
&lt;p&gt;　　event.set()&lt;/p&gt;
&lt;p&gt;　　event.clear()&lt;/p&gt;
&lt;p&gt;　　event.wait()&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;if the flag is set,the wait method doesn't do anything&lt;/span&gt;&lt;br/&gt;&lt;span&gt;标志位设定，代表绿灯，直接通行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if the flag is cleared,wait will block until it becomes set again&lt;/span&gt;&lt;br/&gt;&lt;span&gt;标志位被清空，代表红灯，wait等待变绿灯&lt;/span&gt;&lt;br/&gt;&lt;span&gt;any number of threads my wait for the same event&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;红绿灯案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; event =&lt;span&gt; threading.Event()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; lighter():
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     event.set()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;一开始先设成绿灯&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; count &amp;gt; 5 &lt;span&gt;and&lt;/span&gt; count &amp;lt;=10 :&lt;span&gt;#&lt;/span&gt;&lt;span&gt;改成红灯&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             event.clear()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;清空标志位&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[41;1mred light is on ...\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; count &amp;gt; 10&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             event.set()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;变绿灯&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[42;1mgreen light is on ...\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[42;1mgreen light is on ...\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         count += 1
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; car(name):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; event.is_set():&lt;span&gt;#&lt;/span&gt;&lt;span&gt;代表绿灯&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[%s] running...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;name)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[%s] sees red light,waiting...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;name)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            event.wait()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[34;1m[%s] green light is on,start going ...\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;name)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; light = threading.Thread(target =&lt;span&gt; lighter,)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;light.start()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; car1 = threading.Thread(target = car,args=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tesla&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; car1.start()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202141841515-399669257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;queue队列&lt;/h3&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;span&gt;queue is especially useful in threaded programming when information must be exchanged safely between multiple threads&lt;/span&gt;&lt;p&gt;&lt;span&gt;class queue.Queue(maxsize = 0)先入先出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class queue.LifeQuene(maxsize = 0)last in first out&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class queue.PriorityQueue(maxsize = 0)存储数据时可设置优先级的队列&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;队列就是一个有顺序的容器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;列表和队列的区别：列表取出数据后，数据还在列表中，相当如复制数据；队列的数据只有一份，取走就没有了&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;h4&gt; class queue.Queue:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202142557140-1485094103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用put(),get()方法往队列里加减数据，用qsize()方法得到此刻队列中还有多少数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是有一个问题：当数据都取出来之后，如果还用get()方法去取数据的话，程序就会卡主&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202142946953-905419446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以用&lt;span&gt;get_nowait()&lt;/span&gt;方法，如果queue中没有了数据，就会抛出一个异常，这样就不会被卡住，同时也可以用qsize()方法进行判断，如果没有了数据就不要取了&lt;/p&gt;
&lt;p&gt;Queue.get(block = True,timeout=None)    block参数，如果取不到数据，默认就会卡住，改成false就不会卡住；timeout设置卡住几秒&lt;/p&gt;
&lt;h4&gt;class queue.LifoQueue(maxsize = 0)#last in first out&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; q =&lt;span&gt; queue.LifoQueue()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; q.put(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; q.put(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; q.put(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(q.get())
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202143717328-226608196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;class queue.PriorityQueue(maxsize = 0)#存储数据室可以设置优先级队列&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; q =&lt;span&gt; queue.PriorityQueue()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; q.put((10,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; q.put((-1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; q.put((3,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; q.put((6,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(q.get())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202143912296-1716184474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;生产者消费者模型：&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;在并发编程中使用生产者和消费者模式能够解决大多数并发问题，该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; 例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; q = queue.Queue(maxsize = 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Producer(name):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     count = 1
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         q.put(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;骨头:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;count)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生产了骨头:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,count)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         count += 1
&lt;span&gt;10&lt;/span&gt;         time.sleep(0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Consumer(name):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; q.qsize() &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[%s] 取到 [%s],并且吃到了它。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(name,q.get()))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; p = threading.Thread(target = Producer,args=(&lt;span&gt;&quot;xiaoming&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; c = threading.Thread(target = Consumer,args=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaohong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; c1 = threading.Thread(target = Consumer,args=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liangliang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;p.start()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;c.start()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; c1.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180202144619671-288067852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 02 Feb 2018 06:48:00 +0000</pubDate>
<dc:creator>﹏亦&amp;#176;洛轩づ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charles8866/p/8402291.html</dc:identifier>
</item>
<item>
<title>AQS 框架之 LockSupport 线程阻塞工具类 - romanjoy</title>
<link>http://www.cnblogs.com/romanjoy/p/8399438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/romanjoy/p/8399438.html</guid>
<description>&lt;p&gt;&lt;span&gt;■ &lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　并发包一直是 JDK 里面比较难理解的，同时也是很精美的语言，膜拜下 Doug Li 大神。作者不敢长篇大论，只求循序渐进地把并发包通过理论和实战 (代码) 的方式介绍给大家。&lt;/p&gt;
&lt;p&gt;其实做每一件事都是挺难的，不过只要下笔就不会瞻前顾后。谢谢大家的鼓励帮助，感谢我的好基友KIRA~  好的，热身先从 &lt;strong&gt;LockSupport&lt;/strong&gt; 开始吧~&lt;/p&gt;

&lt;p&gt;&lt;span&gt;■ &lt;strong&gt;LockSupport&lt;/strong&gt; 综述&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;： LockSupport 是一个线程阻塞工具类，可用于在线程内任意位置让线程阻塞和释放&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;： LockSupport 通常不会被直接使用，更多是作为锁实现的基础工具类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;： LockSupport 底层依赖UnSafe实现，即 park() 和 unpark() 原语方法，通过&quot;许可&quot;替代状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;/strong&gt;： park方法用于线程等待&quot;许可&quot;，unpark方法用于为线程提供&quot;许可&quot;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;补充1&lt;/strong&gt;：由于&quot;许可&quot;的存在，当出现一个线程调用park方法，其他线程调用unpark方法时，会保持活跃&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;补充2&lt;/strong&gt;：若开JVM篇的话笔者会从JVM源码角度再次解析park和unpark的底层实现，其实质用mutex和condition维护一个_counter(park-&amp;gt;0，unpark-&amp;gt;1)的变量，即&quot;许可&quot;是一次性的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;补充3&lt;/strong&gt;：此番为 &lt;span&gt;AQS 框架之综述 (赶制中)&lt;/span&gt; 的子番&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;■ &lt;strong&gt;LockSupport&lt;/strong&gt; 数据结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　1. 类定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LockSupport 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   2. 构造器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有构造器，不能被实例化 -- 实质就是个工作类，只能调用静态方法&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; LockSupport() {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot be instantiated.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  3. UnSafe&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hotspot implementation via intrinsics API&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; sun.misc.Unsafe UNSAFE;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因，其表示parkBlocker在内存的偏移量
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;之所以用偏移量是因为parkBlockerOffset被赋值时线程必须是阻塞的，阻塞时直接调方法无效只能走内存&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; parkBlockerOffset;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; SEED;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; PROBE;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; SECONDARY;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        UNSAFE &lt;/span&gt;=&lt;span&gt; sun.misc.Unsafe.getUnsafe();
        Class&lt;/span&gt;&amp;lt;?&amp;gt; tk = Thread.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定变量的内存偏移量&lt;/span&gt;
        parkBlockerOffset =&lt;span&gt; UNSAFE.objectFieldOffset
            (tk.getDeclaredField(&lt;/span&gt;&quot;parkBlocker&quot;&lt;span&gt;));
        SEED &lt;/span&gt;=&lt;span&gt; UNSAFE.objectFieldOffset
            (tk.getDeclaredField(&lt;/span&gt;&quot;threadLocalRandomSeed&quot;&lt;span&gt;));
        PROBE &lt;/span&gt;=&lt;span&gt; UNSAFE.objectFieldOffset
            (tk.getDeclaredField(&lt;/span&gt;&quot;threadLocalRandomProbe&quot;&lt;span&gt;));
        SECONDARY &lt;/span&gt;=&lt;span&gt; UNSAFE.objectFieldOffset
            (tk.getDeclaredField(&lt;/span&gt;&quot;threadLocalRandomSecondarySeed&quot;&lt;span&gt;));
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Exception ex) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(ex); }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  4. permit (许可)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;LockSupport&lt;/strong&gt; 和每个使用它的线程都与一个permit关联，某种意义上可认为是 &lt;strong&gt;Semaphore&lt;/strong&gt; 类，但区别于Semaphores，permit至多只有一个，并不能被累加（即重复调动unpark也不会累加，最多为1）&lt;/li&gt;
&lt;li&gt;permit 相当于一个开关(只有0和1两个值)，默认为0，执行过程如下：
&lt;ul&gt;&lt;li&gt;调用unpark方法，permit+1，即permit=1&lt;/li&gt;
&lt;li&gt;调用park方法，permit被消费-1，即permit=0，同时park方法理解返回&lt;/li&gt;
&lt;li&gt;再次调用park方法，线程会被阻塞(此时permit=0，线程无许可可用，直到permit=1之前都会被阻塞)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;■ &lt;strong&gt;LockSupport&lt;/strong&gt; 数据结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　1. setBlocker / getBlocker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Returns the blocker object supplied to the most recent
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * invocation of a park method that has not yet unblocked, or null
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * if not blocked.  The value returned is just a momentary
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * snapshot -- the thread may have since unblocked or blocked on a
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * different blocker object.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; *  返回提供给最近一次尚未解除阻塞的被park方法调用的blocker对象，如果该调用未阻塞，则返回null
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t the thread
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the blocker
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if argument is null
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.6
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getBlocker(Thread t) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; UNSAFE.getObjectVolatile(t, parkBlockerOffset);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  * This object is recorded while the thread is blocked to permit monitoring and diagnostic 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  * tools to identify the reasons that threads are blocked.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  * 此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBlocker(Thread t, Object arg) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Even though volatile, hotspot doesn't need a write barrier here.&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    UNSAFE.putObject(t, parkBlockerOffset, arg);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;通过线程 &lt;strong&gt;Dump&lt;/strong&gt; 查看一下，可以很明显的看到阻塞的堆栈信息，但其实信息是差不多一样的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/830545/201802/830545-20180201180524671-1607184487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;· 2. park&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：该方法用于等待&quot;许可&quot;，调用时可能发生以下两种情况：
&lt;ul&gt;&lt;li&gt;当&quot;许可&quot;可用时，立即返回并且消费这个许可(将许可变成不可用)&lt;/li&gt;
&lt;li&gt;当&quot;许可&quot;不可用时，当前线程可能被阻塞 java.lang.Thread.State : WAITING parking&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;/strong&gt;： 由于park方法可能在任何时候&quot;无理由&quot;返回，因此通常会在循环中使用(在返回之前再次检查条件)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用&lt;/strong&gt;： park方法是&quot;busy wait&quot;(忙碌等待)的一种优化 (即不需要在自旋上浪费太多时间)，但它必须与 unpark 配对使用才更高效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;： park方法的许可默认是被占用的，在unpark之前调用会获取不到许可而被阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; park() {
    UNSAFE.park(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, 0L&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纳秒级超时返回&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; parkNanos(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;gt; 0&lt;span&gt;)
        UNSAFE.park(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, nanos);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;毫秒级限时等待
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里的时间需要使用系统时间加上需要等待的时间
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LockSupport.parkUntil(System.currentTimeMillis() + 3000);&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; parkUntil(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; deadline) {
    UNSAFE.park(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, deadline);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三种形式的 park 还各自支持一个 blocker 对象参数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建议最好使用这些形式，而不是不带此参数的原始形式
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在锁实现中提供的作为 blocker 的普通参数是 this&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; park(Object blocker) {
    Thread t &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
    setBlocker(t, blocker);
    UNSAFE.park(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, 0L&lt;span&gt;);
    setBlocker(t, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; parkNanos(Object blocker, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;gt; 0&lt;span&gt;) {
        Thread t &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
        setBlocker(t, blocker);
        UNSAFE.park(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, nanos);
        setBlocker(t, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; parkUntil(Object blocker, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; deadline) {
    Thread t &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
    setBlocker(t, blocker);
    UNSAFE.park(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, deadline);
    setBlocker(t, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;· 3. unpark&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;： 该方法用于提供&quot;许可&quot;，会将还不可用的&quot;许可&quot;变成可用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;： 由于 park方法默认是许可占有并阻塞线程，因此调用 park之前最好先调用 unpark (当然因为 park\unpark 的顺序解耦性，所以前后执行顺序无所谓，只是代码上最好遵循 先释放再获取 的规则)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * 注意：必须指定一个线程(但无所谓该线程是否park)，将尝试释放其可能拥有的许可
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unpark(Thread thread) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (thread != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        UNSAFE.unpark(thread);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;· 4. &lt;strong&gt;LockSupport&lt;/strong&gt; 不可重入&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不可重入&lt;/strong&gt;： LockSupport 不可重入，当一个线程多次调用 park 方法，线程将被第二个 park 方法阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     LockSupport.unpark(Thread.currentThread());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们直接用主线程&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     System.out.println(&quot;执行unpark&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    LockSupport.park();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     System.out.println(&quot;执行第一次park&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    LockSupport.park();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     System.out.println(&quot;执行第二次park&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; ---------------------
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;执行unpark
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;执行第一次park
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分析：通过打印结果可以发现第7行其实并没有被打印，根据下面的图片可以看到线程在第7行(对应图片的第16行)上阻塞&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;strong&gt;jstack&lt;/strong&gt; 命令查看一下线程状态，会发现线程是 &lt;strong&gt;WAITING&lt;/strong&gt; 状态，即等待阻塞，而且还是被 park方法阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/830545/201802/830545-20180202105844093-1768987313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; ·5. &lt;strong&gt;LockSupport&lt;/strong&gt; 与中断&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;中断响应&lt;/strong&gt;： LockSupport支持中断响应，线程调用park阻塞时仍能够响应中断请求，但不会抛出InterruptedException异常&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((System.currentTimeMillis() - start) &amp;lt;= 1000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;空转1s&lt;/span&gt;
        System.out.println(&quot;空转1s结束&quot;&lt;span&gt;);
        LockSupport.park();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待&quot;许可&quot;&lt;/span&gt;
        System.out.println(Thread.currentThread().getName() + &quot;是否被中断：&quot; 
            +&lt;span&gt; Thread.currentThread().isInterrupted());
    },&lt;/span&gt;&quot;kira&quot;&lt;span&gt;);
    thread.start();
    thread.interrupt();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断线程&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;---------------------
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：&lt;/span&gt;
&lt;span&gt;空转1s结束
kira是否被中断：&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分析：通过先中断线程再park可以发现可获取中断响应，同时并没有抛出任何异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; ■ suspend()  VS  wait()  VS  park()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　 1. suspend() VS wait()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;suspend() 不会释放锁，wait()会释放锁同时还支持超时处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    2. suspend() VS wait()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LockSupport 解决了suspend()不释放锁从而容易死锁的问题，比如resume()方法被阻塞时，即其他线程在调用 resume()方法之前获取同步锁时被阻塞而导致 resume()方法无法执行进而导致死锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    3. park() VS wait()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;LockSupport&lt;/strong&gt; 不需要先获得某个对象的锁，也不会排除 InterruptedException异常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unpark &lt;/strong&gt;方法可以先于park方法调用，其没有方法调用的时序问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wait/notify&lt;/strong&gt; 机制有个问题在于线程调用notify方法去唤醒其他线程时，需要保证需被唤醒线程必须被wait方法阻塞，否则被唤醒线程会永远处于 &lt;strong&gt;WAITING &lt;/strong&gt;状态，同时notify方法只能唤醒一个线程，当同时有多个线程在同一个对象上 &lt;strong&gt;wait &lt;/strong&gt;等待，就只能有一个线程可以被唤醒(不能指定)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;park/unpark&lt;/strong&gt; 机制通过引入单个&quot;许可&quot;的概念实现对线程同步的解耦，线程间无须关心对方的状态，因为不需要一个变量专门用于存储状态&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Fri, 02 Feb 2018 06:40:00 +0000</pubDate>
<dc:creator>romanjoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/romanjoy/p/8399438.html</dc:identifier>
</item>
<item>
<title>jdk源码-&gt;集合-&gt;ConcurrentHashMap - unbelievableme</title>
<link>http://www.cnblogs.com/kundeg/p/8399144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kundeg/p/8399144.html</guid>
<description>&lt;h2 id=&quot;类的属性&quot;&gt;类的属性&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class ConcurrentHashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;
    implements ConcurrentMap&amp;lt;K,V&amp;gt;, Serializable {
    private static final long serialVersionUID = 7249069246763182397L;
    // 表的最大容量
    private static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
    // 默认表的大小
    private static final int DEFAULT_CAPACITY = 16;
    // 最大数组大小
    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    // 默认并发数
    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
    // 装载因子
    private static final float LOAD_FACTOR = 0.75f;
    // 链表转化为红黑树的阈值
    static fial int TREEIFY_THRESHOLD = 8;
    // 红黑树转化为链表的阈值
    static final int UNTREEIFY_THRESHOLD = 6;
    //当数组长度还未超过64,优先数组的扩容,否则将链表转为红黑树
    static final int MIN_TREEIFY_CAPACITY = 64;
    //扩容时任务的最小转移节点数
    private static final int MIN_TRANSFER_STRIDE = 16;
    // sizeCtl中记录stamp的位数
    private static int RESIZE_STAMP_BITS = 16;
    // 进行扩容所允许的最大线程数
    private static final int MAX_RESIZERS = (1 &amp;lt;&amp;lt; (32 - RESIZE_STAMP_BITS)) - 1;
    // 记录sizeCtl中的大小所需要进行的偏移位数
    private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;    
    // 一系列的标识
    static final int MOVED     = -1; // 结点扩容时，设置的占位结点的hash值
    static final int TREEBIN   = -2; // 链表已经转化为了红黑树，那么桶中第一个元素的hash值(也就是数组中的结点)设置为TREEBIN
    static final int RESERVED  = -3; // hash for transient reservations
    static final int HASH_BITS = 0x7fffffff; // 即为int的最大值：2的31次幂-1
    // 
    /** Number of CPUS, to place bounds on some sizings */
    // 获取可用的CPU个数
    static final int NCPU = Runtime.getRuntime().availableProcessors();
    // 
    /** For serialization compatibility. */
    // 进行序列化的属性
    private static final ObjectStreamField[] serialPersistentFields = {
        new ObjectStreamField(&quot;segments&quot;, Segment[].class),
        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),
        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)
    };
    
    // volatile修饰table，保证对table[i]的修改对其他线程是可见的
    transient volatile Node&amp;lt;K,V&amp;gt;[] table;
    // 下一个表
    private transient volatile Node&amp;lt;K,V&amp;gt;[] nextTable;
    //
    /**
     * Base counter value, used mainly when there is no contention,
     * but also as a fallback during table initialization
     * races. Updated via CAS.
     */
    // 基本计数
    private transient volatile long baseCount;
    /**
    sizeCtl是一个控制标志符：
    负数代表正在进行初始化或扩容操作
    -1代表正在初始化
    -N 表示有N-1个线程正在进行扩容操作
    正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的
    **/
    private transient volatile int sizeCtl;
    
    /**
     * The next table index (plus one) to split while resizing.
     */
    // 扩容时用到，初始时为table.length，表示从索引 0 到transferIndex的节点还未转移
    private transient volatile int transferIndex;

    /**
     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.
     */
    // 旋转锁
    private transient volatile int cellsBusy;

    /**
     * Table of counter cells. When non-null, size is a power of 2.
     */
    // counterCell表
    private transient volatile CounterCell[] counterCells;

    // views
    // 视图
    private transient KeySetView&amp;lt;K,V&amp;gt; keySet;
    private transient ValuesView&amp;lt;K,V&amp;gt; values;
    private transient EntrySetView&amp;lt;K,V&amp;gt; entrySet;
    
    // Unsafe 静态块
    private static final sun.misc.Unsafe U;
    private static final long SIZECTL;
    private static final long TRANSFERINDEX;
    private static final long BASECOUNT;
    private static final long CELLSBUSY;
    private static final long CELLVALUE;
    private static final long ABASE; //node数组第一个结点的地址
    private static final int ASHIFT; //node数组结点相对第一个结点的偏移地址

    static {
        try {
            U = sun.misc.Unsafe.getUnsafe();
            Class&amp;lt;?&amp;gt; k = ConcurrentHashMap.class;
            //获取ConcurrentHashMap这个对象字段sizeCtl在内存中的偏移量
            SIZECTL = U.objectFieldOffset
                (k.getDeclaredField(&quot;sizeCtl&quot;));
            TRANSFERINDEX = U.objectFieldOffset
                (k.getDeclaredField(&quot;transferIndex&quot;));
            BASECOUNT = U.objectFieldOffset
                (k.getDeclaredField(&quot;baseCount&quot;));
            CELLSBUSY = U.objectFieldOffset
                (k.getDeclaredField(&quot;cellsBusy&quot;));
            Class&amp;lt;?&amp;gt; ck = CounterCell.class;
            CELLVALUE = U.objectFieldOffset
                (ck.getDeclaredField(&quot;value&quot;));
            Class&amp;lt;?&amp;gt; ak = Node[].class;
            //可以获取数组第一个元素的偏移地址
            ABASE = U.arrayBaseOffset(ak);
            int scale = U.arrayIndexScale(ak);
            if ((scale &amp;amp; (scale - 1)) != 0)
                throw new Error(&quot;data type scale not a power of two&quot;);
            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内部结点类&quot;&gt;内部结点类&lt;/h2&gt;
&lt;h3 id=&quot;node结点&quot;&gt;Node结点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //最基础的结点，后面三种都继承与它，hash，key，val，next都可以在初始化的时候指定
    static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        //保证在更新结点的值后对其他线程可见
        volatile V val;
        //保证在更新结点的next域后对其他线程可见，例如：put方法在尾部添加结点
        volatile Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.val = val;
            this.next = next;
        }
        //在其子类结点中，find方法都将被重写，对于不同的结构(链表，红黑树，空结点)都有不同的find实现
        Node&amp;lt;K,V&amp;gt; find(int h, Object k) {
            Node&amp;lt;K,V&amp;gt; e = this;
            if (k != null) {
                do {
                    K ek;
                    if (e.hash == h &amp;amp;&amp;amp;
                        ((ek = e.key) == k || (ek != null &amp;amp;&amp;amp; k.equals(ek))))
                        return e;
                } while ((e = e.next) != null);
            }
            return null;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;forwardingnode结点&quot;&gt;ForwardingNode结点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //在扩容时，设置的一个空结点(占位结点)
    static final class ForwardingNode&amp;lt;K,V&amp;gt; extends Node&amp;lt;K,V&amp;gt; {
        final Node&amp;lt;K,V&amp;gt;[] nextTable;
        ForwardingNode(Node&amp;lt;K,V&amp;gt;[] tab) {
            //ForwardingNode的属性不能指定，其hash设计为了MOVED
            super(MOVED, null, null, null);
            this.nextTable = tab;
        }
        //ForwardingNode的find方法,去newTable中查找
        Node&amp;lt;K,V&amp;gt; find(int h, Object k) {
            // loop to avoid arbitrarily deep recursion on forwarding nodes
            outer: for (Node&amp;lt;K,V&amp;gt;[] tab = nextTable;;) {
                Node&amp;lt;K,V&amp;gt; e; int n;
                if (k == null || tab == null || (n = tab.length) == 0 ||
                    (e = tabAt(tab, (n - 1) &amp;amp; h)) == null)
                    return null;
                for (;;) {
                    int eh; K ek;
                    if ((eh = e.hash) == h &amp;amp;&amp;amp;
                        ((ek = e.key) == k || (ek != null &amp;amp;&amp;amp; k.equals(ek))))
                        return e;
                    if (eh &amp;lt; 0) {
                        if (e instanceof ForwardingNode) {
                            tab = ((ForwardingNode&amp;lt;K,V&amp;gt;)e).nextTable;
                            continue outer;
                        }
                        else
                            return e.find(h, k);
                    }
                    if ((e = e.next) == null)
                        return null;
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;treenode结点&quot;&gt;TreeNode结点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //链表转换为红黑树的时候，先将链表中的所有Node转换为Treeode，也就是说TreeNode是保存key-value键值对的红黑树结点，但此时红黑树尚未建立，需要TreeBin
    static final class TreeNode&amp;lt;K,V&amp;gt; extends Node&amp;lt;K,V&amp;gt; {
        TreeNode&amp;lt;K,V&amp;gt; parent;  // red-black tree links
        TreeNode&amp;lt;K,V&amp;gt; left;
        TreeNode&amp;lt;K,V&amp;gt; right;
        TreeNode&amp;lt;K,V&amp;gt; prev;    // needed to unlink next upon deletion
        boolean red;

        TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next,
                 TreeNode&amp;lt;K,V&amp;gt; parent) {
            //属性可以指定
            super(hash, key, val, next);
            this.parent = parent;
        }

        Node&amp;lt;K,V&amp;gt; find(int h, Object k) {
            return findTreeNode(h, k, null);
        }

        //红黑树的实际find方法
        final TreeNode&amp;lt;K,V&amp;gt; findTreeNode(int h, Object k, Class&amp;lt;?&amp;gt; kc) {
            if (k != null) {
                TreeNode&amp;lt;K,V&amp;gt; p = this;
                do  {
                    int ph, dir; K pk; TreeNode&amp;lt;K,V&amp;gt; q;
                    TreeNode&amp;lt;K,V&amp;gt; pl = p.left, pr = p.right;
                    if ((ph = p.hash) &amp;gt; h)
                        p = pl;
                    else if (ph &amp;lt; h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null &amp;amp;&amp;amp; k.equals(pk)))
                        return p;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null)
                        p = pl;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &amp;amp;&amp;amp;
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir &amp;lt; 0) ? pl : pr;
                    else if ((q = pr.findTreeNode(h, k, kc)) != null)
                        return q;
                    else
                        p = pl;
                } while (p != null);
            }
            return null;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;treebin结点&quot;&gt;TreeBin结点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //TreeBin不负责包装key-value键值对，它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象
    static final class TreeBin&amp;lt;K,V&amp;gt; extends Node&amp;lt;K,V&amp;gt; {
            TreeNode&amp;lt;K,V&amp;gt; root;
           volatile TreeNode&amp;lt;K,V&amp;gt; first;
           volatile Thread waiter;
           volatile int lockState;
          // values for lockState
           static final int WRITER = 1; // set while holding write lock
           static final int WAITER = 2; // set when waiting for write lock
           static final int READER = 4; // increment value for setting read lock

           //实例化TreeBin时传入TreeNode的根节点，构造TreeBin的作用是：将还是链表结构的TreeNode转换为了红黑树
           TreeBin(TreeNode&amp;lt;K,V&amp;gt; b) {
           //无法指定属性，TreeBin专属hashTREEBIN
            super(TREEBIN, null, null, null);
            this.first = b;
            TreeNode&amp;lt;K,V&amp;gt; r = null;
            for (TreeNode&amp;lt;K,V&amp;gt; x = b, next; x != null; x = next) {
                next = (TreeNode&amp;lt;K,V&amp;gt;)x.next;
                x.left = x.right = null;
                if (r == null) {
                    x.parent = null;
                    x.red = false;
                    r = x;
                }
                else {
                    K k = x.key;
                    int h = x.hash;
                    Class&amp;lt;?&amp;gt; kc = null;
                    for (TreeNode&amp;lt;K,V&amp;gt; p = r;;) {
                        int dir, ph;
                        K pk = p.key;
                        if ((ph = p.hash) &amp;gt; h)
                            dir = -1;
                        else if (ph &amp;lt; h)
                            dir = 1;
                        else if ((kc == null &amp;amp;&amp;amp;
                                  (kc = comparableClassFor(k)) == null) ||
                                 (dir = compareComparables(kc, k, pk)) == 0)
                            dir = tieBreakOrder(k, pk);
                            TreeNode&amp;lt;K,V&amp;gt; xp = p;
                        if ((p = (dir &amp;lt;= 0) ? p.left : p.right) == null) {
                            x.parent = xp;
                            if (dir &amp;lt;= 0)
                                xp.left = x;
                            else
                                xp.right = x;
                            r = balanceInsertion(r, x);
                            break;
                        }
                    }
                }
            }
            this.root = r;
            assert checkInvariants(root);
        }
        //TreeBin的find方法主要用来进行同步控制，实质还是调用TreeNode的find方法
        final Node&amp;lt;K,V&amp;gt; find(int h, Object k) {
            if (k != null) {
                for (Node&amp;lt;K,V&amp;gt; e = first; e != null; ) {
                    int s; K ek;
                    if (((s = lockState) &amp;amp; (WAITER|WRITER)) != 0) {
                        if (e.hash == h &amp;amp;&amp;amp;
                            ((ek = e.key) == k || (ek != null &amp;amp;&amp;amp; k.equals(ek))))
                            return e;
                        e = e.next;
                    }
                    else if (U.compareAndSwapInt(this, LOCKSTATE, s,
                                                 s + READER)) {
                        TreeNode&amp;lt;K,V&amp;gt; r, p;
                        try {
                            p = ((r = root) == null ? null :
                                 r.findTreeNode(h, k, null));
                        } finally {
                            Thread w;
                            if (U.getAndAddInt(this, LOCKSTATE, -READER) ==
                                (READER|WAITER) &amp;amp;&amp;amp; (w = waiter) != null)
                                LockSupport.unpark(w);
                        }
                        return p;
                    }
                }
            }
            return null;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;构造函数&lt;/h2&gt;
&lt;h3 id=&quot;concurrenthashmap&quot;&gt;ConcurrentHashMap()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public ConcurrentHashMap() {
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;concurrenthashmapint&quot;&gt;ConcurrentHashMap(int)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    public ConcurrentHashMap(int initialCapacity) {
        if (initialCapacity &amp;lt; 0) // 初始容量小于0，抛出异常
            throw new IllegalArgumentException();
        // 最接近initialCapacity的2的次幂值作为容量
        int cap = ((initialCapacity &amp;gt;= (MAXIMUM_CAPACITY &amp;gt;&amp;gt;&amp;gt; 1)) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor(initialCapacity + (initialCapacity &amp;gt;&amp;gt;&amp;gt; 1) + 1)); 
        // 初始化 sizeCtl为正，尚未初始化，其数值为容量大小
        this.sizeCtl = cap;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;concurrenthashmapint-float-int型构造函数&quot;&gt;ConcurrentHashMap(int, float, int)型构造函数　&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor &amp;gt; 0.0f) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0) // 合法性判断
            throw new IllegalArgumentException();
        if (initialCapacity &amp;lt; concurrencyLevel)   
            //并发级别要小于等于桶的个数
            initialCapacity = concurrencyLevel;   
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size &amp;gt;= (long)MAXIMUM_CAPACITY) ?
            MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.sizeCtl = cap;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;核心函数分析&quot;&gt;核心函数分析&lt;/h2&gt;
&lt;h3 id=&quot;putvalk-key-v-value-boolean-onlyifabsent&quot;&gt;putVal(K key, V value, boolean onlyIfAbsent)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;final V putVal(K key, V value, boolean onlyIfAbsent) {
        //合法性检验
        if (key == null || value == null) throw new NullPointerException(); 
        //hash = (key.hashCode ^ (key.hashCode &amp;gt;&amp;gt;&amp;gt; 16)) &amp;amp; HASH_BITS
        int hash = spread(key.hashCode());
        int binCount = 0;
        //不断自旋，因为在initTable和casTabAt用到了compareAndSwapInt、compareAndSwapObject等CAS操作，同步线程竞争的时候，一些尝试就会失败，所以这边要加一个for循环，在失败后继续put结点
        for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) { 
            Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
            // 表为空或者表的长度为0
            if (tab == null || (n = tab.length) == 0) 
                // 初始化表
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) { // 表中key对应的桶为空
                if (casTabAt(tab, i, null,
                             new Node&amp;lt;K,V&amp;gt;(hash, key, value, null))) // CAS操作，实例化一个结点放在该桶中
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED) //说明该结点正在扩容中
                // 去帮助扩容
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) { // 有点分段锁的味道，只是锁住了tab[i]
                //这个判断是非常重要的，有可能在获得该桶的锁之前，正在进行在扩容，获得该桶的锁之后，桶中只有ForwardingNode，如果是这种情况，if判断失败，上述for循环继续put
                    if (tabAt(tab, i) == f) { 
                        if (fh &amp;gt;= 0) { // 该table表中该结点的hash值大于0
                            // binCount赋值为1
                            binCount = 1;
                            for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) { // 无限循环
                                K ek;
                                if (e.hash == hash &amp;amp;&amp;amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;amp;&amp;amp; key.equals(ek)))) { // 判断key是否相等
                                    // 记住该结点的val值
                                    oldVal = e.val;
                                    if (!onlyIfAbsent) // 进行判断
                                        // 将指定的value保存至结点，即进行了结点值的更新
                                        e.val = value;
                                    break;
                                }
                                // 保存当前结点
                                Node&amp;lt;K,V&amp;gt; pred = e;
                                if ((e = e.next) == null) { // 移向链表中的下一个结点，如果为null，就实例化一个结点尾插
                                    
                                    pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                              value, null);
                                    // 退出循环
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) { // 结点为红黑树结点类型
                            Node&amp;lt;K,V&amp;gt; p;
                            // binCount赋值为2
                            binCount = 2;
                            if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                           value)) != null) { // 将hash、key、value放入红黑树
                                // 保存结点的val
                                oldVal = p.val;
                                if (!onlyIfAbsent) // 判断
                                    // 赋值结点value值
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) { // binCount不为0
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD) // 如果binCount大于等于转化为红黑树的阈值
                        // 进行转化
                        treeifyBin(tab, i);
                    if (oldVal != null) // 旧值不为空
                        // 返回旧值
                        return oldVal;
                    break;
                }
            }
        }
        // 增加binCount的数量
        addCount(1L, binCount);
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;put流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算当前key的hash值，根据hash值计算索引 i （i=(table.length - 1) &amp;amp; hash）；&lt;/li&gt;
&lt;li&gt;如果当前table为null，说明是第一次进行put操作，调用initTable()初始化table；&lt;/li&gt;
&lt;li&gt;如果索引 i 位置的节点 f 为空，则直接把当前值作为新的节点直接插入到索引 i 位置；&lt;/li&gt;
&lt;li&gt;如果节点 f 的hash为-1（f.hash == MOVED(-1)），说明当前节点处于移动状态（或者说是其他线程正在对 f 节点进行转移/扩容操作），此时调用helpTransfer(tab, f)帮助转移/扩容；&lt;/li&gt;
&lt;li&gt;如果不属于上述条件，说明已经有元素存储到索引 i 处，此时需要对索引 i 处的节点 f 进行 put or update 操作，首先使用内置锁 synchronized 对节点 f 进行加锁：&lt;br/&gt;如果f.hash&amp;gt;=0，说明 i 位置是一个链表，并且节点 f 是这个链表的头节点，则对 f 节点进行遍历，此时分两种情况：&lt;br/&gt;--如果链表中某个节点e的hash与当前key的hash相同，则对这个节点e的value进行修改操作。&lt;br/&gt;--如果遍历到链表尾都没有找到与当前key的hash相同的节点，则把当前K-V作为一个新的节点插入到这个链表尾部。&lt;/li&gt;
&lt;li&gt;如果节点 f 是TreeBin节点(f instanceof TreeBin)，说明索引 i 位置的节点是一个红黑树，则调用putTreeVal方法找到一个已存在的节点进行修改，或者是把当前K-V放入一个新的节点（put or update）。&lt;/li&gt;
&lt;li&gt;完成插入后，如果索引 i 处是一个链表，并且在插入新的节点后节点数&amp;gt;8，则调用treeifyBin把链表转换为红黑树。&lt;br/&gt;最后，调用addCount更新元素数量&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;node-inittable&quot;&gt;Node[] initTable()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    private final Node&amp;lt;K,V&amp;gt;[] initTable() {
        Node&amp;lt;K,V&amp;gt;[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) { // 不断循环
            i ((sc = sizeCtl) &amp;lt; 0f) // sizeCtl小于0，正在初始化，则进行线程让步等待
                Thread.yield(); // lost initialization race; just spin
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { // CAS操作，比较sizeCtl的值与sc是否相等，相等则用-1替换
                try {
                    if ((tab = table) == null || tab.length == 0) { // table表为空或者大小为0
                        // sc的值即容量设定值是否大于0，若是，则n为sc，否则，n为默认初始容量
                        int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings(&quot;unchecked&quot;)
                        // 实例化结点数组
                        Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];
                        // 内部table引用指向该数组
                        table = tab = nt;
                        // sc为n * 0.75
                        sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                    }
                } finally {
                    // 设置sizeCtl的值
                    sizeCtl = sc;
                }
                break;
            }
        }
        // 返回table表
        return tab;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;tabatnode-tab-int-i&quot;&gt;tabAt(Node[] tab, int i)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/*
 *i为什么要等于((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE呢,计算偏移量
 *ASHIFT是指tab[i]中第i个元素在相对数组第一个元素于的偏移量，而ABASE就算第一数组的内存素的偏移地址
 *所以呢，((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE就算i最后的地址，因此tabAt函数拿到的是table[i]的最新值
*/
static final &amp;lt;K,V&amp;gt; Node&amp;lt;K,V&amp;gt; tabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i) {
        return (Node&amp;lt;K,V&amp;gt;)U.getObjectVolatile(tab, ((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;castabatnode-tab-int-i-node-c-node-v&quot;&gt;casTabAt(Node[] tab, int i, Node c, Node v)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//compareAndSwapObject的作用就算tab[i]和c比较，如果相等就tab[i]=v否则tab[i]=c;
    static final &amp;lt;K,V&amp;gt; boolean casTabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i,
                                        Node&amp;lt;K,V&amp;gt; c, Node&amp;lt;K,V&amp;gt; v) {
        return U.compareAndSwapObject(tab, ((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE, c, v);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;helptransfernode-tab-node-f&quot;&gt;helpTransfer(Node[] tab, Node f)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//帮助其他线程进行转移操作
final Node&amp;lt;K,V&amp;gt;[] helpTransfer(Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt; f) {
    Node&amp;lt;K,V&amp;gt;[] nextTab; int sc;
    if (tab != null &amp;amp;&amp;amp; (f instanceof ForwardingNode) &amp;amp;&amp;amp;
        (nextTab = ((ForwardingNode&amp;lt;K,V&amp;gt;)f).nextTable) != null) {
        //计算操作栈校验码
        int rs = resizeStamp(tab.length);
        while (nextTab == nextTable &amp;amp;&amp;amp; table == tab &amp;amp;&amp;amp;
               (sc = sizeCtl) &amp;lt; 0) {
            if ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex &amp;lt;= 0)//不需要帮助转移，跳出
                break;
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {//每当一个线程来帮助扩容，SIZECTL就+1
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;transfernode-tab-node-nexttab&quot;&gt;transfer(Node[] tab, Node[] nextTab)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;private final void transfer(Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt;[] nextTab) {
    int n = tab.length, stride;
//转移幅度( tab.length/(NCPU*8) )，最小为16
    if ((stride = (NCPU &amp;gt; 1) ? (n &amp;gt;&amp;gt;&amp;gt; 3) / NCPU : n) &amp;lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    if (nextTab == null) {            // initiating
        try { 
          //根据当前数组长度,新建一个两倍长度的数组nextTab
            Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n &amp;lt;&amp;lt; 1];
            nextTab = nt;
        } catch (Throwable ex) {      // try to cope with OOME
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        nextTable = nextTab;
        transferIndex = n;//初始为table的最后一个索引
    }
    int nextn = nextTab.length;
//初始化ForwardingNode节点,持有nextTab的引用,在处理完每个节点之后当做占位节点，表示该槽位已经处理过了
    ForwardingNode&amp;lt;K,V&amp;gt; fwd = new ForwardingNode&amp;lt;K,V&amp;gt;(nextTab);
    boolean advance = true;//一个标志位，可以控制任务领取和任务完成
    boolean finishing = false;  //本线程的任务是否完成
    //自旋移动每个节点，从transferIndex开始移动stride个节点到新的table。
    //i：当前处理的Node索引；bound：需要处理节点的索引边界
    for (int i = 0, bound = 0;;) {
        Node&amp;lt;K,V&amp;gt; f; int fh;
        while (advance) {
          //nextIndex:下一个要处理的结点索引；nextBound:下一个要处理的结点索引边界
            int nextIndex, nextBound;
            //本地线程任务尚未达到边界，则继续执行，如果完成了任务，则进行其他if判断
            if (--i &amp;gt;= bound || finishing)
                advance = false;
           //查看是否还有扩容任务，如果没有就置i等于-1，break while(advance)循环
            else if ((nextIndex = transferIndex) &amp;lt;= 0) {
                i = -1;
                advance = false;
            }
          //控制任务领取：每次线程领取扩容任务后，需要更新transferIndex的值(transferIndex-stride)。
            //CAS修改transferIndex，并更新索引边界，防止领取重复的任务
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex &amp;gt; stride ?
                                   nextIndex - stride : 0))) {
                bound = nextBound;
                i = nextIndex - 1;
                advance = false;
            }
        }
        //本地线程已经完成任务
        if (i &amp;lt; 0 || i &amp;gt;= n || i + n &amp;gt;= nextn) {
            int sc;
            //最后只有一个线程完成收尾工作
            if (finishing) {
                nextTable = null;
                table = nextTab;
                sizeCtl = (n &amp;lt;&amp;lt; 1) - (n &amp;gt;&amp;gt;&amp;gt; 1);//1.5*n：扩容阈值设置为原来容量的1.5倍  依然相当于现在容量的0.75倍
                //终于return
                return;
            }
            //CAS进行将SIZECTL自减
            if (U.compareAndSapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                if ((sc - 2) != resizeStawmp(n) &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT)
                    return;
                //在前面helpTransfer中每来一个线程帮助扩容SIZECTL就+1，线程完毕就-1，所以当所有线程都执行完毕后，SIZRCTL就恢复了初始值resizeStawmp(n) &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT+2，也就宣布扩容完毕了，finishing=true
                finishing = advance = true;
                i = n; // recheck before commit
            }
        }
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);//i位置节点为空，替换为ForwardingNode节点，用于通知其他线程该位置已经处理
        else if ((fh = f.hash) == MOVED)//节点已经被其他线程处理过，继续处理下一个节点
            advance = true; // already processed
        else {
            synchronized (f) {
                //判断很重要，防止该结点已经remove
                if (tabAt(tab, i) == f) {
                //两个Node引用，分别用来指向tab[i],tab[i+n]
                    Node&amp;lt;K,V&amp;gt; ln, hn;
                    if (fh &amp;gt;= 0) {//当前结点为链表结点
                    //链表结构的扩容过程可以见代码后面的图示分析
                        int runBit = fh &amp;amp; n;  
                        Node&amp;lt;K,V&amp;gt; lastRun = f;
                        for (Node&amp;lt;K,V&amp;gt; p = f.next; p != null; p = p.next) {//*********1
                            int b = p.hash &amp;amp; n;
                            if (b != runBit) {
                                runBit = b;
                                lastRun = p;
                            }
                        }
                        if (runBit == 0) {
                            ln = lastRun;
                            hn = null;
                        }
                        else {
                            hn = lastRun;
                            ln = null;
                        }
                        for (Node&amp;lt;K,V&amp;gt; p = f; p != lastRun; p =

 p.next) {// ********2
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph &amp;amp; n) == 0)
                                ln = new Node&amp;lt;K,V&amp;gt;(ph, pk, pv, ln);
                            else
                                hn = new Node&amp;lt;K,V&amp;gt;(ph, pk, pv, hn);
                        }
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                    else if (f instanceof TreeBin) {
                        TreeBin&amp;lt;K,V&amp;gt; t = (TreeBin&amp;lt;K,V&amp;gt;)f;
                        TreeNode&amp;lt;K,V&amp;gt; lo = null, loTail = null;
                        TreeNode&amp;lt;K,V&amp;gt; hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                    //TreeNode不仅有红黑树结构，其继承自Node，在初始化的时候也指定了next域，也是一个链表结构
                        for (Node&amp;lt;K,V&amp;gt; e = t.first; e != null; e = e.next) {
                       //下述过程与hashmap中链表扩容相同，不再累述
                            int h = e.hash;
                            TreeNode&amp;lt;K,V&amp;gt; p = new TreeNode&amp;lt;K,V&amp;gt;
                                (h, e.key, e.val, null, null);
                            if ((h &amp;amp; n) == 0) {
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            }
                            else {
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            }
                        }
                    //ln结点的生成逻辑如下：
                    //(1)如果lo链表的元素个数小于等于UNTREEIFY_THRESHOLD，默认为6，则通过untreeify方法把树节点链表转化成普通节点链表；
                    //(2)否则判断hi链表中的元素个数是否等于0：如果等于0，表示lo链表中包含了所有原始节点，则设置原始红黑树给ln，否则根据lo链表重新构造红黑树。
                        ln = (lc &amp;lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                            (hc != 0) ? new TreeBin&amp;lt;K,V&amp;gt;(lo) : t;
                       //原理与上述相同
                        hn = (hc &amp;lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                            (lc != 0) ? new TreeBin&amp;lt;K,V&amp;gt;(hi) : t;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;链表的扩容过程如下：&lt;br/&gt;使用fn&amp;amp;n可以快速把链表中的元素区分成两类，A类是hash值的第X位(X为n的最高位)为0，B类是hash值的第X位为1，并通过lastRun记录最后需要处理的节点，A类和B类节点可以分散到新数组的槽位i和i+n中，假设链表拉平显示如下：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1053518/201802/1053518-20180201151353093-1777805125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.通过代码标记1处的遍历，记录runBit和lastRun，分别为1和节点6，所以设置hn为节点6，ln为null；&lt;br/&gt;2.通过代码标记2处的遍历，以lastRun节点为终止条件，根据第X位的值分别构造ln链表和hn链表&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1053518/201802/1053518-20180201151420812-5887036.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1053518/201802/1053518-20180201151427500-1789297339.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Transfer过程总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个执行的线程会首先设置sizeCtl属性为一个负值，然后执行transfer(tab, null)，其他晚进来的线程会检查当前扩容是否已经完成(if(nextIndex = transferIndex) &amp;lt;= 0))，没完成则帮助进行扩容(U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex,nextBound = (nextIndex &amp;gt; stride ? nextIndex - stride : 0)))，完成了则直接退出。&lt;/li&gt;
&lt;li&gt;该ConcurrentHashMap的扩容操作可以允许多个线程并发执行，那么就要处理好任务的分配工作。每个线程获取一部分桶的迁移任务(nextIndex - stride)，如果当前线程的任务完成，查看是否还有未迁移的桶(if(nextIndex = transferIndex) &amp;lt;= 0))，若有则继续领取任务执行，若没有则退出(i=-1,advance=false)。在退出时需要检查是否还有其他线程在参与迁移工作(if sc == resizeStawmp(n) &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT+2)，如果有(即前面等式不成立)则自己什么也不做直接退出，如果没有了(advance = finishing = true,i=n)则执行最终的收尾工作(nextTable = null; table = nextTab;sizeCtl = (n &amp;lt;&amp;lt; 1) - (n &amp;gt;&amp;gt;&amp;gt; 1);)。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;treeifybinnode-tab-int-index&quot;&gt;treeifyBin(Node[] tab, int index)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    private final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int index) {
        Node&amp;lt;K,V&amp;gt; b; int n, sc;
        if (tab != null) { // 表不为空
            if ((n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY) // table表的长度小于转换为红黑树的阈值
                // 即使这个时候map中的结点个数还没达到扩容阈值，但是已经有某个桶中结点个数达到转换为红黑树的阈值了了，还是要进行扩容
                tryPresize(n &amp;lt;&amp;lt; 1);
            else if ((b = tabAt(tab, index)) != null &amp;amp;&amp;amp; b.hash &amp;gt;= 0) { // 桶中存在结点并且结点的hash值大于等于0
                synchronized (b) { // 对桶中第一个结点进行加锁
                    if (tabAt(tab, index) == b) { // 第一个结点没有变化
                        TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
                        for (Node&amp;lt;K,V&amp;gt; e = b; e != null; e = e.next) { // 遍历桶中所有结点，将结点转换为treeNode,为了最后的TreeBin调用
                            // 新生一个TreeNode结点
                            TreeNode&amp;lt;K,V&amp;gt; p =
                                new TreeNode&amp;lt;K,V&amp;gt;(e.hash, e.key, e.val,
                                                  null, null);
                            if ((p.prev = tl) == null) // 该结点前驱为空
                                // 设置p为头结点
                                hd = p;
                            else
                                // 尾节点的next域赋值为p
                                tl.next = p;
                            // 尾节点赋值为p
                            tl = p;
                        }
                        // TreeBin转换为红黑树，将第一个结点放在数组中
                        setTabAt(tab, index, new TreeBin&amp;lt;K,V&amp;gt;(hd));
                    }
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;treeifyBin流程:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在进行链表-&amp;gt;红黑树转换之前，会判断map中的结点个数是否达到了MIN_TREEIFY_CAPACITY，如果没有就对进行扩容，结束，如果达到了，就执行2&lt;/li&gt;
&lt;li&gt;如果桶中有结点，遍历桶中的结点，将每个Node封装了TreeNode&lt;/li&gt;
&lt;li&gt;将第一个TreeNode作为参数实例化TreeBin，目的是将TreeNode组织成红黑树结构&lt;/li&gt;
&lt;li&gt;将TreeBin放入数组中，这也就解释了如果桶中是红黑树结构，那么数组中存放的是TreeBin&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;getobject-key&quot;&gt;get(Object key)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; int n, eh; K ek;
        // 计算key的hash值
        int h = spread(key.hashCode()); 
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (e = tabAt(tab, (n - 1) &amp;amp; h)) != null) { // 表不为空并且表的长度大于0并且key所在的桶不为空
            if ((eh = e.hash) == h) { // 表中的元素的hash值与key的hash值相等
                if ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek))) // 键相等
                    // 返回值
                    return e.val;
            }
            else if (eh &amp;lt; 0) // 结点hash值小于0,那么该结点有可能是ForwardingNode或者是TreeNode
                //由于ForwardingNode或者是TreeNode都继承了Node，并且对find方法重写了，分别在扩容的结点或者是在红黑树中查找
                return (p = e.find(h, key)) != null ? p.val : null;
            while ((e = e.next) != null) { //hash&amp;gt;0说明是链表中的结点，遍历查询
                if (e.hash == h &amp;amp;&amp;amp;
                    ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;get流程:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据key计算出hash值&lt;/li&gt;
&lt;li&gt;hash值&amp;amp;（数组长度-1）得到所在数组的index&lt;/li&gt;
&lt;li&gt;如果要找的key就是上述数组index位置的元素，直接返回该元素的值&lt;/li&gt;
&lt;li&gt;如果该数组index位置元素是TreeNode类型，则按照红黑树的查询方式来进行查找&lt;/li&gt;
&lt;li&gt;如果该数组index位置元素非TreeNode类型，则按照链表的方式来进行遍历查询&lt;br/&gt;get线程安全保证：get读取值，第一步：定位到桶tabAt(table,index),该操作是直接从内存中获取值，保证数组中的结点是最新的，第二步:要依赖node的next进行遍历，返回node的val，由于next和val都是volatile修饰，保证了next和val在更新后是线程可见的，即next和val是最新的，因此get是线程安全的&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;replacenodeobject-keyv-valueobject-cv&quot;&gt;replaceNode(Object key,V value,Object cv)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //remove和replace方法的实际调用，value为要设置的新值，如果value为null，就删除结点，cv为key对应的旧值
    final V replaceNode(Object key, V value, Object cv) {
        // 计算key的hash值
        int hash = spread(key.hashCode());
        for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) { // 无限循环
            Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0 ||
                (f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) // table表为空或者表长度为0或者key所对应的桶为空
                // 跳出循环
                break;
            else if ((fh = f.hash) == MOVED) // hash=MOVED说明正在扩容，去帮助扩容
                // 转移
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                boolean validated = false;
                synchronized (f) { // 加锁同步
                    if (tabAt(tab, i) == f) { // 桶中的第一个结点没有发生变化
                        if (fh &amp;gt;= 0) {222 // 结点hash值大于0
                            validated = true;
                            for (Node&amp;lt;K,V&amp;gt; e = f, pred = null;;) { // 无限循环
                                K ek;
                                if (e.hash == hash &amp;amp;&amp;amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;amp;&amp;amp; key.equals(ek)))) { // 找到了key对应的结点
                                    V ev = e.val;
                                    if (cv == null || cv == ev ||
                                        (ev != null &amp;amp;&amp;amp; cv.equals(ev))) { // cv为空或者cv与旧值相等
                                        oldVal = ev;// 保存该结点的val值
                                        if (value != null) // value不为空，更新值 
                                            e.val = value;
                                        else if (pred != null) // 如果e不是头结点
                                            // 直接删除
                                            pred.next = e.next;
                                        else
                                            // 如果e是头结点，将e.next设置为头结点
                                            setTabAt(tab, i, e.next);
                                    }
                                    break;
                                }
                                //向下遍历链表的其他结点
                                pred = e;
                                if ((e = e.next) == null)
                                    break;
                            }
                        }
                        else if (f instanceof TreeBin) { // 为红黑树结点
                            validated = true;
                            // 类型转化
                            TreeBin&amp;lt;K,V&amp;gt; t = (TreeBin&amp;lt;K,V&amp;gt;)f;
                            TreeNode&amp;lt;K,V&amp;gt; r, p;
                            if ((r = t.root) != null &amp;amp;&amp;amp;
                                (p = r.findTreeNode(hash, key, null)) != null) { // 根节点不为空并且存在与指定hash和key相等的结点
                                // 保存p结点的value
                                //下面代码和链表中的做法相似，不再累述
                                V pv = p.val;
                                if (cv == null || cv == pv ||
                                    (pv != null &amp;amp;&amp;amp; cv.equals(pv))) { 
                                    oldVal = pv;
                                    if (value != null) 
                                        p.val = value;
                                    else if (t.removeTreeNode(p)) 
                                        setTabAt(tab, i, untreeify(t.first));
                                }
                            }
                        }
                    }
                }
                if (validated) {
                    if (oldVal != null) {
                        if (value == null)
                            // baseCount值减一
                            addCount(-1L, -1);
                        return oldVal;
                    }
                    break;
                }
            }
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;replaceNode流程:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算出结点所在桶的位置&lt;/li&gt;
&lt;li&gt;如果桶中没有结点，直接break&lt;/li&gt;
&lt;li&gt;如果桶中是ForwardingNode,该线程去帮忙扩容&lt;/li&gt;
&lt;li&gt;如果不是上述两种情况，就需要遍历桶中的结点，进行删除或者更新&lt;br/&gt;--链表：遍历每个结点，查看key是否相等，如果key相等并且value不为null的话，就进行更新，如果key相等value为null的话就进行删除&lt;br/&gt;--红黑树：做法与链表相似，就是查找的时候是红黑树查找&lt;/li&gt;
&lt;li&gt;最后，判断validated变量为true，oldval不为空， 说明有结点删除了，addCount(-1L,-1),返回删除的结点值，否者return null。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;ConcurrentHashMap源码读起来真的脑阔疼，把每个方法，每个变量，每个条件判断弄清楚确实要花很多时间，每每读懂，无不感概设计之精妙，网上的资源也确实有限，本篇博客仅仅是把核心方法分析了一下，而其并发的精髓，还没有涉及，有时间再补漏，希望有兴趣的小伙伴能够交流交流～&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/0fb89aefac66&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/0fb89aefac66&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/u010723709/article/details/48007881&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/u010723709/article/details/48007881&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/leesf456/p/5453341.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/leesf456/p/5453341.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/elricboa/article/details/70199409&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/elricboa/article/details/70199409&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/lovesomnus/article/details/70160018&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/lovesomnus/article/details/70160018&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Feb 2018 06:36:00 +0000</pubDate>
<dc:creator>unbelievableme</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kundeg/p/8399144.html</dc:identifier>
</item>
<item>
<title>企业级分布式存储应用与实战FastDFS实现 - 大天使彦</title>
<link>http://www.cnblogs.com/1477717815fuming/p/8404882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1477717815fuming/p/8404882.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;span&gt;FASTDFS是什么&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;FastDFS是由国人余庆所开发，其项目地址：&lt;a href=&quot;https://github.com/happyfish100&quot;&gt;&lt;span&gt;https://github.com/happyfish100&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FastDFS是一个轻量级的开源分布式文件系统，主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡。&lt;/p&gt;
&lt;p&gt;FastDFS是一款类Google FS的开源分布式文件系统，它用&lt;span&gt;&lt;strong&gt;纯C语言实现&lt;/strong&gt;&lt;/span&gt;，支持Linux、FreeBSD、AIX等UNIX系统。它只能通过 专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、分组存储，灵活简洁、对等结构，不存在单点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、 文件ID由FastDFS生成，作为文件访问凭证。FastDFS不需要传统的name server&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、和流行的web server无缝衔接，FastDFS已提供apache和nginx扩展模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、大、中、小文件均可以很好支持，支持海量小文件存储&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、 支持多块磁盘，支持单盘数据恢复&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、 支持相同文件内容只保存一份，节省存储空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、 存储服务器上可以保存文件附加属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、 下载文件支持多线程方式，支持断点续传&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;指标&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;FastDFS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;mogileFS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;系统简洁性&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;简洁，只有两个角色：tracker和storage&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;一般，有三个角色：tracker，storage和存储文件信息的mysql db&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;系统性能&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;很高（没有数据库，文件同步直接点对点，不经过tracker中转）&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;高（使用mysql来存储文件索引等信息文件同步通过tracker调度和中转）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;系统稳定性&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;高（c语言开发，可以支持高并发和高负载）&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;一般（Perl语言开发，高并发和高负载支持一般）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;RAID方式&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;分组（组内冗余），灵活性大&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;动态冗余，灵活性一般&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;通信协议&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;专有协议&lt;/p&gt;
&lt;p&gt;下载文件支持http&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;技术文档&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;较详细&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;较少&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;文件附加属性（meta data）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;支持&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;不支持&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;相同内容文件只保存一分&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;支持&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;不支持&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;下载文件时支持文件偏移量&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;支持&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;不支持&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;FastDFS和集中存储方式对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;指标&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;FastDFS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;NFS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;集中存储设备如：NetApp,NAS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;线性扩容性&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;差&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;差&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;文件高并发访问性能&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;差&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;一般&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;文件访问方式&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;专有API&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;POSIX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;支持POSIX&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;硬件成本&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;较低&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;相同文件内容只保存一份&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;支持&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;不支持&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;不支持&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140101703-1173353460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作方式：&lt;/strong&gt;客户端向tracker发出请求，然后tracker从storage节点拿到源数据，返还给客户端，然后客户端根据源数据再去请求storage节点。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1.只有两个角色，tracker server和storage server，不需要存储文件索引信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.所有服务器都是对等的，不存在Master-Slave关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.存储服务器采用分组方式，同组内存储服务器上的文件完全相同（RAID 1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.不同组的storage server之间不会相互通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.由storage server主动向tracker server报告状态信息，tracker server之间通常不会相互通信&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140102140-1597023355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. tracker返回一台可用的storage；&lt;/p&gt;
&lt;p&gt;3. client直接和storage通信完成文件上传，storage返回文件ID。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140102500-65715329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. tracker返回一台可用的storage；&lt;/p&gt;
&lt;p&gt;3. client直接和storage通信完成文件下载。&lt;/p&gt;


&lt;p&gt;1.采用binlog文件记录更新操作，根据binlog进行文件同步同一组内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.文件同步只在同组内的storage server之间进行，&lt;/strong&gt;&lt;/span&gt;采用push方式，即源服务器同步给目标服务器；&lt;/p&gt;
&lt;p&gt;源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；&lt;/p&gt;
&lt;p&gt;3.上述第二条规则有个例外，就是&lt;span&gt;&lt;strong&gt;新增加一台storage server时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增服务器。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140102937-1182423503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;Tracker：&lt;/strong&gt;&lt;/span&gt;调度器，负责维持集群的信息，例如各group及其内部的storage node，这些信息也是storage node报告所生成；每个storage node会周期性向tracker发心跳信息；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;storage server：&lt;/strong&gt;&lt;/span&gt;以group为单位进行组织，任何一个storage server都应该属于某个group，一个group应该包含多个storage server；在同一个group内部，各storage server的数据互相冗余；&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;如何在组中挑选storage server：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、rr；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、以ip为次序，找第一个，即IP地址较小者；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、以优先级为序，找第一个；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;如何选择磁盘（存储路径）：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、rr；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、剩余可用空间大者优先；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;生成FID：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;由源头storage server ip、创建时的时间戳、大小、文件的校验码和一个随机数进行hash计算后生成；最后基于base64&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;进行文本编码，转换为可打印字符；&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;groupID/MID/H1ID/H2ID/file_name&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;groupID：&lt;/strong&gt;&lt;/span&gt;组编号&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MID：&lt;/strong&gt;&lt;/span&gt;存储路径（存储设备）编号&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;H1ID/H2ID：&lt;/strong&gt;&lt;/span&gt;目录分层&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;file_name：&lt;/strong&gt;&lt;/span&gt;文件名，不同于用户上传时使用文件名，而是由服务器生成hash文件名；&lt;/p&gt;
&lt;p&gt;服务器IP、文件创建时的时间戳、文件大小、文件名和扩展名；&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;文件同步：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;每个storage server在文件存储完成后，会将其信息存于binlog， binlog不包含数据，仅包含文件名等元数据信息；&lt;/p&gt;
&lt;p&gt;binlog可用于同步；&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;tracker：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;编辑tracker server配置文件tracker.conf，需要修改内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;disabled=false（默认为false，表示是否无效）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;port=22122（默认为22122）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;base_path=/data/fastdfs/tracker&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;storage server：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;disabled=false（默认为false，表示是否无效）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;port=23000（默认为23000）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;base_path=/data/fastdfs/storage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tracker_server=172.18.10.232:22122&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;store_path0=/data/fastdfs/storage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;http.server_port=8888（默认为8888，nginx中配置的监听端口那之一致）&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;实验环境：3台机器，一台tracker调度器，两台storage节点服务器&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;（1）安装fastdfs&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;1.创建一个安装fastdfs所需软件包的目录&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;cd /app&lt;/p&gt;
&lt;p&gt;mkdir fastdfs&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.用lftp将安装fastdfs所需软件包下载到该目录里&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;lftp 172.17.0.1&lt;/p&gt;
&lt;p&gt;lftp 172.17.0.1:/pub/Sources/7.x86_64/fastdfs&amp;gt; mget *&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140103406-569246962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.安装fastdfs&lt;/p&gt;
&lt;p&gt;yum localinstall fastdfs* lib* -y 因为有依赖关系，所以和依赖的库文件包一起安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140104000-1218948326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4.另外两台机器也是如此&lt;/span&gt;&lt;/h4&gt;
&lt;h2&gt;&lt;span&gt;（2）配置tracker调度器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cd /etc/fdfs&lt;/p&gt;
&lt;p&gt;cp tracker.conf.sample tracker.conf 在/etc/fdfs目录下有一个tracker配置文件模板，将其复制并改名为tracker.conf作为tarcker的配置文件&lt;/p&gt;
&lt;p&gt;vim tracker.conf&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;disabled=false（默认为false，表示是否无效）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;port=22122（默认为22122）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;base_path=/data/fastdfs/tracker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;mdkir /data/fastdfs/tracker -p&lt;/p&gt;

&lt;p&gt;/etc/init.d/fdfs_trackerd start 启动tracker服务&lt;/p&gt;
&lt;p&gt;注意：路径和创建的目录要一致，不要写错，否则tracker服务就会起不来&lt;/p&gt;
&lt;p&gt;ss -ntl 查看是否有22122端口&lt;/p&gt;
&lt;p&gt;ps -ef|grep fdfs 查看tracker进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140104437-911570351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;（3）配置storage节点服务器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cd /etc/fdfs&lt;/p&gt;
&lt;p&gt;cp storage.conf.sample storage.conf 在/etc/fdfs目录下有一个storage配置文件模板，将其复制并改名为storage.conf作为storage的配置文件&lt;/p&gt;

&lt;p&gt;vim storage.conf&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;disabled=false（默认为false，表示是否无效）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;port=23000（默认为23000）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;base_path=/data/fastdfs/storage&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;tracker_server=172.18.10.232:22122&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;store_path0=/data/fastdfs/storage&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;http.server_port=8888（默认为8888，nginx中配置的监听端口那之一致）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;mkdir /data/fastdfs/storage -p&lt;/p&gt;
&lt;p&gt;/etc/init.d/fdfs_storaged start 启动storage服务&lt;/p&gt;
&lt;p&gt;注意：路径和创建的目录要一致，不要写错，否则storage服务就会起不来&lt;/p&gt;
&lt;p&gt;ss -ntl 查看是否有23000端口&lt;/p&gt;
&lt;p&gt;ps -ef|grep fdfs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140104734-2059090290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;（4）查看存储节点状态，需要配置客户端配置文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cd /etc/fdfs&lt;/p&gt;
&lt;p&gt;cp client.conf.sample client.conf&lt;/p&gt;
&lt;p&gt;vim client.conf&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;base_path=/data/fastdfs/tracker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;tracker_server=192.168.10.190:22122&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;fdfs_monitor /etc/fdfs/client.conf 查看存储节点状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140105125-491004817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;（5）文件上传&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;fdfs_upload_file /etc/fdfs/client.conf /root/solo-2.2.0.war&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140105359-1816287548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在storage节点服务器上查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140105640-1401434146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在tracker调度器上做md5校验&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;6.上传文件查看（在调度器上查看）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;fdfs_file_info /etc/fdfs/client.conf group1/M00/00/00/wKgKu1ocsWGADh40AABakQQUHpk839.log&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140105921-1441854210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.文件下载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKgKu1ocsWGADh40AABakQQUHpk839.log&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140106265-367246902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;8.FastDFS实现nginx代理（在storage节点）&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;1、安装nginx以及对应模块&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;cd /app/fastdfs&lt;/p&gt;
&lt;p&gt;yum localinstall nginx* -y&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、修改nginx的location配置，映射路径和启动模块&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;location /group1/M00 {&lt;/p&gt;
&lt;p&gt;root /data/fastdfs/storage/data;&lt;/p&gt;
&lt;p&gt;ngx_fastdfs_module;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、修改对应fastdfs模块&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;vim /etc/fdfs/mod_fastdfs.conf&lt;/p&gt;
&lt;p&gt;url_have_group_name = true&lt;/p&gt;
&lt;p&gt;tracker_server=192.168.10.190:22122&lt;/p&gt;
&lt;p&gt;store_path0=/data/fastdfs/storage&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4.启动nginx服务&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;5.然后我上传一个图片文件&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140106562-608475211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;6.在浏览器上去访问，访问成功&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1235933/201802/1235933-20180202140107000-1113989970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Feb 2018 06:01:00 +0000</pubDate>
<dc:creator>大天使彦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1477717815fuming/p/8404882.html</dc:identifier>
</item>
<item>
<title>如何用docker部署redis cluster - 小新是也</title>
<link>http://www.cnblogs.com/chenchuxin/p/8404699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenchuxin/p/8404699.html</guid>
<description>&lt;p&gt;由于本人是个docker控，不喜欢安装各种环境，而且安装redis-trib也有点繁琐，索性用docker来做redis cluster。&lt;br/&gt;本文用的是伪集群，真正的集群放到不同的机器即可。端口是7001-7006。&lt;br/&gt;工作目录：&lt;code&gt;/data/redis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先创建一堆对应端口的文件夹，下面是脚本&lt;br/&gt;&lt;strong&gt;create.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for i in `seq 7001 7006`
do
 mkdir -p ${i}/data
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加执行权限并执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chmod 777 create.sh
./create.sh&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本人不喜欢docker run，所以用了&lt;code&gt;docker-compose&lt;/code&gt;。官方文档 &lt;a href=&quot;https://docs.docker.com/compose/overview/&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/compose/overview/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建docker-compose.yml&quot;&gt;创建docker-compose.yml&lt;/h3&gt;
&lt;p&gt;用&lt;code&gt;publicisworldwide/redis-cluster&lt;/code&gt;镜像的原因是人家已经把配置文件写好了，配置文件没有挂载是懒，别学我&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker-compose.yml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '3.4'

x-image:
 &amp;amp;default-image
 publicisworldwide/redis-cluster
x-restart:
 &amp;amp;default-restart
 always
x-netmode:
 &amp;amp;default-netmode
 host

services:
 redis1:
  image: *default-image
  network_mode: *default-netmode
  restart: *default-restart
  volumes:
  - /data/redis/7001/data:/data
  environment:
  - REDIS_PORT=7001

 redis2:
  image: *default-image
  network_mode: *default-netmode
  restart: *default-restart
  volumes:
  - /data/redis/7002/data:/data
  environment:
  - REDIS_PORT=7002

 redis3:
  image: *default-image
  network_mode: *default-netmode
  restart: *default-restart
  volumes:
  - /data/redis/7003/data:/data
  environment:
  - REDIS_PORT=7003

 redis4:
  image: *default-image
  network_mode: *default-netmode
  restart: *default-restart
  volumes:
  - /data/redis/7004/data:/data
  environment:
  - REDIS_PORT=7004

 redis5:
  image: *default-image
  network_mode: *default-netmode
  restart: *default-restart
  volumes:
  - /data/redis/7005/data:/data
  environment:
  - REDIS_PORT=7005

 redis6:
  image: *default-image
  network_mode: *default-netmode
  restart: *default-restart
  volumes:
  - /data/redis/7006/data:/data
  environment:
  - REDIS_PORT=7006&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动所有redis&quot;&gt;启动所有redis&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose up -d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果报错，那就是版本问题。&lt;br/&gt;查看docker版本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker -v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;a href=&quot;https://docs.docker.com/compose/compose-file/&quot;&gt;文档&lt;/a&gt;中可查看docker版本支持的docker-compose.yml版本，为了方便大家查看，我复制出来了。不过一般来说，docker升级比较快，功能迭代也很快，最好还是用最新版本。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;17.09.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;17.06.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3.2&lt;/td&gt;
&lt;td&gt;17.04.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;1.13.1+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;1.13.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.3&lt;/td&gt;
&lt;td&gt;17.06.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.2&lt;/td&gt;
&lt;td&gt;1.13.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2.1&lt;/td&gt;
&lt;td&gt;1.12.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;1.10.0+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;1.9.1.+&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;运行以下命令(&lt;code&gt;inem0o/redis-trib&lt;/code&gt;没有pull会自动pull)&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;：加上&lt;strong&gt;-it&lt;/strong&gt;，不然后续的确认没法继续&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run --rm -it inem0o/redis-trib create --replicas 1 192.168.30.70:7001 192.168.30.70:7002 192.168.30.70:7003 192.168.30.70:7004 192.168.30.70:7005 192.168.30.70:7006&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会出现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Creating cluster
&amp;gt;&amp;gt;&amp;gt; Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.30.70:7001
192.168.30.70:7002
192.168.30.70:7003
Adding replica 192.168.30.70:7004 to 192.168.30.70:7001
Adding replica 192.168.30.70:7005 to 192.168.30.70:7002
Adding replica 192.168.30.70:7006 to 192.168.30.70:7003
M: 5a7bd7698b1fe55beb44faac051d66c8a03fd1b1 192.168.30.70:7001
   slots:0-5460 (5461 slots) master
M: bb8fda08e1dcd39e937443f81b5458e80f52d804 192.168.30.70:7002
   slots:5461-10922 (5462 slots) master
M: d907530ee9f6356e0e61a6c7f4d0cc1b22da1189 192.168.30.70:7003
   slots:10923-16383 (5461 slots) master
S: 52eee69afa751d71c84d5436d14b0e16a37536fa 192.168.30.70:7004
   replicates 5a7bd7698b1fe55beb44faac051d66c8a03fd1b1
S: 701ed2fbb3df9fc63b083818620f5c020d05e323 192.168.30.70:7005
   replicates bb8fda08e1dcd39e937443f81b5458e80f52d804
S: a3548a9dffa225f05786ea2289db65f5f1c623be 192.168.30.70:7006
   replicates d907530ee9f6356e0e61a6c7f4d0cc1b22da1189
Can I set the above configuration? (type 'yes' to accept):&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入&lt;code&gt;yes&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Waiting for the cluster to join.....
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.30.70:7001)
M: 5a7bd7698b1fe55beb44faac051d66c8a03fd1b1 192.168.30.70:7001
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
M: d907530ee9f6356e0e61a6c7f4d0cc1b22da1189 192.168.30.70:7003@17003
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: a3548a9dffa225f05786ea2289db65f5f1c623be 192.168.30.70:7006@17006
   slots: (0 slots) slave
   replicates d907530ee9f6356e0e61a6c7f4d0cc1b22da1189
S: 701ed2fbb3df9fc63b083818620f5c020d05e323 192.168.30.70:7005@17005
   slots: (0 slots) slave
   replicates bb8fda08e1dcd39e937443f81b5458e80f52d804
S: 52eee69afa751d71c84d5436d14b0e16a37536fa 192.168.30.70:7004@17004
   slots: (0 slots) slave
   replicates 5a7bd7698b1fe55beb44faac051d66c8a03fd1b1
M: bb8fda08e1dcd39e937443f81b5458e80f52d804 192.168.30.70:7002@17002
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;创建集群的时候会遇到&lt;code&gt;Waiting for the cluster to join....................&lt;/code&gt;一直没有成功&lt;br/&gt;&lt;strong&gt;答&lt;/strong&gt;：网络模式改成&lt;code&gt;host&lt;/code&gt;，docker run 的方式加上&lt;code&gt;-net host&lt;/code&gt;，docker-compose方式加上&lt;code&gt;network_mode: host&lt;/code&gt;。&lt;br/&gt;我原本是端口映射 &lt;code&gt;7001:7000&lt;/code&gt;+&lt;code&gt;17001:17000&lt;/code&gt;，但是不行，不知道什么原因。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 02 Feb 2018 05:21:00 +0000</pubDate>
<dc:creator>小新是也</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenchuxin/p/8404699.html</dc:identifier>
</item>
<item>
<title>读书笔记一 - 小兵千睿</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/8404255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/8404255.html</guid>
<description>&lt;p&gt;   &lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiaobingqianrui/1158428/o_Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98.jpg&quot; alt=&quot;&quot; width=&quot;131&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　为进一步加强Python知识扩展和学习，在朋友的推荐下选择了&amp;lt;&amp;lt;Selenium2自动化测试实战&amp;gt;&amp;gt;，作者胡志恒，基于Python语言实现，以实例的方式详细讲解WebDriver的类库体系，对于目前阶段的我来说很适合，本着&quot;把书读厚再把书读薄&quot;的思想开始学习！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div id=&quot;divimg&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1117865/201802/1117865-20180202114614765-313471452.png&quot; alt=&quot;&quot; width=&quot;100%&quot;/&gt;&lt;/div&gt;

&lt;h2&gt;　　1） 根据项目流程阶段划分软件测试　&lt;/h2&gt;
&lt;p&gt;　　　　 &lt;img src=&quot;https://images2017.cnblogs.com/blog/1117865/201802/1117865-20180202122416156-807647166.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　单元测试：模块接口、局部数据格式、路径、错误处理、边界条件测&lt;/p&gt;
&lt;p&gt;　　　　集成测试：将各个模块进行整合，判断整体功能是否达到预期要求，全局数据结构是否有问题，单个模块的误差积累是否会被放大&lt;/p&gt;
&lt;p&gt;　　　　系统测试：功能测试、性能测试、稳定性测试、安全测试、兼容测试&lt;/p&gt;
&lt;p&gt;　　　　验收性测试：根据项目合同进行各种确认测试&lt;/p&gt;
&lt;h2&gt;　　2） 白盒测试、黑盒测试、灰盒测试　　&lt;/h2&gt;
&lt;p&gt;　　　          &lt;img src=&quot;https://images2017.cnblogs.com/blog/1117865/201802/1117865-20180202123141734-645929824.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　黑盒测试：着眼余程序的外部结构，不考虑内部逻辑，主要对软件功能和软件UI进行测试，只关心软件的输入和输出&lt;/p&gt;
&lt;p&gt;　　　　白盒测试：按照规格说明书对程序的内部结构进行测试&lt;/p&gt;
&lt;p&gt;　　　　灰盒测试：介于黑盒和白盒之间，既关注内部表现也关注输入输出&lt;/p&gt;
&lt;h2&gt;　　3） 功能测试与性能测试&lt;/h2&gt;
&lt;p&gt;　　　　功能测试：检查实际的功能是否符合用户的需求。&lt;span&gt;功能测试又可可以细分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　性能测试：通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试&lt;span&gt;软件的性能主要有时间性能和控件性能两种，时间性能指指令的响应时间，空间性能反映在硬件资源、cpu、内存、带宽消耗等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　4） 手工测试与自动化测试&lt;/h2&gt;
&lt;p&gt;　　　　手工测试：需要拥有一定的业务知识和基本测试方法的专业的测试人员通过键盘鼠标等输入一些参数查看返回的结构是否符合预期结果，在目前的测试领域，手工测试仍然是无法代替的一种测试方法&lt;/p&gt;
&lt;p&gt;　　　　自动化测试：功能自动化测试和性能自动化测试，通过测试工具（或框架）录制/编写测试脚本，对软件进行测试&lt;/p&gt;
&lt;h2&gt;　　5） 冒烟测试、回归测试、随机测试、探索性测试和安全测试　　　&lt;/h2&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1117865/201802/1117865-20180202130320578-520445761.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　自动化测试的重要性不断提升随着敏捷的热度不断提升，持续集成、持续交付作为敏捷的核心实践之一，越来越受到重视。然而大家很快发现，自动化测试是持续集成、持续交付的灵魂，没有有效的自动化测试保证，持续集成和持续交付就仅仅是一个无用的躯壳了。&lt;/p&gt;
&lt;p&gt;　　分层自动化测试倡导的是从黑盒(UI)单层到黑白盒多层的自动化测试体系，从全面黑盒自动化测试到对系统的不同层次进行自动化测试&lt;/p&gt;
&lt;p&gt;　　UI（UI界面层）：UI自动化测试、JS自动化测试&lt;/p&gt;
&lt;p&gt;　　Service（业务逻辑层）：模块接口测试、web接口测试&lt;/p&gt;
&lt;p&gt;　　Unit（数据处理层）：单元测试、Code Review&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;什么样的项目适合自动化测试？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　a. 任务测试明确，不会频繁变动&lt;/p&gt;
&lt;p&gt;　　b. 比较频繁的回归测试&lt;/p&gt;
&lt;p&gt;　　c. 软件界面稳定，变动少&lt;/p&gt;
&lt;p&gt;　　d. 需要在多平台上运行的相同的测试案例、组合遍历性的测试，大量的重复任务&lt;/p&gt;
&lt;p&gt;　　e. 软件维护周期长&lt;/p&gt;
&lt;p&gt;　　f. 具备大量的自动化测试平台&lt;/p&gt;
&lt;p&gt;　　g. 测试人员具备较强测编程能力&lt;/p&gt;

</description>
<pubDate>Fri, 02 Feb 2018 05:18:00 +0000</pubDate>
<dc:creator>小兵千睿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobingqianrui/p/8404255.html</dc:identifier>
</item>
<item>
<title>Intel DPDK 全面解读 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8404650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8404650.html</guid>
<description>&lt;h2 id=&quot;高性能网络技术&quot;&gt;高性能网络技术&lt;/h2&gt;
&lt;p&gt;随着云计算产业的异军突起，网络技术的不断创新，越来越多的网络设备基础架构逐步向基于通用处理器平台的架构方向融合，从传统的物理网络到虚拟网络，从扁平化的网络结构到基于 SDN 分层的网络结构，无不体现出这种创新与融合。&lt;/p&gt;
&lt;p&gt;这在使得网络变得更加可控制和成本更低的同时，也能够支持大规模用户或应用程序的性能需求，以及海量数据的处理。究其原因，其实是高性能网络编程技术随着网络架构的演进不断突破的一种必然结果。&lt;/p&gt;
&lt;h2 id=&quot;c10k-到-c10m-问题的演进&quot;&gt;C10K 到 C10M 问题的演进&lt;/h2&gt;
&lt;p&gt;如今，关注的更多是 C10M 问题（即单机 1 千万个并发连接问题）。很多计算机领域的大佬们从硬件上和软件上都提出了多种解决方案。从硬件上，比如说，现在的类似很多 40Gpbs、32-cores、256G RAM 这样配置的 X86 服务器完全可以处理 1 千万个以上的并发连接。&lt;/p&gt;
&lt;p&gt;但是从硬件上解决问题就没多大意思了，首先它成本高，其次不通用，最后也没什么挑战，无非就是堆砌硬件而已。所以，抛开硬件不谈，我们看看从软件上该如何解决这个世界难题呢？&lt;/p&gt;
&lt;p&gt;这里不得不提一个人，就是 Errata Security 公司的 CEO Robert Graham，他在 Shmoocon 2013 大会上很巧妙地解释了这个问题。有兴趣可以查看其 YouTube 的演进视频： &lt;a href=&quot;http://www.youtube.com/watch?v=73XNtI0w7jA#!&quot;&gt;C10M Defending The Internet At Scale&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201802/431521-20180202125016203-1852422480.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他提到了 UNIX 的设计初衷其实为电话网络的控制系统而设计的，而不是一般的服务器操作系统，所以，它仅仅是一个数据负责数据传送的系统，没有所谓的控制层面和数据层面的说法，不适合处理大规模的网络数据包。最后他得出的结论是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;OS 的内核不是解决 C10M 问题的办法，恰恰相反 OS 的内核正式导致 C10M 问题的关键所在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么这么说基于-os-内核的数据传输有什么弊端&quot;&gt;为什么这么说？基于 OS 内核的数据传输有什么弊端？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、中断处理。&lt;/strong&gt;当网络中大量数据包到来时，会产生频繁的硬件中断请求，这些硬件中断可以打断之前较低优先级的软中断或者系统调用的执行过程，如果这种打断频繁的话，将会产生较高的性能开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、内存拷贝。&lt;/strong&gt;正常情况下，一个网络数据包从网卡到应用程序需要经过如下的过程：数据从网卡通过 DMA 等方式传到内核开辟的缓冲区，然后从内核空间拷贝到用户态空间，在 Linux 内核协议栈中，这个耗时操作甚至占到了数据包整个处理流程的 57.1%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、上下文切换。&lt;/strong&gt;频繁到达的硬件中断和软中断都可能随时抢占系统调用的运行，这会产生大量的上下文切换开销。另外，在基于多线程的服务器设计框架中，线程间的调度也会产生频繁的上下文切换开销，同样，锁竞争的耗能也是一个非常严重的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、局部性失效。&lt;/strong&gt;如今主流的处理器都是多个核心的，这意味着一个数据包的处理可能跨多个 CPU 核心，比如一个数据包可能中断在 cpu0，内核态处理在 cpu1，用户态处理在 cpu2，这样跨多个核心，容易造成 CPU 缓存失效，造成局部性失效。如果是 NUMA 架构，更会造成跨 NUMA 访问内存，性能受到很大影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、内存管理。&lt;/strong&gt;传统服务器内存页为 4K，为了提高内存的访问速度，避免 cache miss，可以增加 cache 中映射表的条目，但这又会影响 CPU 的检索效率。&lt;/p&gt;
&lt;p&gt;综合以上问题，可以看出内核本身就是一个非常大的瓶颈所在。那很明显解决方案就是想办法绕过内核。&lt;/p&gt;
&lt;h2 id=&quot;解决方案探讨&quot;&gt;解决方案探讨&lt;/h2&gt;
&lt;p&gt;针对以上弊端，分别提出以下技术点进行探讨。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、控制层和数据层分离。&lt;/strong&gt;将数据包处理、内存管理、处理器调度等任务转移到用户空间去完成，而内核仅仅负责部分控制指令的处理。这样就不存在上述所说的系统中断、上下文切换、系统调用、系统调度等等问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用多核编程技术代替多线程技术，&lt;/strong&gt;并设置 CPU 的亲和性，将线程和 CPU 核进行一比一绑定，减少彼此之间调度切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、针对 NUMA 系统&lt;/strong&gt;，尽量使 CPU 核使用所在 NUMA 节点的内存，避免跨内存访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、使用大页内存&lt;/strong&gt;代替普通的内存，减少 cache-miss。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、采用无锁技术&lt;/strong&gt;解决资源竞争问题。&lt;/p&gt;
&lt;p&gt;经很多前辈先驱的研究，目前业内已经出现了很多优秀的集成了上述技术方案的高性能网络数据处理框架，如 6wind、windriver、netmap、dpdk 等，其中，Intel 的 dpdk 在众多方案脱颖而出，一骑绝尘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201802/431521-20180202125234687-1893812869.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dpdk 为 Intel 处理器架构下用户空间高效的数据包处理提供了库函数和驱动的支持，它不同于 Linux 系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理。&lt;/p&gt;
&lt;p&gt;也就是 dpdk 绕过了 Linux 内核协议栈对数据包的处理过程，在用户空间实现了一套数据平面来进行数据包的收发与处理。在内核看来，dpdk 就是一个普通的用户态进程，它的编译、连接和加载方式和普通程序没有什么两样。&lt;/p&gt;
&lt;h2 id=&quot;dpdk-的突破&quot;&gt;dpdk 的突破&lt;/h2&gt;
&lt;p&gt;相对传统的基于内核的网络数据处理，dpdk 对从内核层到用户层的网络数据流程进行了重大突破，我们先看看传统的数据流程和 dpdk 中的网络流程有什么不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统 Linux 内核网络数据流程：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;硬件中断---&amp;gt;取包分发至内核线程---&amp;gt;软件中断---&amp;gt;内核线程在协议栈中处理包---&amp;gt;处理完毕通知用户层
用户层收包--&amp;gt;网络层---&amp;gt;逻辑层---&amp;gt;业务层&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;dpdk 网络数据流程：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;硬件中断---&amp;gt;放弃中断流程
用户层通过设备映射取包---&amp;gt;进入用户层协议栈---&amp;gt;逻辑层---&amp;gt;业务层&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就具体看看 dpdk 做了哪些突破？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UIO （用户空间的 I/O 技术）的加持。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dpdk 能够绕过内核协议栈，本质上是得益于 UIO 技术，通过 UIO 能够拦截中断，并重设中断回调行为，从而绕过内核协议栈后续的处理流程。&lt;/p&gt;
&lt;p&gt;UIO 设备的实现机制其实是对用户空间暴露文件接口，比如当注册一个 UIO 设备 uioX，就会出现文件 /dev/uioX，对该文件的读写就是对设备内存的读写。除此之外，对设备的控制还可以通过 /sys/class/uio 下的各个文件的读写来完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201802/431521-20180202125414796-706128566.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存池技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dpdk 在用户空间实现了一套精巧的内存池技术，内核空间和用户空间的内存交互不进行拷贝，只做控制权转移。这样，当收发数据包时，就减少了内存拷贝的开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大页内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dpdk 实现了一组大页内存分配、使用和释放的 API，上层应用可以很方便使用 API 申请使用大页内存，同时也兼容普通的内存申请。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无锁环形队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dpdk 基于 Linux 内核的无锁环形缓冲 kfifo 实现了自己的一套无锁机制。支持单生产者入列/单消费者出列和多生产者入列/多消费者出列操作，在数据传输的时候，降低性能的同时还能保证数据的同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;poll-mode网卡驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DPDK网卡驱动完全抛弃中断模式，基于轮询方式收包，避免了中断开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NUMA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dpdk 内存分配上通过 proc 提供的内存信息，使 CPU 核心尽量使用靠近其所在节点的内存，避免了跨 NUMA 节点远程访问内存的性能问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 亲和性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dpdk 利用 CPU 的亲和性将一个线程或多个线程绑定到一个或多个 CPU 上，这样在线程执行过程中，就不会被随意调度，一方面减少了线程间的频繁切换带来的开销，另一方面避免了 CPU 缓存的局部失效性，增加了 CPU 缓存的命中率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多核调度框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dpdk 基于多核架构，一般会有主从核之分，主核负责完成各个模块的初始化，从核负责具体的业务处理。&lt;/p&gt;
&lt;p&gt;除了上述之外，dpdk 还有很多的技术突破，可以用下面这张图来概之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201802/431521-20180202125548812-1308226741.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;dpdk-的应用&quot;&gt;dpdk 的应用&lt;/h2&gt;
&lt;p&gt;dpdk 作为优秀的用户空间高性能数据包加速套件，现在已经作为一个“胶水”模块被用在多个网络数据处理方案中，用来提高性能。如下是众多的应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201802/431521-20180202125607359-287540014.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据面虚拟交换机&quot;&gt;数据面（虚拟交换机）：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OVS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Open vSwitch 是一个多核虚拟交换机平台，支持标准的管理接口和开放可扩展的可编程接口，支持第三方的控制接入。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/openvswitch/ovs&quot; class=&quot;uri&quot;&gt;https://github.com/openvswitch/ovs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VPP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VPP 是 cisco 开源的一个高性能的包处理框架，提供了 交换/路由 功能，在虚拟化环境中，使它可以当做一个虚拟交换机来使用。在一个类 SDN 的处理框架中，它往往充当数据面的角色。经研究表明，VPP 性能要好于 ovs+dpdk 的组合，但它更适用于NFV，适合做特定功能的网络模块。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.fd.io/view/VPP&quot; class=&quot;uri&quot;&gt;https://wiki.fd.io/view/VPP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lagopus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lagopus 是另一个多核虚拟交换的实现，功能和 OVS 差不多，支持多种网络协议，如 Ethernet，VLAN，QinQ，MAC-in-MAC，MPLS 和 PBB，以及隧道协议，如 GRE，VxLan 和 GTP。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lagopus/lagopus/blob/master/QUICKSTART.md&quot; class=&quot;uri&quot;&gt;https://github.com/lagopus/lagopus/blob/master/QUICKSTART.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Snabb&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Snabb 是一个简单且快速的数据包处理工具箱。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SnabbCo/snabbswitch/blob/master/README.md&quot; class=&quot;uri&quot;&gt;https://github.com/SnabbCo/snabbswitch/blob/master/README.md&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据面虚拟路由器&quot;&gt;数据面（虚拟路由器）：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OPENCONTRAIL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个集成了 SDN 控制器的虚拟路由器，现在多用在 OpenStack 中，结合 Neutron 为 OpenStack 提供一站式的网络支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.opencontrail.org/&quot; class=&quot;uri&quot;&gt;http://www.opencontrail.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CloudRouter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个分布式的路由器。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloudrouter.org/&quot; class=&quot;uri&quot;&gt;https://cloudrouter.org/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户空间协议栈&quot;&gt;用户空间协议栈&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;mTCP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mTCP 是一个针对多核系统的高可扩展性的用户空间 TCP/IP 协议栈。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/eunyoung14/mtcp/blob/master/README&quot; class=&quot;uri&quot;&gt;https://github.com/eunyoung14/mtcp/blob/master/README&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IwIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IwIP 针对 RAM 平台的精简版的 TCP/IP 协议栈实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git.savannah.gnu.org/cgit/lwip.git/tree/README&quot; class=&quot;uri&quot;&gt;http://git.savannah.gnu.org/cgit/lwip.git/tree/README&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seastar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Seastar 是一个开源的，基于 C++ 11/14 feature，支持高并发和低延迟的异步编程高性能库。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.seastar-project.org/&quot; class=&quot;uri&quot;&gt;http://www.seastar-project.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;f-stack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;腾讯开源的用户空间协议栈，移植于 FreeBSD协议栈，粘合了 POSIX API，上层应用（协程框架，Nginx,Redis），纯 C 编写，易上手。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/f-stack/f-stack&quot; class=&quot;uri&quot;&gt;https://github.com/f-stack/f-stack&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;dpdk 绕过了 Linux 内核协议栈，加速数据的处理，用户可以在用户空间定制协议栈，满足自己的应用需求，目前出现了很多基于 dpdk 的高性能网络框架，OVS 和 VPP 是常用的数据面框架，mTCP 和 f-stack 是常用的用户态协议栈。很多大公司都在使用 dpdk 来优化网络性能。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：对云计算感兴趣的小伙伴可以关注我的微信公众号：aCloudDeveloper，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201802/431521-20180202125851625-1007169747.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Feb 2018 05:01:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8404650.html</dc:identifier>
</item>
<item>
<title>CSS选择器的新用法 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8404264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8404264.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　现在，预处理器(如&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/6242257.html&quot; target=&quot;_blank&quot;&gt;sass&lt;/a&gt;)似乎已经成为开发CSS的标配，正如几年前&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/6489658.html&quot; target=&quot;_blank&quot;&gt;jQuery&lt;/a&gt;是开发JS的标配一样。JS的querySelector借鉴了jQuery的选择器思想，CSS选择器也借鉴了预处理器的变量定义、选择器嵌套、代码块重用等常用功能。本文将详细介绍CSS选择器的新用法&lt;/p&gt;

&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;　　一般地，我们在进行web开发时，会有一套变量定义规范，以sass为例，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色定义规范&lt;/span&gt;
$color-background : #&lt;span&gt;222&lt;/span&gt;&lt;span&gt;
$color&lt;/span&gt;-background-d : rgba(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0.3&lt;/span&gt;&lt;span&gt;)
$color&lt;/span&gt;-highlight-background : #&lt;span&gt;333&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体定义规范&lt;/span&gt;
$font-size-small :&lt;span&gt; 12px
$font&lt;/span&gt;-size-medium :&lt;span&gt; 14px
$font&lt;/span&gt;-size-large : 18px
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而CSS变量的语法如下&lt;/p&gt;
&lt;p&gt;【声明变量】&lt;/p&gt;
&lt;p&gt;　　变量必须以&lt;code&gt;--&lt;/code&gt;开头。例如--example-variable: 20px，意思是将20px赋值给--example-varibale变量&lt;/p&gt;
&lt;p&gt;　　可以将声明变量的语句置于任何元素内，如果要设置全局变量，则可以设置为:root、body或html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
:root{--bgColor:#&lt;span&gt;000&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　变量声明就像普通的样式声明语句一样，也可以使用内联样式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;body style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bgColor:#000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【使用变量】&lt;/p&gt;
&lt;p&gt;　　使用var()函数使用变量，并且可以被使用在任意的地方。例如：var(--example-variable)会返回--example-variable所对应的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;body style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bgColor:#000;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 100px;height: 100px;background-color: var(--bgColor)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;    
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　var()函数还有一个可选参数，用来设置默认值，当变量无法取得值时，则使用默认值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 100px;height: 100px;background-color: var(--bgColor,pink)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　[注意]关于CSS变量的详细用法&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/7182771.html&quot; target=&quot;_blank&quot;&gt;移步至此&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;@apply&lt;/h3&gt;
&lt;p&gt;　　介绍@apply之前，先介绍一下sass中的混合宏@mixin，指可以重用的代码块&lt;/p&gt;
&lt;p&gt;　　比如，常见的文字溢出隐藏重用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@mixin overflow-&lt;span&gt;ellipsis{
    overflow:hidden;
    text&lt;/span&gt;-&lt;span&gt;overflow: ellipsis;
    white&lt;/span&gt;-&lt;span&gt;space: nowrap;
  };
div {
    @include  overflow&lt;/span&gt;-&lt;span&gt;ellipsis;
}　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而应用规则集@apply也是实现类似的功能。与var()相比，@apply是引用样式的集合，而var()是引用一个单独的样式值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:root{
  &lt;/span&gt;--overflow-&lt;span&gt;ellipsis:{
    overflow:hidden;
    text&lt;/span&gt;-&lt;span&gt;overflow: ellipsis;
    white&lt;/span&gt;-&lt;span&gt;space: nowrap;
  };
}
.title{
  width:200px;
  @apply &lt;/span&gt;--overflow-&lt;span&gt;ellipsis;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;自定义选择器&lt;/h3&gt;
&lt;p&gt;　　自定义选择器通过&lt;code&gt;@custom-selector&lt;/code&gt;来定义，后面跟随一个&lt;code&gt;:--&lt;/code&gt;接着是自定义选择器的名称，后面是需要定义的选择器，多个用逗号隔开&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@custom-selector :--heading h1, h2, h3, h4, h5, h6;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样，:--heading就成为一个可以使用的选择器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
:--&lt;span&gt;heading{
  margin: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
h1, h2, h3, h4, h5, h6｛
   margin: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面两段代码的效果相同&lt;/p&gt;

&lt;h3&gt;选择器嵌套&lt;/h3&gt;
&lt;p&gt;　　CSS规则包含许多重复的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;table.colortable td {
  text&lt;/span&gt;-&lt;span&gt;align:center;
}
table.colortable td.c {
  text&lt;/span&gt;-&lt;span&gt;transform:uppercase;
}
table.colortable td:first&lt;/span&gt;-child, table.colortable td:first-child+&lt;span&gt;td {
  border:1px solid black;
}
table.colortable th {
  text&lt;/span&gt;-&lt;span&gt;align:center;
  background:black;
  color:white;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用嵌套语法后，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;table.colortable {
  &lt;/span&gt;&amp;amp;&lt;span&gt; td {
    text&lt;/span&gt;-&lt;span&gt;align:center;
    &lt;/span&gt;&amp;amp;.c { text-&lt;span&gt;transform:uppercase }
    &lt;/span&gt;&amp;amp;:first-child, &amp;amp;:first-child +&lt;span&gt; td { border:1px solid black }
  }
  &lt;/span&gt;&amp;amp;&lt;span&gt; th {
    text&lt;/span&gt;-&lt;span&gt;align:center;
    background:black;
    color:white;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当使用嵌套样式规则时，必须能够引用由父规则匹配的元素; 毕竟是整个嵌套点。为了达到这个目的，这个规范定义了一个新的选择器，即嵌套选择器，写成ASCII符号＆&lt;/p&gt;
&lt;p&gt;　　当在嵌套样式规则的选择器中使用时，嵌套选择器表示由父规则匹配的元素。在任何其他情况下使用时，它什么都不代表。（也就是说，它是有效的，但不匹配任何元素）&lt;/p&gt;
&lt;p&gt;　　[注意]&amp;amp;嵌套选择符的两种错误写法如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.foo {
  color: red;
  .bar &lt;/span&gt;&amp;amp;&lt;span&gt; { color:blue; }
}
.foo {
  color: red;
  &lt;/span&gt;&amp;amp;&lt;span&gt;.bar, .baz { color: blue; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【@nest】&lt;/p&gt;
&lt;p&gt;　　为了解决上面的嵌套选择符&amp;amp;的脆弱，可以使用@nest选择符，@nest可适用范围更广，只要与嵌套选择符&amp;amp;共同作用即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.foo {
  color: red;
  @nest &lt;/span&gt;&amp;amp; &amp;gt;&lt;span&gt; .bar {
    color: blue;
  }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等价于&lt;/span&gt;
&lt;span&gt;   .foo { color: red; }
   .foo &lt;/span&gt;&amp;gt; .bar { color: blue; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.foo {
  color: red;
  @nest .parent &lt;/span&gt;&amp;amp;&lt;span&gt; {
    color: blue;
  }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等价于&lt;/span&gt;
&lt;span&gt;   .foo { color: red; }
   .parent .foo { color: blue; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.foo {
  color: red;
  @nest :not(&lt;/span&gt;&amp;amp;&lt;span&gt;) {
    color: blue;
  }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等价于&lt;/span&gt;
&lt;span&gt;   .foo { color: red; }
   :not(.foo) { color: blue; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　[注意]@nest选择符的两种错误写法如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.foo {
  color: red;
  @nest .bar {
    color: blue;
  }
}
.foo {
  color: red;
  @nest &lt;/span&gt;&amp;amp;&lt;span&gt; .bar, .baz {
    color: blue;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;　　遗憾地是，除了CSS变量variable可以在新版本chrome下使用外，其他CSS选择器的新用法目前都没有浏览器支持。但是，CSS后处理器postcss中的cssnext插件可以解决所有问题&lt;/p&gt;
&lt;p&gt;　　就像&lt;a href=&quot;http://cssnext.io/&quot; target=&quot;_blank&quot;&gt;cssnext官网&lt;/a&gt;说的一样，今天就开始使用明天的CSS语法&lt;/p&gt;

</description>
<pubDate>Fri, 02 Feb 2018 03:29:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8404264.html</dc:identifier>
</item>
</channel>
</rss>