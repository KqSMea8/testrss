<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>salesforce零基础学习（八十四）配置篇： 自定义你的home page layout - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/7899371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/7899371.html</guid>
<description>&lt;p&gt;当我们进入salesforce系统或者切换app后，默认第一个看到的就是home页面。home页面简单的来说可以包括&lt;span&gt;左侧(narrow component)&lt;/span&gt;和&lt;span&gt;右侧(wide component)&lt;/span&gt;两部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211221857337-1413264539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;左侧包含Recent View,Custom Link,Create New等快捷入口等组件，右侧包括tasks,item to approval,calendar,dashboard snapshot等等。&lt;/p&gt;
&lt;p&gt;有时，不同简档的用户需要看到不同的Home页面中的组件或者显示不同的custom link等操作，这时我们就需要针对不同的简档配置不同的home page layout。配置步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一. Home Page Layout配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Set Up处搜索home page找到Home Page Layouts进入;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211211258024-873053708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.输入custom home page layout 名称，勾选需要显示在左侧和中间部分需要显示的组件；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211222412946-92584031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.调整顺序并点击save &amp;amp; assign；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211222631274-1837050964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.将创建的page layout 分配给profile 为System Administrator保存；&lt;/strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211222833712-1037924475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.效果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211223437321-810057550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过第一个图和效果展示的图可以看到通过自定义配置，将左侧的Create New组件拿掉了。&lt;/p&gt;
&lt;p&gt;通过上面的配置，我们看到针对profile自定义home page layout 很简单，无非就是勾选需要的component，调整顺序后分配一个或者多个简档即可。&lt;/p&gt;
&lt;p&gt;那么component是怎么出现的呢？&lt;/p&gt;
&lt;p&gt;component包含两部分，一部分是标准的component,包括Create New,Item to approve等等,另外一部分就是自定义 home page component.使用自定义home page component可以让你的home首页变得更加丰富，更加符合扩充的业务要求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 二.Home Page Component&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.点击Set Up，搜索Home Page Component后点击Home Page Component&lt;/strong&gt;:从图中可以看到，上面标准的component包括常见的component,其中Messages &amp;amp; Alerts 和Custom Links可以自定义，其他均只能引用，无法修改，下面有新建自定义的Components的按钮可以新建；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171213214040644-1885338527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.点击New按钮新建Custom Components,可以分成四类创建&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　Links：选择一个或者一组custom link作为一个component展示，类似标准组件custom links效果，此种类型仅可以放在左侧（Narrow Component）；&lt;/li&gt;
&lt;li&gt;　　Image/Logo：一张图片展示在sidebar处，此处更多的是使用公司的logo；&lt;/li&gt;
&lt;li&gt;　　HTML Area：富文本编辑器展示HTML区域，此类型可以放在左侧(Narrow Component)，也可以放在右侧(Wide Component)；&lt;/li&gt;
&lt;li&gt;       Visualforce Area:展示一个VF Page，此类型可以放在左侧(Narrow Component),也可以放在右侧(Wide Component)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171213215932082-1357281077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Links类型为可以创建一个自定义链接展示在component中，后面会详细描述Links类型的展示，下面针对Image/Logo,HTML Area 以及Visualforce Area 类型简单描述。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.1 Image/Logo:此类型通常用于展示公司Logo，其他情况下根据业务情况自己抉择。显示的图片需要先上传Document上并且要求图片必须小于100K。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　选择Type类型为Image，Name赋值以后点击Next；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216131928637-973485963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　点击Insert an Image选择图片存在的Document，选择后点击Save。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216132652169-639679482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　点击需要添加的Home Page Layout，将需要的componnet选中，并调整Component显示顺序后Save；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216132743731-1682636155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　Home首页效果展示。 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216132853653-367266010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　2.2 Html Area : 此处可以使用富文本编辑器简单的展示你需要展示的HTML区块，此模块不支持HTML标签，区域可以根据你创建时的选择放在左侧以及右侧。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　选择Type为HTML Area 输入名称后选择Next；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216134203091-679292676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　使用富文本编辑器按照要求创建需要的富文本内容以及格式后点击Save；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216135041278-97387133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　更改Home Page Layout，选择Test Html Area后更改显示顺序点击Save.下图为显示效果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216135317841-521832750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;2.3 Visualforce Area : HTML Area展示的效果毕竟没法写样式有很多限制，展示Visualforce Page可以更加丰富页面效果，比如首页展示公司产品进行轮播等等。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　新建Type 为Visualforce Area的Component,并赋值Name；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216140100794-1756712336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 　　选择需要展示的Visualforce Page 设置显示的高度等设置信息点击Save,然后修改Home Page Layout，将此Component勾选；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216140757858-1066784292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　 展示效果：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216141014624-7445872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三. Custom Link&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二步中有一项是创建类型为Custom Links，选择此类型后将一个或者一组Custom Link放在一起作为一个Component展示，Custom Link入口以及实现展示如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Set Up搜索Custom Link后在home下有一项为Custom Links,选中后即可新建或者更改Custom Link;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216202853389-1984893751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Custom Link源包括三部分组成：URL,On Click JavaScript以及Visualforce Page。&lt;/strong&gt;重写过标准的action或者新建过action的小伙伴应该对下面的页面很熟悉，Custom Link同样也支持Merge Field；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　URL:此种方式直接在输入框写一下目标的URL即可，当然这里面是可以引用merge field以及function来简单的实现一些动态情况的处理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216203755124-53945660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　On Click JavaScript：如果此链接是有复杂的逻辑进行确认最终的URL，可以使用On Click JavaScript,此种方式除了可以引用merge field以外，引入ajax toolkit js后还可以使用soql语句进行fetch操作来更加强大的支持你的业务要求。下面的例子为当前登录用户为lightning用户，则显示标准lightning页面，否则显示自定义列表页面；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216232425233-1365423662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Visualforce Page：指定点击此链接跳转到某个Visualforce Page页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216232756843-767623932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.修改Home Page Component,&lt;/strong&gt;将需要显示的Custom Links 选中后，将此component显示在Home Page Layout上即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216233202858-2038390666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;此篇主要描述如何自定义Home主页的UI，以及Home Page Layout,Home Page Component,Custom Links使用，主要内容都是基于配置的，开发量基本没有。篇中有描述错误地方欢迎指出，有问题的欢迎留言。&lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 15:37:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/7899371.html</dc:identifier>
</item>
<item>
<title>观中兴程序员跳楼之我见 - 邹琼俊</title>
<link>http://www.cnblogs.com/jiekzou/p/8048059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiekzou/p/8048059.html</guid>
<description>&lt;p&gt;数日前，中兴的一位42岁程序员跳楼引发了一场风波，中兴重新被推到了风口浪尖上，说实话，最近这几年，我都已经快忘记有中兴这家公司了，忘记这家曾经可以和华为分庭抗礼的公司，显然，它正逐渐被世人遗忘。&lt;img src=&quot;http://images2017.cnblogs.com/blog/413851/201712/413851-20171216231917639-2061374377.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次看见城里人跳楼，我总是想吐槽，尤其跳楼的还是同行。&lt;br/&gt;有些人肯定会说我冷漠，我只想说：真冷漠尤胜假仁义。真冷漠无公害，假仁义有如毒鸡汤，贻害无穷。&lt;/p&gt;&lt;p&gt;前阵子一保安伸手去接跳楼自杀的女子，双双身亡，连见义勇为都不算，有些跳楼自杀的人，居然还砸死路人，这，无力吐槽......”路见不平不吭声呀，拍拍屁股就走人哇，回家还要写代码啊...“&lt;/p&gt;&lt;p&gt;本来“死去元知万事空”，可是跳楼这样的事件，总是会成为小市民茶余饭后八卦和津津乐道的段子，别跟我说你有多伤心多同情、觉得多可惜...你若是真仁义，可曾去为死者家属捐过钱或者去悼念过，又或者去慰问过死难者的亲朋......显然是不会有的，最多在媒体上评论上一句：好可惜...何其廉价而又微不足道的一句话......&lt;/p&gt;&lt;p&gt;如果一个人自己都不珍惜自己的生命，别人又何必去怜惜他呢？自杀者，何足惜...&lt;br/&gt;歌词“心若在，梦就在...”说得太不明了，文化人都比较喜欢装B嘛，这大家都能理解，这里的“心”，不是死了的心脏或者冰冻的心脏，而是指人，人若在梦就在，人都不再了，还有啥梦可言呢？&lt;/p&gt;&lt;p&gt;都说三十而立，四十岁，男人正是花样年华，且上有老要孝敬，下有小要抚养，这一跳，死者解脱，活人受罪，作为男人，毫无家庭责任感可言，如果这么一点小挫折都承受不了，那么只能说：“有些人活着，他已经死了...&quot;要知道，社会上本来就存在各种黑暗，我们要学会坚强！从这一跳，不由得想起《三国演义》的歌词《这一拜》，然而到了这里却成了《这一跳》，我自己来填词好了。这一跳，快意恩仇赴黄泉，徒留代码在人间；这一跳，弃家逃避当懦夫，不忠不孝又不义；空余恨，这一跳，阴阳两隔，曾经沧海难为水，这一跳，生死不改，来世再做程序员......&lt;img src=&quot;http://images2017.cnblogs.com/blog/413851/201712/413851-20171216231824577-892498849.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;为什么要说是城里人跳楼，而不是农村人跳楼呢？一来城里楼高，二来城里人高调，三来城里人比较势力&lt;br/&gt;（死也要搏出名，信不信我死给你们看），即便是农村里来的人在城里待久了也很容易被同化。我曾经分析过，自杀的方式千千万，为何城里人钟爱跳楼，而农村人喜欢喝农药，文艺青年则钟情于卧轨自杀...&lt;br/&gt;有人说在城里跳楼最方便，可是这样子高空坠物，万一砸到人或者小朋友怎么办，就算不砸到人，砸到人家车、人家店、或者砸坏了花花草草，也不好嘛！而农村的人相对而言实在得多，也低调得多，更无公害性，独自一个人找个角落，偷偷的、默默的喝农药而亡，死了也无公害。&lt;/p&gt;&lt;p&gt;作为程序员，平时整天对着个电脑写代码，又少与人打交道，还是应该多”读书“，读书可以净化一个人的心灵，提升一个人的精神境界，尤其是读历史书，都说读史可以明智！&lt;/p&gt;&lt;p&gt;额外吐槽一下如今中国现状：以前由于职业习惯，背略微有点沉，个子又不高，而自己又是农村出来孩纸，没见过什么世面，总觉得缺乏男人应有的自信，但是自从遇见遍地低头族，我瞬间充满了自信，因为他们在我面前，总是抬不起头，所以我无论在公交、地铁上还是在走路，我总是昂首挺胸的走，遇见低头族，我头扬得更高，人更加有自信了，因为放眼望去，群雄俯首...哈哈！&lt;/p&gt;&lt;p&gt;自杀而亡者，不独性命堪，更是遗祸家人，悲呼哀哉！愿逝者安息！愿生者引以为戒！&lt;/p&gt;
&lt;p&gt;多少人曾羡慕你年轻时意气风发，可知谁叹息你冲天一怒去跳楼......&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tech.sina.com.cn/i/2017-12-15/doc-ifypsqiz9812858.shtml&quot; target=&quot;_blank&quot;&gt;中兴跳楼员工妻子现身 称跳楼因成公司内斗牺牲品&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 15:17:00 +0000</pubDate>
<dc:creator>邹琼俊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiekzou/p/8048059.html</dc:identifier>
</item>
<item>
<title>SQL基础教程读书笔记-1 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8048051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8048051.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;51&quot;&gt;

&lt;h2&gt;&lt;span&gt;2.2 算数运算符和比较运算符&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.2.1算数运算符&lt;/span&gt;&lt;/h3&gt;
&lt;span&gt;&lt;strong&gt;+ - * /&lt;/strong&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;需要注意&lt;strong&gt;NULL&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;5 + NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;10 - NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;1 * NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4 / NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;NULL / 9&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;NULL / 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以上运算结果全都是NULL,实际上所有包含NULL的运算，结果肯定是NULL。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;2.2.2比较运算符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;=&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;和~相等&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;和~不相等&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;大于等于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;大于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;小于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;小于等于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;2.对字符串使用不等号时的注意事项&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;字符串类型的数据原则上按照字典进行排序&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11 &amp;gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是 '11'&amp;lt;'2'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.不能对NULL使用比较运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;希望选取NULL记录时，需要在条件表达式中使用&lt;strong&gt;IS NULL&lt;/strong&gt;运算符；希望选取不是NULL的记录时，需要在条件表达式中使用&lt;strong&gt;IS NOT NULL&lt;/strong&gt; 运算符。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.3逻辑运算符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.SQL中的逻辑运算包含对真、假和不确定进行运算的三值逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否定某一条件&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;AND&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;并且&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;OR&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;或&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;2.AND优先级高于OR，优先执行OR可以使用括号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.三值逻辑中的AND和OR真值表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;P&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;Q&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;P AND Q&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;OR&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;P&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;Q&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;P OR Q&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;3.1 对表进行聚合查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.聚合函数（集合函数）：计算之前已经将NULL排除在外。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;COUNT&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;计算表中的记录数（行数）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;SUM&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;计算表中数值列中数据的合计值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;AVG&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;计算表中数值列中数据的平均值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;MAX&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;求出表中任意列中数据的最大值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;MIN&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;求出表中任意列中数据的最小值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;2.COUNT函数的结果根据参数的不同而不同&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COUNT(*)包含NULL的数据行数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COUNT(&amp;lt;列名&amp;gt;)NULL之外的数据行数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MAX/MIN函数几乎适用于所有数据类型的列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SUM/AVG只适用于数值类型的列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.使用聚合函数删除重复值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;COUNT( DISTINCT *)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.2对表进行分组&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.GROUP BY子句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT &amp;lt;列名1&amp;gt;，&amp;lt;列名2&amp;gt;，&amp;lt;列名3&amp;gt;，...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;FROM &amp;lt;表明&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;GROUP BY &amp;lt;列名1&amp;gt;，&amp;lt;列名2&amp;gt;，&amp;lt;列名3&amp;gt;，...;&lt;br/&gt;&lt;strong&gt;聚合键中包含NULL时，在结果中会以&quot;不确定&quot;行（空行）的形式表现出来。&lt;/strong&gt;&lt;br/&gt;2.与聚合函数和GROUP BY子句有关的常见错误&lt;br/&gt;常见错误①——在SELECT子句中书写了多余的列（MYSQL 支持）&lt;br/&gt;使用聚合函数时，SELECT子句只能存在以下三种元素&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;常数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;聚合函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GROUP BY 子句指定的列名（也就是聚合键）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;常见错误②——在GROUP BY子句中写了列的别名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下列语句会发生执行错误：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT product_type AS pt,count(*)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM product&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GROUP BY pt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这是因为SQL在DBMS中的执行顺序造成的——SELECT子句在GROUP BY子句之后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见错误③——GROUP BY子句结果能排序吗&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GROUP BY 子句结果的显示是无序的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见错误④——在WHERE子句中使用聚合函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;只有SELECT子句和HAVING子句（以及ORDER BY子句）中能够使用聚合函数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.3为聚合结果指定条件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.HAVING子句为集合（组）指定条件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HAVING可以使用3中要素：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;常数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;聚合函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GROUP BY子句中指定的列名（聚合键）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.相对于HAVING子句，更适合写在WHERE 子句中的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;聚合键所对应的条件不应写在HAVING子句当中，而应写在WHERE子句中。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;原因：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①:WHERE子句 = 指定行所对应的条件；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HAVING子句 = 指定组所对应的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②:WHERE执行速度快，使用COUNT函数等对表中数据进行聚合操作时，DBMS内部会进行排序处理，尽可能减少排序的行数，才能增加处理速度。WHERE在排序前过滤，减少了排序行数。HAVING在排序之后进行过滤。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.4 对查询结果进行排序&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.使用ORDER BY对查询结果进行排序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.在ORDER BY 子句中列名的后面使用关键字ASC 可以进行升序排序；使用DESC关键字可以进行降序排序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.ORDER BY子句中可以使用多个排序键。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.排序键包含NULL时，会在开头或末尾进行汇总。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.在ORDER BY子句中可以使用SELECT子句中定义的别名。这是因为SELECT的执行顺序：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM——&amp;gt;WHERE——&amp;gt;GROUP BY ——&amp;gt;HAVING ——&amp;gt;SELECT ——&amp;gt;ORDER BY&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6.在ORDER BY子句中可以使用SELECT子句中未使用的列和聚合函数。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 16 Dec 2017 15:16:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8048051.html</dc:identifier>
</item>
<item>
<title>虚拟DOM详解 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/8047742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/8047742.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; global module, document, Node &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
import {Module} from &lt;/span&gt;'./modules/module'&lt;span&gt;;
import {Hooks} from &lt;/span&gt;'./hooks'&lt;span&gt;;
import vnode, {VNode, VNodeData, Key} from &lt;/span&gt;'./vnode'&lt;span&gt;;
import &lt;/span&gt;* as is from './is'&lt;span&gt;;
import htmlDomApi, {DOMAPI} from &lt;/span&gt;'./htmldomapi'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; isUndef(s: any): &lt;span&gt;boolean&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; s ===&lt;span&gt; undefined; }
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; isDef(s: any): &lt;span&gt;boolean&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; s !==&lt;span&gt; undefined; }

type VNodeQueue &lt;/span&gt;= Array&amp;lt;VNode&amp;gt;&lt;span&gt;;

const emptyNode &lt;/span&gt;= vnode(''&lt;span&gt;, {}, [], undefined, undefined);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; sameVnode(vnode1: VNode, vnode2: VNode): &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vnode1.key === vnode2.key &amp;amp;&amp;amp; vnode1.sel ===&lt;span&gt; vnode2.sel;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isVnode(vnode: any): vnode is VNode {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vnode.sel !==&lt;span&gt; undefined;
}

type KeyToIndexMap &lt;/span&gt;=&lt;span&gt; {[key: string]: number};

type ArraysOf&lt;/span&gt;&amp;lt;T&amp;gt; =&lt;span&gt; {
  [K &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; keyof T]: (T[K])[];
}

type ModuleHooks &lt;/span&gt;= ArraysOf&amp;lt;Module&amp;gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; createKeyToOldIdx(children: Array&amp;lt;VNode&amp;gt;&lt;span&gt;, beginIdx: number, endIdx: number): KeyToIndexMap {
  let i: number, map: KeyToIndexMap &lt;/span&gt;= {}, key: Key |&lt;span&gt; undefined, ch;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = beginIdx; i &amp;lt;= endIdx; ++&lt;span&gt;i) {
    ch &lt;/span&gt;=&lt;span&gt; children[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      key &lt;/span&gt;=&lt;span&gt; ch.key;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key !== undefined) map[key] =&lt;span&gt; i;
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
}

const hooks: (keyof Module)[] &lt;/span&gt;= ['create', 'update', 'remove', 'destroy', 'pre', 'post'&lt;span&gt;];

export {h} from &lt;/span&gt;'./h'&lt;span&gt;;
export {thunk} from &lt;/span&gt;'./thunk'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; init(modules: Array&amp;lt;Partial&amp;lt;Module&amp;gt;&amp;gt;, domApi?&lt;span&gt;: DOMAPI) {
  let i: number, j: number, cbs &lt;/span&gt;=&lt;span&gt; ({} as ModuleHooks);

  const api: DOMAPI &lt;/span&gt;= domApi !== undefined ?&lt;span&gt; domApi : htmlDomApi;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将各个模块的增删改查钩子方法挂在模块钩子集合中&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; hooks.length; ++&lt;span&gt;i) {
    cbs[hooks[i]] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = 0; j &amp;lt; modules.length; ++&lt;span&gt;j) {
      const hook &lt;/span&gt;=&lt;span&gt; modules[j][hooks[i]];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hook !==&lt;span&gt; undefined) {
        (cbs[hooks[i]] as Array&lt;/span&gt;&amp;lt;any&amp;gt;&lt;span&gt;).push(hook);
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; emptyNodeAt(elm: Element) {
    const id &lt;/span&gt;= elm.id ? '#' + elm.id : ''&lt;span&gt;;
    const c &lt;/span&gt;= elm.className ? '.' + elm.className.split(' ').join('.') : ''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vnode(api.tagName(elm).toLowerCase() + id +&lt;span&gt; c, {}, [], undefined, elm);
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createRmCb(childElm: Node, listeners: number) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; rmCb() {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (--listeners === 0&lt;span&gt;) {
        const parent &lt;/span&gt;=&lt;span&gt; api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any, data &lt;/span&gt;=&lt;span&gt; vnode.data;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data !==&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.init)) {
        i(vnode);
        data &lt;/span&gt;=&lt;span&gt; vnode.data;
      }
    }
    let children &lt;/span&gt;= vnode.children, sel =&lt;span&gt; vnode.sel;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sel === '!'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(vnode.text)) {
        vnode.text &lt;/span&gt;= ''&lt;span&gt;;
      }
      vnode.elm &lt;/span&gt;=&lt;span&gt; api.createComment(vnode.text as string);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sel !==&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parse selector&lt;/span&gt;
      const hashIdx = sel.indexOf('#'&lt;span&gt;);
      const dotIdx &lt;/span&gt;= sel.indexOf('.'&lt;span&gt;, hashIdx);
      const hash &lt;/span&gt;= hashIdx &amp;gt; 0 ?&lt;span&gt; hashIdx : sel.length;
      const dot &lt;/span&gt;= dotIdx &amp;gt; 0 ?&lt;span&gt; dotIdx : sel.length;
      const tag &lt;/span&gt;= hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0&lt;span&gt;, Math.min(hash, dot)) : sel;
      const elm &lt;/span&gt;= vnode.elm = isDef(data) &amp;amp;&amp;amp; isDef(i = (data as VNodeData).ns) ?&lt;span&gt; api.createElementNS(i, tag)
                                                                               : api.createElement(tag);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hash &amp;lt; dot) elm.setAttribute('id', sel.slice(hash + 1&lt;span&gt;, dot));
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dotIdx &amp;gt; 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '&lt;span&gt;));
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.create.length; ++&lt;span&gt;i) cbs.create[i](emptyNode, vnode);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is.array(children)) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; children.length; ++&lt;span&gt;i) {
          const ch &lt;/span&gt;=&lt;span&gt; children[i];
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      i &lt;/span&gt;= (vnode.data as VNodeData).hook; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reuse variable&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(i)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i.create) i.create(emptyNode, vnode);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i.insert) insertedVnodeQueue.push(vnode);
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      vnode.elm &lt;/span&gt;=&lt;span&gt; api.createTextNode(vnode.text as string);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vnode.elm;
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; addVnodes(parentElm: Node,
                     before: Node &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                     vnodes: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                     startIdx: number,
                     endIdx: number,
                     insertedVnodeQueue: VNodeQueue) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; startIdx &amp;lt;= endIdx; ++&lt;span&gt;startIdx) {
      const ch &lt;/span&gt;=&lt;span&gt; vnodes[startIdx];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; invokeDestroyHook(vnode: VNode) {
    let i: any, j: number, data &lt;/span&gt;=&lt;span&gt; vnode.data;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data !==&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.destroy)) i(vnode);
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.destroy.length; ++&lt;span&gt;i) cbs.destroy[i](vnode);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vnode.children !==&lt;span&gt; undefined) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = 0; j &amp;lt; vnode.children.length; ++&lt;span&gt;j) {
          i &lt;/span&gt;=&lt;span&gt; vnode.children[j];
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; i !== &quot;string&quot;&lt;span&gt;) {
            invokeDestroyHook(i);
          }
        }
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; removeVnodes(parentElm: Node,
                        vnodes: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                        startIdx: number,
                        endIdx: number): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; startIdx &amp;lt;= endIdx; ++&lt;span&gt;startIdx) {
      let i: any, listeners: number, rm: () &lt;/span&gt;=&amp;gt; &lt;span&gt;void&lt;/span&gt;, ch =&lt;span&gt; vnodes[startIdx];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners &lt;/span&gt;= cbs.remove.length + 1&lt;span&gt;;
          rm &lt;/span&gt;=&lt;span&gt; createRmCb(ch.elm as Node, listeners);
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.remove.length; ++&lt;span&gt;i) cbs.remove[i](ch, rm);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = ch.data) &amp;amp;&amp;amp; isDef(i = i.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.remove)) {
            i(ch, rm);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            rm();
          }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Text node&lt;/span&gt;
&lt;span&gt;          api.removeChild(parentElm, ch.elm as Node);
        }
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; updateChildren(parentElm: Node,
                          oldCh: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                          newCh: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                          insertedVnodeQueue: VNodeQueue) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明指针&lt;/span&gt;
    let oldStartIdx = 0, newStartIdx = 0&lt;span&gt;;
    let oldEndIdx &lt;/span&gt;= oldCh.length - 1&lt;span&gt;;

    let oldStartVnode &lt;/span&gt;= oldCh[0&lt;span&gt;];
    let oldEndVnode &lt;/span&gt;=&lt;span&gt; oldCh[oldEndIdx];
    let newEndIdx &lt;/span&gt;= newCh.length - 1&lt;span&gt;;
    let newStartVnode &lt;/span&gt;= newCh[0&lt;span&gt;];
    let newEndVnode &lt;/span&gt;=&lt;span&gt; newCh[newEndIdx];
    let oldKeyToIdx: any;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (oldStartIdx &amp;lt;= oldEndIdx &amp;amp;&amp;amp; newStartIdx &amp;lt;=&lt;span&gt; newEndIdx) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果节点已经被标记处理过，直接跳过&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (oldStartVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        oldStartVnode &lt;/span&gt;= oldCh[++oldStartIdx]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vnode might have been moved left&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldEndVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newStartVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newEndVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx];

      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldStartVnode, newStartVnode)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理头头相同情况&lt;/span&gt;
&lt;span&gt;        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode &lt;/span&gt;= oldCh[++&lt;span&gt;oldStartIdx];
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldEndVnode, newEndVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾尾相同&lt;/span&gt;
&lt;span&gt;        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx];
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldStartVnode, newEndVnode)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头尾相同 // Vnode moved right&lt;/span&gt;
&lt;span&gt;        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将oldStart指向的节点插入到oldEnd指向节点前面&lt;/span&gt;
&lt;span&gt;        api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node));
        oldStartVnode &lt;/span&gt;= oldCh[++&lt;span&gt;oldStartIdx];
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldEndVnode, newStartVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vnode moved left 尾头相同&lt;/span&gt;
&lt;span&gt;        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将oldEnd指向节点插入到oldStart之前&lt;/span&gt;
&lt;span&gt;        api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node);
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx];
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldKeyToIdx === undefined) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 制作key-index的哈西集合&lt;/span&gt;
          oldKeyToIdx =&lt;span&gt; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld &lt;/span&gt;=&lt;span&gt; oldKeyToIdx[newStartVnode.key as string];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUndef(idxInOld)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; New element&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新节点则插入到oldStart指向的dom节点之前&lt;/span&gt;
&lt;span&gt;          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          elmToMove &lt;/span&gt;=&lt;span&gt; oldCh[idxInOld];
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (elmToMove.sel !==&lt;span&gt; newStartVnode.sel) {
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打补丁&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对旧的位置坐标记设为undefined&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将更新后的节点移动到oldStart之前&lt;/span&gt;
&lt;span&gt;            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] &lt;/span&gt;=&lt;span&gt; undefined as any;
            api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node);
          }
          newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
        }
      }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldStartIdx &amp;gt; oldEndIdx) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新的有剩余则需要将这些节点插入到dom树中&lt;/span&gt;
      before = newCh[newEndIdx+1] == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : newCh[newEndIdx+1&lt;span&gt;].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newStartIdx &amp;gt; newEndIdx) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老的有节点则应该移除&lt;/span&gt;
&lt;span&gt;      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) {
    let i: any, hook: any;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用prepatch钩子&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isDef(i = vnode.data) &amp;amp;&amp;amp; isDef(hook = i.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; hook.prepatch)) {
      i(oldVnode, vnode);
    }
    const elm &lt;/span&gt;= vnode.elm =&lt;span&gt; (oldVnode.elm as Node);
    let oldCh &lt;/span&gt;=&lt;span&gt; oldVnode.children;
    let ch &lt;/span&gt;=&lt;span&gt; vnode.children;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldVnode === vnode) &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有变化直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (vnode.data !== undefined) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对两个虚拟dom树的根节点进行更新&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.update.length; ++&lt;span&gt;i) cbs.update[i](oldVnode, vnode);
      i &lt;/span&gt;=&lt;span&gt; vnode.data.hook;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.update)) i(oldVnode, vnode);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUndef(vnode.text)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否有文本节点&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (isDef(oldCh) &amp;amp;&amp;amp; isDef(ch)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 都有子节点对子节点进行diff算法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (oldCh !== ch) updateChildren(elm, oldCh as Array&amp;lt;VNode&amp;gt;, ch as Array&amp;lt;VNode&amp;gt;&lt;span&gt;, insertedVnodeQueue);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isDef(ch)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新虚拟dom有子节点旧的没有，则把新的子节点挂在dom上&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isDef(oldVnode.text)) api.setTextContent(elm, ''&lt;span&gt;);
        addVnodes(elm, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ch as Array&amp;lt;VNode&amp;gt;, 0, (ch as Array&amp;lt;VNode&amp;gt;).length - 1&lt;span&gt;, insertedVnodeQueue);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isDef(oldCh)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老的里面有子节点，新的没有直接干掉老的&lt;/span&gt;
        removeVnodes(elm, oldCh as Array&amp;lt;VNode&amp;gt;, 0, (oldCh as Array&amp;lt;VNode&amp;gt;).length - 1&lt;span&gt;);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isDef(oldVnode.text)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老的有文本信息直接设置为空字符串&lt;/span&gt;
        api.setTextContent(elm, ''&lt;span&gt;);
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldVnode.text !== vnode.text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用新的文本信息替换旧的&lt;/span&gt;
&lt;span&gt;      api.setTextContent(elm, vnode.text as string);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(hook) &amp;amp;&amp;amp; isDef(i = hook.postpatch)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用postpatch方法&lt;/span&gt;
&lt;span&gt;      i(oldVnode, vnode);
    }
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; patch(oldVnode: VNode |&lt;span&gt; Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.pre.length; ++i) cbs.pre[i]();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用所有模块的pre钩子方法&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (!isVnode(oldVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非虚拟dom直接清空&lt;/span&gt;
      oldVnode =&lt;span&gt; emptyNodeAt(oldVnode);
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sameVnode(oldVnode, vnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两个虚拟dom树的根节点完全一样才会进行打补丁&lt;/span&gt;
&lt;span&gt;      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果跟节点不同直接干掉旧的根节点，重新创建dom元素插入到dom树中&lt;/span&gt;
      elm =&lt;span&gt; oldVnode.elm as Node;
      parent &lt;/span&gt;=&lt;span&gt; api.parentNode(elm);

      createElm(vnode, insertedVnodeQueue);

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], &lt;/span&gt;0, 0&lt;span&gt;);
      }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对每个插入的元素使用相应模块中的insert钩子方法进行更新&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; insertedVnodeQueue.length; ++&lt;span&gt;i) {
      (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.post.length; ++i) cbs.post[i](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用所有钩子模块的post方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; vnode;
  };
}&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 16 Dec 2017 14:20:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/8047742.html</dc:identifier>
</item>
<item>
<title>Mybatis框架解析之Builder解析 - KMSFan</title>
<link>http://www.cnblogs.com/kmsfan/p/8047878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kmsfan/p/8047878.html</guid>
<description>&lt;p&gt;首先我们从builder这个类入手，首先我们注意到BaseBuilder,其实它的本质上市一个抽象类，它从本质上抽象出了Builder的一切，我猜想这里一定使用了建造者模式，但是这个抽象类里面居然没有抽象方法！&lt;/p&gt;
&lt;p&gt;其中XXXValueOf方法，其实是把String字符串转换成了相对应的类型，如下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bd682ed8-cb54-43fe-9d1b-de14354b353b')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd682ed8-cb54-43fe-9d1b-de14354b353b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd682ed8-cb54-43fe-9d1b-de14354b353b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bd682ed8-cb54-43fe-9d1b-de14354b353b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd682ed8-cb54-43fe-9d1b-de14354b353b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Boolean booleanValueOf(String value, Boolean defaultValue) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultValue : Boolean.valueOf(value);
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer integerValueOf(String value, Integer defaultValue) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultValue : Integer.valueOf(value);
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; stringSetValueOf(String value, String defaultValue) {
    value &lt;/span&gt;= (value == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultValue : value);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;String&amp;gt;(Arrays.asList(value.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中resoveXXXType的目的就是把string转换成相对应的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('45dba8f4-175e-4503-a8a8-e1cd7a634cd1')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_45dba8f4-175e-4503-a8a8-e1cd7a634cd1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_45dba8f4-175e-4503-a8a8-e1cd7a634cd1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('45dba8f4-175e-4503-a8a8-e1cd7a634cd1',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_45dba8f4-175e-4503-a8a8-e1cd7a634cd1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; JdbcType resolveJdbcType(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JdbcType.valueOf(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving JdbcType. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ResultSetType resolveResultSetType(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultSetType.valueOf(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving ResultSetType. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ParameterMode resolveParameterMode(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ParameterMode.valueOf(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving ParameterMode. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的方法是通过字符串别名解析出相对应的类型，再从类型创建实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d4589562-b55e-457c-8ce4-fa8785264a7a')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d4589562-b55e-457c-8ce4-fa8785264a7a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d4589562-b55e-457c-8ce4-fa8785264a7a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d4589562-b55e-457c-8ce4-fa8785264a7a',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d4589562-b55e-457c-8ce4-fa8785264a7a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object createInstance(String alias) {
    Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; resolveClass(alias);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolveClass(alias).newInstance();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error creating instance. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; resolveClass(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolveAlias(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving class. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注意下面的，是2个不同的重载类，是第一个调用第二个。首先得到相对应的TypeHanlder类型，如果该TypeHanlder在typeHanlderRegisty注册中心有留存，那么返回，否则从javatype里创建一个新的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('536e4b64-a3ef-443c-82ac-0f85eec35e1b')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_536e4b64-a3ef-443c-82ac-0f85eec35e1b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_536e4b64-a3ef-443c-82ac-0f85eec35e1b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('536e4b64-a3ef-443c-82ac-0f85eec35e1b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_536e4b64-a3ef-443c-82ac-0f85eec35e1b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; TypeHandler&amp;lt;?&amp;gt; resolveTypeHandler(Class&amp;lt;?&amp;gt;&lt;span&gt; javaType, String typeHandlerAlias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (typeHandlerAlias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    Class&lt;/span&gt;&amp;lt;?&amp;gt; type =&lt;span&gt; resolveClass(typeHandlerAlias);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !TypeHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(type)) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + type.getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is not a valid TypeHandler because it does not implement TypeHandler interface&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    @SuppressWarnings( &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; already verified it is a TypeHandler&lt;/span&gt;
    Class&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt; typeHandlerType = (Class&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt;) type;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolveTypeHandler(javaType, typeHandlerType);
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; TypeHandler&amp;lt;?&amp;gt; resolveTypeHandler(Class&amp;lt;?&amp;gt; javaType, Class&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; typeHandlerType) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (typeHandlerType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; javaType ignored for injected handlers see issue #746 for full detail&lt;/span&gt;
    TypeHandler&amp;lt;?&amp;gt; handler =&lt;span&gt; typeHandlerRegistry.getMappingTypeHandler(typeHandlerType);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; not in registry, create a new one&lt;/span&gt;
      handler =&lt;span&gt; typeHandlerRegistry.getInstance(javaType, typeHandlerType);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handler;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中MapperBuilderAssistant在此包下面，并且继承了BaseBuilder,下面对此类做一个解析，比如下面的就是解析命名空间的，就是包名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b6ec82c5-06f1-4b65-97cf-cda253c2edd3')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_b6ec82c5-06f1-4b65-97cf-cda253c2edd3&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b6ec82c5-06f1-4b65-97cf-cda253c2edd3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b6ec82c5-06f1-4b65-97cf-cda253c2edd3',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b6ec82c5-06f1-4b65-97cf-cda253c2edd3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; String applyCurrentNamespace(String &lt;span&gt;base&lt;/span&gt;&lt;span&gt;, boolean isReference) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isReference) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is it qualified with any namespace yet?&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt;.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is it qualified with this namespace yet?&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt;.startsWith(currentNamespace + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt;.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dots are not allowed in element names, please remove it from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;base&lt;/span&gt;&lt;span&gt;);
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; currentNamespace + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的代码主要是用namespace得到cache的一个实例，就这么理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b430db11-5d08-4ec1-a3ec-0c1163339d76')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b430db11-5d08-4ec1-a3ec-0c1163339d76&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b430db11-5d08-4ec1-a3ec-0c1163339d76&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b430db11-5d08-4ec1-a3ec-0c1163339d76',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b430db11-5d08-4ec1-a3ec-0c1163339d76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; Cache useCacheRef(String &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;namespace&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cache-ref element requires a namespace attribute.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      unresolvedCacheRef &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      Cache cache &lt;/span&gt;= configuration.getCache(&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cache == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IncompleteElementException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No cache for namespace '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;namespace&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' could be found.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
      currentCache &lt;/span&gt;=&lt;span&gt; cache;
      unresolvedCacheRef &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IncompleteElementException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No cache for namespace '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;namespace&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' could be found.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的方法是创建cache。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f316c6ed-1725-41ce-9010-6fed9ad92ecb')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_f316c6ed-1725-41ce-9010-6fed9ad92ecb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f316c6ed-1725-41ce-9010-6fed9ad92ecb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f316c6ed-1725-41ce-9010-6fed9ad92ecb',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f316c6ed-1725-41ce-9010-6fed9ad92ecb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Cache useNewCache(Class&amp;lt;? extends Cache&amp;gt;&lt;span&gt; typeClass,
      Class&lt;/span&gt;&amp;lt;? extends Cache&amp;gt;&lt;span&gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    Cache cache &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CacheBuilder(currentNamespace)
        .implementation(valueOrDefault(typeClass, PerpetualCache.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
        .addDecorator(valueOrDefault(evictionClass, LruCache.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
        .clearInterval(flushInterval)
        .size(size)
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    configuration.addCache(cache);
    currentCache &lt;/span&gt;=&lt;span&gt; cache;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中有一个地方要弄清楚，就是Class&amp;lt;? extends Cache&amp;gt; typeClass,    Class&amp;lt;? extends Cache&amp;gt; evictionClass的区别在哪里？在哪里呢？请看下图，一个是实现，一个是装饰者，你可以暂时理解为作用不同，就这么简单。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/567748/201712/567748-20171216214324968-1281445395.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;下面是addParameterMap方法的一些介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; ParameterMap addParameterMap(String id, Class&amp;lt;?&amp;gt; parameterClass, List&amp;lt;ParameterMapping&amp;gt;&lt;span&gt; parameterMappings) {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到包名。&lt;/span&gt;
    id = applyCurrentNamespace(id, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工厂方法创建参数Map,并添加到configuration中去。&lt;/span&gt;
    ParameterMap parameterMap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterMap.Builder(configuration, id, parameterClass, parameterMappings).build();
    configuration.addParameterMap(parameterMap);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parameterMap;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是buildParameterMap的介绍，其实它也是利用了工厂方法骑构造。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6c07fa04-8ca6-4f31-bde4-94006be3b017')&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_6c07fa04-8ca6-4f31-bde4-94006be3b017&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c07fa04-8ca6-4f31-bde4-94006be3b017&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6c07fa04-8ca6-4f31-bde4-94006be3b017',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c07fa04-8ca6-4f31-bde4-94006be3b017&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ParameterMapping buildParameterMapping(
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; parameterType,
      String property,
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; javaType,
      JdbcType jdbcType,
      String resultMap,
      ParameterMode parameterMode,
      Class&lt;/span&gt;&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; typeHandler,
      Integer numericScale) {
    resultMap &lt;/span&gt;= applyCurrentNamespace(resultMap, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Class parameterType = parameterMapBuilder.type();&lt;/span&gt;
    Class&amp;lt;?&amp;gt; javaTypeClass =&lt;span&gt; resolveParameterJavaType(parameterType, property, javaType, jdbcType);
    TypeHandler&lt;/span&gt;&amp;lt;?&amp;gt; typeHandlerInstance =&lt;span&gt; resolveTypeHandler(javaTypeClass, typeHandler);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterMapping.Builder(configuration, property, javaTypeClass)
        .jdbcType(jdbcType)
        .resultMapId(resultMap)
        .mode(parameterMode)
        .numericScale(numericScale)
        .typeHandler(typeHandlerInstance)
        .build();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的是建立一个结果集，然后把结果集添加到configuration里面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('db783f49-dab1-436d-8279-816419f036d2')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_db783f49-dab1-436d-8279-816419f036d2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_db783f49-dab1-436d-8279-816419f036d2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('db783f49-dab1-436d-8279-816419f036d2',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_db783f49-dab1-436d-8279-816419f036d2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultMap addResultMap(
      String id,
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; type,
      String extend,
      Discriminator discriminator,
      List&lt;/span&gt;&amp;lt;ResultMapping&amp;gt;&lt;span&gt; resultMappings,
      Boolean autoMapping) {
    id &lt;/span&gt;= applyCurrentNamespace(id, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    extend &lt;/span&gt;= applyCurrentNamespace(extend, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (extend != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;configuration.hasResultMap(extend)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IncompleteElementException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Could not find a parent resultmap with id '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + extend + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
      ResultMap resultMap &lt;/span&gt;=&lt;span&gt; configuration.getResultMap(extend);
      List&lt;/span&gt;&amp;lt;ResultMapping&amp;gt; extendedResultMappings = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ResultMapping&amp;gt;&lt;span&gt;(resultMap.getResultMappings());
      extendedResultMappings.removeAll(resultMappings);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove parent constructor if this resultMap declares a constructor.&lt;/span&gt;
      boolean declaresConstructor = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ResultMapping resultMapping : resultMappings) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {
          declaresConstructor &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (declaresConstructor) {
        Iterator&lt;/span&gt;&amp;lt;ResultMapping&amp;gt; extendedResultMappingsIter =&lt;span&gt; extendedResultMappings.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (extendedResultMappingsIter.hasNext()) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) {
            extendedResultMappingsIter.remove();
          }
        }
      }
      resultMappings.addAll(extendedResultMappings);
    }
    ResultMap resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)
        .discriminator(discriminator)
        .build();
    configuration.addResultMap(resultMap);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;当然，下面的也太多了，就不一一介绍了，还有一些这些结果集的一些Getter方法；有兴趣的可以自己去看看，不过我们从这里得到了一个很重要的东西，那就是贯穿上下文的一个东西：Configuration!,这个东西可以说是无处不在，不管是在基类，还是在派生类中。&lt;/p&gt;
&lt;p&gt;我们还看到了一些工厂的Relover，那这些resover类其实也是调用了上面的一些public方法而已，没啥特别的，真的。&lt;/p&gt;
&lt;p&gt;下面我们再看看SqlSourceBuilder 这个类，这个先从string解析成map,然后再判断是否是sql类型，如果是，继续解析。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e06a2dd0-16ea-4cc7-816f-949e0b689c8c')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_e06a2dd0-16ea-4cc7-816f-949e0b689c8c&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e06a2dd0-16ea-4cc7-816f-949e0b689c8c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e06a2dd0-16ea-4cc7-816f-949e0b689c8c',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e06a2dd0-16ea-4cc7-816f-949e0b689c8c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ParameterMapping buildParameterMapping(String content) {
      Map&lt;/span&gt;&amp;lt;String, String&amp;gt; propertiesMap =&lt;span&gt; parseParameterMapping(content);
      String property &lt;/span&gt;= propertiesMap.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; propertyType;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (metaParameters.hasGetter(property)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #448 get type from additional params&lt;/span&gt;
        propertyType =&lt;span&gt; metaParameters.getGetterType(property);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (typeHandlerRegistry.hasTypeHandler(parameterType)) {
        propertyType &lt;/span&gt;=&lt;span&gt; parameterType;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (JdbcType.CURSOR.name().equals(propertiesMap.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jdbcType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))) {
        propertyType &lt;/span&gt;= java.sql.ResultSet.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (property == &lt;span&gt;null&lt;/span&gt; || Map.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(parameterType)) {
        propertyType &lt;/span&gt;= Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        MetaClass metaClass &lt;/span&gt;=&lt;span&gt; MetaClass.forClass(parameterType, configuration.getReflectorFactory());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (metaClass.hasGetter(property)) {
          propertyType &lt;/span&gt;=&lt;span&gt; metaClass.getGetterType(property);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          propertyType &lt;/span&gt;= Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        }
      }
      ParameterMapping.Builder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterMapping.Builder(configuration, property, propertyType);
      Class&lt;/span&gt;&amp;lt;?&amp;gt; javaType =&lt;span&gt; propertyType;
      String typeHandlerAlias &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, String&amp;gt;&lt;span&gt; entry : propertiesMap.entrySet()) {
        String name &lt;/span&gt;=&lt;span&gt; entry.getKey();
        String value &lt;/span&gt;=&lt;span&gt; entry.getValue();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javaType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          javaType &lt;/span&gt;=&lt;span&gt; resolveClass(value);
          builder.javaType(javaType);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jdbcType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.jdbcType(resolveJdbcType(value));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.mode(resolveParameterMode(value));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numericScale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.numericScale(Integer.valueOf(value));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.resultMapId(value);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;typeHandler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          typeHandlerAlias &lt;/span&gt;=&lt;span&gt; value;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jdbcTypeName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.jdbcTypeName(value);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do Nothing&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Expression based parameters are not supported yet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An invalid property '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' was found in mapping #{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + content + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}.  Valid properties are &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; parameterProperties);
        }
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (typeHandlerAlias != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中比较重要的就是下面的代码，下面做一个分析，首先会得到typeHanldler,然后再在buidler里对这个进行注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;if&lt;/span&gt; (typeHandlerAlias != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; builder.build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们关键是看看builder.build方法，它是一个private的方法，它的作用就是get到我们开始设置的值，下面的validate方法也是做一些基础验证的，具体的可以略过，没啥价值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; resolveTypeHandler() {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameterMapping.typeHandler == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parameterMapping.javaType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        Configuration configuration &lt;/span&gt;=&lt;span&gt; parameterMapping.configuration;
        TypeHandlerRegistry typeHandlerRegistry &lt;/span&gt;=&lt;span&gt; configuration.getTypeHandlerRegistry();
        parameterMapping.typeHandler &lt;/span&gt;=&lt;span&gt; typeHandlerRegistry.getTypeHandler(parameterMapping.javaType, parameterMapping.jdbcType);
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们再来看看这个类:StaticSqlSource 其实我觉得这个玩意没啥用！真的不是贬低写mybatis的人，真没看出有什么用，具体看下面的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6760d333-1772-4fd1-96eb-d16774c26563')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_6760d333-1772-4fd1-96eb-d16774c26563&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6760d333-1772-4fd1-96eb-d16774c26563&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6760d333-1772-4fd1-96eb-d16774c26563',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6760d333-1772-4fd1-96eb-d16774c26563&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticSqlSource implements SqlSource {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final String sql;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final List&amp;lt;ParameterMapping&amp;gt;&lt;span&gt; parameterMappings;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final Configuration configuration;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StaticSqlSource(Configuration configuration, String sql) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(configuration, sql, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StaticSqlSource(Configuration configuration, String sql, List&amp;lt;ParameterMapping&amp;gt;&lt;span&gt; parameterMappings) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sql =&lt;span&gt; sql;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parameterMappings =&lt;span&gt; parameterMappings;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configuration =&lt;span&gt; configuration;
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BoundSql getBoundSql(Object parameterObject) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BoundSql(configuration, sql, parameterMappings, parameterObject);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这些类同级的包里面，还有一个XML的包，里面包含的DTD文件，以及一些工具类，大家理解这些东西，其实就是为了把烦人的XML转换成一个可用的configuration对象的的工具类就行了，真的没必要深究。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/567748/201712/567748-20171216220319108-1375933912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于builder的&lt;em id=&quot;__mceDel&quot;&gt;annotation &lt;/em&gt;大家应该不陌生了吧？我介绍了这么多。构造函数说得很清楚了，其实把一些基本的注解加进了，CRUD而已。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; MapperAnnotationBuilder(Configuration configuration, Class&amp;lt;?&amp;gt;&lt;span&gt; type) {
    String resource &lt;/span&gt;= type.getName().replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.java (best guess)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.assistant = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperBuilderAssistant(configuration, resource);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configuration =&lt;span&gt; configuration;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;

    sqlAnnotationTypes.add(Select.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlAnnotationTypes.add(Insert.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlAnnotationTypes.add(Update.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlAnnotationTypes.add(Delete.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    sqlProviderAnnotationTypes.add(SelectProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlProviderAnnotationTypes.add(InsertProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlProviderAnnotationTypes.add(UpdateProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlProviderAnnotationTypes.add(DeleteProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;有一个核心方法，比较重要:parse,作用很明显，就是转换呗，然后是从configuration拿玩意，然后转换成有用的东西。其实这个不就是我们写的mapper类的XML文件吗？！用过mybatis的人都知道的。注释写了一点，不过更深入了，我觉得没必要写了，靠大家自己去发掘。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e2cbda21-f2e0-4e79-b67f-be52783081fc')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_e2cbda21-f2e0-4e79-b67f-be52783081fc&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e2cbda21-f2e0-4e79-b67f-be52783081fc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e2cbda21-f2e0-4e79-b67f-be52783081fc',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e2cbda21-f2e0-4e79-b67f-be52783081fc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parse() {
    String resource &lt;/span&gt;=&lt;span&gt; type.toString();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;configuration.isResourceLoaded(resource)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;载入XML资源文件。&lt;/span&gt;
&lt;span&gt;      loadXmlResource();
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把资源文件添加到configuation里面。&lt;/span&gt;
&lt;span&gt;      configuration.addLoadedResource(resource);
      assistant.setCurrentNamespace(type.getName());
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改assistant变量&lt;/span&gt;
&lt;span&gt;      parseCache();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改assistant变量2&lt;/span&gt;
&lt;span&gt;      parseCacheRef();
      Method[] methods &lt;/span&gt;=&lt;span&gt; type.getMethods();
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #237&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;method.isBridge()) {
            parseStatement(method);
          }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IncompleteElementException e) {
          configuration.addIncompleteMethod(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MethodResolver(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, method));
        }
      }
    }
    parsePendingMethods();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 16 Dec 2017 14:13:00 +0000</pubDate>
<dc:creator>KMSFan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kmsfan/p/8047878.html</dc:identifier>
</item>
<item>
<title>Tomcat 源码分析（一）——启动与生命周期组件 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/8047869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/8047869.html</guid>
<description>&lt;p&gt;写在前面的话：读Tomcat源码也有段时间了，大领悟谈不上。一些小心得记录下来，供大家参考相护学习。&lt;/p&gt;
&lt;p&gt;一、启动流程&lt;/p&gt;
&lt;p&gt;Tomcat启动首先需要熟悉的是它的启动流程。和初学者第一天开始写Hello World一样，Tomcat的启动也依赖main方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * org.apache.catalina.startup.Bootstrap
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (daemon == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Bootstrap bootstrap = &lt;span&gt;new&lt;/span&gt; Bootstrap(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例对象&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         bootstrap.init(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        handleThrowable(t);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     daemon =&lt;span&gt; bootstrap;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实例化Bootstrap之后，首先需要对它初始化。初始化的流程很长，但是省略掉细节其实就是做了两件事：&lt;/p&gt;
&lt;p&gt;（1）为当前线程创建类加载器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
initClassLoaders()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）通过反射实例化一个Catalina对象（Tomcat组件的实际管理者）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Class&amp;lt;?&amp;gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;&lt;span&gt;);
Object startupInstance &lt;/span&gt;= startupClass.newInstance();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 初始化以后daemon和catalinaDaemon就完成了赋值。继续main方法往下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; String command = &quot;start&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (args.length &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     command = args[args.length - 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (command.equals(&quot;startd&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     args[args.length - 1] = &quot;start&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     daemon.load(args); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     daemon.start(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (command.equals(&quot;stopd&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     args[args.length - 1] = &quot;stop&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    daemon.stop();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (command.equals(&quot;start&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     daemon.setAwait(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    daemon.load(args);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    daemon.start();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (command.equals(&quot;stop&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    daemon.stopServer(args);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先执行加载，依然是使用反射调用Catalina对象的load()方法。方法里面的代码很多第一次看的同学肯定会有点蒙，仔细分析一下：&lt;/p&gt;
&lt;p&gt;（1）读取conf/server.xml文件并解析InputStream：&lt;/p&gt;
&lt;p&gt;Digester是一个xml文件解析工具，目前属于Apache的Jakarta项目。使用Digester解析xml文件代码量少也非常简单。&lt;a href=&quot;http://commons.apache.org/digester/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）初始化Server&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Server serv =&lt;span&gt; getServer();
serv.init();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来我们看看server.xml的文档结构，里面包含了几个重要的节点：Server、Listener、Service、Connector、Engine、Realm、Host。初始化的过程其实就是将这些节点所代表的对象逐一初始化。Server是其它节点的根节点，所以首先对它执行init()操作。&lt;/p&gt;
&lt;p&gt;二、生命周期管理&lt;/p&gt;
&lt;p&gt;Tomcat中的许多对象都实现了Lifecycle接口，里面定义了12个状态，类关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/871676/201712/871676-20171216204226905-640664638.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LifecycleBase实现了Lifecycle并引入LifecycleState和LifecycleSupport，LifecycleState是一个枚举类，将12个状态除NEW和FAILED以外分别将状态和事件对应，并通过事件触发监听器。LifecycleSupport集中管理各种监听器。Tomcat通过4个方法管理这些状态：init() 、start()、stop()、destroy()，而LifecycleBase实现了init() 、start()、stop()、destroy()又暴露了4个接口initInternal()、startInternal()、stopInternal()、destroyInternal()。所有生命周期对象都需要实现以上4个方法，是设计模式中的模板模式。&lt;/p&gt;
&lt;p&gt;初略分析了一下Tomcat对于组件的管理方式，接下来再回到Catalina的load()方法。方法中通过getServer()获取StandardServer实例，并执行initInternal()方法。在server.xml配置文件中，server节点可以包含多个service&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; services.length; i++&lt;span&gt;) {
    services[i].init(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化StandardService&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在StandardService的initInternal()方法中继续初始化Connector和Executor，重点代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (connectorsLock) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Connector connector : connectors) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            connector.init();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             String message =&lt;span&gt; sm.getString(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &quot;standardService.connector.initFailed&quot;&lt;span&gt;, connector);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            log.error(message, e);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Boolean.getBoolean(&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LifecycleException(message);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当所有组件初始化完成之后执行启动流程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; getServer().start();&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     Server srv =&lt;span&gt; getServer();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     srv.start(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动流程...&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (LifecycleException e) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     log.fatal(sm.getString(&quot;catalina.serverStartFail&quot;&lt;span&gt;), e);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        getServer().destroy();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (LifecycleException e1) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         log.debug(&quot;destroy() failed for failed Server &quot;&lt;span&gt;, e1);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和initInternal()流程类似，startInternal()方法也是逐步调用，就不在文章中一一分析了。感兴趣的同学要想深入探究请通过源码debug分析。&lt;/p&gt;

&lt;p&gt;总结：Tomcat启动流程实质上就是对各个生命周期组件的管理并通过Digester解析xml文件，这些组件在不同的生命周期状态又分别对应不同的响应事件，监听器通过响应事件驱动也方便了开发者的二次扩展值得认真学习。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 14:11:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/8047869.html</dc:identifier>
</item>
<item>
<title>基于百度地图SDK和Elasticsearch GEO查询的地理围栏分析系统（1） - 扎心了老铁</title>
<link>http://www.cnblogs.com/kangoroo/p/8047586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kangoroo/p/8047586.html</guid>
<description>&lt;p&gt;本文描述了一个系统，功能是评价和抽象地理围栏(Geo-fencing)，以及监控和分析核心地理围栏中业务的表现。&lt;/p&gt;
&lt;p&gt;技术栈：Spring-JQuery-百度地图WEB SDK&lt;/p&gt;
&lt;p&gt;存储：Hive-Elasticsearch-MySQL-Redis&lt;/p&gt;

&lt;p&gt;什么是地理围栏？&lt;/p&gt;
&lt;p&gt;LBS系统中，地理围栏指的是虚拟边界围成的部分。&lt;/p&gt;
&lt;p&gt;tips：这只是一个demo，支撑实习生的本科毕设，不代表生产环境，而且数据已经做了脱密处理，为了安全还是隐去了所有数据。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、地理围栏的圈选&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1061021/201712/1061021-20171216195032343-1141251246.png&quot; alt=&quot;&quot; width=&quot;779&quot; height=&quot;346&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)热力图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;热力图展示的是，北京市最近一天的业务密度（这里是T+1数据，在实际工作场景中往往是通过实时流采集分析实时的数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)圈选地理围栏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统提供了圆形(距中心点距离)、矩形、多边形三种类型的图形圈选，并通过百度地图SDK采集图形的信息。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、地理围栏的持久化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)提供地理围栏的持久化功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1061021/201712/1061021-20171216200128827-781467835.png&quot; alt=&quot;&quot; width=&quot;787&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2)地理围栏列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是持久化的地理围栏列表，可以看到类型和围栏信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1061021/201712/1061021-20171216200716202-154037399.png&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当圈选完成，可以选择持久化地理围栏，这个围栏将会沉淀下来，供后续业务分析和监控。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、聚合分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)提供日订单量，日盈利和日取消率的聚合分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如下图是在某个地理围栏区域内，11月这30天内，订单量的变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1061021/201712/1061021-20171216201041202-235097510.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; (2)详细列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供每一天数据的详细信息，对异常点可以标红和预警&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1061021/201712/1061021-20171216201440952-747680973.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面基本就是系统的全部核心功能。下面进入实现部分。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现 - 数据准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、数据源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据源应该是业务的数据库(例如订单库)以及客户端埋点日志(端动作)，公司的离线采集和ETL团队经过了漫长的工作，将数据处理好存入了Hive中。&lt;/p&gt;
&lt;p&gt;对于本文系统来说，数据源就是Hive中的order表。要做的是将Hive中的数据导入到Elasticsearch中，使用Elasticsearch强大的GEO Query支持进行分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、数据导入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据的导入使用的是一段Java的Spark脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）先解决依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spark-core是必备依赖。引入spark-hive来处理Hive中的数据。引入elasticsearch-hadoop来搞定Hive到ES的写入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.spark&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spark-core_2.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.6.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;provided&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.spark&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spark-hive_2.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.6.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;provided&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.elasticsearch&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;elasticsearch-hadoop&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.3.4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（2）编写spark脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;先上代码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ToES &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JavaSparkContext javaSparkContext;
    &lt;/span&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HiveContext hiveContext;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String num;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *   初始化Load
    *   创建sparkContext, hiveContext
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ToES(String num) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num =&lt;span&gt; num;
        initSparckContext();
        initHiveContext();
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *   创建sparkContext
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initSparckContext() {
        SparkConf sparkConf;
        String warehouseLocation &lt;/span&gt;= System.getProperty(&quot;user.dir&quot;&lt;span&gt;);
        sparkConf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkConf()
                .setAppName(&lt;/span&gt;&quot;to-es&quot;&lt;span&gt;)
                .set(&lt;/span&gt;&quot;spark.sql.warehouse.dir&quot;&lt;span&gt;, warehouseLocation)
                .setMaster(&lt;/span&gt;&quot;yarn-client&quot;&lt;span&gt;)
                .set(&lt;/span&gt;&quot;es.nodes&quot;, &quot;10.93.21.21,10.93.18.34,10.93.18.35,100.90.62.33,100.90.61.14&quot;&lt;span&gt;)
                .set(&lt;/span&gt;&quot;es.port&quot;, &quot;8049&quot;).set(&quot;pushdown&quot;, &quot;true&quot;).set(&quot;es.index.auto.create&quot;, &quot;true&quot;&lt;span&gt;);
        javaSparkContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JavaSparkContext(sparkConf);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *   创建hiveContext
    *   用于读取Hive中的数据
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initHiveContext() {
        hiveContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HiveContext(javaSparkContext);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *   使用spark-sql从hive中读取数据, 然后写入es.
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hive2es() {
        String query &lt;/span&gt;= String.format(&quot;select * from kangaroo.order where concat_ws('-', year, month, day) = '%s' and product_id in (3,4) and area = 1&quot;&lt;span&gt;,
                transTimeToFormat(System.currentTimeMillis() &lt;/span&gt;- Integer.parseInt(num)*24*60*60*1000L, &quot;yyyy-MM-dd&quot;&lt;span&gt;));
        DataFrame rows &lt;/span&gt;=&lt;span&gt; hiveContext.sql(query)
                .select(&lt;/span&gt;&quot;order_id&quot;, &quot;starting_lng&quot;, &quot;starting_lat&quot;, &quot;order_status&quot;, &quot;tip&quot;, &quot;bouns&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;pre_total_fee&quot;, &quot;dynamic_price&quot;, &quot;product_id&quot;, &quot;starting_name&quot;, &quot;dest_name&quot;, &quot;type&quot;&lt;span&gt;);
        JavaRDD&lt;/span&gt;&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; rdd = rows.toJavaRDD().map(&lt;span&gt;new&lt;/span&gt; Function&amp;lt;Row, Map&amp;lt;String, Object&amp;gt;&amp;gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
            *   转换成Map, 解决字段类型不匹配问题
            * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; call(Row row) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; map =  &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
                Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; location = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;row.size(); i++&lt;span&gt;) {
                    String key &lt;/span&gt;=&lt;span&gt; row.schema().fields()[i].name();
                    Object value &lt;/span&gt;=&lt;span&gt; row.get(i);
&lt;/span&gt;&lt;span&gt;                    map.put(key, value);
                }
                location.put(&lt;/span&gt;&quot;lat&quot;, Double.parseDouble(map.get(&quot;starting_lat&quot;&lt;span&gt;).toString()));
                location.put(&lt;/span&gt;&quot;lon&quot;, Double.parseDouble(map.get(&quot;starting_lng&quot;&lt;span&gt;).toString()));
                map.remove(&lt;/span&gt;&quot;starting_lat&quot;&lt;span&gt;);
                map.remove(&lt;/span&gt;&quot;starting_lng&quot;&lt;span&gt;);
                map.put(&lt;/span&gt;&quot;location&quot;&lt;span&gt;, location);
                map.put(&lt;/span&gt;&quot;date&quot;, transTimeToFormat(System.currentTimeMillis() - Integer.parseInt(num)*24*60*60*1000L, &quot;yyyy-MM-dd&quot;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
            }
        });
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        map.put(&lt;/span&gt;&quot;es.mapping.id&quot;, &quot;order_id&quot;&lt;span&gt;);
        JavaEsSpark.saveToEs(rdd, &lt;/span&gt;&quot;moon/bj&quot;&lt;span&gt;, map);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String transTimeToFormat(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; currentTime, String formatStr) {
        String formatTime &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            SimpleDateFormat format &lt;/span&gt;=  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(formatStr);
            formatTime &lt;/span&gt;=&lt;span&gt; format.format(currentTime);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; formatTime;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String num &lt;/span&gt;= args[0&lt;span&gt;];
        ToES toES &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ToES(num);
        toES.hive2es();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SparkContext和HiveContext的初始化，请自行参考代码。&lt;/p&gt;
&lt;p&gt;ES的集群配置是在sparkConf中加载进去的，加载方式请自己参照代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1）数据过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;hive-sql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; kangaroo.&lt;span&gt;order&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; concat_ws(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;year&lt;/span&gt;, &lt;span&gt;month&lt;/span&gt;, &lt;span&gt;day&lt;/span&gt;) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; product_id &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; area &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;a)Hive的order表实现为一个外部表，year/month/day是分区字段，也就是说数据是按照天为粒度挂载的。&lt;/p&gt;
&lt;p&gt;b)product_id是业务编号，这里过滤出了目标业务的订单。&lt;/p&gt;
&lt;p&gt;c)area为城市编号，这里只过滤出北京。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2）列的裁剪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Elasticsearch有个弊端是由于索引的建立，当数据导入Elasticsearch数据量会膨胀，所以一定要进行维度的裁剪。&lt;/p&gt;
&lt;p&gt;我们的订单Hive表姑且就叫它order吧，这个表有40+个字段，我们导入到ES中，只选用了其中的12个字段。&lt;/p&gt;
&lt;p&gt;在代码中是，通过DataFrame的select实现的裁剪&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
DataFrame rows =&lt;span&gt; hiveContext.sql(query)
                .select(&lt;/span&gt;&quot;order_id&quot;, &quot;starting_lng&quot;, &quot;starting_lat&quot;, &quot;order_status&quot;, &quot;tip&quot;, &quot;bouns&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;pre_total_fee&quot;, &quot;dynamic_price&quot;, &quot;product_id&quot;, &quot;starting_name&quot;, &quot;dest_name&quot;, &quot;type&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能会有这样的好奇，这样做在hive-sql中把所有字段全拿到然后在裁剪？为什么不直接在sql语句中进行裁剪？简单解释一下，由于spark的惰性求值，应该是没有区别的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3）map转换操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面将dataFrame转换成rdd，执行map操作，将每一条记录进行处理，处理的核心逻辑，是将starting_lng、starting_lat压成一个HashMap的location字段。&lt;/p&gt;
&lt;p&gt;为什么要这样做呢？&lt;/p&gt;
&lt;p&gt;因为在Elasticsearch中要这样存储点的经纬度，并且将location字段声明为geo_point类型，才能使用空间索引查询。&lt;/p&gt;
&lt;p&gt;然后我们顺便生成了一个date字段，表示订单是哪一天的，方便后面的以天为粒度进行聚合查询。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4）批量存入ES&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        Map&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        map.put(&lt;/span&gt;&quot;es.mapping.id&quot;, &quot;order_id&quot;&lt;span&gt;);
        JavaEsSpark.saveToEs(rdd, &lt;/span&gt;&quot;moon/bj&quot;, map);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就将rdd中的数据批量存入到ES中了，存入的索引是index=moon，type=bj，这里映射了order_id为ES文档的document_id。我们下面马上就会说如何建立moon/bj的mapping&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5）ES索引建立 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再将数据导入到ES之前，要建立index和mapping。&lt;/p&gt;
&lt;p&gt;创建index=moon&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl -XPOST &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.93.21.21:8049/moon?pretty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建type=bj的mapping&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
curl -XPOST &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.93.21.21:8049/moon/bj/_mapping?pretty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -d &lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order_status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bouns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pre_total_fee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic_price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;product_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dest_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not_analyzed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;starting_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not_analyzed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;departure_time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not_analyzed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;geo_point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not_analyzed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        }
    }
}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里要注意的是，location字段的类型-geo_point。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6）打包编译spark程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以yarn队列形式运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
spark-submit --queue=root.*** to-es-&lt;span&gt;1.0&lt;/span&gt;-SNAPSHOT-jar-with-dependencies.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在ES的head中可以看到数据已经加载进去了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1061021/201712/1061021-20171216213848061-1672969899.png&quot; alt=&quot;&quot; width=&quot;925&quot; height=&quot;367&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，数据已经准备好了。&lt;/p&gt;
&lt;p&gt;今天先到这，后面的博客会描述如何搞定百度地图前端和Elasticsearch GEO查询。&lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 13:43:00 +0000</pubDate>
<dc:creator>扎心了老铁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kangoroo/p/8047586.html</dc:identifier>
</item>
<item>
<title>自动类型安全的.NET标准REST库refit - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/8047749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/8047749.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.hanselman.com/&quot;&gt;SCOTT HANSELMAN&lt;/a&gt; 博客上看到一个好东西《&lt;a href=&quot;https://www.hanselman.com/blog/ExploringRefitAnAutomaticTypesafeRESTLibraryForNETStandard.aspx&quot;&gt;Exploring refit, an automatic type-safe REST library for .NET Standard&lt;/a&gt;》，他推荐了一个.NET标准1.4 的自动类型安全的REST库refit。 refit 类似于Java的&lt;a href=&quot;http://square.github.io/retrofit&quot;&gt;Retrofit&lt;/a&gt;，是一套RESTful架构的.NET客户端实现，基于特性，提供把REST API返回的数据转化为(Plain Ordinary C# Object,简单C#对象)，POCO to JSON，网络请求(POST，GET,PUT，DELETE等)封装，内部封装使用HttpClient,前者专注于接口的封装，后者专注于网络请求的高效，二者分工协作。我们的应用程序通过 &lt;code&gt;refit&lt;/code&gt;请求网络，实际上是使用 &lt;code&gt;refit&lt;/code&gt;接口层封装请求参数、Header、Url 等信息，之后由 &lt;code&gt;HttpClient&lt;/code&gt;完成后续的请求操作，在服务端返回数据之后，&lt;code&gt;HttpClient&lt;/code&gt;将原始的结果交给 &lt;code&gt;refit&lt;/code&gt;，后者根据用户的需求对结果进行解析的过程。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IGitHubApi
{
    [Get(&quot;/users/{user}&quot;)]
    Task&amp;lt;User&amp;gt; GetUser(string user);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义上面的一个REST API接口。 该接口定义了一个函数 GetUser,该函数会通过HTTP GET请求去访问服务器的&lt;code&gt;/users/{user}&lt;/code&gt;路径并把返回的结果封装为User POCO 对象返回。&lt;/p&gt;
&lt;p&gt;其中URL路径中的&lt;code&gt;{user}&lt;/code&gt;的值为GetUser函数中的参数 &lt;code&gt;user&lt;/code&gt;的取值。&lt;/p&gt;
&lt;p&gt;然后通过 &lt;code&gt;RestService&lt;/code&gt; 类来生成一个 &lt;code&gt;IGitHubApi&lt;/code&gt; 接口的实现，使用HttpClient 调用；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var gitHubApi = RestService.For&amp;lt;IGitHubApi&amp;gt;(&lt;a href=&quot;https://api.github.com&quot;&gt;https://api.github.com&lt;/a&gt;);
var octocat = await gitHubApi.GetUser(&quot;octocat&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的示例可以看出， refit使用特性来声明HTTP请求&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持 URL 参数替换和查询参数&lt;/li&gt;
&lt;li&gt;返回结果转换为C#对象(返回结果可以为JSON)&lt;/li&gt;
&lt;li&gt;支持 Multipart请求和文件上传&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;具体使用文档&lt;/h4&gt;
&lt;p&gt;函数和函数参数上的特性声明了请求方式&lt;/p&gt;
&lt;h5&gt;1、请求方式&lt;/h5&gt;
&lt;p&gt;每个函数都必须带有 HTTP特性来表明请求方式和请求的URL路径。类库中有5个HTTP注解:&lt;strong&gt;GET&lt;/strong&gt;, &lt;strong&gt;POST&lt;/strong&gt;, &lt;strong&gt;PUT&lt;/strong&gt;,&lt;strong&gt;DELETE&lt;/strong&gt;和&lt;strong&gt;HEAD&lt;/strong&gt;。注解中的参数为请求的&lt;strong&gt;相对URL路径&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Get(&quot;/users/list&quot;)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在URL路径中也可以指定URL参数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Get(&quot;/users/list?sort=desc&quot;)]&lt;/code&gt;
&lt;/pre&gt;
&lt;h5&gt;2、URL处理&lt;/h5&gt;
&lt;p&gt;请求的URL可以根据函数参数动态更新。一个可替换的区块为用 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 包围的字符串，而函数参数必需用 &lt;code&gt;@&lt;/code&gt;&lt;code&gt;AliasAs特性&lt;/code&gt;标明，并且特性&lt;em&gt;的参数为&lt;/em&gt; &lt;strong&gt;同样的字符串&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Get(&quot;/group/{id}/users&quot;)]//注意 字符串id
Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; GroupList([AliasAs(&quot;id&quot;)] int groupId); //注意 AliasAs特性的参数要和前面的字符串一样 id&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
还支持查询参数
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[Get(&quot;/group/{id}/users&quot;)]
Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; GroupList([AliasAs(&quot;id&quot;)] int groupId, [AliasAs(&quot;sort&quot;)] string sortOrder);

GroupList(4, &quot;desc&quot;);
&amp;gt;&amp;gt;&amp;gt; &quot;/group/4/users?sort=desc&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5&gt;3、请求体（Request Body）&lt;/h5&gt;
&lt;p&gt;通过[&lt;code&gt;Body]特性&lt;/code&gt;可以声明一个对象作为请求体发送到服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Post(&quot;/users/new&quot;)]
Task CreateUser([Body] User user);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
对象将被&lt;code&gt;RestService &lt;/code&gt;使用对应的转换器转换为字符串或者字节流提交到服务器。
&lt;/pre&gt;
&lt;h5&gt;4、FORM ENCODED AND MULTIPART 表单和Multipart&lt;/h5&gt;
&lt;p&gt;函数也可以注解为发送表单数据和multipart 数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、服务器结果转换为C# 对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;RestService&lt;/code&gt; 的转换器把HTTP请求结果（默认为JSON）转换为C#对象，C#对象通过函数返回值指定&lt;/p&gt;
&lt;p&gt;6、&lt;strong&gt;添加请求头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过[Headers]来添加请求头,支持动态的请求头。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;refit&lt;/code&gt;是非常强大的，本文通过丰富的示例和对源码的挖掘，向大家展示了 &lt;span&gt;refit&lt;/span&gt;自身强大的功能以及扩展性&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 13:29:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/8047749.html</dc:identifier>
</item>
<item>
<title>SpringData 基于SpringBoot快速入门 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/8047132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/8047132.html</guid>
<description>&lt;p&gt;本章通过学习SpringData 和SpringBoot 相关知识将面向服务架构(SOA)的单点登录系统(SSO)需要的代码实现。这样可以从实战中学习两个框架的知识，又可以为单点登录系统打下基础。通过本章你将掌握 SpringBoot项目的搭建，Starter pom的使用，配置全局文件，核心注解SpringBootApplication 介绍以及单元测试 SpringBootTest注解的使用。SpringData 的入门使用，Repository接口的使用，查询方法关键字的规则定义，@Query，@Modifying 注解的使用，最后是开发中的建议和遇到的问题。文章底部提供源码。&lt;/p&gt;
&lt;h2 id=&quot;springboot-知识&quot;&gt;SpringBoot 知识&lt;/h2&gt;
&lt;p&gt;SpringBoot 是一个用于简化Spring应用搭建开发的框架。开发过程中，我们经常通过配置xml文件来整合第三方技术。而这些重复整合的工作交给了SpringBoot完成。SpringBoot使用&quot;习惯优于配置&quot;的理念帮我们快速搭建并运行项目。对主流的开发框架能无配置集成。笔者用的开发工具是sts(Spring Tool Suite),其操作和eclipse几乎一致。若没有这个工具，创建Maven项目是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201712/806956-20171216192509577-2044105820.png&quot; alt=&quot;项目搭建&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;starter-pom&quot;&gt;Starter pom&lt;/h3&gt;
&lt;p&gt;先看看Maven项目核心配置文件 pom.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.itdragon&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springbootStudy&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
    &amp;lt;name&amp;gt;springbootStudy&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;
    &amp;lt;!-- 
        添加 spring boot的父级依赖，它是SpringBoot项目的标志
        spring-boot-starter-parent 它是一个特殊的starter，提供了很多相关的Maven依赖，不用再为version而头疼了，大大简化了开发
    --&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.9.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;&amp;lt;!-- 添加web依赖 ，包含spring和springmvc等--&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;&amp;lt;!-- 添加对jpa的支持，包含spring-data和Hibernate --&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;&amp;lt;!-- mysql连接的jar包 --&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;&amp;lt;!-- 因为SpringBoot内嵌的tomcat不支持jsp页面，同时SpringBoot也不推荐用jsp --&amp;gt;
           &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
           &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;
           &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;&amp;lt;!-- jsp标签库 --&amp;gt;
           &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
           &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;&amp;lt;!-- SpringBoot 编译插件 --&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;细心的同学会发现该文件中出现大量的 spring-boot-starter-* 的语句。SpringBoot之所以能简化开发的秘密就在这里------ Starter pom&lt;br/&gt;&lt;strong&gt;spring-boot-starter-parent&lt;/strong&gt; ：父级依赖，SpringBoot项目的标志。里面封装了很多jar的版本&lt;br/&gt;&lt;strong&gt;spring-boot-starter-web&lt;/strong&gt; ：对web项目的支持，其中包含了SpringMVC和tomcat&lt;br/&gt;&lt;strong&gt;spring-boot-starter-data-jpa&lt;/strong&gt; ：对JPA的支持，其中包含了常用的SpringData和Hibernate，没有Mybatis哦&lt;br/&gt;&lt;strong&gt;spring-boot-starter-tomcat&lt;/strong&gt; ：使用tomcat作为Servlet容器&lt;br/&gt;&lt;strong&gt;spring-boot-starter-test&lt;/strong&gt; ：对常用测试框架的支持，如JUnit&lt;br/&gt;还有很多......&lt;/p&gt;
&lt;h3 id=&quot;配置全局文件&quot;&gt;配置全局文件&lt;/h3&gt;
&lt;p&gt;再看看SpringBoot项目全局配置文件 application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 配置tomcat端口号
server.port=8081

# 配置SpringMVC视图解析器
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

# 配置连接池，默认使用的是tomcat的连接池，但实际很少用tomcat的连接池
spring.datasource.url=jdbc:mysql://localhost:3306/jpa?useUnicode=true&amp;amp;characterEncoding=UTF8
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
# 配置方言 否则提示：Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set
spring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect
# 自动更新数据库表结构，也可以是 validate | update | create | create-drop
spring.jpa.properties.hibernate.hbm2ddl.auto=update
# 显示sql语句
spring.jpa.show-sql=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全局配置文件可以是application.properties 也可以是 application.yml，建议放在resources目录下。更多配置: &lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/blob/master/SpringBoot/SpringData/springbootStudy/src/main/resources/springboot.properties&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/blob/master/SpringBoot/SpringData/springbootStudy/src/main/resources/springboot.properties&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;核心注解&quot;&gt;核心注解&lt;/h3&gt;
&lt;p&gt;最后是SpringBoot HelloWorld项目的入口类，只需要下面一个java文件，执行main方法，即可实现页面的跳转和数据返回的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@SpringBootApplication
public class SpringbootStudyApplication {
    
    @RequestMapping(&quot;/&quot;)
    public String index() {
        return &quot;index&quot;;
    }
    
    @RequestMapping(&quot;hello&quot;)
    @ResponseBody
    public String helloWorld() {
        return &quot;Hello SpringBoot !&quot;;
    }

    public static void main(String[] args) {
        SpringApplication.run(SpringbootStudyApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@SpringBootApplication：是 SpringBoot 的核心注解，一般用在入口类上。它是一个组合注解，其中主要内容有一下三个&lt;br/&gt;@SpringBootConfiguration：是一个类级注释，指示对象是一个bean定义的源，可以理解为xml中的beans，一般和 @Bean 注解一起使用。&lt;br/&gt;@EnableAutoConfiguration：启用 Spring 应用程序上下文的自动配置，试图猜测和配置您可能需要的bean。自动配置类通常采用基于你的 classpath 和已经定义的 beans 对象进行应用。&lt;br/&gt;@ComponentScan：该注解会自动扫描指定包下的全部标有 @Component、@Service、@Repository、@Controller注解 的类，并注册成bean&lt;/p&gt;
&lt;p&gt;SpringData入口类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StartApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(StartApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;springdatajpa-知识&quot;&gt;SpringDataJPA 知识&lt;/h2&gt;
&lt;p&gt;SpringData 是一个用于简化数据库访问，并支持云服务的开源框架。支持非关系型数据库(NoSQL) 和 关系型数据库。其主要目的是使数据库的访问变得方便快捷。&lt;br/&gt;SpringData JPA 是由Spring提供的简化JPA开发的框架，致力于减少数据访问层的开发量。&lt;/p&gt;
&lt;h3 id=&quot;pojo层&quot;&gt;POJO层&lt;/h3&gt;
&lt;p&gt;创建实体类User 表，对应数据库表名是 itdragon_user，id作为自增长的主键，plainPassword是不保存到数据库的明文密码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Transient;

/**
 * 用户实体类
 * @author itdragon
 *
 */
@Table(name=&quot;itdragon_user&quot;)
@Entity
public class User {
    
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;                        // 自增长主键
    private String account;                 // 登录的账号
    private String userName;                // 注册的昵称
    @Transient
    private String plainPassword;           // 登录时的密码，不持久化到数据库
    private String password;                // 加密后的密码
    private String salt;                    // 用于加密的盐
    private String iphone;                  // 手机号
    private String email;                   // 邮箱
    private String platform;                // 用户来自的平台
    private String createdDate;             // 用户注册时间
    private String updatedDate;             // 用户最后一次登录时间
    
    // 省略get/set/toString 方法
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;repository接口层&quot;&gt;Repository接口层&lt;/h3&gt;
&lt;p&gt;创建UserRepository，这是SpringData 的核心知识点，我们先看代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.List;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.repository.query.Param;
import com.itdragon.pojo.User;

/**
 * 核心知识：SpringData Repository 接口
 * 
 * CrudRepository 接口提供了最基本的对实体类的添删改查操作 
 * - T save(T entity);                  //保存单个实体 
 * - T findOne(ID id);                  // 根据id查找实体         
 * - void delete(ID/T/Iterable);        // 根据Id删除实体，删除实体，批量删除 
 * PagingAndSortingRepository 提供了分页与排序功能
 * - &amp;lt;T, ID extends Serializable&amp;gt;           // 第一个参数传实体类，第二个参数传注解数据类型
 * - Iterable&amp;lt;T&amp;gt; findAll(Sort sort);        // 排序 
 * - Page&amp;lt;T&amp;gt; findAll(Pageable pageable);    // 分页查询（含排序功能）
 * JpaSpecificationExecutor 提供了Specification(封装 JPA Criteria查询条件)的查询功能
 * - List&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec);
 * - Page&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec, Pageable pageable);
 * - List&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; spec, Sort sort);
 * 
 * 开发建议
 * 1. 这里值列出的是常用方法
 * 2. CrudRepository 中的findAll() 方法要慎用。当数据库中数据量大，多线程脚本调用findAll方法，系统可能会宕机。
 * 3. CrudRepository 中的deletAll()方法要慎用。这是物理删除，现在企业一般采用逻辑删除。
 * 4. PagingAndSortingRepository 和 JpaSpecificationExecutor 能满足大部分业务需求。
 */
public interface UserRepository extends PagingAndSortingRepository&amp;lt;User, Long&amp;gt;, 
    JpaSpecificationExecutor&amp;lt;User&amp;gt;{
    
    /**
     * 重点知识：SpringData 查询方法定义规范
     * 
     * 1. 查询方法名一般以 find | read | get 开头，建议用find
     *  findByAccount : 通过account查询User
     *  account是User的属性，拼接时首字母需大写
     * 2. 支持的关键词有很多比如 Or,Between,isNull,Like,In等
     *  findByEmailEndingWithAndCreatedDateLessThan : 查询在指定时间前注册，并以xx邮箱结尾的用户
     *  And : 并且
     *  EndingWith : 以某某结尾
     *  LessThan : 小于
     * 
     * 注意
     * 若有User(用户表) Platform(用户平台表) 存在一对一的关系，且User表中有platformId字段
     * SpringData 为了区分：
     * findByPlatFormId     表示通过platformId字段查询
     * findByPlatForm_Id    表示通过platform实体类中id字段查询
     * 
     * 开发建议
     * 表的设计，尽量做单表查询，以确保高并发场景减轻数据库的压力。
     */
    
    // 1 通过账号查用户信息
    User findByAccount(String account);
    // 2 获取指定时间内以xx邮箱结尾的用户信息
    List&amp;lt;User&amp;gt; findByEmailEndingWithAndCreatedDateLessThan(String email, String createdDate);

    /**
     * 重点知识：使用 @Query 注解
     * 
     * 上面的方法虽然简单(不用写sql语句)，但它有最为致命的问题-----不支持复杂查询，其次是命名太长
     * 1. 使用@Query 注解实现复杂查询，设置 nativeQuery=true 使查询支持原生sql
     * 2. 配合@Modifying 注解实现创建，修改，删除操作
     * 3. SpringData 默认查询事件为只读事务，若要修改数据则需手动添加事务注解
     * 
     * 注意
     * 若@Query 中有多个参数，SpringData 提供两种方法：
     * 第一种 ?1 ... ?2        要求参数顺序一致
     * 第二种 :xxx ... :yyy    xxx 和 yyy 必须是实体类对应的属性值，不要求参数顺序但参数前要加上@Param(&quot;xxx&quot;)
     * 模糊查询可使用 %xxx%
     * 
     * 开发建议
     * 1. 参数填写的顺序要保持一致，不要给自己添加麻烦
     * 2. 建议使用@Query，可读性较高
     */
    // 3 获取某平台活跃用户数量
    @Query(value=&quot;SELECT count(u.id) FROM User u WHERE u.platform = :platform AND u.updatedDate &amp;lt;= :updatedDate&quot;)
    long getActiveUserCount(@Param(&quot;platform&quot;)String platform, @Param(&quot;updatedDate&quot;)String updatedDate);
    
    // 4 通过邮箱或者手机号模糊查询用户信息
    @Query(value=&quot;SELECT u FROM User u WHERE u.email LIKE %?1% OR u.iphone LIKE %?2%&quot;)
    List&amp;lt;User&amp;gt; findByEmailAndIhpneLike(String email, String iphone);
    
    // 5 修改用户邮箱
    @Modifying
    @Query(&quot;UPDATE User u SET u.email = :email WHERE u.id = :id&quot;)
    void updateUserEmail(@Param(&quot;id&quot;) Long id, @Param(&quot;email&quot;) String email);
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中共有五个方法，每个方法都包含了很多的知识点。&lt;br/&gt;方法一和方法二主要介绍的是SpringData关键字的用法。&lt;br/&gt;1 &lt;strong&gt;关键字的解析&lt;/strong&gt;&lt;br/&gt;这里用findByPlatFormId() 方法来介绍SpringData 解析查询方法的流程。&lt;br/&gt;第一步：去除关键字findBy&lt;br/&gt;第二步：剩下的PlatFormId 首字母小写并在User对象中找是否有该属性，若有则查询并结束。若没有则第三步&lt;br/&gt;第三步：platFormId，从右到左截取到第一个大写字母，再判断剩下的platForm是否为User对象，如此循环直到结束为止。&lt;br/&gt;2 &lt;strong&gt;级联属性区分&lt;/strong&gt;&lt;br/&gt;若查询的属性是实体类，为了避免误会和冲突，用&quot;_&quot;表示属性中的属性&lt;br/&gt;3 &lt;strong&gt;查询分页排序&lt;/strong&gt;&lt;br/&gt;若findByPlatFormId() 方法想要排序或者分页，是可以在后面加Pageable，Sort参数。&lt;br/&gt;findByPlatFormId(String platFormId, Pageable pageable)&lt;br/&gt;findByPlatFormId(String platFormId, Sort sort)&lt;br/&gt;4 &lt;strong&gt;其他的关键字&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201712/806956-20171216201221139-477023651.png&quot; alt=&quot;关键字&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法三到方法五主要介绍的是 @Query 注解的使用。&lt;br/&gt;1 &lt;strong&gt;传参方式&lt;/strong&gt;&lt;br/&gt;索引参数：?n ，n从1开始，表示第一个参数。方法传入的参数的照顺序和个数要和 n 保持一致。&lt;br/&gt;命名参数：:key ，传参必须有 @Param(&quot;key&quot;) 注解修饰&lt;br/&gt;2 &lt;strong&gt;原生的sql&lt;/strong&gt;&lt;br/&gt;@Query 注解支持本地查询，即用原生的sql语句。如：@Query(value=&quot;xxxx&quot;, nativeQuery=true)&lt;br/&gt;3 &lt;strong&gt;Modifying&lt;/strong&gt;&lt;br/&gt;若直接执行修改操作，SpringDataJPA 会提示错误信息 Executing an update/delete query 。是因为Spring Data 默认所有的查询均声明为只读事务。&lt;br/&gt;所以我们要在Service层添加 @Transactional 注解。&lt;/p&gt;
&lt;p&gt;SpringDataJPA 核心知识Repository接口&lt;br/&gt;1 &lt;strong&gt;Repository&lt;/strong&gt;: 空接口，标识作用，表明任何继承它的均为Repository接口类&lt;br/&gt;2 &lt;strong&gt;CrudRepository&lt;/strong&gt;: 继承 Repository，实现了一组 CRUD 相关的方法 &lt;br/&gt;3 &lt;strong&gt;PagingAndSortingRepository&lt;/strong&gt;: 继承 CrudRepository，实现了一组分页排序相关的方法&lt;br/&gt;4 &lt;strong&gt;JpaRepository&lt;/strong&gt;： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法&lt;br/&gt;5 &lt;strong&gt;JpaSpecificationExecutor&lt;/strong&gt;: 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法 &lt;br/&gt;PagingAndSortingRepository 和 JpaSpecificationExecutor 基本满足企业中大部分的需求。也可以自定义Repository，只需继承 JpaRepository 即可具备了通用的数据访问控制层的能力。&lt;br/&gt;进入各自接口类中，使用快捷键 Ctrl + o 即可查看当前类的所有方法，所以这里就不贴出来了。&lt;/p&gt;
&lt;h3 id=&quot;service层&quot;&gt;Service层&lt;/h3&gt;
&lt;p&gt;创建UserService 并加上注解 @Transactional&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import javax.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.itdragon.common.ItdragonResult;
import com.itdragon.pojo.User;
import com.itdragon.repository.UserRepository;

@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public ItdragonResult registerUser(User user) {
        // 检查用户名是否注册，一般在前端验证的时候处理，因为注册不存在高并发的情况，这里再加一层查询是不影响性能的
        if (null != userRepository.findByAccount(user.getAccount())) {
            return ItdragonResult.build(400, &quot;&quot;);
        }
        userRepository.save(user);
        // 注册成功后选择发送邮件激活。现在一般都是短信验证码
        return ItdragonResult.build(200, &quot;&quot;);
    }
    
    public ItdragonResult editUserEmail(String email) {
        // 通过Session 获取用户信息, 这里假装从Session中获取了用户的id，后面讲解SOA面向服务架构中的单点登录系统时，修改此处代码 FIXME
        long id = 3L;
        // 添加一些验证，比如短信验证
        userRepository.updateUserEmail(id, email);
        return ItdragonResult.ok();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;
&lt;p&gt;SpringBoot 的单元测试，需要用到 @RunWith 和 @SpringBootTest注解，代码注释中有详细介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.List;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.test.context.junit4.SpringRunner;
import com.itdragon.StartApplication;
import com.itdragon.common.ItdragonUtils;
import com.itdragon.pojo.User;
import com.itdragon.repository.UserRepository;
import com.itdragon.service.UserService;

/**
 * @RunWith 它是一个运行器
 * @RunWith(SpringRunner.class) 表示让测试运行于Spring测试环境，不用启动spring容器即可使用Spring环境
 * @SpringBootTest(classes=StartApplication.class)  表示将StartApplication.class纳入到测试环境中，若不加这个则提示bean找不到。
 * 
 * @author itdragon
 *
 */
@RunWith(SpringRunner.class)
@SpringBootTest(classes=StartApplication.class)
public class SpringbootStudyApplicationTests {
    
    @Autowired
    private UserService userService;
    @Autowired
    private UserRepository userRepository;

    @Test
    public void contextLoads() {
    }
    
    @Test   // 测试注册，新增数据
    public void registerUser() {
        User user = new User();
        user.setAccount(&quot;gitLiu&quot;);
        user.setUserName(&quot;ITDragonGit&quot;);
        user.setEmail(&quot;itdragon@git.com&quot;);
        user.setIphone(&quot;12349857999&quot;);
        user.setPlainPassword(&quot;adminroot&quot;);
        user.setPlatform(&quot;github&quot;);
        user.setCreatedDate(ItdragonUtils.getCurrentDateTime());
        user.setUpdatedDate(ItdragonUtils.getCurrentDateTime());
        ItdragonUtils.entryptPassword(user);
        userService.registerUser(user);
    }
    
    @Test   // 测试SpringData 关键字
    public void findByEmailEndingWithAndCreatedDateLessThan() {
        List&amp;lt;User&amp;gt; users = userRepository.findByEmailEndingWithAndCreatedDateLessThan(&quot;qq.com&quot;, ItdragonUtils.getCurrentDateTime());
        System.out.println(users.toString());
    }
    
    @Test   // 测试SpringData @Query 注解和传多个参数
    public void getActiveUserCount() {
        long activeUserCount = userRepository.getActiveUserCount(&quot;weixin&quot;, ItdragonUtils.getCurrentDateTime());
        System.out.println(activeUserCount);
    }
    
    @Test   // 测试SpringData @Query 注解，传多个参数 和 like 查询
    public void findByEmailAndIhpneLike() {
        List&amp;lt;User&amp;gt; users = userRepository.findByEmailAndIhpneLike(&quot;163.com&quot;, &quot;6666&quot;);
        System.out.println(users.toString());
    }
    
    @Test   // 测试SpringData @Query 注解 和 @Modifying 注解
    public void updateUserEmail() {
        /**
         * org.springframework.dao.InvalidDataAccessApiUsageException:Executing an update/delete query; nested exception is javax.persistence.TransactionRequiredException: Executing an update/delete query
         * userRepository.updateUserEmail(3L, &quot;update@email.com&quot;);
         */
        userService.editUserEmail(&quot;update@email.com&quot;);
    }
    
    @Test   // 测试SpringData PagingAndSortingRepository 接口
    public void testPagingAndSortingRepository() {
        int page = 1;   // 从0开始，第二页
        int size = 3;   // 每页三天数据
        PageRequest pageable = new PageRequest(page, size, new Sort(new Order(Direction.ASC, &quot;id&quot;)));
        Page&amp;lt;User&amp;gt; users = userRepository.findAll(pageable);
        System.out.println(users.getContent().toString()); // 当前数据库中有5条数据，正常情况可以打印两条数据，id分别为4，5 (先排序，后分页)
    }
    
    @Test   // 测试SpringData JpaSpecificationExecutor 接口
    public void testJpaSpecificationExecutor(){
        int pageNo = 1;
        int pageSize = 3;
        PageRequest pageable = new PageRequest(pageNo, pageSize);
        Specification&amp;lt;User&amp;gt; specification = new Specification&amp;lt;User&amp;gt;() {
            @Override
            public Predicate toPredicate(Root&amp;lt;User&amp;gt; root,
                    CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder cb) {
                Predicate predicate = cb.gt(root.get(&quot;id&quot;), 1); // 查询id 大于 1的数据
                return predicate;
            }
        };
        Page&amp;lt;User&amp;gt; users = userRepository.findAll(specification, pageable);
        System.out.println(users.getContent().toString());  // 当前数据库中有5条数据，正常情况可以打印一条数据，id为5
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可能存在的问题&quot;&gt;可能存在的问题&lt;/h2&gt;
&lt;h4 id=&quot;项目启动时提示-unknown-character-set-utf8mb4&quot;&gt;项目启动时提示 Unknown character set: 'utf8mb4'&lt;/h4&gt;
&lt;p&gt;导致的原因可能是mysql服务器版本安装不正确，解决方法有两种。&lt;br/&gt;第一种：换mysql-connector-java jar包版本为 5.1.6 (不推荐)； 当前jar版本为 5.1.44。&lt;br/&gt;第二种：重装mysql版本，当前最新版本是5.7。教程都准备好了。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/sshoub/p/4321640.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/sshoub/p/4321640.html&lt;/a&gt; (mysql安装)&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/y694721975/article/details/52981377&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/y694721975/article/details/52981377&lt;/a&gt; (mysql卸载)&lt;/p&gt;
&lt;h4 id=&quot;springboot-连接池配置疑惑&quot;&gt;SpringBoot 连接池配置疑惑&lt;/h4&gt;
&lt;p&gt;我们只是在全局配置文件中设置了相关值，就完成了连接池的配置，想必大家都有所疑惑。其实当我们在pom.xml文件中加入spring-boot-starter-data-jpa 依赖时，SpringBoot就会自动使用tomcat-jdbc连接池。&lt;br/&gt;当然我们也可以使用其他的连接池。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gslblog/p/7169481.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/gslblog/p/7169481.html&lt;/a&gt; (springBoot数据库连接池常用配置)&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaosiyuan/p/6255292.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/xiaosiyuan/p/6255292.html&lt;/a&gt; (SpringBoot使用c3p0)&lt;/p&gt;
&lt;h4 id=&quot;sts工具-ctrl-shift-o-重新导包快捷键失效&quot;&gt;STS工具 ctrl + shift + o 重新导包快捷键失效&lt;/h4&gt;
&lt;p&gt;解决方法：preference -&amp;gt; general -&amp;gt; keys ,找到 Organize Imports ,然后 在 When 里面选择 Editing Java Source&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1 SpringDataJPA 是简化JPA开发的框架，SpringBoot是简化项目开发的框架。&lt;br/&gt;2 spring-boot-starter-parent 是SpringBoot项目的标志&lt;br/&gt;3 SpringBootApplication 注解是SpringBoot项目的入口&lt;br/&gt;4 SpringData 通过查询关键字和 @Query注解实现对数据库的访问&lt;br/&gt;5 SpringData 通过PagingAndSortingRepository 实现分页，排序和常用的crud操作&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/SpringData&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/SpringData&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里 SpringData 基于SpringBoot快速入门就结束了，如果有什么问题请指教，如果觉得不错可以点一下推荐。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 12:50:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/8047132.html</dc:identifier>
</item>
<item>
<title>【机器学习】RNN学习 - 水奈樾</title>
<link>http://www.cnblogs.com/rucwxb/p/8047401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rucwxb/p/8047401.html</guid>
<description>&lt;p&gt;&lt;span&gt;感谢中国人民大学的胡鹤老师，课程容量巨大，收获颇丰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前提到的CNN模型主要用到人类的视觉中枢，但其有一劣势，无论是人类的视觉神经还是听觉神经，所接受到的都是一个连续的序列，使用CNN相当于割裂了前后的联系。从而诞生了专门为处理序列的Recurrent Neural Network（RNN），每一个神经元除了当前信息的输入外，还有之前产生的记忆信息，保留序列依赖型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、RNN基本原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示有两种表示方法，每张图片左边是RNN的神经元（称为memory cell），右边是按时间轴展开后的情况。每次输入两个信息输出两个信息，每轮处理hidden state。把同样神经元在时间上展开处理，比CNN更加节省参数，是一个相当高效的表示方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171211081541756-1232768737.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171211081751818-669616273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可参考如下公式表示，最后简化后的形式同一般神经元相同，输入信息乘权重加偏值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171211082028756-2120760154.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于t状态的t由t-1时候决定，因而具有记忆功能，也叫作memory cell（或cell）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;隐状态可由如下表示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171211082434006-1885352676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;隐状态是当前t时刻的状态，也由t-1时刻决定，简单情况下，hidden state等同于output（y），但大多较为复杂的cell中，它们并不相同。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216130908137-1268466415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、RNN种类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. sequence-to-sequence：&lt;/span&gt;输入输出都是一个序列。例如股票预测中的RNN，输入是前N天价格，输出明天的股市价格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171211084622490-1828165372.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2. sequence-to-vector：&lt;/span&gt;输入是一个序列，输出单一向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如，输入一个电影评价序列，输出一个分数表示情感趋势（喜欢还是讨厌）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216131758762-2043854341.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3. vector-to-sequence：&lt;/span&gt;输入单一向量，输出一个序列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216131816887-877494752.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4.Encoder-Decoder：&lt;/span&gt;输入sequence-to-vector，称作encoder，输出vector-to-sequence，称作decoder。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个delay模型，经过一段延迟，即把所有输入都读取后，在decoder中获取输入并输出一个序列。这个模型在机器翻译中使用较广泛，源语言输在入放入encoder，浓缩在状态信息中，生成目标语言时，可以生成一个不长度的目标语言序列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171211084549302-2078649370.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;三、RNN实例&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.手动实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是一个手动实现RNN的实例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
n_inputs = 3
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; hidden state &lt;/span&gt;
n_neurons = 5&lt;span&gt;

X0 &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_inputs])
X1 &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_inputs])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 由于Wx要和X相乘，故低维是n_inputs&lt;/span&gt;
Wx = tf.Variable(tf.random_normal(shape=[n_inputs, n_neurons],dtype=&lt;span&gt;tf.float32))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 低维，高维都是n_neurons，为了使得输出也是hidden state的深度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 这样下一次才可以继续运算&lt;/span&gt;
Wy = tf.Variable(tf.random_normal(shape=[n_neurons,n_neurons],dtype=&lt;span&gt;tf.float32))
b &lt;/span&gt;= tf.Variable(tf.zeros([1, n_neurons], dtype=&lt;span&gt;tf.float32))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Y0初始化为0，初始时没有记忆&lt;/span&gt;
Y0 = tf.tanh(tf.matmul(X0, Wx) +&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把上一轮输出Y0也作为输入&lt;/span&gt;
Y1 = tf.tanh(tf.matmul(Y0, Wy) + tf.matmul(X1, Wx) +&lt;span&gt; b)
init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
X0_batch &lt;/span&gt;= np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 0, 1]]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; t = 0 &lt;/span&gt;
X1_batch = np.array([[9, 8, 7], [0, 0, 0], [6, 5, 4], [3, 2, 1]]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; t = 1  &lt;/span&gt;
&lt;span&gt;with tf.Session() as sess:
　　init.run()
　　Y0_val, Y1_val &lt;/span&gt;= sess.run([Y0, Y1], feed_dict=&lt;span&gt;{X0: X0_batch, X1: X1_batch}) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Y0，Y1都是4*5大小，4是mini-batch数目，5是输出神经元个数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;TensorFlow函数集成后实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.static unrolling through time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;static_rnn()是使用链式cells实现一个按时间轴展开的RNN&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这种和上面那种手动实现的效果相同&lt;/span&gt;
n_inputs = 3&lt;span&gt;
n_neurons &lt;/span&gt;= 5&lt;span&gt;
X0 &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_inputs])
X1 &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_inputs])

basic_cell &lt;/span&gt;= tf.contrib.rnn.BasicRNNCell(num_units=&lt;span&gt;n_neurons)
output_seqs, states &lt;/span&gt;= tf.contrib.rnn.static_rnn(basic_cell, [X0, X1], dtype=&lt;span&gt;tf.float32)
Y0, Y1 &lt;/span&gt;=&lt;span&gt; output_seqs
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; run部分&lt;/span&gt;
init =&lt;span&gt; tf.global_variables_initializer()
X0_batch &lt;/span&gt;= np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 0, 1&lt;span&gt;]])
X1_batch &lt;/span&gt;= np.array([[9, 8, 7], [0, 0, 0], [6, 5, 4], [3, 2, 1&lt;span&gt;]])

with tf.Session() as sess:
    init.run()
    Y0_val, Y1_val &lt;/span&gt;= sess.run([Y0, Y1], feed_dict={X0: X0_batch, X1: X1_batch})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;packing sequence&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
n_steps = 2&lt;span&gt;
n_inputs &lt;/span&gt;= 3&lt;span&gt;
n_neurons &lt;/span&gt;= 5
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入是一个三维tensor，none是mini-batch大小不限，n_steps是序列长度&lt;/span&gt;
X =&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把一个高维度n的tensor展开成一个n-1维，降维，这里是3位降到2维列表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; unstack之前要做一个1,2维转置，相当于构造了n_steps个数的列表&lt;/span&gt;
X_seqs = tf.unstack(tf.transpose(X, perm=[1, 0, 2&lt;span&gt;]))
basic_cell &lt;/span&gt;= tf.contrib.rnn.BasicRNNCell(num_units=&lt;span&gt;n_neurons)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; states是最新状态&lt;/span&gt;
output_seqs, states = tf.contrib.rnn.static_rnn( basic_cell, X_seqs, dtype=&lt;span&gt;tf.float32) 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再做一个转置，和输入对应 &lt;/span&gt;
outputs = tf.transpose(tf.stack(output_seqs), perm=[1, 0, 2&lt;span&gt;]) 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入大小4*2*3 &lt;/span&gt;
X_batch =&lt;span&gt; np.array([ 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; t = 0　　　　 t = 1 &lt;/span&gt;
[[0, 1, 2], [9, 8, 7]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 0 &lt;/span&gt;
[[3, 4, 5], [0, 0, 0]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 1 &lt;/span&gt;
[[6, 7, 8], [6, 5, 4]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 2 &lt;/span&gt;
[[9, 0, 1], [3, 2, 1]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 3 &lt;/span&gt;
&lt;span&gt;]) 
with tf.Session() as sess:
 init.run()
 outputs_val &lt;/span&gt;= outputs.eval(feed_dict=&lt;span&gt;{X: X_batch})
 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; output_val是一个4*2*5，仅输出维度神经元个数改变&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. dynamic RNN&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本身支持高维tensor输入，内嵌一个循环运行足够多次数的cell，不需要unstack步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个内嵌循环while_loop()在前向传播中将每次迭代的tensor值存储下来，以便于反向传播过程中使用其计算梯度值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
X =&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 动态RNN内部封装一个循环&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 根据输入，动态决定自己需要展开几次&lt;/span&gt;
basic_cell = tf.contrib.rnn.BasicRNNCell(num_units=&lt;span&gt;n_neurons)
outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(basic_cell, X, dtype=tf.float32)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;dynamicRNN可以动态规定输入大小（就像句子输入）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
n_steps = 2&lt;span&gt;
n_inputs &lt;/span&gt;= 3&lt;span&gt;
n_neurons &lt;/span&gt;= 5&lt;span&gt;

X &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
basic_cell &lt;/span&gt;= tf.contrib.rnn.BasicRNNCell(num_units=&lt;span&gt;n_neurons)
seq_length &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32, [None])
outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(basic_cell, X, dtype=tf.float32, sequence_length=&lt;span&gt;seq_length)
init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; X_batch的大小4*2*3&lt;/span&gt;
X_batch =&lt;span&gt; np.array([
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; step 0     step 1&lt;/span&gt;
        [[0, 1, 2], [9, 8, 7]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 1&lt;/span&gt;
        [[3, 4, 5], [0, 0, 0]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 2 (padded with zero vectors)&lt;/span&gt;
        [[6, 7, 8], [6, 5, 4]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 3&lt;/span&gt;
        [[9, 0, 1], [3, 2, 1]], &lt;span&gt;#&lt;/span&gt;&lt;span&gt; instance 4&lt;/span&gt;
&lt;span&gt;    ])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里设置sequence大小，一共4个batch，第二维上只取第一个&lt;/span&gt;
seq_length_batch = np.array([2, 1, 2, 2&lt;span&gt;])
with tf.Session() as sess:
    init.run()
    outputs_val, states_val &lt;/span&gt;=&lt;span&gt; sess.run(
        [outputs, states], feed_dict&lt;/span&gt;={X: X_batch, seq_length: seq_length_batch})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;如果事先不知道输出序列的长度，就需要定义一个end-of-sequence token（eos token），无论是课上还是网上相关信息都很少，这里就不展开了。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、RNN训练&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 拟合分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RNN比较难以训练，单是如下图的节点中，cost function就包含y2,y3,y4三个输出，往回回溯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216162519921-728949656.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下MINIST中使用150个RNN神经元，最后加一个全连接层，得到10个神经元的输出（分别对应0-9），最后看对应在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216162812718-28341611.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; fully_connected
n_steps &lt;/span&gt;= 28&lt;span&gt;
n_inputs &lt;/span&gt;= 28&lt;span&gt;
n_neurons &lt;/span&gt;= 150&lt;span&gt;
n_outputs &lt;/span&gt;= 10&lt;span&gt;
learning_rate &lt;/span&gt;= 0.001&lt;span&gt;

X &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一维输出&lt;/span&gt;
y =&lt;span&gt; tf.placeholder(tf.int32, [None])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用最简单的basicRNNcell&lt;/span&gt;
basic_cell = tf.contrib.rnn.BasicRNNCell(num_units=&lt;span&gt;n_neurons)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用dynamic_rnn&lt;/span&gt;
outputs, states = tf.nn.dynamic_rnn(basic_cell, X, dtype=&lt;span&gt;tf.float32)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 原始输出&lt;/span&gt;
logits = fully_connected(states, n_outputs, activation_fn=&lt;span&gt;None)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算和真实的交叉熵&lt;/span&gt;
xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=&lt;span&gt;logits)
loss &lt;/span&gt;=&lt;span&gt; tf.reduce_mean(xentropy)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用AdamOptimizer&lt;/span&gt;
optimizer = tf.train.AdamOptimizer(learning_rate=&lt;span&gt;learning_rate)
training_op &lt;/span&gt;=&lt;span&gt; optimizer.minimize(loss)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算准确率，只有等于y才是对的，其他都错&lt;/span&gt;
correct = tf.nn.in_top_k(logits, y, 1&lt;span&gt;)
accuracy &lt;/span&gt;=&lt;span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))
init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span&gt;import&lt;/span&gt;&lt;span&gt; input_data
mnist &lt;/span&gt;= input_data.read_data_sets(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tmp/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换到合理的输入shape&lt;/span&gt;
X_test = mnist.test.images.reshape((-1&lt;span&gt;, n_steps, n_inputs))
y_test &lt;/span&gt;=&lt;span&gt; mnist.test.labels
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; run100遍，每次处理150个输入&lt;/span&gt;
n_epochs = 100&lt;span&gt;
batch_size &lt;/span&gt;= 150
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始循环&lt;/span&gt;
&lt;span&gt;with tf.Session() as sess:
    init.run()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; epoch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_epochs):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; iteration &lt;span&gt;in&lt;/span&gt; range(mnist.train.num_examples //&lt;span&gt; batch_size):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读入数据并reshape&lt;/span&gt;
            X_batch, y_batch =&lt;span&gt; mnist.train.next_batch(batch_size)
            X_batch &lt;/span&gt;= X_batch.reshape((-1&lt;span&gt;, n_steps, n_inputs))
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; X大写，y小写&lt;/span&gt;
            sess.run(training_op, feed_dict=&lt;span&gt;{X: X_batch, y: y_batch})
        acc_train &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_batch, y: y_batch})
        acc_test &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_test, y: y_test})
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次打印一下当前信息&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(epoch, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Train accuracy:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, acc_train, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test accuracy:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, acc_test)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以下，只用了150个参数，做了单层。就可以达到非常高的效果，可以看出rnn效果非常不错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216163539358-837123545.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;序列预测，前20个状态作为输入，则第2个到21个作为输出，作为训练集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216163721827-979753452.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入x0-x19&lt;/span&gt;
n_steps = 20
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只预测一个值&lt;/span&gt;
n_inputs = 1
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rnn有100个&lt;/span&gt;
n_neurons = 100&lt;span&gt;
n_outputs &lt;/span&gt;= 1
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; none表示min_batch大小这里任意&lt;/span&gt;
X =&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
y &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_outputs])
cell &lt;/span&gt;= tf.contrib.rnn.BasicRNNCell(num_units=n_neurons, activation=&lt;span&gt;tf.nn.relu)
outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(cell, X, dtype=tf.float32)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如上代码中，每次输出的vector都是100维的，加入一个output rejections后，使得每次只输出1个值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216164151077-743435083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;output rejection实现代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置输出为上面设定的n_outputs大小&lt;/span&gt;
cell =&lt;span&gt; tf.contrib.rnn.OutputProjectionWrapper(
     tf.contrib.rnn.BasicRNNCell(num_units&lt;/span&gt;=n_neurons, activation=tf.nn.relu), output_size=&lt;span&gt;n_outputs)

learning_rate &lt;/span&gt;= 0.001&lt;span&gt;
loss &lt;/span&gt;= tf.reduce_mean(tf.square(outputs -&lt;span&gt; y))
optimizer &lt;/span&gt;= tf.train.AdamOptimizer(learning_rate=&lt;span&gt;learning_rate)
training_op &lt;/span&gt;=&lt;span&gt; optimizer.minimize(loss)
init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始训练&lt;/span&gt;
n_iterations = 10000&lt;span&gt;
batch_size &lt;/span&gt;= 50&lt;span&gt;
with tf.Session() as sess:
    init.run()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; iteration &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_iterations):
        X_batch, y_batch &lt;/span&gt;= [...] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; fetch the next training batch&lt;/span&gt;
        sess.run(training_op, feed_dict=&lt;span&gt;{X: X_batch, y: y_batch})
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; iteration % 100 ==&lt;span&gt; 0:
            mse &lt;/span&gt;= loss.eval(feed_dict=&lt;span&gt;{X: X_batch, y: y_batch})
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(iteration, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\tMSE:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, mse)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 2.预测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个RNN训练好后，它就可以生成很多新的东西。RNN的强大的生成能力非常有魅力，用很多曲子去训练它，它就可以生成新的曲子，用很多文章训练它，他就可以生成新的文章。如果可以训练出功能非常强的RNN模型，就有可能代替人的工作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;with tf.Session() as sess:                  
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入训练好的模型&lt;/span&gt;
    saver.restore(sess, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./my_time_series_model&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成新的曲线&lt;/span&gt;
    sequence = [0.] *&lt;span&gt; n_steps
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; iteration &lt;span&gt;in&lt;/span&gt; range(300&lt;span&gt;):
        X_batch &lt;/span&gt;= np.array(sequence[-n_steps:]).reshape(1, n_steps, 1&lt;span&gt;)
        y_pred &lt;/span&gt;= sess.run(outputs, feed_dict=&lt;span&gt;{X: X_batch})
        sequence.append(y_pred[0, &lt;/span&gt;-1, 0])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216165531983-633677144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RNN也可以不断叠加，形成很深的网络，如下图所示，每一层输出都反馈到当前位置的输入，时间轴展开后，如右边所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216165606436-593835078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
n_inputs = 2&lt;span&gt;
n_steps &lt;/span&gt;= 5&lt;span&gt;

X &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
n_neurons &lt;/span&gt;= 100&lt;span&gt;
n_layers &lt;/span&gt;= 3 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 做了3层rnn&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 模型不是越复杂越好，越复杂所需数据量越大，否则会有过拟合的风险&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 可以加dropout来控制&lt;/span&gt;
layers = [tf.contrib.rnn.BasicRNNCell(num_units=&lt;span&gt;n_neurons)
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
multi_layer_cell &lt;/span&gt;=&lt;span&gt; tf.contrib.rnn.MultiRNNCell(layers)
outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_layer_cell, X, dtype=&lt;span&gt;tf.float32)
init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()
X_batch &lt;/span&gt;= np.random.rand(2&lt;span&gt;, n_steps, n_inputs)
with tf.Session() as sess:
    init.run()
    outputs_val, states_val &lt;/span&gt;= sess.run([outputs, states], feed_dict={X: X_batch})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;五、困难及优化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反向训练时，对于RNN来说，要横向往前推，一直往前推到序列开始的地方。当序列非常长时，梯度消失，梯度爆炸都与路径长度太长有关，前面的权重都基本固定不变，没有训练效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这个困难，有了很多更复杂RNN模型的提出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.LSTM（Long Short Term Memory）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;97年提出，直到深度学习提出，使用LSTM做出具体实事后，才火起来。或许是因为现在有大数据的环境，以及训练能力很强的硬件这些客观条件得具备，才能真正发挥LSTM的威力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它把训练信息分为长期记忆（c）和短期记忆（h），上面的长期记忆信息，可以穿到很远，即使序列长到1000，也可以向前传导。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它分了很多个门（gate），输出信息趋近于0，门关闭，趋近于1门打开。i是输入门控制新输入加多少到长期记忆中，f是forget控制是否受长期记忆的影响，哪些长期记忆被忘掉，o是输出门控制哪些长期记忆可以输出并作为短期记忆ht传递下去，通过这3个门控制信息的流动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以保证长期记忆变换的缓慢，相对稳定，可以对距离比较远的序列影响，ht和ht-1可以看到距离也比较远，短期记忆ht-1变化明显。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216170310514-1968622218.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216171548749-1961024832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TensorFlow中LSTM具体实现&lt;/span&gt;
n_steps = 28&lt;span&gt;
n_inputs &lt;/span&gt;= 28&lt;span&gt;
n_neurons &lt;/span&gt;= 150&lt;span&gt;
n_outputs &lt;/span&gt;= 10&lt;span&gt;
n_layers &lt;/span&gt;= 3&lt;span&gt;

learning_rate &lt;/span&gt;= 0.001&lt;span&gt;

X &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.float32, [None, n_steps, n_inputs])
y &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32, [None])

lstm_cells &lt;/span&gt;= [tf.contrib.rnn.BasicLSTMCell(num_units=&lt;span&gt;n_neurons)
              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_layers)]
multi_cell &lt;/span&gt;=&lt;span&gt; tf.contrib.rnn.MultiRNNCell(lstm_cells)
outputs, states &lt;/span&gt;= tf.nn.dynamic_rnn(multi_cell, X, dtype=&lt;span&gt;tf.float32)
top_layer_h_state &lt;/span&gt;= states[-1][1&lt;span&gt;]
logits &lt;/span&gt;= tf.layers.dense(top_layer_h_state, n_outputs, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
xentropy &lt;/span&gt;= tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=&lt;span&gt;logits)
loss &lt;/span&gt;= tf.reduce_mean(xentropy, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
optimizer &lt;/span&gt;= tf.train.AdamOptimizer(learning_rate=&lt;span&gt;learning_rate)
training_op &lt;/span&gt;=&lt;span&gt; optimizer.minimize(loss)
correct &lt;/span&gt;= tf.nn.in_top_k(logits, y, 1&lt;span&gt;)
accuracy &lt;/span&gt;=&lt;span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))
    
init &lt;/span&gt;= tf.global_variables_initializer()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;LSTM还有一点改进Peephole Connection&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;lstm_cell = tf.contrib.rnn.LSTMCell(num_units=n_neurons, use_peepholes=True) &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;2. GRU（Gated recurrent unit）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; GRU是对LSTM简化后的版本，去掉了长短期记忆的区分（都是h），减少了几个门，2014年提出，从参数上来说较LSTM简单些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统一用update gate控制原来的i门和f门。z趋近于0就用ht-1来更新，趋近于1就取当前输入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比LSTM还少一个矩阵乘法，实际表现不比LSTM差，也成为现在很多研究者越来越看重的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216172316764-271888180.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216172329389-2127370962.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用时，直接调用GRU cell即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;gru_cell = tf.contrib.rnn.GRUCell(num_units=n_neurons) &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;六、RNN在NLP（natural language processing）中的应用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RNN的输入原本是one-hot的表示，但这样会使得输入极其稀疏，不好训练。于是将高维空间映射到低维（如100维）空间，用这个低维嵌入的输入做训练，非常有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Word Embeddings&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同含义的词在低维空间中距离近，含义差的多的离得远。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把50000维数据映射到150维数据空间上&lt;/span&gt;
vocabulary_size = 50000&lt;span&gt;
embedding_size &lt;/span&gt;= 150
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 做一个全连接&lt;/span&gt;
embeddings = tf.Variable(tf.random_uniform([vocabulary_size, embedding_size], -1.0, 1.0&lt;span&gt;))

train_inputs &lt;/span&gt;= tf.placeholder(tf.int32, shape=[None]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from ids&lt;/span&gt;
embed = tf.nn.embedding_lookup(embeddings, train_inputs)&lt;span&gt;#&lt;/span&gt;&lt;span&gt; to embd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;例如下图所示，把要翻译的英文句子做输入，用训练后的状态值做输入，和法语作为训练集的作为decoder输入。第一位放一个起始信号&amp;lt;go&amp;gt;，输出和输入刚好错一位，最后一位以一个结束标识&amp;lt;eos&lt;em id=&quot;__mceDel&quot;&gt;&amp;gt;结束。这样做是为了后继应用时，翻译新句子没有training label，只有英文输入。把英文输入放进来后加一个&amp;lt;go&amp;gt;，得到第一个je输出，把第一个词放进来得到第二个输出bois。。最后&amp;lt;eos&amp;gt;翻译结束。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216173413046-1172187711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后实际应用时如下，输入&amp;lt;go&amp;gt;开始翻译。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201712/1214565-20171216173825077-417965380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 11:24:00 +0000</pubDate>
<dc:creator>水奈樾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rucwxb/p/8047401.html</dc:identifier>
</item>
</channel>
</rss>