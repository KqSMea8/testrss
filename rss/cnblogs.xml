<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ocelot简易教程（四）之请求聚合以及服务发现 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9695639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9695639.html</guid>
<description>&lt;p&gt;上篇文章给大家讲解了Ocelot的一些特性并对路由进行了详细的介绍，今天呢就大家一起来学习下Ocelot的请求聚合以及服务发现功能。希望能对大家有所帮助。&lt;/p&gt;
&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9695639.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9695639.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;请求聚合&quot;&gt;请求聚合&lt;/h2&gt;
&lt;p&gt;Ocelot允许你声明聚合路由，这样你可以把多个正常的ReRoutes打包并映射到一个对象来对客户端的请求进行响应。比如，你请求订单信息，订单中又包含商品信息，这里就设计到两个微服务，一个是商品服务，一个是订单服务。如果不运用聚合路由的话，对于一个订单信息，客户端可能需要请求两次服务端。实际上这会造成服务端额外的开销。这时候有了聚合路由后，你只需要请求一次聚合路由，然后聚合路由会合并订单跟商品的结果都一个对象中，并把这个对象响应给客户端。使用Ocelot的此特性可以让你很容易的实现前后端分离的架构。&lt;br/&gt;为了实现Ocelot的请求功能，你需要在ocelot.json中进行如下的配置。这里我们指定了了两个正常的ReRoutes,然后给每个ReRoute设置一个Key属性。最后我们再Aggregates节点中的ReRouteKeys属性中加入我们刚刚指定的两个Key从而组成了两个ReRoutes的聚合。当然我们还需要设置UpstreamPathTemplate匹配上游的用户请求，它的工作方式与正常的ReRoute类似。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：不要把Aggregates中UpstreamPathTemplate设置的跟ReRoutes中的UpstreamPathTemplate设置成一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们先上个实例例子先！演示代码已经同步更新Github上。有兴趣的朋友可以查看源码：&lt;a href=&quot;https://github.com/yilezhu/OcelotDemo&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/OcelotDemo&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在开始实例前先把我们的ocelot Nuget包升级到最新的12.0.0版本，当然你也可以不进行升级。这里需要注意一下，如果你升级到12.0.0的版本的话，那么你&lt;code&gt;config.AddOcelot()&lt;/code&gt;的用法会发生改变，需要传入参数&lt;code&gt;config.AddOcelot(hostingContext.HostingEnvironment)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.为了演示的需要这里我们新增一个类库项目，分别新建两个类，一个是商品Good类，一个是订单Order类（这里只是为了演示的需要，所以代码很简陋）如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class Goods
    {
        public int Id { get; set; }
        public string Content { get; set; }
    }

public class Orders
    {
        public int Id { get; set; }
        public string Content { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;26.778088904445&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;接下来我们给OrderApi以及GoodApi分别新建一个控制器，并返回相应的实体。如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//GoodApi项目中
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class GoodController : ControllerBase
    {
        // GET api/Good/5
        [HttpGet(&quot;{id}&quot;)]
        public ActionResult&amp;lt;string&amp;gt; Get(int id)
        {
            var item = new Goods
            {
                Id = id,
                Content = $&quot;{id}的关联的商品明细&quot;,
            };
            return JsonConvert.SerializeObject(item);
        }
    }
  //OrderApi项目中  
[Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class OrderController : ControllerBase
    {
        // GET api/Order/5
        [HttpGet(&quot;{id}&quot;)]
        public ActionResult&amp;lt;string&amp;gt; Get(int id)
        {
            var item = new Orders {
                Id=id,
                Content=$&quot;{id}的订单明细&quot;,
            };
            return JsonConvert.SerializeObject(item);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;接下来我们分别在ocelot.good.json以及ocelot.order.json中新增一个路由，并给出Keys.如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里注意，跟上篇文章中的路由不同的是，这里多了一个Key属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//ocelot.good.json
{
      &quot;DownstreamPathTemplate&quot;: &quot;/api/Good/{id}&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;DownstreamHostAndPorts&quot;: [
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 1001
        }
      ],
      &quot;UpstreamPathTemplate&quot;: &quot;/good/{id}&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot;, &quot;Post&quot; ],
      &quot;Key&quot;: &quot;Good&quot;,
      &quot;Priority&quot;: 2
    }
//ocelot.order.json
{
      &quot;DownstreamPathTemplate&quot;: &quot;/api/Order/{id}&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;DownstreamHostAndPorts&quot;: [
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 1002
        }
      ],
      &quot;UpstreamPathTemplate&quot;: &quot;/order/{id}&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot;, &quot;Post&quot; ],
      &quot;Key&quot;: &quot;Order&quot;,
      &quot;Priority&quot;: 2
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5.5&quot;&gt;
&lt;p&gt;在ocelot.all.json中加入聚合配置，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  &quot;Aggregates&quot;: [
    {
      &quot;ReRouteKeys&quot;: [
        &quot;Good&quot;,
        &quot;Order&quot;
      ],
      &quot;UpstreamPathTemplate&quot;: &quot;/GetOrderDetail/{id}&quot;
    }
  ]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：这里&lt;code&gt;Aggregates&lt;/code&gt;跟&lt;code&gt;ReRoutes&lt;/code&gt;同级，&lt;code&gt;ReRouteKeys&lt;/code&gt;中填写的数组就是上面步骤3中设置的&lt;code&gt;Key&lt;/code&gt;属性对应的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;6.9257950530035&quot;&gt;
&lt;p&gt;我们分别运行起来三个项目，然后访问接口地址：&lt;a href=&quot;http://localhost:1000/GetOrderDetail/1&quot; class=&quot;uri&quot;&gt;http://localhost:1000/GetOrderDetail/1&lt;/a&gt; 会得到如下的聚合响应内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201809/1377250-20180924152722994-1283657813.png&quot; alt=&quot;1537715634581&quot;/&gt;&lt;br/&gt;格式化后代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
    &quot;Good&quot;:{
        &quot;Id&quot;:1,
        &quot;Content&quot;:&quot;1的关联的商品明细&quot;
    },
    &quot;Order&quot;:{
        &quot;Id&quot;:1,
        &quot;Content&quot;:&quot;1的订单明细&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6.199375&quot;&gt;
&lt;p&gt;眼尖的朋友可能已经猜到了。聚合路由返回的内容就是json串。json串由&lt;code&gt;ReRouteKeys&lt;/code&gt;组成，每个&lt;code&gt;Key&lt;/code&gt;的内容就是具体下游响应的内容了！实例代码已经同步更新到Github上，地址：&lt;a href=&quot;https://github.com/yilezhu/OcelotDemo&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/OcelotDemo&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Ocelot将始终使用聚合请求返回内容类型application/json。还有需要注意的是聚合请求不会返回404请求。如果两个下游都返回404状态码的话，这里聚合后的响应也不会返回404，只会返回空的json串，拿上面的实例，如果两个下游都返回404的话，那么他的响应代码类似下面这样：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
   &quot;Good&quot;: ,
   &quot;Order&quot;:
}&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;如果下游服务返回404，则聚合将仅为该下游服务返回任何内容。即使所有下游都返回404，它也不会将聚合响应更改为404。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;服务发现&quot;&gt;服务发现&lt;/h2&gt;
&lt;p&gt;Ocelot允许您指定服务发现提供程序，并将使用它来查找Ocelot将请求转发到的下游服务的主机和端口。目前，这仅在GlobalConfiguration部分中受支持，这意味着相同的服务发现提供程序将用于为ReRoute级别指定ServiceName的所有ReRoutes。&lt;/p&gt;
&lt;h3 id=&quot;consul&quot;&gt;Consul&lt;/h3&gt;
&lt;p&gt;在使用Consul前你首先要做的就是安装在Ocelot中提供Consul支持的NuGet包&lt;br/&gt;&lt;code&gt;Install-Package Ocelot.Provider.Consul&lt;/code&gt;&lt;br/&gt;然后将下面的内容添加在ConfigureServices方法中&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddOcelot()//注入Ocelot服务
                    .AddConsul(); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GlobalConfiguration中需要加入以下内容。如果您未指定主机和端口，则将使用Consul默认值。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&quot;ServiceDiscoveryProvider&quot;: {
    &quot;Host&quot;: &quot;localhost&quot;,
    &quot;Port&quot;: 8500,
    &quot;Type&quot;: &quot;Consul&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;注意：如果你采用&lt;code&gt;AddOcelot()&lt;/code&gt;这种方式来自动加载ocelot配置文件的方式，那么你需要新建一个ocelot.global.json文件，然后加入上面的配置：如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
&quot;GlobalConfiguration&quot;: {
  &quot;ServiceDiscoveryProvider&quot;: {
    &quot;Host&quot;: &quot;localhost&quot;,
    &quot;Port&quot;: 8500,
    &quot;Type&quot;: &quot;Consul&quot;
  }
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;pre&gt;
&lt;code&gt;然后重新运行dotnet run命令会自动合并配置信息到Ocelot.json中，生成的对应内容如下：
​```C#
&quot;ServiceDiscoveryProvider&quot;: {
      &quot;Host&quot;: &quot;localhost&quot;,
      &quot;Port&quot;: 8500,
      &quot;Type&quot;: &quot;Consul&quot;,
      &quot;Token&quot;: null,
      &quot;ConfigurationKey&quot;: null,
      &quot;PollingInterval&quot;: 0
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个上篇文章中已经进行了相关的介绍。&lt;/p&gt;
&lt;p&gt;为了告诉Ocelot ReRoute是为其主机和端口使用服务发现提供程序，您必须在下游请求时添加要使用的ServiceName和负载均衡器。目前，Ocelot可以使用RoundRobin和LeastConnection算法。如果未指定负载均衡器，则Ocelot将不会对请求进行负载均衡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
    &quot;DownstreamPathTemplate&quot;: &quot;/api/posts/{postId}&quot;,
    &quot;DownstreamScheme&quot;: &quot;https&quot;,
    &quot;UpstreamPathTemplate&quot;: &quot;/posts/{postId}&quot;,
    &quot;UpstreamHttpMethod&quot;: [ &quot;Put&quot; ],
    &quot;ServiceName&quot;: &quot;product&quot;,
    &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;LeastConnection&quot;
    },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置此项后，Ocelot将从服务发现提供程序中查找下游主机和端口，并跨任何可用服务进行负载平衡请求。&lt;/p&gt;
&lt;h3 id=&quot;动态路由&quot;&gt;动态路由&lt;/h3&gt;
&lt;p&gt;作者的想法是在使用服务发现提供程序时启用动态路由。在此模式下，Ocelot将使用上游路径的第一个段来与服务发现提供程序一起查找下游服务。&lt;/p&gt;
&lt;p&gt;例如，使用https://api.yilezhu.cn/product/products 等网址调用ocelot 。Ocelot将采用产品路径的第一部分&lt;code&gt;product&lt;/code&gt;，并将其用作在Consul中查找服务的Key。如果consul返回一个服务，Ocelot将使用从consul返回的主机和端口以及剩余路径段组合后的Url来进行请求的响应。，如：http：// hostfromconsul：portfromconsul/products。Ocelot将正常向下游URL转发查询字符串。即query&lt;/p&gt;
&lt;p&gt;要启用动态路由，您需要在配置中保留0个ReRoutes。目前您无法混合动态和配置ReRoutes。除此之外，您还需要指定上面概述的Service Discovery提供程序详细信息和下游http / https方案作为DownstreamScheme。&lt;/p&gt;
&lt;p&gt;除此之外，您还可以设置RateLimitOptions，QoSOptions，LoadBalancerOptions和HttpHandlerOptions，DownstreamScheme（您可能希望在https上调用Ocelot，但可以通过http与私有服务进行通信），这些将应用于所有动态ReRoutes。&lt;/p&gt;
&lt;p&gt;配置可能看起来像:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
    &quot;ReRoutes&quot;: [],
    &quot;Aggregates&quot;: [],
    &quot;GlobalConfiguration&quot;: {
        &quot;RequestIdKey&quot;: null,
        &quot;ServiceDiscoveryProvider&quot;: {
            &quot;Host&quot;: &quot;localhost&quot;,
            &quot;Port&quot;: 8500,
            &quot;Type&quot;: &quot;Consul&quot;,
            &quot;Token&quot;: null,
            &quot;ConfigurationKey&quot;: null
        },
        &quot;RateLimitOptions&quot;: {
            &quot;ClientIdHeader&quot;: &quot;ClientId&quot;,
            &quot;QuotaExceededMessage&quot;: null,
            &quot;RateLimitCounterPrefix&quot;: &quot;ocelot&quot;,
            &quot;DisableRateLimitHeaders&quot;: false,
            &quot;HttpStatusCode&quot;: 429
        },
        &quot;QoSOptions&quot;: {
            &quot;ExceptionsAllowedBeforeBreaking&quot;: 0,
            &quot;DurationOfBreak&quot;: 0,
            &quot;TimeoutValue&quot;: 0
        },
        &quot;BaseUrl&quot;: null,
            &quot;LoadBalancerOptions&quot;: {
            &quot;Type&quot;: &quot;LeastConnection&quot;,
            &quot;Key&quot;: null,
            &quot;Expiry&quot;: 0
        },
        &quot;DownstreamScheme&quot;: &quot;http&quot;,
        &quot;HttpHandlerOptions&quot;: {
            &quot;AllowAutoRedirect&quot;: false,
            &quot;UseCookieContainer&quot;: false,
            &quot;UseTracing&quot;: false
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ocelot还允许您设置DynamicReRoutes，允许您为每个下游服务设置速率限制规则。如果您有一个产品和搜索服务，并且您希望对另一个进行速率限制，则此功能非常有用。这方面的一个例子如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
    &quot;DynamicReRoutes&quot;: [
        {
        &quot;ServiceName&quot;: &quot;product&quot;,
        &quot;RateLimitRule&quot;: {
                &quot;ClientWhitelist&quot;: [],
                &quot;EnableRateLimiting&quot;: true,
                &quot;Period&quot;: &quot;1s&quot;,
                &quot;PeriodTimespan&quot;: 1000.0,
                &quot;Limit&quot;: 3
            }
        }
    ],
    &quot;GlobalConfiguration&quot;: {
        &quot;RequestIdKey&quot;: null,
        &quot;ServiceDiscoveryProvider&quot;: {
            &quot;Host&quot;: &quot;localhost&quot;,
            &quot;Port&quot;: 8523,
            &quot;Type&quot;: &quot;Consul&quot;
        },
        &quot;RateLimitOptions&quot;: {
            &quot;ClientIdHeader&quot;: &quot;ClientId&quot;,
            &quot;QuotaExceededMessage&quot;: &quot;&quot;,
            &quot;RateLimitCounterPrefix&quot;: &quot;&quot;,
            &quot;DisableRateLimitHeaders&quot;: false,
            &quot;HttpStatusCode&quot;: 428
        }
        &quot;DownstreamScheme&quot;: &quot;http&quot;,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此配置意味着如果您在/product/上进入Ocelot请求，则动态路由将启动，并且ocelot将使用针对DynamicReRoutes部分中的产品服务的速率限制设置。&lt;/p&gt;
&lt;h2 id=&quot;github地址&quot;&gt;GitHub地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yilezhu/OcelotDemo&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/OcelotDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ocelot简易教程目录&quot;&gt;Ocelot简易教程目录&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9557375.html&quot;&gt;Ocelot简易教程（一）之Ocelot是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9563188.html&quot;&gt;Ocelot简易教程（二）之快速开始1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9638417.html&quot;&gt;Ocelot简易教程（二）之快速开始2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9664977.html&quot;&gt;Ocelot简易教程（三）之主要特性及路由详解&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;2.4943820224719&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9695639.html&quot;&gt;Ocelot简易教程（四）之请求聚合以及服务发现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文接着上篇文章进行了Ocelot请求聚合功能以及服务发现功能的介绍，并且对Ocelot动态路由功能也进行了简单的阐述。对于请求聚合这块进行了相关实例代码的演示，并已经更新到Github上面了！希望能对大家有所帮助！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 24 Sep 2018 07:28:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>Ocelot简易教程（四）之请求聚合以及服务发现 上篇文章给大家讲解了Ocelot的一些特性并对路由进行了详细的介绍，今天呢就大家一起来学习下Ocelot的请求聚合以及服务发现功能。希望能对大家有所帮</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9695639.html</dc:identifier>
</item>
<item>
<title>【不定期更新】FPGA/IC岗位常见笔试面试题总结 - 没落骑士</title>
<link>http://www.cnblogs.com/moluoqishi/p/9682936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moluoqishi/p/9682936.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1 数字IC（ASIC）设计流程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　规格定制、详细设计、HDL编码、仿真验证、逻辑综合（产生网表）、静态时序分析（STA）、形式验证（对比综合后网表与HDL设计功能是否一致）。之后包括布局布线（进行硬件模块和连线资源映射）等操作，最终生成验证后的版图文件用于流片。其中综合是划分IC设计前端和后端的界限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2 MCU结构：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　它是由CPU系统、程序存储器（ROM）、数据存储器（RAM）、各种I/O端口、基本功能单元（定时器/计数器等）组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3 SOC低功耗技术：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在各个设计层级上均有低功耗技术：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a.工艺级：降低电源供电电压和阈值电压。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b.电路级：降低总线电压摆幅。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　c.门级：同样通过低电压实现低功耗技术。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　d.RTL级：主要从减少不希望的跳变入手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　e.系统级：门控技术（控制和消除不必要的寄存器活动）和异步电路（电路只在需要时工作，消除全局时钟树功耗）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;4 MOS管基本概念：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MOS中文意思是金属氧化物半导体场效应管，由栅极（G）、漏级（D）、源级（S）组成。分为PMOS和NMOS两种类型，区别在于G级高电平时，N型管导通，P型管截止。两者往往是成对出现的，即CMOS。只要一只导通，另一只则不导通，现代单片机主要是采用CMOS工艺制成的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5 FPGA内部结构及资源：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　FPGA主要由可编程单元、可编程I/O单元及布线资源构成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可编程逻辑单元（可配置逻辑单元，CLB）由两个SLICE构成，SLICE主要包括实现组合逻辑的LUT和实现时序逻辑的触发器。FPGA内部还包含专用存储单元BRAM，运算单元DSP Slice，及专用内嵌功能单元，如：PLL、Serdes等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6 FPGA内部LUT实现组合逻辑的原理：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　LUT相当于存放逻辑表达式对应真值表的RAM。软件将逻辑表达式所有可能结果列出后存放在RAM中，输入作为RAM地址，输出为逻辑运算结果。如使用LUT模拟二输入“与”逻辑。列出真值表：00 -- 0，01 -- 0,10 -- 0,11 -- 1。此时将00 01 10 11作为地址线，依次将结果0 0 0 1存放在RAM中。当输入00时及输出0&amp;amp;0=0.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7 常用逻辑表达式化简公式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左右关系为*变+，+变*&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　交换律：A*B = B*A 　　　　　　　　A+B = B+A&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结合律：(A*B)*C = A*(B*C)　　　　  (A+B)+C = A+(B+C)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　分配率：A(B+C) = AB+AC　　　　　A+BC = (A+B)(A+C)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;特殊定律：&lt;/span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180920212340607-1274926429.png&quot; alt=&quot;&quot; width=&quot;314&quot; height=&quot;72&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;8 FIR滤波器与IIR滤波器函数表达式、特点及结构：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　FIR（有限冲激响应）滤波器：非递归，具有线性相位。IIR（无限冲激响应）滤波器：递归结构，非线性相位。相同阶数FIR和IIR滤波器，IIR滤波器滤波效果较好，但会产生相位失真。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FIR滤波器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对N个采样数据进行加权和平均处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表达式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180920214043285-14897967.png&quot; alt=&quot;&quot; width=&quot;178&quot; height=&quot;52&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180920214258470-984139216.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IIR滤波器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;包含递归部分也包含非递归部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表达式：（具有N个前馈系数和M-1个反馈系数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180920214524052-473585108.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;51&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180920214631133-1348771882.png&quot; alt=&quot;&quot; width=&quot;545&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 24 Sep 2018 07:24:00 +0000</pubDate>
<dc:creator>没落骑士</dc:creator>
<og:description>1 数字IC（ASIC）设计流程： 规格定制、详细设计、HDL编码、仿真验证、逻辑综合（产生网表）、静态时序分析（STA）、形式验证（对比综合后网表与HDL设计功能是否一致）。之后包括布局布线（进行硬</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moluoqishi/p/9682936.html</dc:identifier>
</item>
<item>
<title>JavaScript设计模式基础之闭包(终) - y-y-y-y</title>
<link>http://www.cnblogs.com/y-y-y-y/p/9695498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/y-y-y-y/p/9695498.html</guid>
<description>&lt;p&gt;对于前端程序员来说闭包还是比较难以理解的，&lt;/p&gt;
&lt;p&gt;闭包的形成与变量的作用域以及变量的生产周期密切相关，所以要先弄懂变量的作用域和生存周期。&lt;/p&gt;
&lt;p&gt;1.变量作用域&lt;/p&gt;
&lt;p&gt;　　变量的作用域，就是指变量的有效范围，通常我们指的作用域就是函数作用域（毕竟全局的作用域没有要指的意义，关键哪都能访问）&lt;/p&gt;
&lt;p&gt;　　声明变量的时候推荐使用es6语法中的let 和const 可以避免var声明变量出现的一些不必要的错误而且let声明变量只作用于当前作用域 避免使用不带var 或者let直接声明变量，可能会导致命名冲突。&lt;/p&gt;
&lt;p&gt;2.变量生存周期&lt;/p&gt;
&lt;p&gt;　　除了变量作用域之外，另外一个跟闭包有关的概念就是变量生存周期。&lt;/p&gt;
&lt;p&gt;　　对于全局变量来说，它的生存周期就是永久，除非我们主动销毁它，而对于函数里面声明的变量来说 它的生存周期会随着函数调用解释而被销毁。&lt;/p&gt;
&lt;p&gt;闭包的定义： 最简单直白的说法就是 函数返回函数&lt;/p&gt;
&lt;p&gt;闭包的应用：封装私有变量、延续局部变量的寿命&lt;/p&gt;
&lt;p&gt;1.封装私有变量：&lt;/p&gt;
&lt;p&gt;　　使用闭包可以把一些不需要暴露在全局的变量封装成“私有变量”&lt;/p&gt;
&lt;p&gt;　　如有一个计算数组偶数乘积的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    let num = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arr){
        let a &lt;/span&gt;= 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; arr.length; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[i] % 2 === 0&lt;span&gt;){
                a &lt;/span&gt;*=&lt;span&gt; arr[i];
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }
   
    console.log( num([&lt;/span&gt;1,2,3,4]));//输出8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入缓存机制提高函数性能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
let cache =&lt;span&gt; {};
    let num &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arr){
        let args &lt;/span&gt;= Array.prototype.join.call(arr,',');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出1,2,3,4&lt;/span&gt;
        console.log(cache[args])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次调用输出为undefined进行下一步计算 第二次调用输出8 直接返回&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入相同参数就比不必进行计算 直接返回缓存提高性能&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(cache[args]){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[args];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是相同参数则进行计算&lt;/span&gt;
        let a = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; arr.length; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[i] % 2 === 0&lt;span&gt;){
                a &lt;/span&gt;*=&lt;span&gt; arr[i];
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cache[args] =&lt;span&gt; a;
    }
   
    console.log( num([&lt;/span&gt;1,2,3,4]));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8 进行计算&lt;/span&gt;
    console.log( num([1,2,3,4]));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8 返回缓存&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这明显能看到cache这个缓存变量只在num函数里面被使用，与其让它们一起暴露在全局不然把它封装在num函数内部，减少页面中的全局变量，以免该变量在其他地方被修改而引发错误&lt;/p&gt;
&lt;p&gt;封装后代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
let num = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        let cache &lt;/span&gt;=&lt;span&gt; {};
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arr){
            let args &lt;/span&gt;= Array.prototype.join.call(arr,',');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出1,2,3,4&lt;/span&gt;
            console.log(cache[args])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次调用输出为undefined进行下一步计算 第二次调用输出8 直接返回&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入相同参数就比不必进行计算 直接返回缓存提高性能&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断cache缓存对象里面有args这个key值没&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(args &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cache){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[args];
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是相同参数则进行计算&lt;/span&gt;
            let a = 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; arr.length; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[i] % 2 === 0&lt;span&gt;){
                    a &lt;/span&gt;*=&lt;span&gt; arr[i];
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cache[args] =&lt;span&gt; a;
        }
       
    })();
   
    console.log( num([&lt;/span&gt;1,2,3,4]));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8 进行计算&lt;/span&gt;
    console.log( num([1,2,3,4]));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8 返回缓存&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.延续局部变量寿命&lt;/p&gt;
&lt;p&gt;src属性会自动请求服务器数据如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  let report = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(src){
            let img &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Image();
            img.src &lt;/span&gt;=&lt;span&gt; src;
            console.log(img.src);
        }
        report(`https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1537779456907&amp;amp;di=c72dd79d1dbb02bb9340743bf08e99f7&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F94cad1c8a786c91723e93522c43d70cf3ac757c6.jpg`);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　但是一些低版本的浏览器实现存在着bug，在这些浏览器上面使用该函数会丢失数据 因为函数调用结束后变量销毁 我们可以用闭包封闭起来就能解决低版本浏览器bug&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  let report = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            let imgs &lt;/span&gt;=&lt;span&gt; [];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(src){
                let img &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Image();
                imgs.push(img);
                img.src &lt;/span&gt;=&lt;span&gt; src;
            }
            
        })()
        report(`https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1537779456907&amp;amp;di=c72dd79d1dbb02bb9340743bf08e99f7&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F94cad1c8a786c91723e93522c43d70cf3ac757c6.jpg`);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来要来点干货了 &lt;/p&gt;
&lt;p&gt;用闭包实现命令模式：&lt;/p&gt;
&lt;p&gt;在JavaScript中闭包的各种设计模式实现里面，闭包的运用特别广泛，在我后续的博客中将体会到这一点&lt;/p&gt;
&lt;p&gt;简单编写一段闭包实现命令模式 如果上述的闭包使用你基本会了的话不会对我们的理解造成困难&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button id=&quot;start&quot;&amp;gt;打开电脑&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;end&quot;&amp;gt;关闭电脑&amp;lt;/button&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令&lt;/span&gt;
        let Computer =&lt;span&gt; {
            open(){
                alert(&lt;/span&gt;'打开电脑'&lt;span&gt;);
            },
            close(){
                alert(&lt;/span&gt;'关闭电脑'&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建命令执行中介&lt;/span&gt;
        let createCommand = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(receiver){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;
            let execute = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; receiver.open();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;
            let undo = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; receiver.close();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                execute,
                undo
            }
        };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置执行命令者&lt;/span&gt;
        let setCommand = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(command){
            document.querySelector(&lt;/span&gt;'#start').onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                command.execute();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出打开电脑&lt;/span&gt;
&lt;span&gt;            }
            document.querySelector(&lt;/span&gt;'#end').onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                command.undo();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出关闭电脑&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入命令方法 传入执行中介 &lt;/span&gt;
&lt;span&gt;    setCommand(createCommand(Computer));
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码还是不难重在理解 &lt;/p&gt;

</description>
<pubDate>Mon, 24 Sep 2018 06:46:00 +0000</pubDate>
<dc:creator>y-y-y-y</dc:creator>
<og:description>对于前端程序员来说闭包还是比较难以理解的， 闭包的形成与变量的作用域以及变量的生产周期密切相关，所以要先弄懂变量的作用域和生存周期。 1.变量作用域 变量的作用域，就是指变量的有效范围，通常我们指的作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/y-y-y-y/p/9695498.html</dc:identifier>
</item>
<item>
<title>Mysql高一致高可用方案 - 余正忠</title>
<link>http://www.cnblogs.com/yuzhengzhong/p/9695499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzhengzhong/p/9695499.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一句话总结：使用官方Mysql Innodb Cluster集群方案实现Mysql冗余备份，无单点故障的高可用性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目背景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;腾讯数据中心网络的SDN控制器，项目业务对数据的要求如下：&lt;/p&gt;
&lt;p&gt;1、对数据可用性要求高，要求多节点冗余备份，Mysql单点故障后可以切换到其他节点&lt;/p&gt;
&lt;p&gt;2、对数据准确性要求高，对Mysql写数据时，需要强一致性备份，不能是异步的备份&lt;/p&gt;
&lt;p&gt;3、并发请求低&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;业内方案：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;203&quot;&gt;方案&lt;/td&gt;
&lt;td width=&quot;205&quot;&gt;优点&lt;/td&gt;
&lt;td width=&quot;197&quot;&gt;缺点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td width=&quot;203&quot;&gt;主备或一主多备，默认为异步复制，可安装插件半同步复制&lt;/td&gt;
&lt;td width=&quot;205&quot;&gt;官方方案，可进行读写分离，配置较简单&lt;/td&gt;
&lt;td width=&quot;237&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;1、写节点单点故障&lt;/p&gt;
&lt;p&gt;2、默认异步备份，非强一致性&lt;/p&gt;
&lt;p&gt;3、将从库提升为主库需要应用层实现&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;203&quot;&gt;双主 + keepalive + 虚IP&lt;/td&gt;
&lt;td width=&quot;205&quot;&gt;双主可同时写&lt;/td&gt;
&lt;td width=&quot;237&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1、引入了keepalive组件&lt;/p&gt;
&lt;p&gt;2、双主同时写存在较多冲突场景&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;203&quot;&gt;MariaDB Gelera Cluster&lt;/td&gt;
&lt;td width=&quot;205&quot;&gt;支持多写和高可用性，同步复制备份，每个节点保留全部数据&lt;/td&gt;
&lt;td width=&quot;237&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1、全同步写，写性能较低&lt;/p&gt;
&lt;p&gt;2、不支持锁的SQL如lock/unlock等&lt;/p&gt;
&lt;p&gt;3、不支持XA事务&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;203&quot;&gt;Mysql NDB Cluster&lt;/td&gt;
&lt;td width=&quot;205&quot;&gt;官方方案，支持分片即分布式存储，支持多写，号称可做到99.999%的可用性&lt;/td&gt;
&lt;td width=&quot;237&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1、架构复杂，部署也较复杂&lt;/p&gt;
&lt;p&gt;2、管理节点的可靠性需额外再考虑&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;203&quot;&gt;Mysql Fabric&lt;/td&gt;
&lt;td width=&quot;205&quot;&gt;早起Oracle出的方案，支持分片和基于同步或半同步的复制备份&lt;/td&gt;
&lt;td width=&quot;237&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1、用的人较少，方案有点不成熟&lt;/p&gt;
&lt;p&gt;2、需要修改代码，使用特定的mysql-connector&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;业内在冗余备份的基础上，提高并发能力的设计思路有：&lt;/p&gt;
&lt;p&gt;1、读写分离，单入口写，多节点同时读&lt;/p&gt;
&lt;p&gt;2、写并发提升：数据分片，即类似分库，1~100的数据分布在节点A，100~200的数据分布在节点B，不同分片的数据如2和102可同时写&lt;/p&gt;
&lt;p&gt;3、写并发提升：多主即多写，大多数情况不同数据同时写，当碰到同时操作同一数据如update同一条记录，由额外的仲裁流程介入，Mysql多主模式的处理方式为先提交的事务写成功，后提交的事务失败抛出异常，由应用层面处理看是丢弃或是读取最新事务后重新发起事务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;采用方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于分片、多写等复杂的方案架构复杂，都有一些限制，而项目还用到了Mysql的事务，XA事务，事务隔离，事务传播，表锁，行锁等，固应根据项目需要选择尽量简单的方案，采用Mysql官方的Innodb Cluster方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/83HeYicrL9w3ib600ysgiaVT8YKNAX7Df9TmL5ZI0OQdiaNOGksuYkjcn1VveTocq2shkJeZvp9jJqDrEJkkMia4uNw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.2560553633217992&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/83HeYicrL9w3ib600ysgiaVT8YKNAX7Df9TmL5ZI0OQdiaNOGksuYkjcn1VveTocq2shkJeZvp9jJqDrEJkkMia4uNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;578&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Mysql Innodb Cluster方案其实是由Mysql几个功能和插件组成的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1、Mysql Group Replication组复制&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于paxos协议的高一致性备份，写节点挂掉后自动重新选主，支持单主模式和多主模式(这里我们采用单主模式)。具体如下：&lt;/p&gt;
&lt;p&gt;  1）高一致性&lt;/p&gt;
&lt;p&gt;  基于原生复制及 paxos 协议的组复制技术，提供一致数据安全保证&lt;/p&gt;
&lt;p&gt;  2）高容错性&lt;/p&gt;
&lt;p&gt;  多数派机制，只要不是超过一半节点挂掉就能工作，内置了集群检测、fail-tolarence、fail-over等机制&lt;/p&gt;
&lt;p&gt;  3）高扩展性&lt;/p&gt;
&lt;p&gt;  节点的新增和移除都是自动的，新节点加入后，会自动从其他节点上同步状态，直到新节点和其他节点保持一致，如果某节点被移除了，其他节点自动更新组信息，自动维护新的组信息&lt;/p&gt;
&lt;p&gt;  4）高灵活性&lt;/p&gt;
&lt;p&gt;  有单主模式和多主模式，单主模式下，所有写操作都在主上进行；多主模式下，所有 server 都可以同时处理写操作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2、Mysql Router&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mysql Router更多是为应用层面服务的，假设应用层面如hibernate配置了数据库url为具体某个写节点，当该节点挂掉后，虽然组复制机制会自动重新选主，但应用层面就需要做额外处理如切换数据源等。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.66125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/83HeYicrL9w3ib600ysgiaVT8YKNAX7Df9TiaicymKfThlZaHNfNekgatibyh5Jaczhg50tyH59prOxEe3cR8xibORDLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/83HeYicrL9w3ib600ysgiaVT8YKNAX7Df9TiaicymKfThlZaHNfNekgatibyh5Jaczhg50tyH59prOxEe3cR8xibORDLA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.66125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/83HeYicrL9w3ib600ysgiaVT8YKNAX7Df9TiaicymKfThlZaHNfNekgatibyh5Jaczhg50tyH59prOxEe3cR8xibORDLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而Mysql Router可以为应用层面屏蔽下面数据库的变化，提供统一的操作入口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3、Mysql shell&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mysql shell是作为Mysql Cluster的命令行管理工具。&lt;/p&gt;

&lt;p&gt;引用：&lt;/p&gt;
&lt;p&gt;https://dev.mysql.com/doc/refman/8.0/en/mysql-innodb-cluster-introduction.html&lt;/p&gt;
&lt;p&gt;https://dev.mysql.com/doc/refman/8.0/en/group-replication-summary.html&lt;/p&gt;
&lt;p&gt;https://dev.mysql.com/doc/mysql-router/8.0/en/mysql-router-innodb-cluster.html&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/403910/201809/403910-20180924144614832-755186141.png&quot; alt=&quot;&quot; width=&quot;634&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 06:46:00 +0000</pubDate>
<dc:creator>余正忠</dc:creator>
<og:description>一句话总结：使用官方Mysql Innodb Cluster集群方案实现Mysql冗余备份，无单点故障的高可用性。 项目背景： 腾讯数据中心网络的SDN控制器，项目业务对数据的要求如下： 1、对数据可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzhengzhong/p/9695499.html</dc:identifier>
</item>
<item>
<title>redis的LRU算法（二） - lifehacker</title>
<link>http://www.cnblogs.com/Lifehacker/p/redis_lru.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lifehacker/p/redis_lru.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Lifehacker/p/redis_random_lru.html&quot; target=&quot;_blank&quot;&gt;前文再续，书接上一回&lt;/a&gt;。上次讲到redis的LRU算法，文章实在精妙，最近可能有机会用到其中的技巧，顺便将下半部翻译出来，实现的时候参考下。&lt;/p&gt;

&lt;p&gt;搏击俱乐部的第一法则：用裸眼观测你的算法&lt;/p&gt;
&lt;p&gt;Redis2.8的LRU实现已经上线了，在不同的负载环境下经过测试，用户没有抱怨Redis的清理机制。为了继续改进，我希望能观察到算法的性能，同时不会浪费大量CPU，不增加1比特空间占用。&lt;/p&gt;

&lt;p&gt;我设计了一个测试用例。导入指定数量的key，然后顺序访问他们，好让他们的最近访问时间顺序递减。再添加50%的key，那么之前的key有50%就会被淘汰掉。理想情况下，被淘汰的应该是前50%的。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/90397/201809/90397-20180924105603880-781523132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绿色的是新添加的key，灰色的是第一次添加的key，白色表示被移除的。&lt;/p&gt;

&lt;p&gt;LRU v2：不要丢掉重要信息&lt;/p&gt;
&lt;p&gt;当采用了N-key取样时，默认会建立16个key的池，将里面的key按空闲时间排序。新key只会在池不满或者空闲时间大于池里最小的，才能进池。&lt;/p&gt;

&lt;p&gt;这个实现极大的提升了性能，实现又简单，没有大bug。只要一点点性能监控和一些memmove()就完成了。&lt;/p&gt;

&lt;p&gt;同时，新的redis-cli模式（-lru-test）支持测试LRU精度，可以更接近真实的负载来看新算法的工况，尝试不同算法的时候，至少可以发现明显的速度退化。&lt;/p&gt;

&lt;p&gt;最近最少访问（LFU）&lt;/p&gt;
&lt;p&gt;我最近又部分重构了Redis cache的换页算法。这些工作源于一个issue：当你在Redis 3.2有多个数据库的时候，算法总是做局部选择。比如DB 0的所有key都用的很频繁，DB 1的所有key都用的很少。Redis会从每个DB里丢弃一个key。理性的选择应该是先丢弃DB 1的key，丢完以后再丢DB 0的&lt;/p&gt;

&lt;p&gt;Redis用作cache的时候，通常不会跟不同DB混合用，但我还是开始着手改进，最后将db的id包括在池里，然后所有DB都共用一个池，这个实现比原始先快20%&lt;/p&gt;

&lt;p&gt;这次改进激起了我对Redis这块子系统的好奇心。我花了好些天进行优化，如果我用一个大点的池子，会好点吗？如果选择key的时候考虑了流逝的时间，效果会不会更好？&lt;/p&gt;

&lt;p&gt;最后，我终于明白到，LRU算法会受到取样数量限制，只要数量足够，效果就很好，很难再改进。正如上图所示，每次取样10个键，已经和理论上的LRU几乎一样准确了。&lt;/p&gt;

&lt;p&gt;因为原始算法难以改进，我开始想其他办法。回顾前文，其实我们真正想要的，是保留未来最有可能访问的key，即是最常访问的key，而不是最新访问的key。这就是LFU算法。理论上LFU的实现很简单，只要给每个key挂一个计数器，我们就可以知道给定的key是不是比另一个key访问更多了。&lt;/p&gt;

&lt;p&gt;当然，LFU的实现上有几个通用的难点：&lt;/p&gt;
&lt;p&gt;1. LFU里没法使用链表法转移到头部的技巧了。因为完美LFU需要key严格按访问量排序。当访问量一致时，排序算法可能劣化为O（N），即使计数器只变了一点点&lt;/p&gt;
&lt;p&gt;2. LFU没法简单的只在访问时对计数器加一。因为访问模式会随着时间发生变化，所以一个高分的key需要随着时间流逝而分数递减。&lt;/p&gt;

&lt;p&gt;在Redis里第一个问题不是问题，我们可以沿用LRU的随机取样方法。第二个问题仍然存在，我们需要一个方法来递减分数，或者随着时间流逝将计数器折半。&lt;/p&gt;

&lt;p&gt;24bit空间实现的LFU&lt;/p&gt;
&lt;p&gt;在Redis里，我们可以用的就是LRU的24bit空间，需要一些奇技淫巧来实现。&lt;/p&gt;

&lt;p&gt;在24bit空间里，需要塞下：&lt;/p&gt;
&lt;p&gt;1. 某种类型的访问计数器&lt;/p&gt;
&lt;p&gt;2. 足够的信息来决定何时折半计数器&lt;/p&gt;

&lt;p&gt;我的解决方案如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;16&lt;/span&gt; bits      &lt;span&gt;8&lt;/span&gt;&lt;span&gt; bits
      &lt;/span&gt;+----------------+--------+
      + Last decr time | LOG_C  |
      +----------------+--------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8bit用来计数，16bit用来记录上次递减的时间&lt;/p&gt;

&lt;p&gt;你可能会认为，8bit计数器很快就会溢出了吧？这就是技巧所在：我用的是对数计数器。具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  uint8_t LFULogIncr(uint8_t counter) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (counter == &lt;span&gt;255&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)rand()/&lt;span&gt;RAND_MAX;
      &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; baseval = counter -&lt;span&gt; LFU_INIT_VAL;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (baseval &amp;lt; &lt;span&gt;0&lt;/span&gt;) baseval = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; p = &lt;span&gt;1.0&lt;/span&gt;/(baseval*server.lfu_log_factor+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r &amp;lt; p) counter++&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; counter;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计数器的值越大，真正加一的概率越小。上述代码算出一个概率p，介乎0到1之间，计数器越大，p越小。然后生成0-1之间的随机数r，只有r&amp;lt;p的时候，计数器才会加一。&lt;/p&gt;

&lt;p&gt;现在我们来看看计数器折半的问题。转成分钟为单位的unix时间，低16位会存在上面保留的16位空间内。当Redis进行随机取样，扫描key空间的时候，所有遇到的key都会被检查是否应该递减。如果上次递减实在N分钟之前（N是可配置的），并且计数器的值是高分值，那计数器就会被折半。如果计数器是低分值，则只会递减。（希望我们可以更好的分辨少访问量的key，因为我们的计数器精度比较低）&lt;/p&gt;

&lt;p&gt;还有一个问题，新的key需要一个生存的机会。Redis里新key会从5分开始。上面的递减算法已经考虑到这个分数，如果key分数低于5分，更容易被丢弃（一般是长时间没访问的非活跃key）。&lt;/p&gt;

</description>
<pubDate>Mon, 24 Sep 2018 05:23:00 +0000</pubDate>
<dc:creator>lifehacker</dc:creator>
<og:description>本文介绍了Redis lru和lfu算法的实现，呈现了对数计数器的简单实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lifehacker/p/redis_lru.html</dc:identifier>
</item>
<item>
<title>ReactNative之从HelloWorld中看环境搭建、组件封装、Props及State - 青玉伏案</title>
<link>http://www.cnblogs.com/ludashi/p/9282913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ludashi/p/9282913.html</guid>
<description>&lt;p&gt;开篇呢，先给大家问个好，今天是中秋节，祝大家中秋节快乐！！虽然是中秋节，但是木有回家还是总结一下知识点写写博客吧，想着昨天总结一下的，但是昨天和几个同学小聚了一下，酒逢知己总是千杯少呢，喝的微醺不适合写东西，所以就留到今天总结了。因为这段时间在工作中陆陆续续的接触到了一些RN开发的东西，还是需要总结一下的。今天只是个开篇，接下来还会有陆陆续续的关于RN开发的总结，&lt;span&gt;今天主要是环境搭建、简单的组件封装、Props和State的介绍，稍后还会更新布局、动画等一些开发中常用的东西&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;虽然RN没有Release版、虽然Airbnb放弃了RN、虽然Facebook正在重构RN, 但是RN还是动态化比较好的选择方案的，还是要好好的搞一下RN的，当然也是工作中需要。既然要搞，就得认真呢，这篇是关于RN的第一篇博客，后续还会有其他关于RN的博客跟进的，也好在自己的学习历程中打个Tag。今天博客比较简单，是RN入门级别的，当然进阶的东西目前还没有接触过，等深入后再展开来记录吧。&lt;/p&gt;
&lt;p&gt;RN官方文档（&lt;span&gt;&lt;a href=&quot;https://facebook.github.io/react-native/docs/getting-started&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://facebook.github.io/react-native/docs/getting-started&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、RN下的Hello World&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接触一个新的东西那必须从&lt;span&gt;HelloWorld&lt;/span&gt;开始呢，下方就一步步的从无到有搞一个RN的Hello World！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、安装Node和VSCode&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们来搞一下Hello World前的准备工作，使用RN时，Node环境是必不可少的，如果你没有Node环境可以使用brew进行安装。（如果你还没安装Homebrew, 那么请Google自行安装）&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;
&lt;code&gt;brew install &lt;span class=&quot;hljs-keyword&quot;&gt;node&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;然后可以把node的源更新成taobao的镜像，这样访问速度会快一些。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;npm config set registry https:&lt;span class=&quot;hljs-regexp&quot;&gt;//registry.&lt;span class=&quot;hljs-built_in&quot;&gt;npm.taobao.org --&lt;span class=&quot;hljs-built_in&quot;&gt;global
&lt;span class=&quot;hljs-built_in&quot;&gt;npm config set disturl https:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-built_in&quot;&gt;npm.taobao.org/dist --&lt;span class=&quot;hljs-built_in&quot;&gt;global&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;装完Node后，然后就是选择安装一个开发RN的IDE了，当然你如果够强大，完全可以用记事本来编写RN的代码。当然用记事本是开玩笑的，可以用Sublime Text、Visual Studio Code等，如果比较土壕的程序员呢，你可以支持一下正版的Webstorm。当然想我这样“温饱都成问题”的程序猿，就只能用免费的VSCode了。&lt;/p&gt;
&lt;p&gt;官方地址：&lt;span&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://code.visualstudio.com/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180708111240424-173529513.png&quot; alt=&quot;&quot; width=&quot;225&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然本篇博客使用的VScode，但是平时开发中用WebStorm感觉还是挺爽的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、安装 exp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接在模拟器上调试，依赖于exp这个App，下方这个命令就是安装exp。安装完后，会在模拟器上看到Expo这个App, 下方我们就会用到这个Expo。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm install exp --global&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709125656526-848176327.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;419&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709125500283-1213010970.png&quot; alt=&quot;&quot; width=&quot;188&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、create-react-native-app and run app&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装完Node后，使用Node的npm把&lt;strong&gt;create-react-native-app&lt;/strong&gt;这个包装一下，可以快速的创建一个RN-Project。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180708111159600-866226239.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后使用create-react-native-app可以创建一个RN工程了，下方创建了一个名为MyFirstRNProject的RN工程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180708162249448-1850421271.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建完相关的RN工程成功后会有相关的提示，我们还是按照其提示的俩，使用 yarn start 来启动工程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180708162430103-923905298.png&quot; alt=&quot;&quot; width=&quot;412&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;

&lt;p&gt;启动后，会让你选择相关的运行方式，因为本篇博客是在iOS环境下做的Demo，所有就直接选择 i 即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180708164202971-857499333.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;551&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 选择 i 后，就会启动模拟器中的Expo。可以用 command + D 来调用和隐藏开发调试面板。然后就会看到右边红框找那个的默认的文案。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709125754125-1362167085.png&quot; alt=&quot;&quot; width=&quot;209&quot; height=&quot;468&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709125808301-620884084.png&quot; alt=&quot;&quot; width=&quot;209&quot; height=&quot;468&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们可以将默认的文案改一下，然后修改一下样式，添加上我们的Hello World保存即可。因为默认&lt;span&gt;Live Reload&lt;/span&gt;是打开的，所以当相关的文件被修改后，模拟器上的工程会自动Reload加载改动后的效果，具体如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709130348624-1293306394.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;365&quot;/&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709130311490-220526610.png&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在上面的代码中我们还需注意到下方定义了一个 styles 的常量，该常量是我们需要的样式对象。在RN中可以使用 &lt;span&gt;StylesSheet.create()&lt;/span&gt;方法来创建我们需要的样式。改样式的定义规则与Web前端中的CSS差不多，使用方式页非常的相似。下方我们还会定义其他的样式表，稍后会介绍到。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、使用TypeScript来开发RN&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为之前使用的另一个动态化的框架是用TypeScript来开发的，想在RN中也用TypeScript来开发，当然其默认的js语言的。在RN中支持TS开发，有相关的文档（&lt;span&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Native-Starter&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/Microsoft/TypeScript-React-Native-Starter&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709132536794-1337908763.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;637&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后把工程中的App.js替换成App.tsx即可。（纯ts文件使用.ts来命名，有JSX的TS文件则使用tsx来做后缀），改完再次运行我们的Hello World即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709132346430-1425129469.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、自定义组件（Componet）、Props以及State&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实现完HelloWorld后我们来看一下RN中组件封装的姿势，下方会封装一个&lt;span&gt;HelloWorld&lt;/span&gt;的组件，然后在该组件的基础上看一下RN中Props和State的使用姿势。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、HelloWorld组件封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在RN中封装的组件都需要继承自 &lt;span&gt;Component&lt;/span&gt; 类，然后在该类中正常的去添加相关布局和相关逻辑即可。下方我们将上述的&lt;span&gt;HelloWorld&lt;/span&gt;进行了提取，创建了一个HelloWorld类，该类继承自React中的&lt;span&gt;Component&lt;/span&gt;。然后在&lt;span&gt;render()&lt;/span&gt;方法中通过JSX来添加需要渲染的各种组件，当然在我们的HelloWorld中，我们只用到了Text这个组件来展示文字。&lt;/p&gt;
&lt;p&gt;封装的组件的使用姿势与RN提供组件的使用姿势是一样的，都是通过JSX的语法来引入使用的。下方 &lt;span&gt;&amp;lt;HelloWorld /&amp;gt;&lt;/span&gt; 就是我们封装组件HelloWorld的使用姿势。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180709202217175-1553973386.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、Props - 属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;属性，说白了就是一个组件负责接送外部参数的一个东西，类似于一个方法的参数。当然，如果你使用一个&lt;span&gt;Function&lt;/span&gt;来定义一个组件的话，那么这个Props就是方法的参数。&lt;/p&gt;
&lt;p&gt;在上面的&lt;span&gt;HelloWorld&lt;/span&gt;的示例中，我们其实已经使用到了&lt;span&gt;Props&lt;/span&gt;这个东西，只不过是系统自带的，比如上面为HelloWorld指定的 style 就是一个props, 该&lt;span&gt;props&lt;/span&gt;传入的是一个样式对象。我们从Web前端的角度来说，属性这个东西应该是比较好理解的，div后边跟的key 和 value, 后边这个value就是相关key的属性。接下来我们将要介绍如何给自定义的组件添加特定的属性。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180710101430181-770606621.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;217&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下方我们写了一个HelloWorld的组件，该组件继承与React中的&lt;span&gt;Component&lt;/span&gt;，然后在render中渲染了一些组件，其中的Text是从属性Props中取的，从下方代码中看出，直接从Props中取相应的Key是可以取到的，不过强取值的话，会标红，会提示相关的熟悉在Props中不存在。稍后会解决该问题。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180710183411909-1305503814.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下方就是我们写的&lt;span&gt;Hello Props&lt;/span&gt;组件，组件中的相关内容时通过Props中的相关&lt;span&gt;key-value&lt;/span&gt;来传过来的。换句话说，Props就是一个传值的JSON串。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180711174552320-1340065321.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通常我们在开发中会为&lt;span&gt;Props&lt;/span&gt;定义相关的类型，来声明Props中都有哪些东西，下方就是我们为上述的HelloWorld补的Props的类型，然后通过协议的形式指定给HelloWorld组件。从下代码我们看出，在Props类型后边还有一个&lt;span&gt;null&lt;/span&gt;的类型，该类型是声明State的类型使用的。该处我们没有相关的状态，就暂且不指定，下方使用到的地方我们会给出相关的状态值。&lt;/p&gt;
&lt;p&gt;添加完相关的类型声明后，之前下方标红的地方就不存在了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201809/545446-20180924103818448-151225880.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、State-状态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;状态对应RN来说有着举足轻重的地位，整个RN的页面或者一个小的RN组件都可以看做是一个状态机，该状态机就是通过这个State来管理的。&lt;span&gt;State&lt;/span&gt;中可以存放各种状态以及各种值，当这些值或者状态被修改时，那么这个组件节点就会被重新渲染，也就是更新页面或者组件。下方我们就为我们的HelloWorld添加上相关的State状态，然后通过该状态所对应的值做一些事情。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明State类型：首先我们像声明之前的Props类型一样声明了一个&lt;span&gt;HelloWorldStateType&lt;/span&gt;的状态类型，然后HelloWorld组件中状态类型的位置设置了该类型。改类型中有一个属性，从状态属性我们不难看出是用来控制某个空是否展示白色的。&lt;/li&gt;
&lt;li&gt;初始State：我们指定状态类型后，该状态还需要一个初始状态，于是在构造器中对该状态进行了初始化。&lt;/li&gt;
&lt;li&gt;定时器修改状态：然后我们用定义了一个定时器，使用定时器来定时的修改状态的值，这样便于我们观察状态修改后的变化。定时器的作用就是“&lt;span&gt;隔一秒改一下时间&lt;/span&gt;”（下方有个错别字，就不改了）&lt;/li&gt;
&lt;li&gt;最后就是在渲染的&lt;span&gt;render&lt;/span&gt;方法中获取相关状态值进行使用了。该状态最终用来控制字体颜色的变化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201809/545446-20180924105057723-1189133274.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;608&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下方就是上述代码运行的相关效果，从下方的效果中不难看出，没个一秒文字的颜色会随着状态而修改。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/545446/201807/545446-20180711174436608-1693841066.gif&quot; alt=&quot;&quot; width=&quot;280&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 今天博客就先到这儿，该做饭去了，下篇博客会总结一个RN中常用的布局方式。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 03:22:00 +0000</pubDate>
<dc:creator>青玉伏案</dc:creator>
<og:description>开篇呢，先给大家问个好，今天是中秋节，祝大家中秋节快乐！！虽然是中秋节，但是木有回家还是总结一下知识点写写博客吧，想着昨天总结一下的，但是昨天和几个同学小聚了一下，酒逢知己总是千杯少呢，喝的微醺不适合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ludashi/p/9282913.html</dc:identifier>
</item>
<item>
<title>Java自定义注解 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9695055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9695055.html</guid>
<description>&lt;p&gt;随着springboot的流行，以前基于XML的spring配置用的越来越少，JavaConfig形式使用的越来越多，类似于:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Configuration
public class AppConfig {    
    @Bean(name=&quot;helloBean&quot;)
    public HelloWorld helloWorld() {
        return new HelloWorldImpl();
    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出更多的是基于注解(Annotation)实现的，包括springboot的入口类**Application。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ComponentScan(&quot;com.alibaba.trade&quot;)
@EnableAutoConfiguration//(exclude = {PageHelperAutoConfiguration.class})
@ServletComponentScan
@EnableTransactionManagement
@EnableDiscoveryClient
@EnableWebMvc
@MapperScan(&quot;com.alibaba.trade.shared.mapper&quot;)
public class TradeApplication extends SpringBootServletInitializer {
    public static void main(String[] args) {
        SpringApplication.run(TradeApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java注解不仅让我们减少了项目中XML文件，方便了维护，同时也使我们代码更简洁。那么项目中我们如何阅读注解以及如何创造自己的注解呢？&lt;/p&gt;

&lt;p&gt;Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。&lt;br/&gt;Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。&lt;/p&gt;
&lt;h2 id=&quot;内置注解&quot;&gt;内置注解&lt;/h2&gt;
&lt;p&gt;Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。&lt;br/&gt;1、作用在代码的注解是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Override&lt;/code&gt; - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Deprecated&lt;/code&gt; - 标记过时方法。如果使用该方法，会报编译警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@SuppressWarnings&lt;/code&gt; - 指示编译器去忽略注解中声明的警告。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、作用在其他注解的注解(或者说&lt;strong&gt;元注解&lt;/strong&gt;)是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Retention&lt;/code&gt; - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Documented&lt;/code&gt; - 标记这些注解是否包含在用户文档中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Target&lt;/code&gt; - 标记这个注解应该是哪种 Java 成员。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Inherited&lt;/code&gt; - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、从 Java 7 开始，额外添加了 3 个注解:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@SafeVarargs&lt;/code&gt; - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@FunctionalInterface&lt;/code&gt; - Java 8 开始支持，标识一个匿名函数或函数式接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Repeatable&lt;/code&gt; - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;元注解&quot;&gt;元注解&lt;/h3&gt;
&lt;p&gt;1、@Retention&lt;br/&gt;&lt;code&gt;@Retention&lt;/code&gt; annotation指定标记注释的存储方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。&lt;/li&gt;
&lt;li&gt;RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。&lt;/li&gt;
&lt;li&gt;RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、@Documented&lt;br/&gt;&lt;code&gt;@Documented&lt;/code&gt; 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。&lt;/p&gt;
&lt;p&gt;3、@Target&lt;br/&gt;&lt;code&gt;@Target&lt;/code&gt; 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ElementType.TYPE 可以应用于类的任何元素。&lt;/li&gt;
&lt;li&gt;ElementType.FIELD 可以应用于字段或属性。&lt;/li&gt;
&lt;li&gt;ElementType.METHOD 可以应用于方法级注释。&lt;/li&gt;
&lt;li&gt;ElementType.PARAMETER 可以应用于方法的参数。&lt;/li&gt;
&lt;li&gt;ElementType.CONSTRUCTOR 可以应用于构造函数。&lt;/li&gt;
&lt;li&gt;ElementType.LOCAL_VARIABLE 可以应用于局部变量。&lt;/li&gt;
&lt;li&gt;ElementType.ANNOTATION_TYPE 可以应用于注释类型。&lt;/li&gt;
&lt;li&gt;ElementType.PACKAGE 可以应用于包声明。&lt;/li&gt;
&lt;li&gt;ElementType.TYPE_PARAMETER&lt;/li&gt;
&lt;li&gt;ElementType.TYPE_USE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4、@Inherited&lt;br/&gt;&lt;code&gt;@Inherited&lt;/code&gt; 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。&lt;/p&gt;
&lt;p&gt;5、@Repeatable&lt;br/&gt;Repeatable Java SE 8中引入的，&lt;code&gt;@Repeatable&lt;/code&gt;注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。&lt;/p&gt;

&lt;p&gt;Java中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface SPI {
    /**
     * default extension name
     */
    String value() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道java.lang.annotation包中有一个Annotation的接口，它是所有注解类型扩展的公共接口。那我们是否可以直接通过实现该接口来实现自定义注解呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.lang.annotation.Annotation;
public class MyAnnotation implements Annotation {
    @Override
    public Class&amp;lt;? extends Annotation&amp;gt; annotationType() {
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现Annotation接口中只有一个annotationType的方法，而且通过源码的注释我们可以发现答案是不能。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201809/1162587-20180924111548367-445385279.png&quot;/&gt;&lt;br/&gt;汉译即为：Annotaion被所有注解类型继承，但是要注意：手动扩展继承此接口的接口不会定义注解类型。另请注意，此接口本身不定义注解类型。&lt;/p&gt;

&lt;p&gt;自定义注解的使用场景很多，我们在造轮子写框架的过程经常会使用到，例如我最近就遇到了一个业务场景：像一些编辑业务信息的接口，产品要求信息编辑后的新旧值对比，对比的业务功能，我们的实现方式是拿到前端填写的Form表单(新值)和数据库中查询出来的Dto(旧值)通过反射技术获取到相同属性字段名，再比较属性值就可以得出新旧值。得到值之后我们也知道该字段的Dto中的字段名，但是如何将比较得到的新旧值字段的中文名返回给前端呢？例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Stedent {
        private String name;
        private int age;
        private String sex;
       //省略setter,getter
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比较后我们的结果是 name : &quot;xiaoming &quot;-&amp;gt; &quot;daming&quot;，age : 24 -&amp;gt; 26。但是我们不能直接将name和age返回给前端，他们需要的格式是：姓名: &quot;xiaoming &quot;-&amp;gt; &quot;daming&quot;，年龄 : 24 -&amp;gt; 26。这时候就可以考虑自定义一个注解&lt;code&gt;@FieldName&lt;/code&gt;,&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Deprecated
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface FieldName {
    String value() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将该注解加在属性字段上面&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student {
    @FieldName(value = &quot;姓名&quot;)
    private String name;
    @FieldName(value = &quot;年龄&quot;)
    private int age;
    @FieldName(value = &quot;性别&quot;)
    private String sex;
    //省略setter,getter
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后就可以通过反射获取该字段中文名&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 如果 oldField 属性值与 newField 属性值的内容不相同
if (!isEmpty(newValue)) {
    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    String newFieldName = newField.getName();
    if (newField.isAnnotationPresent(ApiModelProperty.class)) {
        ApiModelProperty apiModelPropertyAnno = newField.getAnnotation(ApiModelProperty.class);
        newFieldName = apiModelPropertyAnno.value();
    else if (newField.isAnnotationPresent(FieldName.class)) {
        FieldName fieldNameAnno = newField.getAnnotation(FieldName.class);
        newFieldName = fieldNameAnno.name();
    }
        map.put(FIELD_NAME, newFieldName);
        map.put(OLD_VALUE, oldValue);
        map.put(NEW_VALUE, newValue);
        list.add(map);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 24 Sep 2018 03:16:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>前言 随着springboot的流行，以前基于XML的spring配置用的越来越少，JavaConfig形式使用的越来越多，类似于: 可以看出更多的是基于注解(Annotation)实现的，包括spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9695055.html</dc:identifier>
</item>
<item>
<title>记一次全站升级https引发的一系列问题 - 小卖铺的老爷爷</title>
<link>http://www.cnblogs.com/laoyeye/p/9694833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoyeye/p/9694833.html</guid>
<description>&lt;p&gt;中秋假期，闲来无事。花了一下午折腾了下https，说实话这年头还有网站不上https显然是折腾精神不够啊~&lt;/p&gt;
&lt;h2&gt;1、SSL证书评估&lt;/h2&gt;
&lt;p&gt;看了市面上各种类型的证书，有收费的也有免费的，但是最终还是选择了腾讯云提供的TrustAsia一年免费期的证书，没有次数限制，可以过期后再次申请。最主要的原因还是我懒，哈哈~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201809/1075594-20180924094644712-1558086407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2、SSL证书安装&lt;/h2&gt;
&lt;p&gt;从腾讯云将申请的证书下载到本地，解压获得3个文件夹，分别是Apache、IIS、Nginx 服务器的证书文件，可以根据自己的实际情况，安装在三种服务器上。&lt;/p&gt;
&lt;p&gt;我这里使用Nginx做前端转发。更多的介绍可以查看文档：https://cloud.tencent.com/document/product/400/4143&lt;/p&gt;
&lt;h4 id=&quot;2.1-.E8.8E.B7.E5.8F.96.E8.AF.81.E4.B9.A6&quot;&gt;2.1 获取证书&lt;/h4&gt;
&lt;p&gt;Nginx文件夹内获得SSL证书文件 1_www.domain.com_bundle.crt 和私钥文件 2_www.domain.com.key,&lt;br/&gt;1_www.domain.com_bundle.crt 文件包括两段证书代码 “-----BEGIN CERTIFICATE-----”和“-----END CERTIFICATE-----”,&lt;br/&gt;2_www.domain.com.key 文件包括一段私钥代码“-----BEGIN RSA PRIVATE KEY-----”和“-----END RSA PRIVATE KEY-----”。&lt;/p&gt;
&lt;h4 id=&quot;2.2-.E8.AF.81.E4.B9.A6.E5.AE.89.E8.A3.85&quot;&gt;2.2 证书安装&lt;/h4&gt;
&lt;p&gt;将域名 www.domain.com 的证书文件1_www.domain.com_bundle.crt 、私钥文件2_www.domain.com.key保存到同一个目录，例如/usr/local/nginx/conf目录下。&lt;br/&gt;更新Nginx根目录下 conf/nginx.conf 文件如下：&lt;/p&gt;
&lt;div class=&quot;markdown-code J-markdownCode&quot;&gt;
&lt;div class=&quot;markdown-code-bd J-codeBox&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen 443;
        server_name www.domain.com; #填写绑定证书的域名
        ssl on;
        ssl_certificate 1_www.domain.com_bundle.crt;
        ssl_certificate_key 2_www.domain.com.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
        ssl_prefer_server_ciphers on;
        location / {
            root   html; #站点目录
            index  index.html index.htm;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;配置完成后，先用&lt;code&gt;bin/nginx –t&lt;/code&gt;来测试下配置是否有误，正确无误的话，重启nginx。就可以使用 &lt;code&gt;https://www.domain.com&lt;/code&gt; 来访问了。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;div class=&quot;doc-table-wrap&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置文件参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;listen 443&lt;/td&gt;
&lt;td&gt;SSL访问端口号为443&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ssl on&lt;/td&gt;
&lt;td&gt;启用SSL功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ssl_certificate&lt;/td&gt;
&lt;td&gt;证书文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ssl_certificate_key&lt;/td&gt;
&lt;td&gt;私钥文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ssl_protocols&lt;/td&gt;
&lt;td&gt;使用的协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ssl_ciphers&lt;/td&gt;
&lt;td&gt;配置加密套件，写法遵循openssl标准&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h4 id=&quot;2.3-.E4.BD.BF.E7.94.A8.E5.85.A8.E7.AB.99.E5.8A.A0.E5.AF.86.EF.BC.8Chttp.E8.87.AA.E5.8A.A8.E8.B7.B3.E8.BD.AChttps.EF.BC.88.E5.8F.AF.E9.80.89.EF.BC.89&quot;&gt;2.3 使用全站加密，http自动跳转https（可选）&lt;/h4&gt;
&lt;p&gt;对于用户不知道网站可以进行https访问的情况下，让服务器自动把http的请求重定向到https。&lt;br/&gt;在服务器这边的话配置的话，可以在页面里加js脚本，也可以在后端程序里写重定向，当然也可以在web服务器来实现跳转。Nginx是支持rewrite的（只要在编译的时候没有去掉pcre）&lt;br/&gt;在http的server里增加&lt;code&gt;rewrite ^(.*) https://$host$1 permanent;&lt;/code&gt;&lt;br/&gt;这样就可以实现80进来的请求，重定向为https了。&lt;/p&gt;
&lt;h2&gt; 3、证书安装的一系列问题。&lt;/h2&gt;
&lt;h4&gt;3.1 端口号问题&lt;/h4&gt;
&lt;p&gt;需要注意的是，我们通常使用的80端口作为http默认访问的端口，而在https中使用的443端口，这个是需要特别注意的，我在安装过程中一开始就没有注意端口号的问题，导致https一直没有生效，后来问了公司的运维同学才知道，耽误了很长的时间。&lt;/p&gt;
&lt;h4&gt;3.2 http跳转https&lt;/h4&gt;
&lt;p&gt;一般我们的网站支持https之后，就不在支持http的访问了。这时候就需要把http的访问请求，重定向到https。实现的过程也很简单，新增一个server，然后加入以下配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen       80;

        location / {
            rewrite (.*) https://www.laoyeye.net;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接将80端口的访问，全部转发到网站的https域名，其实我这个写的还不是很规范，一般不会将域名写死，而是根据请求的域名做重定向的。&lt;/p&gt;
&lt;h4&gt;3.3 一级域名跳转二级域名的问题&lt;/h4&gt;
&lt;p&gt;一般我们的网站很多都想让www作为网站的首页，这是一个二级域名，而我们默认的一级域名，如laoyeye.net是不提供服务的，这个时候就需要将https访问这个域名的请求重定向到www域名，实现的过程也很简单。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen       443;
        server_name laoyeye.net; #填写绑定证书的域名
        ssl on;
        ssl_certificate 1_www.laoyeye.net_bundle.crt;
        ssl_certificate_key 2_www.laoyeye.net.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
        ssl_prefer_server_ciphers on;
        location / {
            rewrite (.*) http://www.laoyeye.net;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;需要注意的是这里处理的是&lt;span&gt;https://laoyeye.net&lt;/span&gt;链接&lt;/span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;http://laoyeye.net&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;在上面端口80的监听中是已经做了处理的。&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;3.4 400 Bad Request | The plain HTTP request was sent to HTTPS port&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201809/1075594-20180924101131913-823291699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成上述的配置，基本上访问&lt;span&gt;http&lt;/span&gt;://www.laoyeye.net/，还是&lt;span&gt;http&lt;/span&gt;://laoyeye.net/，亦或是&lt;span&gt;https&lt;/span&gt;://laoyeye.net/，均会跳转到&lt;span&gt;https&lt;/span&gt;://www.laoyeye.net/。但是我发现个别的链接访问会出现400错误，搞了一下午才弄清问题所在。&lt;/p&gt;
&lt;p&gt;原因主要是我在后端逻辑处理的时候使用了重定向，后端重定向后返回的是http链接，就会出现这个问题。&lt;/p&gt;
&lt;p&gt;解决办法也很多，很多人会改tomcat的配置，让重定向后的链接直接是https形式的。其实我不怎么喜欢这种方式，因为这样做的侵入性太大。当换一个tomcat服务器后，可能你并不会想起这个配置。&lt;/p&gt;
&lt;p&gt;既然我们是在nginx上配置的ssl，这里我们还是从nginx上想办法。&lt;/p&gt;
&lt;p&gt;在&lt;span class=&quot;line&quot;&gt;location种加入如下配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    proxy_redirect   http:// https://;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句话的作用是对发送给客户端的URL进行修改, 将http协议强制转为https，完成这个配置后就不会出现400的问题了。&lt;/p&gt;
&lt;p&gt;当然我还有一些个人的配置问题，比如QQ互联的回调地址啦，也是需要修改http为https才能正常使用。&lt;/p&gt;
&lt;p&gt;附Nginx入门以及我的配置参考：&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoyeye/p/6622783.html&quot;&gt;一、Nginx安装手册&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoyeye/p/6754359.html&quot;&gt;三、nginx实现反向代理负载均衡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的nginx配置供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;user  root;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

upstream tomcat_server {
            server xxxx:xxxx;
        }

    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {

        listen 80;

        location / {

                rewrite (.*) https://www.laoyeye.net;

        }

    }

    server {
        listen       443;
        server_name  laoyeye.net;
   
        ssl on;
        ssl_certificate 1_www.laoyeye.net_bundle.crt;
        ssl_certificate_key 2_www.laoyeye.net.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
        ssl_prefer_server_ciphers on;

    #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            rewrite (.*) https://www.laoyeye.net;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }
    server { 
        listen 443;
        server_name www.laoyeye.net;
        ssl on;
        ssl_certificate 1_www.laoyeye.net_bundle.crt;
        ssl_certificate_key 2_www.laoyeye.net.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
        ssl_prefer_server_ciphers on;

        location / {

         #域名www.laoyeye.net的请求全部转发到tomcat_server即tomcat服务上
         proxy_pass http://tomcat_server;
         proxy_set_header Host $host:$server_port;
         proxy_set_header X-Real-IP $remote_addr;
         proxy_set_header X-Real-PORT $remote_port;
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                
         # 必须配置:
         proxy_set_header X-Forwarded-Proto  $scheme;

         # 作用是对发送给客户端的URL进行修改, 将http协议强制转为https
         proxy_redirect   http:// https://; 
        index index.jsp index.html index.htm;

        }

    }
                 
    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 24 Sep 2018 02:55:00 +0000</pubDate>
<dc:creator>小卖铺的老爷爷</dc:creator>
<og:description>中秋假期，闲来无事。花了一下午折腾了下https，说实话这年头还有网站不上https显然是折腾精神不够啊~ 1、SSL证书评估 看了市面上各种类型的证书，有收费的也有免费的，但是最终还是选择了腾讯云提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoyeye/p/9694833.html</dc:identifier>
</item>
<item>
<title>spring-boot-2.0.3不一样系列之源码篇 - run方法（三）之createApplicationContext，绝对有值得你看的地方 - youzhibing2904</title>
<link>http://www.cnblogs.com/youzhibing/p/9686969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youzhibing/p/9686969.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　此系列是针对springboot的启动，旨在于和大家一起来看看springboot启动的过程中到底做了一些什么事。如果大家对springboot的源码有所研究，可以挑些自己感兴趣或者对自己有帮助的看；但是如果大家没有研究过springboot的源码，不知道springboot在启动过程中做了些什么，那么我建议大家从头开始一篇一篇按顺序读该系列，不至于从中途插入，看的有些懵懂。当然，文中讲的不对的地方也欢迎大家指出，有待改善的地方也希望大家不吝赐教。老规矩：一周至少一更，中途会不定期的更新一些其他的博客，可能是springboot的源码，也可能是其他的源码解析，也有可能是其他的。&lt;/p&gt;
&lt;p&gt;　　路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;p&gt;　　github：&lt;span&gt;&lt;a href=&quot;https://github.com/youzhibing&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/youzhibing&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　码云(gitee)：&lt;span&gt;&lt;a href=&quot;https://gitee.com/youzhibing&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://gitee.com/youzhibing&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;前情回顾&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　大家还记得&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/youzhibing/p/9622441.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;上篇博文&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;讲了什么吗，或者说大家知道上篇博文讲了什么吗。这里帮大家做个简单回顾，主要做了两件事&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、加载外部化配置的资源到environment&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　包括命令行参数、servletConfigInitParams、servletContextInitParams、systemProperties、sytemEnvironment、random、application.yml(.yaml/.xml/.properties)，如下所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180922075136564-855568901.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、广播ApplicationEnvironmentPreparedEvent事件，触发相应的监听器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　ConfigFileApplicationListener&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　添加名叫random的RandomValuePropertySource到environment&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　添加名叫applicationConfig:[classpath:/application.yml]的OriginTrackedMapPropertySource到environment&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　LoggingApplicationListener&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　初始化日志系统&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;createApplicationContext&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　先欣赏下我们的战绩，看看我们对run方法完成了多少的源码解读&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_7838b654-e9e1-41bf-b7a9-dc2832804458&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7838b654-e9e1-41bf-b7a9-dc2832804458&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7838b654-e9e1-41bf-b7a9-dc2832804458&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Run the Spring application, creating and refreshing a new
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ApplicationContext}.
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args the application arguments (usually passed from a Java main method)
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a running {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ApplicationContext}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigurableApplicationContext run(String... args) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 秒表，用于记录启动时间；记录每个任务的时间，最后会输出每个任务的总费时&lt;/span&gt;
    StopWatch stopWatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StopWatch();
    stopWatch.start();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; spring应用上下文，也就是我们所说的spring根容器&lt;/span&gt;
    ConfigurableApplicationContext context = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义SpringApplication启动错误的回调接口&lt;/span&gt;
    Collection&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置jdk系统属性java.awt.headless，默认情况为true即开启&lt;/span&gt;
&lt;span&gt;    configureHeadlessProperty();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取启动时监听器(EventPublishingRunListener实例)&lt;/span&gt;
    SpringApplicationRunListeners listeners =&lt;span&gt; getRunListeners(args)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发ApplicationStartingEvent事件，启动监听器会被调用，一共5个监听器被调用，但只有两个监听器在此时做了事&lt;/span&gt;
&lt;span&gt;    listeners.starting(); 
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数封装，也就是在命令行下启动应用带的参数，如--server.port=9000&lt;/span&gt;
        ApplicationArguments applicationArguments = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultApplicationArguments(
                args);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 准备环境：1、加载外部化配置的资源到environment；2、触发ApplicationEnvironmentPreparedEvent事件&lt;/span&gt;
        ConfigurableEnvironment environment =&lt;span&gt; prepareEnvironment(listeners,
                applicationArguments);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置spring.beaninfo.ignore，并添加到名叫systemProperties的PropertySource中；默认为true即开启&lt;/span&gt;
&lt;span&gt;        configureIgnoreBeanInfo(environment);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印banner图&lt;/span&gt;
        Banner printedBanner =&lt;span&gt; printBanner(environment);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建应用上下文，这是本文重点&lt;/span&gt;
        context =&lt;span&gt; createApplicationContext();
        exceptionReporters &lt;/span&gt;=&lt;span&gt; getSpringFactoriesInstances(
                SpringBootExceptionReporter.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Class[] { ConfigurableApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; }, context);
        prepareContext(context, environment, listeners, applicationArguments,
                printedBanner);
        refreshContext(context);
        afterRefresh(context, applicationArguments);
        stopWatch.stop();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logStartupInfo) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StartupInfoLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainApplicationClass)
                    .logStarted(getApplicationLog(), stopWatch);
        }
        listeners.started(context);
        callRunners(context, applicationArguments);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, listeners);
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
    }

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        listeners.running(context);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　前菜&lt;/h3&gt;
&lt;p&gt;　　　　configureIgnoreBeanInfo(environment)；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_b19bfa83-40ce-4178-a5af-e6f9d8090e79&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b19bfa83-40ce-4178-a5af-e6f9d8090e79&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b19bfa83-40ce-4178-a5af-e6f9d8090e79&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureIgnoreBeanInfo(ConfigurableEnvironment environment) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (System.getProperty(
            CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        Boolean ignore &lt;/span&gt;= environment.getProperty(&quot;spring.beaninfo.ignore&quot;&lt;span&gt;,
                Boolean.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, Boolean.TRUE);
        System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME,
                ignore.toString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180922074206279-221480186.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　配置spring.beaninfo.ignore，并添加到名叫systemProperties的PropertySource中，默认为true即开启，如上图所示。&lt;span&gt;至于spring.beaninfo.ignore配置这个有什么用，什么时候用，暂时还没体现，后续应该会有所体现，我们暂时先将其当做一个疑问放着&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　printBanner(environment)；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_72a81352-ae6f-40d2-8915-be7fecbeb205&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_72a81352-ae6f-40d2-8915-be7fecbeb205&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_72a81352-ae6f-40d2-8915-be7fecbeb205&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Banner printBanner(ConfigurableEnvironment environment) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.bannerMode ==&lt;span&gt; Banner.Mode.OFF) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    ResourceLoader resourceLoader &lt;/span&gt;= (&lt;span&gt;this&lt;/span&gt;.resourceLoader != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceLoader
            : &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultResourceLoader(getClassLoader()));
    SpringApplicationBannerPrinter bannerPrinter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringApplicationBannerPrinter(
            resourceLoader, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.banner);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.bannerMode ==&lt;span&gt; Mode.LOG) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bannerPrinter.print(environment, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainApplicationClass, logger);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bannerPrinter.print(environment, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainApplicationClass, System.out);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　打印banner图，就是下面这个图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180922074109725-1363016679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　并返回Banner对象，后续还会用到。&lt;/p&gt;
&lt;h3&gt;　　正餐&lt;/h3&gt;
&lt;p&gt;　　　　通过前面两道前菜，我相信我们已经胃口大开了，那么请开始我们的正餐 - createApplicationContext&lt;/p&gt;
&lt;p&gt;　　　　源代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_29771e10-6bc8-4d70-bb82-597ff7015ef4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_29771e10-6bc8-4d70-bb82-597ff7015ef4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_29771e10-6bc8-4d70-bb82-597ff7015ef4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Strategy method used to create the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ApplicationContext}. By default this
 * method will respect any explicitly set application context or application context
 * class before falling back to a suitable default.
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the application context (not yet refreshed)
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setApplicationContextClass(Class)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ConfigurableApplicationContext createApplicationContext() {
    Class&lt;/span&gt;&amp;lt;?&amp;gt; contextClass = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationContextClass;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contextClass == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.webApplicationType) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SERVLET:
                contextClass &lt;/span&gt;=&lt;span&gt; Class.forName(DEFAULT_WEB_CONTEXT_CLASS);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; REACTIVE:
                contextClass &lt;/span&gt;=&lt;span&gt; Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                contextClass &lt;/span&gt;=&lt;span&gt; Class.forName(DEFAULT_CONTEXT_CLASS);
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
                    &lt;/span&gt;&quot;Unable create a default ApplicationContext, &quot;
                            + &quot;please specify an ApplicationContextClass&quot;&lt;span&gt;,
                    ex);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　根据SpringApplication的webApplicationType来实例化对应的上下文；如果webApplicationType的值是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext，如果是REACTIVE则实例化AnnotationConfigReactiveWebServerApplicationContext（响应式编程，后续再看），如果既不是SERVLET、也不是REACTIVE，那么则是默认情况（也就是我们所说的非web引用），实例化AnnotationConfigApplicationContext。还记得webApplicationType的值是怎么获取的吗，请点&lt;a href=&quot;https://www.cnblogs.com/youzhibing/p/9550343.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这里&lt;/span&gt;&lt;/a&gt;。很显然我们目前的应用类型是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180922085024573-913602931.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　利用反射调用AnnotationConfigServletWebServerApplicationContext的构造方法进行实例化，期间有对构造方法进行可访问性设置，同时还进行了Kotlin的校验。我们目前应用中不涉及Kotlin，先放着不用看。&lt;/p&gt;
&lt;h4&gt;　　　　AnnotationConfigServletWebServerApplicationContext类图&lt;/h4&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180922094337935-493127842.png&quot; alt=&quot;&quot;/&gt;　　　　AnnotationConfigServletWebServerApplicationContext父级类&lt;/h4&gt;
&lt;p&gt;　　　　　　从类图中我们可知，类结构比较深，我们从上往下来看&lt;span&gt;各个父类的构造方法&lt;/span&gt;（实现的接口先不看），看看构造方法体里面所做的事。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;DefaultResourceLoader&lt;/strong&gt;&lt;/span&gt;，默认资源加载器&lt;/p&gt;
&lt;p&gt;　　　　　　　　获取默认的类加载器，获取的是当前线程的上下文类加载器。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;AbstractApplicationContext&lt;/strong&gt;&lt;/span&gt;，抽象应用上下文&lt;/p&gt;
&lt;p&gt;　　　　　　　　初始化属性resourcePatternResolver，也就是资源模式解析器；实际类型是PathMatchingResourcePatternResolver，它是基于模式匹配的，默认使用AntPathMatcher进行路径匹配，它除了支持ResourceLoader支持的前缀外，还额外支持“classpath*:”用于加载所有匹配的类路径Resource。&lt;/p&gt;
&lt;p&gt;　　　　　　　　另外beanFactoryPostProcessors属性此时已经初始化了，后续肯定会用到，大家注意下。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;GenericApplicationContext&lt;/strong&gt;&lt;/span&gt;，通用应用上下文&lt;/p&gt;
&lt;p&gt;　　　　　　　　初始化属性beanFactory，其类型是DefaultListableBeanFactory，DefaultListableBeanFactory类图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180922202955805-1034368874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;DefaultListableBeanFactory的父级类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　我们根据上图，从上往下读&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;SimpleAliasRegistry&lt;/strong&gt;，简单别名注册器&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　没有明确的定义构造方法，也就是只有默认的无参构造方法，我们可认为只是实例化了自己。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;DefaultSingletonBeanRegistry&lt;/strong&gt;，默认单例bean注册器，用于注册共享的单例bean&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　没有明确的定义构造方法，也就是只有默认的无参构造方法，我们可认为只是实例化了自己。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;FactoryBeanRegistrySupport&lt;/strong&gt;，工厂bean注册器支持，用于注册工厂bean单例&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　没有明确的定义构造方法，也就是只有默认的无参构造方法，我们可认为只是实例化了自己。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;AbstractBeanFactory&lt;/strong&gt;，抽象bean工厂&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　无参构造方法体内为空，我们可认为只是实例化了自己。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;AbstractAutowireCapableBeanFactory&lt;/strong&gt;，抽象的有自动装配装配能力的bean工厂，赋予了自动装配功能&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　该类提供bean创建（具有构造函数解析），属性填充，接线（包括自动装配）和初始化。 处理运行时bean引用，解析托管集合，调用初始化方法等。支持自动装配构造函数，按名称的属性和按类型的属性。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　无参构造方法中，添加了三个非自动装配的接口：BeanNameAware、BeanFactoryAware和BeanClassLoaderAware。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;DefaultListableBeanFactory&lt;/strong&gt;，ListableBeanFactory的默认实现&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　该类用于注册所有bean定义、也可用作独立的bean工厂，当然也可以用作我们自定义bean工厂的父类。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　无参构造方法中也只是调用了super()，我们可认为只是实例化了自己。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;GenericWebApplicationContext&lt;/strong&gt;&lt;/span&gt;，通用web应用上下文，在GenericApplicationContext基础上增加web支持&lt;/p&gt;
&lt;p&gt;　　　　　　　　无参构造方法中，只是调用了super()，我们可认为只是实例化了自己。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;&lt;span&gt;ServletWebServerApplicationContext&lt;/span&gt;&lt;/strong&gt;，servlet web服务应用上下文，能够从自身引导，创建，初始化和运行WebServer&lt;/p&gt;
&lt;p&gt;　　　　　　　　无参构造方法中是空内容，我们可认为只是实例化了自己。&lt;/p&gt;
&lt;p&gt;　　　　　　DefaultListableBeanFactory类图中，有很多类的属性值得我们留意，比如&lt;span&gt;SimpleAliasRegistry的aliasMap、DefaultSingletonBeanRegistry的singletonObjects、singletonFactories和earlySingletonObjects、FactoryBeanRegistrySupport的factoryBeanObjectCache、AbstractBeanFactory的beanPostProcessors、AbstractAutowireCapableBeanFactory的ignoredDependencyInterfaces、DefaultListableBeanFactory中的属性beanDefinitionMap和beanDefinitionNames&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　AnnotationConfigServletWebServerApplicationContext类图中，也有很多类的属性值得我们留意，比如&lt;span&gt;AbstractApplicationContext的beanFactoryPostProcessors、GenericApplicationContext的beanFactory（就是DefaultListableBeanFactory）、GenericWebApplicationContext的servletContext、ServletWebServerApplicationContext的webServer和servletConfig&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;　　　　AnnotationConfigServletWebServerApplicationContext构造方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Create a new {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AnnotationConfigServletWebServerApplicationContext} that needs
 * to be populated through {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #register} calls and then manually
 * {&lt;/span&gt;&lt;span&gt;@linkplain&lt;/span&gt;&lt;span&gt; #refresh refreshed}.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AnnotationConfigServletWebServerApplicationContext() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.reader = &lt;span&gt;new&lt;/span&gt; AnnotatedBeanDefinitionReader(&lt;span&gt;this&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化注解bean定义读取器&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.scanner = &lt;span&gt;new&lt;/span&gt; ClassPathBeanDefinitionScanner(&lt;span&gt;this&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化类路径bean定义扫描器&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　构造方法中的内容也比较简单，就是实例化两个bean，并赋值给自己的属性。我们接着往下看，AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner到底是什么，构造方法中到底做了什么？&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;AnnotatedBeanDefinitionReader&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　从类注释上来看，作用就是用于编程式注解bean的注册，例如我们平时用到的@Component，还有@Configuration类下的@Bean等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://files.cnblogs.com/files/youzhibing/AnnotatedBeanDefinitionReader.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　构造方法中调用getOrCreateEnvironment(registry)来获取environment；大家调试跟进的话会发现，此处新实例化了StandardServletEnvironment，大家还记得&lt;a href=&quot;https://www.cnblogs.com/youzhibing/p/9622441.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;SpringApplication中的environmen&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;/a&gt;吗，它也是StandardServletEnvironment实例，&lt;span&gt;那么此处为什么还要新new一个StandardServletEnvironment呢&lt;/span&gt;，总结中给大家答案。&lt;/p&gt;
&lt;p&gt;　　　　　　　　属性ConditionEvaluator conditionEvaluator，大家留意下属性类型ConditionEvaluator ，通常用来评估@Conditional。&lt;/p&gt;
&lt;p&gt;　　　　　　　　另外还注册了注解配置处理器：AnnotationAwareOrderComparator、ContextAnnotationAutowireCandidateResolver、ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor、EventListenerMethodProcessor、DefaultEventListenerFactory。&lt;/p&gt;
&lt;p&gt;　　　　　　　　此时beanFactory属性如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180923104917813-883064328.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;ClassPathBeanDefinitionScanner&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　从类注释上来看，就是一个bean定义扫描器，用来扫描类路径下的bean侯选者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180923110435225-518820694.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　其中registerDefaultFilters，注册了两个AnnotationTypeFilter：一个针对@Component，一个针对@ManagedBean&lt;/p&gt;
&lt;p&gt;　　　　　　　　此时beanFactory属性如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747662/201809/747662-20180923111734104-1774774512.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　此时虽然已经创建了应用上下文，但还只是具有一个骨架（填充了少部分内容），后续会往这个骨架上填充器官和肉体，来构成一个完整的应用。那往哪填充呢？就是我们上面提的到个各个类中的属性。&lt;/p&gt;
&lt;h3&gt;　　甜点&lt;/h3&gt;
&lt;p&gt;　　　　上面讲了那么多，相信大家此时有点蒙，看似一个简单的createApplicationContext，却引发了一系列类的实例化；大家主要关注上述两个类图中父级类，对每个类进行一遍通读，大致了解下每个类中有些什么属性。后续肯定会对这些属性进行填充，并利用这些属性完成我们的应用。&lt;/p&gt;
&lt;p&gt;　　　　有时候，不是对手有多强大，只是我们不敢去尝试；勇敢踏出第一步，你会发现自己比想象中更优秀！诚如海因斯第一次跑进人类10s大关时所说：上帝啊，原来那扇门是虚掩着的！&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1、文中疑问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　AnnotatedBeanDefinitionReader中为什么还要实例化一个StandardServletEnvironment？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　我们可以把这个问题变一下，为什么不把SpringApplication中的environment直接注入到AnnotatedBeanDefinitionReader，而是要在AnnotatedBeanDefinitionReader中实例化新的StandardServletEnvironment？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　我们看下类所在的包可知，SpringApplication是Spring boot的特有的类，而AnnotatedBeanDefinitionReader是spring中的类，我们知道spring boot依赖spring，但spring不依赖spring boot，那么我们在spring中能用spring boot特有的内容吗？我们可能又有另外的疑问了，&lt;span&gt;那为什么不先实例化spring中的StandardServletEnvironment，然后将它赋值给SpringApplication&lt;/span&gt;，就目前而言，我也不知道，不过在后续应该能找到答案，我们暂且先当一个疑问留着。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、AnnotatedBeanDefinitionReader与ClassPathBeanDefinitionScanner&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　前者是注解bean定义读取器，用于编程式注解bean的注册；后者是类路径bean定义扫描器，用于检测类路径上的bean候选者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　AnnotatedBeanDefinitionReade用来加载class类型的配置，在它初始化的时候，会预先注册一些BeanPostProcessor和BeanFactoryPostProcessor，这些处理器会在接下来的spring初始化流程中被调用。ClassPathBeanDefinitionScanner是一个扫描指定类路径中注解Bean定义的扫描器，在它初始化的时候，会初始化一些需要被扫描的注解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、BeanDefinition&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Spring容器里通过BeanDefinition对象来表示Bean，BeanDefinition描述了Bean的配置信息；根据BeanDefinition实例化bean，并放到bean缓存中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、spring bean配置方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　有三种：基于XML的配置方式 、基于注解的配置方式和基于Java类的配置方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　基于XML，这个我们都很熟，类似：&amp;lt;bean id=&quot;xx&quot; class=&quot;xxx&quot; /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　基于注解，这个我们也用的比较多，入@Component、@Service、@Controller等&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　基于java类，spring的推荐配置方式，@Configuration配合@Bean　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5、createApplicationContext到底做了什么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　说的简单点：创建web应用上下文，对其部分属性：reader、scanner、beanFactory进行了实例化；reader中实例化了属性conditionEvaluator；scanner中添加了两个AnnotationTypeFilter：一个针对@Component，一个针对@ManagedBean；beanFactory中注册了8个注解配置处理器。这些就目前而言，可能没提现其作用，后续肯定会用到的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/&quot; target=&quot;_blank&quot;&gt;Spring Boot Reference Guide&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring boot 源码&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 00:58:00 +0000</pubDate>
<dc:creator>youzhibing2904</dc:creator>
<og:description>前言 此系列是针对springboot的启动，旨在于和大家一起来看看springboot启动的过程中到底做了一些什么事。如果大家对springboot的源码有所研究，可以挑些自己感兴趣或者对自己有帮助</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youzhibing/p/9686969.html</dc:identifier>
</item>
<item>
<title>大数据需要学什么? - 大叔据</title>
<link>http://www.cnblogs.com/uncleData/p/9693320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uncleData/p/9693320.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意本文非广告，阅读时间四分钟左右，适合大数据入门级读者阅读&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;大数据需要学习什么？很多人问过我这个问题。每一次回答完都觉得自己讲得太片面了，总是没有一个合适的契机去好好总结这些内容，直到开始写这篇东西。大数据是近五年兴起的行业，发展迅速，很多技术经过这些年的迭代也变得比较成熟了，同时新的东西也不断涌现，想要保持自己竞争力的唯一办法就是不断学习。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面的是我整理的一张思维导图，内容分成几大块，包括了分布式计算与查询，分布式调度与管理，持久化存储，大数据常用的编程语言等等内容，每个大类下有很多的开源工具，这些就是作为大数据程序猿又爱又恨折腾得死去活来的东西了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491039/201809/1491039-20180921155211499-588474554.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;Java&lt;/h2&gt;
&lt;p&gt;java可以说是大数据最基础的编程语言，据我这些年的经验，我接触的很大一部分的大数据开发都是从Jave Web开发转岗过来的（当然也不是绝对我甚至见过产品转岗大数据开发的，逆了个天）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是因为大数据的本质无非就是海量数据的计算，查询与存储，后台开发很容易接触到大数据量存取的应用场景&lt;/li&gt;
&lt;li&gt;二就是java语言本事了，天然的优势，因为大数据的组件很多都是用java开发的像HDFS,Yarn,Hbase,MR,Zookeeper等等，想要深入学习，填上生产环境中踩到的各种坑，必须得先学会java然后去啃源码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说到啃源码顺便说一句，开始的时候肯定是会很难，需要对组件本身和开发语言都有比较深入的理解，熟能生巧慢慢来，等你过了这个阶段，习惯了看源码解决问题的时候你会发现源码真香。&lt;/p&gt;
&lt;h2 id=&quot;scala&quot;&gt;Scala&lt;/h2&gt;
&lt;p&gt;scala和java很相似都是在jvm运行的语言，在开发过程中是可以无缝互相调用的。Scala在大数据领域的影响力大部分都是来自社区中的明星Spark和kafka,这两个东西大家应该都知道（后面我会有文章多维度介绍它们），它们的强势发展直接带动了Scala在这个领域的流行。&lt;/p&gt;
&lt;h2 id=&quot;python和shell&quot;&gt;Python和Shell&lt;/h2&gt;
&lt;p&gt;shell应该不用过多的介绍非常的常用，属于程序猿必备的通用技能。python更多的是用在数据挖掘领域以及写一些复杂的且shell难以实现的日常脚本。&lt;/p&gt;

&lt;p&gt;什么是分布式计算？分布式计算研究的是如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多服务器进行处理，最后把这些计算结果综合起来得到最终的结果。&lt;/p&gt;
&lt;p&gt;举个栗子，就像是组长把一个大项目拆分，让组员每个人开发一部分，最后将所有人代码merge，大项目完成。听起来好像很简单，但是真正参与过大项目开发的人一定知道中间涉及的内容可不少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如这个大项目如何拆分？任务如何分配？每个人手头已有工作怎么办？每个人能力不一样怎么办？每个人开发进度不一样怎么办？开发过程中组员生病要请长假他手头的工作怎么办？指挥督促大家干活的组长请假了怎么办？最后代码合并过程出现问题怎么办？项目延期怎么办？项目最后黄了怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仔细想想上面的夺命十连问，其实每一条都是对应了分布式计算可能会出现的问题，具体怎么对应大家思考吧我就不多说了，其实已经是非常明显了。也许有人觉得这些问题其实在多人开发的时候都不重要不需要特别去考虑怎么办，但是在分布式计算系统中不一样，每一个都是非常严重并且非常基础的问题，需要有很好的解决方案。&lt;/p&gt;
&lt;p&gt;最后提一下，分布式计算目前流行的工具有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;离线工具Spark，MapReduce等&lt;/li&gt;
&lt;li&gt;实时工具Spark Streaming，Storm，Flink等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这几个东西的区别和各自的应用场景我们之后再聊。&lt;/p&gt;

&lt;p&gt;传统的网络存储系统采用的是集中的存储服务器存放所有数据，单台存储服务器的io能力是有限的，这成为了系统性能的瓶颈，同时服务器的可靠性和安全性也不能满足需求，尤其是大规模的存储应用。&lt;/p&gt;
&lt;p&gt;分布式存储系统，是将数据分散存储在多台独立的设备上。采用的是可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491039/201809/1491039-20180923163220973-309243746.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是hdfs的存储架构图，hdfs作为分布式文件系统，兼备了可靠性和扩展性，数据存储3份在不同机器上（两份存在同一机架，一份存在其他机架）保证数据不丢失。由NameNode统一管理元数据，可以任意扩展集群。&lt;/p&gt;
&lt;p&gt;主流的分布式数据库有很多hbase，mongoDB，GreenPlum，redis等等等等，没有孰好孰坏之分，只有合不合适，每个数据库的应用场景都不同，其实直接比较是没有意义的，后续我也会有文章一个个讲解它们的应用场景原理架构等。&lt;/p&gt;

&lt;p&gt;现在人们好像都很热衷于谈&quot;去中心化&quot;，也许是区块链带起的这个潮流。但是&quot;中心化&quot;在大数据领域还是很重要的，至少目前来说是的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式的集群管理需要有个组件去分配调度资源给各个节点，这个东西叫yarn;&lt;/li&gt;
&lt;li&gt;需要有个组件来解决在分布式环境下&quot;锁&quot;的问题，这个东西叫zookeeper；&lt;/li&gt;
&lt;li&gt;需要有个组件来记录任务的依赖关系并定时调度任务，这个东西叫azkaban。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然这些“东西”并不是唯一的，其实都是有很多替代品的，我这里只举了几个比较常用的例子。&lt;/p&gt;

&lt;p&gt;回答完这个问题，准备说点其他的。最近想了很久，准备开始写一系列的文章，记录这些年来的所得所想，感觉内容比较多不知从哪里开始，就画了文章开头的思维导图确定了大的方向，大家都知道大数据的主流技术变化迭代很快，不断会有新的东西加入，所以这张图里内容也会根据情况不断添加。细节的东西我会边写边定，大家也可以给我一些建议，我会根据写的内容实时更新这张图以及下面的目录。&lt;/p&gt;
&lt;h2 id=&quot;关于分组&quot;&gt;关于分组&lt;/h2&gt;
&lt;p&gt;上面的大数据组件分组其实是比较纠结的，特别是作为一个有强迫症的程序猿，有些组件好像放在其他组也可以，而且我又不想要分太多的组看起来会很乱，所以上面这张图的分组方式会稍主观一些。分组方式肯定不是绝对的。&lt;/p&gt;
&lt;p&gt;举个例子，像kafka这种消息队列一般不会和其它的数据库或者像HDFS这种文件系统放在一起，但是它们同样都具备有分布式持久化存储的功能，所以就把它们放在一块儿了；还有openTsDB这种时序数据库，说是数据库实际上只是基于HBase上的一个应用，我觉得这个东西更侧重于查询和以及用何种方式存储，而不在于存储本身，所以就主观地放在了“分布式计算与查询”这一类，还有OLAP的工具也同样放在了这一组。&lt;/p&gt;
&lt;p&gt;同样的情况还存在很多，大家有异议也可以说出来讨论下。&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;大家都知道大数据的技术日新月异，作为一个程序猿想要保持竞争力就必须得不断地学习。写这些文章的目的比较简单，&lt;strong&gt;一是可以当做一个笔记，梳理知识点；二是希望能帮到一些人了解学习大数据&lt;/strong&gt;。每一篇的篇幅不会太长，阅读时间控制在5到10分钟。我的公众号大叔据，会同步更新。喜欢看公众号文章的同学可以关注下，文章的篇幅不会太长，不会占用你太多的阅读时间，每天花一点时间学习，长期积累总是会有收获的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3334524-a32f634684a8d101.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;欢迎关注大叔&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 24 Sep 2018 00:38:00 +0000</pubDate>
<dc:creator>大叔据</dc:creator>
<og:description>注意本文非广告，阅读时间四分钟左右，适合大数据入门级读者阅读 大数据需要学习什么？很多人问过我这个问题。每一次回答完都觉得自己讲得太片面了，总是没有一个合适的契机去好好总结这些内容，直到开始写这篇东西</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uncleData/p/9693320.html</dc:identifier>
</item>
</channel>
</rss>