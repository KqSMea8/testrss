<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【JDK源码分析】深入源码分析CountDownLatch - 还是搬砖踏实</title>
<link>http://www.cnblogs.com/d-homme/p/9375105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/d-homme/p/9375105.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-3&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33.886925795053&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;CountDownLatch是一个闭锁实现，它可以使一个或者多个线程等待一组事件发生。它包含一个计数器，用来表示需要等待的事件数量，coutDown方法用于表示一个事件发生，计数器随之递减，而await方法等待计数器为0之前一直阻塞。它是基于AQS的共享锁来实现的，其中使用了较多的AQS的方法，所以在这之前最好阅读过AQS的源码，不嫌弃也可以查看本人之前&lt;a href=&quot;https://www.cnblogs.com/d-homme/p/9357006.html&quot; target=&quot;_blank&quot;&gt;AQS的源码分析&lt;/a&gt;，有些AQS方法没有在之前分析过的这里涉及到了会进行分析。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-4&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;我们先看它的属性和构造器，&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sync为其内部类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Sync sync;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唯一的一个构造器
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造参数count就是需要等待事件的数量&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CountDownLatch(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了保证count &amp;gt;= 0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (count &amp;lt; 0) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;count &amp;lt; 0&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造sync&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync(count);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在来看内部类Sync，它继承了AQS，实现了共享锁方法，下面来看其源码，代码行数不多很好理解&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-6&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 4982264981922014374L&lt;span&gt;;

        Sync(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setState 为AQS更改其state变量的方法
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将AQS state变量设置成count&lt;/span&gt;
&lt;span&gt;            setState(count);
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AQS的获取state锁状态值&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getState();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试获取共享锁&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回1表示此时锁状态值为0表示锁已释放
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1表示此时锁状态值大于0，表示出于锁定状态&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; (getState() == 0) ? 1 : -1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试释放共享锁（计数器递减releases次）&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decrement count; signal when transition to zero
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待锁状态值为0或者更改锁状态值成功&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将state赋值给变量c&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时锁已清除&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递减&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; nextc = c-1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较state的状态值是否等于C,等于将state状态值改为nextc&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetState(c, nextc))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更改成功后，如果nextc为0则返回true&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; nextc == 0&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-7&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h4 id=&quot;await方法&quot;&gt;await方法&lt;/h4&gt;
&lt;p&gt;await方法就是当state状态值不为0时将当前线程阻塞，然后等待唤醒&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; await() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用的AQS获取共享锁可中断方法&lt;/span&gt;
        sync.acquireSharedInterruptibly(1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来看看AQS的acquireSharedInterruptibly方法&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-9&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;34.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此方法调用的是CountDownLatch内部类Sync的方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果锁状态不为0，则执行doAcquireSharedInterruptibly方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; 0&lt;span&gt;)
            doAcquireSharedInterruptibly(arg);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;doAcquireSharedInterruptibly方法也是由AQS实现的&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-10&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一个共享锁节点到队列&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.SHARED);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直到线程被唤醒或者线程被中断时跳出循环&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node节点的前驱节点&lt;/span&gt;
                &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用CountDownLatch内部类Sync的方法
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果锁状态值为0，则返回值大于0&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r &amp;gt;= 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当锁状态值为0，开始将note节点设置为头节点并唤醒后继节点
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是队列不断的出列，然后唤醒后继节点，后继节点被唤醒后由于前驱节点被设置成头节点，又会调用该方法进行后继节点的唤醒&lt;/span&gt;
&lt;span&gt;                        setHeadAndPropagate(node, r);
                        p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                        failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 shouldParkAfterFailedAcquire用于清除已中断/或者取消的线程以及判断此次循环是否需要挂起线程
                 parkAndCheckInterrupt 挂机当前线程
                 shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 在AQS之前博文里分析过这里就不再分析了
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示当前线程中断，取消获取锁
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前分析过，略过源码分析&lt;/span&gt;
&lt;span&gt;                cancelAcquire(node);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;setHeadAndPropagate方法，主要作用是唤醒后继节点线程&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-11&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeadAndPropagate(Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; propagate) {
        Node h &lt;/span&gt;=&lt;span&gt; head; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点设置为头节点，节点关联的线程设置为空&lt;/span&gt;
&lt;span&gt;        setHead(node)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (propagate &amp;gt; 0 || h == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0 ||&lt;span&gt;
            (h &lt;/span&gt;= head) == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0&lt;span&gt;) {
            Node s &lt;/span&gt;=&lt;span&gt; node.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; s.isShared())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点等待状态为signal时，唤醒后继节点线程&lt;/span&gt;
&lt;span&gt;                doReleaseShared();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;doReleaseShared很巧妙，当当前节点等待状态为signal时，唤醒后继节点线程&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            Node h &lt;/span&gt;=&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程等待状态为signal时表示后继节点需要唤醒&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, 0&lt;span&gt;))
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示h节点的状态替换失败，会再次循环判断h节点的状态&lt;/span&gt;
                        &lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒后继节点&lt;/span&gt;
&lt;span&gt;                    unparkSuccessor(h);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 状态为0时，将其改成PROPAGATE，更改失败会再次循环判断h节点的状态&lt;br/&gt;　　　　　　　　　 // 这种情况发生在一个线程调用await方法，节点的等待状态还是初始值0未来得及被修改，刚好state被置为0然后调用了doReleaseShared方法&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == 0 &amp;amp;&amp;amp;
                         !compareAndSetWaitStatus(h, 0&lt;span&gt;, Node.PROPAGATE))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h4 id=&quot;countdown方法&quot;&gt;countDown方法&lt;/h4&gt;
&lt;p&gt;countDown方法递减state值，当值为0时，依次唤醒等待的线程&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-14&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; countDown() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递减一次state值，知道state为0时唤醒等待中的线程&lt;/span&gt;
        sync.releaseShared(1&lt;span&gt;);
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试将state减去arg&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state为0时唤醒线程&lt;/span&gt;
&lt;span&gt;            doReleaseShared();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-15&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot;&gt;
&lt;p&gt;到此分析完毕。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-16&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot;&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;通过源码知道CountDownLatch 不能像CyclicBarrier那样使用完毕后还可以复用；&lt;/li&gt;
&lt;li&gt;CountDownLatch 是通过共享锁来实现的，它的构造参数就是AQS state的值；&lt;/li&gt;
&lt;li&gt;由于内部类继承了AQS，所以它内部也是FIFO队列，同时也一样是前驱节点唤醒后继节点。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 26 Jul 2018 15:33:00 +0000</pubDate>
<dc:creator>还是搬砖踏实</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/d-homme/p/9375105.html</dc:identifier>
</item>
<item>
<title>SpringBoot23 分模块开发 - CRUD_Architect</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/9375107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/9375107.html</guid>
<description>
&lt;h2&gt;1 开发环境说明&lt;/h2&gt;
&lt;p&gt;　　JDK：1.8&lt;/p&gt;
&lt;p&gt;　　MAVEN：3.5&lt;/p&gt;
&lt;p&gt;　　IDEA：2017.2.5&lt;/p&gt;
&lt;p&gt;　　SpringBoot：2.0.3.RELEASE&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726220329184-93710895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2 创建SpringBoot项目&lt;/h2&gt;
&lt;h3&gt;　　2.1 项目信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726220457186-905101547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2.2 添加项目依赖&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726221323919-1807377251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2.3 修改pom文件&lt;/h3&gt;
&lt;p&gt;　　　　添加lombok依赖、修改devtools、修改plugin&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_58ae49cc-2b3b-4ad7-b94f-04357cadfbd4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_58ae49cc-2b3b-4ad7-b94f-04357cadfbd4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_58ae49cc-2b3b-4ad7-b94f-04357cadfbd4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.xiangxu&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;module-demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;module-demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Demo project for Spring Boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.3.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-devtools&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/org.projectlombok/lombok &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.projectlombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.18.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;provided&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;3 逻辑功能实现&lt;/h2&gt;
&lt;p&gt;　　实现简单的增删改查，利用map来模拟内存数据库&lt;/p&gt;
&lt;h3&gt;　　3.1 包结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726222934135-1555634696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3.2 model层&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_ae8856c5-208e-4921-8c77-4612af37bd48&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ae8856c5-208e-4921-8c77-4612af37bd48&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ae8856c5-208e-4921-8c77-4612af37bd48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.xiangxu.moduledemo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 王杨帅
 * @create 2018-07-26 22:16
 * @desc 学生实体类
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3.3 repository层&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_04c13e1b-66a9-4b8d-acb8-aea365210220&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04c13e1b-66a9-4b8d-acb8-aea365210220&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_04c13e1b-66a9-4b8d-acb8-aea365210220&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.xiangxu.moduledemo.repository;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.xiangxu.moduledemo.model.Student;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Repository;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 王杨帅
 * @create 2018-07-26 22:17
 * @desc 学生持久层
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Repository
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentRepository {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 利用Map模拟内存数据库
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Integer, Student&amp;gt; repository =&lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 主键发生器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger idGenerator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 新增
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; student
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student save(Student student) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 产生ID&lt;/span&gt;
        Integer id =&lt;span&gt; idGenerator.incrementAndGet();
        student.setId(id);
        student.setName(student.getName() &lt;/span&gt;+&lt;span&gt; id);
        repository.put(id, student);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; student;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取列表
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Collection&amp;lt;Student&amp;gt;&lt;span&gt; findAll() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; repository.values();
    }



}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3.4 web层&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_983b8ae4-1624-4a1b-8d63-75b931b71e76&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_983b8ae4-1624-4a1b-8d63-75b931b71e76&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_983b8ae4-1624-4a1b-8d63-75b931b71e76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.xiangxu.moduledemo.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.xiangxu.moduledemo.model.Student;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.xiangxu.moduledemo.repository.StudentRepository;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.web.bind.annotation.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collection;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 王杨帅
 * @create 2018-07-26 22:23
 * @desc 学生控制层
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@RequestMapping(value &lt;/span&gt;= &quot;/student&quot;&lt;span&gt;)
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StudentRepository studentRepository;

    @GetMapping
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Collection&amp;lt;Student&amp;gt;&lt;span&gt; findAll() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentRepository.findAll();
    }

    @PostMapping
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student save(@RequestBody Student student) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentRepository.save(student);
    }

    @GetMapping(value &lt;/span&gt;= &quot;/connect&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String connect() {
        String result &lt;/span&gt;= &quot;前后端连接成功&quot;&lt;span&gt;;
        log.info(result);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3.5 启动应用并进行测试&lt;/h3&gt;
&lt;p&gt;　　　　》新增&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726223214426-1863577928.png&quot; alt=&quot;&quot; width=&quot;877&quot; height=&quot;583&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　》查询列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726223243632-1209389770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3.6 打包&lt;/h3&gt;
&lt;p&gt;　　　　进入到项目根目录执行：mvn -Dmaven.test.skip -U clean package&lt;/p&gt;
&lt;p&gt; 　　　　技巧01：执行完后会在根目录下的target目录下生成class文件和打包文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726223458745-1263184026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726223545660-1488165196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3.7 执行jar包&lt;/h3&gt;
&lt;p&gt;　　　　技巧01：进入到jar包所在文件夹执行：java -jar jar包名称 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726223658065-1712207504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726223710139-1735919723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3.8 重复3.5操作&lt;/h3&gt;

&lt;h2&gt;4 分模块&lt;/h2&gt;
&lt;p&gt;　　需求：在上面的例子中，将model、repository、controller都写在了一个模块中；现在需要将它们写在不同的模块中&lt;/p&gt;
&lt;h3&gt;　　4.1 修改当前项目的pom.xml文件&lt;/h3&gt;
&lt;p&gt;　　　　将打包方式从jar改成pom，让当前项目作为主模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726224043492-1012399151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　4.2 新建一个web模块&lt;/h3&gt;
&lt;p&gt;　　　　技巧01：右键单击主模块根文件夹 -&amp;gt; module -&amp;gt; maven&lt;/p&gt;
&lt;p&gt;　　　　技巧02：子模块创建成功后会放在父模块根目录下&lt;/p&gt;
&lt;p&gt;　　　　技巧03：新建完成后，在主模块中会出现子模块的相关信息，在子模块中也会将主模块作为父模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726224522799-290002947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726224603022-1471442477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726224245511-63525774.png&quot; alt=&quot;&quot; width=&quot;919&quot; height=&quot;610&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 　　4.2.1 代码移动&lt;/h4&gt;
&lt;p&gt;　　　　技巧01：设置子模块的文件夹， 左键单击子模块文件夹 -&amp;gt; file菜单 -&amp;gt; projectstructure&lt;/p&gt;
&lt;p&gt;　　　　技巧02：将父模块中的src的java文件中的所哟文件移动到web模块中src的java文件中，resources和test做类似的操作&lt;/p&gt;
&lt;p&gt;　　　　技巧03：直接利用鼠标选中拖动就行啦，弹出的提示框要选择移动所有选项；再次弹出的选择continue&lt;/p&gt;
&lt;p&gt;　　　　技巧04：移动完成后刷新maven&lt;/p&gt;
&lt;p&gt;　　　　技巧05：刷新maven后进入到主函数启动应用进行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726225044601-828850273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726225152316-755458658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726224802996-1583345739.png&quot; alt=&quot;&quot; width=&quot;932&quot; height=&quot;551&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　4.3 创建model模块和repository模块&lt;/h3&gt;
&lt;p&gt;　　　　将model相关的移动到model模块，将repository相关的移动到repository模块&lt;/p&gt;
&lt;p&gt;　　　　技巧01：包名要保持一致，这样是为了不用改动代码&lt;/p&gt;
&lt;p&gt;　　　　坑01：移动完成后会有代码报错，因为repository依赖model，web又依赖repository&lt;/p&gt;
&lt;p&gt;　　　　解决01：在repository模块中引入model依赖，在web模块中引入repository依赖&lt;/p&gt;
&lt;p&gt;　　　　技巧02：依赖引入后刷新maven&lt;/p&gt;
&lt;p&gt;　　　　技巧03：找到main函数启动测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726230352024-2146600407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726230402286-23399979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5 打包&lt;/h2&gt;
&lt;h3&gt;　　5.1 进入到主模块执行：mvn -Dmaven.test.skip -U clean package&lt;/h3&gt;
&lt;p&gt;　　　　-Dmaven.test.skip -&amp;gt; 跳过测试&lt;/p&gt;
&lt;p&gt;　　　　-U -&amp;gt; 更新包&lt;/p&gt;
&lt;p&gt;　　　　clean -&amp;gt; ？？&lt;/p&gt;
&lt;p&gt;　　　　坑01：提示找不到main函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726231205735-1286322340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　解决01：在maven插件中添加main函数的路径【注意：maven插件的相关信息在主模块的pom.xml中，而main函数在web模块中】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726231531251-242979771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　坑02：再次启动时提示一些包找不到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726231726907-1365574255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　原因02：maven相关配置和main函数不在一个模块时就会报这种错误&lt;/p&gt;
&lt;p&gt;　　　　解决02：将maven相关的配置信息移动到main函数所在的那个模块【本案例是将主模块中的maven配置信息移动到web模块中去】&lt;/p&gt;
&lt;p&gt;　　　　技巧01：移动完后再次执行 mvn -Dmaven.test.skip -U clean package &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726232017404-236034689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　5.2 通过jar包启动应用&lt;/h3&gt;
&lt;p&gt;　　　　技巧01：由于maven的相关配置在web模块下，所以产生的jar信息在web模块下的target文件中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726232233660-930186219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　技巧02：进入到web模块的target文件夹，启动相关jar包即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201807/1057762-20180726232301771-1966562475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　5.3 重复3.5操作&lt;/h3&gt;









</description>
<pubDate>Thu, 26 Jul 2018 15:33:00 +0000</pubDate>
<dc:creator>CRUD_Architect</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/9375107.html</dc:identifier>
</item>
<item>
<title>Spring_总结_01_Spring概述 - shirayner</title>
<link>http://www.cnblogs.com/shirui/p/9373606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shirui/p/9373606.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;从今天开始，重新总结一下Spring的相关知识，主要是结合《Spring实战（第四版）》和 《JavaEE开发的颠覆者——SpringBoot实战》这两本书以及官方文档，同时加入自己的一点点点小小小理解，如有不当之处，还请指正。&lt;/p&gt;

&lt;h2&gt;二、Spring最根本的使命&lt;/h2&gt;
&lt;p&gt;Spring框架是一个轻量级的企业级开发的一站式解决方案，所谓解决方案就是可以基于Spring解决JavaEE开发的所有问题。&lt;/p&gt;
&lt;p&gt;事实上，Spring也确实在不断朝这个方向努力，从官方上列出的Spring产品就可以看出，同时这也反映出 &lt;span&gt;Spring最根本的使命：简化Java开发&lt;/span&gt;。&lt;/p&gt;

&lt;h2&gt;三、Spring框架的四大原则&lt;/h2&gt;
&lt;p&gt;为了简化Java开发，Spring框架所有功能的设计和实现都基于四大原则：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）使用POJO进行轻量级和最小侵入式开发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）通过依赖注入和基于接口编程实现松耦合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）通过AOP和默认习惯进行声明式编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）使用AOP和模板（template）减少模式化代码&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;四、Spring 的六大模块&lt;/h2&gt;
&lt;p&gt;Spring是模块化的，这意味着你可以只使用你需要的 Spring 的模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/748623/201807/748623-20180726221245526-2107004714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                          图 1.1 Spring框架由6个定义良好的模块分类组成&lt;/p&gt;

&lt;h3&gt;1.核心容器(Core Container)&lt;/h3&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Spring-Core&lt;/td&gt;
&lt;td&gt;核心工具类，Spring其他模块大量使用Spring-Core;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Spring-Bean&lt;/td&gt;
&lt;td&gt;Spring定义Bean的支持；&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Spring-Context&lt;/td&gt;
&lt;td&gt;运行时Spring容器；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Spring-Context-Support&lt;/td&gt;
&lt;td&gt;Spring容器对第三方包的集成支持；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Spring-Expression &lt;/td&gt;
&lt;td&gt;使用表达式语言在运行时查询和操作对象。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;2.AOP&lt;/h3&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Spring-AOP&lt;/td&gt;
&lt;td&gt;基于代理的AOP支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Spring-Aspects&lt;/td&gt;
&lt;td&gt;基于AspectJ的AOP支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;3.消息（Messaging）&lt;/h3&gt;
&lt;p&gt;Spring-Messaging ：对消息架构和协议的支持。&lt;/p&gt;

&lt;h3&gt;4.Web&lt;/h3&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Spring-Web&lt;/td&gt;
&lt;td&gt;提供基础的Web集成的功能，在Web项目中提供Spring的容器。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Spring-Webmvc&lt;/td&gt;
&lt;td&gt;提供基于Servlet的Spring MVC&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Spring-WebSocket&lt;/td&gt;
&lt;td&gt;提供WebSocket&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Spring-Webmvc-Portlet&lt;/td&gt;
&lt;td&gt;提供Portlet环境支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;4.数据访问/集成（Data Acess / Integration）&lt;/h3&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Spring-JDBC&lt;/td&gt;
&lt;td&gt;提供以JDBC访问数据库的支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Spring-TX&lt;/td&gt;
&lt;td&gt;提供编程式和声明式的事务支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Spring-ORM&lt;/td&gt;
&lt;td&gt;提供对对象/关系映射技术的支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Spring-OXM&lt;/td&gt;
&lt;td&gt;提供对对象/XML映射技术的支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Spring-JMS&lt;/td&gt;
&lt;td&gt;提供对JMS的支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h2&gt;五、Spring的生态&lt;/h2&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Spring Boot&lt;/td&gt;
&lt;td&gt;使用默认开发配置来实现快速开发&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Spring XD&lt;/td&gt;
&lt;td&gt;用来简化大数据应用开发&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Spring Cloud&lt;/td&gt;
&lt;td&gt;为分部式系统开发提供工具集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Spring Data&lt;/td&gt;
&lt;td&gt;对主流的关系型和NoSQL数据库的支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Spring Integration&lt;/td&gt;
&lt;td&gt;通过消息机制对企业集成模式（EIP）的支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;Spring Batch&lt;/td&gt;
&lt;td&gt;简化及优化大量数据的批处理操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;Spring Security&lt;/td&gt;
&lt;td&gt;通过认证和授权保护应用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;Spring HATEOAS&lt;/td&gt;
&lt;td&gt;基于HATEOAS原则简化了REST服务开发&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;Spring Social&lt;/td&gt;
&lt;td&gt;与社交网络API(如Faceook、新浪微博、QQ等)的集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;Spring AMQP&lt;/td&gt;
&lt;td&gt;对基于AMQP的消息的支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Spring Mobile&lt;/td&gt;
&lt;td&gt;提供对手机设备检测的功能，给不同的设备返回不同的页面的支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;Spring for Android&lt;/td&gt;
&lt;td&gt;主要提供在Android上消费RESTful API的功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;Spring Web Flow&lt;/td&gt;
&lt;td&gt;基于Spring MVC提供基于向导流程式的Web应用开发&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;Spring Web Services&lt;/td&gt;
&lt;td&gt;提供了基于协议有限的SOAP/Web服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;Spring LDAP&lt;/td&gt;
&lt;td&gt;简化使用LDAP开发&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;Spring Session&lt;/td&gt;
&lt;td&gt;提供一个API及实现来管理用户会话信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2&gt;六、参考资料&lt;/h2&gt;
&lt;p&gt;1.《Spring实战（第四版）》&lt;/p&gt;
&lt;p&gt;2.《JavaEE开发的颠覆者——SpringBoot实战》&lt;/p&gt;

</description>
<pubDate>Thu, 26 Jul 2018 15:28:00 +0000</pubDate>
<dc:creator>shirayner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shirui/p/9373606.html</dc:identifier>
</item>
<item>
<title>完美数据迁移-MongoDB Stream的应用 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9375045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9375045.html</guid>
<description>&lt;h2 id=&quot;一背景介绍&quot;&gt;一、背景介绍&lt;/h2&gt;
&lt;p&gt;最近微服务架构火的不行，但本质上也只是风口上的一个热点词汇。&lt;br/&gt;作为笔者的经验来说，想要应用一个新的架构需要带来的变革成本是非常高的。&lt;/p&gt;
&lt;p&gt;尽管如此，目前还是有许多企业踏上了服务化改造的道路，这其中则免不了&quot;旧改&quot;的各种繁杂事。&lt;br/&gt;所谓的&quot;旧改&quot;，就是把现有的系统架构来一次重构，拆分成多个细粒度的服务后，然后找时间&lt;br/&gt;升级割接一把，让新系统上线。这其中，&lt;strong&gt;数据的迁移&lt;/strong&gt;往往会成为一个非常重要且繁杂的活儿。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;拆分服务时数据迁移的挑战在哪？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先是难度大，做一个迁移方案需要了解项目的前身今世，评估迁移方案、技术工具等等；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其次是成本高。由于新旧系统数据结构是不一样的，需要定制开发迁移转化功能。很难有一个通用的工具能一键迁移；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;再者，对于一些容量大、可靠性要求高的系统，要能够不影响业务，出了问题还能追溯，因此方案上还得往复杂了想。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二常见方案&quot;&gt;二、常见方案&lt;/h2&gt;
&lt;p&gt;按照迁移的方案及流程，可将数据迁移分为三类：&lt;/p&gt;
&lt;h3 id=&quot;停机迁移&quot;&gt;1. 停机迁移&lt;/h3&gt;
&lt;p&gt;最简单的方案，停机迁移的顺序如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180726230935975-1287608598.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用停机迁移的好处是流程操作简单，工具成本低；然而缺点也很明显，&lt;br/&gt;迁移过程中业务是无法访问的，因此只适合于规格小、允许停服的场景。&lt;/p&gt;
&lt;h3 id=&quot;业务双写&quot;&gt;2. 业务双写&lt;/h3&gt;
&lt;p&gt;业务双写是指对现有系统先进行改造升级，支持同时对新库和旧库进行写入。&lt;br/&gt;之后再通过数据迁移工具对旧数据做全量迁移，待所有数据迁移转换完成后切换到新系统。&lt;/p&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180726230955258-172559890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;业务双写的方案是平滑的，对线上业务影响极小；在出现问题的情况下可重新来过，操作压力也会比较小。&lt;/p&gt;
&lt;p&gt;笔者在早些年前尝试过这样的方案，整个迁移过程确实非常顺利，但实现该方案比较复杂，&lt;br/&gt;需要对现有的代码进行改造并完成新数据的转换及写入，对于开发人员的要求较高。&lt;br/&gt;在业务逻辑清晰、&lt;strong&gt;团队对系统有足够的把控能力&lt;/strong&gt;的场景下适用。&lt;/p&gt;
&lt;h3 id=&quot;增量迁移&quot;&gt;3. 增量迁移&lt;/h3&gt;
&lt;p&gt;增量迁移的基本思路是先进行全量的迁移转换，待完成后持续进行增量数据的处理，直到数据追平后切换系统。&lt;/p&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180726231004210-1520103142.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;要求系统支持增量数据的记录。&lt;br/&gt;对于MongoDB可以利用&lt;strong&gt;oplog&lt;/strong&gt;实现这点，为避免全量迁移过程中oplog被冲掉，&lt;br/&gt;在开始迁移前就必须开始监听oplog，并将变更全部记录下来。&lt;br/&gt;如果没有办法，需要从应用层上考虑，比如为所有的表(集合)记录下updateTime这样的时间戳，&lt;br/&gt;或者升级应用并支持将修改操作单独记录下来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;增量数据的回放是持续的。&lt;br/&gt;在所有的增量数据回放转换过程中，系统仍然会产生新的增量数据，这要求迁移工具&lt;br/&gt;能做到将增量数据持续回放并将之追平，之后才能做系统切换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;MongoDB 3.6版本开始便提供了Change Stream功能，支持对数据变更记录做监听。&lt;br/&gt;这为实现数据同步及转换处理提供了更大的便利，下面将探讨如何利用Change Stream实现数据的增量迁移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三change-stream-介绍&quot;&gt;三、Change Stream 介绍&lt;/h2&gt;
&lt;p&gt;Chang Stream(变更记录流) 是指collection(数据库集合)的变更事件流，应用程序通过&lt;strong&gt;db.collection.watch()&lt;/strong&gt;这样的命令可以获得被监听对象的实时变更。&lt;br/&gt;在该特性出现之前，你可以通过拉取 &lt;strong&gt;oplog&lt;/strong&gt;达到同样的目的；但 oplog 的处理及解析相对复杂且存在被回滚的风险，如果使用不当的话还会带来性能问题。&lt;br/&gt;Change Stream 可以与&lt;a href=&quot;https://docs.mongodb.com/manual/aggregation/&quot;&gt;aggregate framework&lt;/a&gt;结合使用，对变更集进行进一步的过滤或转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;由于Change Stream 利用了存储在 oplog 中的信息，因此对于单进程部署的MongoDB无法支持Change Stream功能，&lt;br/&gt;其只能用于启用了副本集的独立集群或分片集群&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;监听的目标&quot;&gt;监听的目标&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;单个集合&lt;/td&gt;
&lt;td&gt;除系统库(admin/local/config)之外的集合，3.6版本支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;单个数据库&lt;/td&gt;
&lt;td&gt;除系统库(admin/local/config)之外的数据库集合，4.0版本支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;整个集群&lt;/td&gt;
&lt;td&gt;整个集群内除去系统库( (admin/local/config)之外的集合 ，4.0版本支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;变更事件&quot;&gt;变更事件&lt;/h3&gt;
&lt;p&gt;一个&lt;strong&gt;Change Stream Event&lt;/strong&gt;的基本结构如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
   _id : { &amp;lt;BSON Object&amp;gt; },
   &quot;operationType&quot; : &quot;&amp;lt;operation&amp;gt;&quot;,
   &quot;fullDocument&quot; : { &amp;lt;document&amp;gt; },
   &quot;ns&quot; : {
      &quot;db&quot; : &quot;&amp;lt;database&amp;gt;&quot;,
      &quot;coll&quot; : &quot;&amp;lt;collection&quot;
   },
   &quot;documentKey&quot; : { &quot;_id&quot; : &amp;lt;ObjectId&amp;gt; },
   &quot;updateDescription&quot; : {
      &quot;updatedFields&quot; : { &amp;lt;document&amp;gt; },
      &quot;removedFields&quot; : [ &quot;&amp;lt;field&amp;gt;&quot;, ... ]
   }
   &quot;clusterTime&quot; : &amp;lt;Timestamp&amp;gt;,
   &quot;txnNumber&quot; : &amp;lt;NumberLong&amp;gt;,
   &quot;lsid&quot; : {
      &quot;id&quot; : &amp;lt;UUID&amp;gt;,
      &quot;uid&quot; : &amp;lt;BinData&amp;gt;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;字段说明&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;_id&lt;/td&gt;
&lt;td&gt;变更事件的Token对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;operationType&lt;/td&gt;
&lt;td&gt;变更类型(见下面介绍)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;fullDocument&lt;/td&gt;
&lt;td&gt;文档内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ns&lt;/td&gt;
&lt;td&gt;监听的目标&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ns.db&lt;/td&gt;
&lt;td&gt;变更的数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ns.coll&lt;/td&gt;
&lt;td&gt;变更的集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;documentKey&lt;/td&gt;
&lt;td&gt;变更文档的键值，含_id字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;updateDescription&lt;/td&gt;
&lt;td&gt;变更描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;updateDescription.updatedFields&lt;/td&gt;
&lt;td&gt;变更中更新字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;updateDescription.removedFields&lt;/td&gt;
&lt;td&gt;变更中删除字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;clusterTime&lt;/td&gt;
&lt;td&gt;对应oplog的时间戳&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;txnNumber&lt;/td&gt;
&lt;td&gt;事务编号，仅在多文档事务中出现，4.0版本支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;lsid&lt;/td&gt;
&lt;td&gt;事务关联的会话编号，仅在多文档事务中出现，4.0版本支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Change Steram支持的变更类型有以下几个：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;insert&lt;/td&gt;
&lt;td&gt;插入文档&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;删除文档&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;replace&lt;/td&gt;
&lt;td&gt;替换文档，当执行replace操作指定upsert时，可能是insert事件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;update&lt;/td&gt;
&lt;td&gt;更新文档，当执行update操作指定upsert时，可能是insert事件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;invalidate&lt;/td&gt;
&lt;td&gt;失效事件，比如执行了collection.drop或collection.rename&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;利用以下的shell脚本，可以打印出集合 T_USER上的变更事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;watchCursor=db.T_USER.watch()
while (!watchCursor.isExhausted()){
   if (watchCursor.hasNext()){
      printjson(watchCursor.next());
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面提供一些样例，感受一下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insert 事件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;_id&quot;: {
        &quot;_data&quot;: &quot;825B5826D10000000129295A10046A31C593902B4A9C9907FC0AB1E3C0DA46645F696400645B58272321C4761D1338F4860004&quot;
    },
    &quot;operationType&quot;: &quot;insert&quot;,
    &quot;clusterTime&quot;: Timestamp(1532503761, 1),
    &quot;fullDocument&quot;: {
        &quot;_id&quot;: ObjectId(&quot;5b58272321c4761d1338f486&quot;),
        &quot;name&quot;: &quot;LiLei&quot;,
        &quot;createTime&quot;: ISODate(&quot;2018-07-25T07:30:43.398Z&quot;)
    },
    &quot;ns&quot;: {
        &quot;db&quot;: &quot;appdb&quot;,
        &quot;coll&quot;: &quot;T_USER&quot;
    },
    &quot;documentKey&quot;: {
        &quot;_id&quot;: ObjectId(&quot;5b58272321c4761d1338f486&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;update事件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
 &quot;_id&quot; : {
  &quot;_data&quot; : &quot;825B5829DF0000000129295A10046A31C593902B4A9C9907FC0AB1E3C0DA46645F696400645B582980ACEC5F345DB998EE0004&quot;
 },
 &quot;operationType&quot; : &quot;update&quot;,
 &quot;clusterTime&quot; : Timestamp(1532504543, 1),
 &quot;ns&quot; : {
  &quot;db&quot; : &quot;appdb&quot;,
  &quot;coll&quot; : &quot;T_USER&quot;
 },
 &quot;documentKey&quot; : {
  &quot;_id&quot; : ObjectId(&quot;5b582980acec5f345db998ee&quot;)
 },
 &quot;updateDescription&quot; : {
  &quot;updatedFields&quot; : {
   &quot;age&quot; : 15
  },
  &quot;removedFields&quot; : [ ]
 }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;replace事件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;_id&quot; : {
        &quot;_data&quot; : &quot;825B58299D0000000129295A10046A31C593902B4A9C9907FC0AB1E3C0DA46645F696400645B582980ACEC5F345DB998EE0004&quot;
    },
    &quot;operationType&quot; : &quot;replace&quot;,
    &quot;clusterTime&quot; : Timestamp(1532504477, 1),
    &quot;fullDocument&quot; : {
        &quot;_id&quot; : ObjectId(&quot;5b582980acec5f345db998ee&quot;),
        &quot;name&quot; : &quot;HanMeimei&quot;,
        &quot;age&quot; : 12
    },
    &quot;ns&quot; : {
        &quot;db&quot; : &quot;appdb&quot;,
        &quot;coll&quot; : &quot;T_USER&quot;
    },
    &quot;documentKey&quot; : {
        &quot;_id&quot; : ObjectId(&quot;5b582980acec5f345db998ee&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;delete事件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;_id&quot; : {
        &quot;_data&quot; : &quot;825B5827A90000000229295A10046A31C593902B4A9C9907FC0AB1E3C0DA46645F696400645B58272321C4761D1338F4860004&quot;
    },
    &quot;operationType&quot; : &quot;delete&quot;,
    &quot;clusterTime&quot; : Timestamp(1532503977, 2),
    &quot;ns&quot; : {
        &quot;db&quot; : &quot;appdb&quot;,
        &quot;coll&quot; : &quot;T_USER&quot;
    },
    &quot;documentKey&quot; : {
        &quot;_id&quot; : ObjectId(&quot;5b58272321c4761d1338f486&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;invalidate 事件&lt;/strong&gt;&lt;br/&gt;执行db.T_USER.drop() 可输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;_id&quot; : {
        &quot;_data&quot; : &quot;825B582D620000000329295A10046A31C593902B4A9C9907FC0AB1E3C0DA04&quot;
    },
    &quot;operationType&quot; : &quot;invalidate&quot;,
    &quot;clusterTime&quot; : Timestamp(1532505442, 3)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多的Change Event 信息可以&lt;a href=&quot;https://docs.mongodb.com/manual/reference/change-events/&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;四实现增量迁移&quot;&gt;四、实现增量迁移&lt;/h2&gt;
&lt;p&gt;本次设计了一个简单的论坛帖子迁移样例，用于演示如何利用&lt;strong&gt;Change Stream&lt;/strong&gt;实现完美的增量迁移方案。&lt;br/&gt;&lt;strong&gt;背景如下：&lt;/strong&gt;&lt;br/&gt;现有的系统中有10W个帖子，每个帖子都属于一个频道(channel)，如下表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;美食&lt;/td&gt;
&lt;td&gt;Food&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;情感&lt;/td&gt;
&lt;td&gt;Emotion&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;宠物&lt;/td&gt;
&lt;td&gt;Pet&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;家居&lt;/td&gt;
&lt;td&gt;House&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;征婚&lt;/td&gt;
&lt;td&gt;Marriage&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;教育&lt;/td&gt;
&lt;td&gt;Education&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;旅游&lt;/td&gt;
&lt;td&gt;Travel&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;新系统中频道字段将采用英文简称，同时要求能支持平滑升级。&lt;br/&gt;根据前面篇幅的叙述，我们将使用Change Stream 功能实现一个&lt;strong&gt;增量迁移&lt;/strong&gt;的方案。&lt;/p&gt;
&lt;p&gt;相关表的转换如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180726231027808-588452509.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;br/&gt;topic 是帖子原表，在迁移开始前将开启&lt;strong&gt;watch任务&lt;/strong&gt;持续获得增量数据，并记录到 topic_incr表中；&lt;br/&gt;接着执行全量的迁移转换，之后再&lt;strong&gt;持续&lt;/strong&gt;对增量表数据进行迁移，直到无新的增量为止。&lt;/p&gt;
&lt;p&gt;接下来我们使用Java程序来完成相关代码，mongodb-java--driver 在 3.6 版本后才支持 watch 功能&lt;br/&gt;需要确保升级到对应版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.mongodb&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;mongo-java-driver&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;3.6.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;定义Channel频道的转换表&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public static enum Channel {
    Food(&quot;美食&quot;),
    Emotion(&quot;情感&quot;),
    Pet(&quot;宠物&quot;),
    House(&quot;家居&quot;),
    Marriage(&quot;征婚&quot;),
    Education(&quot;教育&quot;),
    Travel(&quot;旅游&quot;)
    ;
    private final String oldName;

    public String getOldName() {
        return oldName;
    }

    private Channel(String oldName) {
        this.oldName = oldName;
    }

    /**
     * 转换为新的名称
     * 
     * @param oldName
     * @return
     */
    public static String toNewName(String oldName) {
        for (Channel channel : values()) {
            if (channel.oldName.equalsIgnoreCase(oldName)) {
                return channel.name();
            }
        }
        return &quot;&quot;;
    }

    /**
     * 返回一个随机频道
     * 
     * @return
     */
    public static Channel random() {
        Channel[] channels = values();
        int idx = (int) (Math.random() * channels.length);
        return channels[idx];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;为 topic 表预写入1w条记录&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private static void preInsertData() {
    MongoCollection&amp;lt;Document&amp;gt; topicCollection = getCollection(coll_topic);

    // 分批写入，共写入1w条数据
    int current = 0;
    int batchSize = 100;

    while (current &amp;lt; 10000) {
        List&amp;lt;Document&amp;gt; topicDocs = new ArrayList&amp;lt;Document&amp;gt;();

        for (int j = 0; j &amp;lt; batchSize; j++) {
            Document topicDoc = new Document();

            Channel channel = Channel.random();
            topicDoc.append(field_channel, channel.getOldName());
            topicDoc.append(field_nonce, (int) (Math.random() * nonce_max));

            topicDoc.append(&quot;title&quot;, &quot;This is the tilte -- &quot; + UUID.randomUUID().toString());
            topicDoc.append(&quot;author&quot;, &quot;LiLei&quot;);
            topicDoc.append(&quot;createTime&quot;, new Date());
            topicDocs.add(topicDoc);
        }

        topicCollection.insertMany(topicDocs);
        current += batchSize;
        logger.info(&quot;now has insert {} records&quot;, current);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述实现中，每个帖子都分配了随机的频道(channel)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开启监听任务，将topic上的所有变更写入到增量表&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;MongoCollection&amp;lt;Document&amp;gt; topicCollection = getCollection(coll_topic);
MongoCollection&amp;lt;Document&amp;gt; topicIncrCollection = getCollection(coll_topic_incr);

// 启用 FullDocument.update_lookup 选项
cursor = topicCollection.watch().fullDocument(FullDocument.UPDATE_LOOKUP).iterator();
while (cursor.hasNext()) {

    ChangeStreamDocument&amp;lt;Document&amp;gt; changeEvent = cursor.next();
    OperationType type = changeEvent.getOperationType();
    logger.info(&quot;{} operation detected&quot;, type);

    if (type == OperationType.INSERT || type == OperationType.UPDATE || type == OperationType.REPLACE
            || type == OperationType.DELETE) {

        Document incrDoc = new Document(field_op, type.getValue());
        incrDoc.append(field_key, changeEvent.getDocumentKey().get(&quot;_id&quot;));
        incrDoc.append(field_data, changeEvent.getFullDocument());
        topicIncrCollection.insertOne(incrDoc);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中通过watch 命令获得一个MongoCursor对象，用于遍历所有的变更。&lt;br/&gt;&lt;strong&gt;FullDocument.UPDATE_LOOKUP&lt;/strong&gt;选项启用后，在update变更事件中将携带完整的文档数据(FullDocument)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;watch()&lt;/strong&gt;命令提交后，mongos会与分片上的mongod(主节点)建立订阅通道，这可能需要花费一点时间。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为了模拟线上业务的真实情况，启用几个线程对topic表进行持续写操作；&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private static void startMockChanges() {

    threadPool.submit(new ChangeTask(OpType.insert));
    threadPool.submit(new ChangeTask(OpType.update));
    threadPool.submit(new ChangeTask(OpType.replace));
    threadPool.submit(new ChangeTask(OpType.delete));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ChangeTask 实现逻辑如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (true) {
    logger.info(&quot;ChangeTask {}&quot;, opType);
    if (opType == OpType.insert) {
        doInsert();
    } else if (opType == OpType.update) {
        doUpdate();
    } else if (opType == OpType.replace) {
        doReplace();
    } else if (opType == OpType.delete) {
        doDelete();
    }
    sleep(200);
    long currentAt = System.currentTimeMillis();
    if (currentAt - startAt &amp;gt; change_during) {
        break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一个变更任务会不断对topic产生写操作，触发一系列ChangeEvent产生。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;doInsert：生成随机频道的topic后，执行insert&lt;/li&gt;
&lt;li&gt;doUpdate：随机取得一个topic，将其channel字段改为随机值，执行update&lt;/li&gt;
&lt;li&gt;doReplace：随机取得一个topic，将其channel字段改为随机值，执行replace&lt;/li&gt;
&lt;li&gt;doDelete：随机取得一个topic，执行delete&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以&lt;strong&gt;doUpdate&lt;/strong&gt;为例，实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void doUpdate() {
    MongoCollection&amp;lt;Document&amp;gt; topicCollection = getCollection(coll_topic);

    Document random = getRandom();
    if (random == null) {
        logger.info(&quot;update skip&quot;);
        return;
    }

    String oldChannel = random.getString(field_channel);
    Channel channel = Channel.random();

    random.put(field_channel, channel.getOldName());
    random.put(&quot;createTime&quot;, new Date());
    topicCollection.updateOne(new Document(&quot;_id&quot;, random.get(&quot;_id&quot;)), new Document(&quot;$set&quot;, random));

    counter.onChange(oldChannel, channel.getOldName());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动一个全量迁移任务，将 topic 表中数据迁移到 topic_new 新表&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;final MongoCollection&amp;lt;Document&amp;gt; topicCollection = getCollection(coll_topic);
final MongoCollection&amp;lt;Document&amp;gt; topicNewCollection = getCollection(coll_topic_new);

Document maxDoc = topicCollection.find().sort(new Document(&quot;_id&quot;, -1)).first();
if (maxDoc == null) {
    logger.info(&quot;FullTransferTask detect no data, quit.&quot;);
    return;
}

ObjectId maxID = maxDoc.getObjectId(&quot;_id&quot;);
logger.info(&quot;FullTransferTask maxId is {}..&quot;, maxID.toHexString());

AtomicInteger count = new AtomicInteger(0);

topicCollection.find(new Document(&quot;_id&quot;, new Document(&quot;$lte&quot;, maxID)))
        .forEach(new Consumer&amp;lt;Document&amp;gt;() {

            @Override
            public void accept(Document topic) {
                Document topicNew = new Document(topic);
                // channel转换
                String oldChannel = topic.getString(field_channel);
                topicNew.put(field_channel, Channel.toNewName(oldChannel));

                topicNewCollection.insertOne(topicNew);
                if (count.incrementAndGet() % 100 == 0) {
                    logger.info(&quot;FullTransferTask progress: {}&quot;, count.get());
                }
            }

        });
logger.info(&quot;FullTransferTask finished, count: {}&quot;, count.get());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在全量迁移开始前，先获得当前时刻的的最大 _id 值(可以将此值记录下来)作为终点。&lt;br/&gt;随后逐个完成迁移转换。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在全量迁移完成后，便开始最后一步：增量迁移&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：增量迁移过程中，变更操作仍然在进行&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final MongoCollection&amp;lt;Document&amp;gt; topicIncrCollection = getCollection(coll_topic_incr);
final MongoCollection&amp;lt;Document&amp;gt; topicNewCollection = getCollection(coll_topic_new);

ObjectId currentId = null;
Document sort = new Document(&quot;_id&quot;, 1);
MongoCursor&amp;lt;Document&amp;gt; cursor = null;

// 批量大小
int batchSize = 100;
AtomicInteger count = new AtomicInteger(0);

try {
    while (true) {

        boolean isWatchTaskStillRunning = watchFlag.getCount() &amp;gt; 0;

        // 按ID增量分段拉取
        if (currentId == null) {
            cursor = topicIncrCollection.find().sort(sort).limit(batchSize).iterator();
        } else {
            cursor = topicIncrCollection.find(new Document(&quot;_id&quot;, new Document(&quot;$gt&quot;, currentId)))
                    .sort(sort).limit(batchSize).iterator();
        }

        boolean hasIncrRecord = false;

        while (cursor.hasNext()) {
            hasIncrRecord = true;

            Document incrDoc = cursor.next();

            OperationType opType = OperationType.fromString(incrDoc.getString(field_op));
            ObjectId docId = incrDoc.getObjectId(field_key);

            // 记录当前ID
            currentId = incrDoc.getObjectId(&quot;_id&quot;);

            if (opType == OperationType.DELETE) {

                topicNewCollection.deleteOne(new Document(&quot;_id&quot;, docId));
            } else {

                Document doc = incrDoc.get(field_data, Document.class);

                // channel转换
                String oldChannel = doc.getString(field_channel);
                doc.put(field_channel, Channel.toNewName(oldChannel));

                // 启用upsert
                UpdateOptions options = new UpdateOptions().upsert(true);

                topicNewCollection.replaceOne(new Document(&quot;_id&quot;, docId),
                        incrDoc.get(field_data, Document.class), options);
            }

            if (count.incrementAndGet() % 10 == 0) {
                logger.info(&quot;IncrTransferTask progress, count: {}&quot;, count.get());
            }
        }

        // 当watch停止工作(没有更多变更)，同时也没有需要处理的记录时，跳出
        if (!isWatchTaskStillRunning &amp;amp;&amp;amp; !hasIncrRecord) {
            break;
        }

        sleep(200);
    }
} catch (Exception e) {
    logger.error(&quot;IncrTransferTask ERROR&quot;, e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增量迁移的实现是一个&lt;strong&gt;不断 tail&lt;/strong&gt; 的过程，利用 **_id 字段的有序特性 ** 进行分段迁移；&lt;br/&gt;即记录下当前处理的 _id 值，循环拉取在 该 _id 值之后的记录进行处理。&lt;/p&gt;
&lt;p&gt;增量表(topic_incr)中除了DELETE变更之外，其余的类型都保留了整个文档，&lt;br/&gt;因此可直接利用 replace + upsert 追加到新表。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最后，运行整个程序&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[2018-07-26 19:44:16] INFO ~ IncrTransferTask progress, count: 2160
[2018-07-26 19:44:16] INFO ~ IncrTransferTask progress, count: 2170
[2018-07-26 19:44:27] INFO ~ all change task has stop， watch task quit.
[2018-07-26 19:44:27] INFO ~ IncrTransferTask finished, count: 2175
[2018-07-26 19:44:27] INFO ~ TYPE 美食:1405
[2018-07-26 19:44:27] INFO ~ TYPE 宠物:1410
[2018-07-26 19:44:27] INFO ~ TYPE 征婚:1428
[2018-07-26 19:44:27] INFO ~ TYPE 家居:1452
[2018-07-26 19:44:27] INFO ~ TYPE 教育:1441
[2018-07-26 19:44:27] INFO ~ TYPE 情感:1434
[2018-07-26 19:44:27] INFO ~ TYPE 旅游:1457
[2018-07-26 19:44:27] INFO ~ ALLCHANGE 12175
[2018-07-26 19:44:27] INFO ~ ALLWATCH 2175&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看 topic 表和 topic_new 表，发现两者数量是相同的。&lt;br/&gt;为了进一步确认一致性，我们对两个表的分别做一次聚合统计：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;topic表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.topic.aggregate([{
    &quot;$group&quot;:{
        &quot;_id&quot;:&quot;$channel&quot;,
        &quot;total&quot;: {&quot;$sum&quot;: 1}
        }
    },
    {
        &quot;$sort&quot;: {&quot;total&quot;:-1}
        }
    ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;topic_new表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.topic_new.aggregate([{
    &quot;$group&quot;:{
        &quot;_id&quot;:&quot;$channel&quot;,
        &quot;total&quot;: {&quot;$sum&quot;: 1}
        }
    },
    {
        &quot;$sort&quot;: {&quot;total&quot;:-1}
        }
    ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前者输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180726231105165-685257136.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后者输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180726231154007-1117844618.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前后对比的结果是一致的！&lt;/p&gt;
&lt;h2 id=&quot;五后续优化&quot;&gt;五、后续优化&lt;/h2&gt;
&lt;p&gt;前面的章节演示了一个增量迁移的样例，在投入到线上运行之前，这些代码还得继续优化：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;写入性能，线上的数据量可能会达到亿级，在全量、增量迁移时应采用合理的批量化处理；&lt;br/&gt;另外可以通过增加并发线程，添置更多的Worker，分别对不同业务库、不同表进行处理以提升效率。&lt;br/&gt;增量表存在&lt;strong&gt;幂等性&lt;/strong&gt;，即回放多次其最终结果还是一致的，但需要保证&lt;strong&gt;表级有序&lt;/strong&gt;，即一个表同时只有一个线程在进行增量回放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;容错能力，一旦 watch 监听任务出现异常，要能够从更早的时间点开始(使用startAtOperationTime参数)，&lt;br/&gt;而如果写入时发生失败，要支持重试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;回溯能力，做好必要的跟踪记录，比如将转换失败的ID号记录下来，旧系统的数据需要保留，&lt;br/&gt;以免在事后追究某个数据问题时找不着北。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据转换，新旧业务的差异不会很简单，通常需要借助大量的转换表来完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一致性检查，需要根据业务特点开发自己的一致性检查工具，用来证明迁移后数据达到想要的一致性级别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BTW，数据迁移一定要结合业务特性、架构差异来做考虑，否则还是在耍流氓。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;服务化系统中扩容、升级往往会进行数据迁移，对于业务量大，中断敏感的系统通常会采用平滑迁移的方式。&lt;br/&gt;MongoDB 3.6 版本后提供了 Change Stream 功能以支持应用订阅数据的变更事件流，&lt;br/&gt;本文使用 Stream 功能实现了增量平滑迁移的例子，这是一次尝试，相信后续这样的应用场景会越来越多。&lt;br/&gt;欢迎关注&quot;美码师的公众号&quot; -- 唯美食与技术不可辜负&quot; ，期待更多精彩内容^-^&lt;/p&gt;
&lt;h2 id=&quot;附参考文档&quot;&gt;附参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.10tiao.com/html/249/201703/2651959992/1.html&quot;&gt;百亿级数据迁移-58沈剑&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/changeStreams/&quot;&gt;MongoDB-ChangeStream&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.percona.com/blog/2017/11/22/mongodb-3-6-change-streams-nest-temperature-fan-control-use-case/&quot;&gt;Use-ChangeStream To Handle Temperature&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 15:14:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9375045.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之ASP.NET Core on Docker - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/aspnetcore_on_docker_foundation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/aspnetcore_on_docker_foundation.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt; &lt;/em&gt;此篇已加入&lt;a title=&quot;find more ?&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础系列文章索引&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1.1 总体介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726221105300-1650411740.png&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个&lt;span&gt;&lt;em&gt;&lt;strong&gt;轻量级、可移植的容器&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;简而言之&amp;gt; &lt;/strong&gt;容器是一个打包了应用服务的环境，它是一个&lt;strong&gt;&lt;span&gt;轻量级的虚拟机&lt;/span&gt;&lt;/strong&gt;，每一个容器由一组特定的应用和必要的依赖库组成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Docker和传统虚拟化之间最大的区别在于：&lt;strong&gt;&lt;span&gt;容器是在操作系统层面上实现虚拟化，即直接复用本地主机的操作系统&lt;/span&gt;&lt;/strong&gt;；而传统虚拟化则是在硬件层面实现，如VMware vShpere, Xen及Citrix等。&lt;/p&gt;
&lt;h2&gt;1.2 Docker结构&lt;/h2&gt;
&lt;p&gt;　　Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。&lt;/p&gt;
&lt;p&gt;　　Docker 容器通过 Docker 镜像来创建。&lt;/p&gt;
&lt;p&gt;　　容器与镜像的关系类似于&lt;span&gt;&lt;strong&gt;面向对象编程中的对象与类&lt;/strong&gt;&lt;/span&gt;。　　&lt;/p&gt;
&lt;p&gt;　　Docker的架构如下图所示，Client 通过接口与Server进程通信实现容器的构建，运行和发布。Client和Server可以运行在同一台集群，也可以通过跨主机实现远程通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726222640794-679564755.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体详细内容，请浏览：《&lt;a href=&quot;https://www.cnblogs.com/SzeCheng/p/6822905.html&quot; target=&quot;_blank&quot;&gt;几张图帮你理解Docker基本原理及快速入门&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;　　（1）准备一台Linux主机，这里以CentOS 7.2为例。当然，你也可以使用Windows，不过你得确保是Windows 10 pro版本及以上，且安装了Hyper-V等一系列的相关软件。&lt;/p&gt;
&lt;p&gt;　　（2）安装docker&lt;/p&gt;
&lt;p&gt;　　# yum install docker&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726223251675-409859616.png&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）启动docker服务&lt;/p&gt;
&lt;p&gt;　　# systemctl start docker.sevice&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726223414820-138794994.png&quot; alt=&quot;&quot; width=&quot;642&quot; height=&quot;45&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）配置开机启动并验证&lt;/p&gt;
&lt;p&gt;　　# systemctl enable docker.service&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726223533171-1855330570.png&quot; alt=&quot;&quot; width=&quot;855&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　验证：查看docker版本信息 &lt;/p&gt;
&lt;p&gt;　　# docker version&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726223618190-2049562782.png&quot; alt=&quot;&quot; width=&quot;545&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（5）配置docker加速器 =&amp;gt; 原因你懂得，不设置慢死你，云服务器除外&lt;/p&gt;
&lt;p&gt;　　# vim /etc/docker/daemon.json&lt;/p&gt;
&lt;blockquote readability=&quot;2.4285714285714&quot;&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;&quot;registry-mirrors&quot;: [&quot;&lt;a href=&quot;https://d8b3zdiw.mirror.aliyuncs.com/&quot;&gt;https://d8b3zdiw.mirror.aliyuncs.com&lt;/a&gt;&quot;]&lt;/p&gt;
&lt;p&gt;}　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　然后重启docker服务&lt;/p&gt;
&lt;p&gt;　　# systemctl daemon-reload&lt;/p&gt;
&lt;p&gt;　　# systemctl restart docker&lt;/p&gt;
&lt;p&gt;　　（6）Hello World&lt;/p&gt;
&lt;p&gt;　　# docker run hello-world&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726223924295-2078865923.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（1）拉取dotnet/aspnetcore的最新镜像，这里以aspnetcore 2.0为例&lt;/p&gt;
&lt;p&gt;　　# docker pull microsoft/aspnetcore:2.0&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726224228324-1489528676.png&quot; alt=&quot;&quot; width=&quot;541&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　PS：如果要拉取最新版本（比如.net core 2.1），可以将版本号改为aspnetcore:&lt;strong&gt;latest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;如果你想要拉取更多microsoft的镜像，那么搜索一下把：# docker search microsoft&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726224415557-1720987293.png&quot; alt=&quot;&quot; width=&quot;741&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拉取了不想要的镜像，那么删除一个吧，如：# docker rmi imagesID&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726224515396-2123967148.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拉取之后，验证一下是否拉取成功了：# docker images&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726224602787-1973372153.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）现在我们进入VS中为我们的一个ASP.NET Core WebAPI编辑一个Dockerfile&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 父镜像
FROM microsoft&lt;/span&gt;/aspnetcore:&lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;

# 设置工作目录
WORKDIR &lt;/span&gt;/&lt;span&gt;app

# 复制发布文件到&lt;/span&gt;/&lt;span&gt;app下
COPY . &lt;/span&gt;/&lt;span&gt;app

# 设置端口
EXPOSE &lt;/span&gt;&lt;span&gt;8810&lt;/span&gt;&lt;span&gt;

# 使用dotnet Manulife.DNC.MSAD.NB.AgentService.dll来运行ASP.NET Core项目，注意大小写
ENTRYPOINT [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Manulife.CD.MSAD.NB.AgentService.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--server.urls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:8810&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）发布这个ASP.NET Core WebAPI，并将Release文件传送到Linux服务器中（你可以选择xFTP或者WinScp等工具）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726225348887-274300204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）进入上图的AgentService目录中，开始打包docker镜像&lt;/p&gt;
&lt;p&gt;　　# docker build -t agentservice-container:1.0 . =&amp;gt; &lt;span&gt;不要忘记后面还有一个点.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726225539354-340026973.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此刻再次验证：# docker images&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726225642114-1886531538.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（5）万里长征最后一步：运行docker&lt;/p&gt;
&lt;p&gt;　　# docker run -name agentservice -d -p 8810:8810 agentservice-container:1.0&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726225731111-755289091.png&quot; alt=&quot;&quot; width=&quot;793&quot; height=&quot;34&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里的两个端口号分别是宿主机和容器的映射，前一个是你在外部访问的端口号，后一个是你要映射到docker容器中的端口号，切记和我们在Dockerfile中暴露出来的端口号保持一致。&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;这里如果docker run失败后再次运行会提示名称已存在，可以使用以下命令来删除容器&lt;/p&gt;
&lt;p&gt;　　# docker rm -f [dockername]&lt;/p&gt;
&lt;p&gt;　　如果想要docker容器在非正常退出后自动重启，可以加上--restart选项，例如下面：&lt;/p&gt;
&lt;p&gt;　　# docker run --name agentservice -d -p 8810:8810 agentservice-container:1.0 --restart=always&lt;/p&gt;
&lt;p&gt;　　（6）验证docker运行效果&lt;/p&gt;
&lt;p&gt;　　方式一：在宿主机验证&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726230508376-1010695496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　方式二：在远程客户端通过浏览器访问&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726230516068-774247915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726231305535-528287816.jpg&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此部分主要针对于在Linux上的dotnet core应用程序，保证程序在异常或者是电脑重启的时候仍然能够正常访问。大家可以浏览杨晓东的《&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/dotnetcore-supervisor.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core Linux下为dotnet创建守护进程&lt;/a&gt;》以及focus-lei的《&lt;a href=&quot;https://www.cnblogs.com/focus-lei/p/6868324.html&quot; target=&quot;_blank&quot;&gt;在docker上运行.net core程序&lt;/a&gt;》来学习，这里就不再赘述了。&lt;/p&gt;

&lt;p&gt;（1）菜鸟教程，《&lt;a href=&quot;http://www.runoob.com/docker/docker-tutorial.html&quot; target=&quot;_blank&quot;&gt;Docker教程&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（2）杨晓东，《&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/dotnetcore-docker.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core Docker部署&lt;/a&gt;》，《&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/dotnetcore-supervisor.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core Linux下为dotnet创建守护进程&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（3）李朝强，《&lt;a href=&quot;https://www.cnblogs.com/ibeisha/p/netcoreondocker.html&quot; target=&quot;_blank&quot;&gt;Docker打包ASP.NET Core应用，在CentOS上运行&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（4）圣杰，《&lt;a href=&quot;https://www.cnblogs.com/sheng-jie/p/8107877.html&quot; target=&quot;_blank&quot;&gt;.NET Core容器化@Docker&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（5）focus-lei，《&lt;a href=&quot;https://www.cnblogs.com/focus-lei/p/6868324.html&quot; target=&quot;_blank&quot;&gt;在Docker上运行.net core程序&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 26 Jul 2018 15:14:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/aspnetcore_on_docker_foundation.html</dc:identifier>
</item>
<item>
<title>string类总结第一部分函数介绍 - GolLong</title>
<link>http://www.cnblogs.com/gollong/p/9372868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gollong/p/9372868.html</guid>
<description>&lt;p&gt;　　在前面几章，看了整个String类的源码，给每个方法都行写了注释，但是太过凌乱，今天我就把String类的方法整理归纳，然后再讲一下String类比较难以理解的部分&lt;/p&gt;
&lt;p&gt;　　特此声明：本文篇幅较大，涵盖知识点较多，请耐着性子读下去，毕竟写文章不易，写知识性文章更加不易！&lt;/p&gt;

&lt;p&gt;　　这是第一部分的内容，由于String的函数较多，我将他们分为四大类，分别是构造性函数、转换性函数、功能性函数以及私有函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;私有函数：主要是把属性以及一些私有方法列出来&lt;/li&gt;
&lt;li&gt;构造性函数：也就是字符串的构造器&lt;/li&gt;
&lt;li&gt;转换性函数：负责字符串和其他类型之间的转换，比如说valueOf&lt;/li&gt;
&lt;li&gt;功能性函数：其实除了构造函数和转换函数，其他函数都具些特别常用的功能，我们经常使用功能函数，所有我将他们罗列出来（ps：重点）&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;私有函数：&lt;/h2&gt;
&lt;p&gt;　　如果你仔细看源代码的话，会发现每个私有函数都会在代码中被频繁调用，String把这些被多次用到的重复代码进行封装，&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt; value[];
　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Default to 0&lt;/span&gt;
　　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -6849794470754667710L&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ObjectStreamField[] serialPersistentFields = &lt;span&gt;new&lt;/span&gt; ObjectStreamField[0&lt;span&gt;];&lt;br/&gt;　　首先是四个属性，最后两个是用来实现序列化和反序列化的，详细内容会单独讲解&lt;br/&gt;　　第一个属性：char value[]就表明了String字符串的本质，char数组表明它是引用类型，final表明它是常量，所以他是一个在JVM线程共享区的方法区中的常量，&lt;br/&gt;所以每当我们创建一个String对象时，&lt;/span&gt;都会在常量池中查找是否已经存在该常量，若存在就将该对象指向该常量，若不存在就先在常量池中创建该常量，然后再指向这个常量。&lt;br/&gt;　　这里讲一下常量和变量：可能有的同学对常量的概念很模糊，只知道常量和变量是相对的，&lt;br/&gt;　　变量：我们常说的局部变量和成员变量都是变量，变量分为基本类型和引用类型，基本类型就是那八大类型（boolean,byte,char,short,int,long,float,double）而引用类型分为三种，数组，类和接口&lt;br/&gt;　　常量：常量分为俩种，字面值常量和自定义常量，比如说Math.min（2,3）其中的2和3就是直接传入的俩个常量，在Math类中public static final double PI = 3.14159265358979323846这么定义的PI就是自定义常量，&lt;br/&gt;也就是我们通常意义上的常量，常量就是其值不可改变的，也就是用final修饰，比如说2就表示2，PI就表示3.14159265358979323846。static修饰词限定了该常量的值被类的对象所共享，可以通过类名直接调用，Math.PI。&lt;br/&gt;　　第二个属性hash，这个属性会带你走进hashCode（）方法的神秘世界，详情请参照hashCode（）方法，这个hash属性是用来在一定程度上标识字符串唯一性的，你可以把它认为成一种ID，但是hash并不是地址值，详细去看一下hash表的数据结构，&lt;br/&gt;这个hash只能称之为哈希码，绝对不是什么地址值，也就是说hashCode方法返回的是对象在内存中的地址的说法是错误的
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkBounds(&lt;span&gt;byte&lt;/span&gt;[] bytes, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length)&lt;br/&gt;　　在String构造函数中用于检查边界，也就是检查传入的offset和length是否有问题&lt;br/&gt;&lt;/span&gt;&lt;span&gt;   String(&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; share)&lt;br/&gt;　　打包私有构造函数，它为speed.this构造函数共享值数组，总是需要使用share == true来调用。需要单独的构造函数，因为我们已经有一个公共String（char []）构造函数，它可以复制给定的char[]。&lt;br/&gt;不要纠结与这个Boolean类型的参数，它只是一个用来区别于String（char[]）构造器的&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; nonSyncContentEquals(AbstractStringBuilder sb)&lt;br/&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CaseInsensitiveComparator &lt;span&gt;implements&lt;/span&gt; Comparator&amp;lt;String&amp;gt;&lt;span&gt;, java.io.Serializable {}&lt;br/&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;局部内部类，是String实现不区分大小写的equals方法的核心代码实现，详情在&lt;/span&gt;&lt;/span&gt;public boolean equalsIgnoreCase(String anotherString)中
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOfSupplementary(&lt;span&gt;int&lt;/span&gt; ch, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)&lt;br/&gt;&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOfSupplementary(&lt;span&gt;int&lt;/span&gt; ch, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(&lt;span&gt;char&lt;/span&gt;[] source, &lt;span&gt;int&lt;/span&gt; sourceOffset, &lt;span&gt;int&lt;/span&gt; sourceCount,String target, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(&lt;span&gt;char&lt;/span&gt;[] source, &lt;span&gt;int&lt;/span&gt; sourceOffset, &lt;span&gt;int&lt;/span&gt; sourceCount,&lt;span&gt;char&lt;/span&gt;[] target, &lt;span&gt;int&lt;/span&gt; targetOffset, &lt;span&gt;int&lt;/span&gt; targetCount,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(&lt;span&gt;char&lt;/span&gt;[] source, &lt;span&gt;int&lt;/span&gt; sourceOffset, &lt;span&gt;int&lt;/span&gt; sourceCount,String target, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(&lt;span&gt;char&lt;/span&gt;[] source, &lt;span&gt;int&lt;/span&gt; sourceOffset, &lt;span&gt;int&lt;/span&gt; sourceCount,&lt;span&gt;char&lt;/span&gt;[] target, &lt;span&gt;int&lt;/span&gt; targetOffset, &lt;span&gt;int&lt;/span&gt; targetCount,&lt;span&gt;int&lt;/span&gt; fromIndex)&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 构造性函数：&lt;/h2&gt;
&lt;p&gt;　　String的构造函数，还是很让人懵逼的，总的来说他们的具体功能是就是将String ,char[],byte[],StringBuilder StringBuffer 转换为String类型，后几个大家都容易理解，就是将其他类型装换为String类型，但是第一个呢，将String转换为String？这有什么用呢？且听我细细道来&lt;/p&gt;
&lt;p&gt;我们先看源代码（由于我之前在String源码解析中已经发过了，这里就不重复发了），new String()只有一行this.value = &quot;&quot;.value;，new String(String original)只有两行this.value = original.value;this.hash = original.hash;很简单的吧&lt;/p&gt;
&lt;p&gt;　　这就引出了一道经典的面试题：String s = new String(&quot;gollong&quot;)创建了几个对象？&lt;/p&gt;
&lt;p&gt;　　　　首先你要明白什么创建对象，String s;并没有创建对象，只是声明一个引用，new String(&quot;gollong&quot;)才是真正的创建对象，然后String s = new String(&quot;gollong&quot;)完成引用的实例化。&lt;/p&gt;
&lt;p&gt;　　　　其实你要明白这是调用的一个构造函数，传入的参数是String类型的，那么就很简单了，我们将这一行代码分解为如下两行&lt;/p&gt;
&lt;p&gt;　　　　　　String temp = &quot;gollong&quot;;&lt;/p&gt;
&lt;p&gt;　　　　　　String s = new String(temp);&lt;/p&gt;
&lt;p&gt;　　　　这就好理解了吧，首先会在常量池中创建一个“gollong”,这是第一个对象（当然是在常量池中本身没有这个对象的前提下），其次会在堆中创建第二个对象，因为new出来的对象肯定及一定在堆中，再把前一个对象当做实参传入到其中&lt;/p&gt;
&lt;p&gt;　　　　我用一张概念图来解释这个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1444454/201807/1444454-20180726153906104-1745700149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String()
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String(String original)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; value[])
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;char&lt;/span&gt; value[], &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;int&lt;/span&gt;[] codePoints, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)&lt;br/&gt;　　看上去好像是将int数组转换为String，但是你去试试，输出的东西并不是简单的把每一个int值链接起来，这里面大有学问，我们都知道java是采用Unicode字符集的，那Unicode内是怎么表示的呢，&lt;br/&gt;Unicode内部一共有三种长度的字符，分别占用一个字节、两个字节、四个字节，而这个int类型的数组就是指符合Unicode的四个字节长度的字符，在编码一章中再讲吧，太复杂了
    @Deprecated
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt; ascii[], &lt;span&gt;int&lt;/span&gt; hibyte, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt; ascii[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hibyte)   &lt;br/&gt;　　已经过时的俩个方法，其意义是将byte数组转换为String对象，我们都知道byte类型只占用一个字节，而组成String的char类型却占有两个字节，这就涉及到互相转换时高8位的处理问题了&lt;br/&gt;而对于不同的编码方式（请注意：在不详细区别编码和解码是，编码就是指编码和解码的统称），处理方式是不同的，所以这两个构造器可以让使用者指定高8位的内容，但是人为指定的往往是不正确的&lt;br/&gt;所以标注为过时（请注意：过时并不意味着不能用，只是不推荐使用，因为它总有一 天会被淘汰的），才有了以下的六个指定编码方式的方法。&lt;br/&gt;　　 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt; bytes[], &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt; length, String charsetName)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnsupportedEncodingException
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt; bytes[], &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length, Charset charset)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt; bytes[], String charsetName)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnsupportedEncodingException
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; bytes[], Charset charset)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt; bytes[], &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; bytes[])&lt;br/&gt;　　指定编码方式的将byte转换为char，其中可以通过两个方式指定，一种是传入编码的字符串表示，最经常使用的方法，另一种是传入Charset对象，毕竟能不造对象就不造，浪费空间
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String(StringBuffer buffer)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(StringBuilder builder)  
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 转换性函数：&lt;/h2&gt;
&lt;p&gt;　　就是一些负责把其他类型的变量转换为String类型，或者把String转换为byte[],char[]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String format(String format, Object... args)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String format(Locale l, String format, Object... args)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String join(CharSequence delimiter, CharSequence... elements)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String join(CharSequence delimiter,Iterable&amp;lt;? &lt;span&gt;extends&lt;/span&gt; CharSequence&amp;gt;&lt;span&gt; elements)&lt;br/&gt;　　
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String valueOf(Object obj)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; data[])
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;char&lt;/span&gt; data[], &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)&lt;br/&gt;　　上面俩个内部调用的就是String的构造器new String(char data[])和new String(char data[],int offset,int count)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String copyValueOf(&lt;span&gt;char&lt;/span&gt; data[], &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String copyValueOf(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; data[])
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; b)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; l)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; f) 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String valueOf(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; d)&lt;br/&gt;　　static修饰的类函数，可通过String.直接调用，返回一个String，类似于工具类的做法， 经常被用来将单个的各种类型转换为String，其实内部调用的就是八大数据类型的包装类的toString方法
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getChars(&lt;span&gt;int&lt;/span&gt; srcBegin, &lt;span&gt;int&lt;/span&gt; srcEnd, &lt;span&gt;char&lt;/span&gt; dst[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dstBegin)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getBytes(&lt;span&gt;int&lt;/span&gt; srcBegin, &lt;span&gt;int&lt;/span&gt; srcEnd, &lt;span&gt;byte&lt;/span&gt; dst[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dstBegin)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getBytes(String charsetName)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnsupportedEncodingException
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] getBytes(Charset charset)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] getBytes()
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[] toCharArray()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 功能性函数：&lt;/h2&gt;
&lt;p&gt;　　由于功能性函数很多，我把他们进行了详细的分类&lt;/p&gt;
&lt;h3&gt;来自于Object的函数：&lt;/h3&gt;
&lt;p&gt;　　继承自Object类的三个方法，都很重要&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;equals ：重写后用来比较俩个字符串的每对应的俩个字符是否相等，也就是比较内容是否相等，很容易理解，但是往往与他同时出现的==就不是那么容易理解了，在后面的第二部分中讲解&lt;/li&gt;
&lt;li&gt;hashCode：返回的是字符串额hash值，而在java中String的哈希码计算规则是s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]，这里就不列计算过程，详细去google。一定要注意hashCode返回的不是地址值，返回的是哈希码，是通过规则算出来的&lt;/li&gt;
&lt;li&gt;toString：返回当前对象，并不是你想象当中的遍历字符串中的每一个字符，而字符串对象直接输出就是遍历。根本不需要重写toString方法，我相信你肯定听说过这句话，输出一个字符串对象就是输出它的值，是因为String重写了toString方法，现在我说这句话是错的你信吗？&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object anObject)
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode()
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String toString()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;判断函数：&lt;/h3&gt;
&lt;p&gt;通过比较此字符串和指定的内容，返回一个boolean类型，一般用在if()和while()语句中，都是很常用的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty()&lt;br/&gt;　　判断字符串是否为空，也及时判断char数组的长度是否为0
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contentEquals(StringBuffer sb)   &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contentEquals(CharSequence cs)&lt;br/&gt;　　判断内容是否相等，StringBuffer是什么我们都知道，&lt;/span&gt;CharSequence 是个什么呢？其实CharSequence 是字符序列接口，我们所接触到的像String，StringBuffer，StringBuider等都是它的实现类。大家既然都是字符串，哪来比较下内容也无可厚非嘛
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equalsIgnoreCase(String anotherString) &lt;/span&gt;&lt;span&gt;　&lt;br/&gt;　　&lt;span&gt;忽略大小写的比较，核心调用的是regionMatches方法，而regionMathes是用来测试俩个字符串某些部分是否相等，而equals只能整个比较，这就是我们用它的原来，但是一般不怎么使用，都是用contains&lt;/span&gt;&lt;br/&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; regionMatches(&lt;span&gt;int&lt;/span&gt; toffset, String other, &lt;span&gt;int&lt;/span&gt; ooffset,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; regionMatches(&lt;span&gt;boolean&lt;/span&gt; ignoreCase, &lt;span&gt;int&lt;/span&gt; toffset,String other, &lt;span&gt;int&lt;/span&gt; ooffset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) &lt;br/&gt;　　判断字符串是否以指定字符串开始或结尾&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; startsWith(String prefix, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toffset) &lt;/span&gt;&lt;span&gt;　　&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; startsWith(String prefix) &lt;/span&gt;&lt;span&gt;　　&lt;br/&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; endsWith(String suffix)&lt;/span&gt;&lt;/em&gt;&lt;span&gt;　&lt;br/&gt;　　&lt;span&gt;判断字符串是否匹配指定的正则表达式&lt;/span&gt;&lt;br/&gt;　　public&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; matches(String regex) &lt;/span&gt;&lt;span&gt;　&lt;br/&gt;　　&lt;/span&gt;&lt;/em&gt;&lt;span&gt;判断字符串是否包含指定的字符序列，注意传入的是CharSequence对象&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;br/&gt;　　public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; contains(CharSequence s)&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;比较函数：&lt;/h3&gt;
&lt;p&gt;比较函数其实也是判断函数，只不过下面的三个函数返回值不是boolean类型的，我将他们单独罗列出来，其实我们一般不会手动调用这些函数的，数组工具类Arrays中有一个方法排序方法sort()&lt;/p&gt;
&lt;p&gt;public static void sort(Object[] a)：这是不指定排序方式（元素之间怎么比较）的方法，其实内部就是调用自然排序，也就是实现comparable接口实现的comparTo方法&lt;/p&gt;
&lt;p&gt;public static &amp;lt;T&amp;gt; void sort(T[] a, Comparator&amp;lt;? super T&amp;gt; c)：这是指定外部比较器的方法，这个比较器就是新建一个类实现Comparator接口重写compare方法的比较方式，要比较的类型当做泛型传递进去，&lt;/p&gt;
&lt;p&gt;在String类中，写了一个成员内部类来实现这个比较器，在重写compare方法，得到的功能是忽略大小写的比较，在public int compareToIgnoreCase(String str)方法内得到体现，其实这个方法和public boolean equalsIgnoreCase(String anotherString)功能是一样的&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(String anotherString)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;String&amp;gt; CASE_INSENSITIVE_ORDER = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CaseInsensitiveComparator();    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compareToIgnoreCase(String str)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;查询函数：&lt;/h3&gt;
&lt;p&gt;　　很常用的一些函数，具体作用是查询某个字符或字符串的位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length()&lt;br/&gt;　　 返回字符串的长度，也就是value的长度
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; charAt(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index)&lt;br/&gt;　　 返回字符串中某个下标对应的字符，很实用的方法
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; codePointAt(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index)&lt;br/&gt;　　 还记得codePoint是什么吗？他为什么是int类型的呢？去上面看看就明白了。返回对应下标的Unicode codePoint
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; codePointBefore(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index)&lt;br/&gt;　　 返回对应下标前一个的Unicode codePoint
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; codePointCount(&lt;span&gt;int&lt;/span&gt; beginIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; endIndex)&lt;br/&gt;　 　返回指定范围内Unicode codePoint的总数
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; offsetByCodePoints(&lt;span&gt;int&lt;/span&gt; index, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; codePointOffset)&lt;br/&gt;　　 返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ch)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(&lt;span&gt;int&lt;/span&gt; ch, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ch)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(&lt;span&gt;int&lt;/span&gt; ch, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(String str)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(String str, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastIndexOf(String str)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(String str, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ch)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(&lt;span&gt;int&lt;/span&gt; ch, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ch)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(&lt;span&gt;int&lt;/span&gt; ch, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(String str)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexOf(String str, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fromIndex)    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastIndexOf(String str)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lastIndexOf(String str, &lt;span&gt;int&lt;/span&gt; fromIndex)&lt;br/&gt;　　上面的indexOf方法都是返回指定字符或者字符串第一次出现的下标，lastIndexOf是返回指定字符或者字符串的最后一次出现的下标，fromIndex用于指定开始的位置，这里需要注意一点：&lt;br/&gt;　　　　从我们的习惯出发，肯定是自左向右搜索，indexOf方法便是这样自左向右，fromIndex参数用于指定开始搜索的位置&lt;br/&gt;　　　　而lastIndexOf却是自右向左搜索，找到的第一个便是我们要寻找的最后一个字符或字符串，所以fromIndex是指定开始搜索的位置，实际上就是我们习惯自左向右搜索方式的结束位置
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;功能函数：&lt;/h3&gt;
&lt;p&gt;　　平时我们获得字符串可以不是很满意，需要我们通过一些函数去掉里面的某些字符或者替换一些，再或者进行大小写转换，没错，下面的函数你都会用到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; String substring(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; beginIndex)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String substring(&lt;span&gt;int&lt;/span&gt; beginIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; endIndex)&lt;br/&gt;　　切片函数，说实话我学java到现在，不知道怎么叫这个函数，只时称呼他substring，这几天在看python，python里面是切片函数，听起来还不错就借用啦，哈哈，顾名思义，用一个字符串切出你想要的部分，说实话java中的切片函数远没有python中的好用，大家去看看python的就明白了
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CharSequence subSequence(&lt;span&gt;int&lt;/span&gt; beginIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; endIndex)&lt;br/&gt;　　也是切片，返回的是CharSequence接口对象，说实话返回的就是一个String对象（自己去看源码就知道了），其实就是一个向上转型（CharSequence s =  new String()）。
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String concat(String str)&lt;br/&gt;　　类似于StringBUffer中的append函数，在字符串的结尾追加字符串，其内部调用的就是String(char[] ,boolean)构造器的，但是这种字符串追加的代价高昂，所以我们一般选择StringBuffer和StringBuilder
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String replace(&lt;span&gt;char&lt;/span&gt; oldChar, &lt;span&gt;char&lt;/span&gt;&lt;span&gt; newChar)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String replaceFirst(String regex, String replacement)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String replaceAll(String regex, String replacement)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String replace(CharSequence target, CharSequence replacement)&lt;br/&gt;　　以上四个是替换函数，其中第一个只能替换字符串中的所有的指定字符，注意只能替换单个字符&lt;br/&gt;而第四个函数重构此方法后参数就变为了CharSequence接口，现在对CharSequence很熟悉了吧，所以replace其实什么都可替换，只不过一般我们都是操作字符串String，所以经常使用的是第三个。而第二个仅仅替换找到的第一个指定字符串&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; String[] split(String regex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; limit)
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; String[] split(String regex)&lt;br/&gt;　　切割函数，根据指定的正则表达式切割字符串，返回结果是String数组，其中参数limit用于现代最终字符串数组的长度，前面都讲过了，不进行详细的讲解了
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; String toLowerCase(Locale locale)
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; String toLowerCase()
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; String toUpperCase(Locale locale)
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; String toUpperCase()&lt;br/&gt;　　将字符串中的字符全部转换为大写或者小写，其中locale用于指定本地规则
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; String trim()&lt;br/&gt;　　去除字符串两端的空格，很实用的小函数
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; String intern();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个函数intern很有意思，作为一个native方法，很底层，但是我们依然可以通过一个例子来揭开它神秘的面纱，我们明天实战练习见！！！&lt;/p&gt;
&lt;p&gt;写了一天，可能有些字打错了，或有些没讲清楚，望大家见谅☆￣(＞。☆)。&lt;/p&gt;

</description>
<pubDate>Thu, 26 Jul 2018 15:06:00 +0000</pubDate>
<dc:creator>GolLong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gollong/p/9372868.html</dc:identifier>
</item>
<item>
<title>有轻功：用3行代码让Python数据处理脚本获得4倍提速 - 爱喵的程序员</title>
<link>http://www.cnblogs.com/pythonyezi/p/9375006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonyezi/p/9375006.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180726/539531e2e0e74d5f8bab1799fabace01.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python是一门非常适合处理数据和自动化完成重复性工作的编程语言，我们在用数据训练机器学习模型之前，通常都需要对数据进行预处理，而Python就非常适合完成这项工作，比如需要重新调整几十万张图像的尺寸，用Python没问题！你几乎总是能找到一款可以轻松完成数据处理工作的Python库。&lt;/p&gt;
&lt;p&gt;然而，虽然Python易于学习，使用方便，但它并非运行速度最快的语言。默认情况下，Python程序使用一个CPU以单个进程运行。不过如果你是在最近几年配置的电脑，通常都是四核处理器，也就是有4个CPU。这就意味着在你苦苦等待Python脚本完成数据处理工作时，你的电脑其实有75%甚至更多的计算资源就在那闲着没事干！&lt;/p&gt;
&lt;p&gt;今天我（作者Adam Geitgey——译者注）就教大家怎样通过并行运行Python函数，充分利用你的电脑的全部处理能力。得益于Python的 concurrent.futures 模块，我们只需3行代码，就能将一个普通数据处理脚本变为能并行处理数据的脚本，提速4倍。&lt;/p&gt;
&lt;p&gt;普通Python处理数据方法&lt;/p&gt;
&lt;p&gt;比方说，我们有一个全是图像数据的文件夹，想用Python为每张图像创建缩略图。&lt;/p&gt;
&lt;p&gt;下面是一个短暂的脚本，用Python的内置glob函数获取文件夹中所有JPEG图像的列表，然后用Pillow图像处理库为每张图像保存大小为128像素的缩略图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180726/ad100b4c88024dbd96dd5fc1e5b7c0de.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这段脚本沿用了一个简单的模式，你会在数据处理脚本中经常见到这种方法：&lt;/p&gt;
&lt;p&gt;首先获得你想处理的文件（或其它数据）的列表&lt;/p&gt;
&lt;p&gt;写一个辅助函数，能够处理上述文件的单个数据&lt;/p&gt;
&lt;p&gt;使用for循环调用辅助函数，处理每一个单个数据，一次一个。&lt;/p&gt;
&lt;p&gt;咱们用一个包含1000张JPEG图像的文件夹测试一下这段脚本，看看运行完要花多长时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180726/2c5d6703ca31444d865796f1ef0f5494.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行程序花了8.9秒，但是电脑的真实工作强度怎样呢？&lt;/p&gt;
&lt;p&gt;我们再运行一遍程序，看看程序运行时的活动监视器情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180726/8227412739934d1cb0f4dee19c791e04.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;电脑有75%的处理资源处于闲置状态！这是什么情况？&lt;/p&gt;
&lt;p&gt;这个问题的原因就是我的电脑有4个CPU，但Python只使用了一个。所以程序只是卯足了劲用其中一个CPU，另外3个却无所事事。因此我需要一种方法能将工作量分成4个我能并行处理的单独部分。幸运的是，Python中有个方法很容易能让我们做到！&lt;/p&gt;
&lt;p&gt;试试创建多进程&lt;/p&gt;
&lt;p&gt;下面是一种可以让我们并行处理数据的方法：&lt;/p&gt;
&lt;p&gt;1.将JPEG文件划分为4小块。 2.运行Python解释器的4个单独实例。 3.让每个Python实例处理这4块数据中的一块。 4.将这4部分的处理结果合并，获得结果的最终列表。&lt;/p&gt;
&lt;p&gt;4个Python拷贝程序在4个单独的CPU上运行，处理的工作量应该能比一个CPU大约高出4倍，对吧？&lt;/p&gt;
&lt;p&gt;最妙的是，Python已经替我们做完了最麻烦的那部分工作。我们只需告诉它想运行哪个函数以及使用多少实例就行了，剩下的工作它会完成。整个过程我们只需要改动3行代码。&lt;/p&gt;
&lt;p&gt;首先，我们需要导入concurrent.futures库，这个库就内置在Python中：&lt;/p&gt;
&lt;p&gt;import concurrent.futures&lt;/p&gt;
&lt;p&gt;接着，我们需要告诉Python启动4个额外的Python实例。我们通过让Python创建一个Process Pool来完成这一步：&lt;/p&gt;
&lt;p&gt;with concurrent.futures.ProcessPoolExecutor() as executor:&lt;/p&gt;
&lt;p&gt;默认情况下，它会为你电脑上的每个CPU创建一个Python进程，所以如果你有4个CPU，就会启动4个Python进程。&lt;/p&gt;
&lt;p&gt;最后一步是让创建的Process Pool用这4个进程在数据列表上执行我们的辅助函数。完成这一步，我们要将已有的for循环：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180726/10057450f96a46bc93da3cf813d9381b.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该executor.map()函数调用时需要输入辅助函数和待处理的数据列表。这个函数能帮我完成所有麻烦的工作，包括将列表分为多个子列表、将子列表发送到每个子进程、运行子进程以及合并结果等。干得漂亮！&lt;/p&gt;
&lt;p&gt;这也能为我们返回每个函数调用的结果。Executor.map()函数会按照和输入数据相同的顺序返回结果。所以我用了Python的zip()函数作为捷径，一步获取原始文件名和每一步中的匹配结果。&lt;/p&gt;
&lt;p&gt;这里是经过这三步改动后的程序代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180726/a17b825bbc4c4ec6aa6403b9d50eeef2.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来运行一下这段脚本，看看它是否以更快的速度完成数据处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180726/add9046d7e2e46a48587415525aa6ad6.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;脚本在2.2秒就处理完了数据！比原来的版本提速4倍！之所以能更快的处理数据，是因为我们使用了4个CPU而不是1个。&lt;/p&gt;
&lt;p&gt;但是如果你仔细看看，会发现“用户”时间几乎为9秒。那为何程序处理时间为2.2秒，但不知怎么搞得运行时间还是9秒？这似乎不太可能啊？&lt;/p&gt;
&lt;p&gt;这是因为“用户”时间是所有CPU时间的总和，我们最终完成工作的CPU时间总和一样，都是9秒，但我们使用4个CPU完成的，实际处理数据时间只有2.2秒！&lt;/p&gt;
&lt;p&gt;注意：启用更多Python进程以及给子进程分配数据都会占用时间，因此靠这个方法并不能保证总是能大幅提高速度。如果你要处理非常大的数据集，这里有篇设置将数据集切分成多少小块的文章，可以读读，会对你帮助甚大.&lt;/p&gt;
&lt;p&gt;这种方法总能帮我的数据处理脚本提速吗？&lt;/p&gt;
&lt;p&gt;如果你有一列数据，并且每个数据都能单独处理时，使用我们这里所说的Process Pools是一个提速的好方法。下面是一些适合使用并行处理的例子：&lt;/p&gt;
&lt;p&gt;从一系列单独的网页服务器日志里抓取统计数据。&lt;/p&gt;
&lt;p&gt;从一堆XML，CSV和JSON文件中解析数据。&lt;/p&gt;
&lt;p&gt;对大量图片数据做预处理，建立机器学习数据集。&lt;/p&gt;
&lt;p&gt;但也要记住，Process Pools并不是万能的。使用Process Pool需要在独立的Python处理进程之间来回传递数据。如果你要处理的数据不能在处理过程中被有效地传递，这种方法就行不通了。简而言之，你处理的数据必须是Python知道怎么应对的类型。&lt;/p&gt;
&lt;p&gt;同时，也无法按照一个预想的顺序处理数据。如果你需要前一步的处理结果来进行下一步，这种方法也行不通。&lt;/p&gt;
&lt;p&gt;那GIL的问题呢？&lt;/p&gt;
&lt;p&gt;你可能知道Python有个叫全局解释器锁（Global Interpreter Lock）的东西，即GIL。这意味着即使你的程序是多线程的，每个线程也只能执行一个Python指令。GIL确保任何时候都只有一个Python线程执行。换句话说，多线程的Python代码并不能真正地并行运行，从而无法充分利用多核CPU。&lt;/p&gt;
&lt;p&gt;但是Process Pool能解决这个问题！因为我们是运行单独的Python实例，每个实例都有自己的GIL。这样我们获得是真正能并行处理的Python代码！&lt;/p&gt;
&lt;p&gt;不要害怕并行处理！&lt;/p&gt;
&lt;p&gt;有了concurrent.futures库，Python就能让你简简单单地修改一下脚本后，立刻让你电脑上所有CPU投入到工作中。不要害怕尝试这种方法，一旦你掌握了，它就跟一个for循环一样简单，却能让你的数据处理脚本快到飞起。&lt;/p&gt;
&lt;p&gt;我有一个微信公众号，经常会分享一些python技术相关的干货；如果你喜欢我的分享，可以用微信搜索“python语言学习”&lt;br/&gt;关注&lt;/p&gt;
&lt;p&gt;欢迎大家加入千人交流答疑裙：699+749+852&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 15:05:00 +0000</pubDate>
<dc:creator>爱喵的程序员</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonyezi/p/9375006.html</dc:identifier>
</item>
<item>
<title>Android位置权限以及数组寻找索引的坑 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/9374931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/9374931.html</guid>
<description>&lt;p&gt;填坑与求解惑来的。&lt;/p&gt;
&lt;h2 id=&quot;一android-危险权限来自官方文档的坑&quot;&gt;一、Android 危险权限，来自官方文档的坑？？？&lt;/h2&gt;
&lt;p&gt;Android开发者都知道，Android 6.0 之前，权限申请只需要在 AndroidManifest.xml 文件中声明就可以。Android 6.0 开始，权限申请发生了变化，危险权限需要在应用中动态申请，之前写过一篇 Android 动态申请危险权限的笔记，详情参考： &lt;a href=&quot;http://www.cnblogs.com/joy99/p/6023247.html&quot;&gt;Android 6.0 动态申请危险权限&lt;/a&gt;。&lt;br/&gt;先截个图，看看Android官方的说明：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758949/201807/758949-20180726224516945-1009773519.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看危险权限的分组情况：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758949/201807/758949-20180726224537004-1356858107.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;意思是，对危险权限进行了分组，同一组中，只要有有一个权限被授权了，同组中其它权限也就默认授权了。比如，我授权应用有读存储卡的权限之后，应用也就有了写存储卡的权限，事实上也确实如此。&lt;br/&gt;然而问题来了，利用 GPS 获取位置信息的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LocationManager locationManager = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
if(locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)){
    if(ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
                != PackageManager.PERMISSION_GRANTED &amp;amp;&amp;amp; ActivityCompat.checkSelfPermission
                (MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION)
                != PackageManager.PERMISSION_GRANTED){
        // request permissions
        // ...
        // ...
    }else{         
        Location location = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER;
        if(location != null){  
            double latitude = location.getLatitude();  
            double longitude = location.getLongitude();  
        }  
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过官方的危险权限组，我们也能看到：Location 权限组里包含：&lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; 和 &lt;code&gt;ACCESS_COARSE_LOCATION&lt;/code&gt; 两个权限，按照上面的说明，两个权限只要有一个申请授权成功，即可成功获取经纬度。——&lt;strong&gt;然鹅，当成功申请了&lt;/strong&gt; &lt;code&gt;ACCESS_COARSE_LOCATION&lt;/code&gt; &lt;strong&gt;权限后，程序依然会崩，错误信息提示，需要获得&lt;/strong&gt; &lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; &lt;strong&gt;权限&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;二spinner-的-setselection-方法源于自己想当然的坑&quot;&gt;二、Spinner 的 setSelection() 方法，源于自己想当然的坑！！！&lt;/h2&gt;
&lt;p&gt;Android 中的下拉列表控件 spinner 有一个方法 setSelection(int position) ,显示第几项。此方法可能没有效果？？？总是显示第一项？？？&lt;/p&gt;
&lt;p&gt;------------------------------------分割线----------------------------------&lt;/p&gt;
&lt;p&gt;当在做两个spinner联动时，spinner2依据spinner1的选择填充数据，然后使用setSeletion(2)来设置默认项。结果发现：spinner2显示的总是第一项，但是实际选择的确实已经是position 2的位置 。&lt;br/&gt;解决方法：&lt;/p&gt;
&lt;p&gt;旧代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　spinner.setAdapter(adapter);
　　spinner.setSelection(2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方案有二：&lt;/p&gt;
&lt;p&gt;(1)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　spinner.setAdapter(adapter);
　　spinner.setSelection(2,true);  //spinner会重新layout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 推荐&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    spinner.setAdapter(adapter);![](https://images2018.cnblogs.com/blog/758949/201807/758949-20180726224508174-131546620.jpg)

　　adapter.notifyDataSetChanged(); //通知spinner刷新数据
    spinner.setSelection(2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，这到底是什么原因造成的？我认为这是一个bug 。这种情况通常发生在重新填充数据之后，除此之外，使用setSelection(int position)都能得到正确的显示。&lt;/p&gt;
&lt;p&gt;setSelection(int position, boolean animate)和setSelection(int position) 实现机制有较大区别，当调用前者时重新layout，立即触发onItemSelected函数，作用相当于用手直接点击。而后者设置了下次选择位置：setNextSelectedPositionInt(position); 然后请求Layout;，而requestLayout并非立即执行，仅仅是一个schedule。但是后者可能在重新装载数据然后Layout时丢失了某些状态。&lt;/p&gt;
&lt;p&gt;以上分割线中内容系转载：原文链接：https://www.xuebuyuan.com/672724.html&lt;/p&gt;
&lt;p&gt;-------------------------------------分割线------------------------------------------&lt;/p&gt;
&lt;p&gt;然鹅，我要说的坑不是这样，我没有两个 Spinner 联动，我出现的问题是这样的，上代码&lt;br/&gt;布局文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.example.sharpcj.helloworld.MainActivity&quot;&amp;gt;

    &amp;lt;Spinner
        android:id=&quot;@+id/sp_test&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerInParent=&quot;true&quot;&amp;gt;

    &amp;lt;/Spinner&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;java 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example.sharpcj.helloworld;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.Spinner;

import java.util.Arrays;

public class MainActivity extends AppCompatActivity {

    private Spinner mSpTest;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        String[] strs = new String[20];
        for (int i = 0; i &amp;lt; strs.length; i++) {
            strs[i] = &quot;第&quot; + i + &quot;项&quot;;
        }
        mSpTest = findViewById(R.id.sp_test);
        mSpTest.setAdapter(new ArrayAdapter&amp;lt;&amp;gt;(this, android.R.layout.simple_list_item_1, strs));

        int index = Arrays.binarySearch(strs, &quot;第11项&quot;);
        mSpTest.setSelection(index);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758949/201807/758949-20180726224706536-1783591009.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;what？？？&lt;br/&gt;为什么会这样呢？ spinner 表示这个锅它不背，其实这个坑怪我自己想当然了，原因在于错误地使用了 &lt;code&gt;Arrays.binarySearch(Object[] a , Object key)&lt;/code&gt; 这个方法，想当然地认为了返回值为查找到数组的 index。代码中， index 的实际值是 -2 。&lt;/p&gt;
&lt;p&gt;网上找了一下资料：&lt;br/&gt;&lt;code&gt;binarySearch(int[] a, int key)&lt;/code&gt; 此方法的规则是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、如果找到关键字，则返回值为关键字在数组中的位置索引，且索引从0开始&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;2、如果没有找到关键字，返回值为负的插入点值，所谓插入点值就是第一个比关键字大的元素在数组中的位置索引，而且这个位置索引从1开始。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而&lt;code&gt;binarySearch(Object[] a, Object key)&lt;/code&gt; 最终调用方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // Like public version, but without range checks.
    private static int binarySearch0(Object[] a, int fromIndex, int toIndex,
                                     Object key) {
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &amp;lt;= high) {
            int mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1;
            @SuppressWarnings(&quot;rawtypes&quot;)
            Comparable midVal = (Comparable)a[mid];
            @SuppressWarnings(&quot;unchecked&quot;)
            int cmp = midVal.compareTo(key);

            if (cmp &amp;lt; 0)
                low = mid + 1;
            else if (cmp &amp;gt; 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found.
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于 Object 类型，Oracle 大神写的这个二分法寻找索引的代码暂时没看懂。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 14:44:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy99/p/9374931.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——HttpContext - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9369637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9369637.html</guid>
<description>&lt;p&gt;之前的文章记述了&lt;a href=&quot;https://www.cnblogs.com/kenwoo/p/9309264.html&quot;&gt;从ASP.NET Core Module到KestrelServer&lt;/a&gt;的请求处理过程。现在该聊聊如何生成ASP.NET中我们所熟悉的HttpContext。&lt;/p&gt;
&lt;p&gt;当KestrelServer启动时，会绑定相应的IP地址，同时在绑定时将加入HttpConnectionMiddleware作为终端连接的中间件。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task StartAsync&amp;lt;TContext&amp;gt;(IHttpApplication&amp;lt;TContext&amp;gt; application, CancellationToken cancellationToken)
{
    try
    {
        ...

        async Task OnBind(ListenOptions endpoint)
        {
            // Add the HTTP middleware as the terminal connection middleware
            endpoint.UseHttpServer(endpoint.ConnectionAdapters, ServiceContext, application, endpoint.Protocols);

            var connectionDelegate = endpoint.Build();

            // Add the connection limit middleware
            if (Options.Limits.MaxConcurrentConnections.HasValue)
            {
                connectionDelegate = new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;
            }

            var connectionDispatcher = new ConnectionDispatcher(ServiceContext, connectionDelegate);
            var transport = _transportFactory.Create(endpoint, connectionDispatcher);
            _transports.Add(transport);

            await transport.BindAsync().ConfigureAwait(false);
        }

        await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IConnectionBuilder UseHttpServer&amp;lt;TContext&amp;gt;(this IConnectionBuilder builder, IList&amp;lt;IConnectionAdapter&amp;gt; adapters, ServiceContext serviceContext, IHttpApplication&amp;lt;TContext&amp;gt; application, HttpProtocols protocols)
{
    var middleware = new HttpConnectionMiddleware&amp;lt;TContext&amp;gt;(adapters, serviceContext, application, protocols);
    return builder.Use(next =&amp;gt;
    {
        return middleware.OnConnectionAsync;
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当请求抵达此中间件时，在其OnConnectionAsync方法里会创建HttpConnection对象，并通过该对象处理请求。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task OnConnectionAsync(ConnectionContext connectionContext)
{
    ...

    var connection = new HttpConnection(httpConnectionContext);
    _serviceContext.ConnectionManager.AddConnection(httpConnectionId, connection);

    try
    {
        var processingTask = connection.ProcessRequestsAsync(_application);

        ...
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ProcessRequestsAsync方法内部会根据HTTP协议的不同创建Http1Connection或者Http2Connection对象，一般为Http1Connection。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task ProcessRequestsAsync&amp;lt;TContext&amp;gt;(IHttpApplication&amp;lt;TContext&amp;gt; httpApplication)
{
    try
    {
        ...

        lock (_protocolSelectionLock)
        {
            // Ensure that the connection hasn't already been stopped.
            if (_protocolSelectionState == ProtocolSelectionState.Initializing)
            {
                switch (SelectProtocol())
                {
                    case HttpProtocols.Http1:
                        // _http1Connection must be initialized before adding the connection to the connection manager
                        requestProcessor = _http1Connection = CreateHttp1Connection(_adaptedTransport, application);
                        _protocolSelectionState = ProtocolSelectionState.Selected;
                        break;
                    case HttpProtocols.Http2:
                        // _http2Connection must be initialized before yielding control to the transport thread,
                        // to prevent a race condition where _http2Connection.Abort() is called just as
                        // _http2Connection is about to be initialized.
                        requestProcessor = CreateHttp2Connection(_adaptedTransport, application);
                        _protocolSelectionState = ProtocolSelectionState.Selected;
                        break;
                    case HttpProtocols.None:
                        // An error was already logged in SelectProtocol(), but we should close the connection.
                        Abort(ex: null);
                        break;
                    default:
                        // SelectProtocol() only returns Http1, Http2 or None.
                        throw new NotSupportedException($&quot;{nameof(SelectProtocol)} returned something other than Http1, Http2 or None.&quot;);
                }

                _requestProcessor = requestProcessor;
            }
        }

        if (requestProcessor != null)
        {
            await requestProcessor.ProcessRequestsAsync(httpApplication);
        }

        await adaptedPipelineTask;
        await _socketClosedTcs.Task;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Http1Connection父类HttpProtocol里的ProcessRequests方法会创建一个Context对象，但这还不是最终要找到的HttpContext。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private async Task ProcessRequests&amp;lt;TContext&amp;gt;(IHttpApplication&amp;lt;TContext&amp;gt; application)
{
    // Keep-alive is default for HTTP/1.1 and HTTP/2; parsing and errors will change its value
    _keepAlive = true;

    while (_keepAlive)
    {
        ...

        var httpContext = application.CreateContext(this);

        try
        {
            KestrelEventSource.Log.RequestStart(this);

            // Run the application code for this request
            await application.ProcessRequestAsync(httpContext);

            if (_ioCompleted == 0)
            {
                VerifyResponseContentLength();
            }
        }
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在HostingApplication类中会看到HttpContext原来是由HttpContextFactory工厂类生成的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Context CreateContext(IFeatureCollection contextFeatures)
{
    var context = new Context();
    var httpContext = _httpContextFactory.Create(contextFeatures);

    _diagnostics.BeginRequest(httpContext, ref context);

    context.HttpContext = httpContext;
    return context;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HttpContextFactory类才是最后的一站。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public HttpContext Create(IFeatureCollection featureCollection)
{
    if (featureCollection == null)
    {
        throw new ArgumentNullException(nameof(featureCollection));
    }

    var httpContext = new DefaultHttpContext(featureCollection);
    if (_httpContextAccessor != null)
    {
        _httpContextAccessor.HttpContext = httpContext;
    }

    var formFeature = new FormFeature(httpContext.Request, _formOptions);
    featureCollection.Set&amp;lt;IFormFeature&amp;gt;(formFeature);

    return httpContext;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单理了张流程图总结一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201807/991496-20180726214933077-417105506.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成的HttpContext对象最终传递到IHttpApplication的ProcessRequestAsync方法。之后的事情便是HttpHost与HttpApplication的工作了。&lt;/p&gt;
&lt;p&gt;那么费了这么多工夫，所生成的HttpContext究竟有什么用处呢？&lt;/p&gt;
&lt;p&gt;先查看MSDN上对它的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Encapsulates all HTTP-specific information about an individual HTTP request.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以理解为对于每个单独的HTTP请求，其间所创建的HttpContext对象封装了全部所需的HTTP信息。&lt;/p&gt;
&lt;p&gt;再看其包含的属性：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public abstract class HttpContext
{
    public abstract IFeatureCollection Features { get; }
    public abstract HttpRequest Request { get; }
    public abstract HttpResponse Response { get; }
    public abstract ConnectionInfo Connection { get; }
    public abstract WebSocketManager WebSockets { get; }
    public abstract AuthenticationManager Authentication { get; }
    public abstract ClaimsPrincipal User { get; set; }
    public abstract IDictionary&amp;lt;object, object&amp;gt; Items { get; set; }
    public abstract IServiceProvider RequestServices { get; set; }
    public abstract CancellationToken RequestAborted { get; set; }
    public abstract string TraceIdentifier { get; set; }
    public abstract ISession Session { get; set; }
    public abstract void Abort();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求(Request)，响应(Response)，会话(Session)这些与HTTP接触时最常见到的名词，都出现在HttpContext对象中。说明在处理HTTP请求时，若是需要获取这些相关信息，完全可以通过调用其属性而得到。&lt;/p&gt;
&lt;p&gt;通过传递一个上下文环境参数，以协助获取各环节处理过程中所需的信息，在各种框架中是十分常见的作法。ASP.NET Core里的用法并无特别的创新，但其实用性还是毋庸置疑的。如果想要构建自己的框架时，不妨多参考下ASP.NET Core里的代码，毕竟它已是一个较成熟的产品，其中有许多值得借鉴的地方。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 14:36:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9369637.html</dc:identifier>
</item>
<item>
<title>HDU 2015 （水） - GerJCS</title>
<link>http://www.cnblogs.com/mimangdewo-a1/p/9374839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mimangdewo-a1/p/9374839.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a title=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2015&quot; href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2015&quot; target=&quot;_blank&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=2015&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;给你个长度为n(n&amp;lt;=100)的数列，该数列定义为从2开始的递增有序偶数，让你按顺序每m个数求出一个平均值，如果最后不足m个，则以实际数量求平均值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 记录 n = 100 的数列的 100 个 前 n(n为1 ~ 100) 项和，一个长度为 n 的 “滑动窗口”， 从头滑动到尾，过程中每次停滞都做一次除以 n 的操作并输出，注意格式，最后判断有没有剩下的了，有就输出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PS：&lt;/strong&gt;感觉自己代码写的好丑，思路好挫，因为既然是偶数应该有办法不去计算，直接输出某个数，或者某两个数的平均数，先上AC代码吧，其他的学会了一会来更新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（代码和题目 m, n的意思反了，代码 m 表示长度为 m 的数列，n 表示每 n 个求平均值）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cmath&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;iomanip&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include&amp;lt;algorithm&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s[&lt;span&gt;105&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100&lt;/span&gt;; i ++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         s[i] = s[i - &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m, n;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt;&lt;span&gt; n)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= m / n; i ++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(i == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 cout &amp;lt;&amp;lt; (s[n * i] - s[n * i - n]) /&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (s[n * i] - s[n * i - n]) /&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(m % n != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (s[m] - s[m / n * n]) / (m - m / n *&lt;span&gt; n);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         cout &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 4 6 8 10&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更好的办法&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;                          &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                      **********更新*********&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;学会了方法二：&lt;a title=&quot;http://www.cnblogs.com/ibosong/archive/2012/02/16/2353499.html&quot; href=&quot;http://www.cnblogs.com/ibosong/archive/2012/02/16/2353499.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/ibosong/archive/2012/02/16/2353499.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路挺好的，不需开数组，一次遍历，途中有能整除 n 的，就输出一次，数列结束了就判断是否有剩下的数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现规律 hdoj  P11 这前几道题就是可以优化，少去开数组，只用一个变量就可以解决的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;                      **********第二次更新*********&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;超级开心，网上没找到这种方法&lt;img src=&quot;https://images2018.cnblogs.com/blog/874109/201807/874109-20180726235712631-401133716.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但感觉挺开心挺好的思路，拿到现场塞上去写好疼啊，又耗时间（思考时间），又不好搞，还是方法一正常一下吧，感觉思路好但显现效果不大&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1A代码：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cmath&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;iomanip&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include&amp;lt;algorithm&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s[&lt;span&gt;105&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m, n;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt;&lt;span&gt; n)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= m / n; i ++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(i == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 cout &amp;lt;&amp;lt; n + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; n + &lt;span&gt;1&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt; * n * (i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(m % n != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (m + m * m - (m / n * n + pow(m / n * n, &lt;span&gt;2&lt;/span&gt;))) / (m - m / n *&lt;span&gt; n);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         cout &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 26 Jul 2018 14:27:00 +0000</pubDate>
<dc:creator>GerJCS</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mimangdewo-a1/p/9374839.html</dc:identifier>
</item>
</channel>
</rss>