<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>DNS 访问 Service - 每天5分钟玩转 Docker 容器技术（138） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8512231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8512231.html</guid>
<description>&lt;p&gt;&lt;span&gt;在 Cluster 中，除了可以通过 Cluster IP 访问 Service，Kubernetes 还提供了更为方便的 DNS 访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kubeadm 部署时会默认安装 kube-dns 组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063218723-628460204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;kube-dns 是一个 DNS 服务器。每当有新的 Service 被创建，kube-dns 会添加该 Service 的 DNS 记录。Cluster 中的 Pod 可以通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;SERVICE_NAME&amp;gt;.&amp;lt;NAMESPACE_NAME&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 访问 Service。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd-svc.default&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 访问 Service &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063233205-1056243030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如上所示，我们在一个临时的 busybox Pod 中验证了 DNS 的有效性。另外，由于这个 Pod 与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 同属于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;default&lt;/span&gt;&lt;/code&gt;&lt;span&gt; namespace，可以省略 &lt;/span&gt;&lt;code&gt;&lt;span&gt;default&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 直接用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 访问 Service。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063246715-974714868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nslookup&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 DNS 的信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063257825-1500177874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;DNS 服务器是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-dns.kube-system.svc.cluster.local&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这实际上就是 kube-dns 组件，它本身是部署在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-system&lt;/span&gt;&lt;/code&gt;&lt;span&gt; namespace 中的一个 Service。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;httpd-svc.default.svc.cluster.local&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的完整域名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果要访问其他 namespace 中的 Service，就必须带上 namesapce 了。&lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get namespace&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看已有的 namespace。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063439122-1021230417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-public&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中部署 Service &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd2-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，配置如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063455181-148692124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;namespace: kube-public&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定资源所属的 namespace。多个资源可以在一个 YAML 文件中定义，用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 分割。执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建资源：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063507946-441107958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-public&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 Service：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063522543-286081000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在 busybox Pod 中访问 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd2-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180306063534602-1825284509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为属于不同的 namespace，必须使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpd2-svc.kube-public&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 才能访问到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes 集群内部可以通过 Cluster IP 和 DNS 访问 Service，那么集群外部如何访问呢？下一节我们将讨论这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://item.jd.com/16936307278.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Mar 2018 22:21:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8512231.html</dc:identifier>
</item>
<item>
<title>Django2.0文档 - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8508914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8508914.html</guid>
<description>&lt;h2&gt;第四章 模板&lt;/h2&gt;
&lt;h3&gt; 1.标签&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(1)if/else&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;{% if %} 标签检查(evaluate)一个变量，如果这个变量为真（即，变量存在，非空，不是布尔值假），系统会&lt;br/&gt;显示在 {% if %} 和 {% endif %} 之间的任何内容，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% if today_is_weekend %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Welcome to the weekend!&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endif %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;{% else %} 标签是可选的：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% if today_is_weekend %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Welcome to the weekend!&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% else %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Get back to work.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endif %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;{% if %} 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)for&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;{% for %} 允许我们在一个序列上迭代。 与Python的 for 语句的情形类似，循环语法是 for X in Y ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。 每一次循环中，模板系统会渲染在 {% for %} 和&lt;br/&gt;{% endfor %} 之间的所有内容。&lt;/p&gt;
&lt;p&gt;例如，给定一个运动员列表 athlete_list 变量，我们可以使用下面的代码来显示这个列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% for athlete in athlete_list %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ athlete.name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endfor %}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给标签增加一个 reversed 使得该列表被反向迭代：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% for athlete in athlete_list reversed %}
...
{% endfor %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以嵌套使用 {% for %} 标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% for athlete in athlete_list %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ athlete.name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% for sport in athlete.sports_played %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ sport }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endfor %}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endfor %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Django不支持退出循环操作。 如果我们想退出循环，可以改变正在迭代的变量，让其仅仅包含需要迭代的项目。 同理，Django也不支持continue语句，我们无法让当前迭代操作跳回到循环头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在每个`` {% for %}``循环里有一个称为`` forloop`` 的模板变量。这个变量有一些提示循环进度信息的属性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;forloop.counter 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的，所以在第一次循环时 forloop.counter 将会被设置为1。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; lists(request):
    lists &lt;/span&gt;= [1,2,3,4,5&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lists.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lists&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:lists})
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt; {% for item in lists %}
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ forloop.counter }}:{{ item }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% endfor %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1:1

2:2

3:3

4:4

5:5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;--&amp;gt;&amp;gt;forloop.counter0 类似于 forloop.counter ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0。&lt;/p&gt;
&lt;p&gt;--&amp;gt;&amp;gt;forloop.revcounter0 类似于 forloop.revcounter ，但它以0做为结束索引。 在第一次执行循环时，该变量会被置为序列的项的个数减1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;forloop.first 是一个布尔值，如果该迭代是第一次执行，那么它被置为````&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; {% for item in lists %}
        {% if forloop.first %}
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color: red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ forloop.counter }}:{{ item }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% else %}
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ forloop.counter }}:{{ item }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% endif %}

    {% endfor %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180305142242967-507511244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;forloop.last 是一个布尔值；在最后一次执行循环时被置为True。&lt;/p&gt;
&lt;p&gt;forloop.parentloop 是一个指向当前循环的上一级循环的 forloop 对象的引用（在嵌套循环的情况下）。&lt;/p&gt;
&lt;h3&gt;2.注释&lt;/h3&gt;
&lt;p&gt;就像HTML或者Python，Django模板语言同样提供代码注释。 注释使用 {# #} ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{# This is a comment #}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要实现多行注释，可以使用`` {% comment %}`` 模板标签，就像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% comment %}
This is a
multi‐line comment.
{% endcomment %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.过滤器&lt;/h3&gt;
&lt;p&gt;模板过滤器是在变量被显示前修改它的值的一个简单方法。 过滤器使用管道字符，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{ name|lower }}    #它功能是转换文本为小写。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过滤管道可以被* 套接* ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入，如此下去&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{ my_list|first|upper }}   #查找列表的第一个元素并将其转化为大写。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.locals() 技巧&lt;/h3&gt;
&lt;p&gt;如果你是个喜欢偷懒的程序员并想让代码看起来更加简明，可以利用 Python 的内建函数 locals() 。它返回的字典对所有局部变量的名称与值进行映射。 因此，前面的视图可以重写成下面这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; lists(request):
    lists &lt;/span&gt;= [1,2,3,4,5&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lists.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;locals() 的值，它囊括了函数执行到该时间点时所定义的一切变量&lt;/p&gt;
&lt;h3&gt;5.模板继承&lt;/h3&gt;
&lt;p&gt; (1)定义基础模板base.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{% block title %}{% endblock %}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My helpful timestamp site&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% block content %}{% endblock %}
    {% block footer %}
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Thanks for visiting my site&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% endblock %}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个叫做 base.html 的模板定义了一个简单的 HTML 框架文档，我们将在所有页面中使用。 子模板的作用就是重载、添加或保留那些块的内容。&lt;br/&gt;所有的 {% block %} 标签告诉模板引擎，子模板可以重载这些部分。 每个 {% block %} 标签所要做的是告诉模板引擎，该模板下的这一块内容将有可能被子模板覆盖。&lt;/p&gt;
&lt;p&gt;(2)子模板current_time.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% extends 'base.html' %}

{% block title %}The current time{% endblock%}

{% block content %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;It is now {{ current_date }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endblock %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse,render

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; current_datetime(request):
    current_date &lt;/span&gt;=&lt;span&gt; datetime.datetime.now()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cuttent_datetime.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;current_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:current_date})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       以下是其工作方式：在加载 current_datetime.html 模板时，模板引擎发现了 {% extends %} 标签，模板引擎立即装载其父模板，即本例中的 base.html 。此时，模板引擎注意到 base.html 中的三个 {% block %} 标签，并用子模板的内容替换这些 block 。因此，引擎将会使用我们在 { block title %} 中定义的标题，对 {% block content %} 也是如此。 所以，网页标题一块将由 {% block title %} 替换，同样地，网页的内容一块将由 {% block content %} 替换。注意由于子模板并没有定义 footer 块，模板系统将使用在父模板中定义的值。 父模板 {% block %} 标签中的内容总是被当作一条退路。继承并不会影响到模板的上下文。 换句话说，任何处在继承树上的模板都可以访问到你传到模板中的每一个模板变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7e8a94a1-2a72-4cd7-90ae-e41052e97573')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7e8a94a1-2a72-4cd7-90ae-e41052e97573&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7e8a94a1-2a72-4cd7-90ae-e41052e97573&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7e8a94a1-2a72-4cd7-90ae-e41052e97573',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7e8a94a1-2a72-4cd7-90ae-e41052e97573&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
如果在模板中使用 {% extends %&lt;span&gt;} ，必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作
用。
一般来说，基础模板中的 {&lt;/span&gt;% block %&lt;span&gt;} 标签越多越好。 记住，子模板不必定义父模板中所有的代码块，因
此你可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。 俗话
说，钩子越多越好。
如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个 {&lt;/span&gt;% block %&lt;span&gt;} 中。
如果你需要访问父模板中的块的内容，使用 {{ block.super }} 这个标签吧，这一个魔法变量将会表现出
父模板中的内容。 如果只想在上级代码块基础上添加内容，而不是全部重载，该变量就显得非常有用了。
不允许在同一个模板中定义多个同名的 {&lt;/span&gt;% block %&lt;span&gt;} 。 存在这样的限制是因为block 标签的工作方式是双
向的。 也就是说，block 标签不仅挖了一个要填的坑，也定义了在 父 模板中这个坑所填充的内容。如果模
板中出现了两个相同名称的 {&lt;/span&gt;% block %&lt;span&gt;} 标签，父模板将无从得知要使用哪个块的内容。
{&lt;/span&gt;% extends %&lt;span&gt;} 对所传入模板名称使用的加载方法和 get_template() 相同。 也就是说，会将模板名称被添
加到 TEMPLATE_DIRS 设置之后。
多数情况下， {&lt;/span&gt;% extends %&lt;span&gt;} 的参数应该是字符串，但是如果直到运行时方能确定父模板名，这个参数也
可以是个变量。 这使得你能够实现一些很酷的动态功能。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;模板继承的一些诀窍&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt; 第五章 模型&lt;/h2&gt;
&lt;h3&gt; 1.MTV and MVC&lt;/h3&gt;
&lt;p&gt;把数据存取逻辑、业务逻辑和表现逻辑组合在一起的概念有时被称为软件架构的Model-View-Controller(MVC)模式。 在这个模式中， Model 代表数据存取层，View 代表的是系统中选择显示什么和怎么显示的部分，Controller 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。&lt;/p&gt;
&lt;p&gt; 　   M:数据存取部分，由django数据库层处理，本章要讲述的内容。&lt;/p&gt;
&lt;p&gt;　　V:选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。&lt;/p&gt;
&lt;p&gt;　　C:根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的Python 函数&lt;/p&gt;
&lt;p&gt; 由于 C 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），Django 也被称为MTV 框架。在 MTV 开发模式中：&lt;/p&gt;
&lt;p&gt; 　　M:代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等&lt;/p&gt;
&lt;p&gt; 　　T:代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。&lt;/p&gt;
&lt;p&gt;　　V:代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。&lt;/p&gt;
&lt;h3&gt; 2.设置数据库为Mysql&lt;/h3&gt;
&lt;p&gt; 在settings里面修改配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
DATABASES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ENGINE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.db.backends.mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据库名字&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;USER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;账号&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PASSWORD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在app的init.py里面导入pymysql模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
pymysql.install_as_MySQLdb()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置好后打开 python manage.py shell 来进行测试。输入一下命令，如果没有报错说明，说明数据库配置是正确的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; connection
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; cursor = connection.cursor()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.第一个模型&lt;/h3&gt;
&lt;p&gt;书籍/作者/出版商 数据库&lt;/p&gt;
&lt;p&gt;　　 一个作者有姓，有名及email地址。&lt;/p&gt;
&lt;p&gt;　　出版商有名称，地址，所在城市、省，国家，网站。&lt;/p&gt;
&lt;p&gt;　　书籍有书名和出版日期。 它有一个或多个作者（和作者是多对多的关联关系[many-to-many]）， 只有一个出版商（和出版商是一对多的关联关系[one-to-many]，也被称作外　         键[foreign key]）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Publisher(models.Model):
    name &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    address &lt;/span&gt;= models.CharField(max_length=50&lt;span&gt;)
    city &lt;/span&gt;= models.CharField(max_length=60&lt;span&gt;)
    state_province &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    country &lt;/span&gt;= models.CharField(max_length=50&lt;span&gt;)
    website &lt;/span&gt;=&lt;span&gt; models.URLField()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Author(models.Model):
    first_name &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    last_name &lt;/span&gt;= models.CharField(max_length=40&lt;span&gt;)
    email &lt;/span&gt;=&lt;span&gt; models.EmailField()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book(models.Model):
    title &lt;/span&gt;= models.CharField(max_length=100&lt;span&gt;)
    publication_date &lt;/span&gt;=&lt;span&gt; models.DateField()
    authors &lt;/span&gt;=&lt;span&gt; models.ManyToManyField(Author)
    publisher &lt;/span&gt;= models.ForeignKey(Publisher,on_delete = models.CASCADE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开shell,添加publisher&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180305234357406-173532836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们打印整个publisher列表时，我们没有得到想要的有用信息，只需要为Publisher对象添加一个__str__方法 ,就可以对Publisher对象更容易理解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ea53ece0-7736-4d1d-9617-81ac21656cb0')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ea53ece0-7736-4d1d-9617-81ac21656cb0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ea53ece0-7736-4d1d-9617-81ac21656cb0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ea53ece0-7736-4d1d-9617-81ac21656cb0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ea53ece0-7736-4d1d-9617-81ac21656cb0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Publisher(models.Model):
    name &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    address &lt;/span&gt;= models.CharField(max_length=50&lt;span&gt;)
    city &lt;/span&gt;= models.CharField(max_length=60&lt;span&gt;)
    state_province &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    country &lt;/span&gt;= models.CharField(max_length=50&lt;span&gt;)
    website &lt;/span&gt;=&lt;span&gt; models.URLField()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Author(models.Model):
    first_name &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    last_name &lt;/span&gt;= models.CharField(max_length=40&lt;span&gt;)
    email &lt;/span&gt;=&lt;span&gt; models.EmailField()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(self.first_name,self.last_name)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book(models.Model):
    title &lt;/span&gt;= models.CharField(max_length=100&lt;span&gt;)
    publication_date &lt;/span&gt;=&lt;span&gt; models.DateField()
    authors &lt;/span&gt;=&lt;span&gt; models.ManyToManyField(Author)
    publisher &lt;/span&gt;= models.ForeignKey(Publisher,on_delete =&lt;span&gt; models.CASCADE)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.title
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;添加__str__方法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180305234956564-1935312894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.数据过滤&lt;/h3&gt;
&lt;p&gt; 可以使用`` filter()`` 方法对数据进行过滤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306000041969-2023439238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以传入多个参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Publisher.objects.filter(country=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;U.S.A.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, state_province=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;魔术般的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Publisher.objects.filter(name__contains=&lt;span&gt;&quot;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306000340033-841695995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他的一些查找类型有：&lt;/p&gt;
&lt;p&gt;　　icontains(大小写无关的LIKE),startswith和endswith, 还有range&lt;/p&gt;
&lt;h3&gt;5.获取单个对象&lt;/h3&gt;
&lt;p&gt;上面的例子中`` filter()`` 函数返回一个记录集，这个记录集是一个列表。 相对列表来说，有些时候我们更需要获取单个的对象， `` get()`` 方法就是在此时使用的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306000625628-661679251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，就返回了单个对象，而不是列表（更准确的说，QuerySet)。 所以，如果结果是多个对象，会导致抛出异常：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306000729214-286386157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果查询没有返回结果也会抛出异常：&lt;/p&gt;
&lt;h3&gt; 6.数据排序&lt;/h3&gt;
&lt;p&gt;在运行前面的例子中，你可能已经注意到返回的结果是无序的。 我们还没有告诉数据库 怎样对结果进行排序，所以我们返回的结果是无序的。&lt;/p&gt;
&lt;p&gt;在你的 Django 应用中，你或许希望根据某字段的值对检索结果排序，比如说，按字母顺序。 那么，使用order_by()这个方法就可以搞定了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306001006863-1176904402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以对任意字段进行排序,如果需要以多个字段为标准进行排序（第二个字段会在第一个字段的值相同的情况下被使用到），使用多个参数就可以了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306001121280-1876113272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们还可以指定逆向排序，在前面加一个减号‐前缀：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306001238956-1767388705.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;限制返回的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306001939325-595917136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.更新和删除对象&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录。 以下示例演示如何将所有Publisher的country字段值由’U.S.A’更改为’USA’：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306002345927-1659597781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;update()方法会返回一个整型数值，表示受影响的记录条数。 在上面的例子中，这个值是2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 删除数据库中的对象只需调用该对象的delete()方法即可：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306002552371-1348838387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第六章 Django站点管理&lt;/h2&gt;
&lt;h3&gt; 1.创建admin用户&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python manage.py createsuperuser
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 访问：http://127.0.0.1:8000/admin/，输入用户名，密码登录进入管理界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306004852702-971367280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到只有Groutps和Users&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306010049859-385783466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要向让app book里面的models显示在这里面，只需把book注册到admin&lt;/p&gt;
&lt;p&gt;book app下的admin.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; book &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Register your models here.&lt;/span&gt;
&lt;span&gt;admin.site.register(models.Author)
admin.site.register(models.Book)
admin.site.register(models.Publisher)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以在管理界面看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306010439205-1848257673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中文显示的方法：Meta&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Publisher(models.Model):
    name &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    address &lt;/span&gt;= models.CharField(max_length=50&lt;span&gt;)
    city &lt;/span&gt;= models.CharField(max_length=60&lt;span&gt;)
    state_province &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    country &lt;/span&gt;= models.CharField(max_length=50&lt;span&gt;)
    website &lt;/span&gt;=&lt;span&gt; models.URLField()

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        verbose_name_plural &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.Admin工作原理&lt;/h3&gt;
&lt;p&gt;当服务启动时，Django从`` url.py`` 引导URLconf，然后执行`` admin.autodiscover()`` 语句。 这个函数遍历INSTALLED_APPS配置，并且寻找相关的admin.py文件。 如果在指定的app目录下找到admin.py，它就执行其中的代码。&lt;/p&gt;
&lt;p&gt;在`` book`` 应用程序目录下的`` admin.py`` 文件中，每次调用`` admin.site.register()`` 都将那个模块注册到管理工具中。 管理工具只为那些明确注册了的模块显示一个编辑/修改的界面。应用程序`` django.contrib.auth`` 包含自身的`` admin.py`` ，所以Users和Groups能在管理工具中自动显示。其它的django.contrib应用程序，如django.contrib.redirects，其它从网上下在的第三方Django应用程序一样，都会自行添加到管理工具。&lt;/p&gt;
&lt;h3&gt; 3.设置字段可选&lt;/h3&gt;
&lt;p&gt; 你或许会发现管理工具有个限制：编辑表单需要你填写每一个字段，然而在有些情况下，你想要某些字段是可选的。 举个例子，我们想要Author模块中的email字段成为可选，即允许不填。 在现实世界中，你可能没有为每个作者登记邮箱地址。&lt;/p&gt;
&lt;p&gt;为了指定email字段为可选，你只要编辑Book模块：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Author(models.Model):
    first_name &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    last_name &lt;/span&gt;= models.CharField(max_length=40&lt;span&gt;)
    email &lt;/span&gt;= models.EmailField(&lt;span&gt;null=True,blank=True&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些代码告诉Django，作者的邮箱地址允许输入一个空值&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt; 4.自定义字段标签    &lt;/h3&gt;
&lt;p&gt; 在编辑页面中，每个字段的标签都是从模块的字段名称生成的。规则很简单： 用空格替换下划线；首字母大写&lt;/p&gt;
&lt;p&gt;然而，字段名称并不总是贴切的。有些情况下，你可能想自定义一个标签。 你只需在模块中指定verbose_name。&lt;/p&gt;
&lt;p&gt; 举个例子，说明如何将Author.email的标签改为e-mail，中间有个横线。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Author(models.Model):
    first_name &lt;/span&gt;= models.CharField(max_length=30&lt;span&gt;)
    last_name &lt;/span&gt;= models.CharField(max_length=40&lt;span&gt;)
    email &lt;/span&gt;= models.EmailField(null=True,blank=True,&lt;span&gt;verbose_name='e-mail'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改之前&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306013200082-484950612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;改之后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306013457401-1623595633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.自定义ModelAdmi类&lt;/h3&gt;
&lt;p&gt; 迄今为止，我们做的blank=True、null=True和verbose_name修改其实是模块级别，而不是管理级别的。 也就是说，这些修改实质上是构成模块的一部分，并且正好被管理工具使用，而不是专门针对管理工具的。&lt;/p&gt;
&lt;p&gt;除了这些，Django还提供了大量选项让你针对特别的模块自定义管理工具。 这些选项都在ModelAdminclasses里面，这些类包含了管理工具中针对特别模块的配置。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;（1）自定义列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 默认情况下，Author下面只显示每个作者的姓名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306014701556-1383730662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在这基础上改进，添加其它字段，从而改变列表的显示。比如说：在这个列表中可以看到作者的邮箱地址，为了达到这个目的，我们将为Author模块定义一个ModelAdmin类。 这个类是自定义管理工具的关键，其中最基本的一件事情是允许你指定列表中的字段。&lt;/p&gt;
&lt;p&gt; 修改admin.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; book &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;last_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

admin.site.register(models.Author,&lt;span&gt;AuthorAdmin&lt;/span&gt;)
admin.site.register(models.Book)
admin.site.register(models.Publisher)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到如下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306015054839-1234769399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释一下代码：&lt;/p&gt;
&lt;p&gt;我们新建了一个类AuthorAdmin，它是从django.contrib.admin.ModelAdmin派生出来的子类，保存着一个类的自定义配置，以供管理工具使用。我们只自定义了一项：list_display，它是一个字段名称的元组，用于列表显示。当然，这些字段名称必须是模块中有的。&lt;/p&gt;
&lt;p&gt;我们修改了admin.site.register()调用，在Author后面添加了AuthorAdmin。你可以这样理解：用AuthorAdmin选项注册Author模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）添加快速查询栏&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;last_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    search_fields &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;last_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在页面顶端看到一个查询栏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306015744110-238828663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）添加过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，让我们为Book列表页添加一些过滤器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    list_filter &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)

admin.site.register(models.Author,AuthorAdmin)
admin.site.register(models.Book,&lt;span&gt;BookAdmin&lt;/span&gt;)
admin.site.register(models.Publisher)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到右边有filter,Django为日期型字段提供了快捷过滤方式，它包含：今天、过往七天、当月和今年&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306021552883-1024309387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外一种过滤日期的方式是使用date_hierarchy选项，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    list_filter &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    &lt;span&gt;date_hierarchy &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= 'publication_date'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改好后，页面中的列表顶端会有一个逐层深入的导航条，效果如下. 它从可用的年份开始，然后逐层细分到月乃至日。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306021843241-1874408576.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;请注意，date_hierarchy接受的是* 字符串* ，而不是元组。因为只能对一个日期型字段进行层次划分。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; （4）降序排列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们改变默认的排序方式，按publication date降序排列。&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    list_filter &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    date_hierarchy &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ordering = ('-publication_date',)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; （5）自定义编辑表单&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt; 正如自定义列表那样，编辑表单多方面也能自定义。
&lt;p&gt;首先，我们先自定义字段顺序。 默认地，表单中的字段顺序是与模块中定义是一致的。 我们可以通过使用ModelAdmin子类中的fields选项来改变它：&lt;/p&gt;
&lt;div class=&quot;textLayer&quot; readability=&quot;35.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    list_filter &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    date_hierarchy &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ordering &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
   &lt;span&gt; fields &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= ('title', 'authors', 'publisher', 'publication_date')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;textLayer&quot;&gt;
&lt;p&gt;改之前：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306023106235-1859135640.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;改之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306023517971-959362638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过fields这个选项，你可以排除一些不想被其他人编辑的fields 只要不选上不想被编辑的field(s)即可。&lt;/p&gt;
&lt;p&gt;例如，在book数据库中，我们可以隐藏publication_date，以防止它被编辑。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
fields = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306023725690-664705790.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;另一个常用的编辑页面自定义是针对多对多字段的。 真如我们在book编辑页面看到的那样，`` 多对多字段`` 被展现成多选框。虽然多选框在逻辑上是最适合的HTML控件，但它却不那么好用。 如果你想选择多项，你必须还要按下Ctrl键。 虽然管理工具因此添加了注释（help_text），但是当它有几百个选项时，它依然显得笨拙。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;更好的办法是使用&lt;/p&gt;
&lt;p&gt;filter_horizontal。让我们把它添加到BookAdmin中，然后看看它的效果。&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    list_filter &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    date_hierarchy &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ordering &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    &lt;span&gt;filter_horizontal &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= ('authors',)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;请注意移除fields选项，以使得编辑页面包含所有字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加之前&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306024027083-672660100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加之后，明显方便多了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306024422001-412564185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对那些拥有十个以上选项的`` 多对多字段`` 使用filter_horizontal。 这比多选框好用多了。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt; 
&lt;p&gt;ModelAdmin类还支持filter_vertical选项。 它像filter_horizontal那样工作，除了控件都是垂直排列，而不是水平排列的。 至于使用哪个，只是个人喜好问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;45&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 filter_vertical = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306024728051-421364379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;filter_horizontal和filter_vertical选项只能用在多对多字段上, 而不能用于ForeignKey字段。 默认地，管理工具使用`` 下拉框`` 来展现`` 外键`` 字段。但是，正如`` 多对多字段`` 那样，有时候你不想忍受因装载并显示这些选项而产生的大量开销。 例如，我们的book数据库膨胀到拥有数千条publishers的记录，以致于book的添加页面装载时间较久，因为它必须把每一个publisher都装载并显示在`` 下拉框`` 中。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法是使用`` raw_id_fields`` 选项。它是一个包含外键字段名称的元组，它包含的字段将被展现成`` 文本框`` ，而不再是`` 下拉框`` 。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookAdmin(admin.ModelAdmin):
    list_display &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    list_filter &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    date_hierarchy &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ordering &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-publication_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    filter_vertical &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
    &lt;span&gt;raw_id_fields &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= ('publisher',)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306025404991-997112179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201803/1299879-20180306025422673-1044421655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个输入框中，你输入什么呢？ publisher的数据库ID号。 考虑到人们通常不会记住这些数据库ID，管理工具提供了一个放大镜图标方便你输入。点击那个图标将会弹出一个窗口，在那里你可以选择想要添加的publisher。&lt;/p&gt;
&lt;h2&gt; 第七章 用户、用户组和权限&lt;/h2&gt;
&lt;p&gt;因为你是用超级用户登录的，你可以创建，编辑和删除任何对像。 然而，不同的环境要求有不同的权限，系统不允许所有人都是超级用户。 管理工具有一个用户权限系统，通过它你可以根据用户的需要来指定他们的权限，从而达到部分访问系统的目的。&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;你通过管理界面编辑用户及其许可就像你编辑别的对象一样。 浏览用户和用户组区域的时候已经见过这些了。 如你所想，用户对象有标准的用户名、密码、邮箱地址和真实姓名，同时它还有关于使用管理界面的权限定义。&lt;/p&gt;
&lt;p&gt;首先，这有一组三个布尔型标记：&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;　　&lt;span&gt;活动标志：&lt;/span&gt;它用来控制用户是否已经激活。 如果一个用户帐号的这个标记是关闭状态，而用户又尝试用它
&lt;p&gt;　　　　　　　登录时，即使密码正确，他也无法登录系统。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;成员标志：&lt;/span&gt;它用来控制这个用户是否可以登录管理界面（即：这个用户是不是你们组织里的成员） 由于用&lt;/p&gt;
&lt;p&gt;　　　　　　    户系统可以被用于控制公众页面（即：非管理页面）的访问权限（详见第十四章），这个标志可用来区分&lt;/p&gt;
&lt;p&gt;　　　　　　　公众用户和管理用户。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;超级用户标志：&lt;/span&gt;它赋予用户在管理界面中添加、修改和删除任何项目的权限。 如果一个用户帐号有这个标&lt;/p&gt;
&lt;p&gt;　　　　　　　　　志，那么所有权限设置（即使没有）都会被忽略。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;普通的活跃，非超级用户的管理用户可以根据一套设定好的许可进入。 管理界面中每种可编辑的对象（如：books、authors、publishers）都有三种权限：创建许可，编辑许可和删除许可。 给一个用户授权许可也就表明该用户可以进行许可描述的操作。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;当你创建一个用户时，它没有任何权限，该有什么权限是由你决定的。 例如，你可以给一个用户添加和修改publishers的权限，而不给他删除的权限。 请注意，这些权限是定义在模块级别上，而不是对象级别上的。据个例子，你可以让小强修改任何图书，但是不能让他仅修改由机械工业出版社出版的图书。 后面这种基于对象级别的权限设置比较复杂，并且超出了本书的覆盖范围。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;span&gt;注释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;权限管理系统也控制编辑用户和权限。 如果你给某人编辑用户的权限，他可以编辑自己的权限，这种能力可能不是你希望的。 赋予一个用户修改用户的权限，本质上说就是把他变成一个超级用户。你也可以给组中分配用户。 一个组简化了给组中所有成员应用一套许可的动作。 组在给大量用户特定权限的时候很有用。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 06 Mar 2018 15:36:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8508914.html</dc:identifier>
</item>
<item>
<title>常用校验码（奇偶校验，海明校验，CRC）学习总结 - WhiteBlackCat</title>
<link>http://www.cnblogs.com/FZfangzheng/p/8519791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FZfangzheng/p/8519791.html</guid>
<description>&lt;h2 id=&quot;常用校验码奇偶校验海明校验crc学习总结&quot;&gt;常用校验码（奇偶校验，海明校验，CRC）学习总结&lt;/h2&gt;
&lt;h3 id=&quot;一.为什么要有校验码&quot;&gt;一.为什么要有校验码？&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为在数据存取和传送的过程中，由于元器件或者噪音的干扰等原因会出现错误，这个时候我们就需要采取相应的措施，发现并纠正错误，对于错误的检测和校正，大多采取“冗余校验”的思想，即除原数据外，额外增加若干位编码，这些新增的代码称为校验位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二.数据是如何校验的&quot;&gt;二.数据是如何校验的？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043829/201803/1043829-20180306231344493-733142842.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入的数据m经过f得到p校验位。&lt;/li&gt;
&lt;li&gt;数据m和校验位一起通过存储器或传输线路，分别得到m'和p'，这两者可能和m,f相同，也可能由于传输储存发生问题而不同。&lt;/li&gt;
&lt;li&gt;由数据m'再次经过f得到校验位p''，比较p''和p'，从而得出是否出错，输出对应的信息，如何比较，会在下面的对应校验码中给出。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三.码距&quot;&gt;三.码距&lt;/h3&gt;
&lt;p&gt;若干位代码组成的一个字称为码字，而两个码字具有&lt;strong&gt;不同代码的位数&lt;/strong&gt;为这两个码字的距离，而码制里各种码字间&lt;strong&gt;最小&lt;/strong&gt;的距离称为码距。&lt;/p&gt;
&lt;h5 id=&quot;比如8421码1001和0000有两位不同所以距离是2而0010和0011的距离为1是最小的距离故8421码码距为1&quot;&gt;比如8421码，1001和0000，有两位不同，所以距离是2，而0010和0011的距离为1，是最小的距离，故8421码码距为1&lt;/h5&gt;
&lt;p&gt;那么，码距有什么用呢？答案是码距和这种类型的码的检错，纠错能力有关。&lt;/p&gt;
&lt;h5 id=&quot;如8421码由于码距是1无检错纠错能力比如数据0000如果其中一位变化变成0001那么这个数据仍然是合法的&quot;&gt;如8421码，由于码距是1，无检错，纠错能力，比如数据0000，如果其中一位变化，变成0001，那么，这个数据仍然是合法的。&lt;/h5&gt;
&lt;h5 id=&quot;再如奇偶校验码中奇校验码如100000000和010000000码距为2我们可以发现如果数据中有一位变化了如100000000变为110000000我们可以很容易地判断出数据出错了因为110000000不符合奇校验的编码校验位和数据位一起所含1的个数为奇数&quot;&gt;再如奇偶校验码中奇校验码，如100000000和010000000，码距为2，我们可以发现，如果数据中有一位变化了，如100000000变为110000000，我们可以很容易地判断出数据出错了，因为110000000不符合奇校验的编码（校验位和数据位一起所含1的个数为奇数）&lt;/h5&gt;
&lt;p&gt;我们可以发现，校验码可以帮助扩大码距，从而找出错误。&lt;/p&gt;
&lt;p&gt;码距与检错、纠错能力的关系（当d≤4）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若码距d为奇数，则能发现d-1位错，或能纠正(d-1)/2位错。&lt;/li&gt;
&lt;li&gt;若码距d为偶数，则能发现d/2位错，并能纠正(d/2-1)位错。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;四.奇偶校验码&quot;&gt;四.奇偶校验码&lt;/h3&gt;
&lt;h4 id=&quot;编码方式&quot;&gt;1.编码方式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;无论数据位多少位，校验位只有一位&lt;/li&gt;
&lt;li&gt;数据位和校验位一共所含的1个数为奇数，称为奇校验&lt;/li&gt;
&lt;li&gt;数据位和校验位一共所含的1个数为偶数，称为偶校验&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如（加粗为校验位）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;00000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;00000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;00000000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;01010100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;01010100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;01010100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;01111111&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;01111111&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;01111111&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于数据传输过程一般是出现一位错误，而奇偶校验码能发现奇数个错误，所以奇偶校验的实用价值还是很高的。&lt;/p&gt;
&lt;h4 id=&quot;实现原理&quot;&gt;2.实现原理&lt;/h4&gt;
&lt;p&gt;那么，奇偶校验是怎么来发现错误的呢？根据&lt;strong&gt;二.数据是如何校验的&lt;/strong&gt;我们可以知道，在数据传输之前，我们会求一次校验位，传输后，会求一次校验位，那么，在奇偶校验中，我们通过比较这两个校验位是否相同，一般是采用异或的方式，若结果为1，则说明有奇数个错误，结果为0，则说明正确或者偶数个错误。&lt;/p&gt;
&lt;h3 id=&quot;五.海明校验码&quot;&gt;五.海明校验码&lt;/h3&gt;
&lt;h4 id=&quot;引入&quot;&gt;1.引入&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在了解了奇偶校验码之后，我们可以稍稍做下思考，既然奇偶校验码具有一定的局限性，也就是只能检测奇数的错误，并且不能改正错误，这也就意味着数据一旦传输错误，我们必须要重新上传，那么，我们有办法确定错误发生的位置么？只要确定了错误发生的位置，改正其实就是取反。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;这个时候，让我们来看看奇偶校验码，它是在数据的前面或者后面加上以为校验位，那么，如果我们将数据分段，分成某些小段，这样是不是能判断错误发生的位置呢？&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;海明校验码-最简单求法&quot;&gt;2.海明校验码 最简单求法&lt;/h4&gt;
&lt;h6 id=&quot;我们以8位数据位45位校验位为例&quot;&gt;我们以8位数据位，4（5）位校验位为例&lt;/h6&gt;
&lt;p&gt;我们将海明校验码表示为(&lt;strong&gt;H13&lt;/strong&gt;) H12 H11 H10 H9 &lt;strong&gt;H8&lt;/strong&gt; H7 H6 H5 &lt;strong&gt;H4&lt;/strong&gt; H3 &lt;strong&gt;H2&lt;/strong&gt; &lt;strong&gt;H1&lt;/strong&gt;&lt;br/&gt;其中加粗的部分为校验位，校验位所在位置为2^（i-1），i=1,2,3...&lt;br/&gt;我们还可以把它写成（&lt;strong&gt;P5&lt;/strong&gt;） D8 D7 D6 D5 &lt;strong&gt;P4&lt;/strong&gt; D4 D3 D2 &lt;strong&gt;P3&lt;/strong&gt; D1 &lt;strong&gt;P2&lt;/strong&gt; &lt;strong&gt;P1&lt;/strong&gt;&lt;br/&gt;其中P代表的是校验位，D代表数据位&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;2^0&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D7&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D5&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D4&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D2&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D1&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;P1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;S1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2^1&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D6&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D3&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;P2&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;S2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;2^2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D8&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;D4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;P3&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;S3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2^3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;D5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;P4&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;S4&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043829/201803/1043829-20180306231412927-1501972435.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看看这个表是怎么画出来的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先数据位和校验位的位置我们通过公式可以得出&lt;/li&gt;
&lt;li&gt;同列数据位所占的位置对应的行的值之和为列的值。举个例子，如D1,所在列为3，所在行分别为2^0和2^1，即1和2,满足式子1+2=3。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;校验位的值为同行数据位相异或得到，至于P5，则是由所有数据位和校验位一起异或得到。&lt;/p&gt;
&lt;h4 id=&quot;海明校验码判断修复错误&quot;&gt;3.海明校验码判断修复错误&lt;/h4&gt;
&lt;p&gt;下面引入一个错误字S的概念&lt;br/&gt;其实错误字S也就是传输前后分别求的校验位的异或值，奇偶校验码只要看一个错误字，而海明校验码则要考虑多个错误字。&lt;br/&gt;S4 ~ S1为全0,说明没错. S4 ~ S1不为全0,说明有错. S5=1说明1位出错,而S5=0说明2位错，不再有效，且不能查出是哪2位出错。&lt;br/&gt;S4~S1的编码值对应的则是出错的海明码位号（&lt;strong&gt;不太清楚图表可以返回上面的表格对照&lt;/strong&gt;）：&lt;br/&gt;如1100，对应D8出错&lt;br/&gt;如1011，对应D7出错&lt;br/&gt;如1010，对应D6出错&lt;br/&gt;如1001，对应D5出错......&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tip：我们通过观察8个数据位4个校验位的海明校验码，发现，若一位出错，则至少有两组校验码的生成收到影响，故我们得到其码距为3，根据码距与检错、纠错能力的关系可以得出该校验码能发现两位错，或修改一位错。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;校验码位数的确定&quot;&gt;4.校验码位数的确定&lt;/h4&gt;
&lt;p&gt;前面看完后，一定有人会有疑问，为什么八位数据位我要四位或者五位校验位，三位不行么？六位不行么？那么，请继续看看下面&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;假定数据位数为n，校验码为k位，则故障字位数也为k位。k位故障字所能表示的状态最多是2K，每种状态可用来说明一种出错情况。&lt;/p&gt;
&lt;p&gt;若只有一位错，则结果可能是：&lt;br/&gt;数据中某一位错 (n种可能)&lt;br/&gt;校验码中有一位错 (k种可能)&lt;br/&gt;无错 ( 1 种可能)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假定最多有一位错，则n和k必须满足下列关系：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2^k≥1+n+k， 即：2^k-1≥n+k&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以当数据有8位时，校验码和故障字都应有至少4位。&lt;/p&gt;
&lt;h3 id=&quot;六.循环冗余码crc码&quot;&gt;六.循环冗余码（CRC码）&lt;/h3&gt;
&lt;h4 id=&quot;为什么大批量数据不用奇偶校验&quot;&gt;1.为什么大批量数据不用奇偶校验？&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在每个字符后增加一位校验位会增加大量的额外开销；尤其在网络通信中，对传输的二进制比特流没有必要再分解成一个个字符，因而无法采用奇偶校验码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;模2运算&quot;&gt;2.模2运算&lt;/h4&gt;
&lt;p&gt;在介绍CRC码之前，有必要介绍下计算CRC码必要的模2运算：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;模2运算不考虑加法进位和减法借位，上商的原则是当部分余数首位是１时商取１，反之商取0。然后按模2相减原则求得最高位后面几位的余数。这样当被除数逐步除完时，最后的余数位数比除数少一位。这样得到的余数就是校验位。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043829/201803/1043829-20180306231458268-1144251998.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基本思想&quot;&gt;3.基本思想&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;数据信息M(x)为一个n位的二进制数据，将M(x)左移k位后，用一个约定的“生成多项式”G(x)相除，G(x)是一个k+1位的二进制数，相除后得到的k位余数就是校验位。校验位拼接到M(x)后，形成一个n+k位的代码，称该代码为循环冗余校验 ( CRC ) 码，也称（n+k,n）码。&lt;/li&gt;
&lt;li&gt;一个CRC码一定能被生成多项式整除，当数据和校验位一起送到接受端后，只要将接受到的数据和校验位用同样的生成多项式相除，如果正好除尽，表明没有发生错误；若除不尽，则表明某些数据位发生了错误。通常要求重传一次。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043829/201803/1043829-20180306231524274-1915027911.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;crc码求法&quot;&gt;4.CRC码求法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043829/201803/1043829-20180306231540369-539089777.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043829/201803/1043829-20180306231552784-969347973.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;crc码检错&quot;&gt;5.CRC码检错&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;将收到的CRC码用约定的生成多项式G(x)去除,如果码字无误则余数应位0,如果有某一位出错,则余数不为0,不同位数出错余数不同.&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043829/201803/1043829-20180306231607038-1285099627.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 06 Mar 2018 15:17:00 +0000</pubDate>
<dc:creator>WhiteBlackCat</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FZfangzheng/p/8519791.html</dc:identifier>
</item>
<item>
<title>使用java实现阿里云消息队列简单封装 - 狂盗一枝梅</title>
<link>http://www.cnblogs.com/kuangdaoyizhimei/p/8508357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kuangdaoyizhimei/p/8508357.html</guid>
<description>&lt;p&gt;最近公司有使用阿里云消息队列的需求，为了更加方便使用，本人用了几天时间将消息队列封装成api调用方式以方便内部系统的调用，现在已经完成，特此记录其中过程和使用到的相关技术，与君共勉。&lt;/p&gt;
&lt;p&gt;现在阿里云提供了两种消息服务：mns服务和ons服务，其中我认为mns是简化版的ons，而且mns的消息消费需要自定义轮询策略的，相比之下，ons的发布与订阅模式功能更加强大（比如相对于mns，ons提供了消息追踪、日志、监控等功能），其api使用起来更加方便，而且听闻阿里内部以后不再对mns进行新的开发，只做维护，ons服务则会逐步替代mns服务成为阿里消息服务的主打产品，所以，如果有使用消息队列的需求，建议不要再使用mns，使用ons是最好的选择。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://m.aliyun.com/doc/product/29530.html&quot; target=&quot;_blank&quot;&gt;https://m.aliyun.com/doc/product/29530.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;涉及到的技术：Spring，反射、动态代理、Jackson序列化和反序列化&lt;/p&gt;
&lt;p&gt;在看下面的文章之前，需要先看上面的文档以了解相关概念（Topic、Consumer、Producer、Tag等）以及文档中提供的简单的发送和接收代码实现。&lt;/p&gt;
&lt;p&gt;该博文只针对有消息队列知识基础的朋友看，能帮上大家的忙我自然很高兴，看不懂的也不要骂，说明你路子不对。&lt;/p&gt;


&lt;h2&gt;1.消息发送&lt;/h2&gt;
&lt;p&gt;在一个简单的cs架构中，假设server会监听一个Topic的Producer发送的消息，那么它首先应该提供client一个api，client只需要简单的调用该api，就可以通过producer来生产消息&lt;/p&gt;
&lt;h2&gt;2.消息接收&lt;/h2&gt;
&lt;p&gt;由于api是server制定的，所以server当然也知道如何消费这些消息&lt;/p&gt;
&lt;p&gt;在这个过程中，server实际充当着消费者的角色，client实际充当着生产者的角色，但是生产者生产消息的规则则由消费者制定以满足消费者消费需求。&lt;/p&gt;
&lt;h2&gt;3.最终目标&lt;/h2&gt;
&lt;p&gt;我们要创建一个单独的jar包，起名为queue-core为生产者和消费者提供依赖和发布订阅的具体实现。&lt;/p&gt;


&lt;h2&gt;1.消费者提供接口&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@Topic(name=&quot;kdyzm&quot;,producerId=&quot;kdyzm_producer&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserQueueResource {
    
    @Tag(&lt;/span&gt;&quot;test1&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleUserInfo(@Body @Key(&quot;userInfoHandler&quot;&lt;span&gt;) UserModel user);
    
    @Tag(&lt;/span&gt;&quot;test2&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleUserInfo1(@Body @Key(&quot;userInfoHandler1&quot;&lt;span&gt;) UserModel user);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Topic和producer之间是N:1的关系，所以这里直接将producerId作为Topic的一个属性；Tag是一个很关键的过滤条件，消费者通过它进行消息的分类做不同的业务处理，所以，这里使用Tag作为路由条件。&lt;/p&gt;
&lt;h2&gt;2.生产者使用消费者提供的api发送消息&lt;/h2&gt;
&lt;p&gt; 由于消费者只提供了接口给生产者使用，接口是没有办法直接使用的，因为没有办法实例化，这里使用动态代理生成对象，在消费者提供的api中，添加如下config，以方便生产者直接导入config即可使用，这里使用了基于java的spring config，请知悉。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueueConfig {

    @Autowired
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserQueueResource userQueueResource() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; QueueResourceFactory.createProxyQueueResource(UserQueueResource.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.queue-core对生产者发送消息的封装&lt;/h2&gt;
&lt;p&gt;以上1中所有的注解（Topic、Tag、Body 、Key）以及2中使用到的QueueResourceFactory类都要在queue-core中定义，其中注解的定义只是定义了规则，真正的实现实际上是在QueueResourceFactory中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aliyun.openservices.ons.api.Message;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aliyun.openservices.ons.api.Producer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aliyun.openservices.ons.api.SendResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.wy.queue.core.api.MQConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.wy.queue.core.utils.JacksonSerializer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.wy.queue.core.utils.MQUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.wy.queue.core.utils.QueueCoreSpringUtils;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QueueResourceFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger=LoggerFactory.getLogger(QueueResourceFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String topicName;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String producerId;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; JacksonSerializer serializer=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JacksonSerializer();
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PREFIX=&quot;PID_&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; QueueResourceFactory(String topicName,String producerId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.topicName =&lt;span&gt; topicName;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.producerId=&lt;span&gt;producerId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T createProxyQueueResource(Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        String topicName &lt;/span&gt;=&lt;span&gt; MQUtils.getTopicName(clazz);
        String producerId &lt;/span&gt;=&lt;span&gt; MQUtils.getProducerId(clazz);
        T target &lt;/span&gt;= (T) Proxy.newProxyInstance(QueueResourceFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader(),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] { clazz }, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueueResourceFactory(topicName,producerId));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(args.length == 0 || args.length&amp;gt;1&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;only accept one param at queueResource interface.&quot;&lt;span&gt;);
        }
        String tagName&lt;/span&gt;=&lt;span&gt;MQUtils.getTagName(method);
        ProducerFactory producerFactory &lt;/span&gt;= QueueCoreSpringUtils.getBean(ProducerFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        MQConnection connectionInfo &lt;/span&gt;= QueueCoreSpringUtils.getBean(MQConnection.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        
        Producer producer &lt;/span&gt;= producerFactory.createProducer(PREFIX+connectionInfo.getPrefix()+&quot;_&quot;+&lt;span&gt;producerId);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息&lt;/span&gt;
        Message msg = &lt;span&gt;new&lt;/span&gt; Message( &lt;span&gt;//&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在控制台创建的 Topic，即该消息所属的 Topic 名称&lt;/span&gt;
                connectionInfo.getPrefix()+&quot;_&quot;+&lt;span&gt;topicName,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Message Tag,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可理解为 Gmail 中的标签，对消息进行再归类，方便 Consumer 指定过滤条件在 MQ 服务器过滤&lt;/span&gt;
&lt;span&gt;                tagName,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Message Body
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任何二进制形式的数据， MQ 不做任何干预，
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要 Producer 与 Consumer 协商好一致的序列化和反序列化方式&lt;/span&gt;
                serializer.serialize(args[0&lt;span&gt;]).getBytes());
        SendResult sendResult &lt;/span&gt;=&lt;span&gt; producer.send(msg);
        logger.info(&lt;/span&gt;&quot;Send Message success. Message ID is: &quot; +&lt;span&gt; sendResult.getMessageId());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里特意将自定义包和第三方使用的包名都贴过来了，以便于区分。&lt;/p&gt;
&lt;p&gt;这里到底做了哪些事情呢？&lt;/p&gt;
&lt;p&gt;发送消息的过程就是动态代理创建一个代理对象，该对象调用方法的时候会被拦截，首先解析所有的注解，比如topicName、producerId、tag等关键信息从注解中取出来，然后调用阿里sdk发送消息，过程很简单，但是注意，这里发送消息的时候是分环境的，一般来讲现在企业中会区分QA、staging、product三种环境，其中QA和staging是测试环境，对于消息队列来讲，也是会有三种环境的，但是QA和staging环境往往为了降低成本使用同一个阿里账号，所以创建的topic和productId会放到同一个区域下，这样同名的TopicName是不允许存在的，所以加上了环境前缀加以区分，比如QA_TopicName,PID_Staging_ProducerId等等；另外，queue-core提供了MQConnection接口，以获取配置信息，生产者服务只需要实现该接口即可。&lt;/p&gt;

&lt;h2&gt;4.生产者发送消息&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserQueueResource userQueueResource;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMessage() {
        UserModel userModel&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserModel();
        userModel.setName(&lt;/span&gt;&quot;kdyzm&quot;&lt;span&gt;);
        userModel.setAge(&lt;/span&gt;25&lt;span&gt;);
        userQueueResource.handleUserInfo(userModel);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要数行代码即可将消息发送到指定的Topic，相对于原生的发送代码，精简了太多。&lt;/p&gt;

&lt;p&gt; 相对于消息发送，消息的消费要复杂一些。&lt;/p&gt;
&lt;h2&gt;1.消息消费设计&lt;/h2&gt;
&lt;p&gt;由于Topic和Consumer之间是N:N的关系，所以将ConsumerId放到消费者具体实现的方法上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
@QueueResource
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserQueueResourceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserQueueResource {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass());

    @Override
    @ConsumerAnnotation(&lt;/span&gt;&quot;kdyzm_consumer&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleUserInfo(UserModel user) {
        logger.info(&lt;/span&gt;&quot;收到消息1：{}&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Gson().toJson(user));
    }

    @Override
    @ConsumerAnnotation(&lt;/span&gt;&quot;kdyzm_consumer1&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleUserInfo1(UserModel user) {
        logger.info(&lt;/span&gt;&quot;收到消息2：{}&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Gson().toJson(user));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里又有两个新的注解@QueueResource和@ConsumerAnnotation，这两个注解后续会讨论如何使用。有人会问我为什么要使用ConsumerAnnotation这个名字而不使用Consumer这个名字，因为Consumer这个名字和aliyun提供的sdk中的名字冲突了。。。。&lt;/p&gt;
&lt;p&gt;在这里， 消费者提供api 接口给生产者以方便生产者发送消息，消费者则实现该接口以消费生产者发送的消息，如何实现api接口就实现了监听，这点是比较关键的逻辑。&lt;/p&gt;
&lt;h2&gt;2.queue-core实现消息队列监听核心逻辑&lt;/h2&gt;
&lt;p&gt;第一步：使用sping 容器的监听方法获取所有加上QueueResource注解的Bean&lt;/p&gt;
&lt;p&gt;第二步：分发处理Bean&lt;/p&gt;
&lt;p&gt;如何处理这些Bean呢，每个Bean实际上都是一个对象，有了对象，比如上面例子中的UserQueueResourceImpl 对象，我们可以拿到该对象实现的接口字节码对象，进而可以拿到该接口UserQueueRerousce上的注解以及方法上和方法中的注解，当然UserQueueResourceImpl实现方法上的注解也能拿得到，这里我将获取到的信息以consumerId为key，其余相关信息封装为Value缓存到了一个Map对象中，核心代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
Class&amp;lt;?&amp;gt; clazz =&lt;span&gt; resourceImpl.getClass();
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazzIf = clazz.getInterfaces()[0&lt;span&gt;];
        Method[] methods &lt;/span&gt;=&lt;span&gt; clazz.getMethods();
        String topicName &lt;/span&gt;=&lt;span&gt; MQUtils.getTopicName(clazzIf);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method m : methods) {
            ConsumerAnnotation consumerAnno &lt;/span&gt;= m.getAnnotation(ConsumerAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; consumerAnno) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.error(&quot;method={} need Consumer annotation.&quot;, m.getName());&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            String consuerId &lt;/span&gt;=&lt;span&gt; consumerAnno.value();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(consuerId)) {
                logger.error(&lt;/span&gt;&quot;method={} ConsumerId can't be null&quot;&lt;span&gt;, m.getName());
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            Class&lt;/span&gt;&amp;lt;?&amp;gt;[] parameterTypes =&lt;span&gt; m.getParameterTypes();
            Method resourceIfMethod &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                resourceIfMethod &lt;/span&gt;=&lt;span&gt; clazzIf.getMethod(m.getName(), parameterTypes);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (NoSuchMethodException |&lt;span&gt; SecurityException e) {
                logger.error(&lt;/span&gt;&quot;can't find method={} at super interface={} .&quot;&lt;span&gt;, m.getName(), clazzIf.getCanonicalName(),
                        e);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            String tagName &lt;/span&gt;=&lt;span&gt; MQUtils.getTagName(resourceIfMethod);
            consumersMap.put(consuerId, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodInfo(topicName, tagName, m));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三步：通过反射实现消费的动作&lt;/p&gt;
&lt;p&gt;首先，先确定好反射动作执行的时机，那就是监听到了新的消息&lt;/p&gt;
&lt;p&gt;其次，如何执行反射动作？不赘述，有反射相关基础的童鞋都知道怎么做，核心代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
MQConnection connectionInfo = QueueCoreSpringUtils.getBean(MQConnection.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        String topicPrefix&lt;/span&gt;=connectionInfo.getPrefix()+&quot;_&quot;&lt;span&gt;;
        String consumerIdPrefix&lt;/span&gt;=PREFIX+connectionInfo.getPrefix()+&quot;_&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String consumerId:consumersMap.keySet()){
            MethodInfo methodInfo&lt;/span&gt;=&lt;span&gt;consumersMap.get(consumerId);
            Properties connectionProperties&lt;/span&gt;=&lt;span&gt;convertToProperties(connectionInfo);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 您在控制台创建的 Consumer ID&lt;/span&gt;
            connectionProperties.put(PropertyKeyConst.ConsumerId, consumerIdPrefix+&lt;span&gt;consumerId);
            Consumer consumer &lt;/span&gt;=&lt;span&gt; ONSFactory.createConsumer(connectionProperties);
            consumer.subscribe(topicPrefix&lt;/span&gt;+methodInfo.getTopicName(), methodInfo.getTagName(), &lt;span&gt;new&lt;/span&gt; MessageListener() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅多个Tag&lt;/span&gt;
                &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Action consume(Message message, ConsumeContext context) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        String messageBody&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(message.getBody(),&quot;UTF-8&quot;&lt;span&gt;);
                        logger.info(&lt;/span&gt;&quot;receive message from topic={},tag={},consumerId={},message={}&quot;,topicPrefix+methodInfo.getTopicName(),methodInfo.getTagName(),consumerIdPrefix+&lt;span&gt;consumerId,messageBody);
                        Method method&lt;/span&gt;=&lt;span&gt;methodInfo.getMethod();
                        Class&lt;/span&gt;&amp;lt;?&amp;gt; parameType = method.getParameterTypes()[0&lt;span&gt;];
                        Object arg &lt;/span&gt;=&lt;span&gt; jacksonSerializer.deserialize(messageBody, parameType);
                        Object[] args&lt;/span&gt;=&lt;span&gt;{arg};
                        method.invoke(resourceImpl, args);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                        logger.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,e);
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Action.CommitMessage;
                }
            });
            consumer.start();
            logger.info(&lt;/span&gt;&quot;consumer={} has started.&quot;,consumerIdPrefix+&lt;span&gt;consumerId);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kdyzm/queue-core.git&quot; target=&quot;_blank&quot;&gt; https://github.com/kdyzm/queue-core.git&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Mar 2018 15:16:00 +0000</pubDate>
<dc:creator>狂盗一枝梅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kuangdaoyizhimei/p/8508357.html</dc:identifier>
</item>
<item>
<title>创建基于MailKit和MimeKit的.NET基础邮件服务 - 彭泽0902</title>
<link>http://www.cnblogs.com/pengze0902/p/8519715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengze0902/p/8519715.html</guid>
<description>&lt;p&gt;       邮件服务是一般的系统都会拥有和需要的功能，但是对于.NET项目来说，邮件服务的创建和使用会较为的麻烦。.NET对于邮件功能提供了System.Net.Mail用于创建邮件服务，该基础服务提供邮件的基础操作，并且使用也较为的简单。对于真正将该功能使用于项目的人，就会慢慢发现其中的优缺点，甚至有些时候不能忍受其中的问题。在这里介绍一种微软用于替代System.Net.Mail的邮件服务组件MailKit和MimeKit，官网地址：http://www.mimekit.net/。GitHub地址：https://github.com/jstedfast/MimeKit。下面就具体的介绍一下。&lt;/p&gt;
&lt;h3&gt;　　一.MailKit和MimeKit基础概述：&lt;/h3&gt;
&lt;p&gt;       MailKit组件的支持的客户端类型比较多，例如SMTP客户端、POP3客户端、IMAP4客户端。该组件是一个跨平台的Email组件，该组件支持.NET 4.0，.NET 4.5，Xamarin.Android，Xamarin.iOS，Windows Phone 8.1等等平台。&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/831875/201803/831875-20180306225702274-1077650335.png&quot; alt=&quot;&quot; width=&quot;901&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      MimeKit提供了一个MIME解析器，组件具备的解析特性灵活、性能高、很好的处理各种各样的破碎的MIME格式化。&lt;span class=&quot;goog-text-highlight&quot;&gt;MimeKit的性能实际上&lt;span class=&quot;goog-text-highlight&quot;&gt;与GMime相当。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      该组件在安全性的还是比较高的，处理安全的方式较多，SASL认证、支持S / MIME v3.2、支持OpenPGP、支持DKIM签名等等方式。Mailkit组件可以通过&lt;span class=&quot;goog-text-highlight&quot;&gt;CancellationToken取消对应的操作，CancellationToken传播应取消操作的通知，一个&lt;span class=&quot;selflink&quot;&gt;的CancellationToken使线程，线程池工作项目之间，或取消合作任务的对象。过实例化CancellationTokenSource对象来创建取消令牌，该对象管理从其CancellationTokenSource.Token属性检索的取消令牌。然后，将取消令牌传递到应该收到取消通知的任意数量的线程，任务或操作。令牌不能用于启动取消。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;goog-text-highlight&quot;&gt;     MailKit组件支持异步操作，在内部编写的有关I/O异步操作的类。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　二.创建基础邮件服务：&lt;/h3&gt;
&lt;p&gt;           介绍过MailKit和MimeKit组建的基础信息，接下来就介绍一下如何使用两个组件的基本功能，在这里我将基本操作做了一个简单的封装，一般的项目可以直接引用封装好的类，大家可以根据实际的情况对该组件进行扩展。&lt;/p&gt;
&lt;h4&gt;          1.邮件发送基础服务API&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件服务API
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailServiceApi
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发送邮件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mailBodyEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;邮件基础信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sendServerConfiguration&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;发件人基础信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SendResultEntity SendMail(MailBodyEntity mailBodyEntity,
            SendServerConfigurationEntity sendServerConfiguration)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sendServerConfiguration == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sendServerConfiguration == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sendResultEntity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendResultEntity();

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt; SmtpClient(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProtocolLogger(CreateMailLog())))
            {
                client.ServerCertificateValidationCallback &lt;/span&gt;= (s, c, h, e) =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                Connection(mailBodyEntity, sendServerConfiguration, client, sendResultEntity);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sendResultEntity.ResultStatus == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sendResultEntity;
                }

                SmtpClientBaseMessage(client);

                Authenticate(mailBodyEntity, sendServerConfiguration, client, sendResultEntity);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sendResultEntity.ResultStatus == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sendResultEntity;
                }

                Send(mailBodyEntity, sendServerConfiguration, client, sendResultEntity);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sendResultEntity.ResultStatus == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sendResultEntity;
                }

                client.Disconnect(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sendResultEntity;
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 连接服务器
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mailBodyEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;邮件内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sendServerConfiguration&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;发送配置&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;client&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;客户端对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sendResultEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;发送结果&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Connection(MailBodyEntity mailBodyEntity, SendServerConfigurationEntity sendServerConfiguration,
            SmtpClient client, SendResultEntity sendResultEntity)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                client.Connect(sendServerConfiguration.SmtpHost, sendServerConfiguration.SmtpPort);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SmtpCommandException ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;尝试连接时出错:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SmtpProtocolException ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;尝试连接时的协议错误:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务器连接错误:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 账户认证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mailBodyEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;邮件内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sendServerConfiguration&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;发送配置&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;client&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;客户端对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sendResultEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;发送结果&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Authenticate(MailBodyEntity mailBodyEntity, SendServerConfigurationEntity sendServerConfiguration,
            SmtpClient client, SendResultEntity sendResultEntity)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                client.Authenticate(sendServerConfiguration.SenderAccount, sendServerConfiguration.SenderPassword);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无效的用户名或密码:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SmtpCommandException ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;尝试验证错误:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SmtpProtocolException ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;尝试验证时的协议错误:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;账户认证错误:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发送邮件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mailBodyEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;邮件内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sendServerConfiguration&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;发送配置&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;client&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;客户端对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sendResultEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;发送结果&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Send(MailBodyEntity mailBodyEntity, SendServerConfigurationEntity sendServerConfiguration,
            SmtpClient client, SendResultEntity sendResultEntity)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                client.Send(MailMessage.AssemblyMailMessage(mailBodyEntity));
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SmtpCommandException ex)
            {
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ex.ErrorCode)
                {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SmtpErrorCode.RecipientNotAccepted:
                        sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收件人未被接受:{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SmtpErrorCode.SenderNotAccepted:
                        sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发件人未被接受:{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SmtpErrorCode.MessageNotAccepted:
                        sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息未被接受:{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SmtpProtocolException ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送消息时的协议错误:{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                sendResultEntity.ResultInformation &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;邮件接收失败:{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                sendResultEntity.ResultStatus &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取SMTP基础信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;client&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;客户端对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MailServerInformation SmtpClientBaseMessage(SmtpClient client)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mailServerInformation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MailServerInformation
            {
                Authentication &lt;/span&gt;=&lt;span&gt; client.Capabilities.HasFlag(SmtpCapabilities.Authentication),
                BinaryMime &lt;/span&gt;=&lt;span&gt; client.Capabilities.HasFlag(SmtpCapabilities.BinaryMime),
                Dsn &lt;/span&gt;=&lt;span&gt; client.Capabilities.HasFlag(SmtpCapabilities.Dsn),
                EightBitMime &lt;/span&gt;=&lt;span&gt; client.Capabilities.HasFlag(SmtpCapabilities.EightBitMime),
                Size &lt;/span&gt;=&lt;span&gt; client.MaxSize
            };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mailServerInformation;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建邮件日志文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CreateMailLog()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logPath = AppDomain.CurrentDomain.BaseDirectory + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/DocumentLog/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                Guid.NewGuid() &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (File.Exists(logPath)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logPath;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fs =&lt;span&gt; File.Create(logPath);
            fs.Close();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; logPath;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;       2.组装邮件消息：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailMessage
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 组装邮件文本/附件邮件信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mailBodyEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;邮件消息实体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MimeMessage AssemblyMailMessage(MailBodyEntity mailBodyEntity)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mailBodyEntity == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(mailBodyEntity));
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MimeMessage();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置邮件基本信息&lt;/span&gt;
&lt;span&gt;            SetMailBaseMessage(message, mailBodyEntity);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; multipart = &lt;span&gt;new&lt;/span&gt; Multipart(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mixed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入文本消息&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(mailBodyEntity.MailTextBody) == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; alternative = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MultipartAlternative
                {
                    AssemblyMailTextMessage(mailBodyEntity.MailTextBody, mailBodyEntity.MailBodyType)
                 };

                multipart.Add(alternative);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入附件&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (mailBodyEntity.MailFilePath != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; File.Exists(mailBodyEntity.MailFilePath) == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mimePart =&lt;span&gt; AssemblyMailAttachmentMessage(mailBodyEntity.MailFileType, mailBodyEntity.MailFileSubType,
                     mailBodyEntity.MailFilePath);

                multipart.Add(mimePart);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组合邮件内容&lt;/span&gt;
            message.Body =&lt;span&gt; multipart;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; message;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置邮件基础信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;minMessag&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mailBodyEntity&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MimeMessage SetMailBaseMessage(MimeMessage minMessag, MailBodyEntity mailBodyEntity)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (minMessag == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mailBodyEntity == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入发件人&lt;/span&gt;
            minMessag.From.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MailboxAddress(mailBodyEntity.Sender, mailBodyEntity.SenderAddress));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入收件人&lt;/span&gt;
            &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; recipients &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mailBodyEntity.Recipients)
            {
                minMessag.To.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MailboxAddress(recipients));
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入抄送人&lt;/span&gt;
            &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cC &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mailBodyEntity.Cc)
            {
                minMessag.Cc.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MailboxAddress(cC));
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入主题&lt;/span&gt;
            minMessag.Subject =&lt;span&gt; mailBodyEntity.Subject;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; minMessag;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 组装邮件文本信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mailBody&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;邮件文本内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;textPartType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;邮件文本类型(plain,html,rtf,xml)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TextPart AssemblyMailTextMessage(&lt;span&gt;string&lt;/span&gt; mailBody, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; textPartType)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(mailBody))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(textPartType))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; textBody = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextPart(textPartType)
            {
                Text &lt;/span&gt;=&lt;span&gt; mailBody
            };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; textBody;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 组装邮件附件信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileAttachmentType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;附件类型(image,application)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileAttachmentSubType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;附件子类型 &lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileAttachmentPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;附件路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MimePart AssemblyMailAttachmentMessage(&lt;span&gt;string&lt;/span&gt; fileAttachmentType, &lt;span&gt;string&lt;/span&gt; fileAttachmentSubType, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileAttachmentPath)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(fileAttachmentSubType))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(fileAttachmentType))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(fileAttachmentPath))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attachment = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MimePart(fileAttachmentType, fileAttachmentSubType)
            {
                Content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MimeContent(File.OpenRead(fileAttachmentPath)),
                ContentDisposition &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentDisposition(ContentDisposition.Attachment),
                ContentTransferEncoding &lt;/span&gt;=&lt;span&gt; ContentEncoding.Base64,
                FileName &lt;/span&gt;=&lt;span&gt; Path.GetFileName(fileAttachmentPath)
            };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; attachment;
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;       3.邮件基础服务实体：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件内容实体
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailBodyEntity
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件文本内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MailTextBody { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件内容类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MailBodyType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件附件文件类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MailFileType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件附件文件子类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MailFileSubType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件附件文件路径
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MailFilePath { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 收件人
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Recipients { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 抄送
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Cc { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发件人
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Sender { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发件人地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SenderAddress { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件主题
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Subject { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Body { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件服务器基础信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailServerInformation
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SMTP服务器支持SASL机制类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Authentication { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SMTP服务器对消息的大小
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;uint&lt;/span&gt; Size { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SMTP服务器支持传递状态通知
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Dsn { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SMTP服务器支持Content-Transfer-Encoding
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; EightBitMime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SMTP服务器支持Content-Transfer-Encoding
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; BinaryMime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SMTP服务器在消息头中支持UTF-8
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UTF8 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

&lt;/span&gt;&lt;span&gt;    ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件发送结果
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SendResultEntity
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 结果信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ResultInformation { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 结果状态
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ResultStatus { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件发送服务器配置
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SendServerConfigurationEntity
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮箱SMTP服务器地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SmtpHost { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮箱SMTP服务器端口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SmtpPort { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否启用IsSsl
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsSsl { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮件编码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MailEncoding { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发件人账号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SenderAccount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发件人密码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SenderPassword { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     上面提供了借助MailKit组建创建发送邮件服务，分别是创建邮件服务器连接，组装邮件基础信息，邮件基础实体。发送邮件的基础服务比较的多，下面介绍一下邮件的接收。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 跟投邮件服务API
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReceiveEmailServiceApi
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置发件人信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SendServerConfigurationEntity SetSendMessage()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sendServerConfiguration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendServerConfigurationEntity
            {
                SmtpHost &lt;/span&gt;= ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmtpServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                SmtpPort &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;.Parse(ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SmtpPort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]),
                IsSsl &lt;/span&gt;= Convert.ToBoolean(ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsSsl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]),
                MailEncoding &lt;/span&gt;= ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MailEncoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                SenderAccount &lt;/span&gt;= ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SenderAccount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                SenderPassword &lt;/span&gt;= ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SenderPassword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sendServerConfiguration;
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 接收邮件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReceiveEmail()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sendServerConfiguration =&lt;span&gt; SetSendMessage();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sendServerConfiguration == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException();
            }

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt; ImapClient(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProtocolLogger(CreateMailLog())))
            {
                client.Connect(sendServerConfiguration.SmtpHost, sendServerConfiguration.SmtpPort,
                    SecureSocketOptions.SslOnConnect);
                client.Authenticate(sendServerConfiguration.SenderAccount, sendServerConfiguration.SenderPassword);
                client.Inbox.Open(FolderAccess.ReadOnly);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uids =&lt;span&gt; client.Inbox.Search(SearchQuery.All);
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; uid &lt;span&gt;in&lt;/span&gt;&lt;span&gt; uids)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message =&lt;span&gt; client.Inbox.GetMessage(uid);
                    message.WriteTo($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{uid}.eml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }

                client.Disconnect(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 下载邮件内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DownloadBodyParts()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sendServerConfiguration =&lt;span&gt; SetSendMessage();

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImapClient())
            {
                client.Connect(sendServerConfiguration.SmtpHost, sendServerConfiguration.SmtpPort,
                    SecureSocketOptions.SslOnConnect);
                client.Authenticate(sendServerConfiguration.SenderAccount, sendServerConfiguration.SenderPassword);
                client.Inbox.Open(FolderAccess.ReadOnly);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 搜索Subject标题包含“MimeKit”或“MailKit”的邮件&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; query = SearchQuery.SubjectContains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MimeKit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Or(SearchQuery.SubjectContains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MailKit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uids =&lt;span&gt; client.Inbox.Search(query);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取搜索结果的摘要信息（我们需要UID和BODYSTRUCTURE每条消息，以便我们可以提取文本正文和附件）&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; items = client.Inbox.Fetch(uids, MessageSummaryItems.UniqueId |&lt;span&gt; MessageSummaryItems.BodyStructure);

                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; items)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确定一个目录来保存内容&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; directory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/MailBody&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, item.UniqueId.ToString());

                    Directory.CreateDirectory(directory);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IMessageSummary.TextBody是一个便利的属性，可以为我们找到“文本/纯文本”的正文部分&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; bodyPart =&lt;span&gt; item.TextBody;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下载'text / plain'正文部分&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; body =&lt;span&gt; (TextPart) client.Inbox.GetBodyPart(item.UniqueId, bodyPart);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TextPart.Text是一个便利的属性，它解码内容并将结果转换为我们的字符串&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; text =&lt;span&gt; body.Text;

                    File.WriteAllText(Path.Combine(directory, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), text);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 现在遍历所有附件并将其保存到磁盘&lt;/span&gt;
                    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; attachment &lt;span&gt;in&lt;/span&gt;&lt;span&gt; item.Attachments)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 像我们对内容所做的那样下载附件&lt;/span&gt;
                        &lt;span&gt;var&lt;/span&gt; entity =&lt;span&gt; client.Inbox.GetBodyPart(item.UniqueId, attachment);

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 附件可以是message / rfc822部件或常规MIME部件&lt;/span&gt;
                        &lt;span&gt;var&lt;/span&gt; messagePart = entity &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MessagePart;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (messagePart != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rfc822 =&lt;span&gt; messagePart;

                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path = Path.Combine(directory, attachment.PartSpecifier + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.eml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                            rfc822.Message.WriteTo(path);
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; part =&lt;span&gt; (MimePart) entity;

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意：这可能是空的，但大多数会指定一个文件名&lt;/span&gt;
                            &lt;span&gt;var&lt;/span&gt; fileName =&lt;span&gt; part.FileName;

                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path =&lt;span&gt; Path.Combine(directory, fileName);

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; decode and save the content to a file&lt;/span&gt;
                            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; stream =&lt;span&gt; File.Create(path))
                                part.Content.DecodeTo(stream);
                        }
                    }
                }

                client.Disconnect(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建邮件日志文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CreateMailLog()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logPath = AppDomain.CurrentDomain.BaseDirectory + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/DocumentLog/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                DateTime.Now.ToUniversalTime().ToString(CultureInfo.InvariantCulture) &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (File.Exists(logPath)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logPath;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fs =&lt;span&gt; File.Create(logPath);
            fs.Close();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; logPath;

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     上面只是简单的介绍了邮件的接收，如果需要更加深入的了解功能，可以进一步对组件源码进行解析，该组件的文档为较为的丰富。&lt;/p&gt;
&lt;h3&gt;　　三.组件使用感悟：&lt;/h3&gt;
&lt;p&gt;            MailKit和MimeKit组件在项目的使用中较为的便捷，基本包含了所有的基础邮件服务操作。组件提供的SmtpClient类提供的功能很丰富，例如连接邮件服务器，邮件账户认证，组装邮件消息，获取邮件服务器配置信息等等方法的提供，可以让我们在项目中快速的获取邮件服务的所有信息。&lt;/p&gt;
&lt;p&gt;           使用过邮件功能的项目 都会有困扰，客户端与邮件服务器的连接是否成功，以及邮件是否发送成功状态没有办法很快的获取，只能根据邮件服务器返回的一场状态进行判断。但是MailKit提供对应的方法和异常类，对邮件服务器返回的异常信息进行解析，客户端可以根据这些异常类获取邮件状态。&lt;/p&gt;
&lt;p&gt;           MailKit组件的提供了ProtocolLogger类，该类用于记录SMTP操作基础信息，该类作用为记录邮件服务日志。在邮件发送完毕后，需要及时的关闭连接，调用Disconnect(true)方法。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Mar 2018 15:00:00 +0000</pubDate>
<dc:creator>彭泽0902</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengze0902/p/8519715.html</dc:identifier>
</item>
<item>
<title>Java中的Lock与synchronized - 大大控</title>
<link>http://www.cnblogs.com/huangbw/p/8516024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangbw/p/8516024.html</guid>
<description>&lt;p&gt;并发编程学习笔记之Lock与synchronized&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、什么是可重入锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lcok在Java中是一个接口，一般在面试问题中问到的可能是ReentrantLock与synchronized的区别。ReentrantLock是Lock的一个实现类，字面意思的话就是&lt;strong&gt;可重入锁，&lt;/strong&gt;那么什么是可重入锁呢。&lt;/p&gt;
&lt;p&gt;可重入锁是锁的一个相关概念，并不是特指我们的ReentrantLock，而是如果一个锁具备可重入性，那我们就说这是一个可重入锁。ReentrantLock和synchronized都是可重入锁。至于什么是可重入性，这里举个简单的例子，现在在一个类里我们有两个方法（代码如下），一个叫做去北京，一个叫做买票，那我们在去北京的方法里可以直接调用买票方法，假如两个方法全都用synchronized修饰的话，在执行去北京的方法，线程获取了对象的锁，接着执行买票方法，如果synchronized不具备可重入性，那么线程已经有这个对象的锁了，现在又来申请，就会导致线程永远等待无法获取到锁。而synchronized和ReentrantLock都是可重入锁，就不会出现上述的问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Trip {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; goToBeiJing() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去北京  &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        buyATicket();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buyATicket() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 买票&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、Lock与synchronized的不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二者都是可重入锁，那么为什么要有两个呢？既然存在，那么就一定是有意义的。synchronized是Java中的一个关键字，而Lock是Java1.5后在java.util.concurrent.locks包下提供的一种实现同步的方法，那么显然的，synchronized一定是有什么做不到的或者缺陷，才导致了Lock的诞生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.synchronized的缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）当一个代码块被synchronized修饰的时候，一个线程获取到了锁，并且执行代码块，那么其他的线程需要等待正在使用的线程释放掉这个锁，那么释放锁的方法只有两种，一种是代码执行完毕自动释放，一种是发生异常以后jvm会让线程去释放锁。那么如果这个正在执行的线程遇到什么问题，比如等待IO或者调用sleep方法等等被阻塞了，无法释放锁，而这时候其他线程只能一直等待，将会特别影响效率。那么有没有一种办法让其他线程不必一直傻乎乎的等在这里吗？&lt;/p&gt;
&lt;p&gt;2）当一个文件，同时被多个线程操作时，读操作和写操作会发生冲突，写操作和写操作会发生冲突，而读操作和读操作并不会冲突，但是如果我们用synchronized的话，会导致一个线程在读的时候，其他线程想要读的话只能等待，那么有什么办法能不锁读操作吗？&lt;/p&gt;
&lt;p&gt;3）在使用synchronized时，我们无法得知线程是否成功获取到锁，那么有什么办法能知道是否获取到锁吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.java.util.concurrent.locks包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）Lock&lt;/p&gt;
&lt;p&gt;Lock是一个接口，源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Lock {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; lockInterruptibly() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; tryLock();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    Condition newCondition();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ReentrantLock是Lock的一个实现类，也是唯一一个实现类，它的意思是可重入锁，可重入锁前面已经讲过了。ReentrantLock中提供了更多的一些方法。不过常用的就是Lock中的这些。&lt;/p&gt;
&lt;p&gt;来看一下Lock接口这些方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。&lt;/p&gt;
&lt;p&gt;这里有四个方法来获取锁，那么区别在哪里呢？&lt;/p&gt;
&lt;p&gt;lock()使我们平时用的最多的，最用是用来获取锁，如果锁已经被其他线程获取，那么就等待。但是采用Lock必须要主动释放锁，所以我们一般在try{}catch{}块中处理然后在finally中释放锁，举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;lock.lock();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 捕获异常&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    lock.unlock();   
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; tryLock()是一个boolean类型的方法，当调用这个方法的时候，线程会去尝试获取锁，如果获取到的话会返回true，如果获取不到返回false，也就是说这个方法会立马返回一个结果，线程不会等待。&lt;/p&gt;
&lt;p&gt;tryLock(long time, TimeUnit unit)是上面tryLock()方法的一个重载方法，加了两个参数，给定了等待的时间，如果在规定时间拿到锁返回true，如果拿不到返回false。这两个方法的一般用法和Lock类似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (lock.tryLock()) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理    &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 捕获异常&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        lock.unlock();   
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lockInterruptibly()就比较特殊了，它表示可被中断的，意思就是，当尝试获取锁的时候，如果获取不到的话就会等待，但是，在等待的过程中它是可以响应中断的，也就是中断线程的等待过程。使用形式的话一样用try catch处理，就不贴代码了。&lt;/p&gt;
&lt;p&gt;2）ReadWriteLock&lt;/p&gt;
&lt;p&gt;ReadWriteLock也是一个接口，这个接口中只有两个方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ReadWriteLock {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    Lock readLock();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    Lock writeLock();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个接口的从字面就能看出来他的用途，读锁和写锁，这时候是不是想起了前面我写到的synchronized的第二条。&lt;/p&gt;
&lt;p&gt;ReentrantReadWriteLock是ReadWriteLock的一个实现类，最常用到的也是获取读锁和获取写锁。下面看例子：&lt;/p&gt;
&lt;p&gt;首先是使用synchronized的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Main m = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Main();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;        
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                m.read(Thread.currentThread());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }.start();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;          
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                m.read(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }.start(); 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;      
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(Thread thread) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(System.currentTimeMillis() - startTime &amp;lt;= 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             System.out.println(thread.getName()+&quot;线程在进行读操作&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(thread.getName()+&quot;线程完成读操作&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码的执行结果是在一个线程打印出完成读操作后，另一条线程才会开始进行读操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Thread-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程完成读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-1线程完成读操作
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面看如果用ReadWriteLock：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; ReentrantReadWriteLock readWriteLock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Main m = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Main();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;        
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                m.read(Thread.currentThread());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }.start();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;          
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                m.read(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }.start(); 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(Thread thread) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        readWriteLock.readLock().lock();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(System.currentTimeMillis() - startTime &amp;lt;= 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 System.out.println(thread.getName()+&quot;线程在进行读操作&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             System.out.println(thread.getName()+&quot;线程完成读操作&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        readWriteLock.unlock();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只是把之前的synchronized换成了ReadWriteLock，但是输出结果却是两个线程在一起进行读操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Thread-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;1线程在进行读操作
Thread&lt;/span&gt;-&lt;span&gt;0线程完成读操作
Thread&lt;/span&gt;-1线程完成读操作
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个结果可以看到两个线程同时进行读操作，效率大大的提升了。但是要注意的是，如果一个线程获取了读锁，那么另外的线程想要获取写锁则需要等待释放；而如果一个线程已经获取了写锁，则另外的线程想获取读锁或写锁都需要等待写锁被释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下二者：&lt;/p&gt;
&lt;p&gt;1.synchronized是Java的关键字，是内置特性，而Lock是一个接口，可以用它来实现同步。&lt;/p&gt;
&lt;p&gt;2.synchronized同步的时候，其中一条线程用完会自动释放锁，而Lock需要手动释放，如果不手动释放，可能会造成死锁。&lt;/p&gt;
&lt;p&gt;3.使用synchronized如果其中一个线程不释放锁，那么其他需要获取锁的线程会一直等待下去，知道使用完释放或者出现异常，而Lock可以使用可以响应中断的锁或者使用规定等待时间的锁&lt;/p&gt;
&lt;p&gt;4.synchronized无法得知是否获取到锁，而Lcok可以做到。&lt;/p&gt;
&lt;p&gt;5.用ReadWriteLock可以提高多个线程进行读操作的效率。&lt;/p&gt;
&lt;p&gt;所以综上所述，在两种锁的选择上，当线程对于资源的竞争不激烈的时候，效率差不太多，但是当大量线程同时竞争的时候，Lock的性能会远高于synchronized。&lt;/p&gt;

</description>
<pubDate>Tue, 06 Mar 2018 13:42:00 +0000</pubDate>
<dc:creator>大大控</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangbw/p/8516024.html</dc:identifier>
</item>
<item>
<title>Docker集群编排工具之Kubernetes（K8s）介绍、安装及使用 - 酷酷的二连长</title>
<link>http://www.cnblogs.com/lyq863987322/p/8516958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyq863987322/p/8516958.html</guid>
<description>&lt;h2&gt;K8s基础原理&lt;/h2&gt;
&lt;p&gt;k8s中文社区：&lt;a href=&quot;https://www.kubernetes.org.cn/&quot; target=&quot;_blank&quot;&gt;https://www.kubernetes.org.cn/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;Kubernetes与较早的集群管理系统Mesos和YARN相比，对容器尤其是 Docker的支持更加原生，同时提供了更强大的机制实现资源调度，自动 管理容器生命周期，负载均衡，高可用等底层功能，使开发者可以专注于开发应用。&lt;/p&gt;
&lt;p&gt;Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。&lt;/p&gt;
&lt;h3&gt;K8s特性&lt;/h3&gt;
&lt;p&gt;Kubernetes是为生产环境而设计的容器调度管理系统，对于负载均衡、 服务发现、高可用、滚动升级、自动伸缩等容器云平台的功能要求有原生支持&lt;/p&gt;
&lt;p&gt;一个K8s集群是由分布式存储（etcd）、服务节点（Minion， etcd现在称为Node）和控制节点（Master）构成的。所有的集群状态都保存在etcd中，Master节点上则运行集群的管理控制模块。Node节点是真正运行应用容器的主机节点，在每个Minion节点上都会运行一个Kubelet代理，控制该节点上的容器、镜像和存储卷等。&lt;/p&gt;
&lt;h3&gt;K8s架构图，介绍&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201803/1234532-20180306201435336-301150279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;Master（管理节点）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;API Server：供Kubernetes API接口，主要处理 Rest操作以及更新Etcd中的对象。 所有资源增删改查的唯一入口。&lt;/li&gt;
&lt;li&gt;Scheduler：绑定Pod到Node上，资源调度。&lt;/li&gt;
&lt;li&gt;Controller Manager： 所有其他群集级别的功能，目前由控制器Manager执行。资源对象的 自动化控制中心。&lt;/li&gt;
&lt;li&gt;Etcd：所有持久化的状态信息存储在Etcd中。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Node（计算节点）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Kubelet：管理Pods以及容器、镜像、Volume等，实现对集群 对节点的管理&lt;/li&gt;
&lt;li&gt;Kube-proxy：提供网络代理以及负载均衡，实现与Service通讯。&lt;/li&gt;
&lt;li&gt;Docker Engine：负责节点的容器的管理工作。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;API SERVER（授权）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;只有API Server与存储通信，其他模块通过 API Server访问集群状态。&lt;/li&gt;
&lt;li&gt;一个工作节点的问题不影响集群体。&lt;/li&gt;
&lt;li&gt;在K8s集群中，所有的配置管理操作都声明 式而非命令式的。&lt;/li&gt;
&lt;li&gt;各个模块在内存中缓存自己的相关状态以 提高系统性能。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Scheduler（资源调度）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;负责集群的资源调度，根据特定的调度算法将pod调度到指定的minion上。&lt;/li&gt;
&lt;li&gt;这部分工作分出来变成一个组件，意味着可以很方便地替换成其他的调度器。&lt;/li&gt;
&lt;li&gt;Scheduler调度器输入是待调度pod和可用的工作节点列表，输出则是应用调度 算法从列表中选择一个最优的用于绑定待调度的pod节点。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Controller Manager（控制管理中心）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点、命名空间、服务账号、资源定额等的管理并执行自动化修复流程，确保集群处于预期的工作状态&lt;/li&gt;
&lt;li&gt;在Kubernetes集群中，每个Controller就是一个操作系统，它通过API Server监控系统的共享状态，并尝试着将系统状态从“现有状态”修正到“期望状态”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201803/1234532-20180306203837495-1421055388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;POD（资源池）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Pod是K8s集群中所有业务类型的基础&lt;/li&gt;
&lt;li&gt;Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。&lt;/li&gt;
&lt;li&gt;Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统。&lt;/li&gt;
&lt;li&gt;POD控制器Deployment、Job、DaemonSet和 PetSet&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201803/1234532-20180306203946217-391958357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;LABEL（标签）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Label是一个 key=value的键值对，由用户指定，可以附加到 K8S资源之上。&lt;/li&gt;
&lt;li&gt;给某个资源定义一个标签，随后可以通过label进行查询和筛选 ，类似SQL的where语句。&lt;/li&gt;
&lt;li&gt;Label可以给对象创建多组标签&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201803/1234532-20180306204324406-1859508761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;Replication Controller，RC&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;RC是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。&lt;/li&gt;
&lt;li&gt;指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。&lt;/li&gt;
&lt;li&gt;即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;PC总结&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;RC里包括完整的POD定义模板&lt;/li&gt;
&lt;li&gt;RC通过Label Selector（标签选择器）机制实现对POD副本的自动控制。&lt;/li&gt;
&lt;li&gt;通过改变RC里的POD副本以实现POD的扩容和缩容&lt;/li&gt;
&lt;li&gt;通过改变RC里POD模块中的镜像版本，可以实现POD的滚动升级。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;K8s组件&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201803/1234532-20180306201453513-563108731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;K8s安装配置&lt;/h2&gt;
&lt;h3&gt;K8s安装方法&lt;/h3&gt;
&lt;p&gt;yum安装  1.5.2&lt;/p&gt;
&lt;p&gt;二进制安装&lt;/p&gt;
&lt;p&gt;kubeadm安装（官方）  需要梯子，全部容器化&lt;/p&gt;
&lt;p&gt;minkube安装&lt;/p&gt;
&lt;p&gt;编译安装&lt;/p&gt;
&lt;p&gt;自动化安装&lt;/p&gt;
&lt;h4&gt;K8s资源&lt;/h4&gt;
&lt;p&gt;官网 　　　kubernetes.io&lt;/p&gt;
&lt;p&gt;中文社区 　&lt;a href=&quot;https://www.kubernetes.org.cn/&quot; target=&quot;_blank&quot;&gt;https://www.kubernetes.org.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github 　　&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot; target=&quot;_blank&quot;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;命令行参考 &lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kub%20ectl/kubectl-commands#&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/reference/generated/kub ectl/kubectl-commands#&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;K8s的安装环境要求&lt;/h4&gt;
&lt;p&gt;1、linux 内核3.10以上&lt;/p&gt;
&lt;p&gt;2、64位系统&lt;/p&gt;
&lt;p&gt;3、内存4G&lt;/p&gt;
&lt;p&gt;4、安装epel&lt;/p&gt;
&lt;p&gt;5、安装docker&lt;/p&gt;
&lt;p&gt;6、开启yum cache保存安装RPM包&lt;/p&gt;
&lt;h3&gt;K8s中有三种类型的ip&lt;/h3&gt;
&lt;p&gt;物理ip（宿主机ip）&lt;/p&gt;
&lt;p&gt;集群ip（cluster ip）：10.254.0.0/16&lt;/p&gt;
&lt;p&gt;pod（容器的ip）：172.16.0.0/16&lt;/p&gt;
&lt;h2&gt;K8s安装与使用&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;环境：三台机器，两个node（计算节点），一个主节点（master）&lt;/p&gt;
&lt;p&gt;yum源需要：repo：CentOS-Base.repo  docker1.12&lt;/p&gt;
&lt;h4&gt;主节点（master）&lt;/h4&gt;
&lt;p&gt;主机名：K8s-master   ip：10.0.0.11   系统：centos7.2 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; etcd -&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; docker -&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; kubernetes -&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; flannel -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;计算节点（node）&lt;/h4&gt;
&lt;p&gt;K8s-node-1   10.0.0.12   centos7.2&lt;/p&gt;
&lt;p&gt;K8s-node-2   10.0.0.13    centos7.2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; docker -&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; kubernetes -&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; flannel -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;在master节点上&lt;/h3&gt;
&lt;h4&gt;修改配置&lt;/h4&gt;
&lt;h5&gt;修改etcd配置文件&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# vim /etc/etcd/&lt;span&gt;etcd.conf
ETCD_NAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ETCD_LISTEN_CLIENT_URLS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ETCD_ADVERTISE_CLIENT_URLS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.0.0.11:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemctl enable etcd.service
systemctl  start etcd.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;检查&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# etcdctl -C http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.0.0.11:2379 cluster-health&lt;/span&gt;
member 8e9e05c52164694d is healthy: got healthy result from http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.0.0.11:2379&lt;/span&gt;
cluster is healthy
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;修改/etc/kubernetes/apiserver&lt;/h5&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
vim /etc/kubernetes/&lt;span&gt;apiserver
 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt; KUBE_API_ADDRESS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--insecure-bind-address=0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; KUBE_API_PORT=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--port=8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; KUBE_ETCD_SERVERS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--etcd-servers=http://10.0.0.11:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; KUBE_ADMISSION_CONTROL=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;修改/etc/kubernetes/config&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/kubernetes/&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; KUBE_MASTER=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--master=http://10.0.0.11:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
systemctl enable kube-&lt;span&gt;apiserver.service
systemctl start kube&lt;/span&gt;-&lt;span&gt;apiserver.service
systemctl enable kube&lt;/span&gt;-controller-&lt;span&gt;manager.service
systemctl start kube&lt;/span&gt;-controller-&lt;span&gt;manager.service
systemctl enable kube&lt;/span&gt;-&lt;span&gt;scheduler.service
systemctl start kube&lt;/span&gt;-scheduler.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看是否启动成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl status kube-apiserver.service kube-controller-manager.service  kube-scheduler.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;在node节点&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/kubernetes/&lt;span&gt;config
KUBE_MASTER&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--master=http://10.0.0.11:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;node-1&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vim /etc/kubernetes/&lt;span&gt;kubelet
KUBELET_ADDRESS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--address=0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
KUBELET_HOSTNAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--hostname-override=10.0.0.12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
KUBELET_API_SERVER&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--api-servers=http://10.0.0.11:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;node-2&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vim /etc/kubernetes/&lt;span&gt;kubelet
KUBELET_ADDRESS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--address=0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
KUBELET_HOSTNAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--hostname-override=10.0.0.13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
KUBELET_API_SERVER&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--api-servers=http://10.0.0.11:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;启动检查&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemctl enable kubelet.service
systemctl start kubelet.service
systemctl enable kube&lt;/span&gt;-&lt;span&gt;proxy.service
systemctl start kube&lt;/span&gt;-proxy.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~&lt;span&gt;]# kubectl get nodes
NAME        STATUS    AGE
&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;   Ready     3m
&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;   Ready     3m
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置flannel网络&lt;/h3&gt;
&lt;/div&gt;
&lt;h4&gt;修改配置文件&lt;/h4&gt;
&lt;p&gt;master、node上均编辑/etc/sysconfig/flanneld&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/sysconfig/&lt;span&gt;flanneld
FLANNEL_ETCD_ENDPOINTS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.0.0.11:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;配置flannel的网络范围&lt;/h4&gt;
&lt;p&gt;etcdctl mk /atomic.io/network/config '{ &quot;Network&quot;: &quot;172.16.0.0/16&quot; }'&lt;/p&gt;
&lt;p&gt;实操：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# etcdctl mk /atomic.io/network/config &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{ &quot;Network&quot;: &quot;172.16.0.0/16&quot; }&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Network&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.16.0.0/16&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;启动&lt;/h4&gt;
&lt;p&gt;在master执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemctl enable flanneld.service 
systemctl start flanneld.service 
service docker restart
systemctl restart kube&lt;/span&gt;-&lt;span&gt;apiserver.service
systemctl restart kube&lt;/span&gt;-controller-&lt;span&gt;manager.service
systemctl restart kube&lt;/span&gt;-scheduler.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在node上执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemctl enable flanneld.service 
systemctl start flanneld.service 
service docker restart
systemctl restart kubelet.service
systemctl restart kube&lt;/span&gt;-proxy.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;K8s常见命令操作&lt;/h3&gt;
&lt;p&gt;命令：kubectl create -f hello.yaml&lt;/p&gt;
&lt;p&gt;文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~&lt;span&gt;]# vim hello.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: hello&lt;/span&gt;-&lt;span&gt;world
spec:
  restartPolicy: Never
  containers:
  &lt;/span&gt;-&lt;span&gt; name: hello
    image: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker.io/busybox:latest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    command: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/echo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello”,”world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实操：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl create -&lt;span&gt;f hello.yaml
pod &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello-world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; created

kubectl get pods   查看默认name信息

kubectl describe pods hello&lt;/span&gt;-world    查看hello-&lt;span&gt;world的详细信息
kubectl delete pods hello&lt;/span&gt;-world      删除名叫hello-&lt;span&gt;world
kubectl replace &lt;/span&gt;-f nginx-&lt;span&gt;rc.yaml     对已有资源进行更新、替换
kubectl edit rc nginx            对现有资源直接进行修改，立即生效
kubectl logs nginx&lt;/span&gt;-gt1jd    　　　查看访问日志
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;存在的坑&lt;/h3&gt;
&lt;p&gt;因为没有证书，拉取图像失败。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de7d7051-3870-4fc4-92fd-efaa286c6a73')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_de7d7051-3870-4fc4-92fd-efaa286c6a73&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de7d7051-3870-4fc4-92fd-efaa286c6a73&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('de7d7051-3870-4fc4-92fd-efaa286c6a73',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de7d7051-3870-4fc4-92fd-efaa286c6a73&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl describe pods hello-&lt;span&gt;world
Name:        hello&lt;/span&gt;-&lt;span&gt;world
Namespace:    default
Node:        &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;/&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt;
Start Time:    Fri, &lt;/span&gt;&lt;span&gt;02&lt;/span&gt; Feb &lt;span&gt;2018&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;28&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;&lt;span&gt;
Labels:        &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Status:        Pending
IP:        
Controllers:    &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Containers:
  hello:
    Container ID:    
    Image:        docker.io&lt;/span&gt;/&lt;span&gt;busybox:latest
    Image ID:        
    Port:        
    Command:
      &lt;/span&gt;/bin/&lt;span&gt;echo&lt;/span&gt;&lt;span&gt;
      hello”,”world
    State:            Waiting
      Reason:            ContainerCreating
    Ready:            False
    Restart Count:        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    Volume Mounts:        &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
    Environment Variables:    &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Conditions:
  Type        Status
  Initialized     True 
  Ready     False 
  PodScheduled     True 
No volumes.
QoS Class:    BestEffort
Tolerations:    &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Events:
  FirstSeen    LastSeen    Count    From            SubObjectPath    Type        Reason        Message
  &lt;/span&gt;---------    --------    -----    ----            -------------    --------    ------        -------&lt;span&gt;
  4m        4m        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    {default-scheduler }           Normal        Scheduled    Successfully assigned hello-world to &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt;
  4m        1m        &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    {kubelet &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;}           Warning        FailedSync    Error syncing pod, skipping: failed to &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StartContainer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; with ErrImagePull: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image pull failed for registry.access.redhat.com/rhel7/pod-infrastructure:latest, this may be because there are no credentials on this request.  details: (open /etc/docker/certs.d/registry.access.redhat.com/redhat-ca.crt: no such file or directory)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  3m    5s    &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    {kubelet &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;}        Warning    FailedSync    Error syncing pod, skipping: failed to &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StartContainer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; with ImagePullBackOff: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Back-off pulling image \&quot;registry.access.redhat.com/rhel7/pod-infrastructure:latest\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;拉取图像失败&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;a&quot;&gt;解决：yum install python-rhsm* -y&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl create -&lt;span&gt;f nginx.yaml 
pod &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello-nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; created
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查是否成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl get pods -&lt;span&gt;o wide
NAME          READY     STATUS    RESTARTS   AGE       IP            NODE
hello&lt;/span&gt;-nginx   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2h        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.2&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RC：保证高可用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;RC是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。&lt;/li&gt;
&lt;li&gt;指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。&lt;/li&gt;
&lt;li&gt;即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;始终保持一个在活着&lt;/p&gt;
&lt;p&gt;rc版yaml编写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# &lt;span&gt;cat&lt;/span&gt; nginx-&lt;span&gt;rc.yaml 
apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx
spec:
  replicas: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  selector:
    app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      &lt;/span&gt;-&lt;span&gt; name: nginx
        image: nginx:latest
        ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动rc版容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl create -f nginx-&lt;span&gt;rc.yaml 
replicationcontroller &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; created
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl get pods -&lt;span&gt;o wide
NAME          READY     STATUS    RESTARTS   AGE       IP            NODE
nginx&lt;/span&gt;-gt1jd   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2m        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.2&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话就算删除了这个容器RC也会立马在起一个&lt;/p&gt;
&lt;h3&gt;版本升级&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# &lt;span&gt;cat&lt;/span&gt; web-&lt;span&gt;rc2.yaml 
apiVersion: v1
kind: ReplicationController
metadata:
  name: myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
spec:
  replicas: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  selector:
    app: myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  template:
    metadata:
      labels:
        app: myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    spec:
      containers:
      &lt;/span&gt;- name: myweb-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        image: kubeguide&lt;/span&gt;/tomcat-&lt;span&gt;app:v2
        ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;8080&lt;/span&gt;
        &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;-&lt;span&gt; name: MYSQL_SERVICE_HOST
          value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        -&lt;span&gt; name: MYSQL_SERVICE_PORT
          value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;升级操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl rolling-update myweb -f web-&lt;span&gt;rc2.yaml 
Created myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Scaling up myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt; from &lt;span&gt;0&lt;/span&gt; to &lt;span&gt;2&lt;/span&gt;, scaling down myweb from &lt;span&gt;2&lt;/span&gt; to &lt;span&gt;0&lt;/span&gt; (keep &lt;span&gt;2&lt;/span&gt; pods available, don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t exceed 3 pods)&lt;/span&gt;
Scaling myweb-&lt;span&gt;2&lt;/span&gt; up to &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Scaling myweb down to &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Scaling myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt; up to &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Scaling myweb down to &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Update succeeded. Deleting myweb
replicationcontroller &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myweb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; rolling updated to &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myweb-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;升级过程&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl get pods -&lt;span&gt;o wide
NAME            READY     STATUS    RESTARTS   AGE       IP            NODE
myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;-mmlcm   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          32s       &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.3&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt;
myweb&lt;/span&gt;-&lt;span&gt;71438&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2m        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.2&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt;
myweb&lt;/span&gt;-cx9j2     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2m        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.3&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;
nginx&lt;/span&gt;-gt1jd     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          1h        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.2&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;
[root@k8s&lt;/span&gt;-master ~]# kubectl get pods -&lt;span&gt;o wide
NAME            READY     STATUS    RESTARTS   AGE       IP            NODE
myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;-0kmzf   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          7s        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.4&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;
myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;-mmlcm   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          1m        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.3&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt;
myweb&lt;/span&gt;-cx9j2     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2m        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.3&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;
nginx&lt;/span&gt;-gt1jd     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          1h        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.2&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;回滚&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# &lt;span&gt;cat&lt;/span&gt; web-&lt;span&gt;rc.yaml 
apiVersion: v1
kind: ReplicationController
metadata:
  name: myweb
spec:
  replicas: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  selector:
    app: myweb
  template:
    metadata:
      labels:
        app: myweb
    spec:
      containers:
      &lt;/span&gt;-&lt;span&gt; name: myweb
        image: kubeguide&lt;/span&gt;/tomcat-&lt;span&gt;app:v1
        ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;8080&lt;/span&gt;
        &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;-&lt;span&gt; name: MYSQL_SERVICE_HOST
          value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        -&lt;span&gt; name: MYSQL_SERVICE_PORT
          value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl rolling-update myweb-&lt;span&gt;2&lt;/span&gt; -f web-&lt;span&gt;rc.yaml 
Created myweb
Scaling up myweb from &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; to &lt;span&gt;2&lt;/span&gt;, scaling down myweb-&lt;span&gt;2&lt;/span&gt; from &lt;span&gt;2&lt;/span&gt; to &lt;span&gt;0&lt;/span&gt; (keep &lt;span&gt;2&lt;/span&gt; pods available, don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t exceed 3 pods)&lt;/span&gt;
Scaling myweb up to &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Scaling myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt; down to &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Scaling myweb up to &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Scaling myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt; down to &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Update succeeded. Deleting myweb&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
replicationcontroller &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myweb-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; rolling updated to &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myweb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl get pods -&lt;span&gt;o wide
NAME          READY     STATUS    RESTARTS   AGE       IP            NODE
myweb&lt;/span&gt;-mbndc   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          1m        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.3&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;
myweb&lt;/span&gt;-qh38r   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2m        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.2&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt;
nginx&lt;/span&gt;-gt1jd   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          1h        &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;79.2&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;svc设置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# &lt;span&gt;cat&lt;/span&gt; web-&lt;span&gt;svc.yaml 
apiVersion: v1
kind: Service
metadata:
  name: myweb
spec:
  type: NodePort
  ports:
    &lt;/span&gt;- port: &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
      nodePort: &lt;/span&gt;&lt;span&gt;30001&lt;/span&gt;&lt;span&gt;
  selector:
    app: myweb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# kubectl create  -f web-svc.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~&lt;span&gt;]# kubectl get svc
NAME         CLUSTER&lt;/span&gt;-IP     EXTERNAL-&lt;span&gt;IP   PORT(S)          AGE
kubernetes   &lt;/span&gt;&lt;span&gt;10.254&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;     &amp;lt;none&amp;gt;        &lt;span&gt;443&lt;/span&gt;/&lt;span&gt;TCP          6h
myweb        &lt;/span&gt;&lt;span&gt;10.254&lt;/span&gt;.&lt;span&gt;91.34&lt;/span&gt;   &amp;lt;nodes&amp;gt;       &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;30001&lt;/span&gt;/TCP   1m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后取node节点检查30001端口是否启动&lt;/p&gt;
&lt;p&gt;然后浏览器web访问node节点的ip:30001进行测试&lt;/p&gt;
&lt;h3&gt;web界面管理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; dashboard.yaml 
apiVersion: extensions&lt;/span&gt;/&lt;span&gt;v1beta1
kind: Deployment
metadata:
# Keep the name &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;sync&lt;/span&gt;&lt;span&gt; with image version and
# gce&lt;/span&gt;/coreos/kube-manifests/addons/&lt;span&gt;dashboard counterparts
  name: kubernetes&lt;/span&gt;-dashboard-&lt;span&gt;latest
  namespace: kube&lt;/span&gt;-&lt;span&gt;system
spec:
  replicas: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  template:
    metadata:
      labels:
        k8s&lt;/span&gt;-app: kubernetes-&lt;span&gt;dashboard
        version: latest
        kubernetes.io&lt;/span&gt;/cluster-service: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    spec:
      containers:
      &lt;/span&gt;- name: kubernetes-&lt;span&gt;dashboard
        image: index.tenxcloud.com&lt;/span&gt;/google_containers/kubernetes-dashboard-amd64:v1.&lt;span&gt;4.1&lt;/span&gt;&lt;span&gt;
        resources:
          # keep request &lt;/span&gt;= limit to keep this container &lt;span&gt;in&lt;/span&gt;&lt;span&gt; guaranteed class
          limits:
            cpu: 100m
            memory: 50Mi
          requests:
            cpu: 100m
            memory: 50Mi
        ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;9090&lt;/span&gt;&lt;span&gt;
        args:
         &lt;/span&gt;-  --apiserver-host=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.0.0.11:8080&lt;/span&gt;
&lt;span&gt;        livenessProbe:
          httpGet:
            path: &lt;/span&gt;/&lt;span&gt;
            port: &lt;/span&gt;&lt;span&gt;9090&lt;/span&gt;&lt;span&gt;
          initialDelaySeconds: &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
          timeoutSeconds: &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@k8s-master ~]# &lt;span&gt;cat&lt;/span&gt; dashboard-&lt;span&gt;svc.yaml 
apiVersion: v1
kind: Service
metadata:
  name: kubernetes&lt;/span&gt;-&lt;span&gt;dashboard
  namespace: kube&lt;/span&gt;-&lt;span&gt;system
  labels:
    k8s&lt;/span&gt;-app: kubernetes-&lt;span&gt;dashboard
    kubernetes.io&lt;/span&gt;/cluster-service: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
spec:
  selector:
    k8s&lt;/span&gt;-app: kubernetes-&lt;span&gt;dashboard
  ports:
  &lt;/span&gt;- port: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
    targetPort: &lt;/span&gt;&lt;span&gt;9090&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl create -&lt;span&gt;f dashboard.yaml
kubectl create &lt;/span&gt;-f dashboard-svc.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后访问：http://10.0.0.11:8080/ui/&lt;/p&gt;

</description>
<pubDate>Tue, 06 Mar 2018 13:42:00 +0000</pubDate>
<dc:creator>酷酷的二连长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyq863987322/p/8516958.html</dc:identifier>
</item>
<item>
<title>java容器类分析：Collection,List,ArrayList - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/8516922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/8516922.html</guid>
<description>&lt;h2&gt;1、 Iterable 与 Iterator&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Iterable 是个接口，实现此接口使集合对象可以通过迭代器遍历自身元素.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public interface Iterable&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;4.4848484848485&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;修饰符和返回值&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;Iterator&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;iterator&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;返回一个内部元素为T类型的迭代器&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.954954954955&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;default&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;void&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;forEach&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;(Consumer&amp;lt;? super &lt;a title=&quot;type parameter in Iterable&quot; href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html&quot;&gt;T&lt;/a&gt;&amp;gt; action)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;对内部元素进行遍历,并对元素进行指定的操作&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;default&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Spliterator&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;spliterator&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;创建并返回一个可分割迭代器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第一个接口iterator()是jdk1.5引入的，需要子类实现一个内部迭代器Iterator遍历元素。&lt;/p&gt;
&lt;p&gt;后两个接口是JDK1.8后新添加的，forEach(Consumer action)是为了方便遍历操作集合内的元素,spliterator()则提供了一个可以并行遍历元素的迭代器,以适应现在cpu多核时代并行遍历的需求.&lt;/p&gt;
&lt;p&gt;其中我们可以看&lt;span&gt;下&lt;strong&gt;default&lt;/strong&gt;修饰符,&lt;/span&gt;这也是Java 8后新出现的,我们知道,如果我们给一个接口新添加一个方法,那么所有他的具体子类都必须实现此方法,为了能给接口拓展新功能,而又不必每个子类都要实现此方法,Java 8新加了default关键字,被其修饰的方法可以不必由子类实现,并且由dafault修饰的方法在接口中有方法体,这打破了Java之前对接口方法的规范.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Iterator 为迭代器类，用于遍历容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public interface Iterator&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;190&quot;/&gt;&lt;col width=&quot;276&quot;/&gt;&lt;col width=&quot;272&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td class=&quot;xl65&quot; width=&quot;190&quot; height=&quot;20&quot;&gt;&lt;span&gt;修饰符和返回值&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;276&quot;&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;272&quot;&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl66&quot; width=&quot;190&quot; height=&quot;20&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;276&quot;&gt;&lt;span&gt;hasNext()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;272&quot;&gt;&lt;span&gt;判断迭代器所指元素是否为最后一个&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; width=&quot;190&quot; height=&quot;20&quot;&gt;&lt;span&gt;E&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl68&quot; width=&quot;276&quot;&gt;&lt;span&gt;next()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;272&quot;&gt;&lt;span&gt;下一个元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl67&quot; width=&quot;190&quot; height=&quot;20&quot;&gt;&lt;span&gt;default&lt;/span&gt; &lt;span class=&quot;font6&quot;&gt;&lt;span&gt;Void&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;276&quot;&gt;&lt;span&gt;remove()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;272&quot;&gt;&lt;span&gt;移除迭代器只想的当前元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;xl67&quot; width=&quot;190&quot; height=&quot;39&quot;&gt;&lt;span&gt;default&lt;/span&gt; &lt;span class=&quot;font6&quot;&gt;&lt;span&gt;Void&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;276&quot;&gt;&lt;span&gt;forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;272&quot;&gt;&lt;span&gt;遍历迭代器指向元素后面的所有元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;AbstartList中实现了Iterator类作为List内部的迭代器，用于访问内部元素，其代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div id=&quot;cnblogs_code_open_80a25002-fc7a-4e57-a6c3-1f333d5523e2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; private &lt;span&gt;class&lt;/span&gt; Itr implements Iterator&amp;lt;E&amp;gt; {
&lt;span&gt;  2&lt;/span&gt;         &lt;span&gt;/**
&lt;span&gt;  3&lt;/span&gt;          * Index of element to be returned by subsequent call to next.
&lt;span&gt;  4&lt;/span&gt;          */&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;         int cursor = 0;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;/**
&lt;span&gt;  8&lt;/span&gt;          * Index of element returned by most recent call to next or
&lt;span&gt;  9&lt;/span&gt;          * previous.  Reset to -1 if this element is deleted by a call
&lt;span&gt; 10&lt;/span&gt;          * to remove.
&lt;span&gt; 11&lt;/span&gt;          */&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         int lastRet = -1;
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;/**
&lt;span&gt; 15&lt;/span&gt;          * The modCount value that the iterator believes that the backing
&lt;span&gt; 16&lt;/span&gt;          * List should have.  If this expectation is violated, the iterator
&lt;span&gt; 17&lt;/span&gt;          * has detected concurrent modification.
&lt;span&gt; 18&lt;/span&gt;          */&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         int expectedModCount = modCount;
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;         public boolean hasNext() {
&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; cursor != size();
&lt;span&gt; 23&lt;/span&gt;         }
&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;         public E next() {
&lt;span&gt; 26&lt;/span&gt;             checkForComodification();
&lt;span&gt; 27&lt;/span&gt;             try {
&lt;span&gt; 28&lt;/span&gt;                 int i = cursor;
&lt;span&gt; 29&lt;/span&gt;                 E next = get(i);
&lt;span&gt; 30&lt;/span&gt;                 lastRet = i;
&lt;span&gt; 31&lt;/span&gt;                 cursor = i + 1;
&lt;span&gt; 32&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; next;
&lt;span&gt; 33&lt;/span&gt;             } catch (IndexOutOfBoundsException e) {
&lt;span&gt; 34&lt;/span&gt;                 checkForComodification();
&lt;span&gt; 35&lt;/span&gt;                 throw &lt;span&gt;new&lt;/span&gt; NoSuchElementException();
&lt;span&gt; 36&lt;/span&gt;             }
&lt;span&gt; 37&lt;/span&gt;         }
&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;         public void remove() {
&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0)
&lt;span&gt; 41&lt;/span&gt;                 throw &lt;span&gt;new&lt;/span&gt; IllegalStateException();
&lt;span&gt; 42&lt;/span&gt;             checkForComodification();
&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;             try {
&lt;span&gt; 45&lt;/span&gt;                 AbstractList.this.remove(lastRet);
&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; cursor)
&lt;span&gt; 47&lt;/span&gt;                     cursor--;
&lt;span&gt; 48&lt;/span&gt;                 lastRet = -1;
&lt;span&gt; 49&lt;/span&gt;                 expectedModCount = modCount;
&lt;span&gt; 50&lt;/span&gt;             } catch (IndexOutOfBoundsException e) {
&lt;span&gt; 51&lt;/span&gt;                 throw &lt;span&gt;new&lt;/span&gt; ConcurrentModificationException();
&lt;span&gt; 52&lt;/span&gt;             }
&lt;span&gt; 53&lt;/span&gt;         }
&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;         final void checkForComodification() {
&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (modCount != expectedModCount)
&lt;span&gt; 57&lt;/span&gt;                 throw &lt;span&gt;new&lt;/span&gt; ConcurrentModificationException();
&lt;span&gt; 58&lt;/span&gt;         }
&lt;span&gt; 59&lt;/span&gt;     }
&lt;span&gt; 60&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;2、Collection&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Collection 是容器类的接口，里面可以存放很多Elements，很多容器都实现了该接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;130&quot;/&gt;&lt;col width=&quot;302&quot;/&gt;&lt;col width=&quot;398&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr&gt;&lt;td class=&quot;xl65&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;修饰符和返回值&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;302&quot;&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;398&quot;&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl66&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;int&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;size()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;判断容器的大小&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot; width=&quot;302&quot;&gt;&lt;span&gt;isEmpty()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;判空&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;contains(Object o)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;是否包含某元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;Object[]&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;toArray()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;转化为数组&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;58&quot;&gt;&lt;span&gt;&amp;lt;T&amp;gt; T[]&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;toArray(T[] a)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;将容器中所有元素拷贝到a中，如果a不够大，则拷贝到返回的数组中。（见AbstactCollection中实现）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;add(E e)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;添加元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;58&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;remove(Object o)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;移除容器中第一个出现Object对象，如果Object为null，则移除第一个出现的null。如果没有Object对象返回false&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;containsAll(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;包含c中所有元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;addAll(Collection&amp;lt;? extends E&amp;gt; c);&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;将c中所有元素添加到容器中&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;39&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;removeAll(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;如果容器中包含c中的元素，删除。（调用remove(Object)）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;xl70&quot; width=&quot;130&quot; height=&quot;19&quot;&gt;&lt;span&gt;default boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl69&quot; width=&quot;302&quot;&gt;&lt;span&gt;removeIf(Predicate&amp;lt;? super E&amp;gt; filter)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl69&quot; width=&quot;398&quot;&gt;&lt;span&gt;移除所有符合条件的元素（JDK1.8中引入）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;xl72&quot; width=&quot;130&quot; height=&quot;19&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;302&quot;&gt;&lt;span&gt;retainAll(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;398&quot;&gt;&lt;span&gt;保留在c中出现的元素，其它全部移除&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl72&quot; width=&quot;130&quot; height=&quot;19&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;302&quot;&gt;&lt;span&gt;clear()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl73&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl72&quot; width=&quot;130&quot; height=&quot;19&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;302&quot;&gt;&lt;span&gt;equals（Object o）&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;398&quot;&gt;&lt;span&gt;与o中所有元素都相等则相等&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl72&quot; width=&quot;130&quot; height=&quot;19&quot;&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;302&quot;&gt;&lt;span&gt;hashCode（）&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl73&quot;&gt;&lt;span&gt;c1.equals(c2) 那么他们的hashCode()一定相等，反之不成立&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl72&quot; width=&quot;130&quot; height=&quot;38&quot;&gt;&lt;span&gt;default Spliterator&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;302&quot;&gt;&lt;span&gt;spliterator()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;398&quot;&gt;&lt;span&gt;在所有元素之上创建一个Spliterator&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl72&quot; width=&quot;130&quot; height=&quot;38&quot;&gt;&lt;span&gt;default Stream&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;302&quot;&gt;&lt;span&gt;stream()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl73&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl72&quot; width=&quot;130&quot; height=&quot;38&quot;&gt;&lt;span&gt;default Stream&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl71&quot; width=&quot;302&quot;&gt;&lt;span&gt;parallelStream()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl73&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上述很多函数的实现可以参考 AbstactList中的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1594931-293dba23ebc504c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. List&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;List是一个接口，继承了Collection中的所有接口，并且添加了自身相关接口和具体实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出，Collection分成了三个分支，List就是其中一个，下面我们具体分析一下增加的接口。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public interface List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;130&quot;/&gt;&lt;col width=&quot;302&quot;/&gt;&lt;col width=&quot;398&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td class=&quot;xl65&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;修饰符和返回值&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;302&quot;&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;398&quot;&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl66&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;Collection中的所有接口&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;37&quot;&gt;&lt;span&gt;default void&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot; width=&quot;302&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;replaceAll(UnaryOperator&amp;lt;E&amp;gt; operator)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;将运算操作后的结果替换List中原有元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;default void&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;sort(Comparator&amp;lt;? super E&amp;gt; c)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;将List中所有元素排序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;get(int index);&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;set(int index, E element)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;remove(int index)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;int&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;indexOf(Object o)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;o在List中第一次出现的位置&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;int&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;lastIndexOf(Object o)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;o在List中最后一次出现的位置&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;ListIterator&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;listIterator()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;获取List的迭代器&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl68&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;ListIterator&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;listIterator(int index)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;获取从某个位置开始的迭代器，index为迭代器起始位置&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;xl70&quot; width=&quot;130&quot; height=&quot;19&quot;&gt;&lt;span&gt;List&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl69&quot; width=&quot;302&quot;&gt;&lt;span&gt;subList(int fromIndex, int toIndex)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl69&quot; width=&quot;398&quot;&gt;&lt;span&gt;子List&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上表可以看出，增加了 和index相关的接口，根据index对List进行的get、set、remove等操作。另一类添加的接口是ListIteator相关的，获取List的迭代器。&lt;/p&gt;
&lt;h3&gt;3.1 ListIterator&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;public interface ListIterator&amp;lt;E&amp;gt; extends Iterator&amp;lt;E&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ListIterator 不光包含Iterator中的三个接口还增加了作为一个List迭代器应该有的接口，如 next(),previous()等&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;130&quot;/&gt;&lt;col width=&quot;302&quot;/&gt;&lt;col width=&quot;398&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td class=&quot;xl65&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;修饰符和返回值&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;302&quot;&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot; width=&quot;398&quot;&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl66&quot; width=&quot;130&quot; height=&quot;20&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;302&quot;&gt;&lt;span&gt;Iterator中的所有接口&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot; width=&quot;398&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;hasNext()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;E&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;next()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;hasPrevious()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;E&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;previous()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;int&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;nextIndex()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;int&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;previousIndex()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;remove()&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;删除next()返回元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;set(E e)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;替换next()返回的元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;xl67&quot; height=&quot;19&quot;&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;add(E e)&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl67&quot;&gt;&lt;span&gt;在nextIndex()后插入元素&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;首先需要明确ListIterator迭代器的作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;允许我们向前、向后两个方向遍历 List;&lt;/li&gt;
&lt;li&gt;在遍历时修改 List 的元素；&lt;/li&gt;
&lt;li&gt;遍历时获取迭代器当前游标所在位置。&lt;/li&gt;
&lt;/ol&gt;&lt;h5&gt;&lt;span&gt;注意，迭代器 没有当前所在元素一说，它只有一个游标( cursor )的概念，这个游标总是在元素之间，比如这样:&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;迭代器的初始位置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161007210652687&quot; alt=&quot;这里写图片描述&quot; width=&quot;640&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用next()后迭代器的位置&lt;/strong&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161007210926863&quot; alt=&quot;这里写图片描述&quot; width=&quot;640&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用 previous() 游标就会回到之前位置。当向后遍历完元素，游标就会在元素 N 的后面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161007211112819&quot; alt=&quot;这里写图片描述&quot; width=&quot;640&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说长度为 N 的集合会有 N+1 个游标的位置。&lt;/p&gt;
&lt;h3&gt;3.2 AbstractCollection / AbstractList&lt;/h3&gt;
&lt;p&gt;        在上面的继承关系图中并没有显示出AbstractCollect和AbstractList的存在，但是在阅读源码的时候经常遇到这两个类，下面讲一下这两个类的作用。&lt;/p&gt;
&lt;p&gt;      首先需要明确的一点是&lt;span&gt;AbstractCollect和AbstractList都是抽象类而不是接口&lt;/span&gt;，它&lt;span&gt;们分别实现了Collection和List接口中的部分函数&lt;/span&gt;。这样继承者直接继承AbstractXXXX 而不需要自己重复实现里面的所有接口。这两个抽象类抽离了公共部分，进行了实现，减少后续类的工作量。&lt;/p&gt;
&lt;p&gt;       ArrayList 和LinkedList都直接或者间接继承了AbstartList类。下图为这两个类的继承关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161016140433033&quot; alt=&quot;这里写图片描述&quot; width=&quot;531&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        具体这两个类里面实现了哪些接口，请自己阅读源码不再讲解。&lt;/p&gt;
&lt;h3&gt;3.3 ArrayList&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;public class ArrayList&amp;lt;E&amp;gt; extends &lt;strong&gt;AbstractList&amp;lt;E&amp;gt;&lt;/strong&gt;&lt;br/&gt;implements &lt;strong&gt;List&amp;lt;E&amp;gt;,&lt;/strong&gt; RandomAccess, Cloneable, java.io.Serializable&lt;/span&gt;&lt;span&gt;我们看到ArrayList的定义的时候很可能会出现一个疑问，为什么它已经继承了AbstractList了还需要去实现List&amp;lt;E&amp;gt;接口？ 答案是，后面的List&amp;lt;E&amp;gt;可以去掉，这里只是让阅读者明白ArrayList是个List。&lt;/span&gt; &lt;span&gt;&lt;span&gt;终于好不容易到了开发者常用的类了，有点窃喜：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;transient Object[] elementData;&lt;/span&gt;&lt;span&gt;这个很重要的成员变量elementData数组用来存放ArrayList中的元素，当第一个元素添加进来后，它的默认长度变为10。&lt;/span&gt;&lt;span&gt;（java中“transient”关键字修饰的成员变量在类序列化的过程中不会被持久化到文件中，保证该成员变量保存信息的安全。）&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;ArrayList的构造函数中可以直接指定elementData数组的长度，那么问题来了，当数组已经完全被占用再向ArrayList中添加元素时，&lt;span&gt;如何再分配更大长度的数组？如何把旧数据拷贝到新数组中？答案见下面这段源码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; private void grow(int minCapacity) {  //最少需要的容量 
&lt;span&gt;  2&lt;/span&gt;         // overflow-conscious &lt;span&gt;code&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt;         int oldCapacity = elementData.length;
&lt;span&gt;  4&lt;/span&gt;         int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);   // 分配最小容量的 1.5倍
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; 0)       
&lt;span&gt;  6&lt;/span&gt;             newCapacity = minCapacity;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
&lt;span&gt;  8&lt;/span&gt;             newCapacity = hugeCapacity(minCapacity);   // 最大容量比较（Inter.MAX_VALUE）
&lt;span&gt;  9&lt;/span&gt;         // minCapacity is usually &lt;span&gt;close&lt;/span&gt; to size, so this is a win:
&lt;span&gt; 10&lt;/span&gt;         elementData = Arrays.copyOf(elementData, newCapacity);  // 将旧数据拷贝到新数组中
&lt;span&gt; 11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其它接口不再细说。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;&lt;a title=&quot;https://www.cnblogs.com/bushi/p/6647006.html&quot; href=&quot;https://www.cnblogs.com/bushi/p/6647006.html&quot;&gt;https://www.cnblogs.com/bushi/p/6647006.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/047e33fdefd2&quot; href=&quot;https://www.jianshu.com/p/047e33fdefd2&quot;&gt;https://www.jianshu.com/p/047e33fdefd2&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Mar 2018 13:37:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/8516922.html</dc:identifier>
</item>
<item>
<title>redis 突然大量逐出导致读写请求block - 大CC</title>
<link>http://www.cnblogs.com/me115/p/8516838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/me115/p/8516838.html</guid>
<description>&lt;h2 id=&quot;现象&quot;&gt;现象&lt;/h2&gt;
&lt;p&gt;redis作为缓存场景使用，内存耗尽时，突然出现大量的逐出，在这个逐出的过程中阻塞正常的读写请求，导致 redis 短时间不可用；&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;redis 中的LRU是如何实现的？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当mem_used内存已经超过maxmemory的设定，对于所有的读写请求，都会触发redis.c/freeMemoryIfNeeded(void)函数以清理超出的内存。&lt;/li&gt;
&lt;li&gt;这个清理过程是阻塞的，直到清理出足够的内存空间。&lt;/li&gt;
&lt;li&gt;这里的LRU或TTL策略并不是针对redis的所有key，而是以配置文件中的maxmemory-samples个key作为样本池进行抽样清理。&lt;br/&gt;maxmemory-samples在redis-3.0.0中的默认配置为5，如果增加，会提高LRU或TTL的精准度，redis作者测试的结果是当这个配置为10时已经非常接近全量LRU的精准度.&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;逐出qps突增非常大的原因：一次需要逐出释放太多的空间会导致阻塞；具体的原因是 mem_tofree 的计算逻辑有问题；&lt;br/&gt;mem_tofree 统计的是：实际已分配的内存总量 - AOF 缓冲区相关的内存；&lt;br/&gt;如果这时候有rehash，会临时分配一个桶来做rehash，这部分内存未排除，所以在rehash阶段，算出来的mem_tofree 就会很大，造成一个时刻需要逐出大量的key，逐出的loop是阻塞的，这个阶段会block redis的请求；&lt;/p&gt;
&lt;p&gt;逐出qps的计算：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;freeMemoryIfNeeded(...)
    &lt;span class=&quot;co&quot;&gt;// 计算出 Redis 目前占用的内存总数，但有两个方面的内存不会计算在内：&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 1）从服务器的输出缓冲区的内存&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 2）AOF 缓冲区的内存&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 3）AOF 重写缓冲区中的内存&lt;/span&gt;
    mem_used = zmalloc_used_memory();
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (slaves) {
        listIter li;
        listNode *ln;

        listRewind(server.slaves,&amp;amp;li);
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {
            redisClient *slave = listNodeValue(ln);
            &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; obuf_bytes = getClientOutputBufferMemoryUsage(slave);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (obuf_bytes &amp;gt; mem_used)
                mem_used = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                mem_used -= obuf_bytes;
        }
    }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (server.aof_state != REDIS_AOF_OFF) {
        mem_used -= sdslen(server.aof_buf);
        mem_used -= aofRewriteBufferSize();
    }
    &lt;span class=&quot;co&quot;&gt;// 计算需要释放多少字节的内存&lt;/span&gt;
    mem_tofree = mem_used - server.maxmemory;
    propagateExpire(db,keyobj);
    &lt;span class=&quot;co&quot;&gt;// 计算删除键所释放的内存数量&lt;/span&gt;
    delta = (&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;) zmalloc_used_memory();
    dbDelete(db,keyobj);
    delta -= (&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;) zmalloc_used_memory();
    mem_freed += delta;
    &lt;span class=&quot;co&quot;&gt;// 对淘汰键的计数器增一&lt;/span&gt;
    server.stat_evictedkeys++;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;github上 @Rosanta 给出的解决方案：释放内存的循环逻辑中最多执行一定次数，达到阈值了就不再逐出，到下个请求来时再释放一点空间；这个方案的好处是不会 block 整个进程，正常的业务读写请求无影响；潜在问题是可能单次写入的数据比释放的空间还大，导致总的内存是一直上升，而不是下降；&lt;/p&gt;
&lt;p&gt;@antirez 给的方案：同样是迭代删除，但会加个标志，保证在迭代删除的逻辑下内存是逐渐下降的，而如果是上升的，还是会block住正常的请求（要控制主总的内存大小）；&lt;br/&gt;详见：&lt;br/&gt;&lt;a href=&quot;https://github.com/antirez/redis/pull/4583&quot; class=&quot;uri&quot;&gt;https://github.com/antirez/redis/pull/4583&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;ref&lt;/h2&gt;
&lt;p&gt;关于 redis 4.0的逐出算法优化&lt;br/&gt;&lt;a href=&quot;http://antirez.com/news/109&quot; class=&quot;uri&quot;&gt;http://antirez.com/news/109&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Mar 2018 13:19:00 +0000</pubDate>
<dc:creator>大CC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/me115/p/8516838.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——35. 使用实例属性替代序数 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8516727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8516727.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;许多枚举通常与单个int值关联。所有枚举都有一个&lt;code&gt;ordinal&lt;/code&gt;方法，它返回每个枚举常量类型的数值位置。你可能想从序数中派生一个关联的int值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Abuse of ordinal to derive an associated value - DON'T DO THIS

public enum Ensemble {

    SOLO,   DUET,   TRIO, QUARTET, QUINTET,

    SEXTET, SEPTET, OCTET, NONET,  DECTET;



    public int numberOfMusicians() { return ordinal() + 1; }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个枚举能正常工作，但对于维护来说则是一场噩梦。如果常量被重新排序，&lt;code&gt;numberOfMusicians&lt;/code&gt;方法将会中断。 如果你想添加一个与你已经使用的int值相关的第二个枚举常量，则没有那么好运了。 例如，为双四重奏（double quartet）添加一个常量可能会很好，它就像八重奏一样，由8位演奏家组成，但是没有办法做到这一点。&lt;/p&gt;
&lt;p&gt;此外，如果没有给所有这些int值添加常量，也不能为某个int值添加一个常量。例如，假设你想要添加一个常量，表示一个由12位演奏家组成的三重四重奏（triple quartet）。对于由11个演奏家组成的合奏曲，并没有标准的术语，因此你不得不为未使用的int值（11）添加一个虚拟常量（dummy constant）。最多看起来就是有些不好看。如果许多int值是未使用的，则是不切实际的。&lt;/p&gt;
&lt;p&gt;幸运的是，这些问题有一个简单的解决方案。 &lt;strong&gt;永远不要从枚举的序号中得出与它相关的值; 请将其保存在实例属性中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum Ensemble {

    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),

    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),

    NONET(9), DECTET(10), TRIPLE_QUARTET(12);



    private final int numberOfMusicians;

    Ensemble(int size) { this.numberOfMusicians = size; }

    public int numberOfMusicians() { return numberOfMusicians; }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;枚举规范对此&lt;code&gt;ordinal&lt;/code&gt;方法说道：“大多数程序员对这种方法没有用处。 它被设计用于基于枚举的通用数据结构，如&lt;code&gt;EnumSet&lt;/code&gt;和&lt;code&gt;EnumMap&lt;/code&gt;。“除非你在编写这样数据结构的代码，否则最好避免使用&lt;code&gt;ordinal&lt;/code&gt;方法。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Mar 2018 12:59:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8516727.html</dc:identifier>
</item>
</channel>
</rss>