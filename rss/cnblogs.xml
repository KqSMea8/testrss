<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>剥掉层层外衣后的RPC是什么样子的? - 农码人生</title>
<link>http://www.cnblogs.com/mycodingworld/p/barerpc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mycodingworld/p/barerpc.html</guid>
<description>&lt;p&gt;RPC,全称为Remote Procedure Call（远程过程调用）。通俗一点讲就是在本地调用远程服务器上的功能。实现远程调用至少需要满足以下几个条件：&lt;/p&gt;
&lt;p&gt;1.网络通信&lt;/p&gt;
&lt;p&gt;2.序列化与反序列化&lt;/p&gt;
&lt;p&gt;3.反射&lt;/p&gt;
&lt;p&gt;远程通信是远程调用的前题，只有经过序列化后的数据才能在网络上传输，传输到服务器端后需要反序列化成对象，然后通过反射机制调用服务器上客户端指定的服务，再将结果返回给客户端，用一张图表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352870/201804/1352870-20180422151101951-1059696437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;服务器每收到一次客户端的请求，就启动一个线程处理，调用具体的服务对象相应的方法，并将返回结果返回给客户端。&lt;/p&gt;
&lt;p&gt;基于此原理，下面写一个示例实现RPC功能：&lt;/p&gt;
&lt;p&gt;项目结构图如下：分别有客户端、服务器、服务以及请求与响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352870/201804/1352870-20180422151537998-653300863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;首先抽象出请求类与响应类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 请求类：属性有请求的类名、方法名、输入参数类型、输入数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.yang.common;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Request &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String className;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String methodName;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法名&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; Class[] inType;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入参数类型&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Object[] inData;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入数据&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getClassName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; className;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setClassName(String className) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.className =&lt;span&gt; className;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMethodName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMethodName(String methodName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methodName =&lt;span&gt; methodName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Class[] getInType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setInType(Class[] inType) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inType =&lt;span&gt; inType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object[] getInData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inData;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setInData(Object[] inData) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inData =&lt;span&gt; inData;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;响应类：属性有返回对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.yang.common;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Response &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Object obj;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回对象&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getObj() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setObj(Object obj) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.obj =&lt;span&gt; obj;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;服务器类以及服务处理类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;服务器类负责接收客户端的请求，并将请求分配给服务处理类进行处理。&lt;/p&gt;
&lt;p&gt;服务器类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.yang.server;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.yang.server.handler.ServerHandler;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetSocketAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ServerSocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器类，负责接收任务，分配任务&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Server {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ServerSocket socket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerSocket();
            socket.bind(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InetSocketAddress(1234&lt;span&gt;));
            BufferedReader in;
            Socket accept;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                accept &lt;/span&gt;=&lt;span&gt; socket.accept();
                System.out.println(&lt;/span&gt;&quot;accept a request from&quot;+&lt;span&gt;accept.getRemoteSocketAddress());
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerHandler(accept)).start();
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e){
            e.printStackTrace();
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务处理类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.yang.server.handler;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.yang.common.Request;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.yang.common.Response;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationTargetException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务处理类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServerHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Socket socket;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ObjectInputStream in;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ObjectOutputStream out;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServerHandler(Socket socket){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.socket=&lt;span&gt;socket;
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(socket.getInputStream());
            Request request &lt;/span&gt;=&lt;span&gt; (Request)in.readObject();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类名&lt;/span&gt;
            String className=&lt;span&gt;request.getClassName();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法名&lt;/span&gt;
            String methodNmae=&lt;span&gt;request.getMethodName();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数类型&lt;/span&gt;
            Class[] inType=&lt;span&gt;request.getInType();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数值&lt;/span&gt;
            Object[] inDate=&lt;span&gt;request.getInData();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据类名导入类的字节码&lt;/span&gt;
            Class cls=&lt;span&gt;Class.forName(className);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据方法名得到方法&lt;/span&gt;
            Method method =&lt;span&gt; cls.getMethod(methodNmae, inType);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建类对象&lt;/span&gt;
            Object obj =&lt;span&gt; cls.newInstance();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法得到结果&lt;/span&gt;
            Object result =&lt;span&gt; method.invoke(obj, inDate);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到socket输出流&lt;/span&gt;
            out=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(socket.getOutputStream());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造Response对象并输出&lt;/span&gt;
            Response response=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response();
            response.setObj(result);
            out.writeObject(response);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (InstantiationException |&lt;span&gt; InvocationTargetException
                &lt;/span&gt;| IllegalAccessException | NoSuchMethodException |&lt;span&gt;
                ClassNotFoundException &lt;/span&gt;|&lt;span&gt; IOException e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(in!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    in.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    in&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(out!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    out.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e2) {
                    e2.printStackTrace();
                }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    out&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    socket.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    socket&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.yang.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hello{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sayHello服务方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHello(String name){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello:&quot;+&lt;span&gt;name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;list服务方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; list(){
        List&lt;/span&gt;&amp;lt;String&amp;gt; list= Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;最后是客户端类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.yang.client;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.yang.common.Request;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.yang.common.Response;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ObjectInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ObjectOutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetSocketAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
        Socket socket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket();
        ObjectOutputStream objectOutputStream&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ObjectInputStream objectInputStream&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            socket.connect(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InetSocketAddress(1234&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装请求类&lt;/span&gt;
            Request request=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Request();
            request.setClassName(&lt;/span&gt;&quot;cn.yang.service.Hello&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全类名&lt;/span&gt;
            request.setMethodName(&quot;sayHello&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;
            request.setInType(&lt;span&gt;new&lt;/span&gt; Class[]{String.&lt;span&gt;class&lt;/span&gt;});&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数类型&lt;/span&gt;
            request.setInData(&lt;span&gt;new&lt;/span&gt; Object[]{&quot;LiMing&quot;});&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数值&lt;/span&gt;

            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Request request=new Request();
            request.setClassName(&quot;cn.yang.service.Hello&quot;);
            request.setMethodName(&quot;list&quot;);
            request.setInType(new Class[]{});
            request.setInData(new Object[]{});&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开socket输出流&lt;/span&gt;
            objectOutputStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(socket.getOutputStream());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入Request对象&lt;/span&gt;
&lt;span&gt;            objectOutputStream.writeObject(request);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开socket输入流&lt;/span&gt;
            objectInputStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(socket.getInputStream());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取Response对象&lt;/span&gt;
            Response response=&lt;span&gt;(Response)objectInputStream.readObject();
            Object obj &lt;/span&gt;=&lt;span&gt; response.getObj();
            System.out.println(&lt;/span&gt;&quot;result:&quot;+&lt;span&gt;obj);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IOException |&lt;span&gt; ClassNotFoundException e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(objectOutputStream!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    objectOutputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(objectInputStream!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    objectInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    socket.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行Server,然后再运行Client，得到结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352870/201804/1352870-20180422141319346-161743485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结：RPC实际上是在网络通信基础之上，运用反射技术达到远程功能调用的目的。Request和Response类必须是可序列化类，以便在网络上传输，并且客户端和服务器都必须有这两个类。这个示例只是以最简单的方式说明RPC本质是什么。&lt;/p&gt;
&lt;p&gt;现在有许多RPC框架，如Thrift,Hessian,JsonRPC,Dubbo,rPcx,gRPC等，他们就是在此基础之上进行再封装，优化，使用户更简便的使用，达到调用远程功能，就如同调用本地功能一样方便。&lt;/p&gt;
&lt;p&gt;上面所说的网络通信、序列化与反序例化以及反射的实现各个框架都有所不同。&lt;/p&gt;
&lt;p&gt;网络通信有的选择TCP，有的选择HTTP。&lt;code&gt;TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快&lt;/code&gt;，因此，在一般情况下，TCP 一定比 HTTP 快。&lt;/p&gt;
&lt;p&gt;就序列化而言，&lt;code&gt;Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈&lt;/code&gt;，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。&lt;/p&gt;
&lt;p&gt;反射技术有Java自带的反射技术，Objenesis以及CGLIB。&lt;/p&gt;
&lt;p&gt;实际应用中，服务不会直接是一个具体的类，而是一个接口，也称为协议，即客户端和服务端达成的一种共识。客户端请求时，传输接口名字，服务端通过接口名字找到接口的实现类，然后创建对象，并执行方法返回结果或者客户端通过服务注册中心找到服务实现类名，传送给服务器，这涉及到服务注册与发现，不同的框架实现的方式也有所不同，甚至一些框架还有流量监控与控制，服务故障转换，负载均衡等。&lt;/p&gt;
&lt;p&gt;这一篇文章只是执砖引玉，希望大家在了解RPC基础原理之后，走上更高的台阶！&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.importnew.com/20327.html&quot; target=&quot;_blank&quot;&gt;轻量级分布式 RPC 框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ityouknow/archive/2017/11/20/7864800.html&quot; target=&quot;_blank&quot;&gt;阿里Dubbo疯狂更新，关Spring Cloud什么事&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 07:23:00 +0000</pubDate>
<dc:creator>农码人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mycodingworld/p/barerpc.html</dc:identifier>
</item>
<item>
<title>.Net Core小技巧 - 使用Swagger上传文件 - 编程玩家</title>
<link>http://www.cnblogs.com/Erik_Xu/p/8904854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erik_Xu/p/8904854.html</guid>
<description>&lt;p&gt; 　　随着前后端分离开发模式的普及，后端人员更多是编写服务端API接口。调用接口实现文件上传是一个常见的功能，同时也需要一个选择文件上传的界面，可以编写前端界面上传，可以使用Postman、curl来模拟上传请求。上述的方式多多少少有点麻烦。Swagger作为Api说明文档及调试工具，如果它能提供文件上传的界面（默认不提供），那会更加方便文件上传提示，本文将介绍如何使用Swagger来上传文件。&lt;/p&gt;


&lt;p&gt;1. 安装Swagger&lt;/p&gt;
&lt;p&gt;Install-Package Swashbuckle.AspNetCore&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422010732781-1335032132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 配置Swagger中间件&lt;/p&gt;
&lt;p&gt;在Startup.ConfigureServices中添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.AddSwaggerGen(c =&amp;gt;&lt;span&gt;
{
    c.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422010932503-1110188907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Startup.Configure中添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.UseSwagger();

app.UseSwaggerUI(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    c.SwaggerEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API V1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422011129546-1608828647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3. 编写API&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST api/values&lt;/span&gt;
&lt;span&gt;[HttpPost]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Post(IFormFile file)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:Save file...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PUT api/values/5&lt;/span&gt;
[HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Put(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, IFormFile file)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:Save file...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. 编写SwaggerFileUploadFilter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SwaggerFileUploadFilter : IOperationFilter
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Apply(Operation operation, OperationFilterContext context)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!context.ApiDescription.HttpMethod.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, StringComparison.OrdinalIgnoreCase) &amp;amp;&amp;amp;
            !context.ApiDescription.HttpMethod.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StringComparison.OrdinalIgnoreCase))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileParameters = context.ApiDescription.ActionDescriptor.Parameters.Where(n =&amp;gt; n.ParameterType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IFormFile)).ToList();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fileParameters.Count &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        operation.Consumes.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/form-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fileParameter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fileParameters)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parameter = operation.Parameters.Single(n =&amp;gt; n.Name ==&lt;span&gt; fileParameter.Name);
            operation.Parameters.Remove(parameter);
            operation.Parameters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonBodyParameter
            {
                Name &lt;/span&gt;=&lt;span&gt; parameter.Name,
                In &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;formData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Description &lt;/span&gt;=&lt;span&gt; parameter.Description,
                Required &lt;/span&gt;=&lt;span&gt; parameter.Required,
                Type &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5. 注册SwaggerFileUploadFilter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
c.OperationFilter&amp;lt;SwaggerFileUploadFilter&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422012214006-613261187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6. 查看结果&lt;/p&gt;
&lt;p&gt;POST方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422012613100-1910085218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422012750468-70646343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;PUT方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422012830086-1171348533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201804/182190-20180422012908323-1170536687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　使用Swagger的文件上传的关键在于SwaggerFileUploadFilter，它继承于Swashbuckle的IOperationFilter，也即它只作用于Swagger，不会对其它模块造成影响。&lt;/p&gt;
&lt;p&gt;　　我们再来看一下SwaggerFileUploadFilter里面的Apply方法的逻辑：&lt;/p&gt;
&lt;p&gt;　　1. 判断请求的方法是否为POST或者PUT，如果是其它请求方法，基本不可能是文件上传操作。&lt;/p&gt;
&lt;p&gt;　　2. 查找方法中类型为IFormFile的参数。&lt;/p&gt;
&lt;p&gt;　　3. 设置Consumes为“multipart/form-data”。&lt;/p&gt;
&lt;p&gt;　　4. 替换IFormFile类型参数描述中的In为formData、Type为File。&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/ErikXu/.NetCoreTips/tree/master/SwaggerFileUpload&quot; target=&quot;_blank&quot;&gt;https://github.com/ErikXu/.NetCoreTips/tree/master/SwaggerFileUpload&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;http://www.talkingdotnet.com/how-to-upload-file-via-swagger-in-asp-net-core-web-api/&quot; target=&quot;_blank&quot;&gt;http://www.talkingdotnet.com/how-to-upload-file-via-swagger-in-asp-net-core-web-api/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Apr 2018 07:06:00 +0000</pubDate>
<dc:creator>编程玩家</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Erik_Xu/p/8904854.html</dc:identifier>
</item>
<item>
<title>再深刻理解下web3.js中estimateGas如何计算智能合约消耗的gas量 - 以太坊开发</title>
<link>http://www.cnblogs.com/helloworld2018/p/8907289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworld2018/p/8907289.html</guid>
<description>&lt;p&gt;我们可使用web3.js框架的estimateGas函数获得一个以太坊智能合约的Gas估计值 ，通过执行一个消息调用或交易，该消息调用或交易直接在节点的VM中执行，并未在区块链中确认，函数会返回估算使用的gas量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数调用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
web3.eth.estimateGas(callObject [, callback])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 web3.eth.sendTransaction 中, 参数大都是可选的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1. Object&lt;/code&gt; - 要发送的交易对象:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;from&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; - 用来传送的账户地址. 默认使用web3.eth.defaultAccount属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;to&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; - (可选) 目标地址,对于创建合同的交易没有定义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;: &lt;code&gt;Number|String|BigNumber&lt;/code&gt; - (可选) 为交易转移的价值以Wei为单位，如果是合同创建交易，也是基金。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gas&lt;/code&gt;: &lt;code&gt;Number|String|BigNumber&lt;/code&gt; - (可选, 默认: 待定) 用于交易的gas量（未使用的gas已退还）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gasPrice&lt;/code&gt;: &lt;code&gt;Number|String|BigNumber&lt;/code&gt; - (可选, 默认: 待定) 此交易的gas价格以wei为单位，默认为平均网络gas价格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; - (可选) Either 包含消息关联数据的字节字符串，或者创建合同事务的初始化代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nonce&lt;/code&gt;: &lt;code&gt;Number&lt;/code&gt; - (可选)一个随机数的整数。 这允许覆盖使用相同随机数的您自己的未决事务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;2.Function&lt;/code&gt; - (optional)如果传递回调，则HTTP请求将变为异步。详细说明在这里 &lt;a href=&quot;https://github.com/ethereum/wiki/wiki/JavaScript-API#using-callbacks&quot;&gt;this note&lt;/a&gt; .&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;返回值： &lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;数字：模拟呼叫/交易的需要使用的gas值。&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;一个简单示例：&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;29&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; web3.eth.estimateGas({
    to: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0xc4abd0339eb8d57087278718986382264244252f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
    data: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0xc6888fa10000000000000000000000000000000000000000000000000000000000000003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
});
console.log(result); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;0x0000000000000000000000000000000000000000000000000000000000000015&quot;&lt;/span&gt;
 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用web3js库中可能遇到estimateGas方法出错的问题。大多数情况下得到的错误是这个：“所需的gas超过允许值或总是交易失败”。&lt;/p&gt;
&lt;p&gt;首先要检查的下交易是否有效。例如，如果正在估计将一定数量的通证发送到另一个地址的gasAmount，那么最主要的检查两件事：&lt;/p&gt;
&lt;p&gt;1. 发送地址中是否有足够的以太。&lt;br/&gt;2. 发送地址中是否有足够的通证/代币。&lt;br/&gt;这些似乎是显而易见要检查的，但是还是可能会犯这种低级错误，认为方法估计Gas只是用来计算估计值，其实不是。如果参数设置的实际条件不对，它在运行这个方法时&lt;strong&gt;不会真正执行任何代码&lt;/strong&gt;就直接抛出错误。&lt;/p&gt;
&lt;p&gt;评估发送通证的所需gas量的代码片段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tokenContract.methods.transfer（recipientAddress，numtokens）
 .estimateGas（{&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;：tokenHolderAddress}，function（gasAmount）{
 console.log（gasAmount）;
 }）;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;官网在这里https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethestimategas.&lt;/p&gt;
&lt;p&gt;也可以在你的浏览器地址栏输入https://ethereum.github.io/browser-solidity，然后直接copy你的合约就可以获得估计值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/845255/201804/845255-20180422145754559-1993064765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个代码中默认的一个示例是提案投票的代码如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
pragma solidity ^&lt;span&gt;0.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
contract Ballot {

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Voter {
        &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; weight;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; voted;
        uint8 vote;
        address &lt;/span&gt;&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Proposal {
        &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; voteCount;
    }

    address chairperson;
    mapping(address &lt;/span&gt;=&amp;gt;&lt;span&gt; Voter) voters;
    Proposal[] proposals;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; Create a new ballot with $(_numProposals) different proposals. //为不同的提案创建一个新的投票合约&lt;/span&gt;
    function Ballot(uint8 _numProposals) &lt;span&gt;public&lt;/span&gt;&lt;span&gt; {
        chairperson &lt;/span&gt;=&lt;span&gt; msg.sender;
        voters[chairperson].weight &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        proposals.length &lt;/span&gt;=&lt;span&gt; _numProposals;
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; Give $(toVoter) the right to vote on this ballot.//授予投票权
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; May only be called by $(chairperson). //只能被主席调用&lt;/span&gt;
    function giveRightToVote(address toVoter) &lt;span&gt;public&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg.sender != chairperson || voters[toVoter].voted) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        voters[toVoter].weight &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; Delegate your vote to the voter $(to).//委托你的投票权&lt;/span&gt;
    function &lt;span&gt;delegate&lt;/span&gt;(address to) &lt;span&gt;public&lt;/span&gt;&lt;span&gt; {
        Voter storage sender &lt;/span&gt;= voters[msg.sender]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assigns reference  指定参数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (sender.voted) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (voters[to].&lt;span&gt;delegate&lt;/span&gt; != address(&lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; voters[to].&lt;span&gt;delegate&lt;/span&gt; !=&lt;span&gt; msg.sender)
            to &lt;/span&gt;= voters[to].&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (to == msg.sender) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        sender.voted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        sender.&lt;/span&gt;&lt;span&gt;delegate&lt;/span&gt; =&lt;span&gt; to;
        Voter storage delegateTo &lt;/span&gt;=&lt;span&gt; voters[to];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegateTo.voted)
            proposals[delegateTo.vote].voteCount &lt;/span&gt;+=&lt;span&gt; sender.weight;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            delegateTo.weight &lt;/span&gt;+=&lt;span&gt; sender.weight;
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; Give a single vote to proposal $(toProposal). //对某个提案投一票&lt;/span&gt;
    function vote(uint8 toProposal) &lt;span&gt;public&lt;/span&gt;&lt;span&gt; {
        Voter storage sender &lt;/span&gt;=&lt;span&gt; voters[msg.sender];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sender.voted || toProposal &amp;gt;= proposals.length) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        sender.voted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        sender.vote &lt;/span&gt;=&lt;span&gt; toProposal;
        proposals[toProposal].voteCount &lt;/span&gt;+=&lt;span&gt; sender.weight;
    }

    function winningProposal() &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (uint8 prop = &lt;span&gt;0&lt;/span&gt;; prop &amp;lt; proposals.length; prop++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proposals[prop].voteCount &amp;gt;&lt;span&gt; winningVoteCount) {
                winningVoteCount &lt;/span&gt;=&lt;span&gt; proposals[prop].voteCount;
                _winningProposal &lt;/span&gt;=&lt;span&gt; prop;
            }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以run下试试。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 07:03:00 +0000</pubDate>
<dc:creator>以太坊开发</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloworld2018/p/8907289.html</dc:identifier>
</item>
<item>
<title>项目微管理16 - 三体 - 沙场秋点兵</title>
<link>http://www.cnblogs.com/dxy1982/p/8906724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxy1982/p/8906724.html</guid>
<description>&lt;p&gt;自从路飞到来以后，PC团队终于有了“三”个人。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三的意义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;“三”是非常奇特的一个数字，在古诗中，四代常常可以看到这样的句子：“飞流直下三千尺，疑是银河落九天”；“东风染尽三千顷，白鹭飞来无处停”；“烽火连三日，家书抵万金”；“三人行必有我师”。这些名句共同的特点是带有“三”。&lt;/p&gt;

&lt;p&gt;四代知道，这里的“三”不是一个具体的数，而是表示“多数“的意思。那么，“三”为什么能代表多数呢？这要追溯到那个叫“老子”的人。“子”在古代，是对人尊敬的称呼，一般用于圣人级别，那可不是开玩笑的！&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422134331864-1700770884.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;在二千二百多年前的春秋末期，有一个伟大的思想家，他叫“李耳”，字“伯阳”，人们也叫他“老聃”，后人尊称他为“老子”。他是道家的创始人，用“道”来说明“宇宙万物的本质、构成、变化和本原。”他说：“一生二、二生三、三生万物。”“三”就是指“天、地、人”，它的含义当然非常广大。“三”又“生万物”，所以，“三”泛指“多数”“多次”。&lt;/p&gt;

&lt;p&gt;四代认为：“三人成行”，也就是“三个人就形成了最小的团队”。从“一”到“二”是量的变化，而从“二”到“三”代表着质的变化。既然现在PC团队已经是三个人了，那就是一个完整的团队了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;红细胞诞生&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;既然是一个完整的团队了，那么最好有一个响亮的名字和一个共同交流的地方。&lt;/p&gt;

&lt;p&gt;为此，四代在QQ中建了一个讨论组，然后把鼬和路飞加入了进来，然后就是准备给它起了个名字。&lt;/p&gt;

&lt;p&gt;在征求了大家的意见，没有什么霸气侧漏的名字后，四代给它起名叫：“红细胞”，取“单个微小，但是非常重要”的含义。对于哺乳动物来说，红细胞负责给身体各个部分传输氧气，并运出组织的代谢物，你说重要吗？&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422135023890-1768212524.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;这个同时也是“我是特种兵2”中“红细胞特别行动组”的缩写。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422135035727-1895059473.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;四代期望“红细胞”中的每个人都能独当一面，不可或缺，像红细胞一样重要，无可替代。&lt;/p&gt;

&lt;p&gt;记得在一次正式的场合，一位兄弟跟四代推荐了他认为的最优秀的团队：“NBA中乔丹时期的火箭队，并且一再表示如果团队建设成这样就好了。”之所以有这个话题，是因为四代此前提到过四代认为“最高效的团队”是军队的，这个观点应该是引起了那位兄弟的思考，并得到了他认为的结论。&lt;/p&gt;

&lt;p&gt;其实到了这个年纪，四代早过了“与人争论什么是最优团队”的阶段。对于现在的四代来说，任何别人给他推荐“最优、最好、最赚、没有缺点”这种“最极品”的东西，四代一律会把它们归到“幼稚”一类。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422135250642-596975082.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;在四代心里，现在只有“最合适的”这个概念；任何经验，不管来自何方，只要适合四代的团队现状，四代就会拿过来尝试，能用就实行，四代可不讲究什么模仿“最优团队”。&lt;/p&gt;

&lt;p&gt;而且在四代心里，火箭队根本称不上什么优秀的团队，充其量优秀的只不过是那三人组合而已，离开那三人以后，火箭队立即一蹶不振。在这样的团队中，三个人小组严重阻碍了团队整体的发展和技术的传承，四代还真不觉得这个团队能称得上“最优秀”的团队。（火箭的粉丝们，抱歉抱歉哈）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;品评团队&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;说到团队，四代其实有一个非常特殊的爱好，就是品评团队。&lt;/p&gt;

&lt;p&gt;在四代接触的历史，生活和影视作品中，存在许多非常优秀的团队，比如历代的开国皇帝，无一例外都有一个文武双全的团队；比如现在成功的各位商业大佬，无一例外都有一伙聪明精干的助手；还比如武侠剧中的各位英雄们，无一例外的都有一帮生死相依的兄弟，所谓“一个好汉三个帮”嘛！&lt;/p&gt;

&lt;p&gt;不过在众多的团队中，四代认为下面这几个是最为耀眼的明星：重耳团队，刘邦团队，“神探狄仁杰”中狄仁杰的团队。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;春秋五霸的老大&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;说起“春秋五霸”中第一人的晋文公，四代是非常佩服，典型的大器晚成，知人善任。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422135550998-968941004.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;在他的团队中，武有先轸，可定天下；文有赵衰，可安社稷；谋有狐偃，运筹帷幄，决胜于千里之外；勇有魏犨，可百万军中取上将首级，忠有介子推，关键时刻可以割肉救主，再加上重耳本身就是一个一等一的人才，这样的团队不能成就一番大业，那简直是没有天理！关键是这几家几乎代代都有杰出人才，不断的把晋国的实力推向新的高潮。&lt;/p&gt;

&lt;p&gt;如果说重耳团队还只是维持在一个邦国的水平的话，那么下一个出场的团队，那真是不得了，它几乎是中国历史上最强大的团队，没有之一，这就是建立伟大西汉帝国的刘邦团队。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;楚汉相争的精英&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;虽然四代对刘老三或者是刘老四并不感冒，不过对于他聚拢团队和用人的水平，那是绝对的崇拜。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422140126816-876619121.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;看看这些闪耀万分，流传后世的名字吧：萧何，月下追韩信那位，有他在，楚汉相争中，哪怕刘邦把内裤输了都没事。韩信，不用说，公认的“兵仙”，四代心中“战神”的不二之人选，从暗渡陈仓开始，到十面埋伏干掉项羽，没他打不赢的仗。张良，顶级谋略大师，从说服刘邦接受汉王，到力劝刘邦封韩信齐王，基本上是算无遗策。陈平，超级参谋，从离间项羽和范增，到反间胭脂和单于，称得上是翻云覆雨。&lt;/p&gt;

&lt;p&gt;此外，还有曹参，樊哙，周勃……他们无一不是一时之人杰，而且难能可贵的是最终团结在一起，用自己的实际行动深深的影响了中国历史的走向，并让中华民族从此有了一个响亮的名字：“大汉”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;大人，您来了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;这些历史中的团队都足够优秀，下面出场的这位就有点特殊，虽然主角是历史上真实的人物，也非常的厉害，是当时罕见的文武双料状元，不过这个人扬名海内却是拜一个叫“高罗佩”的荷兰人所赐，因为这个热衷于研究房中术的外国人写了一部非常精彩的小说叫《狄公案》，注意是外国人用中文写的小说哦，牛掰的一塌糊涂。&lt;/p&gt;

&lt;p&gt;说到这，你肯定猜到了下面这个团队的核心人物-狄仁杰，有“东方福尔摩斯”之称的推理大师。&lt;/p&gt;

&lt;p&gt;近年来，非常好看的电视剧不是太多，而《神探狄仁杰》系列绝对是排的上号的好看，这是四代非常喜欢的武侠推理系列，尤其是前两部。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422140408758-847690056.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;在剧中，狄仁杰也是有团队的，表面上看就是：文由狄仁杰自己担当，负责勘探现场，重组案情，然后推理和制定方略，并常常会问：“我隐隐觉的这里的水很深，元芳，你怎么看？”；武有李元芳，执行需要暴力和危险的任务，令人称奇的是，他一旦独立执行任务，智商立即暴涨，可一旦遇到大人，智商瞬间回零；还有一个徒弟叫曾泰，大家公认没用的人，只会问：“恩师，接下来怎么办？”；此外还有如燕，狄春和八大军头等一些普通的公差人员和家丁。&lt;/p&gt;

&lt;p&gt;不过就是这样一个组合，四代觉得是非常优秀的团队，因为他们中大部分人都不是顶尖的人，但是组合却无案不能破，就像前苏联的米格系列战机，虽然各部分组件都不是最好的，但是组装后的战机的战斗力丝毫不亚于同时代美军最先进的战机。在后来的战争中，这些战机对阵强大的美军，甚至能打出“喷气走廊”这样无比强悍的称谓。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422140923570-1355721852.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;现实的情况就是这样，刘邦和重耳的团队都超级强悍，但是里面的每个人都是顶尖的人才，几乎是可遇不可求，全国就那么几个，但是狄公的团队却是参差不齐，水平大部分一般，非常贴近四代的团队组成：包括四代在内，全部都不是什么杰出的人才。&lt;/p&gt;

&lt;p&gt;下面来看看这个组合的特点：&lt;/p&gt;

&lt;p&gt;狄大人自然不用说，智慧的化身，整个团队的主心骨。&lt;/p&gt;

&lt;p&gt;但是元芳就值得商榷了，不用说，元芳智商平平，从第一部被人陷害开始，到后面一直都是这样，不过他拥有一项非常专业的技能-武功，就像现在很多人技术很好，软技能一般一样，综合水平中等偏上。&lt;/p&gt;

&lt;p&gt;其他人就更一般了，比如曾泰，每次只会问问题和记方案，不过他却代表着一个团队最重要的东西，那个东西叫“可靠的执行力”，还记得每次曾泰率兵在关键时刻出现的场景嘛，难道不觉得那时的曾泰也很帅气吗？&lt;/p&gt;

&lt;p&gt;此外的那些人就不用说了，非常普通，普通的都要靠同一个龙套通过不断换衣服来扮演，不要掉头，说的就是你，“张环-龙套之王”，剧组很缺钱吗？！&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422141225267-1749031384.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可是就是这个奇怪的组合，不断击败各大实力强大的帮派和势力，靠的固然有狄公的智慧，但是更多的时候靠的是大家齐心协力的协作，这就是团队的力量。就像武侠小说里面描述的那样，哪怕是武功最高的那些人，都无法和一支军队相抗衡，这个说的并不是人数的多少，而是说单人很难对抗训练有素的团队。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;做后调整的原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;话说回来，四代觉得他们很优秀，但不会照搬他们的模式，四代还是坚持自己“做后调整”的原则，会从他们的故事中寻求可借鉴的一些方面，然后尝试运用到团队中，不行就调整，实在不行就抛弃。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201804/109061-20180422141948323-216808741.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;那么，到底怎样捏合个人的才能，形成团队的协作，体现团队的力量呢？找来找去，四代找到了一个前面已经说过的一个词，叫做“双赢”。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 06:34:00 +0000</pubDate>
<dc:creator>沙场秋点兵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxy1982/p/8906724.html</dc:identifier>
</item>
<item>
<title>SpringMVC 教程 - Controller - NNS</title>
<link>http://www.cnblogs.com/hitandrew/p/8907088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hitandrew/p/8907088.html</guid>
<description>&lt;h5&gt;原文地址：https://www.codemore.top/cates/Backend/post/2018-04-10/spring-mvc-controller&lt;/h5&gt;
&lt;h5&gt;声明Controller&lt;/h5&gt;
&lt;p&gt;Controller也是一个标准的Spring bean，可以在Servlet的&lt;code&gt;WebApplicationContext&lt;/code&gt;中定义。也可以使用&lt;code&gt;@Controller&lt;/code&gt;注解，Spring会扫描注解自动注册为Spring的bean。 开启自动注册&lt;code&gt;@Controller&lt;/code&gt;注解的bean可以使用如下Java Config的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Configuration
&lt;span class=&quot;hljs-meta&quot;&gt;@ComponentScan(&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.example.web&quot;)
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;WebConfig {

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用xml配置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;beans &lt;span class=&quot;hljs-attr&quot;&gt;xmlns=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;
    &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:p=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;
    &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:context=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;
    &lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;context:component-scan &lt;span class=&quot;hljs-attr&quot;&gt;base-package=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.example.web&quot;/&amp;gt;

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5&gt;请求映射&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;@RequestMapping&lt;/code&gt;可以将请求映射到具体的Controller方法上。通过找到匹配的url，http 方法，请求参数，header，媒体类型来映射请求。这个注解既可以用在类级别，也可以用在方法级别上。 为了方便&lt;code&gt;@RequestMapping&lt;/code&gt;根据HTTP方法不同提供了如下快捷注解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@GetMapping&lt;/li&gt;
&lt;li&gt;@PostMapping&lt;/li&gt;
&lt;li&gt;@DeleteMapping&lt;/li&gt;
&lt;li&gt;@PutMapping&lt;/li&gt;
&lt;li&gt;@PatchMapping&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RestController
&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/persons&quot;)
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;PersonController {

    &lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/{id}&quot;)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Person &lt;span class=&quot;hljs-title&quot;&gt;getPerson&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable Long id) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5&gt;URI 模式&lt;/h5&gt;
&lt;p&gt;请求映射支持glob模式和通配符&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 匹配一个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 匹配0个或多个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**&lt;/code&gt; 匹配0个或多个路径 可以通过&lt;code&gt;@PathVariable&lt;/code&gt; 访问在URI中定义的变量：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/owners/{ownerId}/pets/{petId}&quot;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Pet &lt;span class=&quot;hljs-title&quot;&gt;findPet&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable Long ownerId, @PathVariable Long petId) {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;URI的变量可以在类和方法中定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Controller
&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/owners/{ownerId}&quot;)
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;OwnerController {

    &lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/pets/{petId}&quot;)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Pet &lt;span class=&quot;hljs-title&quot;&gt;findPet&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable Long ownerId, @PathVariable Long petId) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;URI变量会自动类型转换，如果失败会抛出&lt;code&gt;TypeMismatchException&lt;/code&gt;的异常。默认支持&lt;code&gt;int&lt;/code&gt;,&lt;code&gt;long&lt;/code&gt;,&lt;code&gt;Date&lt;/code&gt;等类型，也可以通过DataBinder和 Type Conversion来注册其他需要支持的类型。 URI变量名也可以明确的支持，例如&lt;code&gt;@PathVariable(&quot;customId&quot;)&lt;/code&gt;，不过如果在编译的时候带着调试信息，或者对于Java8 使用&lt;code&gt;-parameters&lt;/code&gt; 编译，则可以不需要明确的命名。 语法&lt;code&gt;{varName:regex}&lt;/code&gt;表示变量根据正则表达是来匹配，例如&quot;/spring-web-3.0.5 .jar&quot;可以使用以下表达式匹配&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}&quot;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;handle&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable String version, @PathVariable String ext) {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;URI同样可以有内嵌的&lt;code&gt;${}&lt;/code&gt;的占位符，在应用启动的时候由&lt;code&gt;PropertyPlaceHolderConfigurer&lt;/code&gt;从本地，系统，环境变量或者其他配置中解析。 Spring MVC使用的是Spring core 中的&lt;code&gt;AntPathMatcher&lt;/code&gt;来匹配路径。&lt;/p&gt;
&lt;h5&gt;模式对比&lt;/h5&gt;
&lt;p&gt;当有很多模式匹配URI的时候，必须通过对比来找到最合适的匹配。这个是通过&lt;code&gt;AntPathMatcher.getPatternComparator(String path)&lt;/code&gt;来实现。 可以根据URI中的变量个数，通配符个数来给URL打分，如果一个URI的变量少，通配符多，那么他得到的分数就会低。当匹配的模式分数相同是，选择匹配模式长的那个，如果分数和长度都相同，选择变量比通配符少的那个。 &lt;code&gt;/**&lt;/code&gt;是不参与评分的，而且总会是最后一个选择。同样&lt;code&gt;/plublic/**&lt;/code&gt;也是当匹配不到其他没有两个通配符的模式的时候才会被选择。 了解更加详细的信息可以查看&lt;code&gt;AntPathMatcher&lt;/code&gt;中的&lt;code&gt;AntPatternComparator&lt;/code&gt;。同时也可个继承&lt;code&gt;PathMatcher&lt;/code&gt;来定制URI匹配。&lt;/p&gt;
&lt;h5&gt;后缀匹配&lt;/h5&gt;
&lt;p&gt;Spring MVC 默认启动&lt;code&gt;.*&lt;/code&gt;后缀匹配模式，这样映射到&lt;code&gt;/person&lt;/code&gt;的controller 同样可以映射到&lt;code&gt;/person.*&lt;/code&gt;。扩展名可以用来代替header中的&lt;code&gt;Accept&lt;/code&gt;表示请求返回的类型。例如&lt;code&gt;person.pdf&lt;/code&gt;,&lt;code&gt;person.xml&lt;/code&gt;等。 因为过去浏览器的&lt;code&gt;Accept&lt;/code&gt;头很难解析，所以这么是有意要的，但是现在浏览器的&lt;code&gt;Accept&lt;/code&gt;更加清晰明确了，所以更好的选择是用&lt;code&gt;Accept&lt;/code&gt;。而且过去一段时间内，使用后缀名匹配的时候会有各种各样的问题，当使用URI变量，路径参数，URI编码时后缀模式会导致歧义。 可以使用以下方法关闭后缀模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PathMatchConfigurer&lt;/code&gt;的&lt;code&gt;useSuffixPatternMatching(false)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContentNeogiationConfigurer&lt;/code&gt; 的&lt;code&gt;favorPathExtension(false)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;后缀匹配和RFD&lt;/h5&gt;
&lt;p&gt;反射型文件下载(RFD)攻击和XSS攻击很相似。XSS依赖于请求的输入，例如查询参数，URI变量等，而RFD是用户点击URL浏览器会下载恶意文件，用户点击后会攻击主机。 由于Spring MVC的 &lt;code&gt;@ResponseBody&lt;/code&gt;和&lt;code&gt;ResponseEntity&lt;/code&gt;会根据URI后缀来渲染不同类型的响应内容，所以可能受到RFD攻击。关闭后缀匹配可以降低攻击的风险，但是不能完全防止RFD攻击。 为了防止RFD攻击，可以在渲染响应内容的时候添加&lt;code&gt;Content-Disposition:inline;filename=f.txt&lt;/code&gt;确保一个安全的下载文件。 默认情况下大多数扩展名都有白名单，可以通过继承&lt;code&gt;HttpMessageConverter&lt;/code&gt;对内容协商注册扩展，可以避免在响应中添加&lt;code&gt;Content-Disposition&lt;/code&gt;。&lt;/p&gt;
&lt;h5&gt;可消费媒体类型&lt;/h5&gt;
&lt;p&gt;通过请求的&lt;code&gt;Content-Type&lt;/code&gt;可以缩小请求的匹配范围，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@PostMapping(path = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/pets&quot;, consumes = &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/json&quot;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;addPet&lt;span class=&quot;hljs-params&quot;&gt;(@RequestBody Pet pet) {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;consumes也支持表达式求反操作，例如&lt;code&gt;!text/plain&lt;/code&gt;指的就除了&lt;code&gt;text/plain&lt;/code&gt;都可以。 可以定义一个类级别的consumes，其方法共享这个consumes，和其他的&lt;code&gt;@ReqeustMapping&lt;/code&gt;的属性不同，方法的consumes会覆盖类的定义。&lt;/p&gt;
&lt;h5&gt;可产生的媒体类型&lt;/h5&gt;
&lt;p&gt;可以通过&lt;code&gt;Accept&lt;/code&gt;头来缩小请求的匹配范围，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(path = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/pets/{petId}&quot;, produces = &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/json;charset=UTF-8&quot;)
&lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Pet &lt;span class=&quot;hljs-title&quot;&gt;getPet&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable String petId) {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;媒体类型可以指定一个字符集。对表达式取反也是支持的，例如：&lt;code&gt;!text/plain&lt;/code&gt;指的就是除了&lt;code&gt;text/plain&lt;/code&gt;都可以。 和consumes一样，也可以指定一个类级别的produces，其方法属性也会覆盖类的属性。&lt;/p&gt;
&lt;h5&gt;参数和HTTP header&lt;/h5&gt;
&lt;p&gt;可以通过参数来缩小请求匹配的范围。可以设置是否有参数(&quot;myParam&quot;),反过来是否没有(&quot;!myParam&quot;)或者指定一个值（&quot;myParam=myValue&quot;)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(path = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/pets/{petId}&quot;, params = &lt;span class=&quot;hljs-string&quot;&gt;&quot;myParam=myValue&quot;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;findPet&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable String petId) {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的情况也适合HTTP header&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(path = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/pets&quot;, headers = &lt;span class=&quot;hljs-string&quot;&gt;&quot;myHeader=myValue&quot;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;findPet&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable String petId) {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 22 Apr 2018 06:17:00 +0000</pubDate>
<dc:creator>NNS</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hitandrew/p/8907088.html</dc:identifier>
</item>
<item>
<title>Java的递归、IO流 - 小白坤</title>
<link>http://www.cnblogs.com/gcywj/p/8906222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gcywj/p/8906222.html</guid>
<description>

&lt;p&gt;&lt;strong&gt;&lt;span&gt;[递归]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　1、 在函数自身内部，调用函数本身的方式，称为递归。&lt;/p&gt;
&lt;p&gt;　　 2、 注意： 递归包括递进去、归出来两步。&lt;br/&gt; 　　　　首先，依次执行【函数调自身语句】上半部分的代码，直到最里层。 {递进去}&lt;br/&gt;　　　　 然后，再从最里层开始，依次执行【函数调自身语句】下半部分的代码。 {归出来}&lt;br/&gt; 　　3、 递归必须通过合适的语句，及时的跳出。 否则，容易造成死循环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360028/201804/1360028-20180422111125077-1334455236.png&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
        System.out.println(&lt;/span&gt;&quot;这是一个函数&quot;&lt;span&gt;);
        num&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num&amp;lt;=2&lt;span&gt;){
            test();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if()不成立不再调用自己&lt;/span&gt;
        }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先执行三次&lt;/span&gt;
        System.out.println(&quot;hahah&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行完num大于2，hahah在执行之前的三次&lt;/span&gt;
&lt;span&gt;    }


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;test类&lt;/span&gt;
test();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360028/201804/1360028-20180422110447224-865621618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;练习：5的阶乘&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用递归实现5的！
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; jie=1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; jiecheng(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
        jie&lt;/span&gt;*=&lt;span&gt;n;
        n&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n&amp;gt;=1&lt;span&gt;){
            jiecheng(&lt;/span&gt;5&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jie;
    }



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Test类：&lt;/span&gt;
System.out.println(jiecheng(5));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;方法2：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt; number){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
           &lt;span&gt;if&lt;/span&gt;(number == 1&lt;span&gt;){
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
           }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; number * test(number - 1&lt;span&gt;);
           }
           
       }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Test类：&lt;/span&gt;
System.out.println(test(5));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;1、[File类]&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; （1） 作用： 用于对磁盘文件进行操作。 删除、创建等。&lt;br/&gt; （2） 三种常用的构造函数：&lt;br/&gt;　　 ① File file1 = new File(&quot;F:\\test&quot;);&lt;br/&gt;　　　直接传入一个路径，拿到一个文件或者是文件夹。&lt;br/&gt; 　　② File file2 = new File(&quot;F:\\test&quot;,&quot;test.txt&quot;);&lt;br/&gt; 　　  第一个参数传入父路径、 第二个参数传入子路径或者文件。&lt;br/&gt;　　 ③ File file3 = new File(file1,&quot;test.txt&quot;);&lt;br/&gt;  第一个参数传入一个父路径的file对象， 第二个参数传入子路径或者文件。&lt;br/&gt; （3） 路径的表示：&lt;br/&gt;　　  文件夹的分隔，可以使用&quot;/&quot;(通常用于Linux系统，Windows也适用)&lt;br/&gt;  　　也可以使用&quot;\\&quot;(通常用于Windows)，注意一个\需要进行转义。&lt;br/&gt; （4）方法：&lt;/p&gt;
&lt;p&gt;　　  1.检测文件是否可读。&lt;/p&gt;
&lt;p&gt;　　　　System.out.println(file1.canRead());&lt;/p&gt;
&lt;p&gt;　　  2.检测文件是否可写。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　System.out.println(file2.canWrite());&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　  3. 比较两个对象是否相等。&lt;br/&gt;　　　　System.out.println(file2.equals(file3));&lt;br/&gt;　　  4. 检测文件是否存在。&lt;br/&gt;　　　　System.out.println(file1.exists());&lt;br/&gt;　　  5. 取到文件的绝对路径&lt;br/&gt;　　　　System.out.println(file1.getAbsolutePath());&lt;br/&gt;　　  6. 取到文件名或者文件夹名&lt;br/&gt;　　       System.out.println(file2.getName());&lt;br/&gt;　　  7. 取到当前文件或文件夹的父路径&lt;br/&gt;　　　　System.out.println(file1.getParent());&lt;br/&gt;　　  8. 检测当前文件是否是绝对路径&lt;br/&gt;　　　　System.out.println(file1.isAbsolute());&lt;br/&gt;　　  9. 检测当前路径是否是目录&lt;br/&gt;　　　　System.out.println(file2.isDirectory());&lt;br/&gt;　　 10. 检测当前路径是否是文件&lt;br/&gt;　　　　System.out.println(file1.isFile());&lt;br/&gt;　　 11. 删除文件: 删除成功返回true，删除失败返回false&lt;br/&gt;　　　　如果删除的是文件夹，则只能删除空文件夹，否则删除失败！&lt;br/&gt;　　　　System.out.println(file1.delete());&lt;br/&gt; 　　12.创建一个新文件。 创建失败返回false&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
   System.out.println(file3.createNewFile());
  } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;   e.printStackTrace();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　13. 创建一个文件夹。只有当文件夹不存在时，才能创建成功。&lt;br/&gt;　　①mkdir: 只能创建一层目录，如果倒数第二层目录也不存在，将创建失败。&lt;br/&gt;　　② mkdirs： 可以创建多层目录，无论有几层不存在，都可以依次创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;System.out.println(file1.mkdir());
System.out.println(file1.mkdirs());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　14.获得文件所在分区的总大小和可用大小，以字节B为单位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;System.out.println(file1.getTotalSpace());
System.out.println(file1.getUsableSpace());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　15.返回当前文件或文件夹的大小。单位B&lt;br/&gt;　　 System.out.println(file2.length());&lt;br/&gt; 　　list(): 返回当前目录中的所有文件和文件夹的名字。 返回值类型为String数组&lt;br/&gt;　　 可以在参数中，传入FilenameFilter接口的实现类对象，表示对列表中的所有文件进行遍历过滤。&lt;br/&gt;　　 需要重写accept方法，如果保留当前文件return true ，如果不要当前文件，return false&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
String[] list = file1.list(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilenameFilter() {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dir: 表示包含当前文件的父路径；
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name： 表示当前文件名&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; accept(File dir, String name) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(name.endsWith(&quot;.txt&quot;&lt;span&gt;)){
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
   }
  });
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String item : list) {
   System.out.println(item);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　16..listFiles(): 返回当前目录中所有的文件和文件夹的路径。 返回值类型为File数组。&lt;br/&gt;　　同样可以对文件进行过滤：&lt;br/&gt; 　　① 与list()一样，使用FilenameFilter进行过滤；&lt;br/&gt;　　 ② 使用FileFilter接口的实现类，进行过滤。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  File[] files = file1.listFiles(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileFilter() {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pathname 表示当前文件的全路径(包括路径名和文件名)。&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; accept(File pathname) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pathname.getName().endsWith(&quot;.txt&quot;&lt;span&gt;)){
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
   }
  });
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File file : files) {
   System.out.println(file.getParent()&lt;/span&gt;+&quot;-----&quot;+&lt;span&gt;file.getName());
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　17. 重命名一个文件。 要求传入一个新文件名的file对象。&lt;br/&gt; 　　 File file4 = new File(&quot;F:\\test\\test08.txt&quot;);&lt;br/&gt;  　　System.out.println(file1.renameTo(file4));&lt;br/&gt;　　18.只读。&lt;br/&gt; 　　 System.out.println(file1.setReadOnly());&lt;/p&gt;
&lt;p&gt;　　19.最后更新时间。&lt;br/&gt;　　  System.out.println(file1.setLastModified(new Date().getTime()));&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;[Java中的IO流]&lt;/span&gt;　&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;　　1、 根据流的方向： 输入流和输出流。　　　&lt;/p&gt;
&lt;p&gt;　　　     根据读取文字的大小: 字节流和字符流。&lt;br/&gt;　　 　　(字节流按字节读取，读取中文时容易乱码； 字符流按照字符读取，通常用于读取中文)&lt;br/&gt;　　　　 根据读取的方式： 节点流和缓存流。&lt;/p&gt;
&lt;p&gt;　　　　 fis = new FileInputStream(&quot;F:/test.txt&quot;);&lt;/p&gt;
&lt;p&gt;　　2.如果第二个参数省略，或传入false，则表示每次写入时将原文件清空，从文件头部开始写入。&lt;br/&gt;　　　　如果第二个参数传入true，则表示不清空原文件，在文件末尾处追加新内容。&lt;/p&gt;
&lt;p&gt;　　3.如果第二个参数省略，或传入false，则表示每次写入时将原文件清空，从文件头部开始写入。&lt;/p&gt;
&lt;p&gt;　　　如果第二个参数传入true，则表示不清空原文件，在文件末尾处追加新内容。&lt;/p&gt;
&lt;p&gt;　　4.按照字节，一个一个字节读取文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　int&lt;/span&gt; n = -1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((n = fis.read()) != -1&lt;span&gt;) {
                sb.append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)n);
            }
            System.out.println(sb);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5.将byte数组直接声明为输入流的长度，一次性读出所有文字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[fis.available()];
fis.read(bytes);
sb.append(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(bytes));
System.out.println(sb);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6.一次读取1024个字节。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = -1&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((n = fis.read(bytes)) != -1&lt;span&gt;) {
    sb.append(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(bytes));
   }
   System.out.println(sb);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7.将字符串转为Byte数组，并通过输出流写入文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fos.write(&quot;12345&quot;&lt;span&gt;.getBytes());
            System.out.println(sb);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8.finally 无论上述代码是否会出现异常，都会执行的一段代码；　&lt;/p&gt;
&lt;p&gt;　　   通常用于关闭各种资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;           &lt;br/&gt;finally {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * finally 无论上述代码是否会出现异常，都会执行的一段代码；
             * 通常用于关闭各种资源。
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                fis.close();
                fos.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                e.printStackTrace();
            }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.[BufferedInputStream、BufferedOutputStream]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;　    继承自java.io.FilterOutputStream（此类是过滤输出流的所有类的超类）&lt;br/&gt;　　1、 作用： 在基本流的基础上进行包装，读取或者写入文件时，将通过缓存进行。&lt;br/&gt;　　 即，先将内容写入到缓存区，缓存区满以后再进行读取或写入操作。&lt;br/&gt; 　　可以大大减小文件的操作次数，提高写入效率。&lt;br/&gt;　　2、 缓存流的使用：&lt;br/&gt;　　在基本流的基础之上，进行包装：&lt;br/&gt;　　new BufferedInputStream(new FileInputStream(&quot;F:/test.txt&quot;));&lt;br/&gt;　　这种写法，我们称之为IO链，IO关闭时只需要关闭最外层流，内层流将自动关闭。&lt;br/&gt;　　3、 BufferedOutputStream在关闭前，通常调用bos.flush();&lt;br/&gt;　　表示关闭前将缓存进行刷新，将缓存区剩余未满的内容写入文件。&lt;br/&gt;　　但是一般.close()方法，自带刷新功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
BufferedInputStream bis = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedOutputStream bos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            bis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;F:/test.txt&quot;&lt;span&gt;));
            
            bos &lt;/span&gt;=  &lt;span&gt;new&lt;/span&gt; BufferedOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;F:/out.txt&quot;,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
            
            StringBuffer sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
            
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = -1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((n = bis.read()) != -1&lt;span&gt;) {
                sb.append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)n);
            }
            System.out.println(sb);
            
            bos.write(sb.toString().getBytes());
            
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * finally 无论上述代码是否会出现异常，都会执行的一段代码；
             * 通常用于关闭各种资源。
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                fis.close();&lt;/span&gt;
&lt;span&gt;                bis.close();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                fos.close();&lt;/span&gt;
                
                &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 在程序最后，刷新缓存流，将缓存流中未满的内容，写入到文件中。
                 * 调用close()方法，将自动刷新。
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                bos.flush();
                bos.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                e.printStackTrace();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.[DataOutputStream/DataInputStream]&lt;/span&gt;&lt;/strong&gt; 　　&lt;/p&gt;
&lt;p&gt;　　1.采用二进制对文件进行读写操作。&lt;br/&gt;　　   与基本流相比，可以直接读写Java中的基本数据类型。&lt;br/&gt;　　   另外，如果操作的文件是一个二进制文件，需要使用DataOutputStream替代FileOutputStream。&lt;br/&gt;　　   同样，Data系列的流，也有read和write方法，操作与基本相同。&lt;br/&gt; &lt;span&gt;注意&lt;/span&gt;： 使用DataOutputStream写入文件为二进制文件，只能使用DataInputStream进行读取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
String name = &quot;zhangsan&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; age = 12&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; height = 178.5&lt;span&gt;;
        String ads &lt;/span&gt;= &quot;山东烟台&quot;&lt;span&gt;;
        
        DataOutputStream dos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        DataInputStream dis &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            dos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DataOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;F:\\zhangsan.txt&quot;&lt;span&gt;));
            dos.writeUTF(name);
            dos.writeInt(age);
            dos.writeDouble(height);
            dos.writeUTF(ads);
            
            dis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DataInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;F:\\zhangsan.txt&quot;&lt;span&gt;));
            String uname &lt;/span&gt;=&lt;span&gt; dis.readUTF();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; uage =&lt;span&gt; dis.readInt();
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; uheight =&lt;span&gt; dis.readDouble();
            String uads &lt;/span&gt;=&lt;span&gt; dis.readUTF();
            
            System.out.println(uname&lt;/span&gt;+&quot;---&quot;+uage+&quot;---&quot;+uheight+&quot;---&quot;+&lt;span&gt;uads);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                dis.close();
                dos.flush();
                dos.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.[ObjectOutputStream/ObjectInputStream]&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　直接继承自：java.io.OutputStream 抽象类&lt;br/&gt; 　　1、 与基本流相同，可以直接使用read、write方法进行读写。&lt;br/&gt;　　 2、 与DateInputStream相同，可以对Java基本数据类型进行直接读写： readInt() writeDouble()&lt;br/&gt; 　　3、 可以只用readObject() 和 writeObject() 直接对对象进行操作。&lt;br/&gt;[对象的序列化和反序列]&lt;br/&gt;　　1、 对象的序列化： 将程序中的对象，持久化的保存在文件中的过程。 ObjectOutputStream&lt;br/&gt;　　2、 对象的反序列化： 将文件中保存的对象，重新读取到程序中的过程呢。ObjectInputStream&lt;br/&gt; 　　如果，要将对象进行序列操作，那么实体类必须实现可序化接口：&lt;br/&gt;　　 class Person implements Serializable{}&lt;br/&gt;注意： 当一个实体类，实现可序化接口后，可以添加一个序列化版本号ID。&lt;br/&gt; (实现序列化接口后，根据警告提示，选择：Adds a generated serial version ID)&lt;br/&gt;　　会自动生成一个静态属性：&lt;br/&gt;　　 private static final long serialVersionUID = -1954048587316264652L;&lt;br/&gt;　　添加以后，可以用ID表示序列化和反序列时操作的对象，是同一个对象。&lt;br/&gt;　　如果不添加版本ID，当序列化一个对象后，如果实体类属性有增删，再进行反序列化时，会造成错误。&lt;br/&gt;　　因为系统认为这已经不是一个类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Person zhangsan = &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;, 12, 178.4, &quot;山东烟台杰瑞教育&quot;&lt;span&gt;);
        
        ObjectOutputStream oos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ObjectInputStream ois &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象的序列化&lt;/span&gt;
            oos = &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;F:/user.txt&quot;&lt;span&gt;));
            oos.writeObject(zhangsan);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象的反序列化&lt;/span&gt;
            ois = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;F:/user.txt&quot;&lt;span&gt;));
            Person p &lt;/span&gt;=&lt;span&gt; (Person)ois.readObject();
            System.out.println(p);
            
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                ois.close();&lt;/span&gt;
&lt;span&gt;                oos.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private static final long serialVersionUID = -1954048587316264652L;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; height;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ads;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; weight;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name, &lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; height, String ads) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ads =&lt;span&gt; ads;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getHeight() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; height;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeight(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; height) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAds() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ads;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAds(String ads) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ads =&lt;span&gt; ads;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, height=&quot; +&lt;span&gt; height
                &lt;/span&gt;+ &quot;, ads=&quot; + ads + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.【字符流】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;　　1. 在处理数据单元时，以一个字符作为单位。而字节流，是以一个字节为单位。&lt;br/&gt;　　2.字符流的基类：&lt;br/&gt;　　 Reader和Writer，这两个类是抽象类。&lt;br/&gt;　　FileReader和FileWriter是直接继承自抽象类的两个字符基本流。&lt;br/&gt;　　3.FileReader和FileWriter在读写文件的时候，只能使用系统默认的编码模式，无法指定编码。&lt;br/&gt;　　如果文件格式与系统默认格式不一致，那使用这俩个方法编写会造成中文乱码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
FileWriter fw=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        FileReader fr&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
             fw&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; FileWriter(&quot;D:/Test/test01.txt&quot;&lt;span&gt;);
             String s&lt;/span&gt;=&quot;帅帅：shuaishuai&quot;&lt;span&gt;;
             fw.write(s);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以直接写字符串
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;             for(int i=0;i&amp;lt;s.length();i++){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                 fw.write(s.charAt(i));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;             fw.flush();
             fr&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; FileReader(&quot;D:/Test/test01.txt&quot;&lt;span&gt;);
             &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n=0&lt;span&gt;;
             StringBuffer sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
             &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((n=fr.read())!=-1&lt;span&gt;){
                 sb.append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)n);
                 
             }
             System.out.println(sb.toString());
        }
             &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                fw.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                e.printStackTrace();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6.【InputSteamReader/OutputStreamWriter】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;   　1.将字符转为字符串，同时支持自定义读写的编码格式。&lt;br/&gt;　　2.常见编码格式：&lt;br/&gt;　　ASCII：美国标准信息码&lt;br/&gt;　　 ISO8859-1：欧洲码&lt;br/&gt;　　ANSI编码：可以分为很多种。&lt;br/&gt;　　 简体中文：&lt;br/&gt;　　 GB2312&lt;br/&gt;　　 GBK&lt;br/&gt;　　 繁体中文：big-5&lt;br/&gt;　　 Unicode编码：国际标准码，兼容绝大部分国家的编码格式。&lt;br/&gt;　　 可以分为UTF-6，UTF-8，UTF-16&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
InputStreamReader isr=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        OutputStreamWriter osw&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            isr&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; InputStreamReader(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;D:/Test/test001.txt&quot;),&quot;UTF-8&quot;&lt;span&gt; );
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n=0&lt;span&gt;;
            StringBuffer sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((n=isr.read())!=-1&lt;span&gt;){
                sb.append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)n);
            }
            System.out.println(sb);
            osw&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:/Test/test001.txt&quot;),&quot;UTF-8&quot;&lt;span&gt;);
            String s&lt;/span&gt;=&quot;shuai真帅&quot;&lt;span&gt;;
            osw.write(s);
            osw.flush();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                isr.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                e.printStackTrace();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.【BufferedReader/BufferedWriter】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　 原来的字符串s是UTF-8的编码格式。&lt;br/&gt;　　 使用 s.getBytes(&quot;UTF-8&quot;) ,表示用UTF-8对字符串进行解码为字节数组。&lt;br/&gt;　　 s=new String(s.getBytes(&quot;UTF-8&quot;),&quot;GBK&quot;);&lt;br/&gt;　　 表示将解码后的字节数组，重新使用GBK的编码，组合成字符串。&lt;br/&gt;　　 最终：一个UTF-8的字符串，通过解析编码解析成GBK的编码形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
BufferedReader br=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedWriter bw&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            br&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;D:/Test/test001.txt&quot;&lt;span&gt;)));
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n=0&lt;span&gt;;
            StringBuffer sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((n=br.read())!=-1&lt;span&gt;){
                sb.append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)n);
            }
            System.out.println(sb);
            
            bw&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:/Test/test001.txt&quot;&lt;span&gt;))); 
            
                String s&lt;/span&gt;=sb.toString()+&quot;hahahaha呵呵呵&quot;&lt;span&gt;;
                s&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(s.getBytes(&quot;UTF-8&quot;),&quot;GBK&quot;&lt;span&gt;);
                
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 22 Apr 2018 06:03:00 +0000</pubDate>
<dc:creator>小白坤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gcywj/p/8906222.html</dc:identifier>
</item>
<item>
<title>c#之异步Socket通信 - 小小屌丝程序员</title>
<link>http://www.cnblogs.com/liyijin/p/8906687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyijin/p/8906687.html</guid>
<description>&lt;p&gt;0.基于上一篇的c#之Socket（同步）通信，在几个大神评论之后，发现是有挺多地方不足的，所以写了一个改进版本的基于c#的异步Socket通信。再加深一下对Socket的使用和理解。其中客户端和服务端均采用WPF界面，实现了心跳，断线重连，一个服务端对应多个客户端的功能。&lt;/p&gt;
&lt;p&gt;一.服务端&lt;/p&gt;
&lt;p&gt;1.1 先创建一个Socket实例，并绑定到20000端口号；通过Listen方法开始监听并设置最大监听数量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个Socket服务端实例，并绑定到20000端口&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.socketServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.socketServer.Bind(&lt;span&gt;new&lt;/span&gt; IPEndPoint(IPAddress.Any, &lt;span&gt;20000&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置最大监听数量&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.socketServer.Listen(&lt;span&gt;10&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.2 开始异步监听客户端，使用的是BeginAccept与EndAccept，当有客户端连接后会自动调用回调函数，此时开始心跳并将客户端的Socket与心跳等信息加入到全局字典中去。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.socketServer.BeginAccept(ar =&amp;gt;&lt;span&gt;
{
    Socket _socket &lt;/span&gt;=&lt;span&gt; socketServer.EndAccept(ar);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始心跳&lt;/span&gt;
    System.Timers.Timer heartbeatTimer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Timers.Timer();
    heartbeatTimer.Interval &lt;/span&gt;= &lt;span&gt;600000&lt;/span&gt;&lt;span&gt;;
    heartbeatTimer.Elapsed &lt;/span&gt;+= &lt;span&gt;new&lt;/span&gt; System.Timers.ElapsedEventHandler((s, e) =&amp;gt;&lt;span&gt; heartbeatTimerIsUp(s, e, _socket));
    heartbeatTimer.Start();

    SocketInfo info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketInfo();
    info.heartbeatTimer &lt;/span&gt;=&lt;span&gt; heartbeatTimer;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.socketInfoDic.Add(_socket, info);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始接收数据&lt;/span&gt;
&lt;span&gt;    thdRevMethod(_socket);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始下一次监听&lt;/span&gt;
&lt;span&gt;    ListenSocket();
}, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3 接收数据，当上一步中有客户端连接成功后，即可开启异步接收来自客户端的数据；使用的是BeginReceive与EndReceive，当接收到来自客户端的数据后，会自动调用回调函数。由于接收到的数据的大小不确定，所以这里每次接收1024字节，然后将接收到的数据拼接起来，用到Available 属性，为可读取的字节数，如果小于等于0，说明此次数据接收完毕。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
Socket _socket = obj &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Socket;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.socketInfoDic.ContainsKey(_socket))
{
    SocketInfo socketInfo &lt;/span&gt;=&lt;span&gt; socketInfoDic[_socket];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始接收消息&lt;/span&gt;
    _socket.BeginReceive(socketInfo.tempByte, &lt;span&gt;0&lt;/span&gt;, socketInfo.tempByte.Length, SocketFlags.None, ar =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; resInt =&lt;span&gt; _socket.EndReceive(ar);
            socketInfo.contentByte &lt;/span&gt;=&lt;span&gt; socketInfo.contentByte.Concat(socketInfo.tempByte).ToArray();
            socketInfo.tempByte &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_socket.Available &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; actualLength = socketInfo.contentByte.Length - (socketInfo.tempByte.Length -&lt;span&gt; resInt);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; res = Encoding.Default.GetString(socketInfo.contentByte, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, actualLength);
                socketInfo.contentByte &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            }
            thdRevMethod(_socket);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SocketException sex)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sex.SocketErrorCode ==&lt;span&gt; SocketError.ConnectionReset)
            {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当客户端断开连接,从列表中移除该客户端&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.socketInfoDic.ContainsKey(_socket))
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.socketInfoDic.Remove(_socket);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序出现异常:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex);
        }
    }, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4 发送数据，用到的是BeginSend与EndSend，发送成功后会自动调用回调函数，其中EndSend()方法返回成功发送的字节数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;byte&lt;/span&gt;[] byteStr =&lt;span&gt; Encoding.Default.GetBytes(msg);
_socket.BeginSend(byteStr, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, byteStr.Length, SocketFlags.None, ar =&amp;gt;&lt;span&gt;
{
    _socket.EndSend(ar);
}, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二.客户端&lt;/p&gt;
&lt;p&gt;2.1 新建Socket实例并开始异步连接到服务端，用到的是BeginConnect与EndConnect，连接成功会自动调用回调函数，此时可开始心跳，接收发送数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建客户端实例，并连接到服务端所在的端口号&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.socketClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接到服务端&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.socketClient.BeginConnect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;20000&lt;/span&gt;, ar =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.socketClient.EndConnect(ar);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.thdRevMethod();
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SocketException sex)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sex.SocketErrorCode ==&lt;span&gt; SocketError.ConnectionRefused)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reconnectTimer.Start();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.heartbeatTimer.Stop();
        }
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.heartbeatTimer.Stop();
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
    }
}, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 发送与接收数据(与客户端类似)&lt;/p&gt;
&lt;p&gt;三.运行示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1088528/201804/1088528-20180422125633281-1474456669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四.总结&lt;/p&gt;
&lt;p&gt;假如上述描述，或者代码逻辑中有任何问题，希望各位大神帮忙指出来，谢谢!&lt;/p&gt;
&lt;p&gt;其中需要注意的地方如下：&lt;/p&gt;
&lt;p&gt;4.1.在异步接收数据的时候，因为接收到的数据大小是不确定的，所以暂定每次只接收1024字节，根据Available判断，如果接收到的数据大于1024字节，则依次拼接得到的数据。&lt;/p&gt;
&lt;p&gt;4.2 在服务端中，每次接收到1024字节的byte[]不能定义成全局变量，而需要与每个Socket客户端一一对应，否则再接收来自多个客户端的消息时会出错。（这边我理解是这样）&lt;/p&gt;
&lt;p&gt;源码下载地址如下：&lt;a title=&quot;AsyncSocketDemo.rar&quot; href=&quot;https://files.cnblogs.com/files/liyijin/AsyncSocketDemo.rar&quot; target=&quot;_blank&quot;&gt;AsyncSocketDemo.rar&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Apr 2018 05:22:00 +0000</pubDate>
<dc:creator>小小屌丝程序员</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyijin/p/8906687.html</dc:identifier>
</item>
<item>
<title>前后端对接的思考及总结 - xiaoymin</title>
<link>http://www.cnblogs.com/xiaoymin/p/8906585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoymin/p/8906585.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;随着前端NodeJs技术的火爆,现在的前端已经非以前传统意义上的前端了,各种前端框架(Vue、React、Angular......)井喷式发展,配合NodeJs服务端渲染引擎,目前前端能完成的工作不仅仅局限于CSS，JS等方面，很多系统的业务逻辑都可以放在前端来完成，例如我司的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;管控&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;那可能有些人会说,前端这么火,NodeJs发展这么迅猛,后端是不是以后都没事情干了，其实不然,拿Java来说，经过这么多年发展,已经相当稳定,完善的生态圈也非最近今年发展起来的NodeJs可比，我们常常说&lt;/span&gt;&lt;span&gt;&lt;strong&gt;闻道有先后，术业有专攻&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;,用在这里最合适不过了，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;集群&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分布式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高可用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;等等技术还是需要后端架构师来思考的事情&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;目前前端同后端的合作方式是前后端分离，通过Nginx+Tomcat的组合部署(还可加nodejs中间件)方式能有效的进行解耦，并且前后端分离为项目以后的架构扩展、微服务化、组件化都打下重要基础,所以这在以后是一个发展的必然趋势,我们需要去适应,做出改变！！！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;早期的开发方式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;早期的开发方式如下图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613480/201804/613480-20180422130102189-420025165.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这也是我前面工作1-3年的开发方式,我们没有前端帮我们写JS函数功能,所有的页面表单验证,数据渲染,数据接口编写都是我们后端全部实现,看上去更像是一个全栈工程师,从需求分析、搭建整个技术架构、数据库表设计、功能设计、编码开发，再到最终部署上线,我们无所不在,这可能也是目前很多小公司仍然在沿用的开发方式,很多后端同学担负起了项目的方方面面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;以我目前的经验来看,这样的开发方式对我个人的成长是有益无害的,因为你只有在了解了前端的JS/CSS/HTML的情况下,然后再谈目前的前后端分离,会让你的工作事半功倍,在写后端接口前,你脑子里浮现的是整个功能的交互页面,最终呈现的是前后端合作开发好后的的终端结果,这大大缩减了前后端的沟通交流&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;前后端分离的探索&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;jsonp&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;可能由于我在前面三年积累了丰富的前端经验,在上家公司主要负责开发官网、微信、后台等相关系统的接口，前期我们的开发方式虽然也是前后端分离的方式,但大都使用jsonp跨域接口调用的方式来达到分离效果,后端所有的接口都是可跨域调用的jsonp形式,抛开需要登录的授权之外的接口，前端在开发的时候本地无需开启服务即可调用服务端接口，然后渲染数据，完成页面交互渲染效果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;jsonp的优点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;兼容性更好,在更低版本的ie浏览器中都能兼容,这里区别于cors跨域类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;jsonp的原理其实很简单，当然,这也涉及到前端的知识,简单点说就是js端的function函数执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;正常的后端响应数据,例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
    &quot;code&quot;:&quot;8200&quot;,
    &quot;data&quot;:{
        &quot;id&quot;:&quot;100&quot;,
        &quot;name&quot;:&quot;Test&quot;
        //more......
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;jsonp需要的返回格式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
callback({
    &quot;code&quot;:&quot;8200&quot;,
    &quot;data&quot;:{
        &quot;id&quot;:&quot;100&quot;,
        &quot;name&quot;:&quot;Test&quot;
        //more......
    }
});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;前端在页面定义callback回调函数,callback函数接收后端响应回来的data-json数据,后端响应后执行callback函数达到调用前端业务逻辑的目的,渲染页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;nginx+ajax&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这种配合开发方式也是适合前端还没有引入Node等一站式开发解决方案的情况下引入的,纯粹的HTML+CSS+JS同后端对接，绑定业务接口,渲染数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我们在使用JSONP开发的时候,前端都是需要在页面端写死HOST+IP接口地址,存在很重大一个弊端就是前端需要些config文件，来配置我们后端的接口请求地址，如果前端工程师规范意识强一点，会通用到一个配置文件里，但是如果没有这方面的意识的话，就会出现代码里硬编码的情况，不利于服务器迁移，代码更新，接口变动等操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;为规避上面碰到的问题,使用nginx的反向代理功能,将后端服务器代理下来,前端在开发的时候本地开启nginx服务，即解决了jsonp跨域问题,同时也解决了无需写死后端的服务ip+端口地址，利于后端在部署时整合代码,减少不必要的错误&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;node&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;随着NodeJs的火热,前端已经可以本地开启服务写接口的情况下,就类似服务端开启tomcat一样,在这样的情况下，前端框架VUE、React等都在此基础上,提供了一套完整的技术解决方案，这和上面说到的开启nginx服务架构有点类似&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这样做的意义：真正的解放了前后端，专注各自擅长的领域&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;技术架构如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613480/201804/613480-20180422130118553-964445732.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;前端node服务直接访问后端Java Restful Api接口服务，Api接口最终访问数据库完成数据查询最终返回node层，node渲染响应数据到前端&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果存在会话信息同步等问题，可以使用中间件,例如redis缓存数据库,解决前端node和后端Api信息同步问题，传参可以通过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;JWT&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;等方式完成接口权限验证&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;不管是jsonp还是ajax+nginx这两种方式,node作为中间件都可以轻松切换处理,而且node作为中间层,还可以将多个后端接口组合成一整个数据集,最终以同步的方式渲染前端,这也利于做SEO优化,也是前面两种方式无法做到的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;关于前后端分离,详细可阅读&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://blog.jobbole.com/65513/?from=timeline&amp;amp;isappinstalled=0&quot;&gt;&lt;span&gt;前后端分离的思考与实践&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;,该文章详细的列述了关于前后端分离的实际经验&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;谈谈接口&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;随着前后端的分离,后端工程师不需要编写页面，不需要写JS,只需要提供接口即可,可是就是仅仅这一个接口，对于很多后端开发工程师而言，在实际开发，同前端对接的过程中,依然问题重重&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;很多后端同学说我只负责写接口,其他我一概不管,这样造成的后果就是&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;1、接口结构无序、杂乱无章&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;2、接口和实际业务场景不相匹配、不可用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;3、频繁的同前端沟通，简单的事情复杂化,前后端都很恼火&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;4、事情没做好&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;后端在编写接口前,首先是对业务的理解,在对业务未理解透彻之前,编码都是无意义的,作为后端来说,需要锻炼自己对整个系统全局考虑的能力,接口之间并非是毫无关联的,我们在写第一个接口之间,其他接口之间的业务逻辑也许考虑到，这在后端团队合作开发不同功能的情况下显得尤为重要.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;后端在开发接口时,我觉得主要从以下几个方面需要注意：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接口url 定义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接口类型、参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;全局错误码定义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接口json格式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接口文档编写&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;接口url定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;对于后端开发人员来说,接口前端入参,最终组合查询数据库资源，经过一系列相关业务场景下的计算，响应给前端json数据，每一层url的path定义需要清晰明了，这和后端在使用AOP定义事务管理同理，后端service需要满足一定的命名规范，这样方便统一管理，而且有这层规范后,后续的前后端对接会轻松很多&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;为了在许多API和长时间内提供一致的开发人员体验，API使用的所有名称应为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;简单&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;直觉&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;一致&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这包括接口，资源，集合，方法和消息的名称。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;由于许多开发人员不是英文母语人士，因此这些命名约定的目标之一是确保大多数开发人员能够轻松了解API。 它通过鼓励在命名方法和资源时使用简单，一致和小的词汇表来实现。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;API中使用的名称应该是正确的美国英语。例如，许可证（而不是许可证），颜色（而不是颜色）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;可以简单地使用常用的简短形式或长字的缩写。例如，API优于应用程序编程接口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;尽可能使用直观，熟悉的术语。例如，当描述删除（和销毁）资源时，删除是优先于擦除。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;对同一概念使用相同的名称或术语，包括跨API共享的概念。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;避免名称重载。为不同的概念使用不同的名称。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;仔细考虑使用可能与常用编程语言中的关键字冲突的名称。可以使用这些名称，但在API审查期间可能会触发额外的审查。谨慎和谨慎地使用它们。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;接口类型、参数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;关于接口的请求类型，目前比较常用的：&lt;/span&gt;&lt;span&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;code&gt;PATCH&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;GET（SELECT）：从服务器取出资源（一项或多项）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;POST（CREATE）：在服务器新建一个资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;DELETE（DELETE）：从服务器删除资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;后端可根据不同的业务场景定义不同的接口类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在定义接口参数之时,目前我们常用的几种提交方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;表单提交，application/x-www-form-urlencoded&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613480/201804/613480-20180422130134144-1785179258.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;表单提交主要针对&lt;/span&gt;&lt;span&gt;&lt;code&gt;key-value&lt;/code&gt;&lt;/span&gt;&lt;span&gt;的提交形式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如下Java片段：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@PostMapping(&quot;/queryAll&quot;)
public RestfulMessage queryAll(RuleCheckLogs ruleCheckLogs, @RequestParam(value = &quot;current_page&quot;,defaultValue = &quot;1&quot;)Integer current_page
            , @RequestParam(value = &quot;page_size&quot;,defaultValue = &quot;10&quot;)Integer page_size
            , @RequestParam(value = &quot;tableName&quot;,required = false) String tableName){
        RestfulMessage restfulMessage=new RestfulMessage();
        try{
            assertArgumentNotEmpty(ruleCheckLogs.getProjectId(),&quot;质检方案id不能为空&quot;); restfulMessage.setData(qcRuleCheckLogsService.queryRuleLogsByPage(ruleCheckLogs,tableName,current_page,page_size));
        }catch (Exception e){
            restfulMessage=wrapperException(e);
        }
        return restfulMessage;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;文件流提交&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;json提交,application/json&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613480/201804/613480-20180422130142870-1326942749.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;json提交方式在SpringMVC或Spring Boot中主要有两种,一种是以&lt;/span&gt;&lt;span&gt;&lt;code&gt;@RequestBody&lt;/code&gt;&lt;/span&gt;&lt;span&gt;注解接收方式，另外一种是以&lt;/span&gt;&lt;span&gt;&lt;code&gt;HttpEntity&amp;lt;String&amp;gt; requestEntity&lt;/code&gt;&lt;/span&gt;&lt;span&gt;字节接收&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Java代码示例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@PostMapping(&quot;/mergeModelEntitys&quot;)
public RestfulMessage mergeModelEntitys(HttpEntity&amp;lt;String&amp;gt; requestEntity){
    RestfulMessage restfulMessage=new RestfulMessage();
    try{
        JsonObject paramsJson = paramJson(requestEntity);
        assertJsonNotEmpty(paramsJson,&quot;请求参数不能为空&quot;);
        //more...
    }catch (Exception e){
        restfulMessage=wrapperException(e);
    }
    return restfulMessage;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;全局错误码定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;错误码的定义同HTTP请求状态码一样,对接者能通过系统定义的错误码,快速了解接口返回错误信息，方便排查错误原因&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
    &quot;code&quot;: &quot;8200&quot;,
    &quot;message&quot;: &quot;Success&quot;,
    &quot;data&quot;: {
        &quot;total_page&quot;: 1,
        &quot;current_page&quot;: 1,
        &quot;page_size&quot;: 10,
        &quot;count&quot;: 5,
        &quot;data&quot;: [
            {
                &quot;id&quot;: &quot;a29ab07f1d374c22a72e884d4e822b29&quot;,
                //......
            }//....
        ]
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;接口json格式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;后端响应json给前端需要注意以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;1、json格式需固定&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;例如如下图形&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613480/201804/613480-20180422130157069-353459856.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如上图所示,横向是时间,纵向是value值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我们给出的json结构应该如此：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[
    {
        &quot;date&quot;:&quot;2018-01&quot;,
        &quot;value&quot;:100
    },
    {
        &quot;date&quot;:&quot;2018-02&quot;,
        &quot;value&quot;:200
    }
    //more...
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在工作中,我们经常碰见这样的数据格式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[
    &quot;2018-01&quot;:{
    value:100
    },
    &quot;2018-02&quot;:{
    value:200
    }
    //more...
]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这里所说的json格式固定主要针对此种情况,后端给到前端的接口格式必须是固定的，所有动态数据值都需相应的key与之对应&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;2、所有返回接口数据需直接可用,越简单越好&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;后端提供给前端的接口数据,最终交给前端的工作，只需要让前端渲染数据即可,越简单越好，不因掺杂过多的业务逻辑让前端处理，所有复杂的业务逻辑，能合并规避掉的都需后端处理掉.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;接口文档编写&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接口文档编写是前后端对接重要依据，后端写明接口文档，前端根据接口文档对接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;文档形势目前主要分几种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;1、依赖swagger框架，自动生成接口文档（swagger只能生成基于key-value详细参数方式，针对json格式，无法说明具体请求内容）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;2、手动编写说明文档，推荐markdown编写&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;接口对接&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;万事俱备,只欠东风,虽然上面我们准备了所有我们该准备的，接口定义完美无缺,接口文档也已说明，但在对接时任然可能出现问题，此时我想我们还需注意的细节&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;1、后端接口需自行进行Junit单元测试&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Spring目前集成Junit框架可方便进行单元测试，包括对业务bean的方法测试，以及针对api的mock测试&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@RunWith(SpringRunner.class)
@SpringBootTest
public class QcWebApplicationTests {
​
@Autowired
private WebApplicationContext context;
​
private MockMvc mvc;
​
@Autowired
QcFieldService qcFieldService;
​
@Before
public void setUp() throws Exception {
        //初始化mock对象
mvc = MockMvcBuilders.webAppContextSetup(context).build();
}
​
@Test
public void queryByDsId(){
try {
            //针对mock-接口Controller层测试
mvc.perform(MockMvcRequestBuilders.post(&quot;/qc/entity/queryByDsId&quot;)
                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    .param(&quot;dsId&quot;, &quot;7d4c101498c742368ef7232f492b95bc&quot;)
                    .accept(MediaType.APPLICATION_JSON))
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andDo(MockMvcResultHandlers.print());
} catch (Exception e) {
e.printStackTrace();
}
}
    
    @Test
    public void testUpdateField(){
QcField qcField=new QcField();
qcField.setId(&quot;513ee55f5dc2498cb69b14b558bc73e6&quot;);
qcField.setShortName(&quot;密码&quot;);
        //业务bean-service方法测试
qcFieldService.updateBatchFields(Lists.newArrayList(qcField));
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;2、使用工具测试，推荐PostMan&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;作为接口调试神器,Postman大名想必大家都已知道&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;作为后端来说,我们需要学会查看chrome推荐给我们的审查元素的功能，可参看&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000683599&quot;&gt;&lt;span&gt;Chrome开发工具介绍&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;chrome提供了一个可以copy当前接口的url功能，最终生成curl命令行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613480/201804/613480-20180422130211850-965592528.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;最终通过&lt;/span&gt;&lt;span&gt;&lt;code&gt;Copy as cURL(bash)&lt;/code&gt;&lt;/span&gt;&lt;span&gt;功能可生成curl命令&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
curl 'http://demo.com/qc/ds/getAll' -H 'Origin: http://demo.com' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: zh-CN,zh;q=0.9' -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36' -H 'Content-Type: application/x-www-form-urlencoded' -H 'Accept: application/json, text/plain, */*' -H 'Referer: http://demo.com/index.html' -H 'Connection: keep-alive' --data 'current_page=1&amp;amp;page_size=6&amp;amp;' --compressed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;以上命令可以在Linux等各终端直接执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;curl命令&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://man.linuxde.net/ftp&quot;&gt;&lt;span&gt;ftp&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;postman提供导入curl命令行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613480/201804/613480-20180422130223222-1112090453.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;3、前后端需心平气和沟通，勿推卸责任，前后端开发人员水平不尽相同,作为同事,需要的是团结合作，努力将事情做好,而非相互推卸&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;前后端分离,简化了我们的开发方式,不同人专注于不同的领域,技术价值最大化,大大提高工作效率,我们在掌握这些技能的同时,也需要加强自身的发展,以适应当前的技术发展趋势,不管是前端还是后端,多了解一些，总是没错的,古人云：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;技多不压身&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，我想也正是此理！！！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 05:03:00 +0000</pubDate>
<dc:creator>xiaoymin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoymin/p/8906585.html</dc:identifier>
</item>
<item>
<title>使用Nwjs开发桌面应用体验 - 一级码农VIP</title>
<link>http://www.cnblogs.com/zhupengfei/p/8906131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhupengfei/p/8906131.html</guid>
<description>&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;79.5&quot;&gt;
&lt;p&gt;是骡子是马总要拉出来溜溜才知道，是吧。&lt;/p&gt;
&lt;p&gt;查了一下，目前用Nodejs开发桌面应用，主要有两种方案&lt;/p&gt;
&lt;p&gt;　　1.Electron&lt;/p&gt;
&lt;p&gt;　　Electron是一款利用Web技术开发跨平台桌面应用的框架。项目地址是:https://github.com/atom/electron&lt;/p&gt;
&lt;p&gt;　　2.NW.js&lt;/p&gt;
&lt;p&gt;　　NW.js是Intel的工程师写的一个基于node.js和chromium的应用程序运行环境。项目地址是：https://github.com/rogerwang/node-webkit&lt;/p&gt;

&lt;h3&gt;　　一、NW.js的下载&lt;/h3&gt;
&lt;p&gt;　　官网地址是：http://nwjs.io/&lt;/p&gt;
&lt;p&gt;　　进去之后，点击下载SDK的版本，并解压至本地目录即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422105925777-1145824800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里遇到一个郁闷的事，从官网上下载的0.30版本的zip包，怎么都打不开，提示压缩包有错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422105902215-45630697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 使用7zip也不行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422110005574-524400784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是从官网下载的，真是服了。下载了10几次都不行。。&lt;/p&gt;

&lt;p&gt;只能从其他网站下载了一个0.23的包使用。&lt;/p&gt;
&lt;h3&gt;　　二、应用编写&lt;/h3&gt;
&lt;p&gt;　　1.在nw.exe目录中创建一个helloworld的文件夹。&lt;/p&gt;
&lt;p&gt;　　新建index.html&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Hello zhupengfei!&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;helloworld.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按新建helloworld.js&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.write('Hello, World!');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　新建package.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{
  //应用的入口页面(也可以设置成js文件)
  &quot;main&quot;: &quot;index.html&quot;,
  //应用的名称
  &quot;name&quot;: &quot;HelloWorld&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2. 运行helloworld。&lt;/p&gt;
&lt;p&gt;　　a) 在nw.exe所在目录按下shift+鼠标右键，选择&quot;在此处打开命令窗口&quot;。然后输入nw helloworld即可看到运行效果。注意建议使用cmd，不要使用powershell。我使用powershell必须使用./nw 才可以。&lt;/p&gt;
&lt;p&gt;　　b) 可以直接将helloworld目录拖拽到nw.exe上同样也可以运行。&lt;/p&gt;
&lt;h3&gt;　　三、应用打包&lt;/h3&gt;
&lt;p&gt;　　一般windows的桌面应用都是exe可执行文件，是不依赖于其他文件和环境的。而我们创建的helloworld应用是依赖于nw.exe和相关文件的，那么如何将应用打包成一个可执行文件呢？&lt;/p&gt;
&lt;p&gt;　　经过google，果然是有解决方案的，那就是Enigma Virtual Box&lt;/p&gt;
&lt;p&gt;　　1. 下载Enigma Virtual Box&lt;/p&gt;
&lt;p&gt;　　地址是：http://enigmaprotector.com/en/downloads.html&lt;/p&gt;
&lt;p&gt;　　选择最后一个下载就可以了，然后安装。&lt;/p&gt;
&lt;p&gt;　　2. 将应用打包成helloworld.nw文件。&lt;/p&gt;
&lt;p&gt;　　进入到helloworld目录中，全选三个文件打包成zip，然后改名成helloworld.nw。&lt;/p&gt;
&lt;p&gt;　　(有一个坑，这里从网上看了说用WINRAR压缩成ZIP不行，必须用7-zip，所以这里直接通过。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/908341/201611/908341-20161125174606284-149497896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 合并helloworld.nw和nw.exe&lt;/p&gt;
&lt;p&gt;　　将helloworld.nw文件移动到和nw.exe同级目录下，然后执行命令，注意nw.exe必须在前面，不要弄反了，hello.exe运行会出错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
copy /b nw.exe+helloworld.nw hello.exe
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　发现多了一个hello.exe文件，双击发现是可以运行的。不过这还不是最终的结果，因为将hello.exe移动到其他文件夹之后，就不能正常执行了。&lt;/p&gt;

&lt;p&gt;　　4. 使用Enigma Virtual Box打包成exe，安装后可以语言中选择中文显示。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422110519592-1841519458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Input File Name选择刚才生成的hello，Output File Name就是输出文件。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;除了刚才合并的hello.exe文件，其他所有文件都需要添加进来，有一个快速的方法就是直接将所需的文件和文件夹，直接拖进来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422124615819-460040240.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422124814309-670917551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后点击右下角的&quot;执行封包&quot;按钮，&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/908341/201611/908341-20161125181310268-818039460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422111346331-813633888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;打包以后文件太大了，144M啊。我晕，这才只是个demo啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　看到上图结果，就说明执行成功了。&lt;/p&gt;
&lt;p&gt;　　找到打包后的文件，然后执行。&lt;/p&gt;
&lt;h3&gt;　　四、加密&lt;/h3&gt;
&lt;p&gt;加密必须使用SDK包，开始下载的是运行时包，不知道，后来下载了SDK包，才发现里面有nwjc.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422113433574-866001921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;增加加密字符串，又方便确认是否加密成功。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422123428387-76192698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行以下命令，将JS文件加密为bin文件&lt;/p&gt;
&lt;p&gt;$ cd helloworld&lt;/p&gt;
&lt;p&gt;$ ../nwjc.exe helloworld.js helloworld.bin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422113846908-1255102330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多了两个文件。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422123601772-940815452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 内容确实输出了。&lt;/p&gt;
&lt;p&gt; 然后按照上面相同的步骤，压缩zip修改为nw，然后合并，处理等等。&lt;/p&gt;
&lt;p&gt;个人总结：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人感觉两者都差不多吧，昨天用Electron做了一个demo，效果出来了。还不错。今天用Nwjs试一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么还要用Nwjs呢，原因是Electron目前无法支持代码保护，可以asar压缩，但是可以解压。做桌面应用多数还是商业项目，所以代码保护我认为是必须的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;昨天晚上看Electron的github里吵了半天，最后的结论是eclectron没有计划在项目中增加代码保护功能，原因是他们认为多数人用不到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我觉得做桌面应用还是选用传统的.net java C++等吧，像nodejs python说是全栈，其实最多还是能做桌面应用，真是要商用，还是差一些，最好慎重选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　遇到问题可以微信联系我哦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422110753176-1653176899.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者支付宝联系我&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801648/201804/801648-20180422110728477-1355164090.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Apr 2018 04:41:00 +0000</pubDate>
<dc:creator>一级码农VIP</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhupengfei/p/8906131.html</dc:identifier>
</item>
<item>
<title>详解vue移动端 下拉刷新 - 绯色璃</title>
<link>http://www.cnblogs.com/feiseli/p/8903880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feiseli/p/8903880.html</guid>
<description>&lt;p&gt;看完这篇文章，相信大伙也一样可以，做出一个自己的刷新，加载的组件&lt;/p&gt;
&lt;p&gt;说这个功能之前，大家要先了解一下，要怎么触发滚动条事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1009170/201804/1009170-20180421103712686-731838843.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       一定要注意，所有滚动事件都必须要满足这个条件，横向滚动条也一样，&lt;/p&gt;
&lt;p&gt;只要满足子元素宽度大于父元素宽度就可以了。（下篇文章会讲怎么实现一个横向滚动条）&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;接入正题！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先来看看怎么剖析这个下拉刷新。&lt;/p&gt;
&lt;p&gt;要用到的移动端的三个事件： touchstart(手指按下)，touchmove（手指移动），touchend（手指离开）&lt;/p&gt;
&lt;p&gt;下拉刷新也就是（touchstart =&amp;gt; touchmove(下移动) =&amp;gt;touchend）的一个过程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大体思路&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;       下拉主要与手指触摸y轴点有关&lt;/p&gt;
&lt;p&gt;       1.记录下手指按下y轴的坐标点&lt;/p&gt;
&lt;p&gt;       2.记录手指移动时，移动的距离（注意：要判断手指是向上移还是向下移，向上移就是滚动）&lt;/p&gt;
&lt;p&gt;       3.启动下拉刷新事件&lt;/p&gt;
&lt;p&gt;看代码：&lt;/p&gt;
&lt;p&gt;　　vue中要在methods里面注册事件，在绑定到父元素上，这里大家应该都是用vue-cli搭建的项目了吧！&lt;/p&gt;
&lt;p&gt;没有的话，我回头给个链接给大家，里面有已经搭建好的项目结构。包含这个插件的源码，demo都在里面&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;em&gt;&amp;lt;template&amp;gt;&lt;br/&gt;　　&amp;lt;div class=&quot;parent&quot;&amp;gt;&lt;br/&gt;　　　　&amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br/&gt;　　&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;export default {&lt;br/&gt;　　data(){&lt;br/&gt;　　　　return {&lt;br/&gt;　　　　　　top: 0,&lt;br/&gt;　　　　　　startY: 0,          // 保存 y轴点的位置&lt;br/&gt;　　　　　　touching: false,   // 代表当前是否处于 下拉刷新行为的开关，也就是当属于滚动行为时，就要退出该事件机制&lt;br/&gt;　　　　}　　&lt;br/&gt;　　},&lt;br/&gt;　　methods: {&lt;br/&gt;　　　　touchStart(e) {&lt;br/&gt;　　　　　　// e代表该事件对象，&lt;/em&gt;e.targetTouches[0].pageY可以拿到手指按下的 y轴点&lt;br/&gt;　　　　　　this.startY = e.targetTouches[0].pageY&lt;br/&gt;　　　　　　// 开启下拉刷新状态&lt;br/&gt;　　　　　　this.touching = true&lt;br/&gt;　　　　　　
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;em&gt;　　　　},&lt;br/&gt;　　　　touchMove(e) {&lt;br/&gt;　　　　 //这个 touchMove，只要页面在动都会发生的，所以 touching就起作用了&lt;br/&gt;　　　　　　// 如果 touching为false，说明这个正在移动的页面不是我们想要的下拉刷新，有可能是用户随意拉了一下页面而已，或者其他&lt;br/&gt;　　　　　　if(!this.touching) return&lt;br/&gt;　　　　　　// 获取移动的距离&lt;br/&gt;　　　　　　let diff = e.targetToc=uches[0].pageY - this.startY &lt;br/&gt;　　　　　　//判断是向上拉还是向下拉 &lt;br/&gt;　　　　　　if(diff &amp;gt;０) { &lt;br/&gt;　　　　　　　　e.preventDefault()&lt;br/&gt;　　　　　　} else {&lt;br/&gt;　　　　　　　　return 　　&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　//这个this.top要对应绑定到该元素的transform: translateY(+top+ 'px')上，不然是无法拉动的&lt;br/&gt;　　　　　　// 因此这里还要对偏移高度做一下处理，直接设置diff +&lt;/em&gt;&lt;/em&gt;&lt;em&gt;&lt;em&gt;(this.state === 2 ? 40 : 0) 太快了，因为拉取幅度太大&lt;br/&gt;　　　　　　// 让diff*0.25这样子就差不多了&lt;br/&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　　　　　　this.top = &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;Math.floor(diff*0.25)&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; + (this.state === 2 ? 40 : 0)&lt;br/&gt;　　　　　　if（this.top &amp;gt;= 40）{&lt;br/&gt;　　　　　　　　this.state = 1   //代表正在拉取&lt;br/&gt;　　　　　　} else {&lt;br/&gt;　　　　　　　　this.state = 0  // 代表初始转态&lt;br/&gt;　　　　　　}&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　}，&lt;br/&gt;　　　　touchEnd(e) {&lt;br/&gt;　　　　　　this.touching = false&lt;br/&gt;　　　　　　if(this.state === 2) {&lt;br/&gt;　　　　　　　　this.top = 40&lt;br/&gt;　　　　　　　　return &lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　// 判断抬起时的高度，是大于40 就开启刷新&lt;br/&gt;　　　　　　if(this.top &amp;gt;= 40) {&lt;br/&gt;　　　　　　　　this.refresh()&lt;br/&gt;　　　　　　} else {&lt;br/&gt;　　　　　　　　this.state = 0&lt;br/&gt;　　　　　　　　this.top = 0&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　},&lt;br/&gt;　　　　refresh() {&lt;br/&gt;　　　　　　this.state = 2&lt;br/&gt;　　　　　　this.top = 40&lt;br/&gt;　　　　　　const self = this&lt;br/&gt;　　　　　　// 这里可以调用父组件的方法去请求刷新接口&lt;br/&gt;　　　　　　this.$emit('getRefresh', function(self){&lt;br/&gt;　　　　　　　　//传个回调过去，请求完数据就复原&lt;br/&gt;　　　　　　　　self.state = 0&lt;br/&gt;　　　　　　　　self.top = 0&lt;br/&gt;　　　　　　})&lt;br/&gt;　　　　}&lt;br/&gt;　　}&lt;p&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1009170/201804/1009170-20180422113214945-1679530729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里就完结了，当然现在肯定不能直接用的，要结合你的实际业务逻辑来用的，&lt;/p&gt;
&lt;p&gt;我把demo放到github上了 ：&lt;/p&gt;
&lt;p&gt;https://github.com/13725102796/css3-demo/blob/master/src/plugins/scroll/scroll.vue&lt;/p&gt;
&lt;p&gt;看不懂的，建议整个项目拉下拉，跑一下，里面还有检验的插件，弹窗的等等，都是我在项目中用到，再抽出来的。&lt;/p&gt;
&lt;p&gt;方法： &lt;em id=&quot;__mceDel&quot;&gt;git clone https://github.com/13725102796/css3-demo.git&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;同时，也欢迎各位提提 issues，或者各位想扩展一些其它的插件都可以。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最后，别忘了给个star！与君互勉，一起啃砖！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下一篇就讲怎么做这个滚动加载！！！&lt;/em&gt;&lt;/p&gt;




</description>
<pubDate>Sun, 22 Apr 2018 04:34:00 +0000</pubDate>
<dc:creator>绯色璃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feiseli/p/8903880.html</dc:identifier>
</item>
</channel>
</rss>