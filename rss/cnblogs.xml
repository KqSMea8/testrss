<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>爬虫基础（二）——网页 - 南宫恨</title>
<link>http://www.cnblogs.com/ydkh/p/10012790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ydkh/p/10012790.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　爬虫要爬取的信息主要来自于网页加载的内容，有必要了解一些网页的知识。&lt;/p&gt;
&lt;p&gt;  当我们在浏览器网址栏输入一个网址——URL，经过TCP/IP协议簇的处理，这个网址请求的信息就被发送到URL对应的服务器，接着服务器处理这个请求，并将请求的内容返回给浏览器，浏览器便显示或者下载URL请求相应的资源。这是前一篇博客所述。&lt;/p&gt;
&lt;p&gt;  在这一篇博客，笔者尝试说明浏览器是如何显示出这个页面的。如下&lt;/p&gt;
&lt;h2&gt;HTML&lt;/h2&gt;
&lt;h3&gt;HTML的含义&lt;/h3&gt;
&lt;p&gt;  与超文本相对的是线性文本。线性，即直线关系，成比例。一本书，从第一页到最后一页，呈现直线关系；一本书的书签，从第一章转跳至第十章，呈现的是非线性关系。对于线性的计算机文件，不能直接从从一个位置的文件非线性地转至另一个位置的文件，这中间是要经过一定的顺序；相反，超文本之间的关系是非线性的，从一个HTML文件可以直接连接至另一个HTML文件。促成这种连接的正是是超文本链接，超文本链接就是超链接，上一篇的URL就是超链接的一种，电子书中的书签也是超链接的一种。&lt;/p&gt;
&lt;p&gt;  HTML是一门语言，常用于编写网页，HTML文件是超文本的一种形式。以下是一些名称的解释，以辅助理解，不必太在意于严格的定义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTML(HyperText Mark-up Language)：超文本标记语言&lt;/li&gt;
&lt;li&gt;超文本：HyperText，用超链接的方法，将不同空间的文字信息组织在一起的网状文本&lt;/li&gt;
&lt;li&gt;链接：link，从一个文档指向其它文档或从文本锚点(anchor)指向某已命名位置的链接&lt;/li&gt;
&lt;li&gt;锚点：anchor，是网页制作中超级链接的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接&lt;/li&gt;
&lt;li&gt;超链接：hyperlink，它是一种允许我们同其他网页或站点之间进行连接的页面元素&lt;/li&gt;
&lt;li&gt;超文本链接：Hypertext link，就是超链接。是指用文字链接的形式来指向一个页面&lt;/li&gt;
&lt;li&gt;线性：linear，指量与量之间按比例、成直线的关系，在数学上可以理解为一阶导数为常数的函数&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;树&lt;/h3&gt;
&lt;h4&gt;树的概念&lt;/h4&gt;
&lt;p&gt;  树的结构是很简单的，平时留心观察即可知道树为何是“直”的。从第一个分叉开始这树就是由无数的“开叉”结构组成，直至最微小的枝芽。怎么简单怎么来，数学上的描述不管。下面的性质和定义来自《用Python解决数据结构和算法》&lt;/p&gt;
&lt;h4&gt;树的性质&lt;/h4&gt;
&lt;p&gt;  相关术语在“定义1”里面有解释，以分类树为例 此处有图片&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;树是分层的，分层的意思是树的顶层部分更加宽泛一般而底层部分更加精细具体。在图1中，最上层是“界”，它下面的一层（上层的子层）是“门”，然后是“纲”等等。&lt;/li&gt;
&lt;li&gt;一个节点的子节点（node）和另一个节点的子节点（children）是完全独立的。如图1，“猫属”有两个子节点“家生”和“野生”，“蝇属”中也有一个“家生”， 但它和“猫属”中的“家生”是完全不同而且相互独立的。&lt;/li&gt;
&lt;li&gt;树的每个叶节点（leaf）都是不同的。如图1，对每一种动物，我们都可以从根节点（root）开始沿着一条特定的路径找到它对应的叶节点，并把它和其他动物区分开， 例如对于家猫&lt;/li&gt;
&lt;li&gt;树下层的所有部分（子树Subtree）移动到树的另一位置而不影响更下层的情况。如图2，我们可以将所有标注/etc的子树从根节点下移动到usr/下面但是对httpd的内容及其子节点的内容不会有影响。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124185808789-1684937044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图1 一些动物的分类树&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124185946044-1061338903.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;图2 一小部分Unix文件系统的分层情况&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;定义1&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;strong&gt;树是节点和连接节点的边的集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  这个定义简单粗暴，但蕴含的东西不少。以下是一些相关的东西，都是些抽象的概念，将其类比成枝节叶可以吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节点（Node）：树的基本组成&lt;/li&gt;
&lt;li&gt;边（Edge）：树的基本组成，连接两个节点。。每个节点（除了根节点）都有且只有一条与其他节点相连的入边（指向该节点的边），每个节点可能有许多条出边（从该节点指向其他节点的边）。&lt;/li&gt;
&lt;li&gt;根节点（Root）：树中唯一没有入边的节点&lt;/li&gt;
&lt;li&gt;路径（Path）：路径是由边连接起来的节点的有序排列&lt;/li&gt;
&lt;li&gt;子节点集（Childern）：当一个节点的入边来自于另外一个节点时，称前者为后者的子节点。同一个节点的所有子节点构成子节点集&lt;/li&gt;
&lt;li&gt;父节点（Parent）：一个节点是它的所有出边连接的节点的父节点。&lt;/li&gt;
&lt;li&gt;兄弟节点（Sibling）同一节点的所有子节点胡伟兄弟节点&lt;/li&gt;
&lt;li&gt;子树（Subtree）：子树是一个父节点的某个子节点的所有边和后代节点所构成的集合&lt;/li&gt;
&lt;li&gt;叶节点（LeafNode）：没有子节点的节点称为叶节点&lt;/li&gt;
&lt;li&gt;层数（Level）：一个节点的层数是指从跟节点到该节点的路径的边的数目，定义根节点层数为0&lt;/li&gt;
&lt;li&gt;高度（Height）：树的高度等于所有节点层数的最大值&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;定义2&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;strong&gt;每棵树为空，或者包含一个根节点和0个或多个子树，其中每个子树也符合这样的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  这个定义巧妙，用到递归只能“巧妙”了。&lt;/p&gt;
&lt;h3&gt;HTML的构成&lt;/h3&gt;
&lt;p&gt;  HTML是由一系列的元素组成，元素由首尾标签和其中的内容组成，学习HTML就要学习那一堆元素。标签表示元素的起始和结束。下面是一个简单的HTML网页。例如代下面代码中&lt;/p&gt;
&lt;p&gt;&amp;lt;li&amp;gt;List item one&amp;lt;/li&amp;gt;是元素，&amp;lt;li&amp;gt;是首标签，&amp;lt;/li&amp;gt;是尾标签，'List item one'是内容。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt; xml:lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt; lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;simple&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A simple web page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;List item one&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;List item two&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cs.luther.edu&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Luther CS &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  这个网页也相当于一棵树，树的每一层都对应超文本标记符的一层嵌套。如图3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124190353932-1354695843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图3 与网页的构成元素相对应的树&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;DOM&lt;/h3&gt;
&lt;p&gt;  DOM（Document Object Model），文档对象模型。当浏览器要显示HTML文档网页的时候，浏览器会创建这个网页全部元素的内部表示体系——DOM，类似于地图表示实际的地点一样，DOM也可以看做是这个HTML网页的“地图”，我们可以通过JavaScript（例如父子对象的形式）去读取DOM这张“地图”。在DOM里面，网页的所有元素以父子对象等形式形成树形结构，这棵树最顶层的是浏览器window对象（如图4），window对象的一个子对象是document对象，一个HTML文档被加载到浏览器的时候，都会创建一个document对象，这个对象包含了HTML文档的全部元素，同样HTML的内容也会表示成树形结构（如图3）&lt;/p&gt;
&lt;p&gt;  当DOM把网页表示成“树”的形式（如图3）时，每个元素都相当于树的节点（元素节点），每个属性也相当一个节点（属性节点），文本也是（文本节点），属性节点和文本节点包含在元素节点中。边表示了元素间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124190622808-1820019762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图4 window对象及其一些子对象&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;CSS&lt;/h2&gt;
&lt;p&gt;  通过DOM模型，浏览器就知道如何去显示一个HTML网页的title，h1，body，ul······，但这并不是唯一的方式，我们同样可以通过CSS(Cascading Style Sheets)层级样式表去告诉浏览器该如何去显示一个网页文档，实际上浏览器也会根据外部样式表去构建一棵“树”——CSSOM（CSS Object Model，CSS 对象模型）。&lt;/p&gt;
&lt;p&gt;  CSS是一种样式表语言，用于为HTML文档定义布局。例如，设置字体、颜色、边距、高度、宽度、背景图像等等。爬虫中经常用到CSS选择器。&lt;/p&gt;
&lt;h3&gt;添加CSS的方法&lt;/h3&gt;
&lt;h4&gt;行内样式表&lt;/h4&gt;
&lt;p&gt;  为HTML应用CSS的一种方法是使用HTML属性style。例如下面代码，通过行内样式表将页面背景设为红色，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;例子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;background-color: #FF0000;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这个页面是红色的&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;内部样式表&lt;/h4&gt;
&lt;p&gt;  为HTML应用CSS的另一种方法是采用HTML元素style。代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;例子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     body &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FF0000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;        
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这个页面是红色的&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;外部样式表&lt;/h4&gt;
&lt;p&gt;  外部样式表就是一个扩展名为css的文本文件。如何在一个HTML文档里引用一个外部样式表文件（style.css）呢？可以在HTML文档里创建一个指向外部样式表文件的链接（link）即可，就像下面代码那样，其中href=&quot;style/style.css是CSS文件的路径，要注意的就是外部样式表的路径问题，详略。 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;style/style.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CSS构造样式规则&lt;/h3&gt;
&lt;p&gt;  样式表中包含了定义网页外观的规则，样式表中的每条规则都有两个主要部分：选择器（selector）和声明块（declaration block）。选择器的作用在于定位以及决定哪些元素受到影响；声明块由一个或多个属性- 值对（每个属性-值对构成一条声明，declaration）组成，它们指定应该做什么（参见图5 ～图6）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124191553565-911238200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　构造样式规则的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入selector ，这里的selector 表示希望进行格式化的元素。&lt;/li&gt;
&lt;li&gt;输入{（前花括号）开始声明块。&lt;/li&gt;
&lt;li&gt;输入property:value; ,其中property是CSS 属性的名称，描述要应用哪种格式；value 是该属性允许的选项之一。&lt;/li&gt;
&lt;li&gt;根据需要，重复第(3) 步。通常一行输入一个property: value（一条声明），如图6所示的那样，但这并非强制要求。&lt;/li&gt;
&lt;li&gt;输入}，结束声明块和样式规则。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;CSS选择器&lt;/h3&gt;
&lt;p&gt;  由于选择器具有定位作用，例如所以利用选择器就可以定位到我们想提取的数据，因此，CSS选择器经常在爬虫中出现。常见的CSS选择器语法规则如图7，&lt;a title=&quot;见W3C链接&quot; href=&quot;http://www.w3school.com.cn/cssref/css_selectors.asp&quot;&gt;见W3C链接&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124191626461-473935059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图7 一些CSS选择器的语法规则&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;CSS选择器的应用&lt;/h3&gt;
&lt;h4&gt;在Beautiful Soup中的应用&lt;/h4&gt;
&lt;p&gt;  例如如果爬取到下面这段HTML代码，就可以通过CSS选择器去提取，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
html_doc = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p class=&quot;title&quot;&amp;gt;&amp;lt;b&amp;gt;The Dormouse's story&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;Once upon a time there were three little sisters; and their names were
&amp;lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
&amp;lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; and
&amp;lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;;
and they lived at the bottom of a well.&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup
soup &lt;/span&gt;= BeautifulSoup(html_doc, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择所有title标签,结果是一个列表，可迭代&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择body标签下的所有a标签，并获取文本&lt;/span&gt;
results = soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.get_text())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过id查找 选择a标签，其id属性为link1的标签&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a#link1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择所有p标签中的第三个标签&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p:nth-of-type(3)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相当于soup.select(p)[2]&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 选择a标签，其href属性以lacie结尾&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a[href$=&quot;lacie&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其href属性包含.com&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a[href*=&quot;.com&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过【属性】查找,选择a标签，其属性中存在myname的所有标签&lt;/span&gt;
a = soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a[myname]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其属性href=http://example.com/lacie的所有标签&lt;/span&gt;
b = soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a[href='http://example.com/lacie']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其href属性以http开头&lt;/span&gt;
c = soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a[href^=&quot;http&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(c)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('292bf443-d7cd-4ad3-bf48-667b2ac48155')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_292bf443-d7cd-4ad3-bf48-667b2ac48155&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_292bf443-d7cd-4ad3-bf48-667b2ac48155&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('292bf443-d7cd-4ad3-bf48-667b2ac48155',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_292bf443-d7cd-4ad3-bf48-667b2ac48155&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择body标签下的直接a子标签&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body &amp;gt; a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择id=link1后的所有兄弟节点标签&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#link1~.mysis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择id=link1后的下一个兄弟节点标签&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#link1 + .mysis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其类属性为mysis的标签&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.mysis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从html中排除某标签，此时soup中不再有script标签&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;([s.extract()&lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt; soup(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果想排除多个呢&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;([s.extract()&lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt; soup([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fram&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])])
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;在pyquery中的应用&lt;/h4&gt;
&lt;p&gt;  例如如果爬取到下面这段HTML代码，就可以通过CSS选择器去提取，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
html = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div class=&quot;wrap&quot;&amp;gt;
    &amp;lt;div id=&quot;container&quot;&amp;gt;
        &amp;lt;ul class=&quot;list&quot;&amp;gt;
             &amp;lt;li class=&quot;item-0&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-0 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-1 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;/ul&amp;gt;
     &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
doc &lt;/span&gt;=&lt;span&gt; pq(html)
a &lt;/span&gt;= doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-0.active a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先获取class为item-0 且class为active的li标签内的a标签节点，再提取属性&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, type(a))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取到的结果为链接路径： link3.html&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a.attr.href)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.text())                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取文本，获得a节点的wb&lt;/span&gt;
li = doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-0.active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(li.html())               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; html()返回该节点的所有文本，包括标签a的开始和结束&lt;/span&gt;
lt = doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(lt.html())               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只返回第一个li的文本，欲获取全部需要遍历&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(lt.text())               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回所有li的文本，用空格隔开，结果是字符串类型&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(lt.text()))
b &lt;/span&gt;= doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b, type(b))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b.attr.href)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; attr（）方法只会得到第一个节点的属性，这时，需要遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; b.items():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(item.attr.href)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
html = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div id=&quot;container&quot;&amp;gt;
    &amp;lt;ul class=&quot;list&quot;&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
doc &lt;/span&gt;=&lt;span&gt; pq(html)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#container .list li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#container .list li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))
items &lt;/span&gt;= doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(items.text())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(items.text()))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(items)
lis &lt;/span&gt;= items.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(lis)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(items))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(lis))
ls &lt;/span&gt;= items.children()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回子节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ls)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(ls))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;  这里只说两点，ajax和渲染，因为爬虫经常碰到&lt;/p&gt;
&lt;h3&gt;渲染——浏览器如何显示页面&lt;/h3&gt;
&lt;p&gt;　　到目前为止，已经了解到浏览器在加载HTML的时候，先解析HTML文档，然后生成HTML树——DOM，同时浏览器生成了另外一棵树——CSSOM，这两个模型共同创建“渲染树”，之后浏览器就有了足够的信息去进行布局，并在屏幕上绘制页面。如果这里没有外部样式表也没有行内或者内部样式表（前面所述），也无需操心，因为浏览器本身也自带了一个默认的CSS样式表，只不过我们自定义的CSS样式表会将它覆盖而已。这里的“绘制的页面”就是要显示的页面，暂且理解成编程中的“print”吧，这里的一些奇怪的问题（比如：“浏览器显示HTML文档首尾标签去哪里啦？）”都可以类比print函数中的一些问题（“引号去哪里了？”）来看待，因为浏览器的显示和print函数是的目的都是将内容显示到电脑屏幕！只不过这里的绘制不是普通打印而是&lt;strong&gt;“彩打”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;渲染的过程如下（图片来自&lt;a title=&quot;这里&quot; href=&quot;https://baijiahao.baidu.com/s?id=1593097105869520145&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181125224310378-1064573937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　为什么渲染还和JavaScript有关呢？是的，单单是HTML和CSS就可以显示出网页，但JavaScript却有更强大的功能，其实JavaScript就是网页源代码中的一个脚本，他在浏览器显示页面的时候可以改变这个页面的布局和内容，也就是改变DOM和CSSOM的能力，从而改变了网页的显示。 &lt;/p&gt;
&lt;h3&gt;ajax&lt;/h3&gt;
&lt;p&gt;　　Ajax是一种无需刷新页面即可从服务器（或客户端）上加载数据的手段，这里的刷新是指重新请求，重新下载页面。而Ajax却可以在不刷新的情况下加载数据，从而给人一种“流畅”的感觉。但ajax只是其中的一种手段，例如上面提到的JavaScript渲染也是这样的一种手段。那么ajax是如何实现这种效果的呢？既然加载了数据那么肯定是向服务器发送了请求，那么如何做到不显示新的页面呢？答案是XMLHttpRequest（XHR）对象，它可以实现这种方式。既然是对象当然就有类似于“send()”等方法向服务器发送请求，然后接受到服务器响应的内容，接下来avaScript就会解释并处理这些内容，然后渲染网页，继而浏览器将数据显示出来。因此在爬虫的时候要想爬取这种动态加载的数据，就需要在开发者工具中去找寻这些新的URL请求，然后再在程序中模拟这种请求，再提取数据。就这样先吧。代码来自&lt;a title=&quot;W3C&quot; href=&quot;http://www.w3school.com.cn/tiy/t.asp?f=ajax_post&quot; target=&quot;_blank&quot;&gt;W3C&lt;/a&gt;如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadXMLDoc()
{
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; xmlhttp;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (window.XMLHttpRequest)
  {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; code for IE7+, Firefox, Chrome, Opera, Safari&lt;/span&gt;
&lt;span&gt;  xmlhttp&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
  }
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
  {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; code for IE6, IE5&lt;/span&gt;
&lt;span&gt;  xmlhttp&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveXObject(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.XMLHTTP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
xmlhttp.onreadystatechange&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;()
  {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (xmlhttp.readyState&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; xmlhttp.status&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)
    {
    document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDiv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;xmlhttp.responseText;
    }
  }
xmlhttp.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/ajax/demo_post.asp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
xmlhttp.send();
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AJAX&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;loadXMLDoc()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请求数据&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myDiv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　周末结束了！以上。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:42:00 +0000</pubDate>
<dc:creator>南宫恨</dc:creator>
<og:description>前言 爬虫要爬取的信息主要来自于网页加载的内容，有必要了解一些网页的知识。 当我们在浏览器网址栏输入一个网址——URL，经过TCP/IP协议簇的处理，这个网址请求的信息就被发送到URL对应的服务器，接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ydkh/p/10012790.html</dc:identifier>
</item>
<item>
<title>Dubbo 源码解析四 —— 负载均衡LoadBalance - 王守昌</title>
<link>http://www.cnblogs.com/wangshouchang/p/10018141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshouchang/p/10018141.html</guid>
<description>&lt;p&gt;欢迎来我的 &lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo&quot;&gt;Star&lt;/a&gt; &lt;a href=&quot;https://github.com/wsccoder&quot;&gt;Followers&lt;/a&gt; 后期后继续更新Dubbo别的文章&lt;/p&gt;
&lt;h5 id=&quot;dubbo-源码分析系列之一环境搭建&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/wangshouchang/p/9694197.html&quot;&gt;Dubbo 源码分析系列之一环境搭建&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;dubbo-入门之二---项目结构解析&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/wangshouchang/p/9800659.html&quot;&gt;Dubbo 入门之二 ——- 项目结构解析&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;dubbo-源码分析系列之三-架构原理&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/wangshouchang/p/9812757.html&quot;&gt;Dubbo 源码分析系列之三 —— 架构原理&lt;/a&gt;&lt;/h5&gt;
&lt;h2 id=&quot;技术点&quot;&gt;技术点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;面试中Dubbo负载均衡常问的几点&lt;/li&gt;
&lt;li&gt;常见负载均衡算法简介&lt;/li&gt;
&lt;li&gt;Dubbo 官方文档介绍&lt;/li&gt;
&lt;li&gt;Dubbo 负载均衡的策略&lt;/li&gt;
&lt;li&gt;Dubbo 负载均衡源码解析&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;面试中dubbo负载均衡常问的几点&quot;&gt;面试中Dubbo负载均衡常问的几点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;谈谈dubbo中的&lt;code&gt;负载均衡算法&lt;/code&gt;及特点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最小活跃数&lt;/code&gt;算法中是如何统计这个活跃数的&lt;/li&gt;
&lt;li&gt;简单谈谈你对&lt;code&gt;一致性哈希算法&lt;/code&gt;的认识&lt;/li&gt;
&lt;li&gt;Dubbo默认的负载均衡策略是什么， 为什么使用 RandomLoadBalance 随机负载均衡算法&lt;/li&gt;
&lt;li&gt;谈谈几种负载均衡的优缺点&lt;/li&gt;
&lt;li&gt;如果让你设计负载均衡你将如何设计&lt;/li&gt;
&lt;li&gt;源码负载均衡你学到了什么&lt;/li&gt;
&lt;li&gt;有没有将Dubbo的负载均衡的原理使用在实际的项目中&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;常见负载均衡算法简介&quot;&gt;常见负载均衡算法简介&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;首先引出一点 负载均衡的目的是什么？&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当一台服务器的承受能力达到上限时，那么就需要多台服务器来组成集群，提升应用整体的吞吐量，那么这个时候就涉及到如何合理分配客户端请求到集群中不同的机器，这个过程就叫做负载均衡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面简单介绍几种负载均衡算法，有利于理解源码中为什么这样设计&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;权重随机算法&quot;&gt;权重随机算法&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;策略就是根据权重占比随机。算法很简单，就是一根数轴。然后利用伪随机数产生点，**看点落在了哪个区域从而选择对应的&lt;em&gt;服务器&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/3/163c5bfda5fe150f?imageslim&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;权重轮询算法&quot;&gt;权重轮询算法&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;轮询算法是指依次访问可用服务器列表，其和随机本质是一样的处理，在无权重因素下，轮询只是在选数轴上的点时采取自增对长度取余方式。有权重因素下依然自增取余，再看选取的点落在了哪个区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一致性hash负载均衡算法&quot;&gt;一致性Hash负载均衡算法&lt;/h3&gt;
&lt;p&gt;利用Hash算法定位相同的服务器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;普通的Hash&lt;/strong&gt;：当客户端请求到达是则使用 hash(client) % N,其中N是服务器数量，利用这个表达式计算出该客户端对应的Server处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性Hash&lt;/strong&gt;：一致性Hash是把服务器分布变成一个环形，每一个hash(clinet)的结果会在该环上顺时针寻找第一个与其邻的&lt;code&gt;Server&lt;/code&gt;节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34969168&quot;&gt;一致性Hash算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;—————————— 下面这部分是来源于dubbo 官方文档 ------------------------------------&lt;/p&gt;
&lt;h2 id=&quot;dubbo-官方文档介绍&quot;&gt;Dubbo 官方文档介绍&lt;/h2&gt;
&lt;h3 id=&quot;负载均衡&quot;&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 Random LoadBalance 随机调用&lt;/p&gt;
&lt;h3 id=&quot;负载均衡策略&quot;&gt;负载均衡策略&lt;/h3&gt;
&lt;h3 id=&quot;random-loadbalance&quot;&gt;Random LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;随机&lt;/strong&gt;，按权重设置随机概率。&lt;/li&gt;
&lt;li&gt;在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;roundrobin-loadbalance&quot;&gt;RoundRobin LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;轮询&lt;/strong&gt;，按公约后的权重设置轮询比率。&lt;/li&gt;
&lt;li&gt;存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;leastactive-loadbalance&quot;&gt;LeastActive LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最少活跃调用数&lt;/strong&gt;，相同活跃数的随机，活跃数指调用前后计数差。&lt;/li&gt;
&lt;li&gt;使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;consistenthash-loadbalance&quot;&gt;ConsistentHash LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性 Hash&lt;/strong&gt;，相同参数的请求总是发到同一提供者。&lt;/li&gt;
&lt;li&gt;当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。&lt;/li&gt;
&lt;li&gt;算法参见：&lt;a href=&quot;http://en.wikipedia.org/wiki/Consistent_hashing&quot; class=&quot;uri&quot;&gt;http://en.wikipedia.org/wiki/Consistent_hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;缺省只对第一个参数 Hash，如果要修改，请配置 &lt;code&gt;&amp;lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缺省用 160 份虚拟节点，如果要修改，请配置 &lt;code&gt;&amp;lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;h3 id=&quot;服务端服务级别&quot;&gt;服务端服务级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;客户端服务级别&quot;&gt;客户端服务级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务端方法级别&quot;&gt;服务端方法级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:service interface=&quot;...&quot;&amp;gt;
    &amp;lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&amp;gt;
&amp;lt;/dubbo:service&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;客户端方法级别&quot;&gt;客户端方法级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:reference interface=&quot;...&quot;&amp;gt;
    &amp;lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&amp;gt;
&amp;lt;/dubbo:reference&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;———————————————— Dubbo 官方文档已结束 ------------------------------------------&lt;/p&gt;
&lt;h2 id=&quot;dubbo-负载均衡的策略&quot;&gt;Dubbo 负载均衡的策略&lt;/h2&gt;
&lt;blockquote readability=&quot;3.2291666666667&quot;&gt;
&lt;p&gt;上面官网文档已经说明 Dubbo 的负载均衡算法总共有4种&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我们先看下接口的继承图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1041678-2a60b5d43333fa71.png?imageMogr2/auto-orient/&quot; alt=&quot;类继承结构&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;loadbalance&quot;&gt;LoadBalance&lt;/h3&gt;
&lt;p&gt;首先查看 LoadBalance 接口&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Invoker select(List&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/mock/MockLoadBalance.java&quot;&gt;LoadBalance&lt;/a&gt; 定义了一个方法就是从 invokers 列表中选取一个&lt;/p&gt;
&lt;h3 id=&quot;abstractloadbalance&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java&quot;&gt;AbstractLoadBalance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java&quot;&gt;AbstractLoadBalance&lt;/a&gt; 抽象类是所有负载均衡策略实现类的父类，实现了LoadBalance接口 的方法，同时提供抽象方法交由子类实现，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; select(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
        if (invokers == null || invokers.size() == 0)
            return null;
        if (invokers.size() == 1)
            return invokers.get(0);
        return doSelect(invokers, url, invocation);
    }

    protected abstract &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下面对四种均衡策略依次解析&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;randomloadbalance随机&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java&quot;&gt;RandomLoadBalance&lt;/a&gt;(随机)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;随机&lt;/strong&gt;，按权重设置随机概率。&lt;/li&gt;
&lt;li&gt;在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java&quot;&gt;RandomLoadBalance#doSelect()&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
    //先获得invoker 集合大小
    int length = invokers.size(); // Number of invokers
    //总权重
    int totalWeight = 0; // The sum of weights
    //每个invoker是否有相同的权重
    boolean sameWeight = true; // Every invoker has the same weight?
    // 计算总权重
    for (int i = 0; i &amp;lt; length; i++) {
        //获得单个invoker 的权重
        int weight = getWeight(invokers.get(i), invocation);
        //累加
        totalWeight += weight; // Sum
        if (sameWeight &amp;amp;&amp;amp; i &amp;gt; 0 &amp;amp;&amp;amp; weight != getWeight(invokers.get(i - 1), invocation)) {
            sameWeight = false;
        }
    }
    // 权重不相等，随机后，判断在哪个 Invoker 的权重区间中
    if (totalWeight &amp;gt; 0 &amp;amp;&amp;amp; !sameWeight) {
        // 随机
        // If (not every invoker has the same weight &amp;amp; at least one invoker's weight&amp;gt;0), select randomly based on totalWeight.
        int offset = ThreadLocalRandom.current().nextInt(totalWeight);
        // 区间判断
        // Return a invoker based on the random value.
        for (int i = 0; i &amp;lt; length; i++) {
            offset -= getWeight(invokers.get(i), invocation);
            if (offset &amp;lt; 0) {
                return invokers.get(i);
            }
        }
    }
    // 权重相等，平均随机
    // If all invokers have the same weight value or totalWeight=0, return evenly.
    return invokers.get(ThreadLocalRandom.current().nextInt(length));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;假定有3台dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=2&lt;br/&gt;10.0.0.1:20886, weight=3&lt;br/&gt;10.0.0.1:20888, weight=4&lt;br/&gt;随机算法的实现：&lt;br/&gt;totalWeight=9;&lt;br/&gt;假设offset=1（即random.nextInt(9)=1）&lt;br/&gt;1-2=-1&amp;lt;0？是，所以选中 10.0.0.1:20884, weight=2&lt;/p&gt;
&lt;p&gt;假设offset=4（即random.nextInt(9)=4）&lt;br/&gt;4-2=2&amp;lt;0？否，这时候offset=2， 2-3&amp;lt;0？是，所以选中 10.0.0.1:20886, weight=3&lt;/p&gt;
&lt;p&gt;假设offset=7（即random.nextInt(9)=7）&lt;br/&gt;7-2=5&amp;lt;0？否，这时候offset=5， 5-3=2&amp;lt;0？否，这时候offset=2， 2-4&amp;lt;0？是，所以选中 10.0.0.1:20888, weight=4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;流程图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1041678-d69d4e6bb1acf146.png?imageMogr2/auto-orient/&quot; alt=&quot;流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalanceTest.java&quot;&gt;RoundRobinLoadBalance#doSelect()(轮询)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;轮询&lt;/strong&gt;，按公约后的权重设置轮询比率。&lt;/li&gt;
&lt;li&gt;存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
    String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();
    int length = invokers.size(); // Number of invokers
    int maxWeight = 0; // The maximum weight
    int minWeight = Integer.MAX_VALUE; // The minimum weight
    final LinkedHashMap&amp;lt;Invoker&amp;lt;T&amp;gt;, IntegerWrapper&amp;gt; invokerToWeightMap = new LinkedHashMap&amp;lt;Invoker&amp;lt;T&amp;gt;, IntegerWrapper&amp;gt;();
    int weightSum = 0;
    // 计算最小、最大权重，总的权重和。
    for (int i = 0; i &amp;lt; length; i++) {
        int weight = getWeight(invokers.get(i), invocation);
        maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
        minWeight = Math.min(minWeight, weight); // Choose the minimum weight
        if (weight &amp;gt; 0) {
            invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
            weightSum += weight;
        }
    }
    // 计算最小、最大权重，总的权重和。
    AtomicPositiveInteger sequence = sequences.get(key);
    if (sequence == null) {
        sequences.putIfAbsent(key, new AtomicPositiveInteger());
        sequence = sequences.get(key);
    }
    // 获得当前顺序号，并递增 + 1
    int currentSequence = sequence.getAndIncrement();
    // 权重不相等，顺序根据权重分配
    if (maxWeight &amp;gt; 0 &amp;amp;&amp;amp; minWeight &amp;lt; maxWeight) {
        int mod = currentSequence % weightSum;// 剩余权重
        for (int i = 0; i &amp;lt; maxWeight; i++) {// 循环最大权重
            for (Map.Entry&amp;lt;Invoker&amp;lt;T&amp;gt;, IntegerWrapper&amp;gt; each : invokerToWeightMap.entrySet()) {
                final Invoker&amp;lt;T&amp;gt; k = each.getKey();
                final IntegerWrapper v = each.getValue();
                // 剩余权重归 0 ，当前 Invoker 还有剩余权重，返回该 Invoker 对象
                if (mod == 0 &amp;amp;&amp;amp; v.getValue() &amp;gt; 0) {
                    return k;
                }
                // 若 Invoker 还有权重值，扣除它( value )和剩余权重( mod )。
                if (v.getValue() &amp;gt; 0) {
                    v.decrement();
                    mod--;
                }
            }
        }
    }
    // 权重相等，平均顺序获得
    // Round robin
    return invokers.get(currentSequence % length);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法说明&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;假定有3台权重都一样的dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=100&lt;br/&gt;10.0.0.1:20886, weight=100&lt;br/&gt;10.0.0.1:20888, weight=100&lt;br/&gt;轮询算法的实现：&lt;br/&gt;其调用方法某个方法(key)的sequence从0开始：&lt;br/&gt;sequence=0时，选择invokers.get(0%3)=10.0.0.1:20884&lt;br/&gt;sequence=1时，选择invokers.get(1%3)=10.0.0.1:20886&lt;br/&gt;sequence=2时，选择invokers.get(2%3)=10.0.0.1:20888&lt;br/&gt;sequence=3时，选择invokers.get(3%3)=10.0.0.1:20884&lt;br/&gt;sequence=4时，选择invokers.get(4%3)=10.0.0.1:20886&lt;br/&gt;sequence=5时，选择invokers.get(5%3)=10.0.0.1:20888&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;leastactiveloadbalance最少活跃数&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java&quot;&gt;LeastActiveLoadBalance&lt;/a&gt;(最少活跃数)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最少活跃调用数&lt;/strong&gt;，相同活跃数的随机，活跃数指调用前后计数差。&lt;/li&gt;
&lt;li&gt;使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
    // 总个数
    int length = invokers.size(); // Number of invokers
    // 最少的活跃数
    int leastActive = -1; // The least active value of all invokers
    // 相同最小活跃数的个数
    int leastCount = 0; // The number of invokers having the same least active value (leastActive)
    // 相同最小活跃数的下标
    int[] leastIndexs = new int[length]; // The index of invokers having the same least active value (leastActive)
    //总权重
    int totalWeight = 0; // The sum of weights
    // 第一个权重，用于于计算是否相同
    int firstWeight = 0; // Initial value, used for comparision
    // 是否所有权重相同
    boolean sameWeight = true; // Every invoker has the same weight value?
    // 计算获得相同最小活跃数的数组和个数
    for (int i = 0; i &amp;lt; length; i++) {
        Invoker&amp;lt;T&amp;gt; invoker = invokers.get(i);
        // 活跃数
        int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // Active number
        // 权重
        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // Weight
        // 发现更小的活跃数，重新开始
        if (leastActive == -1 || active &amp;lt; leastActive) { // Restart, when find a invoker having smaller least active value.
            // 记录最小活跃数
            leastActive = active; // Record the current least active value
            // 重新统计相同最小活跃数的个数
            leastCount = 1; // Reset leastCount, count again based on current leastCount
            // 重新记录最小活跃数下标
            leastIndexs[0] = i; // Reset
            // 重新统计总权重
            totalWeight = weight; // Reset
            // 记录第一个权重
            firstWeight = weight; // Record the weight the first invoker
            // 还原权重标识
            sameWeight = true; // Reset, every invoker has the same weight value?
        // 累计相同最小的活跃数
        } else if (active == leastActive) { // If current invoker's active value equals with leaseActive, then accumulating.
            // 累计相同最小活跃数下标
            leastIndexs[leastCount++] = i; // Record index number of this invoker
            // 累计总权重
            totalWeight += weight; // Add this invoker's weight to totalWeight.
            // 判断所有权重是否一样
            // If every invoker has the same weight?
            if (sameWeight &amp;amp;&amp;amp; i &amp;gt; 0
                    &amp;amp;&amp;amp; weight != firstWeight) {
                sameWeight = false;
            }
        }
    }
    // assert(leastCount &amp;gt; 0)
    if (leastCount == 1) {
        // 如果只有一个最小则直接返回
        // If we got exactly one invoker having the least active value, return this invoker directly.
        return invokers.get(leastIndexs[0]);
    }
    if (!sameWeight &amp;amp;&amp;amp; totalWeight &amp;gt; 0) {
        // 如果权重不相同且权重大于0则按总权重数随机
        // If (not every invoker has the same weight &amp;amp; at least one invoker's weight&amp;gt;0), select randomly based on totalWeight.
        int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);
        // 并确定随机值落在哪个片断上
        // Return a invoker based on the random value.
        for (int i = 0; i &amp;lt; leastCount; i++) {
            int leastIndex = leastIndexs[i];
            offsetWeight -= getWeight(invokers.get(leastIndex), invocation);
            if (offsetWeight &amp;lt;= 0)
                return invokers.get(leastIndex);
        }
    }
    // 如果权重相同或权重为0则均等随机
    // If all invokers have the same weight value or totalWeight=0, return evenly.
    return invokers.get(leastIndexs[ThreadLocalRandom.current().nextInt(leastCount)]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单思路介绍&lt;/p&gt;
&lt;p&gt;概括起来就两部分,一部分是&lt;code&gt;活跃数&lt;/code&gt;和&lt;code&gt;权重&lt;/code&gt;的统计,另一部分是选择&lt;code&gt;invoker&lt;/code&gt;.也就是他把最小活跃数的&lt;code&gt;invoker&lt;/code&gt;统计到&lt;code&gt;leastIndexs&lt;/code&gt;数组中,如果权重一致(这个一致的规则参考上面的随机算法)或者总权重为0,则均等随机调用,如果不同,则从&lt;code&gt;leastIndexs&lt;/code&gt;数组中按照权重比例调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法说明&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;最小活跃数算法实现：&lt;br/&gt;假定有3台dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=2，active=2&lt;br/&gt;10.0.0.1:20886, weight=3，active=4&lt;br/&gt;10.0.0.1:20888, weight=4，active=3&lt;br/&gt;active=2最小，且只有一个2，所以选择10.0.0.1:20884&lt;/p&gt;
&lt;p&gt;假定有3台dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=2，active=2&lt;br/&gt;10.0.0.1:20886, weight=3，active=2&lt;br/&gt;10.0.0.1:20888, weight=4，active=3&lt;br/&gt;active=2最小，且有2个，所以从[10.0.0.1:20884,10.0.0.1:20886 ]中选择；&lt;br/&gt;接下来的算法与随机算法类似：&lt;br/&gt;假设offset=1（即random.nextInt(5)=1）&lt;br/&gt;1-2=-1&amp;lt;0？是，所以选中 10.0.0.1:20884, weight=2&lt;br/&gt;假设offset=4（即random.nextInt(5)=4）&lt;br/&gt;4-2=2&amp;lt;0？否，这时候offset=2， 2-3&amp;lt;0？是，所以选中 10.0.0.1:20886, weight=3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;流程图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1041678-974214615c58dce8.png?imageMogr2/auto-orient/&quot; alt=&quot;流程图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;consistenthashloadbalance一致性哈希&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java&quot;&gt;ConsistentHashLoadBalance&lt;/a&gt;(一致性哈希)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性 Hash&lt;/strong&gt;，相同参数的请求总是发到同一提供者。&lt;/li&gt;
&lt;li&gt;当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;源码其实分为四个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义全局一致性hash选择器的&lt;code&gt;ConcurrentMap&amp;lt;String, ConsistentHashSelector&amp;lt;?&amp;gt;&amp;gt; selectors&lt;/code&gt;，key为方法名称，例如com.alibaba.dubbo.demo.TestService.getRandomNumber&lt;/li&gt;
&lt;li&gt;如果一致性hash选择器不存在或者与以前保存的一致性hash选择器不一样（即dubbo服务provider有变化，通过System.identityHashCode(invokers)计算一个identityHashCode值） 则需要重新构造一个一致性hash选择器&lt;/li&gt;
&lt;li&gt;构造一个一致性hash选择器ConsistentHashSelector的源码如下，通过参数i和h打散Invoker在TreeMap上的位置，replicaNumber默认值为160，所以最终virtualInvokers这个TreeMap的size为&lt;code&gt;invokers.size()*replicaNumber&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择Invoker的步骤
&lt;ol&gt;&lt;li&gt;根据Invocation中的参数invocation.getArguments()转成key&lt;/li&gt;
&lt;li&gt;算出这个key的md5值&lt;/li&gt;
&lt;li&gt;根据md5值的hash值从TreeMap中选择一个Invoker&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;下面源码解析+注释&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConsistentHashLoadBalance extends AbstractLoadBalance {
    public static final String NAME = &quot;consistenthash&quot;;

    /**
     * 服务方法与一致性哈希选择器的映射
     *
     * KEY：serviceKey + &quot;.&quot; + methodName
     */
    private final ConcurrentMap&amp;lt;String, ConsistentHashSelector&amp;lt;?&amp;gt;&amp;gt; selectors = new ConcurrentHashMap&amp;lt;String, ConsistentHashSelector&amp;lt;?&amp;gt;&amp;gt;();

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
        String methodName = RpcUtils.getMethodName(invocation);
        // 基于 invokers 集合，根据对象内存地址来计算定义哈希值
        String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + methodName;
        int identityHashCode = System.identityHashCode(invokers);
        // 获得 ConsistentHashSelector 对象。若为空，或者定义哈希值变更（说明 invokers 集合发生变化），
        // 进行创建新的 ConsistentHashSelector 对象
        ConsistentHashSelector&amp;lt;T&amp;gt; selector = (ConsistentHashSelector&amp;lt;T&amp;gt;) selectors.get(key);
        if (selector == null || selector.identityHashCode != identityHashCode) {
            selectors.put(key, new ConsistentHashSelector&amp;lt;T&amp;gt;(invokers, methodName, identityHashCode));
            selector = (ConsistentHashSelector&amp;lt;T&amp;gt;) selectors.get(key);
        }
        return selector.select(invocation);
    }

    private static final class ConsistentHashSelector&amp;lt;T&amp;gt; {

        /**
         * 虚拟节点与 Invoker 的映射关系
         */
        private final TreeMap&amp;lt;Long, Invoker&amp;lt;T&amp;gt;&amp;gt; virtualInvokers;

        /**
         * 每个Invoker 对应的虚拟节点数
         */
        private final int replicaNumber;

        /**
         * 定义哈希值
         */
        private final int identityHashCode;

        /**
         * 取值参数位置数组
         */
        private final int[] argumentIndex;

        ConsistentHashSelector(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, String methodName, int identityHashCode) {
            this.virtualInvokers = new TreeMap&amp;lt;Long, Invoker&amp;lt;T&amp;gt;&amp;gt;();
            // 设置 identityHashCode
            this.identityHashCode = identityHashCode;
            URL url = invokers.get(0).getUrl();
            // 初始化 replicaNumber
            this.replicaNumber = url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);
            // 初始化 argumentIndex
            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));
            argumentIndex = new int[index.length];
            for (int i = 0; i &amp;lt; index.length; i++) {
                argumentIndex[i] = Integer.parseInt(index[i]);
            }
            // 初始化 virtualInvokers
            for (Invoker&amp;lt;T&amp;gt; invoker : invokers) {
                String address = invoker.getUrl().getAddress();
                // 每四个虚拟结点为一组，为什么这样？下面会说到
                for (int i = 0; i &amp;lt; replicaNumber / 4; i++) {
                    // 这组虚拟结点得到惟一名称
                    byte[] digest = md5(address + i);
                    // Md5是一个16字节长度的数组，将16字节的数组每四个字节一组，
                    // 分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因
                    for (int h = 0; h &amp;lt; 4; h++) {
                        // 对于每四个字节，组成一个long值数值，做为这个虚拟节点的在环中的惟一key
                        long m = hash(digest, h);
                        virtualInvokers.put(m, invoker);
                    }
                }
            }
        }

        public Invoker&amp;lt;T&amp;gt; select(Invocation invocation) {
            // 基于方法参数，获得 KEY
            String key = toKey(invocation.getArguments());
            // 计算 MD5 值
            byte[] digest = md5(key);
            // 计算 KEY 值
            return selectForKey(hash(digest, 0));
        }

        /**
         * 基于方法参数，获得 KEY
         * @param args
         * @return
         */
        private String toKey(Object[] args) {
            StringBuilder buf = new StringBuilder();
            for (int i : argumentIndex) {
                if (i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; args.length) {
                    buf.append(args[i]);
                }
            }
            return buf.toString();
        }

        /**
         * 选一个 Invoker 对象
         * @param hash
         * @return
         */
        private Invoker&amp;lt;T&amp;gt; selectForKey(long hash) {
            // 得到大于当前 key 的那个子 Map ，然后从中取出第一个 key ，就是大于且离它最近的那个 key
            Map.Entry&amp;lt;Long, Invoker&amp;lt;T&amp;gt;&amp;gt; entry = virtualInvokers.ceilingEntry(hash);
            // 不存在，则取 virtualInvokers 第一个
            if (entry == null) {
                entry = virtualInvokers.firstEntry();
            }
            // 存在，则返回
            return entry.getValue();
        }

        /**
         * 对于每四个字节，组成一个 Long 值数值，做为这个虚拟节点的在环中的惟一 KEY
         * @param digest
         * @param number
         * @return
         */
        private long hash(byte[] digest, int number) {
            return (((long) (digest[3 + number * 4] &amp;amp; 0xFF) &amp;lt;&amp;lt; 24)
                    | ((long) (digest[2 + number * 4] &amp;amp; 0xFF) &amp;lt;&amp;lt; 16)
                    | ((long) (digest[1 + number * 4] &amp;amp; 0xFF) &amp;lt;&amp;lt; 8)
                    | (digest[number * 4] &amp;amp; 0xFF))
                    &amp;amp; 0xFFFFFFFFL;
        }

        /**
         * MD5 是一个 16 字节长度的数组，将 16 字节的数组每四个字节一组，
         * 分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因
         * @param value
         * @return
         */
        private byte[] md5(String value) {
            MessageDigest md5;
            try {
                md5 = MessageDigest.getInstance(&quot;MD5&quot;);
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException(e.getMessage(), e);
            }
            md5.reset();
            byte[] bytes;
            try {
                bytes = value.getBytes(&quot;UTF-8&quot;);
            } catch (UnsupportedEncodingException e) {
                throw new IllegalStateException(e.getMessage(), e);
            }
            md5.update(bytes);
            return md5.digest();
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一致性哈希算法的三个关键点 &lt;strong&gt;原理&lt;/strong&gt;， &lt;strong&gt;down机影响面&lt;/strong&gt;， &lt;strong&gt;虚拟节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lihao21/article/details/54193868&quot;&gt;一致性Hash(Consistent Hashing)原理剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;down 机影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在某个节点挂机的时候，会根据虚拟节点选择下一个节点。只影响到一个节点，其他的节点不受到影响&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据一致性Hash算法将生成很多的虚拟节点，这些节点落在圆环中。当某个节点down掉，则压力会给到指定的虚拟节点&lt;/p&gt;
&lt;blockquote readability=&quot;1.0384615384615&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/entry/5b13e712e51d4506da5a039b&quot;&gt;常见负载均衡算法分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dubbo.incubator.apache.org/zh-cn/docs/user/demos/loadbalance.html&quot;&gt;Dubbo 官方文档 负载均衡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/10c30d7b8b6a&quot;&gt;阿飞的博客 14.dubbo源码-负载均衡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/53feb7f5f5d9&quot;&gt;dubbo源码解析-LoadBalance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/javanoob/p/dubbo_loadbalance.html&quot;&gt;Dubbo 负载均衡策略与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://svip.iocoder.cn/Dubbo/cluster-4-impl-loadbalance/&quot;&gt;精尽 Dubbo 源码解析 —— 集群容错（四）之 LoadBalance 实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:33:00 +0000</pubDate>
<dc:creator>王守昌</dc:creator>
<og:description>欢迎来我的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshouchang/p/10018141.html</dc:identifier>
</item>
<item>
<title>初步接触 Java Net 网络编程 - czwbig</title>
<link>http://www.cnblogs.com/czwbig/p/10018118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/czwbig/p/10018118.html</guid>
<description>&lt;p&gt;本文目的是大概了解 Java 网络编程体系，需要一点点 Java IO 基础，推荐教程 &lt;a href=&quot;https://www.cnblogs.com/czwbig/p/10007201.html&quot;&gt;系统学习 Java IO&lt;/a&gt;。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程《Java Networking》 &lt;a href=&quot;http://tutorials.jenkov.com/java-networking/index.html&quot; class=&quot;uri&quot;&gt;http://tutorials.jenkov.com/java-networking/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-网络编程概览&quot;&gt;Java 网络编程概览&lt;/h2&gt;
&lt;p&gt;Java 有一个相当容易使用的内置网络 API，可以很容易地通过互联网上的 TCP / IP 套接字或 UDP 套接字进行通信。 TCP 通常比 UDP 使用得更频繁。&lt;/p&gt;
&lt;p&gt;即使 Java Networking API 允许通过套接字打开和关闭网络连接，但所有通信都通过 Java IO 类 InputStream 和 OutputStream 实现的。&lt;br/&gt;或者，我们可以使用 Java NIO API 中的网络类。 用法类似于 Java Networking API 中的类，但 Java NIO API 可以在非阻塞模式下工作。 在某些情况下，非阻塞模式可提升性能。&lt;/p&gt;
&lt;h5 id=&quot;java-tcp-网络基础&quot;&gt;Java TCP 网络基础&lt;/h5&gt;
&lt;p&gt;通常，客户端会打开与服务器的 TCP / IP 连接，然后开始与服务器通信，当通信结束后客户端关闭连接。如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181125113944385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N6d2JpZw==,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端可以通过一个已打开的连接发送多个请求，实际上，客户端可以向服务器发送尽可能多的数据。 当然，如果需要，服务器也可以关闭连接。&lt;/p&gt;
&lt;h5 id=&quot;java-中-socket-类和-serversocket-类&quot;&gt;Java 中 Socket 类和 ServerSocket 类&lt;/h5&gt;
&lt;p&gt;当客户端想要打开到服务器的 TCP / IP 连接时，它使用 Java Socket 类来实现。 套接字被告知连接到哪个 IP 地址和 TCP 端口，其余部分由 Java 完成。&lt;/p&gt;
&lt;p&gt;如果要启动服务器以侦听来自某个 TCP 端口上的客户端的传入连接，则必须使用 Java ServerSocket 类。 当客户端通过客户端套接字连接到服务器的 ServerSocket 时，服务器上会为该连接分配一个 Socket 。 客户端和服务器的通信就是 Socket 到 Socket 的通信了。&lt;/p&gt;
&lt;p&gt;Socket和ServerSocket在后面的文本中有更详细的介绍。&lt;/p&gt;
&lt;h5 id=&quot;java-udp-网络基础&quot;&gt;Java UDP 网络基础&lt;/h5&gt;
&lt;p&gt;UDP 的工作方式与 TCP 略有不同。 使用 UDP ，客户端和服务器之间没有连接。 客户端可以向服务器发送数据，并且服务器可以（或可以不）接收该数据。 客户端永远不会知道数据是否在另一端收到。 从服务器到客户端发送的数据也是如此。&lt;br/&gt;由于无法保证数据传输，因此 UDP 协议的协议开销较小。&lt;/p&gt;
&lt;p&gt;在一些情况下，无连接 UDP 模型优于 TCP ，比如传输视频等多媒体文件，缺少一些数据是不影响观看的。&lt;/p&gt;
&lt;h2 id=&quot;tcp-socket套接字&quot;&gt;TCP Socket（套接字）&lt;/h2&gt;
&lt;p&gt;为了通过 Internet 连接到服务器（通过TCP / IP），需要创建一个 Socket 并将其连接到服务器。 或者，如果您更喜欢使用 Java NIO ，则可以使用 Java NIO SocketChannel 。&lt;/p&gt;
&lt;h5 id=&quot;创建一个socket&quot;&gt;创建一个Socket&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Socket socket = new Socket(&quot;baidu.com&quot;, 80);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数是地址，可以是 ip 或者域名字符串，第二个参数是端口，端口80是Web服务器端口。&lt;/p&gt;
&lt;h5 id=&quot;写入-socket&quot;&gt;写入 Socket&lt;/h5&gt;
&lt;p&gt;要写入 Socket，必须获取其 OutputStream ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Socket socket = new Socket(&quot;baidu.com&quot;, 80);
OutputStream outputStream = socket.getOutputStream();

outputStream.write(&quot;some data&quot;.getBytes());
outputStream.flush();
outputStream.close();

socket.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当真的希望通过互联网向服务器发送数据时，不要忘记调用 flush() 。操作系统中的底层 TCP / IP 实现会先缓冲数据，缓冲块的大小是与 TCP ​​/ IP 数据包的大小相适应的，这就是说，调用 flush() 只是通知系统发送，但系统并不是立即就帮忙发出去。&lt;/p&gt;
&lt;h5 id=&quot;从-socket-读取&quot;&gt;从 Socket 读取&lt;/h5&gt;
&lt;p&gt;要从 Socket 读取，需要获取其 InputStream ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Socket socket = new Socket(&quot;baidu.com&quot;, 80);
InputStream in = socket.getInputStream();

int data = in.read();
//... read more data...

in.close();
socket.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记住，在读取时我们不能使用读取 InputStream 返回 -1 来判断数据读取结束 ，因为只有在服务器关闭连接时才返回 -1 。 但是服务器可能并不总是关闭连接，比如通过同一连接发送多个请求。 在这种情况下，关闭连接将是非常愚蠢的。&lt;/p&gt;
&lt;p&gt;相反，必须知道从 Socket 的 InputStream 中读取多少字节。 服务器会告知 Socket 它发送的字节数，或者通过查找特殊的数据结束字符来完成。&lt;/p&gt;
&lt;p&gt;使用 Socket 后，必须关闭它以关闭与服务器的连接，这可以通过调用 Socket 对象的 close() 方法完成。&lt;/p&gt;
&lt;h2 id=&quot;serversocket&quot;&gt;ServerSocket&lt;/h2&gt;
&lt;p&gt;可以使用 ServerSocket 来实现 Java 服务器，这样就可以通过 TCP / IP 侦听来自客户端的传入连接。如果更喜欢使用 Java NIO 而不是 Java Networking（标准API），那么也可以使用 ServerSocketChannel 。&lt;/p&gt;
&lt;h5 id=&quot;创建一个-serversocket&quot;&gt;创建一个 ServerSocket&lt;/h5&gt;
&lt;p&gt;这是一个简单的代码示例，它创建一个侦听端口 9000 的 ServerSocket：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ServerSocket serverSocket = new ServerSocket(9000);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;监听传入的连接&quot;&gt;监听传入的连接&lt;/h5&gt;
&lt;p&gt;要接受传入连接，必须调用 ServerSocket.accept() 方法。 accept() 方法返回一个 Socket ，其行为类似于普通的 Socket ，示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ServerSocket serverSocket = new ServerSocket(9000);
boolean isStopped = false;
while(!isStopped){
    Socket clientSocket = serverSocket.accept();
    //do something with clientSocket
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次调用 accept() 方法时只打开一个传入连接。&lt;br/&gt;此外，只有在运行服务器的线程调用 accept() 时才能接受传入连接。 线程在此方法之外执行的所有时间都没有客户端可以连接。 因此，“accept”线程通常将传入连接（Socket）传递给工作线程池，然后工作线程与客户端进行通信。 有关多线程服务器设计的更多信息，请参阅教程跟踪 Java 多线程服务器。&lt;/p&gt;
&lt;h5 id=&quot;关闭客户端-sockets&quot;&gt;关闭客户端 Sockets&lt;/h5&gt;
&lt;p&gt;一旦客户端请求完成，并且不会从该客户端收到进一步的请求，必须关闭该Socket，就像关闭普通客户端Socket一样。调用：&lt;code&gt;socket.close();&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;关闭服务端-sockets&quot;&gt;关闭服务端 Sockets&lt;/h5&gt;
&lt;p&gt;一旦服务器关闭，就需要关闭 ServerSocket 。 调用：&lt;code&gt;serverSocket.close();&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;udp-datagramsocketudp数据报套接字&quot;&gt;UDP DatagramSocket（UDP数据报套接字）&lt;/h2&gt;
&lt;p&gt;DatagramSocket 是 Java 通过 UDP 而不是 TCP 进行网络通信的机制。 UDP 也是 IP 协议的上层。 可以使用 DatagramSocket 来发送和接收 UPD 数据报。&lt;/p&gt;
&lt;h5 id=&quot;udp-对比-tcp&quot;&gt;UDP 对比 TCP&lt;/h5&gt;
&lt;p&gt;通过 TCP 发送数据时，首先要创建连接。 建立 TCP 连接后，TCP 保证数据到达另一端，或者它会告诉你发生了错误。&lt;/p&gt;
&lt;p&gt;使用 UDP，只需将数据包（数据报）发送到网络上的某个 IP 地址。 无法保证数据会到达，也无法保证 UDP 数据包到达的顺序。 这意味着 UDP 比 TCP 具有更少的协议开销（没有流完整性检查）。&lt;/p&gt;
&lt;p&gt;UDP 适用于数据传输，如果数据包在转换过程中丢失则无关紧要。 例如，想象一下通过互联网传输直播电视信号，如果一两帧丢失，这是无关紧要的。我们更不希望直播延迟只是为了确保所有帧都显示出来。 宁愿跳过错过的帧，并直接查看最新的帧。&lt;/p&gt;
&lt;p&gt;还有实时监控视频，宁愿丢失一两帧，也不想延迟于现实 30 秒。与摄像机录像的存储有点不同，将图像从相机录制到磁盘时, 为了保证完整性，可能不希望丢失单帧，而是更愿意稍微延迟。&lt;/p&gt;
&lt;h5 id=&quot;datagrampacket-类&quot;&gt;DatagramPacket 类&lt;/h5&gt;
&lt;p&gt;此类表示数据报包。数据报包用来实现无连接包投递服务。&lt;/p&gt;
&lt;blockquote readability=&quot;7.4515050167224&quot;&gt;
&lt;p&gt;Java 使用 DatagramSocket 代表 UDP 协议的 Socket ，DatagramSocket 本身只是码头，不维护状态，不能产生IO流，它的唯一作用就是接收和发送数据报，使用 DatagramPacket 来代表数据报，DatagramSocket 接收和发送的数据都是通过 DatagramPacket 对象完成的。&lt;br/&gt;每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。不对包投递做出保证。&lt;br/&gt;引用自 &lt;a href=&quot;http://book.51cto.com/art/201203/322540.htm&quot;&gt;李刚《疯狂Java讲义（第2版）》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其所有构造器如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;DatagramPacket(byte[] buf, int length)&lt;/td&gt;
&lt;td&gt;构造 DatagramPacket，用来接收长度为 length 的数据包。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;DatagramPacket(byte[] buf, int length, InetAddress address, int port)&lt;/td&gt;
&lt;td&gt;构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;DatagramPacket(byte[] buf, int length, SocketAddress address)&lt;/td&gt;
&lt;td&gt;构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;以上3个在 byte[] buf 参数后面追加 int offset&lt;/td&gt;
&lt;td&gt;为长度为 length 的包设置偏移量为 offset&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InetAddress 类表示互联网协议 (IP) 地址，可以通过静态方法 getByName(String host) 获得其对象。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;SocketAddress 类里面什么都没有。其子类 InetSocketAddress是(IP地址+端口号)类型，也就是端口地址类型，同样可以使用静态方法 createUnresolved(String host, int port) 获取对象，另外也能由构造函数 InetSocketAddress(InetAddress addr, int port) 创建，其中 InetAddress 对象可省略，也可用字符串代替。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;通过-datagramsocket-发送数据datagrampacket&quot;&gt;通过 DatagramSocket 发送数据（DatagramPacket ）&lt;/h5&gt;
&lt;p&gt;要通过 DatagramSocket 发送数据，必须首先创建一个 DatagramPacket ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;byte[] buffer = new byte[65508];
InetAddress address = InetAddress.getByName(&quot;baidu.com&quot;);

DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 9000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字节缓冲区（字节数组）是要在 UDP 数据报中发送的数据。 上述缓冲区的长度（65508字节）是可以在单个 UDP 数据包中发送的最大数据量。&lt;/p&gt;
&lt;p&gt;DatagramPacket 构造函数中的 buffer.length 是要发送的缓冲区中数据的长度，忽略该数据量之后缓冲区中的所有数据。&lt;/p&gt;
&lt;p&gt;InetAddress 实例包含发送 UDP 数据包的节点（例如服务器）的地址。 InetAddress 类表示 IP 地址（Internet地址）。 getByName() 方法返回一个 InetAddress 实例，其 IP 地址与给定的主机名匹配。&lt;/p&gt;
&lt;p&gt;port 参数是服务器接收数据正在侦听的 UDP 端口，UDP 和 TCP 端口是不一样的。同一台计算机可以有不同的线程同时监听 UDP 的 80 端口和 TCP 中的 80 端口。不同协议下，端口号互不干扰，端口只是应用程序的标识。&lt;/p&gt;
&lt;p&gt;创建一个 DatagramSocket ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DatagramSocket datagramSocket = new DatagramSocket();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要发送数据，请调用 send() 方法，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;datagramSocket.send(packet);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个完整的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class DatagramExample {
    public static void main(String[] args) throws Exception {
        DatagramSocket datagramSocket = new DatagramSocket();

        byte[] buffer = &quot;123456789&quot;.getBytes();
        InetAddress receiverAddress = InetAddress.getLocalHost();

        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, receiverAddress, 80);
        datagramSocket.send(packet);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;通过-datagramsocket-接收数据-datagrampacket&quot;&gt;通过 DatagramSocket 接收数据 （DatagramPacket ）&lt;/h5&gt;
&lt;p&gt;通过 DatagramSocket 接收数据是通过首先创建 DatagramPacket 然后通过 DatagramSocket 的 receive() 方法接收数据来完成的。 这是一个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DatagramSocket socket = new DatagramSocket(80);
byte[] buffer = new byte[10];
DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

socket.receive(packet);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用传递给构造函数的参数值 80 来实例化 DatagramSocket , 此参数是 DatagramSocket 接收 UDP 数据包的 UDP 端口。 如前所述，TCP 和 UDP 端口不相同，因此不重叠。 可以在 TCP 和 UDP 80 端口上侦听两个不同的进程，而不会发生任何冲突。&lt;/p&gt;
&lt;p&gt;其次，创建字节缓冲区和 DatagramPacket 。 注意 DatagramPacket 没有关于要发送数据的节点的信息，就像创建 DatagramPacket 用于发送数据时一样。 这是因为我们将使用 DatagramPacket 接收数据而不是发送数据，因此，不需要目标地址。&lt;/p&gt;
&lt;p&gt;最后调用 DatagramSocket 的 receive() 方法。 此方法将一直阻塞，直到收到 DatagramPacket 。&lt;/p&gt;
&lt;p&gt;收到的数据位于 DatagramPacket 的字节缓冲区中。 这个缓冲区可以通过调用如下代码获取：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;byte[] buffer = packet.getData();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缓冲区会接收多少数据应该由你找到答案。 正在使用的协议应指定每个 UDP 数据包发送的数据量，或指定可以查找到的数据结束标记。真正的服务器程序可能会在循环中调用 receive() 方法，并将所有收到的 DatagramPacket 传递给工作线程池，就像 TCP 服务器对传入连接一样。&lt;/p&gt;
&lt;h2 id=&quot;url-urlconnection&quot;&gt;URL + URLConnection&lt;/h2&gt;
&lt;p&gt;java.net 包中两个有趣的类：URL 类和 URLConnection 类，这些类可用于创建与 Web 服务器（HTTP 服务器）的客户端连接。 这是一个简单的代码示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class URLExample {
    public static void main(String[] args) throws IOException {
        URL url = new URL(&quot;http://baidu.com&quot;);

        URLConnection urlConnection = url.openConnection();
        InputStream inputStream = urlConnection.getInputStream();

        int data = inputStream.read();
        while (data != -1) {
            System.out.print((char) data);
            data = inputStream.read();
        }
        inputStream.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将会输出&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;http-get-和-post&quot;&gt;HTTP GET 和 POST&lt;/h5&gt;
&lt;p&gt;URLConnection 类的作用是构造一个到指定 URL 的 URL 连接。它只有一个构造函数：&lt;code&gt;URLConnection(URL url)&lt;/code&gt; 。&lt;br/&gt;默认情况下，URLConnection 向 Web 服务器发送 HTTP GET 请求，即查询数据。如果要发送 HTTP POST 请求提交数据，请调用URLConnection.setDoOutput(true) 方法，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL url = new URL(&quot;http://baidu.com&quot;);
URLConnection urlConnection = url.openConnection();
urlConnection.setDoOutput(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦设置了 setDoOutput(true) ，因为要提交数据，所以需要输出流。可以打开 URLConnection 的 OutputStream ，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;OutputStream output = urlConnection.getOutputStream();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用此 OutputStream ，可以在 HTTP 请求的正文中编写所需的任何数据。 请记住对其进行 URL 编码（参考 &lt;a href=&quot;https://github.com/chokcoco/cnblogsArticle/issues/6&quot;&gt;【基础进阶】URL详解与URL编码&lt;/a&gt; ，并记得在完成向其写入数据后关闭 OutputStream 。&lt;/p&gt;
&lt;h5 id=&quot;本地文件的url&quot;&gt;本地文件的URL&lt;/h5&gt;
&lt;p&gt;URL 类还可用于访问本地文件系统中的文件。 因此，如果需要代码处理来源不明的文件，比如是来自网络还是本地文件系统，则 URL 类是打开文件的便捷方式。&lt;br/&gt;以下是使用 URL 类在本地文件系统中打开文件的示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL url = new URL(&quot;file:/D:/test/test.txt&quot;);

URLConnection urlConnection = url.openConnection();
InputStream input = urlConnection.getInputStream();

int data = input.read();
while(data != -1){
    System.out.print((char) data);
    data = input.read();
}
input.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，这和通过 HTTP 访问 Web 服务器上的文件的唯一区别是 URL ：&lt;code&gt;&quot;file:/D:/test/test.txt&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;http://baidu.com&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;jarurlconnection&quot;&gt;JarURLConnection&lt;/h4&gt;
&lt;p&gt;JarURLConnection 类用于连接 Java Jar 文件。 连接后可以获取有关 Jar 文件内容的信息。 这是一个简单的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String urlString = &quot;http://butterfly.jenkov.com/&quot;
                 + &quot;container/download/&quot;
                 + &quot;jenkov-butterfly-container-2.9.9-beta.jar&quot;;

URL jarUrl = new URL(urlString);
JarURLConnection connection = new JarURLConnection(jarUrl);

Manifest manifest = connection.getManifest();
JarFile jarFile = connection.getJarFile();
//do something with Jar file...&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 25 Nov 2018 15:27:00 +0000</pubDate>
<dc:creator>czwbig</dc:creator>
<og:description>本文目的是大概了解 Java 网络编程体系，不深入。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程《Java Networking》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/czwbig/p/10018118.html</dc:identifier>
</item>
<item>
<title>MySQL5.6启用sha256_password插件 - GrapefruitTea</title>
<link>http://www.cnblogs.com/GrapefruitTea/p/10017091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrapefruitTea/p/10017091.html</guid>
<description>&lt;p&gt;一、背景：&lt;/p&gt;
&lt;p&gt;　　使用MySQL5.6过程中，发现默认的加密插件为mysql_native_password。而sha256_password的安全程度要比mysql_native_password高，尝试切换为sha256_password。&lt;/p&gt;
&lt;p&gt;二、配置过程：&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;资料：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、从MySQL官网查询到服务器端sha256_password无需显式加载，可以在MySQL配置文件中配置使能。&lt;/p&gt;
&lt;p&gt;　　　  官网见：&lt;a target=&quot;_blank&quot;&gt;https://dev.mysql.com/doc/refman/5.6/en/sha256-pluggable-authentication.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　  &lt;span class=&quot;token selector&quot;&gt;[mysqld]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token selector&quot;&gt;　　     &lt;span class=&quot;token constant&quot;&gt;default-authentication-plugin&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=sha256_password&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2、据官网描述，要启用插件，须通过ssl方式进行连接，也就是说需要配置相关证书。&lt;/p&gt;
&lt;p&gt;　   &lt;span&gt;&lt;strong&gt;实现过程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、下载MySQL安装包，&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/5.6.html#downloads&quot; target=&quot;_blank&quot;&gt;https://dev.mysql.com/downloads/mysql/5.6.html#downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125191851644-1646240421.png&quot; alt=&quot;&quot;/&gt;】&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125191937037-1513130819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、安装MySQL&lt;/p&gt;
&lt;p&gt;　　下载的的MySQL是zip格式的，解压到磁盘后，将my-default.ini另存为my.ini（此处看个人爱好，可不用），关于my.ini需要修改的地方如下：&lt;/p&gt;
&lt;p&gt;　　1）basedir datadir port 需要根据自己使用情况配置。&lt;/p&gt;
&lt;p&gt;　　2）配置默认启用的加密插件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125192516017-436458727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、简单配置完mysql配置文件后，以管理员方式打开cmd，进入第二步解压后的xxxmyql/bin目录。&lt;/p&gt;
&lt;p&gt;　　1）执行mysqld -install（tips：mysqld -remove 是卸载mysql），也可以执行服务名称及配置文件路径：mysqld install mysql5 --defaults-file=&quot;E:\mysql5.6\my.ini&quot;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125193445167-1841671846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）执行net start mysql5启动MySQL服务（我的服务名称为mysql5，上一步install时指定了服务名称，如果install时没指定默认就是MySQL）&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125193512712-1250807819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）输入mysql -uroot -p连接数据库。第一次进入没有密码，直接回车。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125195118163-1748959908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）进入mysql数据库，查询user表的内容，发现默认使用的加密插件为mysql_native_password如下图。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125195335325-1708720356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　是不是my.ini配置的sha256_password没有生效呐？创建一个用户验证下插件是否生效。执行：CREATE USER 'test01'@'localhost' IDENTIFIED BY 'password';发现默认插件是生效了的。但是默认的root为啥不是sha256_password呢，我猜想（只是猜想）&lt;/p&gt;
&lt;p&gt;　　可能是假如root用户默认为sha256_password，那么使用root连接的话，就需要配置相关证书，这样使MySQL的安装过程复杂且使用体验降低。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125200115974-1947238631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用新创建的用户test01登录数据库，因为test01用户使用了sha256_password，此时是登录失败的，提示身份验证需要SSL加密。所以要使用了sha256_password插件的用户是需要通过SSL加密的，也就是需要证书的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125204640262-1093805371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　5）补充一点：安装完成后root用户是没有密码的，要设置密码可以执行mysqladmin -u root -p password，Enter password:直接回车，因为此时root时没有密码的，接着输入及确认输入自己的密码。至此MySQL的安装已经完成。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125201051172-1063579018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3.证书制作及使能&lt;/p&gt;
&lt;p&gt;　　1）找一台安装openssl的Linux的虚拟机，制作证书：（参考：&lt;a href=&quot;https://segmentfault.com/a/1190000007819751&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000007819751&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　　　a 生成一个 CA 私钥：openssl genrsa 2048 &amp;gt; ca-key.pem&lt;/p&gt;
&lt;p&gt;　　　　b 私钥生成一个新的数字证书：openssl req -sha1 -new -x509 -nodes -days 3650 -key ca-key.pem &amp;gt; ca-cert.pem，执行过程中需要填写一些内容，如国家、城市、邮箱等根据实际情况填写。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125205746136-561366598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　c 创建服务侧的私钥及数字证书：openssl req -sha1 -newkey rsa:2048 -days 3650 -nodes -keyout server-key.pem &amp;gt; server-req.pem&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　此时会填写一些内容如b步骤，其中有个密码可以直接回车。&lt;/p&gt;
&lt;p&gt;　　　　d 将生成的私钥转换为 RSA 私钥文件格式：openssl rsa -in server-key.pem -out server-key.pem&lt;/p&gt;
&lt;p&gt;　　　　e  谁用CA 证书来生成一个服务器端的数字证书：openssl x509 -sha1 -req -in server-req.pem -days 3650 -CA ca-cert.pem -CAkey ca-key.pem -set_serial 01 &amp;gt; server-cert.pem&lt;/p&gt;
&lt;p&gt;　　　　至此，服务端相关证书已创建成果，下面创建客户端证书。&lt;/p&gt;
&lt;p&gt;　　　　f 为客户端生成一个私钥和证书：openssl req -sha1 -newkey rsa:2048 -days 3650 -nodes -keyout client-key.pem &amp;gt; client-req.pem  需要填写问题见步骤b&lt;/p&gt;
&lt;p&gt;　　　　g 将生成的私钥转换为 RSA 私钥文件格式：openssl rsa -in client-key.pem -out client-key.pem&lt;/p&gt;
&lt;p&gt;　　　　h 为客户端创建一个数字证书：openssl x509 -sha1 -req -in client-req.pem -days 3650 -CA ca-cert.pem -CAkey ca-key.pem -set_serial 01 &amp;gt; client-cert.pem&lt;/p&gt;
&lt;p&gt;　　　　至此，客户端和服务端证书全部创建完毕，生产八个文件如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125210933105-178211526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　2）配置证书&lt;/p&gt;
&lt;p&gt;　　　　a 现在数据库中是没有开启SSL的，执行命令查看：&lt;code class=&quot;bash plain&quot;&gt;show variables like&lt;/code&gt; &lt;code class=&quot;bash string&quot;&gt;'%ssl%'&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125211309098-433746700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　b 开启SSL方法：证书使能，在MySQL的配置文件my.ini中指定服务端证书路径&lt;/p&gt;
&lt;p&gt;　　　　ssl-ca=E:/mysql5.6/cert/ca-cert.pem&lt;br/&gt;　　　　ssl-cert=E:/mysql5.6/cert/server-cert.pem&lt;br/&gt;　　　　ssl-key=E:/mysql5.6/cert/server-key.pem&lt;/p&gt;
&lt;p&gt;　　　　c 重启MySQL服务，执行net stop mysql5停止服务，再执行net startmysql5开启服务&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125212124980-314358226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　d 再次执行&lt;code class=&quot;bash plain&quot;&gt;show variables like &lt;/code&gt;&lt;code class=&quot;bash string&quot;&gt;'%ssl%'&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;; 查看SSL已经开启了&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125212322329-719818489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　至此MySQL安装及配置证书过程结束。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;测试：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、上面步骤中，在数据库中创建了以sha256_password加密的test01用户，密码为password。此时我们用一般的方式连接肯定会报错&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125213419823-744070872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2、使用开启SSL、指定证书的方式连接就是成功的，且通过\s 可以看出SSL信息，命令：mysql --ssl-ca=E:\mysql5.6\cert\ca-cert.pem --ssl-cert=E:\mysql5.6\cert\client-cert.pem --ssl-key=E:\mysql5.6\cert\client-key.pem -u test01 -ppasswor&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125213108572-1782630868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、当前系统中的root用户还是mysql_native_password的加密方式，如果要想将root的加密方式修改的话执行：&lt;/p&gt;
&lt;p&gt;　　use mysql；&lt;/p&gt;
&lt;p&gt;　　update user set plugin='sha256_password' where user='root';&lt;/p&gt;
&lt;p&gt;　　结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125214225769-941784566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在以root用户修改root用户的密码，&lt;span&gt;执行：&lt;span&gt;SET PASSWORD FOR 'root'@'localhost' = PASSWORD('1qaz@WSX');此时执行成功&lt;/span&gt;&lt;/span&gt;，再执行 FLUSH PRIVILEGES;   password列已经被修改如下图，&lt;span&gt;退出客户端重新连接为啥连不上了？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125215006611-821600974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用ssl方式连接失败了，&lt;span&gt;但是使用空密码（直接回车）登录是成功的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125214843847-2124868661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125221237982-1418381631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是为什么呢，通过分析之前使用sha256_password创建的test01用户发现：test01用户的passwor字段为空，authentication_string字段是有值的；而此时的root的password是有密文的，但authentication_string字段没有值。&lt;/p&gt;
&lt;p&gt;　　所以我们能得出2点：&lt;/p&gt;
&lt;p&gt;　　　　sha256_password加密的用户，密码其实是设置在authentication_string字段上的。&lt;/p&gt;
&lt;p&gt;　　　　root登录时，修改密码插件后，执行SET PASSWORD FOR 'root'@'localhost'设置密码时，当前CMD的session没有实效，还是&lt;span&gt;之前的加密&lt;/span&gt;插件在生效，修改的当然是password字段的值，而authentication_string字段的值依旧是空串。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125221758704-2142610026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最终使用空密码登录后再执行一次设置密码的命令，SET PASSWORD FOR 'root'@'localhost' = PASSWORD('1qaz@WSX');   FLUSH PRIVILEGES;再退出，使用root及新密码登录就是成功的了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/648637/201811/648637-20181125222536017-1209339898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;附上我的my.ini　&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_82d9c812-9b52-498e-a2e3-73d9de456d69&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_82d9c812-9b52-498e-a2e3-73d9de456d69&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82d9c812-9b52-498e-a2e3-73d9de456d69&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# For advice on how to change settings please see
# http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html&lt;/span&gt;
# *** DO NOT EDIT THIS FILE. It&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s a template which will be copied to the&lt;/span&gt;
# *** &lt;span&gt;default&lt;/span&gt; location during install, and will be replaced &lt;span&gt;if&lt;/span&gt;&lt;span&gt; you
# &lt;/span&gt;***&lt;span&gt; upgrade to a newer version of MySQL.

[mysqld]

# Remove leading # and &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; to the amount of RAM &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the most important data
# cache &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; MySQL. Start at &lt;span&gt;70&lt;/span&gt;% of total RAM &lt;span&gt;for&lt;/span&gt; dedicated server, &lt;span&gt;else&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;%&lt;span&gt;.
# innodb_buffer_pool_size &lt;/span&gt;=&lt;span&gt; 128M

# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin

# These are commonly &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;, remove the # and &lt;span&gt;set&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; required.
basedir &lt;/span&gt;= E:/mysql5.&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
datadir &lt;/span&gt;= E:/mysql5.&lt;span&gt;6&lt;/span&gt;/&lt;span&gt;data
port &lt;/span&gt;=&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
# server_id &lt;/span&gt;=&lt;span&gt; .....
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-authentication-plugin=&lt;span&gt;sha256_password 


ssl&lt;/span&gt;-ca=E:/mysql5.&lt;span&gt;6&lt;/span&gt;/cert/ca-&lt;span&gt;cert.pem
ssl&lt;/span&gt;-cert=E:/mysql5.&lt;span&gt;6&lt;/span&gt;/cert/server-&lt;span&gt;cert.pem
ssl&lt;/span&gt;-key=E:/mysql5.&lt;span&gt;6&lt;/span&gt;/cert/server-&lt;span&gt;key.pem

# Remove leading # to &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; options mainly useful &lt;span&gt;for&lt;/span&gt;&lt;span&gt; reporting servers.
# The server defaults are faster &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; transactions and fast SELECTs.
# Adjust sizes &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; needed, experiment to find the optimal values.
# join_buffer_size &lt;/span&gt;=&lt;span&gt; 128M
# sort_buffer_size &lt;/span&gt;=&lt;span&gt; 2M
# read_rnd_buffer_size &lt;/span&gt;=&lt;span&gt; 2M 

sql_mode&lt;/span&gt;=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;







</description>
<pubDate>Sun, 25 Nov 2018 15:05:00 +0000</pubDate>
<dc:creator>GrapefruitTea</dc:creator>
<og:description>MySQL5.6启用sha256_password插件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrapefruitTea/p/10017091.html</dc:identifier>
</item>
<item>
<title>SqlServer 操作 JSON - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/sqlserver-json-support.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/sqlserver-json-support.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Sql Server 从 2016 开始支持了一些 json 操作，最近的项目里也是好多地方直接用字段直接存成了 json ，需要了解一下怎么在 Sql Server 中操作 JSON.&lt;br/&gt;JSON支持适用于 SqlServer 2016 及以上版本 和 Azure SQL Database。&lt;/p&gt;
&lt;p&gt;SqlServer 中内置了一些 JSON 相关的方法：&lt;br/&gt;可以判断一段字符串是否是标准的 json（&lt;code&gt;ISJSON&lt;/code&gt;）&lt;br/&gt;可以直接查询数据成 json 格式(&lt;code&gt;FOR JSON PATH&lt;/code&gt;) 类似于之前的查询一个 xml (&lt;code&gt;FOR XML PATH&lt;/code&gt;)，&lt;br/&gt;查询一个 json 对象的值(&lt;code&gt;JSON_VALUE&lt;/code&gt;)&lt;br/&gt;查询一个 json 数组值&lt;br/&gt;更新一段JSON的内容，修改 JSON 对象里的属性值，删除 JSON 对象里的某一个属性，增加属性&lt;br/&gt;解析一段 json 内容 (&lt;code&gt;OPENJSON&lt;/code&gt;)&lt;/p&gt;
&lt;h2 id=&quot;json-操作&quot;&gt;JSON 操作&lt;/h2&gt;
&lt;h3 id=&quot;json-存储&quot;&gt;JSON 存储&lt;/h3&gt;
&lt;p&gt;数据库里 JSON 存储一般用 &lt;code&gt;NVARCHAR(MAX)&lt;/code&gt; 类型来保存，如果一定是 JSON 形式的数据可以设置一个约束，可以通过 &lt;code&gt;ISJSON&lt;/code&gt; 来给字段加约束，详情&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/json/store-json-documents-in-sql-tables?view=sql-server-2016&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;json-属性加索引&quot;&gt;JSON 属性加索引&lt;/h3&gt;
&lt;p&gt;要给 JSON 对象的某个属性加字段时，需要增加一个虚拟的列，然后在这个列中建立一个索引。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE Sales.SalesOrderHeader
ADD vCustomerName AS JSON_VALUE(Info,'$.Customer.Name')

CREATE INDEX idx_soh_json_CustomerName
ON Sales.SalesOrderHeader(vCustomerName)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;json-基本操作&quot;&gt;JSON 基本操作&lt;/h3&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;name&quot;: &quot;小明&quot;,
    &quot;info&quot;: {
        &quot;address&quot;: {
            &quot;province&quot;: &quot;河南省&quot;,
            &quot;city&quot;: &quot;郑州市&quot;,
            &quot;district&quot;: &quot;郑东新区&quot;
        },
        &quot;hobbies&quot;: [
            &quot;篮球&quot;,
            &quot;足球&quot;,
            &quot;乒乓球&quot;
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询某一属性值
SET @name = JSON_VALUE(@jsonInfo, '$.name');
SET @city = JSON_VALUE(@jsonInfo, '$.info.address.city');

-- 查询数组
SET @hobbies = JSON_QUERY(@jsonInfo, '$.info.hobbies');

-- 增加属性 tempProp

SET @jsonInfo = JSON_MODIFY(@jsonInfo, 'tempProp', 1);

-- 删除属性 tempProp
SET @jsonInfo = JSON_MODIFY(@jsonInfo, 'tempProp', null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:02:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>SqlServer 操作 JSON Intro Sql Server 从 2016 开始支持了一些 json 操作，最近的项目里也是好多地方直接用字段直接存成了 json ，需要了解一下怎么在 Sql</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/sqlserver-json-support.html</dc:identifier>
</item>
<item>
<title>3D点云目标识别和抓取 - BellaVita1</title>
<link>http://www.cnblogs.com/BellaVita/p/9979185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BellaVita/p/9979185.html</guid>
<description>&lt;h2&gt;&lt;span&gt;1、点云目标识别流程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;点云目标识别，顾名思义，需要有标准的目标点云或者标准的点云特征描述向量；对实时采集的点云数据，在里面寻找与目标点云相似度最高的点云块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118223257878-1967761723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2、圆环工件的识别和抓取&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118213927043-1689986790.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.1 点云在XY平面的投影图像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118213948159-463433440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.2 圆环点云采集图像&lt;/p&gt;
&lt;h3&gt;2.1滤波&lt;/h3&gt;
&lt;p&gt;常用点云滤波有带通滤波、统计滤波、半径滤波、去除背景平面、去除边缘。&lt;/p&gt;
&lt;p&gt;带通滤波：就是设置一个x、y、z方向的一个取值范围，以过滤掉明显不在测试距离范围的点云；比如在kinect数据采集中，由于其成像范围Z轴方向比较大，因此会出现很多明显我们不需要的背景噪声信息，这是可以设置一个合理的Z坐标阈值；&lt;/p&gt;
&lt;p&gt;半径滤波：就是搜寻给定半径R内的相邻点云个数，当个数少于给定阈值时，去除点云；主要用在去除孤立点；&lt;/p&gt;
&lt;p&gt; 统计滤波：对每个点，计算最近邻K个点云距离的均值；假设最近邻距离均值符合高斯分布，则剔除距离在一个sigma外的点云；主要用于去除不合群离散点。&lt;/p&gt;
&lt;p&gt;去除背景平面：对放在平面上的物体，背景通常会有一个较大的平面；采用Ransac拟合平面，剔除平面。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118220458623-2048857644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.3 统计滤波阈值选取方式 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118222845908-880700130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.4 圆环滤波后&lt;/p&gt;
&lt;h3&gt;2.2降采样&lt;/h3&gt;
&lt;p&gt;三维点云数据一般数据量都很大，为了提高程序的速度，可以对滤波后的数据进行降采样；降采样的原则是保证点云的整体分布情况，又不能破坏边缘信息（类似于图像处理的边缘保留Edge-preserving）。均匀降采样使用体素格的重心来表示给定半径范围内点的整体信息，来实现降采样和滤波的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118221444317-1533764184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.5 体素格降采样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118221546309-1105323909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.6 单一圆环体素格降采样（蓝色是原始点云数据，红色是降采样数据）&lt;/p&gt;
&lt;h3&gt;2.3 点云分割&lt;/h3&gt;
&lt;p&gt;通过滤波后，点云被分成了很多基本不相邻的块，可以采用聚类的方法来进行分割（类似于二维图像的连通域标记）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181118224405157-1347981895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.7 点云分割 &lt;/p&gt;
&lt;h3&gt;2.4 特征向量计算和匹配&lt;/h3&gt;
&lt;p&gt;当数据量不大的时候，可以直接计算降采样数据的特征向量；数据量很大时，最好先计算特征点（满足旋转、平移、尺度、仿射不变性），然后计算特征点处的特征向量。&lt;/p&gt;
&lt;p&gt;类似于二维图像，3d点云也可以计算每个点的特征，常用的特征描述子有SHOT（signature histogram of orientation）、FPFH（Fast Point of Histogram）等；&lt;/p&gt;
&lt;p&gt;匹配找到对应特征点对后，存在很多误匹配特征点对，需要采用Ransac对点对进行提纯，找到内点Inliners，采用ICP方法计算点对之间的旋转变换关系；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201811/1278543-20181120222717745-432611008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.8 识别的圆环（蓝色点是原始的圆环数据，红色的是识别后经过旋转、平移变化的圆环）&lt;/p&gt;
&lt;p&gt;视频信息已经上传Youtube，附网址：&lt;/p&gt;
&lt;p&gt;机器人抓取视频 &lt;a href=&quot;https://www.youtube.com/watch?v=9UaWKWEigXo&amp;amp;feature=youtu.be&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=9UaWKWEigXo&amp;amp;feature=youtu.be&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:02:00 +0000</pubDate>
<dc:creator>BellaVita1</dc:creator>
<og:description>1、点云目标识别流程 点云目标识别，顾名思义，需要有标准的目标点云或者标准的点云特征描述向量；对实时采集的点云数据，在里面寻找与目标点云相似度最高的点云块。 2、圆环工件的识别和抓取 图2.1 点云在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BellaVita/p/9979185.html</dc:identifier>
</item>
<item>
<title>Linux实用指令（2） - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10018018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10018018.html</guid>
<description>&lt;p&gt;cat指令&lt;/p&gt;
&lt;p&gt;    cat 查看文件内容，&lt;span&gt;只读的方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    cat [选项] 要查看的文件&lt;/p&gt;
&lt;p&gt;• 常用选项&lt;/p&gt;
&lt;p&gt;    -n ：显示行号&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;

&lt;p&gt;注意：cat 只能浏览文件，而不能修改文件，为了浏览方便，&lt;span&gt;一般会带上 管道命令 | more&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加上就是分页显示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224411319-396251710.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;


&lt;p&gt;more指令&lt;/p&gt;
&lt;p&gt;    more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。&lt;/p&gt;
&lt;p&gt;    more指令中内置了若干快捷键，详见操作说明&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224436248-1793665495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;more 要查看的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 操作说明&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt;案例: 采用more查看文件&lt;/p&gt;
&lt;p&gt;/etc/profile&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224501535-24700708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;less指令&lt;/p&gt;
&lt;p&gt;less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支&lt;/p&gt;
&lt;p&gt;持各种显示终端。&lt;/p&gt;
&lt;p&gt;less指令在显示文件内容时，并&lt;span&gt;不是一次将整个文件加载之后才显示&lt;/span&gt;，而是&lt;/p&gt;
&lt;p&gt;根据显示需要加载内容，&lt;span&gt;对于显示大型文件具有较高的效率&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;less 要查看的文件&lt;/p&gt;
&lt;p&gt;• 操作说明&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224543109-689362119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 指令 和 &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 指令&lt;/p&gt;
&lt;p&gt;&amp;gt; 输出重定向        &lt;span&gt;会覆盖原内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt; 追加        &lt;span&gt;不会覆盖原来的内容是追加内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    1) ls -l &amp;gt;文件 （功能描述：列表的内容写入文件a.txt中（&lt;span&gt;覆盖写&lt;/span&gt;））&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224613022-238593520.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;218&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   2) ls -al &amp;gt;&amp;gt;文件 （功能描述：列表的内容追加到文件aa.txt的末尾）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224701163-956423660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3) cat 文件1 &amp;gt; 文件2 （功能描述：将文件1的内容&lt;span&gt;覆盖&lt;/span&gt;到文件2）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224721864-100606398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   4) echo &quot;内容&quot;&amp;gt;&amp;gt; 文件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224746234-1876293088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224822486-1668834775.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;


&lt;p&gt;echo指令&lt;/p&gt;
&lt;p&gt;echo输出内容到控制台。&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    echo [选项] [输出内容]&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt;案例: 使用echo 指令输出环境变量&lt;/p&gt;
&lt;p&gt;案例: 使用echo 指令输出 ssss&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224840211-659686004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;head指令&lt;/p&gt;
&lt;p&gt;head用于&lt;span&gt;显示文件的开头部分内容&lt;/span&gt;，默认情况下head指令显示文件的前10行内容&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    head 文件 (功能描述：查看文件头10行内容)&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;head -n 5 文件&lt;/span&gt; (功能描述：查看文件头5行内容，5可以是任意行数)&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224902785-1568543017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224906942-282741643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;tail指令&lt;/p&gt;
&lt;p&gt;    tail用于&lt;span&gt;输出文件中尾部的内容&lt;/span&gt;，默认情况下tail指令显示文件的前10行内容。&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    1) tail 文件 （功能描述：查看文件头10行内容）&lt;/p&gt;
&lt;p&gt;    2) tail -n 5 文件 （功能描述：查看文件头5行内容，5可以是任意行数）&lt;/p&gt;
&lt;p&gt;    3) tail -f 文件 （功能描述：实时追踪该文档的所有更新）&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt;案例1: 查看/etc/profile 最后5行的代码&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125224940031-1931804597.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例2: 实时监控 mydate.txt , 看看到文件有变化时，是否看到， 实时的追加日期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225025323-766867936.png&quot; alt=&quot;&quot; width=&quot;855&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;


&lt;p&gt;ln 指令&lt;/p&gt;
&lt;p&gt;    软链接也成为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    ln -s [原文件或目录]  [软链接名] （功能描述：给原文件创建一个软链接）&lt;/p&gt;

&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt;案例1: 在/home 目录下创建一个软连接 linkToRoot，连接到 /root 目录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们使用pwd指令查看目录时，仍然看到的是软链接所在目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225054223-1087029079.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例2: 删除软连接 linkToRoot&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除时不需要带  /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225142754-129726653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;history指令&lt;/p&gt;
&lt;p&gt;查看已经执行过历史命令,也可以执行历史指令&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    history （功能描述：查看已经执行过历史命令）&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt;案例1: 显示所有的历史命令&lt;/p&gt;
&lt;p&gt;不加参数默认显示本次连接所使用到的历史指令&lt;/p&gt;
&lt;p&gt; 案例2: 显示最近使用过的10个指令。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225225556-673431606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例3：执行历史编号为5的指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225242617-1233388113.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt; 时间日期类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;date指令-显示当前日期&lt;/p&gt;

&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    1) date （功能描述：显示当前时间）&lt;/p&gt;
&lt;p&gt;    2) date +%Y （功能描述：显示当前年份）&lt;/p&gt;
&lt;p&gt;    3) date +%m （功能描述：显示当前月份）&lt;/p&gt;
&lt;p&gt;    4) date +%d （功能描述：显示当前是哪一天）&lt;/p&gt;
&lt;p&gt;    5) date &quot;+%Y-%m-%d %H:%M:%S&quot;（功能描述：显示年月日时分秒）&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225318782-1805788582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225332806-501073788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;date指令-设置日期&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;date -s 字符串时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt;案例1: 设置系统当前时间 ， 比如设置成 2020-11-11 11:22:22&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225355651-1303093841.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;


&lt;p&gt;cal指令&lt;/p&gt;
&lt;p&gt;查看日历指令&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;cal [选项] （功能描述：不加选项，显示本月日历）&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225418503-556312890.png&quot; alt=&quot;&quot; width=&quot;455&quot; height=&quot;367&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 搜索查找类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;find指令&lt;/p&gt;
&lt;p&gt;    find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    find &lt;span&gt;[搜索范围]&lt;/span&gt; [选项]&lt;/p&gt;
&lt;p&gt;• 选项说明&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225503553-1477742054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225533419-1967096162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; + 是大于   -是小于   不写则是相等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225559973-694631906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;locate指令&lt;/p&gt;
&lt;p&gt;    locaate指令&lt;span&gt;可以快速定位文件路径&lt;/span&gt;。locate指令利用事先建立的系统中所有文件名称及路径&lt;/p&gt;
&lt;p&gt;    的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。&lt;/p&gt;
&lt;p&gt;    为了保证查询结果的准确度，管理员必须定期更新locate时刻。&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    locate 搜索文件&lt;/p&gt;
&lt;p&gt;• 特别说明&lt;/p&gt;
&lt;p&gt;    由于locate指令基于数据库进行查询，所以第一次运行前，&lt;span&gt;必须使用updatedb指令创建locate数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225634115-1432881996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;grep指令和 管道符号 |&lt;/p&gt;
&lt;p&gt;    grep &lt;span&gt;过滤查找&lt;/span&gt; ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    grep [选项] 查找内容 源文件&lt;/p&gt;
&lt;p&gt;• 常用选项&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225659754-1019654817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225717784-2043793818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;行号不区分大小写&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225756479-907127185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;gzip/gunzip 指令&lt;/p&gt;
&lt;p&gt;        gzip 用于压缩文件， gunzip 用于解压的&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;        gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz文件）&lt;/p&gt;
&lt;p&gt;        gunzip 文件.gz （功能描述：解压缩文件命令）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用gzip对文件进行压缩后，，不会保留原文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225814144-1572693212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;zip/unzip 指令&lt;/p&gt;
&lt;p&gt;        zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;        zip [选项] XXX.zip  将要压缩的内容    （功能描述：压缩文件和目录的命令）&lt;/p&gt;
&lt;p&gt;        unzip [选项] XXX.zip    （功能描述：解压缩文件）&lt;/p&gt;
&lt;p&gt;• zip常用选项&lt;/p&gt;
&lt;p&gt;        -r：递归压缩，即压缩目录&lt;/p&gt;
&lt;p&gt;• unzip的常用选项&lt;/p&gt;
&lt;p&gt;        -d&amp;lt;目录&amp;gt; ：指定解压后文件的存放目录&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225826715-560444651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225829991-792975980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;tar 指令&lt;/p&gt;
&lt;p&gt;    tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    tar [选项] XXX.tar.gz 打包的内容 (功能描述：打包目录，压缩后的文件格式.tar.gz)&lt;/p&gt;
&lt;p&gt;• 选项说明&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225841692-531890551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时原文件依然存在&lt;/p&gt;
&lt;p&gt;整体打包     /home/*&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225920431-1850346170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125225938931-1513991155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;解压到的目录前提必须有这个目录才行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必须加上-C&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181125230021563-1368587882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:01:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>cat指令 cat 查看文件内容，只读的方式 • 基本语法 cat [选项] 要查看的文件 • 常用选项 -n ：显示行号 • 应用实例 注意：cat 只能浏览文件，而不能修改文件，为了浏览方便，一般</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10018018.html</dc:identifier>
</item>
<item>
<title>Dubbo源码学习--优雅停机原理及在SpringBoot中遇到的问题 - JavaNoob</title>
<link>http://www.cnblogs.com/javanoob/p/dubbo_graceful_shutdown.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javanoob/p/dubbo_graceful_shutdown.html</guid>
<description>&lt;p&gt;Dubbo源码学习--优雅停机原理及在SpringBoot中遇到的问题&lt;/p&gt;
&lt;h2 id=&quot;相关文章&quot;&gt;相关文章：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/javanoob/p/dubbo_menu.html&quot;&gt;Dubbo源码学习文章目录&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;主要是前一阵子换了工作，第一个任务就是解决目前团队在 Dubbo 停机时产生的问题，同时最近又看了一下 Dubbo 的源码，想重新写一下 Dubbo 相关的文章。&lt;/p&gt;
&lt;h2 id=&quot;优雅停机原理&quot;&gt;优雅停机原理&lt;/h2&gt;
&lt;p&gt;对于一个 java 应用，如果想在关闭应用时，执行一些释放资源的操作一般是通过注册一个 ShutDownHook ，当关闭应用时，不是调用 kill -9 命令来直接终止应用，而是通过调用 kill -15 命令来触发这个 ShutDownHook 进行停机前的释放资源操作。&lt;br/&gt;对于 Dubbo 来说，需要停机前执行的操作包括两部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于服务的提供者，需要通知注册中心来把自己在服务列表中摘除掉。&lt;/li&gt;
&lt;li&gt;根据所配置的协议，关闭协议的端口和连接。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而何为优雅停机呢？就是在集群环境下，有一个应用停机，并不会出现异常。下面来看一下 Dubbo 是怎么做的。&lt;/p&gt;
&lt;h3 id=&quot;注册shutdownhook&quot;&gt;注册ShutDownHook&lt;/h3&gt;
&lt;p&gt;Duubo 在 AbstractConfig 的静态构造函数中注册了 JVM 的 ShutDownHook，而 ShutdownHook 主要是调用 ProtocolConfig.destroyAll() ，源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static {
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
            public void run() {
                if (logger.isInfoEnabled()) {
                    logger.info(&quot;Run shutdown hook now.&quot;);
                }
                ProtocolConfig.destroyAll();
            }
        }, &quot;DubboShutdownHook&quot;));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;protocolconfig.destroyall&quot;&gt;ProtocolConfig.destroyAll()&lt;/h3&gt;
&lt;p&gt;先看一下 ProtocolConfig.destroyAll() 源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
  public static void destroyAll() {
        if (!destroyed.compareAndSet(false, true)) {
            return;
        }
        AbstractRegistryFactory.destroyAll();  //1.

        // Wait for registry notification
        try {
            Thread.sleep(ConfigUtils.getServerShutdownTimeout()); //2.
        } catch (InterruptedException e) {
            logger.warn(&quot;Interrupted unexpectedly when waiting for registry notification during shutdown process!&quot;);
        }

        ExtensionLoader&amp;lt;Protocol&amp;gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class);
        for (String protocolName : loader.getLoadedExtensions()) {
            try {
                Protocol protocol = loader.getLoadedExtension(protocolName);
                if (protocol != null) {
                    protocol.destroy(); //3.
                }
            } catch (Throwable t) {
                logger.warn(t.getMessage(), t);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ProtocolConfig.destroyAll() 有三个比较重要的操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在1这个点调用AbstractRegistryFactory.destroyAll(),其内部会对每个注册中心进行 destroy 操作，进而把注册到注册中心的服务取消注册。&lt;/li&gt;
&lt;li&gt;2这个点是最近 Dubbo 版本新增的操作，用来增强 Dubbo 的优雅停机，在老版本的 Dubbo 其逻辑是直接摘除服务列表，关闭暴露的连接，因为服务取消注册，注册中心是异步的通知消费者变更其存放在自己内存中的提供者列表。因为是异步操作，当调用量比较大的应用时消费者会拿到已经关闭连接点的提供者进行调用，这时候就会产生大量的错误，而2这个点就是通过Sleep 来延迟关闭协议暴露的连接。&lt;/li&gt;
&lt;li&gt;因为 Dubbo 的扩展机制 ，loader.getLoadedExtensions() 会获取到已使用的所有协议，遍历调用 destroy 方法来关闭其打开的端口和连接。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而在第3步会在 Exchange 层 对所有打开的连接进行判断其有没有正在执行的请求，如果有会自旋 Sleep 直到设置的 ServerShutdownTimeout 时间或者已经没有正在执行的请求了才会关闭连接，源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public void close(final int timeout) {
       startClose();
       if (timeout &amp;gt; 0) {
           final long max = (long) timeout;
           final long start = System.currentTimeMillis();
           if (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, true)) {
               sendChannelReadOnlyEvent();
           }
           while (HeaderExchangeServer.this.isRunning() //判断是否还有正在处理的请求
                   &amp;amp;&amp;amp; System.currentTimeMillis() - start &amp;lt; max) { //判断是否超时
               try {
                   Thread.sleep(10);
               } catch (InterruptedException e) {
                   logger.warn(e.getMessage(), e);
               }
           }
       }
       doClose();  
       server.close(timeout); //正在的关闭连接
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;## 在 SpringBoot 应用中存在的问题&lt;/p&gt;
&lt;p&gt;简单的描述一下问题：就是在应用停机时，瞬间会产生大量的报错，比如拿到的数据库连接已经关闭等问题。 其实一看就知道是在停机时还存在正在处理的请求，而这些请求所需要的资源被 Spring 容器所关闭导致的。原来在SpringBoot 启动时会在 refreshContext 操作也注册一个 ShotdownHook 来关闭Spring容器。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void refreshContext(ConfigurableApplicationContext context) {
       this.refresh(context);
       if (this.registerShutdownHook) {
           try {
               context.registerShutdownHook();
           } catch (AccessControlException var3) {
           }
       }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而要解决这个问题就需要取消掉这个 ShutDownHook ，然后再 Dubbo 优雅停机执行后关闭 Spring 容器。具体的修改如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在启动Main方法中，修改SpringBoot 启动代码，取消注册ShutDownHook。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
       SpringApplication app = new SpringApplication(XxxApplication.class);
       app.setRegisterShutdownHook(false);
       app.run(args);
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;注册一个Bean 来让 Dubbo 关闭后关闭Spring容器。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SpringShutdownHook {
   private static final Logger logger = LoggerFactory.getLogger(SpringShutdownHook.class);
   @Autowired
   private ConfigurableApplicationContext configurableApplicationContext;

   public SpringShutdownHook() {
   }

   @PostConstruct
   public void registerShutdownHook() {
       logger.info(&quot;[SpringShutdownHook] Register ShutdownHook....&quot;);
       Thread shutdownHook = new Thread() {
           public void run() {
               try {
                   int timeOut = ConfigUtils.getServerShutdownTimeout();
                   SpringShutdownHook.logger.info(&quot;[SpringShutdownHook] Application need sleep {} seconds to wait Dubbo shutdown&quot;, (double)timeOut / 1000.0D);
                   Thread.sleep((long)timeOut);
                   SpringShutdownHook.this.configurableApplicationContext.close();
                   SpringShutdownHook.logger.info(&quot;[SpringShutdownHook] ApplicationContext closed, Application shutdown&quot;);
               } catch (InterruptedException var2) {
                   SpringShutdownHook.logger.error(var2.getMessage(), var2);
               }

           }
       };
       Runtime.getRuntime().addShutdownHook(shutdownHook);
   }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 25 Nov 2018 14:50:00 +0000</pubDate>
<dc:creator>JavaNoob</dc:creator>
<og:description>Dubbo源码学习 优雅停机原理及在SpringBoot中遇到的问题 相关文章：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/javanoob/p/dubbo_graceful_shutdown.html</dc:identifier>
</item>
<item>
<title>python模块和包 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-module-and-package.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-module-and-package.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;模块&quot;&gt;1. 模块&lt;/h2&gt;
&lt;h3 id=&quot;模块的概念&quot;&gt;1.1 模块的概念&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;模块是 Python 程序架构的一个核心概念&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;每一个以扩展名 &lt;code&gt;py&lt;/code&gt; 结尾的 &lt;code&gt;Python&lt;/code&gt; 源代码文件都是一个 &lt;strong&gt;模块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块名&lt;/strong&gt; 同样也是一个 &lt;strong&gt;标识符&lt;/strong&gt;，需要符合标识符的命名规则&lt;/li&gt;
&lt;li&gt;在模块中定义的 &lt;strong&gt;全局变量&lt;/strong&gt; 、&lt;strong&gt;函数&lt;/strong&gt;、&lt;strong&gt;类&lt;/strong&gt; 都是提供给外界直接使用的 &lt;strong&gt;工具&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块&lt;/strong&gt; 就好比是 &lt;strong&gt;工具包&lt;/strong&gt;，要想使用这个工具包中的工具，就需要先 &lt;strong&gt;导入&lt;/strong&gt; 这个模块&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模块的两种导入方式&quot;&gt;1.2 模块的两种导入方式&lt;/h3&gt;
&lt;h4 id=&quot;import-导入&quot;&gt;1）import 导入&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import 模块名1, 模块名2 &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;提示：在导入模块时，每个导入应该独占一行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import 模块名1
import 模块名2 &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;导入之后&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;code&gt;模块名.&lt;/code&gt; 使用 &lt;strong&gt;模块提供的工具&lt;/strong&gt; —— &lt;strong&gt;全局变量&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt;、&lt;strong&gt;类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;使用-as-指定模块的别名&quot;&gt;使用 &lt;code&gt;as&lt;/code&gt; 指定模块的别名&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果模块的名字太长&lt;/strong&gt;，可以使用 &lt;code&gt;as&lt;/code&gt; 指定模块的名称，以方便在代码中的使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import 模块名1 as 模块别名&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：&lt;strong&gt;模块别名&lt;/strong&gt; 应该符合 &lt;strong&gt;大驼峰命名法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;from...import-导入&quot;&gt;2）from...import 导入&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果希望 &lt;strong&gt;从某一个模块&lt;/strong&gt; 中，导入 &lt;strong&gt;部分&lt;/strong&gt; 工具，就可以使用 &lt;code&gt;from ... import&lt;/code&gt; 的方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import 模块名&lt;/code&gt; 是 &lt;strong&gt;一次性&lt;/strong&gt; 把模块中 &lt;strong&gt;所有工具全部导入&lt;/strong&gt;，并且通过 &lt;strong&gt;模块名/别名&lt;/strong&gt; 访问&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 从 模块 导入 某一个工具
from 模块名1 import 工具名&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;导入之后
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不需要&lt;/strong&gt; 通过 &lt;code&gt;模块名.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以直接使用 &lt;strong&gt;模块提供的工具&lt;/strong&gt; —— &lt;strong&gt;全局变量&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt;、&lt;strong&gt;类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果 &lt;strong&gt;两个模块&lt;/strong&gt;，存在 &lt;strong&gt;同名的函数&lt;/strong&gt;，那么 &lt;strong&gt;后导入模块的函数&lt;/strong&gt;，会 &lt;strong&gt;覆盖掉先导入的函数&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;开发时 &lt;code&gt;import&lt;/code&gt; 代码应该统一写在 &lt;strong&gt;代码的顶部&lt;/strong&gt;，更容易及时发现冲突&lt;/li&gt;
&lt;li&gt;一旦发现冲突，可以使用 &lt;code&gt;as&lt;/code&gt; 关键字 &lt;strong&gt;给其中一个工具起一个别名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;from...import&quot;&gt;from...import *&lt;/h5&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 从 模块 导入 所有工具
from 模块名1 import *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模块的搜索顺序&quot;&gt;1.3 模块的搜索顺序&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 的解释器在 &lt;strong&gt;导入模块&lt;/strong&gt; 时，会：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;搜索 &lt;strong&gt;当前目录&lt;/strong&gt; 指定模块名的文件，&lt;strong&gt;如果有就直接导入&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果没有，再搜索 &lt;strong&gt;系统目录&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在开发时，给文件起名，不要和 &lt;strong&gt;系统的模块文件&lt;/strong&gt; &lt;strong&gt;重名&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 中每一个模块都有一个内置属性 &lt;code&gt;__file__&lt;/code&gt; 可以 &lt;strong&gt;查看模块&lt;/strong&gt; 的 &lt;strong&gt;完整路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import random

# print(random.__file__)

print(random.randint(0, 10))
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果当前目录下，存在一个 &lt;code&gt;random.py&lt;/code&gt; 的文件，程序就无法正常执行了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;这个时候，&lt;code&gt;Python&lt;/code&gt; 的解释器会 &lt;strong&gt;加载当前目录&lt;/strong&gt; 下的 &lt;code&gt;random.py&lt;/code&gt; 而不会加载 &lt;strong&gt;系统的&lt;/strong&gt; &lt;code&gt;random&lt;/code&gt; 模块&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;原则-每一个文件都应该是可以被导入的&quot;&gt;1.4 原则 —— 每一个文件都应该是可以被导入的&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;一个 &lt;strong&gt;独立的 Python 文件&lt;/strong&gt; 就是一个 &lt;strong&gt;模块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在导入文件时，文件中 &lt;strong&gt;所有没有任何缩进的代码&lt;/strong&gt; 都会被执行一遍！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;实际开发场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在实际开发中，每一个模块都是独立开发的，大多都有专人负责&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开发人员&lt;/strong&gt; 通常会在 &lt;strong&gt;模块下方&lt;/strong&gt; &lt;strong&gt;增加一些测试代码&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;仅在模块内使用，而被导入到其他文件中不需要执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;name__-属性&quot;&gt;&lt;code&gt;__name__&lt;/code&gt; 属性&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;__name__&lt;/code&gt; 属性可以做到，测试模块的代码 &lt;strong&gt;只在测试情况下被运行&lt;/strong&gt;，而在 &lt;strong&gt;被导入时不会被执行&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;__name__&lt;/code&gt; 是 &lt;code&gt;Python&lt;/code&gt; 的一个内置属性，记录着一个 &lt;strong&gt;字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;是被其他文件导入的&lt;/strong&gt;，&lt;code&gt;__name__&lt;/code&gt; 就是 &lt;strong&gt;模块名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;是当前执行的程序&lt;/strong&gt; &lt;code&gt;__name__&lt;/code&gt; 是 &lt;strong&gt;&lt;strong&gt;main&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;在很多 Python 文件中都会看到以下格式的代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 导入模块
# 定义全局变量
# 定义类
# 定义函数

# 在代码的最下方
def main():
    # ...
    pass

# 根据 __name__ 判断是否执行下方代码
if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;包package&quot;&gt;2. 包（Package）&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;包&lt;/strong&gt; 是一个 &lt;strong&gt;包含多个模块&lt;/strong&gt; 的 &lt;strong&gt;特殊目录&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目录下有一个 &lt;strong&gt;特殊的文件&lt;/strong&gt; &lt;code&gt;__init__.py&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;包名的 &lt;strong&gt;命名方式&lt;/strong&gt; 和变量名一致，&lt;strong&gt;小写字母&lt;/strong&gt; + &lt;code&gt;_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;import 包名&lt;/code&gt; 可以一次性导入 &lt;strong&gt;包&lt;/strong&gt; 中 &lt;strong&gt;所有的模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;案例演练&quot;&gt;案例演练&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;新建一个 &lt;code&gt;zfx_message&lt;/code&gt; 的 &lt;strong&gt;包&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在目录下，新建两个文件 &lt;code&gt;send_message&lt;/code&gt; 和 &lt;code&gt;receive_message&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;send_message&lt;/code&gt; 文件中定义一个 &lt;code&gt;send&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;receive_message&lt;/code&gt; 文件中定义一个 &lt;code&gt;receive&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;在外部直接导入 &lt;code&gt;zfx_message&lt;/code&gt; 的包&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;要在外界使用 &lt;strong&gt;包&lt;/strong&gt; 中的模块，需要在 &lt;code&gt;__init__.py&lt;/code&gt; 中指定 &lt;strong&gt;对外界提供的模块列表&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 从 当前目录 导入 模块列表
from . import send_message
from . import receive_message&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;发布模块&quot;&gt;3. 发布模块&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果希望自己开发的模块，&lt;strong&gt;分享&lt;/strong&gt; 给其他人，可以按照以下步骤操作&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;制作发布压缩包步骤&quot;&gt;3.1 制作发布压缩包步骤&lt;/h3&gt;
&lt;h4 id=&quot;创建-setup.py&quot;&gt;1) 创建 setup.py&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;setup.py&lt;/code&gt; 的文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from distutils.core import setup

setup(name=&quot;xxx&quot;,  # 包名
      version=&quot;x.x.x&quot;,  # 版本
      description=&quot;xxx&quot;,  # 描述信息
      long_description=&quot;xxx&quot;,  # 完整描述信息
      author=&quot;xxx&quot;,  # 作者
      author_email=&quot;xx@xx.xx&quot;,  # 作者邮箱
      url=&quot;www.xxx.com&quot;,  # 主页
      py_modules=[&quot;xxx.xx&quot;,
                  &quot;xx.xxx&quot;])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有关字典参数的详细信息，可以参阅官方网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/distutils/apiref.html&quot; class=&quot;uri&quot;&gt;https://docs.python.org/2/distutils/apiref.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;构建模块&quot;&gt;2) 构建模块&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ python3 setup.py build&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;生成发布压缩包&quot;&gt;3) 生成发布压缩包&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ python3 setup.py sdist&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装模块&quot;&gt;3.2 安装模块&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ tar zxvf zfx_message-1.0.0.tar.gz

$ sudo python3 setup.py install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;卸载模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接从安装目录下，把安装模块的 &lt;strong&gt;目录&lt;/strong&gt; 删除就可以&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ cd /usr/local/lib/python3.5/dist-packages/
$ sudo rm -r zfx_message*&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pip-安装第三方模块&quot;&gt;3.3 &lt;code&gt;pip&lt;/code&gt; 安装第三方模块&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第三方模块&lt;/strong&gt; 通常是指由 &lt;strong&gt;知名的第三方团队&lt;/strong&gt; &lt;strong&gt;开发的&lt;/strong&gt; 并且被 &lt;strong&gt;程序员广泛使用&lt;/strong&gt; 的 &lt;code&gt;Python&lt;/code&gt; 包 / 模块
&lt;ul&gt;&lt;li&gt;例如 &lt;code&gt;pygame&lt;/code&gt; 就是一套非常成熟的 &lt;strong&gt;游戏开发模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip&lt;/code&gt; 是一个现代的，通用的 &lt;code&gt;Python&lt;/code&gt; 包管理工具&lt;/li&gt;
&lt;li&gt;提供了对 &lt;code&gt;Python&lt;/code&gt; 包的查找、下载、安装、卸载等功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;安装和卸载命令如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 将模块安装到 Python 2.x 环境
$ sudo pip install pygame
$ sudo pip uninstall pygame

# 将模块安装到 Python 3.x 环境
$ sudo pip3 install pygame
$ sudo pip3 uninstall pygame&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在-mac-下安装-ipython&quot;&gt;在 &lt;code&gt;Mac&lt;/code&gt; 下安装 &lt;code&gt;iPython&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo pip install ipython&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在-linux-下安装-ipython&quot;&gt;在 &lt;code&gt;Linux&lt;/code&gt; 下安装 &lt;code&gt;iPython&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo apt install ipython
$ sudo apt install ipython3&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 25 Nov 2018 14:46:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 1. 模块 1.1 模块的概念 模块是 Python 程序架构的一个核心概念 每一个以扩展名 结尾的 源代码文件都是一个 模块 模块名 同样也是一个 标识符 ，需要符合标识符的命名规则 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-module-and-package.html</dc:identifier>
</item>
<item>
<title>2 手写Java LinkedList核心源码 - 九路313</title>
<link>http://www.cnblogs.com/start1225/p/10017937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start1225/p/10017937.html</guid>
<description>&lt;p&gt;上一章我们手写了ArrayList的核心源码，ArrayList底层是用了一个数组来保存数据，数组保存数据的优点就是查找效率高，但是删除效率特别低，最坏的情况下需要移动所有的元素。在查找需求比较重要的情况下可以用ArrayList，如果是删除操作比较多的情况下，用ArrayList就不太合适了。Java为我们提供了LinkedList，是用链接来实现的，我们今天就来手写一个QLinkedList，来提示底层是怎么做的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/594516/201811/594516-20181125224914786-978377305.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，底层用一个双链表，另外有两个指示器，一个指向头，一个指向尾。&lt;br/&gt;链表中的每个节点的next指向下一个节点，同理pre指向上一个节点，第一个节点的pre为null，最后一个节点的next为null&lt;/p&gt;
&lt;p&gt;双链表的细节实现较多，尤其是边界的问题，要十分仔细，LinkedList中设计了许多的小函数，本例中就不设计那么多的小方法了，直接把最核心的代码都写到一个方法中。以方便揭示核心原理。&lt;/p&gt;
&lt;p&gt;下面是完整的QLinkedList的源码，注释很清楚。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class QLinkedList&amp;lt;T&amp;gt; {
    private QNode&amp;lt;T&amp;gt; first; //指向头节点
    private QNode&amp;lt;T&amp;gt; last;  //指向尾节点

    private int size;    //节点的个数

    //节点类
    public static class QNode&amp;lt;T&amp;gt; {
        T value;        //数据
        QNode&amp;lt;T&amp;gt; pre;   //指向上一个节点
        QNode&amp;lt;T&amp;gt; next;  //指向下一个节点


        public QNode(QNode&amp;lt;T&amp;gt; pre, QNode&amp;lt;T&amp;gt; next, T value) {
            this.pre = pre;     //节点的上一个指向
            this.next = next;   //节点的下一个指向
            this.value = value; //存放的数据
        }
    }

    public QLinkedList() {

        //默认是一个空狼链表，first,last都为null, 节点个数为0
        first = null;
        last = null;
        size = 0;
    }

    //默认添加到尾
    public void add(T e) {
        addLast(e);
    }

    //添加到头部
    public void addFirst(T e) {
        if (first == null &amp;amp;&amp;amp; last == null) {
            QNode&amp;lt;T&amp;gt; node = new QNode&amp;lt;&amp;gt;(null, null, e);
            first = node;
            last = node;
        } else {
            QNode&amp;lt;T&amp;gt; node = new QNode&amp;lt;&amp;gt;(null, first, e);
            first.pre = node;
        }

        size++;
    }

    //添加到尾部,我们默认添加的都是不为null的数据
    public void addLast(T e) {
        if (e == null) {
            throw new RuntimeException(&quot;e == null&quot;);
        }

        //1 链表还是空的时候
        if (size == 0) {

            //1.1 新建一个节点，pre,next都为null
            QNode&amp;lt;T&amp;gt; node = new QNode(null, null, e);

            //1.2 只有一个节点，first,last都指向null
            first = node;
            last = node;


        //2 链表不为空
        } else {

            //2.1 新建一个节点，pre指向last最后一个节点，next为null(因为是最后一个节点)
            QNode&amp;lt;T&amp;gt; node = new QNode&amp;lt;&amp;gt;(last, null, e);

            //2.2 同时之前的最后一节点的next 指向新建的node节点
            last.next = node;

            //2.3 然后移动last，让last指向最后一个节点
            last = node;
        }

        //添加一个节点后，别忘了节点的总数加 1
        size++;
    }

    // position 从 0 开始
    // 这里面有个小技巧，可以先判断一下 position 是大于 size/2 还是小于 size/2
    // 如果 position &amp;gt; size / 2 , 说明position是在链表的后半段，我们可以从last开始往前遍历
    // 如果 position &amp;lt; size / 2, 说明position是在链表的前半段，我们可以从first开始往后遍历
    // 这样效率会高许多，这也是双链表的意义所在，我们这里就不这样做了。直接从前往后遍历
    // 读者可以自己实现，以加深对链表的理解
    public T get(int position) {
        // 不合法的position直接抛异常，让开发者直接定位问题
        if (position &amp;lt; 0 || position &amp;gt; size - 1) {
            throw new RuntimeException(&quot;invalid position&quot;);
        }

        // 如果链表为空，直接返回null
        if (size == 0) {
            return null;
        }

        // 如果链表只有一个节点，直接返回
        // 因为position合法性在前面已经验证过
        // 所以在这里面不用验证，一定是0
        if(size == 1){
            return first.value;
        }

        // 注意这个新建的 p 节点，p.next 指向的是 first
        // 这是为了下面的循环，保证 i == 0 的时候，p 指向第一个节点
        QNode&amp;lt;T&amp;gt; p = new QNode&amp;lt;&amp;gt;(null, first, null);
        for (int i = 0; i &amp;lt;= position; i++) {
            p = p.next;
        }

        //如果找到了，就返回value
        if (p != null) {
            return p.value;
        }

        //否则返回 null
        return null;
    }

    // 返回链表的节点总个数
    // 注意first和last节点只是帮助我们方便操作的
    // size可不包括first,last
    public int size() {
        return size;
    }

    // 删除一个元素，这里传的参数是 T e ，我们也可以传position进行删除，这里就不作演示了
    // 可以先调用上面的get()方法，返回对应的值，再调用此方法
    // 读者可以自己实现
    public T remove(T e) {
        //1 不合法，抛异常
        if (e == null) {
            throw new RuntimeException(&quot;e == null&quot;);
        }

        //2 链表为空，返回 null
        if (size == 0) {
            return null;
        }

        //2 如果链表只有一个节点
        if (size == 1) {
            QNode&amp;lt;T&amp;gt; node = first;

            //3 如果相等，删除节点 size-- ,并把first,last赋值为null
            if(e == node.value || e.equals(node.value)){
                first = last = null;
                size--;
                return node.value;
            }else {
                //4 不相等，返回null
                return null;
            }
        }

        // 如果链表大于1个节点，我们从前往后找value等于e的节点
        // 1 查找， 和get()方法一样，注意p的next指向first
        QNode&amp;lt;T&amp;gt; p = new QNode&amp;lt;&amp;gt;(null, first, null);
        boolean find = false;
        for (int i = 0; i &amp;lt; size; i++) {
            p = p.next;

            if (p != null &amp;amp;&amp;amp; (e == p.value || e.equals(p.value))) {
                find = true;
                break;
            }
        }

        // 2 如果找到了
        if (find) {
            // 2.1 如果找到的节点是最后一个节点
            // 删除的是最后一个
            if (p.next == null) {

                //2.2 改变last的值，指向p的前一个节点
                last = p.pre;

                //2.3 p的前一个节点，变成了最后一个节点，所以，前一个节点的next值赋值为null
                p.pre.next = null;

                //2.4 把p.pre赋值为null,已经没有用了
                p.pre = null;

                //2.5 别忘了节点个数减1
                size--;

                //2.6 返回删除的节点的value
                return p.value;

            //3.1 如果删除的是第一个节点（p.pre == null就表明是第一个节点）
            } else if (p.pre == null) {

                //3.2 改变first的指向，指向p的下一个节点
                first = p.next;

                //3.3 p的下一个节点变成了第一个节点，需要把p的下一个节点的pre指向为null
                p.next.pre = null;

                //3.4 p.next没有用了
                p.next = null;

                //3.5 别忘了节点个数减1
                size--;

                //3.6 返回删除的节点的value
                return p.value;


            // 4 如果删除的不是第一个也不是最后一个，是中间的某一个，这种情况最简单
            } else {

                //4.1 p的上一个节点的next需要指向p的下一个节点
                p.pre.next = p.next;

                //4.2 p 的下一个节点的pre需要指向p的上一个节点
                p.next.pre = p.pre;

                //4.3 此时p无用了，把p的pre,next赋值为null
                //这时候不需要调整first,last的位置
                p.pre = null;
                p.next = null;

                //4.4 别忘了节点个数减1
                size--;

                //4.5 返回删除的节点的value
                return p.value;
            }
        }

        //没有找到与e相等的节点，直接返回null
        return null;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来测试一下QLinkedList，测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public static void main(String[] args) {
        QLinkedList&amp;lt;String&amp;gt; list = new QLinkedList&amp;lt;&amp;gt;();
        list.add(&quot;one&quot;);
        list.add(&quot;two&quot;);
        list.add(&quot;three&quot;);
        list.add(&quot;four&quot;);

        System.out.println(list.size);
        for (int i = 0; i &amp;lt; list.size; i++) {
            System.out.println(list.get(i));
        }

        System.out.println(&quot;===================&quot;);

        System.out.println(list.remove(&quot;two&quot;));
        System.out.println(list.size);
        for (int i = 0; i &amp;lt; list.size; i++) {
            System.out.println(list.get(i));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4
one
two
three
four
===================
two
3
one
three
four&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见我们的QLinkedList可以正常的add,get,size,remove了。&lt;br/&gt;建议可以参考一下JDK中的LinkedList。以加深对LinkedList的理解&lt;br/&gt;明天手写HashMap的核心源码实现&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 14:44:00 +0000</pubDate>
<dc:creator>九路313</dc:creator>
<og:description>上一章我们手写了ArrayList的核心源码，ArrayList底层是用了一个数组来保存数据，数组保存数据的优点就是查找效率高，但是删除效率特别低，最坏的情况下需要移动所有的元素。在查找需求比较重要的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/start1225/p/10017937.html</dc:identifier>
</item>
</channel>
</rss>