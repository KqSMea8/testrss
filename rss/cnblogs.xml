<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一步步实现滑动验证码，Java图片处理关键代码 - echov</title>
<link>http://www.cnblogs.com/yaohonv/p/swipecaptcha.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohonv/p/swipecaptcha.html</guid>
<description>&lt;p&gt;　　最近滑动验证码在很多网站逐步流行起来，一方面对用户体验来说，比较新颖，操作简单，另一方面相对图形验证码来说，安全性并没有很大的降低。当然到目前为止，没有绝对的安全验证，只是不断增加攻击者的绕过成本。&lt;/p&gt;
&lt;p&gt;      接下来分析下滑动验证码的核心流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;后端随机生成抠图和带有抠图阴影的背景图片，后台保存随机抠图位置坐标&lt;/li&gt;
&lt;li&gt;前端实现滑动交互，将抠图拼在抠图阴影之上，获取到用户滑动距离值，比如以下示例&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0108/191520_98Ci_251057.png&quot; alt=&quot;&quot; width=&quot;826&quot; height=&quot;802&quot;/&gt;&lt;/li&gt;
&lt;li&gt;前端将用户滑动距离值传入后端，后端校验误差是否在容许范围内。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        这里单纯校验用户滑动距离是最基本的校验，出于更高的安全考虑，可能还会考虑用户滑动的整个轨迹，用户在当前页面的访问行为等。这些可以很复杂，甚至借助到用户行为数据分析模型，最终的目标都是增加非法的模拟和绕过的难度。这些有机会可以再归纳总结常用到的方法，本文重点集中在如何基于Java来一步步实现滑动验证码的生成。&lt;/p&gt;
&lt;p&gt;    可以看到，滑动图形验证码，重要有两个图片组成，抠块和带有抠块阴影的原图，这里面有两个重要特性保证被暴力破解的难度：抠块的形状随机和抠块所在原图的位置随机。这样就可以在有限的图集中制造出随机的、无规律可寻的抠图和原图的配对。&lt;/p&gt;
&lt;p&gt;    用代码如何从一张大图中抠出一个有特定随机形状的小图呢？&lt;/p&gt;
&lt;p&gt;    第一步，先确定一个抠出图的轮廓，方便后续真正开始执行图片处理操作&lt;/p&gt;
&lt;p&gt;    图片是有像素组成，每个像素点对应一种颜色，颜色可以用RGB形式表示，外加一个透明度，把一张图理解成一个平面图形，左上角为原点，向右x轴，向下y轴，一个坐标值对应该位置像素点的颜色，这样就可以把一张图转换成一个二维数组。基于这个考虑，轮廓也用二维数组来表示，轮廓内元素值为1，轮廓外元素值对应0。&lt;/p&gt;
&lt;p&gt;    这时候就要想这个轮廓形状怎么生成了。有坐标系、有矩形、有圆形，没错，用到数学的图形函数。典型用到一个圆的函数方程和矩形的边线的函数，类似：&lt;/p&gt;
&lt;p&gt;(x-a)²+(y-b)²=r²中，有三个参数a、b、r，即圆心坐标为(a，b)，半径r。这些将抠图放在上文描述的坐标系上很容易就图算出来具体的值。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[][] getBlockData() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[targetLength][targetWidth];
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x2 = targetLength-circleR-2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机生成圆的位置&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; h1 = circleR + Math.random() * (targetWidth-3*circleR-&lt;span&gt;r1);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; po = circleR*&lt;span&gt;circleR;
        
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; xbegin = targetLength-circleR-&lt;span&gt;r1;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; ybegin = targetWidth-circleR-&lt;span&gt;r1;
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; targetLength; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; targetWidth; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边○&lt;/span&gt;
                &lt;span&gt;double&lt;/span&gt; d3 = Math.pow(i - x2,2) + Math.pow(j - h1,2&lt;span&gt;);
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (d1 &amp;lt;=&lt;span&gt; po
                        &lt;/span&gt;|| (j &amp;gt;= ybegin &amp;amp;&amp;amp; d2 &amp;gt;=&lt;span&gt; po)
                        &lt;/span&gt;|| (i &amp;gt;= xbegin &amp;amp;&amp;amp; d3 &amp;gt;=&lt;span&gt; po)
                        ) {
                    data[i][j] &lt;/span&gt;= 0&lt;span&gt;;
                    
                }  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    data[i][j] &lt;/span&gt;= 1&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;    第二步，有这个轮廓后就可以依据这个二维数组的值来判定抠图并在原图上抠图位置处加阴影。&lt;/p&gt;
&lt;p&gt;    操作如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cutByTemplate(BufferedImage oriImage,BufferedImage targetImage, &lt;span&gt;int&lt;/span&gt;[][] templateImage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x,
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; targetLength; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; targetWidth; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rgb =&lt;span&gt; templateImage[i][j];
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原图中对应位置变色处理&lt;/span&gt;
                
                &lt;span&gt;int&lt;/span&gt; rgb_ori = oriImage.getRGB(x + i, y +&lt;span&gt; j);
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rgb == 1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抠图上复制对应颜色值&lt;/span&gt;
                    targetImage.setRGB(i, y +&lt;span&gt; j, rgb_ori);
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r = (0xff &amp;amp;&lt;span&gt; rgb_ori);
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; g = (0xff &amp;amp; (rgb_ori &amp;gt;&amp;gt; 8&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = (0xff &amp;amp; (rgb_ori &amp;gt;&amp;gt; 16&lt;span&gt;)));
                    rgb_ori &lt;/span&gt;= r + (g &amp;lt;&amp;lt; 8) + (b &amp;lt;&amp;lt; 16) + (200 &amp;lt;&amp;lt; 24&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原图对应位置颜色变化&lt;/span&gt;
                    oriImage.setRGB(x + i, y +&lt;span&gt; j, rgb_ori);
                } 
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    经过前面两步后，就得到了抠图和带抠图阴影的原图。为增加混淆和提高网络加载效果，还需要对图片做进一步处理。一般有两件事需要做，一对图片做模糊处理增加机器识别难度，二做适当同质量压缩。模糊处理很容易想到高斯模糊，原理很好理解，大家可以去google了解下。具体到Java里面的实现，有很多版本，现在不借助任何第三方jar，提供一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConvolveOp getGaussianBlurFilter(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; radius,
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; horizontal) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (radius &amp;lt; 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Radius must be &amp;gt;= 1&quot;&lt;span&gt;);
        }
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = radius * 2 + 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;[] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;[size];
        
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sigma = radius / 3.0f&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; twoSigmaSquare = 2.0f * sigma *&lt;span&gt; sigma;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sigmaRoot = (&lt;span&gt;float&lt;/span&gt;) Math.sqrt(twoSigmaSquare *&lt;span&gt; Math.PI);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; total = 0.0f&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = -radius; i &amp;lt;= radius; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; distance = i *&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = i +&lt;span&gt; radius;
            data[index] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;) Math.exp(-distance / twoSigmaSquare) /&lt;span&gt; sigmaRoot;
            total &lt;/span&gt;+=&lt;span&gt; data[index];
        }
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; data.length; i++&lt;span&gt;) {
            data[i] &lt;/span&gt;/=&lt;span&gt; total;
        }        
        
        Kernel kernel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (horizontal) {
            kernel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Kernel(size, 1&lt;span&gt;, data);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            kernel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Kernel(1&lt;span&gt;, size, data);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; simpleBlur(BufferedImage src,BufferedImage dest) {
            BufferedImageOp op &lt;/span&gt;= getGaussianBlurFilter(2,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            op.filter(src, dest);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    经测试模糊效果很不错。另外是图片压缩，也不借助任何第三方工具，做同质压缩。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] fromBufferedImage2(BufferedImage img,String imagType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        bos.reset();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到指定Format图片的writer&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         Iterator&amp;lt;ImageWriter&amp;gt; iter =&lt;span&gt; ImageIO.getImageWritersByFormatName(imagType);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         ImageWriter writer =&lt;span&gt; (ImageWriter) iter.next(); 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到指定writer的输出参数设置(ImageWriteParam )&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         ImageWriteParam iwp =&lt;span&gt; writer.getDefaultWriteParam();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置可否压缩&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         iwp.setCompressionQuality(1f); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置压缩质量参数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        iwp.setProgressiveMode(ImageWriteParam.MODE_DISABLED);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         ColorModel colorModel =&lt;span&gt; ColorModel.getRGBdefault();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定压缩时使用的色彩模式&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         iwp.setDestinationType(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; javax.imageio.ImageTypeSpecifier(colorModel,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         colorModel.createCompatibleSampleModel(16, 16&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        writer.setOutput(ImageIO
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        .createImageOutputStream(bos));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         IIOImage iIamge = &lt;span&gt;new&lt;/span&gt; IIOImage(img, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         writer.write(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, iIamge, iwp);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] d =&lt;span&gt; bos.toByteArray();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; d;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    至此，滑动验证码核心的代码处理流程已全部结束，这里面有很多细节可以不断打磨优化，让滑动体验可以变得更好。希望可以帮助到某些准备自己构建滑动验证码的同学。&lt;/p&gt;
&lt;p&gt;    以上代码实现都非常的精炼，一方面为了保证性能，另一方面好理解。另外由于各方面原因也不便引入过多细节，如果疑问，可留言交流。经测试，该生成滑动图形的流程响应时间可以控制在20ms左右，如果原图分辨率在300px*150px以下，可以到10ms左右，在可接受范围内。如果有更高效的方式，希望多多指教。&lt;/p&gt;

&lt;p&gt;https://my.oschina.net/yaohonv/blog/1604185&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 15:22:00 +0000</pubDate>
<dc:creator>echov</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaohonv/p/swipecaptcha.html</dc:identifier>
</item>
<item>
<title>2017我的个人总结：得与失 - fozero</title>
<link>http://www.cnblogs.com/fozero/p/8245519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fozero/p/8245519.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;2017年经历了很多，成长了很多，也收获了很多，转眼又到了2018，回想这一年的经历，得与失，以下是我从这一年我做了些什么，有什么成长；自己的不足或做的不好的地方；这几个方面去总结，以及2018年的展望和计划。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单回顾&quot;&gt;简单回顾&lt;/h2&gt;
&lt;p&gt;还记得我大概也是年初的时候加入了上个公司初识科技，主要负责GO这个产品前端开发，到目前来到现在这个公司刚好一年左右的时间，虽说一年时间不长也不短，也正是在这一年的时间里，我接触到了很多东西，学到了很多， 也让我的视野也开阔了很多，因为以前做过1年多将近2年左右的java后端开发，所以从15年6月份算起转到前端开发也才3年不到的时间，比起很多一开始就从事前端开发的童鞋来说，在前端的技术积累可能并没有他们多，加之我一开始转到前端是以hybrid移动端开发身份进去，在没有人带的情况下，走了一些弯路，那段时间进步也比较慢，当时都是照着文档边学着做，为了能快速的学习，加了很多技术交流群，自己也是一路摸着石头过河，那时候对前端的认识也还停留在以前，以为就是切切图，写写页面，写写js，做了一段时间的hybrid开发之后，期间也负责一些浏览器pc端和移动端的项目，也正是从那开始，个人的技术开始从项目中得到成长和收获，有空的时候开始逛技术论坛，遇到不会的问题学着在网上提问，后来，开始接触一些前端框架，知道了一些前端的MV*框架，angular，react，vuejs，学习和调研了一番之后，将vuejs加入到了部分项目中去使用，同时也真正感受到了vuejs在项目中给我们带来的好处，从思想上改变了原有的开发方式，也正是因为vuejs让我知道了什么叫SPA单页应用，于是在业余时间通过脚手架搭建并学习了一些单页应用的开发技巧，但都是比较浅显的认识，并没有怎么实际去运用它，后来，因为公司平台太小，考虑到个人今后的发展，17年初的时候加入了初识科技，负责公司GO卡产品的前端开发。&lt;/p&gt;
&lt;h2 id=&quot;产品介绍&quot;&gt;产品介绍&lt;/h2&gt;
&lt;p&gt;这里先简单的介绍一下GO卡产品，通俗的来讲其实就是一个理财产品，但跟市面上的一些其他理财产品并不相同，GO卡主要是通过和一些优质的连锁商户合作推出一些会员储值卡，将其在平台上售卖，以达到提前回笼资金，自融资的目的，对于理财用户来说，在平台上购买这些商户的理财分红卡，当普通消费者在商户那里产生消费的时候，GO卡平台会通过特定的算法计算买单用卡，从而让理财用户获得分红收益，实现双方共赢。&lt;/p&gt;
&lt;h2 id=&quot;成长和收获&quot;&gt;成长和收获&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于是创业公司，所以经常加班是少不了的，对于创业公司来说时间是特别重要的，很大一部分是谁能在时间上面占据了优势，谁就有可能会成功。由于公司业务经常的变动，所以很多时间需要加班赶进度，每周也会有1~2次的产品迭代，为了减少上线带来的影响，一般也都是安排在了半夜这样的时间节点。虽然比较辛苦，有时候也会觉得累，但又想一想，其实也是值得的，这一年对于我个人来说进步也是非常的大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;最近这2年的前端的变化非常的大，各种流行的前端框架，构建工具等都像雨后春笋一样走了出来，现在的前端环境已然不再是传统的切图、写样式画页面等等这样简单的一些工作，前端也变得更加的复杂，越来越多的公司开始使用易于开发和维护的工程化、模块化、组件化开发方式，所以对于我们前端来说即是一种机遇同时也是一个挑战。&lt;/li&gt;
&lt;li&gt;前后端分离架构的开发方式给了我思想上很大的改变，与传统的开发方式相比，很大程度的提升了我们的开发效率，降低了前后端的耦合，各司其职，每个人负责各自擅长的部分。&lt;/li&gt;
&lt;li&gt;还有就是对css预编译less、scss有了一定的了解，并在构建官网的时候使用less预编译css，使得我们写的css更加易于维护，它在css语言的基础上提供了更加灵活的功能，比如变量、函数、混合（mixin）。&lt;/li&gt;
&lt;li&gt;在前端性能优化方面也学会了一些技巧，并在项目中进行了实践，让页面请求速度更加的快速，极大的提升了用户的体验，例如，使用gulp构建工具，压缩合并我们的js，css文件，通过减少资源文件大小，提升页面访问速度，减少服务器带宽和压力&lt;/li&gt;
&lt;li&gt;页面响应式布局，通过媒体查询在各个不同屏幕大小实现自适应布局，使得在PC和移动端都能更好的访问，在我们的官网都采用这种布局方式，适配移动端和PC端访问，增强了用户的体验，在移动微信端GO产品，也采用了更好了淘宝的REM适配方案，保证了在不同分辨率手机下显示的效果一致。&lt;/li&gt;
&lt;li&gt;还有就是对nodejs的学习，我们将nodejs作为中间层，负责对后端java数据的获取，并对数据进行处理，以及node层做一些前端的业务处理，将处理好后的数据再返回给前端页面展示，nodejs和java通过接口的形式进行通信，并将token添加在每一次请求接口的参数中用来区分不同的用户。&lt;/li&gt;
&lt;li&gt;在团队合作上，也学会了一些更好的方式，学习通过jira工具去跟踪项目进度，管理项目，使得开发、测试和上线流程更加规范，提升了整体的团队效率，同时版本控制也采用了分布式的git工具来管理代码。&lt;/li&gt;
&lt;li&gt;另外，就是在解决问题的思路上面比以前更加的清晰和高效了，而不是一头钻进死胡同里面出不来，再个就是永远学会站在用户的角度考虑问题，把自己当成一个用户，从而更好的去实现和完善产品的功能，做出更好的产品。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;缺点或不足&quot;&gt;缺点或不足&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上就是自己这一年来的经历和成长，收获了很多，技术上的提升，和朋友之间的友谊，以及同事的帮助等等，但也发现了自己的一些不足：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;在技术研究学习上花费时间不是很多（因为主要时间在学习现有业务和需求）&lt;/li&gt;
&lt;li&gt;时间观念，工作效率有待加强&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有时候考虑问题不够深等等。&lt;/p&gt;
&lt;h2 id=&quot;展望和计划&quot;&gt;2018展望和计划&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后，就是2018年的展望和计划&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;正视以上自己的不足，并加以改进&lt;/li&gt;
&lt;li&gt;加强技术积累，继续在前端这个领域深耕下去，关注开源，向大牛们多多学习&lt;/li&gt;
&lt;li&gt;更多的关注前端的工程化，模块化和组件化，提升个人的工程能力&lt;/li&gt;
&lt;li&gt;继续学习nodejs，尝试使用nodejs开发一些web应用程序&lt;/li&gt;
&lt;li&gt;提升团队协作能力，转换开发思维，今后将更多的从团队角度去考虑问题&lt;/li&gt;
&lt;li&gt;业余时间多参加一些技术交流活动，学习和开拓自己的技术视野&lt;/li&gt;
&lt;li&gt;更加主动的和同事沟通，提升沟通能力和团队合作能力&lt;/li&gt;
&lt;li&gt;提升自己的软技能，给自己制定计划，每个月看一两本书，坚持学习英语等&lt;/li&gt;
&lt;li&gt;加强锻炼，确保有个健康的身体，有个好的工作状态，这样能更好的完成工作任务&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;......&lt;br/&gt;2018，期待遇见更好的自己。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;2018.1.5 by fozero&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 08 Jan 2018 15:20:00 +0000</pubDate>
<dc:creator>fozero</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fozero/p/8245519.html</dc:identifier>
</item>
<item>
<title>小白的Python之路 day5 time,datatime模块详解 - 钱多多的妖孽人生</title>
<link>http://www.cnblogs.com/ManyQian/p/8245490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/8245490.html</guid>
<description>&lt;h2&gt;可以分成三大类：&lt;/h2&gt;
&lt;h2&gt;　　1.标准库&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;　　2.开源模块&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;　　3.自定义模块&lt;/span&gt;&lt;/h2&gt;


&lt;h2&gt;1.time与datetime&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;在Python中，通常有这几种方式来表示时间：1）时间戳 2）格式化的时间字符串 3）元组（struct_time）共九个元素。由于Python的time模块实现主要调用C库，所以各个平台可能有所不同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;strong&gt;UTC（Coordinated Universal Time，世界协调时）亦即格林威治天文时间，世界标准时间。在中国为UTC+8。DST（Daylight Saving Time）即夏令时。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间戳（timestamp）的方式：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。返回时间戳方式的函数主要有time()，clock()等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元组（struct_time）方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。下面列出这种方式元组中的几个元素：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;索引（Index）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;属性（Attribute）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;值（Values）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_year（年）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;比如2018&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_mon（月）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1 - 12&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_mday（日）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1 - 31&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_hour（时）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0 - 23&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_min（分）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0 - 59&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_sec（秒）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0 - 61&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_wday（weekday）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0 - 6（0表示周日）&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_yday（一年中的第几天）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1 - 366&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;tm_isdst（是否是夏令时）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;默认为-1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着介绍time模块中常用的几个函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）time.localtime([secs])：将一个时间戳转换为&lt;span&gt;当前时区的&lt;/span&gt;struct_time。secs参数未提供，则以当前时间为准。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;codetitle&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108193325488-1361254282.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;加入参数后：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;codetitle&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108194158004-688011444.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;如何取其中的数值呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;codetitle&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108210018832-739777643.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;


&lt;p&gt;&lt;br/&gt;&lt;strong&gt;2）time.gmtime([secs])：和localtime()方法类似，gmtime()方法是将一个时间戳转换为&lt;span&gt;UTC时区（0时区）(跟中国时区相差8小时)&lt;/span&gt;的struct_time。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;codetitle&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108201001113-1476506287.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;3）time.time()：返回当前时间的时间戳。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;codetitle&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180107185442221-1295287686.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;4）time.mktime(t)：将一个struct_time转化为时间戳。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;codetitle&quot;&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108210351676-1820976207.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5）time.sleep(secs)：线程推迟指定的时间运行。单位为秒。  #这个就不多说&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6）time.clock()：这个需要注意，在不同的系统上含义不同。在UNIX系统上，它返回的是“进程时间”，它是用秒表示的浮点数（时间戳）。而在WINDOWS中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间。（实际上是以WIN32上QueryPerformanceCounter()为基础，它比毫秒表示更为精确）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;import time &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;if __name__ == '__main__': &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    time.sleep(1) &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    print &quot;clock1:%s&quot; % time.clock() &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    time.sleep(1) &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    print &quot;clock2:%s&quot; % time.clock() &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    time.sleep(1) &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    print &quot;clock3:%s&quot; % time.clock()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;clock1:3.35238137808e-006&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;clock2:1.00004944763&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;clock3:2.00012040636&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中第一个clock()输出的是程序运行时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二、三个clock()输出的都是与第一个clock的时间间隔&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7）time.asctime([t])：把一个表示时间的元组或者struct_time表示为这种形式：'Sun Jun 20 23:21:05 1993'。如果没有参数，将会将time.localtime()作为参数传入。&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;code37933&quot; class=&quot;codebody&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108223558488-746073148.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8）time.ctime([secs])：把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于time.asctime(time.localtime(secs))。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108230918707-125236640.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;9）time.strftime(format[, t])：把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回）转化为格式化的时间字符串。如果t未指定，将传入time.localtime()。如果元组中任何一个元素越界，ValueError的错误将会被抛出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;格式&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%a&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地（locale）简化星期名称&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%A&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地完整星期名称&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%b&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地简化月份名称&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%B&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地完整月份名称&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%c&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地相应的日期和时间表示&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%d&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一个月中的第几天（01 - 31）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%H&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一天中的第几个小时（24小时制，00 - 23）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%I&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;第几个小时（12小时制，01 - 12）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%j&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一年中的第几天（001 - 366）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%m&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;月份（01 - 12）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%M&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;分钟数（00 - 59）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%p&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地am或者pm的相应符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;秒（01 - 61）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;二&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;%U&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;三&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%w&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一个星期中的第几天（0 - 6，0是星期天）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;三&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%W&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;和%U基本相同，不同的是%W以星期一为一个星期的开始。&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%x&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地相应日期&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;本地相应时间&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%y&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;去掉世纪的年份（00 - 99）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%Y&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;完整的年份&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;%Z&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;时区的名字（如果不存在为空字符）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%%&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;‘%'字符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108200158847-1136185879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;“%p”只有与“%I”配合使用才有效果。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;文档中强调确实是0 - 61，而不是59，闰年秒占两秒（汗一个）。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;当使用strptime()函数时，只有当在这年中的周数和天数被确定的时候%U和%W才会被计算。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;code84527&quot; class=&quot;codebody&quot;&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt; time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108210804535-1554048575.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;10）time.strptime(string[, format])：把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt; time.strptime('2018-01-08 21:07:06', '%Y-%m-%d %X')&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;strftime(&quot;格式&quot;,struct_time) -----&amp;gt;&quot;格式化的字符串&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;strptime(&quot;格式化的字符串&quot;,&quot;格式&quot;)-----&amp;gt;struct_time&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;在这个函数中，format默认为：&quot;%a %b %d %H:%M:%S %Y&quot;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后，我们来对time模块进行一个总结。根据之前描述，在Python中共有三种表达方式：1）timestamp 2）tuple或者struct_time 3）格式化字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它们之间的转化如图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;bPic&quot; href=&quot;http://files.jb51.net/file_images/article/201404/2014424120618129.jpg?201432412651&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201404/2014424120618129.jpg?201432412651&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;




&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201801/1274477-20180108232912847-566777051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 08 Jan 2018 15:12:00 +0000</pubDate>
<dc:creator>钱多多的妖孽人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/8245490.html</dc:identifier>
</item>
<item>
<title>springMVC(7)---表单标签 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8245377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8245377.html</guid>
<description>&lt;p id=&quot;2form标签&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;form标签作用                                    &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        简单来讲form表单有两大作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      1：第一就是往后端提交数据或者前端回显数据时候，它会自动的绑定来自Model中的一个属性值到当前form对应的实体对象。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      2：第二是它支持我们在提交表单的时候使用除GET和POST之外的其他方法进行提交，包括DELETE和PUT等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来用案例来说话，看了很多博客，基本上都是用同一个实体来讲解，它确实很全面，我也用它来举例！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一步：创建实体UserModel                   &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserModel{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; testBoolean;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] selectArray;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] testArray;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer radioId;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer selectId;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt;&lt;span&gt; selectIds;    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;Integer,String&amp;gt;&lt;span&gt; testMap;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String remark;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 提供set和get方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：FormController类             &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.ui.Model;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ssm.model.UserModel;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FormController {
    
@RequestMapping(&lt;/span&gt;&quot;/form&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test(Model model){    
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!model.containsAttribute(&quot;userModel&quot;&lt;span&gt;)){    

    UserModel userModel&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserModel();
    userModel.setUsername(&lt;/span&gt;&quot;小小&quot;&lt;span&gt;);
    userModel.setPassword(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;);
    userModel.setTestBoolean(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    userModel.setSelectArray(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] {&quot;唱歌&quot;&lt;span&gt;});
    userModel.setTestArray(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] {&quot;唱歌&quot;,&quot;跳舞&quot;,&quot;画画&quot;&lt;span&gt;});
    userModel.setRadioId(&lt;/span&gt;1&lt;span&gt;);
    userModel.setSelectId(&lt;/span&gt;2&lt;span&gt;);
    userModel.setSelectIds(Arrays.asList(&lt;/span&gt;1,2&lt;span&gt;));
     Map&lt;/span&gt;&amp;lt;Integer,String&amp;gt; mapone=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Integer,String&amp;gt;&lt;span&gt;();
     mapone.put(&lt;/span&gt;1, &quot;唱歌&quot;&lt;span&gt;);
     mapone.put(&lt;/span&gt;2, &quot;跳舞&quot;&lt;span&gt;);
     mapone.put(&lt;/span&gt;3, &quot;画画&quot;&lt;span&gt;);
     userModel.setTestMap(mapone);
     userModel.setRemark(&lt;/span&gt;&quot;备注：我今年1岁了&quot;&lt;span&gt;);
     
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将userModel数据放入&lt;/span&gt;
     model.addAttribute(&quot;userModel&quot;&lt;span&gt;, userModel);
    
   }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;formTag&quot;&lt;span&gt;;
}
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第三步：formTag.jsp              &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/tags/form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:form &lt;/span&gt;&lt;span&gt;modelAttribute&lt;/span&gt;&lt;span&gt;=&quot;userModel&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;     
        
          input 标签：  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:input &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
       password 标签：  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:password &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
       
        绑定boolean的checkbox标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testBoolean&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        
        绑定Array的checkbox 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;唱歌&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;唱歌
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;跳舞&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;跳舞
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;画画&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;画画
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;武术&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;武术&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        
        绑定Array的checkboxs标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkboxes &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectArray&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testArray}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        
        绑定Map的checkboxs 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkboxes &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectIds&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        
        绑定Integer的radio 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobutton &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;radioId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;0
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobutton &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;radioId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;1
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobutton &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;radioId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        绑定Map的radiobuttons 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobuttons &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        绑定Map的select 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        不绑定items数据直接在form:option添加的select 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择人员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;中&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;大&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        不绑定items数据直接在html的option添加的select 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择人员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;中&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;大&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        用form:option绑定items的select 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;请选择人员
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:options &lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        textarea 标签：
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:textarea &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;remark&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第四步：界面效果                   &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108220440582-771559605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第五步：细讲表单标签                      &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;(1)要使用Spring MVC提供的表单标签，首先需要在视图页面添加&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/tags/form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.form标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:form &lt;/span&gt;&lt;span&gt;modelAttribute&lt;/span&gt;&lt;span&gt;=&quot;userModel&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; modelAttribute属性指定该form绑定的是哪个Model，当指定了对应的Model后就可以在form标签内部其它表单标签上通过为path指定Model属性的名称来绑定Model中的数据&lt;/p&gt;
&lt;p&gt;这里面需要注意userModel这个实体一定要已经存在的，不然会保存，就比方说你一开始就加载这个页面，那model还没有把userModel放进来，那么这个页面就会报找不到userModel的错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.input标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:input &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会生成一个type为text的Html input标签，通过path属性来指定要绑定的Model中的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.password标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:password &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会生成一个type为password的Html input标签，通过path属性来指定要绑定的Model中的值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.checkbox标签：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;会生成一个type为checkbox的Html input标签，支持绑定boolean、数组、List或Set类型的数据。&lt;/p&gt;
&lt;p&gt;绑定boolean数据会生成一个复选框，当boolean为true该复选框为选定状态，false为不选定状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testBoolean&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108221318551-660654136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绑定数组、List或Set类型的数据（以数组作为演示）如果绑定的数据中有对应checkbox指定的value时则为选定状态，反之为不选定状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;   在testArray只有：唱歌,跳舞, 画画     &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
        绑定Array的checkbox 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;唱歌&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;唱歌
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;跳舞&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;跳舞
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;画画&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;画画
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkbox &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;testArray&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;武术&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;武术&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108221417332-1692411161.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.checkboxs标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;会根据绑定的items数据生成一组对应的type为checkbox的Html input标签，绑定的数据可以是数组、集合或Map，其中checkboxs的path属性也必指定，当path中的数据有和items中的数据值同的时候对应的checkbox为选定状态，反之为不选定状态。&lt;/p&gt;
&lt;p&gt;绑定集合数据（以数组作为演示）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;   在selectArray数组中，我只放了：唱歌。 而在testArray数组中有：唱歌,跳舞, 画画    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
        绑定Array的checkboxs标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkboxes &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectArray&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testArray}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108222041566-94653422.png&quot; alt=&quot;&quot; width=&quot;310&quot; height=&quot;46&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是当使用EL表达式绑定时需要连Model的名称一起指定如${userModel.testArray}而不能像path一样只指定Model对应的属性名称。&lt;/p&gt;
&lt;p&gt;但通常情况下我们需要的是checkbox显示的是名称，但选择后提交的是对应名称的值，比如id，我们就可以通过绑定Map来实现这个功能： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  selectIds我放的是list集合元素有：1,2  testMap放有(1, &quot;唱歌&quot;)(2, &quot;跳舞&quot;)(3, &quot;画画&quot;) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
        绑定Map的checkboxs 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:checkboxes &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectIds&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108222512347-1816983955.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;46&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成的一组checkbox中其中一个checkbox的html代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 7.radiobutton标签&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;会生成一个type为radio的Html input标签，如果绑定的数据的值对应radiobutton指定的value时则为选定状态，反之为不选定状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在 radioId属性我放的数据是：1  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;   
        绑定Integer的radio 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobutton &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;radioId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;0
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobutton &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;radioId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;1
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobutton &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;radioId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108222806801-2136305513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.radiobuttons标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;会根据绑定的items数据生成一组对应的type为radio的Html input标签，绑定的items数据可以是数组、集合或Map，其中radiobuttons的path属性也必指定，当path的值和items中的某条数据值相同的时候对应的radio为选定状态，反之为不选定状态，用法和checkboxs很相似。但要注意的是：checkboxs的path绑定的是集合radiobuttons的path绑定的是单个值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  这里selectId我放的数据是：2  testMap放有(1, &quot;唱歌&quot;)(2, &quot;跳舞&quot;)(3, &quot;画画&quot;) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
        绑定Map的radiobuttons 标签：&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:radiobuttons &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108223025426-1774360562.png&quot; alt=&quot;&quot; width=&quot;307&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;9.select标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;会生成一个Html select标签，绑定的items数据可以是数组、集合或Map会根据items的内容生成select里面的option选项，当path的值和items中的某条数据值相同的时候对应的option为选定状态，反之为不选定状态，用法与radiobuttons很相似：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  这里selectId我放的数据是：2  testMap放有(1, &quot;唱歌&quot;)(2, &quot;跳舞&quot;)(3, &quot;画画&quot;) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;    
        绑定Map的select 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt; items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108223222441-1370290525.png&quot; alt=&quot;&quot; width=&quot;310&quot; height=&quot;46&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的是根据指定的items自动生成的option选项，但我们也可以不指定items手动添加select的option选项：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  这里selectId我放的数据是：2   &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;   
        不绑定items数据直接在form:option添加的select 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择人员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;中&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;大&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108223435254-921863685.png&quot; alt=&quot;&quot; width=&quot;346&quot; height=&quot;41&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中添加&amp;lt;option&amp;gt;请选择人员&amp;lt;/option&amp;gt; 可以让在没有进行选择的情况下不指定任何默认值。&lt;/p&gt;
&lt;p&gt;下面看一下form:option 与option的区别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        不绑定items数据直接在form:option添加的select 标签：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择人员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;中&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;大&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        不绑定items数据直接在html的option添加的select 标签：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择人员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;中&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;大&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108223612754-296691541.png&quot; alt=&quot;&quot; width=&quot;382&quot; height=&quot;79&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由截图的结果可以看出form:option 正确选择了path中指定的selectId而option没有，说明form:option有数据绑定功能option没有。&lt;/p&gt;
&lt;p&gt;另外我们也可以不为select指定items，而把items指定到form:option 上这两种效果基本是一样的，一点区别就是为select指定items再在select里面添加option是不起作用的会被items生成的option覆盖掉，而把items指定到form:option 上则可以再在select里面添加option：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  用form:option绑定items的select 标签：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:select &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;selectId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;请选择人员
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:options &lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;=&quot;${userModel.testMap}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108223852051-1152494037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;10.textarea标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; remark属性数据是：&quot;备注：我今年1岁了&quot; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
        textarea 标签：
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:textarea &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;remark&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180108224023347-434393146.png&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;38&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;11.hidden标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;会生成一个type为hidden的Html input标签，通过path属性来指定要绑定的Model中的值。&lt;/p&gt;
&lt;p&gt;这篇文章也就基本上是参考别人的文章，自己动手敲了一遍，也没什么难点。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;/strong&gt;少尉【14】&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 14:47:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8245377.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——17.  最小化可变性 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8245387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8245387.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;不可变类简单来说是它的实例不能被修改的类。 包含在每个实例中的所有信息在对象的生命周期中是固定的，因此不会观察到任何变化。 Java平台类库包含许多不可变的类，包括String类，基本类型包装类以及BigInteger类和BigDecimal类。 有很多很好的理由：不可变类比可变类更容易设计，实现和使用。 他们不太容易出错，更安全。&lt;/p&gt;
&lt;p&gt;要使一个类不可变，请遵循以下五条规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;不要提供修改对象状态的方法&lt;/strong&gt;（也称为mutators）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确保这个类不能被继承&lt;/strong&gt;。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过final修饰类，但是我们稍后将讨论另一种方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把所有属性设置为final&lt;/strong&gt;。通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为，正如内存模型[JLS，17.5; Goetz06,16]所述。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把所有的属性设置为private&lt;/strong&gt;。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共final属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示（项目15和16）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确保对任何可变组件的互斥访问&lt;/strong&gt;。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和&lt;code&gt;readObject方法&lt;/code&gt;（条目 88）中进行防御性拷贝（条目 50）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以前条目中的许多示例类都是不可变的。 其中这样的类是条目 11中的&lt;code&gt;PhoneNumber&lt;/code&gt;类，它具有每个属性的访问方法（accessors），但没有相应的设值方法（mutators）。 这是一个稍微复杂一点的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Immutable complex number class

public final class Complex {

    private final double re;

    private final double im;

    public Complex(double re, double im) {

        this.re = re;

        this.im = im;

    }

    public double realPart() {

        return re;

    }

    public double imaginaryPart() {

        return im;

    }

    public Complex plus(Complex c) {

        return new Complex(re + c.re, im + c.im);

    }

    public Complex minus(Complex c) {

        return new Complex(re - c.re, im - c.im);

    }

    public Complex times(Complex c) {

        return new Complex(re * c.re - im * c.im,

                re * c.im + im * c.re);

    }

    public Complex dividedBy(Complex c) {

        double tmp = c.re * c.re + c.im * c.im;

        return new Complex((re * c.re + im * c.im) / tmp,

                (im * c.re - re * c.im) / tmp);

    }

    @Override

    public boolean equals(Object o) {

        if (o == this) {

            return true;

        }

        if (!(o instanceof Complex)) {

            return false;

        }

        Complex c = (Complex) o;

        // See page 47 to find out why we use compare instead of ==

        return Double.compare(c.re, re) == 0

                &amp;amp;&amp;amp; Double.compare(c.im, im) == 0;

    }

    @Override

    public int hashCode() {

        return 31 * Double.hashCode(re) + Double.hashCode(im);

    }

    @Override

    public String toString() {

        return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类代表了一个复数（包含实部和虚部的数字）。 除了标准的Object方法之外，它还为实部和虚部提供访问方法，并提供四个基本的算术运算：加法，减法，乘法和除法。 注意算术运算如何创建并返回一个新的&lt;code&gt;Complex&lt;/code&gt;实例，而不是修改这个实例。 这种模式被称为函数式方法，因为方法返回将操作数应用于函数的结果，而不修改它们。 与其对应的过程（procedural）或命令（imperative）的方法相对比，在这种方法中，将一个过程作用在操作数上，导致其状态改变。 请注意，方法名称是介词（如plus）而不是动词（如add）。 这强调了方法不会改变对象的值的事实。 &lt;code&gt;BigInteger&lt;/code&gt;和&lt;code&gt;BigDecimal&lt;/code&gt;类没有遵守这个命名约定，并导致许多使用错误。&lt;/p&gt;
&lt;p&gt;如果你不熟悉函数式方法，可能会显得不自然，但它具有不变性，具有许多优点。 &lt;strong&gt;不可变对象很简单&lt;/strong&gt;。 一个不可变的对象可以完全处于一种状态，也就是被创建时的状态。 如果确保所有的构造方法都建立了类不变量，那么就保证这些不变量在任何时候都保持不变，使用此类的程序员无需再做额外的工作。 另一方面，可变对象可以具有任意复杂的状态空间。 如果文档没有提供由设置（mutator）方法执行的状态转换的精确描述，那么可靠地使用可变类可能是困难的或不可能的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可变对象本质上是线程安全的; 它们不需要同步&lt;/strong&gt;。 被多个线程同时访问它们时并不会被破坏。 这是实现线程安全的最简单方法。 由于没有线程可以观察到另一个线程对不可变对象的影响，所以&lt;strong&gt;不可变对象可以被自由地共享&lt;/strong&gt;。 因此，不可变类应鼓励客户端尽可能重用现有的实例。 一个简单的方法是为常用的值提供公共的静态 final常量。 例如，&lt;code&gt;Complex&lt;/code&gt;类可能提供这些常量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static final Complex ZERO = new Complex(0, 0);
public static final Complex ONE  = new Complex(1, 0);
public static final Complex I    = new Complex(0, 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法可以更进一步。 一个不可变的类可以提供静态的工厂（条目 1）来缓存经常被请求的实例，以避免在现有的实例中创建新的实例。 所有基本类型的包装类和&lt;code&gt;BigInteger&lt;/code&gt;类都是这样做的。 使用这样的静态工厂会使客户端共享实例而不是创建新实例，从而减少内存占用和垃圾回收成本。 在设计新类时，选择静态工厂代替公共构造方法，可以在以后增加缓存的灵活性，而不需要修改客户端。&lt;/p&gt;
&lt;p&gt;不可变对象可以自由分享的结果是，你永远不需要做出防御性拷贝（ defensive copies）（条目 50）。 事实上，永远不需要做任何拷贝，因为这些拷贝永远等于原始对象。 因此，你不需要也不应该在一个不可变的类上提供一个clone方法或拷贝构造方法（copy constructor）（条目 13）。 这一点在Java平台的早期阶段还不是很好理解，所以String类有一个拷贝构造方法，但是它应该尽量很少使用（条目 6）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不仅可以共享不可变的对象，而且可以共享内部信息&lt;/strong&gt;。 例如，&lt;code&gt;BigInteger&lt;/code&gt;类在内部使用符号数值表示法。 符号用int值表示，数值用int数组表示。 &lt;code&gt;negate&lt;/code&gt;方法生成了一个数值相同但符号相反的新&lt;code&gt;BigInteger&lt;/code&gt;实例。 即使它是可变的，也不需要复制数组；新创建的&lt;code&gt;BigInteger&lt;/code&gt;指向与原始相同的内部数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可变对象为其他对象提供了很好的构件（building blocks）&lt;/strong&gt;，无论是可变的还是不可变的。 如果知道一个复杂组件的内部对象不会发生改变，那么维护复杂对象的不变量就容易多了。这一原则的特例是，不可变对象可以构成&lt;code&gt;Map&lt;/code&gt;对象的键和&lt;code&gt;Set&lt;/code&gt;的元素，一旦不可变对象作为&lt;code&gt;Map&lt;/code&gt;的键或&lt;code&gt;Set&lt;/code&gt;里的元素，即使破坏了&lt;code&gt;Map&lt;/code&gt;和&lt;code&gt;Set&lt;/code&gt;的不可变性，但不用担心它们的值会发生变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可变对象提供了免费的原子失败机制&lt;/strong&gt;（条目 76）。它们的状态永远不会改变，所以不可能出现临时的不一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可变类的主要缺点是对于每个不同的值都需要一个单独的对象&lt;/strong&gt;。 创建这些对象可能代价很高，特别是如果是大型的对象下。 例如，假设你有一个百万位的&lt;code&gt;BigInteger&lt;/code&gt;    ，你想改变它的低位：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BigInteger moby = ...;

moby = moby.flipBit(0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;flipBit&lt;/code&gt;方法创建一个新的&lt;code&gt;BigInteger&lt;/code&gt;实例，也是一百万位长，与原始位置只有一位不同。 该操作需要与&lt;code&gt;BigInteger&lt;/code&gt;大小成比例的时间和空间。 将其与&lt;code&gt;java.util.BitSet&lt;/code&gt;对比。 像&lt;code&gt;BigIntege&lt;/code&gt;r一样，&lt;code&gt;BitSet&lt;/code&gt;表示一个任意长度的位序列，但与&lt;code&gt;BigInteger&lt;/code&gt;不同，&lt;code&gt;BitSe&lt;/code&gt;t是可变的。 &lt;code&gt;BitSet&lt;/code&gt;类提供了一种方法，允许你在固定时间内更改百万位实例中单个位的状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BitSet moby = ...;

moby.flip(0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果执行一个多步操作，在每一步生成一个新对象，除最终结果之外丢弃所有对象，则性能问题会被放大。这里有两种方式来处理这个问题。第一种办法，先猜测一下会经常用到哪些多步的操作，然后讲它们作为基本类型提供。如果一个多步操作是作为一个基本类型提供的，那么不可变类就不必在每一步创建一个独立的对象。在内部，不可变的类可以是任意灵活的。 例如，&lt;code&gt;BigInteger&lt;/code&gt;有一个包级私有的可变的“伙伴类（companion class）”，它用来加速多步操作，比如模幂运算（ modular exponentiation）。出于前面所述的所有原因，使用可变伙伴类比使用BigInteger要困难得多。 幸运的是，你不必使用它：&lt;code&gt;BigInteger&lt;/code&gt;类的实现者为你做了很多努力。&lt;/p&gt;
&lt;p&gt;如果你可以准确预测客户端要在你的不可变类上执行哪些复杂的操作，那么包级私有可变伙伴类的方式可以正常工作。如果不是的话，那么最好的办法就是提供一个公开的可变伙伴类。 这种方法在Java平台类库中的主要例子是String类，它的可变伙伴类是&lt;code&gt;StringBuilder&lt;/code&gt;（及其过时的前身&lt;code&gt;StringBuffer&lt;/code&gt;类）。&lt;/p&gt;
&lt;p&gt;现在你已经知道如何创建一个不可改变类，并且了解不变性的优点和缺点，下面我们来讨论几个设计方案。 回想一下，为了保证不变性，一个类不得允许子类化。 这可以通过使类用 final 修饰，但是还有另外一个更灵活的选择。 而不是使不可变类设置为 final，可以使其所有的构造方法私有或包级私有，并添加公共静态工厂，而不是公共构造方法（条目 1）。 为了具体说明这种方法，下面以&lt;code&gt;Complex&lt;/code&gt;为例，看看如何使用这种方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Immutable class with static factories instead of constructors

public class Complex {

    private final double re;

    private final double im;

    private Complex(double re, double im) {

        [this.re](http://this.re) = re;

        [this.im](http://this.im) = im;

    }

    public static Complex valueOf(double re, double im) {

        return new Complex(re, im);

    }

    ... // Remainder unchanged

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法往往是最好的选择。 这是最灵活的，因为它允许使用多个包级私有实现类。 对于驻留在包之外的客户端，不可变类实际上是final的，因为不可能继承来自另一个包的类，并且缺少公共或受保护的构造方法。 除了允许多个实现类的灵活性以外，这种方法还可以通过改进静态工厂的对象缓存功能来调整后续版本中类的性能。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;BigInteger&lt;/code&gt;和&lt;code&gt;BigDecimal&lt;/code&gt;被写入时，不可变类必须是有效的final，因此它们的所有方法都可能被重写。不幸的是，在保持向后兼容性的同时，这一事实无法纠正。如果你编写一个安全性取决于来自不受信任的客户端的&lt;code&gt;BigIntege&lt;/code&gt;r或&lt;code&gt;BigDecimal&lt;/code&gt;参数的不变类时，则必须检查该参数是“真实的”&lt;code&gt;BigInteger&lt;/code&gt;还是&lt;code&gt;BigDecimal&lt;/code&gt;，而不应该是不受信任的子类的实例。如果是后者，则必须在假设可能是可变的情况下保护性拷贝（defensively copy）（条目 50）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static BigInteger safeInstance(BigInteger val) {

    return val.getClass() == BigInteger.class ?
            val : new BigInteger(val.toByteArray());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本条目开头关于不可变类的规则说明，没有方法可以修改对象，并且它的所有属性必须是final的。事实上，这些规则比实际需要的要强硬一些，其实可以有所放松来提高性能。 事实上，任何方法都不能在对象的状态中产生外部可见的变化。 然而，一些不可变类具有一个或多个非final属性，在第一次需要时将开销昂贵的计算结果缓存在这些属性中。 如果再次请求相同的值，则返回缓存的值，从而节省了重新计算的成本。 这个技巧的作用恰恰是因为对象是不可变的，这保证了如果重复的话，计算会得到相同的结果。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;PhoneNumber&lt;/code&gt;类的&lt;code&gt;hashCode&lt;/code&gt;方法（第53页的条目 11）在第一次调用改方法时计算哈希码，并在再次调用时对其进行缓存。 这种延迟初始化（条目 83）的一个例子，String类也使用到了。&lt;/p&gt;
&lt;p&gt;关于序列化应该加上一个警告。 如果你选择使您的不可变类实现Serializable接口，并且它包含一个或多个引用可变对象的属性，则必须提供显式的&lt;code&gt;readObject&lt;/code&gt;或&lt;code&gt;readResolve&lt;/code&gt;方法，或者使用&lt;code&gt;ObjectOutputStream.writeUnshared&lt;/code&gt;和&lt;code&gt;ObjectInputStream.readUnshared&lt;/code&gt;方法，即默认的序列化形式也是可以接受的。 否则攻击者可能会创建一个可变的类的实例。 这个主题会在条目 88中会详细介绍。&lt;/p&gt;
&lt;p&gt;总而言之，坚决不要为每个属性编写一个get方法后再编写一个对应的set方法。 &lt;strong&gt;除非有充分的理由使类成为可变类，否则类应该是不可变的&lt;/strong&gt;。 不可变类提供了许多优点，唯一的缺点是在某些情况下可能会出现性能问题。 你应该始终使用较小的值对象（如&lt;code&gt;PhoneNumber&lt;/code&gt;和&lt;code&gt;Complex&lt;/code&gt;），使其不可变。 （Java平台类库中有几个类，如&lt;code&gt;java.util.Date&lt;/code&gt;和&lt;code&gt;java.awt.Point&lt;/code&gt;，本应该是不可变的，但实际上并不是）。你应该认真考虑创建更大的值对象，例如&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;BigInteger&lt;/code&gt; ，设成不可改变的。 只有当你确认有必要实现令人满意的性能（条目 67）时，才应该为不可改变类提供一个公开的可变伙伴类。&lt;/p&gt;
&lt;p&gt;对于一些类来说，不变性是不切实际的。&lt;strong&gt;如果一个类不能设计为不可变类，那么也要尽可能地限制它的可变性&lt;/strong&gt;。减少对象可以存在的状态数量，可以更容易地分析对象，以及降低出错的可能性。因此，除非有足够的理由把属性设置为非 final 的情况下，否则应该每个属性都设置为 final 的。把本条目的建议与条目15的建议结合起来，你自然的倾向就是：&lt;strong&gt;除非有充分的理由不这样做，否则应该把每个属性声明为私有final的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造方法应该创建完全初始化的对象，并建立所有的不变性&lt;/strong&gt;。 除非有令人信服的理由，否则不要提供独立于构造方法或静态工厂的公共初始化方法。 同样，不要提供一个“reinitialize”方法，使对象可以被重用，就好像它是用不同的初始状态构建的。 这样的方法通常以增加的复杂度为代价，仅仅提供很少的性能优势。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;类是这些原理的例证。 它是可变的，但它的状态空间有意保持最小范围内。 创建一个实例，使用它一次，并完成：一旦countdown锁的计数器已经达到零，不能再重用它。&lt;/p&gt;
&lt;p&gt;在这个条目中，应该添加关于&lt;code&gt;Complex&lt;/code&gt;类的最后一个注释。 这个例子只是为了说明不变性。 这不是一个工业强度复杂的复数实现。 它对复数使用了乘法和除法的标准公式，这些公式不正确会进行不正确的四舍五入，没有为复数的NaN和无穷大提供良好的语义[Kahan91，Smith62，Thomas94]。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 14:45:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8245387.html</dc:identifier>
</item>
<item>
<title>拉格朗日插值多项式的原理介绍及其应用 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/8245330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/8245330.html</guid>
<description>&lt;p&gt;  插值，不论在数学中的数值分析中，还是在我们实际生产生活中，都不难发现它的身影，比如造船业和飞机制造业中的三次样条曲线。那么，什么是插值呢？我们可以先看一下插值的定义，如下：&lt;/p&gt;
&lt;p&gt;  （&lt;strong&gt;定义&lt;/strong&gt;）如果对于每个&lt;span class=&quot;math inline&quot;&gt;\(1 \leq i \leq n,P(x_{i})=y_{i}\)&lt;/span&gt;,则称函数&lt;span class=&quot;math inline&quot;&gt;\(y=P(x)\)&lt;/span&gt;插值数据点&lt;span class=&quot;math inline&quot;&gt;\((x_{1},y_{1}),...,(x_{n},y_{n})\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;   插值的定义无疑是清楚明了的，而在众多的数学函数中，多项式无疑是最简单，最常见的函数，关于它的理论研究也最为透彻。因此，我们可以不妨先考虑利用多项式来进行插值。那么，这样的多项式是否总是存在呢？答案是肯定的，因为我们有如下定理：&lt;/p&gt;
&lt;p&gt;  （&lt;strong&gt;多项式插值定理&lt;/strong&gt;）令&lt;span class=&quot;math inline&quot;&gt;\((x_{1},y_{1}),...,(x_{n},y_{n})\)&lt;/span&gt;是平面中的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点，各&lt;span class=&quot;math inline&quot;&gt;\(x_{i}\)&lt;/span&gt;互不相同。则有且仅有一个&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;次或者更低的多项式&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;满足&lt;span class=&quot;math inline&quot;&gt;\(P(x_{i})=y_{i},i=1,2,...,n.\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;证明:&lt;/strong&gt;先用归纳法证明存在性，再证明唯一性。&lt;br/&gt;  当&lt;span class=&quot;math inline&quot;&gt;\(n=1\)&lt;/span&gt;时，常函数(0次)&lt;span class=&quot;math inline&quot;&gt;\(P_{1}(x)=x_{1}\)&lt;/span&gt;即符合要求。假设当&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;时存在一个次数&lt;span class=&quot;math inline&quot;&gt;\(\leq n-2\)&lt;/span&gt;的多项式&lt;span class=&quot;math inline&quot;&gt;\(P_{n-1}\)&lt;/span&gt;,使得&lt;span class=&quot;math inline&quot;&gt;\(P_{n-1}(x_{i})=y_{i},i=1,2,...,n-1.\)&lt;/span&gt;则令&lt;span class=&quot;math inline&quot;&gt;\(P_{n}(x)=P_{n-1}(x)+c(x-x_{1})(x-x_{2})...(x-x_{n-1})(x-x_{n})\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;为待定系数，利用&lt;span class=&quot;math inline&quot;&gt;\(P_{n}(x_{n})=y_{n}\)&lt;/span&gt;即可求出待定系数&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;.此时，&lt;span class=&quot;math inline&quot;&gt;\(P_{n}(x_{i})=y_{i},i=1,2,...,n,\)&lt;/span&gt;且&lt;span class=&quot;math inline&quot;&gt;\(P_{n}(x)\)&lt;/span&gt;的次数&lt;span class=&quot;math inline&quot;&gt;\(\leq n-1\)&lt;/span&gt;.这样就证明了存在性。&lt;br/&gt;  其次证明唯一性。假设存在两个这样的多项式，设为&lt;span class=&quot;math inline&quot;&gt;\(P(x)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(Q(x)\)&lt;/span&gt;，它们次数&lt;span class=&quot;math inline&quot;&gt;\(\leq n-1\)&lt;/span&gt;且都插值经过&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点，即&lt;span class=&quot;math inline&quot;&gt;\(P(x_{i})=Q(x_{i})=y_{i},i=1,2,...,n.\)&lt;/span&gt;令&lt;span class=&quot;math inline&quot;&gt;\(H(x)=P(x)-Q(x)\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;的次数也&lt;span class=&quot;math inline&quot;&gt;\(\leq n-1\)&lt;/span&gt;，且有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个不同的根&lt;span class=&quot;math inline&quot;&gt;\(x_{1},x_{2},...,x_{n}\)&lt;/span&gt;.因此，由多项式基本定理可知，&lt;span class=&quot;math inline&quot;&gt;\(H(x)\)&lt;/span&gt;为0多项式，即恒等于0，故有&lt;span class=&quot;math inline&quot;&gt;\(P(x)=Q(x)\)&lt;/span&gt;.这样就证明了存在性。&lt;br/&gt;  &lt;strong&gt;证毕。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  有了以上定理，我们可以放心地使用多项式进行插值，同时，通过上述定理，我们可以用归纳法来构造此多项式，但是，这样的方法难免复杂麻烦。于是，天才的法国数学家拉格朗日（Lagrange）创造性地发明了一种实用的插值多项式方法来解决这个问题，那么，他的方法是怎么样的？&lt;br/&gt;  一般来说，如果我们有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点&lt;span class=&quot;math inline&quot;&gt;\((x_{1},y_{1}),...,(x_{n},y_{n})\)&lt;/span&gt;，各&lt;span class=&quot;math inline&quot;&gt;\(x_{i}\)&lt;/span&gt;互不相同。对于1到n之间的每个&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，定义&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;次多项式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L_{k}(x) = \frac{(x-x_{1})..(x-x_{k-1})(x-x_{k+1})...(x-x_{n})}{(x_{k}-x_{1})..(x_{k}-x_{k-1})(x_{k}-x_{k+1})...(x_{k}-x_{n})}\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(L_{k}(x)\)&lt;/span&gt;具有有趣的性质：&lt;span class=&quot;math inline&quot;&gt;\(L_{k}(x_{k})=1,L_{k}(x_{j})=0,j\neq k.\)&lt;/span&gt;然后定义一个&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;次多项式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P_{n-1}(x)=y_{1}L_{1}(x)+...+y_{n}L_{n}(x).\]&lt;/span&gt;&lt;br/&gt;这样的多项式&lt;span class=&quot;math inline&quot;&gt;\(P_{n-1}(x)\)&lt;/span&gt;满足&lt;span class=&quot;math inline&quot;&gt;\(P_{n-1}(x_{i})=y_{i},i=1,2,...,n.\)&lt;/span&gt;这就是著名的拉格朗日插值多项式！&lt;br/&gt;  以上就是拉格朗日插值多项式的理论介绍部分，接下来我们就要用Python中的Sympy模块来实现拉格朗日插值多项式啦~~&lt;br/&gt;  实现拉格朗日插值多项式的Python代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; sympy &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; Lagrange_interpolation(keys, values):
    x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; symbols(&lt;span class=&quot;st&quot;&gt;'x'&lt;/span&gt;)
    t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(keys)
    ploy &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(t):
        lst &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'((x-'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(_)&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;')/('&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(keys[i])&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'-'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(_)&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'))'&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; keys &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; _ &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; keys[i]]
        item &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'*'&lt;/span&gt;.join(lst)
        ploy.append(&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(values[i])&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'*'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;item)
    ploy &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'+'&lt;/span&gt;.join(ploy)
    
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; factor(expand(ploy))

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; main():
    &lt;span class=&quot;co&quot;&gt;#example 1, interpolation a line &lt;/span&gt;
    x_1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
    y_1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;]
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(x_1) &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(y_1):
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'The lengths of two list are not equal!'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Lagrange_interpolation polynomials is:'&lt;/span&gt;)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(Lagrange_interpolation(x_1,y_1))
    
    &lt;span class=&quot;co&quot;&gt;#example 2, interpolation a parabola&lt;/span&gt;
    x_2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
    y_2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(x_2) &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(y_2):
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'The lengths of two list are not equal!'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Lagrange_interpolation polynomials is:'&lt;/span&gt;)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(Lagrange_interpolation(x_2,y_2))
    
    &lt;span class=&quot;co&quot;&gt;#example 3&lt;/span&gt;
    x_2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
    y_2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(x_2) &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(y_2):
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'The lengths of two list are not equal!'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Lagrange_interpolation polynomials is:'&lt;/span&gt;)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(Lagrange_interpolation(x_2,y_2))
        
main()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数Lagrange_interpolation()具体实现了拉格朗日插值多项式，参数(keys, values)为list形式的点对，在main()函数中举了三个Lagrange_interpolation()函数的应用实例，一个是插值两个点，即直线，一个是插值三个点，即抛物线，一个是插值四个点，但结果却是一次多项式。该程序的运行结果如下：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180108220343531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamNsaWFuOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;程序运行结果&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;  接下来，我们将介绍一个拉格朗日插值多项式的应用，即求&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[1^{k}+2^{k}+...+x^{k}\]&lt;/span&gt;&lt;br/&gt;的求和公式，其中&lt;span class=&quot;math inline&quot;&gt;\(x,k\)&lt;/span&gt;为正整数。分析如下:&lt;br/&gt;  首先，该求和公式应当是一个至多为k+1次的关于&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的多项式。然后，我们可以通过取k+2个不同的点，利用拉格朗日插值多项式的办法来求解，这k+2个不同的点的横坐标可以取&lt;span class=&quot;math inline&quot;&gt;\(x=1,2,...,k+2\)&lt;/span&gt;,在求出其对应的纵坐标的值。&lt;br/&gt;  以下代码分别求出&lt;span class=&quot;math inline&quot;&gt;\(k=1,2,...,50\)&lt;/span&gt;的求和公式，并将其插入到Redis中。
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; sympy &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; redis

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; Lagrange_interpolation(keys, values):
    x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; symbols(&lt;span class=&quot;st&quot;&gt;'x'&lt;/span&gt;)
    t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(keys)
    ploy &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(t):
        lst &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'((x-'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(_)&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;')/('&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(keys[i])&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'-'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(_)&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'))'&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; keys &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; _ &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; keys[i]]
        item &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'*'&lt;/span&gt;.join(lst)
        ploy.append(&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(values[i])&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'*'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;item)
    ploy &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'+'&lt;/span&gt;.join(ploy)
    
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; factor(expand(ploy))

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; degree_of_sum(k):
    x_list, y_list &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [], []
    degree &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; k    &lt;span class=&quot;co&quot;&gt;# degree=k in expression of  1^k+2^k+...+x^{k}&lt;/span&gt;
    cul_sum &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,degree&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;):
        x_list.append(i)
        cul_sum &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;**&lt;/span&gt;degree
        y_list.append(cul_sum)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; Lagrange_interpolation(x_list,y_list)

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; main(): 
    r &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; redis.Redis(host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'localhost'&lt;/span&gt;, port&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6379&lt;/span&gt;,db&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;51&lt;/span&gt;):
        expression &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(degree_of_sum(k))
        r.hset(&lt;span class=&quot;st&quot;&gt;'sum_&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%&lt;/span&gt;k,&lt;span class=&quot;st&quot;&gt;'degree'&lt;/span&gt;,&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(k))
        r.hset(&lt;span class=&quot;st&quot;&gt;'sum_&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%&lt;/span&gt;k,&lt;span class=&quot;st&quot;&gt;'expression'&lt;/span&gt;,expression)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Degree of &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; inserted!'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%&lt;/span&gt;k)

main()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行以上程序，结果如下：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180108221925388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamNsaWFuOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;程序运行结果&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;在Redis中的储存结果如下：&lt;br/&gt;&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180108221948384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamNsaWFuOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;Redis中储存结果&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;我们可以具体查看当&lt;span class=&quot;math inline&quot;&gt;\(k=2\)&lt;/span&gt;时的求和公式，如下：&lt;br/&gt;&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180108222038385?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamNsaWFuOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;k=2时的求和公式&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;  这样我们就介绍完了一个拉格朗日插值多项式的应用了。看了上面的介绍，聪明又机智的你是否能想到更多拉格朗日插值多项式的应用呢？欢迎大家交流哦~~&lt;br/&gt;  新的一年，新的气象，就从这一篇开始~~</description>
<pubDate>Mon, 08 Jan 2018 14:34:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/8245330.html</dc:identifier>
</item>
<item>
<title>不要什么都学-打造自己的差异化价值 - onemuji</title>
<link>http://www.cnblogs.com/bugchecker/p/build_your_unique_value.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bugchecker/p/build_your_unique_value.html</guid>
<description>&lt;p data-type=&quot;p&quot;&gt;0.&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;这个世界变化太快，行业新知识曾不不穷，唯一不变的就是变化。但我们没有别的选择，必须跟上，不然观念落后思路匮乏，与这个时代脱节，就会毫不客气地被这个时代抛弃，这不是危言耸听，而是正在发生的事情。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;那些之前毕业时进了传统外企，一干就是十几年甚至几十年的人，如果一直做的是一个很窄的方向，而现在又碰上产业调整公司裁员，那出来后真的不好找工作了。偏偏到了这个阶段，家庭负担重，消费水平和习惯也摆在那了，短时间内很难调整过来，日子会变得很艰难。更难的，是心里的煎熬。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;1.&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;我也是这样的。被焦虑感包裹，醒来就在考虑以后要怎么度过中年危机(虽然还不算到中年)。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;云计算、大数据、人工智能、区块链，各种新概念涌出来。我一个都还没弄明白学透呢，另外一个又出来了。上班的时候偷空瞄一眼，工作日下班回到家和周末的时候也找时间学，疲于奔命。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;但过几月回头一看，我到底收货了什么，浮于表面的一知半解，甚至更多的焦虑感(焦虑自己是不是学习能力下降，是不是已经跟不上时代，焦虑没有成果)。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;这时候就需要停下来反思了。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;2.&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;我想，是我的战略不对。战略目标不对(不实际)，战术上再勤奋也没用。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;从人的精力角度考虑，根本不可能仅通过自学，在短时间内把大量不同方向的技术掌握到精神的程度。而不掌握到精深的程度，根本没有意义。所以我们要做的是减法：&lt;strong&gt;集中精力打造一项专精技能(或掌握一个专精领域)。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;从心理学角度讲，对一个领域有深入的研究和掌握之后，成就感就有了。带着成就感进入另一个相对陌生的领域，我们也有自信能快速掌握起来。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;专精和掌握一个领域(不管这个领域大还是小)，对于人的意义重大。深度学习/深度工作和流于表面的学习/工作带来的价值不可同日而语，有着质的区别，这也是为什么大家都在呼吁深度学习深度工作的原因。一是深度能带来巨大的回报，二是这也是对外在的浮躁社会的努力抗争 。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;3.&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;打造自己的专精领域/技能，还要考虑所在环境/团队/行业的情况。毕竟我们都想在这个商业社会过得更好，都期望更好的经济上的回报，所以要注意打造自己的差异化价值。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;比如团队里已经有人对大数据非常了解，平时大数据相关的事情都由他掌握。那你再花大精力在大数据上，在团队内的价值不会显得特别高。当然换个思路也可以，在高手的指点下快速掌握大数据技术，然后到其他的团队或公司去发挥，那你的价值一下子就上来了。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;简而言之，成为你的团队/领域/行业里缺一不可的人。当别人有这方面的事情需要处理时，第一个想到的就是你。这就是你的标签。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;4.&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;世界变化很快，但再怎么快，一个标签足够吃一段时间，这段时间足够你来给自己贴上另一个独特的标签。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;与诸君共勉。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;欢迎关注微信公众号：一只母鸡(onemuji)。&lt;/p&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/7f6f2b8f-3274-441f-8a5c-249c1000898f.jpeg&quot; data-width=&quot;258&quot;&gt;&lt;img src=&quot;https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/7f6f2b8f-3274-441f-8a5c-249c1000898f.jpeg&quot; alt=&quot;&quot; width=&quot;258&quot;/&gt;&lt;/div&gt;
&lt;p data-type=&quot;p&quot;&gt;欢迎交流讨论。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 14:03:00 +0000</pubDate>
<dc:creator>onemuji</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bugchecker/p/build_your_unique_value.html</dc:identifier>
</item>
<item>
<title>Java学习笔记-嵌套类 - 水木竹水</title>
<link>http://www.cnblogs.com/shuimuzhushui/p/8207041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuimuzhushui/p/8207041.html</guid>
<description>&lt;h2&gt;嵌套类&lt;/h2&gt;
&lt;p&gt;嵌套类有两种类别：static and non-static，分别对应为静态嵌套类和内部类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OuterClass {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticNestedClass {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        ...
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        ...
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中静态嵌套类只能访问外部类的静态成员，内部类可以访问外部类的任意成员；它们可以被声明为&lt;code&gt;private&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, 或 package private。&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态嵌套类实例化方式为： OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();&lt;/li&gt;
&lt;li&gt;内部类实例化方式：OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 即通过外部类实例才能访问内部类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有两个比较特殊的内部类，分别为局部内部类和匿名类。&lt;/p&gt;
&lt;h2&gt;局部内部类&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;局部内部类（Local CLasses）可声明在类中任意块（block）中，如方法、for或if块中&lt;/li&gt;
&lt;li&gt;局部内部类可以访问外部类的成员，若局部内部类声明在静态块中，则可访问外部类的静态成员；若声明在非静态块中，则可访问外部类所有成员；&lt;/li&gt;
&lt;li&gt;局部内部类可以访问所在块的局部变量，但该局部变量必须声明为final；在JDK8中进行了改进，局部变量可以声明为final或effectively final；&lt;/li&gt;
&lt;li&gt;其他特性类似于普通内部类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中effectively final与final局部变量的区别在于，前者可以不显式声明变量为final，只要在整个过程中，该变量不会被修改（编译器默认该情况为final）。具体为什么局部内部类为什么必须引用final变量，可参考&lt;/p&gt;


&lt;p&gt;匿名类与局部内部类相似，只是没有命名，并且同时进行声明和实例化。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; HelloWorld frenchGreeting = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloWorld() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             String name = &quot;tout le monde&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; greet() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 greetSomeone(&quot;tout le monde&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; greetSomeone(String someone) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 name =&lt;span&gt; someone;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 System.out.println(&quot;Salut &quot; +&lt;span&gt; name);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 匿名内部类适用于只用一次的情况。其他的特性与局部内部类相同。&lt;/p&gt;
&lt;h2 data-reactid=&quot;72&quot;&gt;Lambda表达式&lt;/h2&gt;
&lt;p&gt; 在使用匿名内部类的时候，无需提供类名。对于只有一个方法的接口，使用Lambda显然比匿名类的实现简单明了。如下所示，定义一个LambdaTest接口，该接口只包含一个opt方法：&lt;/p&gt;
&lt;div data-reactid=&quot;72&quot; readability=&quot;28&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; LambdaTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; opt(&lt;span&gt;int&lt;/span&gt; a , &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; LambdaTest sumTest = (a,b) -&amp;gt; a+b；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第5行即为Lambda表达式声明，其中（a,b）为方法的参数，a+b为方法体，-&amp;gt;表示将参数传递给方法体。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Lambda表达式的方法体中，可以是一个表达式，也可以是代码块。若为表达式，Java运行期会计算表达式，并返回结果；若为代码块，可以添加return语句，将结果返回。&lt;/li&gt;
&lt;li&gt;Lambda表达式其实是一个方法的声明，可以认为Lambda表达式是&lt;strong&gt;匿名方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Lambda表达式与局部内部类和匿名类相似，可以访问外部类和外部代码块的变量；但与后两者不同，其&lt;strong&gt;不存在变量覆盖的问题，可以认为没有引入新的代码块，其与外部代码块中的局部变量同级&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;由于第三条，所以在表达式的参数中，&lt;strong&gt;不能声明与同级作用域相同的变量名&lt;/strong&gt;，否则会出现重复定义的异常。&lt;/li&gt;
&lt;li&gt;Lambda表达式是匿名内部类实现形式的一种，其访问的外部变量必须是final或effectively final。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Lambda {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; var = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String x = &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Cal{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; op(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Print{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(String msg);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; operator(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b, Cal cal) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cal.op(a, b);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; operator1(String msg, Print print) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        print.print(msg);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; operator2(String x) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        x = &quot;&quot;;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         
&lt;span&gt;26&lt;/span&gt;         Print print = (msg) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             System.out.println(&quot;Lambda访问外部变量：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            System.out.println(x);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            System.out.println(msg);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             System.out.println(Lambda.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        print.print(x);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         Cal add = (a,b) -&amp;gt; {&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;};
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         Cal mul = (a,b) -&amp;gt; a*&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         
&lt;span&gt;40&lt;/span&gt;         Lambda lambda = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Lambda();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         System.out.println(&quot;2+3=&quot;+lambda.operator(2, 3&lt;span&gt;, add));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         System.out.println(&quot;2*3=&quot;+lambda.operator(2, 3&lt;span&gt;, mul));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         
&lt;span&gt;44&lt;/span&gt;         lambda.var = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         Print print = (msg) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            System.out.println(msg);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            System.out.println(lambda.var);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         lambda.operator1(&quot;Hello World&quot;&lt;span&gt;, print);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         lambda.operator2(&quot;Hello Lambda&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 2+3=5
&lt;span&gt;2&lt;/span&gt; 2*3=6
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Hello World
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 200
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;Lambda访问外部变量：
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;Hello Lambda
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;Hello Lambda
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其中operator2方法可以验证后三条，如果将24行的注释取消，28行就会报“local variables referenced from a lambda expression must be final or effectively final”的异常。&lt;/p&gt;
&lt;h3&gt;目标类型（Target Type）&lt;/h3&gt;
&lt;p&gt;目标类型为外部类方法期望调用的类型，如上例中operator期望调用的目标方法为Cal。Java会根据Lambda表达式所处的语境和上下文信息判断目标类型，并实现调用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div data-reactid=&quot;72&quot; readability=&quot;22.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TargetType {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Cal{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        String op();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Cal1{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; op1();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Cal2{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; op1();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String invoke(Cal cal) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cal.op();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invoke(Cal1 cal1) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        cal1.op1();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invoke(Cal2 cal2) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        cal2.op1();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         invoke(() -&amp;gt; &quot;done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         invoke(() -&amp;gt; 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         invoke(() -&amp;gt; {&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;});
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;声明三个接口（Cal Cal1 Cal2），具有相同名称的方法，但他们的返回值不同。另声明了3个invoke方法，分别接收3个类，即期望的目标类型不同。然后进行测试：&lt;/p&gt;
&lt;p&gt;main方法中的三个语句都通过编译，并且eclipse提示28行调用目标类型为Cal的invoke，29行调用目标类型为Cal1的invoke，30行调用目标类型为Cal2的invoke，目标类型如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1012728/201801/1012728-20180108213057691-61877383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）如果再添加一句如：invoke(() -&amp;gt; 100.0);  则编译器会报错，Type mismatch: cannot convert from double to String；&lt;/p&gt;
&lt;p&gt;（2）如果将Cal接口方法的返回值改为int，则除了28行报错，29行也报错：The method invoke(TargetType.Cal) is ambiguous for the type TargetType，即编译器无法确定调用哪个目标类型。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 官网文档中举的例子为Runnable和Callable，原理一样，如下：&lt;/p&gt;
&lt;div data-reactid=&quot;72&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    V call();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 方法声明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invoke(Runnable r) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    r.run();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &amp;lt;T&amp;gt; T invoke(Callable&amp;lt;T&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; c.call();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div data-reactid=&quot;72&quot; readability=&quot;8.3469387755102&quot;&gt; 根据上下文确定目标类型，由于有返回值，所以会调用参数为Callable的invoke方法：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String s = invoke(() -&amp;gt; &quot;done&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 总结：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;静态嵌套类与内部类区别&lt;/li&gt;
&lt;li&gt;两类特殊的内部类，局部内部类和匿名内部类；&lt;/li&gt;
&lt;li&gt;匿名内部类的特殊实现：Lambda表达式，可认为匿名方法的实现；&lt;/li&gt;
&lt;li&gt;Lambda表达式会根据上下文环境确定目标类型&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;参考：&lt;/h2&gt;
&lt;/div&gt;


</description>
<pubDate>Mon, 08 Jan 2018 13:57:00 +0000</pubDate>
<dc:creator>水木竹水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuimuzhushui/p/8207041.html</dc:identifier>
</item>
<item>
<title>深入剖析MSAA - 风恋残雪</title>
<link>http://www.cnblogs.com/ghl_carmack/p/8245032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ghl_carmack/p/8245032.html</guid>
<description>&lt;p&gt;本文打算对MSAA(Multisample anti aliasing)做一个深入的讲解，包括基本的原理、以及不同平台上的实现对比（主要是PC与Mobile）。为了对MSAA有个更好的理解，所以写下了这篇文章。当然文章中难免有错误之处，如有发现，还请指证，以免误导其他人。好了，废话不多说，下面我们开始正文。&lt;/p&gt;


&lt;h2&gt;Aliasing(走样)&lt;/h2&gt;
&lt;p&gt;在介绍MSAA原理之前，我们先对走样（Aliasing）做个简单介绍。在信号处理以及相关领域中，走样（混叠）在对不同的信号进行采样时，导致得出的信号相同的现象。它也可以指信号从采样点重新信号导致的跟原始信号不匹配的瑕疵。它分为时间走样（比如数字音乐、以及在电影中看到车轮倒转等）和空间走样两种（摩尔纹）。这里我们不详细展开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213705910-1675359239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体到实时渲染领域中，走样有以下三种：&lt;/p&gt;
&lt;ol readability=&quot;13&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;几何体走样（几何物体的边缘有锯齿），几何走样由于对几何边缘采样不足导致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213706363-905821359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;着色走样，由于对着色器中着色公式（渲染方程）采样不足导致。比较明显的现象就是高光闪烁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213706660-821561241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213706972-214047564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面一张图显示了由于对使用了高频法线贴图的高频高光BRDF采样不足时产生的着色走样。下面这张图显示了使用4倍超采样产生的效果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;时间走样，主要是对高速运动的物体采样不足导致。比如游戏中播放的动画发生跳变等。&lt;/p&gt;
&lt;h2&gt;SSAA（超采样反走样）&lt;/h2&gt;
&lt;p&gt;从名字可以看出，超采样技术就是以一个更大的分辨率来渲染场景，然后再把相邻像素值做一个过滤（比如平均等）得到最终的图像（Resolve）。因为这个技术提高了采样率，所以它对于解决上面几何走样和着色走样都是有效果的。如下图所示，首先经对每个像素取n个子采样点，然后针对每个子像素点进行着色计算。最后根据每个子像素的值来合成最终的图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213707207-1122800965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然SSAA可以有效的解决几何走样和着色走样问题，但是它需要更多的显存空间以及更多的着色计算（每个子采样点都需要进行光照计算），所以一般不会使用这种技术。顺着上面的思路，如果我们对最终的每个像素着色，而不是每个子采样点着色的话，那这样虽然显存还是那么多，但是着色的数量少了，那它的效率也会有比较大的提高。这就是我们今天想要主要说的MSAA技术。&lt;/p&gt;
&lt;h2&gt;MSAA(多重采样反走样)&lt;/h2&gt;
&lt;p&gt;在前面提到的SSAA中，每个子采样点都要进行单独的着色，这样在片断（像素）着色器比较复杂的情况下还是很费的。那么能不能只计算每个像素的颜色，而对于那些子采样点只计算一个覆盖信息（coverage）和遮挡信息（occlusion）来把像素的颜色信息写到每个子采样点里面呢？最终根据子采样点里面的颜色值来通过某个重建过滤器来降采样生成目标图像。这就是MSAA的原理。&lt;span&gt;注意这里有一个很重要的点，就是每个子像素都有自己的颜色、深度模板信息，并且每一个子采样点都是需要经过深度和模板测试才能决定最终是不是把像素的颜色得到到这个子采样点所在的位置，而不是简单的作一个覆盖测试就写入颜色。&lt;/span&gt;关于这个的出处，我在接下来的文章里会写出多个出处来佐证这一点。现在让我们先把MSAA的原理讲清楚。&lt;/p&gt;
&lt;h3&gt;Coverage（覆盖）以及Occlusion(遮挡)&lt;/h3&gt;
&lt;p&gt;一个支持D3D11的显卡支持通过光栅化来渲染点、线以及三角形。显卡上的光栅化管线把图形的顶点当作输入，这些顶点的位置是在经由透视变换的齐次裁剪空间。它们用来决定这个三角形在当前渲染目标上的像素的位置。这个可见像素由两个因素决定:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;35.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;覆盖 覆盖是通过判断一个图形是否跟一个指定的像素重叠来决定的。在显卡中，覆盖是通过测试一个采样点是否在像素的中心来决定的。接下来的图片说明了这个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213707472-1150979602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个三角形的覆盖信息。蓝色的点代表采样点，每一个都在像素的中心位置。红色的点代表三角形覆盖的采样点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;67&quot;&gt;
&lt;p&gt;遮挡告诉我们被一个图形覆盖的像素是否被其它的像素覆盖了，这种情况大家应该很熟悉就是z buffer的深度测试。&lt;/p&gt;
&lt;p&gt;覆盖和遮挡两个一起决定了一个图形的可见性。&lt;/p&gt;
&lt;p&gt;就光栅化而言，MSAA跟SSAA的方式差不多，覆盖和遮挡信息都是在一个更大分辨率上进行的。对于覆盖信息来说，硬件会对每个子像素根据采样规则生成n的子采样点。接下来的这张图展示了一个使用了旋转网格（rotated grid）采样方式的子采样点位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213707754-1034685089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三角形会与像素的每个子采样点进行覆盖测试，会生成一个二进制覆盖掩码，它代表了这个三角形覆盖当前像素的比例。对于遮挡测试来说，三角形的深度在每一个覆盖的子采样点的位置进行插值，并且跟z buffer中的深度信息进行比较。由于深度测试是在每个子采样点的级别而不是像素级别进行的，深度buffer必须相应的增大以来存储额外的深度值。在实现中，这意味着深度缓冲区是非MSAA情况下的n倍。&lt;/p&gt;
&lt;p&gt;MSAA跟SSAA不同的地方在于，SSAA对于所有子采样点着色，而MSAA只对当前像素覆盖掩码不为0的进行着色，顶点属性在像素的中心进行插值用于在片断程序中着色。这是MSAA相对于SSAA来说最大的好处。&lt;/p&gt;
&lt;p&gt;虽然我们只对每个像素进行着色，但是并不意味着我们只需要存储一个颜色值，而是需要为每一个子采样点都存储颜色值，所以我们需要额外的空间来存储每个子采样点的颜色值。所以，颜色缓冲区的大小也为非MSAA下的n倍。当一个片断程序输出值时，只有地了覆盖测试和遮挡测试的子采样点才会被写入值。因此如果一个三角形覆盖了4倍采样方式的一半，那么一半的子采样点会接收到新的值。或者如果所有的子采样点都被覆盖，那么所有的都会接收到值。接下来的这张图展示了这个概念：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213707926-1368468659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过使用覆盖掩码来决定子采样点是否需要更新值，最终结果可能是n个三角形部分覆盖子采样点的n个值。接下来的图像展示了4倍MSAA光栅化的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213708285-883517292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;MSAA Resolve(MSAA 解析)&lt;/h3&gt;
&lt;p&gt;像超采样一样，过采样的信号必须重新采样到指定的分辨率，这样我们才可以显示它。&lt;/p&gt;
&lt;p&gt;这个过程叫解析（resolving）。在它最早的版本里，解析过程是在显卡的固定硬件里完成的。一般使用的采样方法就是一像素宽的box过滤器。这种过滤器对于完全覆盖的像素会产生跟没有使用MSAA一样的效果。好不好取决于怎么看它（好是因为你不会因为模糊而减少细节，坏是因为一个box过滤器会引入后走样（postaliasing））。对于三角形边上的像素，你会得到一个标志性的渐变颜色值，数量等于子采样点的个数。接下来的图展示了这一现象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213708519-657972946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然不同的硬件厂商可能会使用不同的算法。比如nVidia的&quot;Quincunx&quot; AA等。随着显卡的不断升级，我们现在可以通过自定义的shader来做MSAA的解析了。&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;通过上面的解释，我们可以看到，整个MSAA并不是在光栅化阶段就可以完全的，它在这个阶段只是生成覆盖信息。然后计算像素颜色，根据覆盖信息和深度信息决定是否来写入子采样点。整个完成后再通过某个过滤器进行降采样得到最终的图像。大体流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213708754-166359701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面我们讲解了MSAA的基本原理，那么具体到不同显卡厂商以及不同平台上的实现有什么不同吗？下面就让我们做些简单的对比。其实，既然算法已经确定了，那么差异基本上就是在一些细节上的处理，以及GPU架构不同带来的差异。&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;15.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;MSAA是否支持&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;自定义Shader解析&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;是否需要更大的颜色 深度 缓冲区&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;Direct3D 9&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;否&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;Direct3D 11&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;Direct3D 12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;需要&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;17.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;OpenGL ES 2.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;(Multisample rasterization cannot be enabled or disabled after a GL context is created. It is enabled if the value of SAMPLE_BUFFERS is one, and disabled otherwise)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Multisample Texture:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用GL_EXT_multisampled_render_to_texture扩展&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;苹果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;APPLE_framebuffer_multisample&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安卓：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用EGL&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;否&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;看GPU架构 ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TBR(Mali Qualcomm Adreno(300系列之前)） TBDR（PowerVR） 不需要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IMR（nVidia Tera Qualcomm Adreno 300系列以及之后可以在IMR、TBR之间切换）需要。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果使用GL_EXT_multisampled_render_to_texture也需要（跟硬件实现有关（enabling MSAA the right way in OpenGL ES））。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;24.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;OpenGL ES 3.0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（The technique is to sample all primitives multiple times at each pixel. The color sample values are resolved to a single, displayable color. For window system-provided framebuffers, this occurs each time a pixel is updated, so the antialiasing appears to be automatic at the application level. For application-created framebuffers, this must be requested by calling the BlitFramebuffer command (see section 4.3.3).）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;When rendering textures, emphasis is placed on multisample anti-aliasing (MSAA), which earlier hardware generations could only run against the framebuffer. OpenGL ES 3.0 can presently support MSAA-type rendering for a texture.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;否&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;如果是系统提供的framebuffer,那么同OpenGL ES 2.0的版本。如果是用户创建的framebuffer，那么是需要额外的显存的(跟硬件实现有关？？？)。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;OpenGL ES 3.1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;是（sampler2DMS）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;如果是系统提供的framebuffer,那么同OpenGL ES 2.0的版本。如果是用户创建的framebuffer，那么是需要额外的显存的(跟硬件实现有关？？？)。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2&gt;IMR vs TBR vs TBDR&lt;/h2&gt;
&lt;h3&gt;IMR （立即渲染模式）&lt;/h3&gt;
&lt;p&gt;目前PC平台上基本上都是立即渲染模式，CPU提交渲染数据和渲染命令，GPU开始执行。它跟当前已经画了什么以及将来要画什么的关系很小（Early Z除外）。流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213708941-542324554.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;TBR（分块渲染）&lt;/h3&gt;
&lt;p&gt;TBR把屏幕分成一系列的小块，每个单独来处理，所以可以做到并行。由于在任何时候显卡只需要场景中的一部分数据就可完成工作，这些数据（如颜色 深度等）足够小到可以放在显卡芯片上（on-chip），有效得减少了存取系统内存的次数。它带来的好处就是更少的电量消耗以及更少的带宽消耗，从而会获得更高的性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213709129-433786075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213709332-124073518.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;TBDR （分块延迟渲染）&lt;/h3&gt;
&lt;p&gt;TBDR跟TBR有些相似，也是分块，并使用在芯片上的缓存来存储数据（颜色以及深度等），它还使用了延迟技术，叫隐藏面剔除（Hidden Surface Removal），它把纹理以及着色操作延迟到每个像素已经在块中已经确定可见性之后，只有那些最终被看到的像素才消耗处理资源。这意味着隐藏像素的不必要处理被去掉了，这确保了每帧使用最低可能的带宽使用和处理周期数，这样就可以获取更高的性能以及更少的电量消耗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213709551-103111282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个简单的对比传统GPU与TBDR&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213709738-1136592043.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;移动平台上的MSAA&lt;/h2&gt;
&lt;p&gt;有了上面对移动GPU架构的简单了解，下面我们看下在移动平台上是怎么处理MSAA的，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213709957-388476827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到如果相对于IMR模式的显卡来说，TBR或者TBDR的实现MSAA会省很多，因为好多工作直接在on-chip上就完成了。这里还是有两个消耗： &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;4倍MSAA需要四倍的块缓冲内存。由于芯片上的块缓冲内存很最贵，所以显卡会通过减少块的大小来消除这个问题。减少块的大小对性能有所影响，但是减少一半的大小并不意味着性能会减半，瓶颈在片断程序的只会有一个很小的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;第二个影响就是在物体边缘会产生更多的片断，这个在IMR模式下也有。每个多边形都会覆盖更多的像素如下图所示。而且，背景和前景的图形都贡献到一个交互的地方，两片断都需要着色，这样硬件隐藏背面剔除就会剔除更少的像素。这些额外片断的消耗跟场景是由多少边缘组成有关，但是10%是一个比较好的猜测。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213710144-1974113446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;主流移动GPU的实现细节&lt;/h2&gt;
&lt;h3&gt;Mali:&lt;/h3&gt;
&lt;p&gt;JUST22 - Multisampled resolve on-tile is supported in hardware with no bandwidth hit Mali GPUs support resolving multisampled framebuffers on-tile. Combined with tile-buffer support for full throughput in 4x MSAA makes 4x MSAA a very compelling way of improving quality with minimal speed hit.&lt;/p&gt;

&lt;p&gt;In GLES on Mali GPUs, the simplest case for 4xMSAA would be to render directly to the window surface (FB0), having set EGL_SAMPLES to 4. This will do all multisampling and resolving in the GPU registers, and will only flush the resolved buffer to memory. This is the most efficient way to implement MSAA on a Mali GPU, and comes at almost no performance cost compared to rendering to a normal window surface. Note that this does not expose the sample buffers themselves to you, and does not require an explicit resolve.&lt;/p&gt;

&lt;h3&gt;Qualcomm Adreno:&lt;/h3&gt;
&lt;p&gt;Anti-aliasing is an important technique for improving the quality of generated images. It reduces&lt;/p&gt;
&lt;p&gt;the visual artifacts of rendering into discrete pixels.&lt;/p&gt;
&lt;p&gt;Among the various techniques for reducing aliasing effects, multisampling is efficiently&lt;/p&gt;
&lt;p&gt;supported by Adreno 4x. Multisampling divides every pixel into a set of samples, each of which&lt;/p&gt;
&lt;p&gt;is treated like a &quot;mini-pixel&quot; during rasterization. Each sample has its own color, depth, and&lt;/p&gt;
&lt;p&gt;stencil value. And those values are preserved until the image is ready for display. When it is time&lt;/p&gt;
&lt;p&gt;to compose the final image, the samples are resolved into the final pixel color. Adreno 4xx&lt;/p&gt;
&lt;p&gt;supports the use of two or four samples per pixel.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/155497/201801/155497-20180108213710332-722833805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;PowerVR:&lt;/h3&gt;
&lt;p&gt;Another benefit of the SGX and SGX-MP architecture is the ability to perform efficient 4x Multi-Sample Anti-Aliasing (MSAA). MSAA is performed entirely on-chip, which keeps performance high without introducing a system memory bandwidth overhead (as would be seen when performing anti-aliasing in some other architectures). To achieve this, the tile size is effectively quartered and 4 sample positions are taken for each fragment (e.g., if the tile size is 16x16, an 8x8 tile will be processed when MSAA is enabled). The reduction in tile size ensures the hardware has sufficient memory to process and store colour, depth and stencil data for all of the sample positions. When the ISP operates on each tile, HSR and depth tests are performed for all sample positions. Additionally, the ISP uses a 1 bit flag to indicate if a fragment contains an edge. This flag is used to optimize blending operations later in the render. When the subsamples are submitted to the TSP, texturing and shading operations are executed on a per-fragment basis, and the resultant colour is set for all visible subsamples. This means that the fragment workload will only slightly increase when MSAA is enabled, as the subsamples within a given fragment may be coloured by different primitives when the fragment contains an edge. When performing blending, the edge flag set by the ISP indicates if the standard blend path needs to be taken, or if the optimized path can be used. If the destination fragment contains an edge, then the blend needs to be performed individually for each visible subsample to give the correct resultant colour (standard blend). If the destination fragment does not contain an edge, then the blend operation is performed once and the colour is set for all visible subsamples (optimized blend). Once a tile has been rendered, the Pixel Back End (PBE) combines the subsample colours for each fragment into a single colour value that can be written to the frame buffer in system memory. As this combination is done on the hardware before the colour data is sent, the system memory bandwidth required for the tile flush is identical to the amount that would be required when MSAA is not enabled.&lt;/p&gt;


&lt;p&gt;On PowerVR hardware Multi-Sampled Anti-Aliasing (MSAA) can be performed directly in on-chip memory before being written out to system memory, which saves valuable memory bandwidth. In general, MSAA is considered to cost relatively little performance. This is true for typical games and UIs, which have low geometry counts but very complex shaders. The complex shaders typically hide the cost of MSAA and have a reduced blend workload. 2x MSAA is virtually free on most PowerVR graphics cores (Rogue onwards), while 4x MSAA+ will noticeably impact performance. This is partly due to the increased on-chip memory footprint, which results in a reduction in tile dimensions (for instance 32 x 32 -&amp;gt; 32 x 16 -&amp;gt; 16 x 16 pixels) as the number of samples taken increases. This in turn results in an increased number of tiles that need to be processed by the tile accelerator hardware, which then increases the vertex stages overall processing cost. The concept of &quot;good enough‟ should be followed in determining how much anti-aliasing is enough. An application may only require 2x MSAA to look &quot;good enough‟, while performing comfortably at a consistent 60 FPS. In some cases there may be no need for anti-aliasing to be used at all e.g. when the target device‟s display has high PPI (pixels per-inch). Performing MSAA becomes more costly when there is an alpha blended edge, resulting in the graphics core marking the pixels on the edge to &quot;on edge blend&quot;. On edge blend is a costly operation, as the blending is performed for each sample by a shader (i.e. in software). In contrast, on opaque edge is performed by dedicated hardware, and is a much cheaper operation as a result. On edge blend is also &quot;sticky‟, which means that once an on-screen pixel is marked, all subsequent blended pixels are blended by a shader, rather than by dedicated hardware. In order to mitigate these costs, submit all opaque geometry first, which keeps the pixels &quot;off edge&quot; for as long as possible. Also, developers should be extremely reserved with the use of blending, as blending has lots of performance implications, not just for MSAA.&lt;/p&gt;

&lt;p&gt;通过上面的讲解，我们了解了MSAA的实现原理，以及在PC平台和移动平台上因为架构的不同导致具体实现细节的不同。MSAA是影响了GPU管理的光栅化、片断程序、光栅操作阶段（每个子采样点都要做深度测试）的。每个子采样点都是有自己的颜色和深度存储的，并且每个子采样点都会做深度测试。在移动平台上，是否需要额外的空间来存储颜色和深度需要根据OpenGL ES的版本以及具体硬件的实现有关。MSAA在一般的情况下（不需要额外空间来存储颜色和深度，直接在on-chip上完成子采样点计算，然后直接resolve到framebuffer）是要比PC平台上效率高的，因为没有了那么大的带宽消耗。但是鉴于硬件实现差异大，建议还是以实测为准。由于本人水平有限，难免会有错误的地方。如果发现，还请指正，以免误导了他人。&lt;/p&gt;


&lt;ol&gt;&lt;li&gt;https://en.wikipedia.org/wiki/Aliasing&lt;/li&gt;
&lt;li&gt;https://en.wikipedia.org/wiki/Moir%C3%A9_pattern&lt;/li&gt;
&lt;li&gt;https://mynameismjp.wordpress.com/2012/10/21/applying-sampling-theory-to-real-time-graphics/&lt;/li&gt;
&lt;li&gt;https://en.wikipedia.org/wiki/Supersampling&lt;/li&gt;
&lt;li&gt;https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/&lt;/li&gt;
&lt;li&gt;https://mynameismjp.wordpress.com/2012/10/28/msaa-resolve-filters/&lt;/li&gt;
&lt;li&gt;http://graphics.stanford.edu/courses/cs248-07/lectures/2007.10.11%20CS248-06%20Multisample%20Antialiasing/2007.10.11%20CS248-06%20Multisample%20Antialiasing.ppt&lt;/li&gt;
&lt;li&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/cc627092(v=vs.85).aspx&lt;/li&gt;
&lt;li&gt;https://www.khronos.org/registry/OpenGL/specs/es/2.0/es_full_spec_2.0.pdf&lt;/li&gt;
&lt;li&gt;https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_multisampled_render_to_texture.txt&lt;/li&gt;
&lt;li&gt;https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/WorkingwithEAGLContexts/WorkingwithEAGLContexts.html#//apple_ref/doc/uid/TP40008793-CH103-SW4&lt;/li&gt;
&lt;li&gt;https://stackoverflow.com/questions/27035893/antialiasing-in-opengl-es-2-0&lt;/li&gt;
&lt;li&gt;https://www.imgtec.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/&lt;/li&gt;
&lt;li&gt;https://www.imgtec.com/blog/understanding-powervr-series5xt-powervr-tbdr-and-architecture-efficiency-part-4/&lt;/li&gt;
&lt;li&gt;https://en.wikipedia.org/wiki/Tiled_rendering&lt;/li&gt;
&lt;li&gt;https://www.qualcomm.com/media/documents/files/the-rise-of-mobile-gaming-on-android-qualcomm-snapdragon-technology-leadership.pdf&lt;/li&gt;
&lt;li&gt;https://static.docs.arm.com/100019/0100/arm_mali_application_developer_best_practices_developer_guide_100019_0100_00_en2.pdf&lt;/li&gt;
&lt;li&gt;https://www.imgtec.com/blog/introducing-the-brand-new-opengl-es-3-0/&lt;/li&gt;
&lt;li&gt;https://www.khronos.org/assets/uploads/developers/library/2014-gdc/Khronos-OpenGL-ES-GDC-Mar14.pdf&lt;/li&gt;
&lt;li&gt;https://android.googlesource.com/platform/external/deqp/+/193f598/modules/gles31/functional/es31fMultisampleShaderRenderCase.cpp&lt;/li&gt;
&lt;li&gt;https://www.anandtech.com/show/4686/samsung-galaxy-s-2-international-review-the-best-redefined/15&lt;/li&gt;
&lt;li&gt;https://www.imgtec.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/&lt;/li&gt;
&lt;li&gt;http://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-TileBasedArchitectures.pdf&lt;/li&gt;
&lt;li&gt;https://static.docs.arm.com/100019/0100/arm_mali_application_developer_best_practices_developer_guide_100019_0100_00_en2.pdf&lt;/li&gt;
&lt;li&gt;https://community.arm.com/graphics/f/discussions/4426/multisample-antialiasing-using-multisample-fbo&lt;/li&gt;
&lt;li&gt;http://cdn.imgtec.com/sdk-documentation/PowerVR+Series5.Architecture+Guide+for+Developers.pdf&lt;/li&gt;
&lt;li&gt;http://cdn.imgtec.com/sdk-documentation/PowerVR.Performance+Recommendations.pdf&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Mon, 08 Jan 2018 13:37:00 +0000</pubDate>
<dc:creator>风恋残雪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ghl_carmack/p/8245032.html</dc:identifier>
</item>
<item>
<title>腾讯WeTest发布《2017中国移动游戏质量白皮书》，专注手游品质提升 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/8244831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/8244831.html</guid>
<description>&lt;p&gt;1月8日，腾讯质量开放平台WeTest正式发布《2017中国移动游戏质量白皮书》。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;刚刚过去的这一年，市场逐渐成熟，中国移动互联网由增量市场转向存量市场。中国移动游戏市场急剧变化，真正的精品游戏也由此获得了更多的生存空间。正如腾讯互娱研发部助理总经理荆彦青在白皮书开卷致辞中所说：&lt;/span&gt;“2017年是精品游戏的破局之年。产品为王，质量先行”。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;大浪淘沙下，不仅过去的投机者们纷纷被迫离场，品质不足的游戏再也难逃被无情淘汰的命运。仅有新奇创意的产品，一旦在产品质量上出现重大问题，也会瞬间跌入谷底。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;“&lt;span&gt;创意&lt;/span&gt;&lt;span&gt;是游戏的灵魂，质量是游戏的生命&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;”&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此次的《&lt;/span&gt;2017&lt;span&gt;中国移动游戏质量白皮书》，分别从研发概况、市场硬件环境、兼容性、客户端&lt;/span&gt;/&lt;span&gt;服务器端性能、安全现状、舆论口碑等多个层面，汇总中国移动游戏产品质量数据和趋势，最大程度展现手游研发质量现状。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;兼容性问题不容忽视，&lt;/span&gt;UI异常占比过半&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在兼容性问题方面，从&lt;/span&gt;2017版白皮书可知，较之往年，安装失败类问题的比重显著下降。在2017年，UI异常、APK Crash、无响应三大兼容性问题在安卓设备中最为突出，其中UI异常问题，在安卓设备中的占比高达57%，而APK Crash（崩溃）问题的占比基本同去年持平。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180108203349551-48258033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而在&lt;/span&gt;iOS设备里，UI异常同样最为普遍，总体占比达43%。后续报告内容中则进一步指出，UI异常问题的突出，与两大因素有关——其中一个是全面屏手机的出现，导致2560*1440超高分辨率下的UI适配异常，另一个则是iOS版本带来的系统兼容性因素，主要集中于Android 4和iOS 11两大系列。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180108203422379-2002863904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安全形势更趋严峻，全行业面临外挂挑战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;“手游安全报告”一章中，着重阐述了当前国内手游行业不容乐观的安全形势，并指出：近三成手游存在致命外挂安全问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此外，在不同类型的产品中，飞行射击类游戏的外挂安全问题最为严重&lt;/span&gt;——平均每款游戏有34个安全问题，其次则是分别为20个和19个的体育类和赛车跑酷类。报告认为，这三类游戏的强交互需求成为了外挂漏洞的“温床”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180108203449019-627267537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而在对不同外挂问题类型的分析中，&lt;/span&gt;“盗刷道具”问题占据了致命问题的1/4左右，不仅占比极高，同时也因其破坏巨大，而理应引起足够重视。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180108203530566-1491631535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1080p以上分辨率成为主流，iPhone X带来适配新问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2017年，在安卓TOP100设备中，1920*1080分辨率占比为39%，比例为各分辨率中最高，甚至更高的2560*1440也已拥有4%的占比，也即意味着1080p以上分辨率在安卓主要机型中的占比已经近半，成为绝对主流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180108203607613-1863087533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而这一数据所蕴含的信息，也同&lt;/span&gt;2017年国内手游市场上，对分辨率较为注重的竞技类游戏的大行其道完全吻合。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;与此同时，&lt;/span&gt;2560*1440超高分辨率的逐渐增多，也与全面屏手机的异军突起密不可分。并且在2017年问世的全面屏手机当中，iPhone X也因其带来的特殊适配问题而得到了全行业的更多关注。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;专注产品质量，&lt;/span&gt;WeTest携手腾讯游戏云为开发者护航&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;产品品质对于当前的移动游戏开发来说，重要性早已不言而喻。而作为一站式游戏&lt;/span&gt;/应用测试服务平台，WeTest对于手游产品质量的注重，充分体现在了《2017中国移动游戏质量白皮书》当中。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;与此同时，&lt;/span&gt;WeTest平台还与腾讯云展开战略合作。腾讯云借助于腾讯海量游戏研发运营经验，致力于打造高质量、全方位、覆盖游戏全生命周期的云服务平台——腾讯游戏云。腾讯游戏云目前已开放全球21个地理区域内的36 个可用区。双方的强强联合，将为广大游戏开发者，在反复打磨产品的过程中提供更专业全面的测试及产品质量服务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用心&lt;/span&gt;&lt;span&gt;创造快乐，&lt;/span&gt;&lt;span&gt;以&lt;/span&gt;&lt;span&gt;品质点亮游戏，&lt;/span&gt;&lt;span&gt;期望更多兼具创意与品质的游戏产品，能够在&lt;/span&gt;2018年茁壮成长。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180108203642926-684664846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;《&lt;/span&gt;2017中国&lt;span&gt;移动游戏&lt;/span&gt;&lt;span&gt;质量&lt;/span&gt;&lt;span&gt;白皮书&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;完整内容，请&lt;/span&gt;&lt;span&gt;前往腾讯&lt;/span&gt;WeTest&lt;span&gt;官网&lt;/span&gt;&lt;span&gt;下载。下载链接：&lt;a href=&quot;http://wetest.qq.com/whitepaper/2017?from=content_cnblogs_wp2017&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;token link&quot;&gt;&lt;span class=&quot;token md md-bracket-start&quot;&gt;&lt;span class=&quot;token md md-underlined-text&quot;&gt;http://wetest.qq.com/whitepaper/2017&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 08 Jan 2018 12:51:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/8244831.html</dc:identifier>
</item>
</channel>
</rss>