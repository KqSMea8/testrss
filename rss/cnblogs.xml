<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>BZOJ 3108: [cqoi2013]图的逆变换 - SongHL</title>
<link>http://www.cnblogs.com/songorz/p/9937744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songorz/p/9937744.html</guid>
<description>&lt;center&gt;&lt;span class=&quot;green&quot;&gt;Time Limit: 10 Sec  &lt;span class=&quot;green&quot;&gt;Memory Limit: 128 MB&lt;br/&gt;&lt;span class=&quot;green&quot;&gt;Submit: 627  &lt;span class=&quot;green&quot;&gt;Solved: 415&lt;br/&gt;[&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/submitpage.php?id=3108&quot;&gt;Submit&lt;/a&gt;][&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problemstatus.php?id=3108&quot;&gt;Status&lt;/a&gt;][&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/bbs.php?id=3108&quot;&gt;Discuss&lt;/a&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/center&gt;
&lt;h2&gt;Description&lt;/h2&gt;
&lt;div class=&quot;content&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;给一个n结点m条边的有向图D，可以这样构造图E：给D的每条边u-&amp;gt;v，在E中建立一个点uv，然后对于D中的两条边u-&amp;gt;v和v-&amp;gt;w，在E中从uv向vw连一条有向边。E中不含有其他点和边。&lt;/p&gt;
&lt;p&gt;输入E，你的任务是判断是否存在相应的D。注意，D可以有重边和自环。&lt;/p&gt;

&lt;/div&gt;
&lt;h2&gt;Input&lt;/h2&gt;
&lt;div class=&quot;content&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;第一行包含测试数据个数T（T&amp;lt;=10）。每组数据前两行为D的边数（即E的点数）m和E的边数k（0&amp;lt;=m&amp;lt;=300）。以下&lt;em&gt;k&lt;/em&gt;行每行两个整数x, y，表示E中有一条有向边x-&amp;gt;y。E中的点编号为0~m-1。&lt;/p&gt;

&lt;/div&gt;
&lt;h2&gt;Output&lt;/h2&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;

&lt;p&gt;对于每组数据输出一行。如果存在，输出Yes，否则输出No。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Sample Input&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;sampledata&quot;&gt;4&lt;br/&gt;2&lt;br/&gt;1&lt;br/&gt;0 1&lt;br/&gt;5&lt;br/&gt;0&lt;br/&gt;4&lt;br/&gt;3&lt;br/&gt;0 1&lt;br/&gt;2 1&lt;br/&gt;2 3&lt;br/&gt;3&lt;br/&gt;9&lt;br/&gt;0 1&lt;br/&gt;0 2&lt;br/&gt;1 2&lt;br/&gt;1 0&lt;br/&gt;2 0&lt;br/&gt;2 1&lt;br/&gt;0 0&lt;br/&gt;1 1&lt;br/&gt;2 2&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Sample Output&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;sampledata&quot;&gt;Yes&lt;br/&gt;Yes&lt;br/&gt;No&lt;br/&gt;Yes&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;65&quot;&gt;
&lt;p&gt; 题解：暴力搜索+剪枝；&lt;/p&gt;
&lt;h3&gt;整理一下判断条件：&lt;/h3&gt;
&lt;p&gt;1.这一行是否有重复的数&lt;/p&gt;
&lt;p&gt;2.这一列是否有重复的数&lt;/p&gt;
&lt;p&gt;3.这一个小九宫格中是否有重复的数&lt;/p&gt;
&lt;p&gt;4.是否符合大于小于的条件&lt;/p&gt;
&lt;p&gt;现在我分别用 &lt;em&gt;h[i][j] ,l[i][j] ,g[i][j] &lt;/em&gt;来表示第i行，第i列，第i个小九宫格中数字j是否重复。还有一个大于小于号的问题后面再说，让我们先来看一下读入。&lt;/p&gt;
&lt;p&gt;输入格式： 一共15行，包含一个新数独的实例。第奇数行包含左右方向的符号（&amp;lt;和&amp;gt;），第偶数行包含上下方向的符号（^和v）&lt;/p&gt;
&lt;p&gt;说是奇数行包含左右方向的符号，偶数行包含上下方向的符号，其实如果你仔细的看一下题目或者样例输入的话，应该不难发现输入格式的描述略有问题，有的行与输入描述是相反的。。。（如果已经改过来了就当我没说）&lt;/p&gt;
&lt;p&gt;其实可以这样看：输入是有15行的，你可以把这15行分成3组，每组5行，这样描述就对了，每一组的奇数行和偶数行按描述进行读入即可。&lt;/p&gt;
&lt;p&gt;读入符号之后，先看这个符号属于哪一个小九宫格（因为不同小九宫格的符号是不相关的），然后就要用到下面这个数组了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;f[i][x][y]&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;它表示第i个小九宫格中第x个数和第y个数是否有大小关系。&lt;br/&gt;读入的时候如果是&quot;&amp;gt;&quot;或者&quot;v&quot;就在相应的位置保存1，如果是&quot;&amp;lt;&quot;或&quot;^&quot;就保存2。&lt;/p&gt;
&lt;p&gt;那么这样一来符号的问题就不是问题了，在选数的时候多加一个循环判断一下这个数周围的大小关系是否合法不就行了？&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;参考代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int a[10][10],h[10][10],l[10][10],g[10][10],m,n,c,f[10][10][10]; 
void dfs(int x,int y)
{
    if(x==9&amp;amp;&amp;amp;y==10) 
    {
       for(int i=1;i&amp;lt;=9;++i) 
       {
                for(int j=1;j&amp;lt;=9;++j) printf(&quot;%d &quot;,a[i][j]);
                cout&amp;lt;&amp;lt;endl;
       }
       return;
    }   
    if(y==10) x=x+1,y=1;
    for(int i=1;i&amp;lt;=9;++i)
    {   
        bool bl=0;
        int g1=((x-1)/3)*3,g2=(y-1)/3,g3=g1+g2;  
        if(g[g3][i]==1||h[x][i]==1||l[y][i]==1) continue;
        for(int j=1;j&amp;lt;=9;++j)
        {
            int ii=(x-1)%3*3+(y-1)%3+1;  
            if(f[g3][ii][j]==1) 
            {
                int xj=g3/3*3+(j-1)/3+1,yj=g3%3*3+(j-1)%3+1;  
                if(a[xj][yj]!=0)
                if(i&amp;lt;a[xj][yj]) 
                                {
                    bl=1; 
                                        break;
                }
            }
            if(f[g3][ii][j]==2) 
            {
                int xj=g3/3*3+(j-1)/3+1,yj=g3%3*3+(j-1)%3+1;
                if(a[xj][yj]!=0)
                if(i&amp;gt;a[xj][yj])
                                {
                    bl=1; 
                                        break;
                } 
            }     
        }
        if(bl==1) continue;
        g[g3][i]=1;h[x][i]=1;l[y][i]=1;
        a[x][y]=i;   
        dfs(x,y+1); 
        a[x][y]=0;   
        g[g3][i]=0;h[x][i]=0;l[y][i]=0;  
    }

}
int main()
{
    int ci=0;
    char s;
    for(int i=1;i&amp;lt;=3;++i)
    {
        for(int k=1;k&amp;lt;=5;++k)  
        {
            if(k%2==1)
            {
                for(int j=1;j&amp;lt;=6;++j)
                {
                    int q1=(i-1)*3,q2=(j-1)/2,q3=q1+q2; 
                    cin&amp;gt;&amp;gt;s;
                    if(s=='&amp;gt;')  
                    {
                        int qq=(k-1)/2*3+(j-1)%2+1; 
                        f[q3][qq][qq+1]=1;    
                        f[q3][qq+1][qq]=2;
                    }
                    else
                    {
                        int qq=(k-1)/2*3+(j-1)%2+1;
                        f[q3][qq][qq+1]=2;
                        f[q3][qq+1][qq]=1;
                    }
                }   
            }
            else
            {
                for(int j=1;j&amp;lt;=9;++j)
                {
                    int q1=(i-1)*3,q2=(j-1)/3,q3=q1+q2;
                    cin&amp;gt;&amp;gt;s;
                    if(s=='v')  
                    {
                        int qq=(k-1)/2*3+(j-1)%3+1;
                        f[q3][qq][qq+3]=1;
                        f[q3][qq+3][qq]=2;
                    } 
                    else
                    {
                        int qq=(k-1)/2*3+(j-1)%3+1;
                        f[q3][qq][qq+3]=2;
                        f[q3][qq+3][qq]=1;
                    }
                }   
            }
        }
    }
    dfs(1,1);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 09 Nov 2018 15:46:00 +0000</pubDate>
<dc:creator>SongHL</dc:creator>
<og:description>Description 给一个n结点m条边的有向图D，可以这样构造图E：给D的每条边u-&gt;v，在E中建立一个点uv，然后对于D中的两条边u-&gt;v和v-&gt;w，在E中从uv向vw连一条有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songorz/p/9937744.html</dc:identifier>
</item>
<item>
<title>全景图转小行星视角投影原理详解 - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/9937729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/9937729.html</guid>
<description>&lt;p&gt;全景图是2:1比例的图片，一般是多张图像拼接而成。全景图2:1的比例可以很方便的映射到球面，而球坐标可以很方便的实现各种有趣的投影。比如小行星，水晶球，局部透视投影等。&lt;/p&gt;
&lt;p&gt;今天来说说怎么将全景图投影到小行星视图：&lt;/p&gt;

&lt;p&gt;首先，要有一副2:1的全景图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201811/1138496-20181109225520995-1642097544.jpg&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;风景秀丽是不是。&lt;/p&gt;
&lt;p&gt;然后，将全景图按照经纬展开法重新贴到球面，图像的宽就是纬度0-2π，图像的高就是经度0-π。&lt;/p&gt;
&lt;p&gt;接下来，需要一种下面这样的投影。将一个球面上的坐标投影到平面上。投影中心在球心到球面之间。&lt;/p&gt;
&lt;p&gt;从百度百科上盗的图，各位将就着看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201811/1138496-20181109230619668-770511698.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种投影方式中，下半球面会全部投影在平面图中的一个圆内，上半球面会全部投影到圆的外面，并且分布越来越稀疏。&lt;/p&gt;
&lt;p&gt;投影过程可以理解为：&lt;/p&gt;
&lt;p&gt;1. 首先建立球坐标系，将经纬度的全景图贴到球面上，这个过程我之前的一篇博客中鱼眼图转经纬图讲过，原理一样。只不过是逆过程。&lt;/p&gt;
&lt;p&gt;2. 设定投影中心点的坐标，然后连接投影中心点和球面上一点，得到一条直线。当然此时需要设置一个视场角FOV，即选择投影的视场角是多大。视场角越大，最后得到的小行星视图中间图像被挤压的越厉害。&lt;/p&gt;
&lt;p&gt;3. 建立投影平面，以上图为例，该投影平面与球面相切与南极点。计算该直线与该投影平面的交点，即可得到投影后的平面坐标。&lt;/p&gt;
&lt;p&gt;4. 上述三步均在球坐标系下完成，得到各个球面点的平面坐标后，根据具体想要得到的平面图像尺寸，将平面坐标转换为图像坐标。至此完成。&lt;/p&gt;
&lt;p&gt;上述是正向投影过程，如果采用反向投影，原理类似，不过倒过来从原全景图像素点取值即可。&lt;/p&gt;

&lt;p&gt;上述过程可以很方便用C++代码实现，读取图像的操作可以用OpenCV：&lt;/p&gt;
&lt;p&gt;投影后得到的小行星视图如下，FOV和投影中心位置都会影响小行星在图像中的大小：&lt;/p&gt;
&lt;p&gt;这个是投影点在北极点，FOV设置的120度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201811/1138496-20181109232608751-853445966.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;投影点在北极点，FOV=170度，则如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201811/1138496-20181109232857418-445849828.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;投影点在北极点与球心的中点，FOV=120度，则如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201811/1138496-20181109233026558-2003378149.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同样道理，如果投影点在南极点，投影平面放在北极，则如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201811/1138496-20181109233746492-1199179591.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同理，如果在球体内随意移动投影点，投影得到的效果也会不同，可以实现不同视角的小行星。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 15:40:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<og:description>全景图是2:1比例的图片，一般是多张图像拼接而成。全景图2:1的比例可以很方便的映射到球面，而球坐标可以很方便的实现各种有趣的投影。比如小行星，水晶球，局部透视投影等。 今天来说说怎么将全景图投影到小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/9937729.html</dc:identifier>
</item>
<item>
<title>flask基础之请求处理核心机制(五) - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/9917239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/9917239.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;总结一下flask框架的请求处理流程。&lt;/p&gt;
&lt;h2 id=&quot;系列文章&quot;&gt;系列文章&lt;/h2&gt;
&lt;h2 id=&quot;wsgi协议&quot;&gt;WSGI协议&lt;/h2&gt;
&lt;p&gt;一般来说http服务器和框架需要进行解耦，http专门负责接受HTTP请求、解析HTTP请求、发送HTTP，响应请求等；而web框架负责处理请求的逻辑，和数据库的交互等等，那么它们之间需要约定一套接口使得http服务器能够调用web框架的处理逻辑，这个协议就是WSGI协议。&lt;/p&gt;
&lt;p&gt;WSGI协议要求http服务器接收到http请求后经过处理得到两个参数，一个是请求数据封装的字典environ，另一个是需要框架回调的方法start_response。&lt;/p&gt;
&lt;p&gt;在flask框架中，服务器对每个请求调用一次app的wsgi_app方法返回结果，而wsgi_app方法的执行过程就是请求的处理流程。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Flask(object):
    def wsgi_app(self, environ, start_response):
        ctx = self.request_context(environ)
        ctx.push()
        error = None
        try:
            try:
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if self.should_ignore_error(error):
                error = None
            ctx.auto_pop(error)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第一步服务器启动&quot;&gt;第一步：服务器启动&lt;/h2&gt;
&lt;p&gt;服务器启动后，假设服务器是基于线程的，此时app对象被创建，加载了相关的初始化参数，这时代理对象如current_app、g、session、request等会被创建，但是它们目前并没有代理任何的对象，如果此时使用它们会报错，需要在第一次接收到请求后才会真正地代理上下文。那么服务器启动究竟干了什么事呢？&lt;/p&gt;
&lt;p&gt;详细请参考：&lt;a href=&quot;https://www.cnblogs.com/cwp-bg/p/9917203.html&quot;&gt;flask之app初始化&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;第二步接收请求创建上下文入栈&quot;&gt;第二步：接收请求，创建上下文，入栈&lt;/h2&gt;
&lt;p&gt;服务器收到一个http请求后，使用app上下文和请求数据创建一个线程，调用app的request_context(self, environ)方法，将解包后封装的http请求数据当做environ参数传入，返回一个RequestContext实例对象，每一个请求都有一个RequestContext实例对象，&lt;strong&gt;同时他们都拥有各自的app上下文，也就是说在本线程中的app应用是服务器初始化app的一个引，因此我们可以动态修改app的属性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将RequestContext对象push进_request_ctx_stack里面，_request_ctx_stack是一个栈对象，此时代理对象request指向栈顶的RequestContext对象的request属性，该request是一个Request对象，而session此时指向栈顶的RequestContext对象的session属性。&lt;/p&gt;
&lt;p&gt;判断_app_ctx_stack栈顶是否存在应用上下文对象AppContext，不存在就创建，同时将AppContext推送到_app_ctx_stack栈对象中，此时current_app指向栈顶AppContext对象的app属性，而g变量指向栈顶AppContext对象的g属性，本质上是一个_AppCtxGlobals对象，数据结构是一个字典。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用上下文和请求上下文存放的栈对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;_request_ctx_stack = LocalStack()
_app_ctx_stack = LocalStack()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;动态修改app的属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from flask import Flask

app = Flask(__name__)

@app.route('/test1')
def test1():
    &quot;&quot;&quot;
    动态添加一个视图函数
    &quot;&quot;&quot;
    @app.route('/test2')
    def test2():
        return 'test2'
    return 'OK'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;应用上下文和请求上下文源码分析&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class Flask(object):
    def app_context(self):
        return AppContext(self)
    def request_context(self, environ):
        return RequestContext(self, environ)

class AppContext(object):
    def __init__(self, app):
        self.app = app
        self.url_adapter = app.create_url_adapter(None)
        self.g = app.app_ctx_globals_class()
    def push(self):
        self._refcnt += 1
        if hasattr(sys, 'exc_clear'):
            sys.exc_clear()
        _app_ctx_stack.push(self) # 将自己推送到栈中
        appcontext_pushed.send(self.app)

class RequestContext(object):
    def __init__(self, app, environ, request=None):
        self.app = app
        if request is None:
            request = app.request_class(environ)
        self.request = request
        self.url_adapter = app.create_url_adapter(self.request)
        self.flashes = None
        self.session = None
    def push(self):
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第三步请求分派&quot;&gt;第三步：请求分派&lt;/h2&gt;
&lt;p&gt;分发请求并执行处理逻辑的函数为full_dispatch_request，其返回一个Response对象。处理的过程为：&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;先执行app对象before_first_request_funcs列表中的所有方法，这是针对app的第一次请求需要的预处理方法，执行该列表中的所有方法是一个原子操作，被加了线程锁，如果不是第一次请求就跳过；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后执行app对象的url_value_preprocessors字典中对应蓝图的列表中的所有方法，对所有的URL进行预处理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;执行app对象的before_request_funcs列表中的所有方法，其会按照加载的顺序链执行，并且如果中间有任何一个方法返回的结果不是None，那么执行中断，直接返回结果，不再执行视图函数。这是针对app所有的请求都会执行的方法，当然也可以通过蓝图来进行管理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过request对象的url_rule(Rule)找到app中的url_map中对应的视图函数执行，返回一个元组的结果rv，就是我们平时写视图函数时返回的元组；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用make_response函数，以返回的结果rv作为参数构建一个Response对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;执行app对象中的after_request_funcs列表的所有方法，以构建的Response对象作为参数，每个方法必须都返回Response类型的对象，最后调用session保存本次的状态信息；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第四步出栈&quot;&gt;第四步：出栈&lt;/h2&gt;
&lt;p&gt;先执行app对象的teardown_request_funcs列表中的所有的方法，其方法和after_request_funcs中的一样，只不过是在出栈前才触发，&lt;strong&gt;这意味着即使处理逻辑的部分出错，这里方法也会执行，&lt;/strong&gt;然后从_request_ctx_stack中弹出RequestContext请求上下文，然后执行app对象中的teardown_appcontext_funcs列表的所有方法，最后从_app_ctx_stack中弹出AppContext应用上下文。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class AppContext:
    def pop(self, exc=_sentinel):
        app_ctx = self._implicit_app_ctx_stack.pop() 

        try:
            clear_request = False
            if not self._implicit_app_ctx_stack:
                self.preserved = False
                self._preserved_exc = None
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_request(exc) # 调用请求钩子
                if hasattr(sys, 'exc_clear'):
                    sys.exc_clear()

                request_close = getattr(self.request, 'close', None)
                if request_close is not None:
                    request_close()
                clear_request = True
        finally:
            rv = _request_ctx_stack.pop() # 弹出请求上下文
            if clear_request:
                rv.request.environ['werkzeug.request'] = None
            if app_ctx is not None:
                app_ctx.pop(exc) # 弹出应用上下文&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;flask请求处理最简代码模型&quot;&gt;flask请求处理最简代码模型&lt;/h2&gt;
&lt;p&gt;假设服务器使用的是多进程模式。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process, Pool
class Flask(object):
    def __call__(self, environ, start_response):
        &quot;&quot;&quot;定义app对请求的处理过程&quot;&quot;&quot;
        pass

def listen_port():
    &quot;&quot;&quot;假设这是端口监听并解析http请求的方法&quot;&quot;&quot;
    pass

def run_web():
    &quot;&quot;&quot;假设这是程序主循环&quot;&quot;&quot;
    app = Flask() # 创建一个app，这是app初始化做的
    pool = Pool(10)
    while True:
        # 获取一个http请求的数据
        environ, start_response = listen_port()
        # 调用app处理请求
        pool.apply_async(app, args=(environ, start_response))

if __name__ == '__main__':
    run_web()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;无论是gunicorn服务器还是uwsgi服务器，其启动后加载了app对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当收到http请求后，按照http协议解析数据，将数据打包成一个字典，将其和响应函数一起作为参数调用app对象的wsgi_app方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;wsgi_app方法按照接收请求，创建上下文，入栈，请求分发，出栈的步骤处理完业务逻辑返回响应数据；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Fri, 09 Nov 2018 15:37:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<og:description>前言 总结一下flask框架的请求处理流程。 系列文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/9917239.html</dc:identifier>
</item>
<item>
<title>总结：JavaScript异步、事件循环与消息队列、微任务与宏任务 - _Zavier</title>
<link>http://www.cnblogs.com/ZavierTang/p/ZavierTang.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZavierTang/p/ZavierTang.html</guid>
<description>&lt;blockquote readability=&quot;5.9253112033195&quot;&gt;
&lt;p&gt;本人正在努力学习前端，内容仅供参考。由于各种原因（不喜欢博客园的UI），大家可以移步我的github阅读体验更佳：&lt;a href=&quot;https://github.com/ZavierTang/zavier-notes/blob/master/JavaScript/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.md&quot;&gt;传送门&lt;/a&gt;，喜欢就点个star咯，或者我的博客：&lt;a href=&quot;https://blog.tangzhengwei.me/&quot; class=&quot;uri&quot;&gt;https://blog.tangzhengwei.me&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;3&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/5b0a64d8f265da0dc82324da&quot;&gt;传送门&lt;/a&gt;，segmentfault：&lt;a href=&quot;https://segmentfault.com/blog/zaviertang&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Philip Roberts&lt;/em&gt; 在演讲 &lt;a href=&quot;https://www.youtube.com/watch?v=8aGhZQkoFbQ&quot;&gt;great talk at JSConf on the event loop&lt;/a&gt; 中说：要是用一句话来形容 JavaScript，我可能会这样：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“JavaScript 是单线程、异步、非阻塞、解释型脚本语言。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;单线程 ?&lt;/li&gt;
&lt;li&gt;异步 ? ?&lt;/li&gt;
&lt;li&gt;非阻塞 ? ? ?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后，这又牵扯到了事件循环、消息队列，还有微任务、宏任务这些。&lt;/p&gt;
&lt;p&gt;作为一个初学者，对这些了解甚少。&lt;/p&gt;
&lt;p&gt;这几天翻阅了不少资料，似乎了解到了一二，是时候总结一下了，它们困扰了我好一段时间，就像学高数那会儿自己去理解一个概念一样。&lt;/p&gt;
&lt;h2 id=&quot;单线程与多线程&quot;&gt;单线程与多线程&lt;/h2&gt;
&lt;p&gt;单线程语言：JavaScript 的设计就是为了处理浏览器网页的交互（DOM操作的处理、UI动画等），决定了它是一门单线程语言。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果有多个线程，它们同时在操作 DOM，那网页将会一团糟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript 是单线程的，那么处理任务是一件接着一件处理，从上往下顺序执行：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('script start')
console.log('do something...')
console.log('script end')

// script start
// do something...
// script end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码会依次打印: &quot;script start&quot; &amp;gt;&amp;gt; &quot;do something...&quot; &amp;gt;&amp;gt; &quot;script end&quot;&lt;/p&gt;
&lt;p&gt;那如果一个任务的处理耗时（或者是等待）很久的话，如：网络请求、定时器、等待鼠标点击等，后面的任务也就会被阻塞，也就是说会阻塞所有的用户交互（按钮、滚动条等），会带来极不友好的体验。&lt;/p&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('script start')

console.log('do something...')

setTimeout(() =&amp;gt; {
  console.log('timer over')
}, 1000)

// 点击页面
console.log('click page')

console.log('script end')

// script start
// do something...
// click page
// script end
// timer over&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&quot;timer over&quot;&lt;/code&gt; 在 &lt;code&gt;&quot;script end&quot;&lt;/code&gt; 后再打印，也就是说计时器并没有阻塞后面的代码。那，发生了什么？&lt;/p&gt;
&lt;p&gt;其实，JavaScript 单线程指的是浏览器中负责解释和执行 JavaScript 代码的只有一个线程，即为&lt;strong&gt;JS引擎线程&lt;/strong&gt;，但是浏览器的渲染进程是提供多个线程的，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JS引擎线程&lt;/li&gt;
&lt;li&gt;事件触发线程&lt;/li&gt;
&lt;li&gt;定时触发器线程&lt;/li&gt;
&lt;li&gt;异步http请求线程&lt;/li&gt;
&lt;li&gt;GUI渲染线程&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;4.0909090909091&quot;&gt;
&lt;p&gt;浏览器渲染进程参考&lt;a href=&quot;https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-6&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当遇到计时器、DOM事件监听或者是网络请求的任务时，JS引擎会将它们直接交给 webapi，也就是浏览器提供的相应线程（如定时器线程为setTimeout计时、异步http请求线程处理网络请求）去处理，而JS引擎线程继续后面的其他任务，这样便实现了 &lt;strong&gt;异步非阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;定时器触发线程也只是为 &lt;code&gt;setTimeout(..., 1000)&lt;/code&gt; 定时而已，时间一到，还会把它对应的回调函数(callback)交给 &lt;strong&gt;消息队列&lt;/strong&gt; 去维护，JS引擎线程会在适当的时候去消息队列取出消息并执行。&lt;/p&gt;
&lt;p&gt;JS引擎线程什么时候去处理呢？消息队列又是什么？&lt;/p&gt;
&lt;p&gt;这里，JavaScript 通过 &lt;strong&gt;事件循环&lt;/strong&gt; &lt;strong&gt;event loop&lt;/strong&gt; 的机制来解决这个问题。&lt;/p&gt;
&lt;p&gt;这个放在后面再讨论吧！&lt;/p&gt;
&lt;h2 id=&quot;同步与异步&quot;&gt;同步与异步&lt;/h2&gt;
&lt;p&gt;上面说到了异步，JavaScript 中有同步代码与异步代码。&lt;/p&gt;
&lt;p&gt;下面便是同步：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('hello 0')

console.log('hello 1')

console.log('hello 2')

// hello 0
// hello 1
// hello 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们会依次执行，执行完了后便会返回结果（打印结果）。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;setTimeout(() =&amp;gt; {
  console.log('hello 0')
}, 1000)

console.log('hello 1')

// hello 1
// hello 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的 &lt;code&gt;setTimeout&lt;/code&gt; 函数便不会立刻返回结果，而是发起了一个异步，setTimeout 便是异步的发起函数或者是注册函数，() =&amp;gt; {...} 便是异步的回调函数。&lt;/p&gt;
&lt;p&gt;这里，JS引擎线程只会关心异步的发起函数是谁、回调函数是什么？并将异步交给 webapi 去处理，然后继续执行其他任务。&lt;/p&gt;
&lt;p&gt;异步一般是以下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络请求&lt;/li&gt;
&lt;li&gt;计时器&lt;/li&gt;
&lt;li&gt;DOM时间监听&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事件循环与消息队列&quot;&gt;事件循环与消息队列&lt;/h2&gt;
&lt;p&gt;回到事件循环 event loop&lt;/p&gt;
&lt;p&gt;其实 &lt;strong&gt;事件循环&lt;/strong&gt; 机制和 &lt;strong&gt;消息队列&lt;/strong&gt; 的维护是由事件触发线程控制的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件触发线程&lt;/strong&gt; 同样是浏览器渲染引擎提供的，它会维护一个 &lt;strong&gt;消息队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等...），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 &lt;strong&gt;事件触发线程&lt;/strong&gt; 将异步对应的 &lt;strong&gt;回调函数&lt;/strong&gt; 加入到消息队列中，消息队列中的回调函数等待被执行。&lt;/p&gt;
&lt;p&gt;同时，JS引擎线程会维护一个 &lt;strong&gt;执行栈&lt;/strong&gt;，同步代码会依次加入执行栈然后执行，结束会退出执行栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/ZavierTang/static/images/stack.png&quot; alt=&quot;Stack&amp;amp;Queue&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从消息队列取出一个任务（即异步的回调函数）放入执行栈中执行。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;消息队列是类似队列的数据结构，遵循先入先出(FIFO)的规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行完了后，执行栈再次为空，事件触发线程会重复上一步操作，再取出一个消息队列中的任务，这种机制就被称为事件循环（event loop）机制。&lt;/p&gt;
&lt;p&gt;还是上面的代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('script start')

setTimeout(() =&amp;gt; {
  console.log('timer over')
}, 1000)

// 点击页面
console.log('click page')

console.log('script end')

// script start
// click page
// script end
// timer over&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行过程：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li&gt;主代码块（script）依次加入执行栈，依次执行，主代码块为：
&lt;ul&gt;&lt;li&gt;console.log('script start')&lt;/li&gt;
&lt;li&gt;setTimeout()&lt;/li&gt;
&lt;li&gt;console.log('click page')&lt;/li&gt;
&lt;li&gt;console.log('script end')&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;console.log() 为同步代码，JS引擎线程处理，打印 &quot;script start&quot;，出栈；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;遇到异步函数 &lt;code&gt;setTimeout&lt;/code&gt;，交给定时器触发线程（异步触发函数为：&lt;code&gt;setTimeout&lt;/code&gt;，回调函数为：&lt;code&gt;() =&amp;gt; { ... }&lt;/code&gt;），JS引擎线程继续，出栈；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;console.log() 为同步代码，JS引擎线程处理，打印 &quot;click page&quot;，出栈；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;console.log() 为同步代码，JS引擎线程处理，打印 &quot;script end&quot;，出栈；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行栈为空，也就是JS引擎线程空闲，这时从消息队列中取出（如果有的话）一条任务（callback）加入执行栈，并执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复第6步。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;（此步的位置不确定）某个时刻（1000ms后），定时器触发线程通知事件触发线程，事件触发线程将回调函数 &lt;code&gt;() =&amp;gt; { ... }&lt;/code&gt; 加入消息队列队尾，等待JS引擎线程执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看出，setTimeout异步函数对应的回调函数( &lt;code&gt;() =&amp;gt; {}&lt;/code&gt; )会在执行栈为空，主代码块执行完了后才会执行。&lt;/p&gt;
&lt;p&gt;零延时：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('script start')

setTimeout(() =&amp;gt; {
  console.log('timer 1 over')
}, 1000)

setTimeout(() =&amp;gt; {
  console.log('timer 2 over')
}, 0)

console.log('script end')

// script start
// script end
// timer 2 over
// timer 1 over&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会先打印 &quot;timer 2 over&quot;，然后打印 &quot;timer 1 over&quot;，尽管 timer 1 先被定时器触发线程处理，但是 timer 2 的callback会先加入消息队列。&lt;/p&gt;
&lt;p&gt;上面，timer 2 的延时为 0ms，HTML5标准规定 setTimeout 第二个参数不得小于4（不同浏览器最小值会不一样），不足会自动增加，所以 &quot;timer 2 over&quot; 还是会在 &quot;script end&quot; 之后。&lt;/p&gt;
&lt;p&gt;就算延时为 0ms，只是 timer 2 的回调函数会立即加入消息队列而已，回调的执行还是得等执行栈为空（JS引擎线程空闲）时执行。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;其实 setTimeout 的第二个参数并不能代表回调执行的准确的延时事件，它只能表示回调执行的最小延时时间，因为回调函数进入消息队列后需要等待执行栈中的同步任务执行完成，执行栈为空时才会被执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;宏任务与微任务&quot;&gt;宏任务与微任务&lt;/h2&gt;
&lt;p&gt;以上机制在ES5的情况下够用了，但是ES6会有一些问题。&lt;/p&gt;
&lt;p&gt;Promise同样是用来处理异步的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log('script start')

setTimeout(function() {
    console.log('timer over')
}, 0)

Promise.resolve().then(function() {
    console.log('promise1')
}).then(function() {
    console.log('promise2')
})

console.log('script end')

// script start
// script end
// promise1
// promise2
// timer over&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WTF?? &quot;promise 1&quot; &quot;promise 2&quot; 在 &quot;timer over&quot; 之前打印了？&lt;/p&gt;
&lt;p&gt;这里有一个新概念：&lt;code&gt;macrotask&lt;/code&gt;（宏任务） 和 &lt;code&gt;microtask&lt;/code&gt;（微任务）。&lt;/p&gt;
&lt;p&gt;所有任务分为 &lt;code&gt;macrotask&lt;/code&gt; 和 &lt;code&gt;microtask&lt;/code&gt;:&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;macrotask：主代码块、setTimeout、setInterval等（可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;microtask：Promise、process.nextTick等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JS引擎线程首先执行主代码块。&lt;/p&gt;
&lt;p&gt;每次执行栈执行的代码就是一个宏任务，包括任务队列(宏任务队列)中的，因为执行栈中的宏任务执行完会去取任务队列（宏任务队列）中的任务加入执行栈中，即同样是事件循环的机制。&lt;/p&gt;
&lt;p&gt;在执行宏任务时遇到Promise等，会创建微任务（.then()里面的回调），并加入到微任务队列队尾。&lt;/p&gt;
&lt;p&gt;microtask必然是在某个宏任务执行的时候创建的，而在下一个宏任务开始之前，浏览器会对页面重新渲染(&lt;code&gt;task&lt;/code&gt; &amp;gt;&amp;gt; &lt;code&gt;渲染&lt;/code&gt; &amp;gt;&amp;gt; &lt;code&gt;下一个task&lt;/code&gt;(从任务队列中取一个))。同时，在上一个宏任务执行完成后，渲染页面之前，会执行当前微任务队列中的所有微任务。&lt;/p&gt;
&lt;p&gt;也就是说，在某一个macrotask执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。&lt;/p&gt;
&lt;p&gt;这样就可以解释 &quot;promise 1&quot; &quot;promise 2&quot; 在 &quot;timer over&quot; 之前打印了。&quot;promise 1&quot; &quot;promise 2&quot; 做为微任务加入到微任务队列中，而 &quot;timer over&quot; 做为宏任务加入到宏任务队列中，它们同时在等待被执行，但是微任务队列中的所有微任务都会在开始下一个宏任务之前都被执行完。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在node环境下，process.nextTick的优先级高于Promise，也就是说：在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行机制：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行一个宏任务（栈中没有就从事件队列中获取）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行过程中如果遇到微任务，就将它添加到微任务的任务队列中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所有说是单线程），即JS引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;异步一般是指：
&lt;ul&gt;&lt;li&gt;网络请求&lt;/li&gt;
&lt;li&gt;计时器&lt;/li&gt;
&lt;li&gt;DOM事件监听&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事件循环机制：
&lt;ul&gt;&lt;li&gt;JS引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。&lt;/li&gt;
&lt;li&gt;JS引擎线程遇到异步函数，会将异步函数交给相应的Webapi，而继续执行后面的任务。&lt;/li&gt;
&lt;li&gt;Webapi会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。&lt;/li&gt;
&lt;li&gt;执行栈为空时，JS引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。&lt;/li&gt;
&lt;li&gt;完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ZavierTang/zavier-notes/blob/master/JavaScript/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.md&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 15:20:00 +0000</pubDate>
<dc:creator>_Zavier</dc:creator>
<og:description>关于JavaScript异步、事件循环与消息队、微任务与宏任务的总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZavierTang/p/ZavierTang.html</dc:identifier>
</item>
<item>
<title>python-函数基础 - 程序灬波</title>
<link>http://www.cnblogs.com/chengxubo/p/9937607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxubo/p/9937607.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;函数简介&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;函数使用&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;定义函数格式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; 函数名([参数列表]):
    函数体&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;[]表示可选，参数可以有，也可以没有，也可以是多个。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;函数名：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;函数调用：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;函数分类(参数与返回值)&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无参无返回值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_hello():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello world!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print_hello()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 带参数无返回值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_n_hello(n):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n):
         &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello world!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
   
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print_n_hello(5)&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 带参有返回值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(m, n):
    c &lt;/span&gt;= m +&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用return返回需要返回的值，不返回默认为None&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; c   
​
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(3, 5))
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;分类的标准是按照有无参数，以及有无返回值。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;函数参数&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;形参：形式参数，就是写在函数定义出的参数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;实参：实际参数，就是在函数调用时传递的参数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;位置参数：也叫必传参数，没有默认值的参数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;默认参数：定义时有默认值，调用时可以不传，必须写在最后&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关键字参数：在函数调用时指定参数名字，参数的位置就无所谓。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;6.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可变长度参数：函数调用时可以传递比定义处更多的参数，多出来的参数会保存在args和kwargs中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; var_len_args(a, b, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;goudan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, *args, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是一个元组，保存多传的位置参数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是一个字典，保存多传的关键字参数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
​
var_len_args(&lt;/span&gt;1, 2, 3, 4, age=10)
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;3&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;*的使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(a, b):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b)
​
lt &lt;/span&gt;= [1, 2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要从列表根据下表获取元素，然后作为参数传递&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; show(lt[0], lt[1])&lt;/span&gt;
show(*&lt;span&gt;lt)
​
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; show2(aa=11, bb=22&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(aa, bb)
   
d &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 123, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 456&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; show2(aa=d['aa'], bb=d['bb'])&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 上下等价&lt;/span&gt;
show2(**d)
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;函数进阶&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;函数的定义位置是随意的？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;函数的名字可以相同吗？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;函数内容能否再定义函数？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;变量的作用域&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;块级作用域&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; True:
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ergou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 能够在块的外部使用，说明没有块级作用域&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(name)
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;局部作用域&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test():
    a &lt;/span&gt;= 10&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不能再函数外部使用，此处会报错&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;全局作用域&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
num = 10&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 声明使用的时外部的同名变量&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt;&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只能使用，不能修改，若想修改协议进行全局声明&lt;/span&gt;
    num = 20
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(num)
​
show()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(num)
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;函数内部可以使用外部变量，但是不能修改&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;若修改需要使用&lt;span&gt;&lt;code&gt;global&lt;/code&gt;&lt;span&gt;进行全局声明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当函数内部与外部出现同名变量，默认使用的时内部变量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;nonlocal使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wai():
    n &lt;/span&gt;= 10
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; nei():
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 声明使用非本地变量，外部函数的局部变量&lt;/span&gt;
&lt;span&gt;        nonlocal n
        n &lt;/span&gt;= 20
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
    nei()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
​
wai()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;递归函数(了解)&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;常用函数&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;内置函数(无需导入)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;：打印，输出
input：输入
abs：求绝对值
type：获取变量的类型
chr：将ASCII数值转换为字符
ord：将字符转换为对应的ASCII
id：获取变量地址
len：统计元素个数
range：产生连续整数的可迭代对象
enumerate：枚举可迭代对象
​
强制类型转换：
int
float
str
list
tuple
set
dict
​
max：求多个参数的最大值，或可迭代对象中的最大元素
min：最小值
sum：求和，可迭代对象元素求和
pow：求幂，pow(&lt;/span&gt;2, 3)等价于2 ** 3&lt;span&gt;
round：四舍五入，可以指定保留位数
​
hex：16进制
oct：8进制
bin：2进制&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;3.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;模块函数(需要导入)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;time：
    sleep：休眠指定的秒数，可以是小数
math：
    e：自然对数
    pi：圆周率
    ceil：向上取整
    floor：向下取整
    sqrt：开方(请平方根)
    degrees：弧度转换为度
    radians：度转换为弧度
sys：
    argv：运行程序时所有的命令行参数列表，第一个是程序文件名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;&lt;br/&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;    练习：完成一个计算器，支持加、减、乘、除运算&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;练习：&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;前面练习全部以函数形式进行封装&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;终端计算器&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;删除列表中的重复元素&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;统计一个字符串中字母、数字及其他字符的个数，返回一个元组即可&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;返回一个列表中第二大的数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;完整列表的排序函数(sort)，支持逆序&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-0.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;号码归属地查询：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;5582|1860101|010|北京市|北京联通GSM卡
5583|1860100|010|北京市|北京联通GSM卡
5584|1368141|010|北京市|北京移动神州行卡
5585|1860111|010|北京市|北京联通GSM卡
5586|1358198|010|北京市|北京移动动感地带卡
5587|1361139|010|北京市|北京移动预付费卡
5588|1361138|010|北京市|北京移动神州行卡
5591|1360110|010|北京市|北京移动全球通卡
5748|1364110|010|北京市|北京移动神州行卡
10186|1581584|020|广东省广州市|广东移动全球通卡
15046|1391897|021|上海市|上海移动全球通卡
17250|1502207|022|天津市|天津移动全球通卡
21137|1345272|023|重庆市万州|重庆移动大众卡
22700|1347812|024|辽宁省沈阳市|辽宁移动大众卡
24256|1377065|025|江苏省南京市|江苏移动全球通卡
26360|1898606|027|湖北省武汉市|湖北电信CDMA卡
28709|1860802|028|四川省成都市|四川联通GSM卡
30641|1552961|029|陕西省西安市|陕西联通GSM卡
31700|1563007|0310|河北省邯郸市|河北联通GSM卡
33360|1583396|0311|河北省石家庄市|河北移动全球通卡
34825|1508122|0312|河北省保定市|河北移动全球通卡
35363|1551235|0313|河北省张家口|河北联通GSM卡
37700|1331326|0316|河北省廊坊市|河北电信CDMA卡
43500|1350358|0358|山西省吕梁市|山西移动全球通卡
43908|1553625|0359|山西省运城市|山西联通GSM卡
44521|1335360|0370|河南省商丘市|河南电信CDMA卡
50078|1509369|0378|河南省开封市|河南移动全球通卡
53603|1583981|0398|河南省三门峡|河南移动全球通卡
53916|1335897|0410|辽宁省铁岭市|辽宁电信CDMA卡
55248|1554254|0411|辽宁省大连市|辽宁联通GSM卡
58618|1374272|0427|辽宁省盘锦市|辽宁移动全球通卡
58932|1554183|0429|辽宁省葫芦岛|辽宁联通GSM卡
60268|1340475|0431|吉林省长春市|吉林移动大众卡&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
​&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 09 Nov 2018 14:58:00 +0000</pubDate>
<dc:creator>程序灬波</dc:creator>
<og:description>函数基础 函数简介 定义：就是具有特定功能的一段代码 优点： 解决代码的重复书写 可以将功能的实现着和使用者分开，提高开发效率 分类： 库函数：print、input、abs等 自定义：用户自己封装的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxubo/p/9937607.html</dc:identifier>
</item>
<item>
<title>Windows下使用Rtools编译R语言包 - 静若清池</title>
<link>http://www.cnblogs.com/liugh/p/9937489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liugh/p/9937489.html</guid>
<description>&lt;p&gt;    使用devtools安装github中的R源代码时，经常会出各种错误，索性搜了一下怎么在Windows下直接打包，网上的资料也是参差不齐，以下是自己验证通过的。&lt;/p&gt;
&lt;p&gt;一、下载Rtools&lt;/p&gt;
&lt;p&gt;   下载地址：&lt;a href=&quot;https://cran.r-project.org/bin/windows/Rtools/&quot; target=&quot;_blank&quot;&gt;https://cran.r-project.org/bin/windows/Rtools/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109213004905-633481977.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;246&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     根据自己安装的R版本，下载兼容的Rtools即可，我下载的是&lt;span&gt;Rtools35.exe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二、安装Rtools&lt;/p&gt;
&lt;p&gt;     Windows下的安装都是傻瓜式的，一步步点确定即可，有两个地方需要注意：&lt;/p&gt;
&lt;p&gt;    2.1 安装路径&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109213321354-30827021.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    第一次安装的时候，没有使用这个默认路径（C:\Rtools），选择了其他的路径，结果在后面安装R包时，报找不到&quot;c:/Rtools/mingw_32/bin/g++&quot;的异常。&lt;/p&gt;
&lt;p&gt;    卸载Rtools后，重新安装时，就用这个默认路径了，后面就OK了。&lt;/p&gt;
&lt;p&gt;   2.2 设置环境变量&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109213753146-1676594695.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    选中上面的“Add rtools to system PATH”，就省了自己在Windows中设置环境变量了。 &lt;/p&gt;
&lt;p&gt;三、编译R语言代码&lt;/p&gt;
&lt;p&gt;    以编译Twitter的&lt;span&gt;BreakoutDetection&lt;/span&gt;为例（https://github.com/twitter/BreakoutDetection），将源代码下载到本地，放到R语言SDK的bin目录下（也可以放到其他目录，只是使用命令时加上路径即可）：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109215256111-1866432537.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    通过cmd命令，切换到上述目录，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Rcmd build BreakoutDetection-1.0.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    输出信息为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;* checking for file 'BreakoutDetection-1.0.1/DESCRIPTION' ... OK
* preparing 'BreakoutDetection':
* checking DESCRIPTION meta-information ... OK
* cleaning src
* checking for LF line-endings in source and make files and shell scripts
* checking for empty or unneeded directories
* looking to see if a 'data/datalist' file should be added
&lt;/span&gt;* building &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BreakoutDetection_1.0.1.tar.gz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   会发现在本地生成了一个&lt;span&gt;BreakoutDetection_1.0.1.tar.gz，这就是我们要安装的包，但不是传说中的zip包，是典型的Linux下的.tar.gz包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;四、安装R语言代码包&lt;/p&gt;
&lt;p&gt;    打开R语言SDK的RGui，选择“Packages”--&amp;gt;&quot;Install package(s) from local files&quot;，如下所示：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109220052663-37025031.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  浏览选择前一步骤生成的包（BreakoutDetection_1.0.1.tar.gz），如下所示：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109220341536-1197156458.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;463&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    安装完后，会在library下发现安装好的包，通过library(BreakoutDetection)命令，即可使用该包中的功能了。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109220658452-219159648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五、Rcmd的一些命令参数&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201811/380081-20181109221325717-2033147693.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 14:17:00 +0000</pubDate>
<dc:creator>静若清池</dc:creator>
<og:description>使用devtools安装github中的R源代码时，经常会出各种错误，索性搜了一下怎么在Windows下直接打包，网上的资料也是参差不齐，以下是自己验证通过的。 一、下载Rtools 下载地址：htt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liugh/p/9937489.html</dc:identifier>
</item>
<item>
<title>Python小白学习之路（十六）—【内置函数一】 - 小伙郭</title>
<link>http://www.cnblogs.com/guoruxin/p/9937491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoruxin/p/9937491.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517322/201811/1517322-20181109215724412-1428771634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将68个内置函数按照其功能分为了10类，分别是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数学运算（7个）
&lt;ul&gt;&lt;li&gt;abs()　　  divmod()  　　max() 　　 min()  　　pow()  　　round() 　　 sum()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类型转换（24个）
&lt;ul&gt;&lt;li&gt;bool() 　　 int()  　　float()  　　complex() 　　 str()  　　bytearray()&lt;/li&gt;
&lt;li&gt;bytes()　　 memoryview()　　 ord() 　　chr() 　　bin()　　 oct() 　　hex()&lt;/li&gt;
&lt;li&gt;tuple() 　　list() 　　dict()　　 set()　　 frozenset(　　) enumerate()&lt;/li&gt;
&lt;li&gt;range() 　　iter() 　　slice() 　　supper() 　　object()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;序列操作（8个）
&lt;ul&gt;&lt;li&gt;all()    　　any()　　 filter() 　　map() 　　next() 　　reversed()　　 sorted()　　 zip()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象操作（7个）
&lt;ul&gt;&lt;li&gt;help() dir() id() hash() type() len() ascii() format() vars()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;反射操作（8个）
&lt;ul&gt;&lt;li&gt;_import__() isinstance() issubclass() hasattr() getattr() setattr() delattr() callable()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;变量操作（2个）
&lt;ul&gt;&lt;li&gt;globals() locals()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;交互操作（2个）
&lt;ul&gt;&lt;li&gt;print() input()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;文件操作（1个）
&lt;/li&gt;
&lt;li&gt;编译执行（4个）
&lt;ul&gt;&lt;li&gt;compile() eval() exec() repr()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;装饰器（3个）
&lt;ul&gt;&lt;li&gt;property() classmethod() staticmethod()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;abs()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Return the absolute value of the argument.取绝对值&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(abs(-1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
1
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;divmod()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;divmod(x, y) -&amp;gt; Return the tuple (x//y, x%y).返回商和余数&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(divmod(5, 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
(2, 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;max()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;返回最大值&lt;/li&gt;
&lt;li&gt;处理的对象为可迭代对象&lt;/li&gt;
&lt;li&gt;(相当于一个for循环取出每一个元素进行比较)&lt;/li&gt;
&lt;li&gt;不同类型之间是不能进行比较的&lt;/li&gt;
&lt;li&gt;每个元素进行比较时，是从每个元素的第一个位置开始依次比较&lt;/li&gt;
&lt;li&gt;(如果一个位置分出大小，后面的位置可以不用进行比较便可以得出比较结果)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用法一：&lt;/span&gt;
num_1 = [1,38,2,0,4,7&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(max(num_1))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用法二：传入对象为字典，默认比较的是字典的key&lt;/span&gt;
age_dic={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:14, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:45, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:18&lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(max(age_dic)) 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(max(age_dic.values())) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较的是字典的values&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;age4
&lt;/span&gt;45
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法三：&lt;br/&gt;任务：&lt;br/&gt;将给定名单中年龄最大的找出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
people_list =&lt;span&gt; [
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xhg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:18&lt;span&gt;},
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:10&lt;span&gt;},
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:30&lt;span&gt;},
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:14&lt;span&gt;},
]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(max(people_list, key = &lt;span&gt;lambda&lt;/span&gt; dic:dic[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 30}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
#程序分析
#这段代码的理解 max(people_list, key = lambda dic:dic['age']，实际上进行了这样一个操作
ret = []
for item in people_list:
ret.append(item['age'])
print(max(ret))
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;min()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;返回可迭代对象的元素中的最小值或者所有参数的最小值&lt;/li&gt;
&lt;li&gt;具体用法同max()函数&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;br/&gt;pow()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Equivalent to x**y (with two arguments) or x**y % z (with three arguments)&lt;/li&gt;
&lt;li&gt;两个参数，做幂运算&lt;/li&gt;
&lt;li&gt;三个参数，先做幂运算，再取余&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(pow(2,3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
8
&lt;span&gt;print&lt;/span&gt;(pow(2,3,3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
2
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;round()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对浮点数进行四舍五入求值&lt;/li&gt;
&lt;li&gt;第二个参数为可选参数，如果不填默认取整，参数代表保留的位数&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(round(3.1415926&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(round(3.1415926, 3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
3
3.142
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;sum()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;对可迭代对象中的每个元素求和&lt;/li&gt;
&lt;li&gt;可迭代对象中的元素类型是数值&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(sum([1, 2, 3, 4, 5&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
15
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;bool() &lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数的逻辑值创建一个新的布尔值&lt;/li&gt;
&lt;li&gt;None '' () {} [] 0 ==&amp;gt;False&lt;/li&gt;
&lt;li&gt;其余 ==&amp;gt;True&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(bool(None))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(bool(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xhg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;False
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;int()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个整数&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(int(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将字符串转化为整形&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(int(123.9)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取整&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
123
123
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;float()&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;根据传入的参数创建一个新的浮点数

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(float(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123.78&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将字符串转化为浮点型&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(float(123))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将整形转换成浮点型&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
123.78
123.0
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;complex()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入参数创建一个新的复数&lt;/li&gt;
&lt;li&gt;有两个参数：&lt;/li&gt;
&lt;li&gt;第一个参数是实部；第二个参数是虚部&lt;/li&gt;
&lt;li&gt;不填参数，默认输出为 0j&lt;/li&gt;
&lt;li&gt;只填一个参数 a，则输出 a + 0j&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(complex())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(complex(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(complex(1, 2&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;0j
(&lt;/span&gt;1+&lt;span&gt;0j)
(&lt;/span&gt;1+2j)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;str()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;将目标参数转化为字符串&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(str(123&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(str(123&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(str([1, 2, 3, 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xhg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(str([1, 2, 3, 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xhg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
123
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
[&lt;/span&gt;1, 2, 3, 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xhg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;bytearray()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的字节数组&lt;/li&gt;
&lt;li&gt;可传入的参数：
&lt;ul&gt;&lt;li&gt;字符串（使用指定编码方式编码）;bytearray()然后使用str.encode()将字符串转换为字节。&lt;/li&gt;
&lt;li&gt;如果它是一个整数，那么数组将具有这个大小，并将用null字节初始化。&lt;/li&gt;
&lt;li&gt;如果它是符合缓冲区接口的对象，则将使用对象的只读缓冲区来初始化字节数组。&lt;/li&gt;
&lt;li&gt;如果它是可迭代的，那么它必须是range 0 &amp;lt; = x &amp;lt; 256的整数的迭代，它被用作数组的初始内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
a = bytearray(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小伙郭&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf -8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字符串需要指定编码方式&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, len(a))
b &lt;/span&gt;= bytearray(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小伙郭&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b, len(b))
c &lt;/span&gt;= bytearray([1,2,3,255]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果元素大于255，将会报错&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c, len(c))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
bytearray(b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xe5\xb0\x8f\xe4\xbc\x99\xe9\x83\xad&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 9&lt;span&gt;
bytearray(b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xd0\xa1\xbb\xef\xb9\xf9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 6&lt;span&gt;
bytearray(b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\x01\x02\x03\xff&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 4
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;bytes()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的不可变字节数组&lt;/li&gt;
&lt;li&gt;具体用法及传入的参数同函数bytearray()&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;ord()&lt;/h2&gt;
&lt;h2&gt;chr()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;返回Unicode字符对应的整数&lt;/li&gt;
&lt;li&gt;返回整数所对应的Unicode字符&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(chr(100&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
100&lt;span&gt;
d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;bin()整数--&amp;gt;2进制字符串&lt;br/&gt;oct()整数--&amp;gt;8进制数字符串&lt;br/&gt;hex()整数--&amp;gt;16进制字符串&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(bin(5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(oct(10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(hex(15&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;0b101
0o12
&lt;/span&gt;0xf
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;tuple()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的元组&lt;/li&gt;
&lt;li&gt;传入的参数为空或者是可迭代对象&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tuple())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(tuple(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(tuple([1, 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;()
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
(&lt;/span&gt;1, 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;list()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的列表&lt;/li&gt;
&lt;li&gt;传入的参数为空或者是可迭代对象&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list([1, 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;[]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;1, 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;br/&gt;dict()&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的字典&lt;/li&gt;
&lt;li&gt;可以由下列四种方式传入参数：
&lt;ul&gt;&lt;li&gt;不传入参数，建立空字典&lt;/li&gt;
&lt;li&gt;通过映射函数创建字典&lt;/li&gt;
&lt;li&gt;通过键值对来创建字典&lt;/li&gt;
&lt;li&gt;通过可迭代对象来创建字典&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dict())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dict(zip([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],[1, 2&lt;span&gt;])))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dict(key1 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, key2 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dict([[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1], [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;{}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;set()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的集合&lt;/li&gt;
&lt;li&gt;set() -&amp;gt; new empty set object&lt;/li&gt;
&lt;li&gt;set(iterable) -&amp;gt; new set object&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(set())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(set([1,2,3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;set()
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;1, 2, 3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;frozenset()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的不可变集合&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(frozenset())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(frozenset(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

frozenset()
frozenset({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;range()&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;根据传入的参数创建一个新的range对象&lt;/li&gt;
&lt;li&gt;python3里面，需要通过for循环来创建range（）每一个元素&lt;/li&gt;
&lt;li&gt;range（a，b）--&amp;gt;左闭右开&lt;/li&gt;
&lt;li&gt;range(stop) -&amp;gt; range object&lt;/li&gt;
&lt;li&gt;range(start, stop[, step]) -&amp;gt; range object&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(item)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; range(10, 15&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(item)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; range(0, 100, 20&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(item)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
0 1 2 3 4 
10 11 12 13 14&lt;span&gt;
0 &lt;/span&gt;20 40 60 80
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写在后面：&lt;/p&gt;
&lt;p&gt;内置函数总结好多哦&lt;/p&gt;
&lt;p&gt;今天眼睛看电脑时间太长了   累&lt;/p&gt;
&lt;p&gt;明天继续总结吧&lt;/p&gt;
&lt;p&gt;今天也就总结了一半的样子&lt;/p&gt;
&lt;p&gt;最近发现之前的知识有些忘记了&lt;/p&gt;
&lt;p&gt;需要返回去再看看了&lt;/p&gt;
&lt;p&gt;开题报告写的不是很好  今天老师要求重新写&lt;/p&gt;
&lt;p&gt;好好加油吧&lt;/p&gt;
&lt;p&gt;明天就是周末啦   可以粗去吃好吃的  放松放松&lt;/p&gt;
&lt;p&gt;更重要的  双11   买买买&lt;/p&gt;

</description>
<pubDate>Fri, 09 Nov 2018 14:17:00 +0000</pubDate>
<dc:creator>小伙郭</dc:creator>
<og:description>将68个内置函数按照其功能分为了10类，分别是： 数学运算（7个） abs() divmod() max() min() pow() round() sum() 类型转换（24个） bool() in</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoruxin/p/9937491.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用GraphQL - 第六章  使用EF Core作为持久化仓储 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9937468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9937468.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181109221011360-1849833945.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core中使用GraphQL&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本篇中我将演示如何配置持久化仓储，这里原文中是使用的&lt;code&gt;Postgres&lt;/code&gt;, 这里我改用了&lt;code&gt;EF Core For SqlServer&lt;/code&gt;。本文的例子需要在上一篇的代码基础上修改。没有代码的同学，可以去&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20V&quot;&gt;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20V&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;之前我们编写了一个&lt;code&gt;DataStore&lt;/code&gt;类，里面硬编码了一个数据集合，这里我们希望改用依赖注入的方式进行解耦，所以首先我们需要创建一个抽象接口&lt;code&gt;IDataStore&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IDataStore
{
    IEnumerable&amp;lt;Item&amp;gt; GetItems();
    Item GetItemByBarcode(string barcode);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于接下来我们需要使用&lt;code&gt;EF Core&lt;/code&gt;, 所以这里我们需要添加一个&lt;code&gt;EF Core&lt;/code&gt;的上下文类&lt;code&gt;ApplicationDbContext&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions&amp;lt;ApplicationDbContext&amp;gt; options) : base(options)
    {

    }
    
    public DbSet&amp;lt;Item&amp;gt; Items { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&amp;lt;Item&amp;gt;().ToTable(&quot;Items&quot;);
        modelBuilder.Entity&amp;lt;Item&amp;gt;().HasKey(p =&amp;gt; p.Barcode);
    
        modelBuilder.Entity&amp;lt;Item&amp;gt;().HasData(new Item { 
            Barcode = &quot;123&quot;, 
            Title = &quot;Headphone&quot;, 
            SellingPrice = 50 });
            
        modelBuilder.Entity&amp;lt;Item&amp;gt;().HasData(new Item { 
            Barcode = &quot;456&quot;, 
            Title = &quot;Keyboard&quot;, 
            SellingPrice = 40 });
        modelBuilder.Entity&amp;lt;Item&amp;gt;().HasData(new Item { 
            Barcode = &quot;789&quot;, 
            Title = &quot;Monitor&quot;, 
            SellingPrice = 100 });

        base.OnModelCreating(modelBuilder);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为了导入一些初始数据，我们在&lt;code&gt;OnModelCreating&lt;/code&gt;方法中使用&lt;code&gt;HasData&lt;/code&gt;方法添加了3个初始数据。&lt;/p&gt;
&lt;p&gt;下面我们修改&lt;code&gt;DataStore&lt;/code&gt;类, &lt;code&gt;DataStore&lt;/code&gt;应该实现&lt;code&gt;IDataStore&lt;/code&gt;接口, 其中的&lt;code&gt;GetItemByBarcode&lt;/code&gt;和&lt;code&gt;GetItems&lt;/code&gt;方法需要改为从数据库中读取。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class DataStore : IDataStore
{
    private ApplicationDbContext _applicationDbContext;

    public DataStore(ApplicationDbContext applicationDbContext)
    {
        _applicationDbContext = applicationDbContext;
    }

    public Item GetItemByBarcode(string barcode)
    {
        return _applicationDbContext.Items.First(i =&amp;gt; i.Barcode.Equals(barcode));
    }

    public IEnumerable&amp;lt;Item&amp;gt; GetItems()
    {
        return _applicationDbContext.Items;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们要在&lt;code&gt;Startup.cs&lt;/code&gt;类中的&lt;code&gt;ConfigureServices&lt;/code&gt;添加Entity Framework配置&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(option =&amp;gt;
{
    option.UseSqlServer(Configuration.GetConnectionString(&quot;SampleDB&quot;));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;TIPS: 这里注意不要忘记创建一个&lt;code&gt;appsettings.json&lt;/code&gt;, 在其中添加数据库连接字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置完成之后，我们需要使用以下命令添加Migration，并更新数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet ef migrations add Initial
dotnet ef database update&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在针对数据库的修改都已经完成了。&lt;/p&gt;
&lt;p&gt;另外我们还需要修改服务注册代码，将注册服务的生命周期从单例(Singleton)改为作用域(Scoped), 因为当注入服务的生命周期为单例时，需要处理多线程问题和潜在的内存泄漏问题。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddScoped&amp;lt;IDataStore, DataStore&amp;gt;();
services.AddScoped&amp;lt;HelloWorldQuery&amp;gt;();
services.AddScoped&amp;lt;ISchema, HelloWorldSchema&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完成后，&lt;code&gt;Startup.cs&lt;/code&gt;最终代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Startup
{
    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public IConfiguration Configuration { get; }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(option =&amp;gt;
        {                                                                                             
             option.UseSqlServer(Configuration.GetConnectionString(&quot;SampleDB&quot;));
        });

        services.AddSingleton&amp;lt;IDocumentExecuter, DocumentExecuter&amp;gt;();
        services.AddSingleton&amp;lt;IDocumentWriter, DocumentWriter&amp;gt;();

        services.AddScoped&amp;lt;IDataStore, DataStore&amp;gt;();
        services.AddScoped&amp;lt;HelloWorldQuery&amp;gt;();
        services.AddScoped&amp;lt;ISchema, HelloWorldSchema&amp;gt;();
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseDefaultFiles();
        app.UseStaticFiles();

        app.UseMiddleware&amp;lt;GraphQLMiddleware&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们启动项目, 程序会抛出一个错误&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;System.InvalidOperationException: Cannot resolve scoped service 'GraphQL.Types.ISchema' from root provider&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题的原因是，中间件是单例的，如果在中间件的构造函数中使用作用域(Scoped)的依赖注入, 会导致这个问题(具体请参见https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1)。这里&lt;code&gt;ISchema&lt;/code&gt;的生命周期是作用域，并且在&lt;code&gt;GraphQLMiddleware&lt;/code&gt;类中是从构造函数注入的，所以这里我们需要修改&lt;code&gt;GraphQLMiddleware&lt;/code&gt;类，&lt;code&gt;ISchema&lt;/code&gt;需要改从&lt;code&gt;Invoke&lt;/code&gt;方法注入。&lt;/p&gt;
&lt;p&gt;中间件最终代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class GraphQLMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IDocumentWriter _writer;
    private readonly IDocumentExecuter _executor;
    public GraphQLMiddleware(RequestDelegate next, IDocumentWriter writer, IDocumentExecuter executor)
    {
        _next = next;
        _writer = writer;
        _executor = executor;
    }

    public async Task InvokeAsync(HttpContext httpContext, ISchema schema)
    {
        if (httpContext.Request.Path.StartsWithSegments(&quot;/api/graphql&quot;)
            &amp;amp;&amp;amp; string.Equals(httpContext.Request.Method,
            &quot;POST&quot;,
            StringComparison.OrdinalIgnoreCase))
        {
            string body;
            using (var streamReader = new StreamReader(httpContext.Request.Body))
            {
                body = await streamReader.ReadToEndAsync();

                var request = JsonConvert.DeserializeObject&amp;lt;GraphQLRequest&amp;gt;(body);

                var result = await _executor.ExecuteAsync(doc =&amp;gt;
                {
                    doc.Schema = schema;
                    doc.Query = request.Query;
                    doc.Inputs = request.Variables.ToInputs();
                }).ConfigureAwait(false);

                var json = await _writer.WriteToStringAsync(result);
                await httpContext.Response.WriteAsync(json);
            }
        }
        else
        {
            await _next(httpContext);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完成之后，我们重新启动项目，项目正常启动成功, &lt;code&gt;GraphiQL&lt;/code&gt;界面出现。&lt;/p&gt;
&lt;p&gt;现在我们还是使用上一章的查询代码，查询二维码是123的货物数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181109221017666-1729104940.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据正常从数据库中读取成功。下一章我们将讲解在ASP.NET Core中如何使用GraphQL添加修改数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20VI&quot;&gt;本文源代码： https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20VI&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 14:14:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>ASP.NET Core中使用GraphQL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9937468.html</dc:identifier>
</item>
<item>
<title>智联招聘爬虫源码分析(一) - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/9937244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/9937244.html</guid>
<description>&lt;p&gt;    最近一直在关注秋招，虽然还没轮到我，不过提前准备总是好的。近期听闻今年秋招形势严峻，为了更好的准备将来的实习、工作，我决定在招聘网站上爬取一些与数据有关的岗位信息，借以给自己将来的职业道路选择提供参考。&lt;/p&gt;


&lt;p&gt;    通过Python的requests库，向网站服务器发送请求，服务器返回相关网页的源码，再通过正则表达式等方式在网页源码中提取出我们想要的信息。&lt;/p&gt;


&lt;h2&gt;    2.1岗位详情url&lt;/h2&gt;
&lt;p&gt;        在智联招聘网站中搜索'大数据'，跳转到大数据岗位页面，接下来我们点开开发者选项，刷新页面，在Network面板的XHR中发现了这样一个数据包:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211921780-286912617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;XHR: &lt;span&gt;&lt;span&gt;&lt;span&gt;XHR&lt;/span&gt;&lt;span&gt;为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        在新的页面打开后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211922262-263083593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        这个页面里出现的所有的岗位信息都在里面了：岗位名称、公司名称、薪水、地区、详情界面的url都在该json里。但是这些信息都不是最重要的，我需要岗位要求以及岗位职责的要求。&lt;/p&gt;
&lt;p&gt;        将该json解析，得到如下结构的json数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211922571-1308198150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        code的值为HTTP的响应码，200表示请求成功。而results数组则是该页面岗位信息的数据。点开第一条数据（results的第一个元素）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211923282-1015573764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        页面中出现的所有数据，以及相关的超链接都在这儿。其中，我们需要的是指向岗位详情界面的超链接——'&lt;span&gt;&lt;strong&gt;positionURL&lt;/strong&gt;&lt;/span&gt;'。点击该链接，进去该岗位信息详情页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211924531-4025265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        好了，我们需要的信息出现了，不过为了简化页面分析的操作，以及尽可能地不被反爬，我决定选择移动适配的页面。&lt;/p&gt;
&lt;p&gt;        再打开开发者选项，在该岗位详情页面，刷新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211924899-2301422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        在&amp;lt;meta&amp;gt;中找到'mobile-agent'，提取后面的url——'url=//m.zhaopin.com/jobs/CZ745244850J00020982209/'，打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211925231-1403621798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        真清爽！&lt;/p&gt;
&lt;h2&gt;    2.2 Xpath定位&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;XPath&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;即为&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;XML&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;路径语言（&lt;/span&gt;&lt;span&gt;XML Path Language&lt;/span&gt;&lt;span&gt;），它是一种用来确定&lt;/span&gt;&lt;span&gt;XML&lt;/span&gt;&lt;span&gt;文档中某部分位置的语言&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    分析该网页的源代码，寻找我们所需信息的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211925549-1811118215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    岗位名称、月薪、公司、地区、学历、年限信息都在'&lt;span&gt;//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[1]/&lt;/span&gt;'下。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;title = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[1]/h1/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;pay = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[1]/div[1]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;place = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[3]/div[1]/span[1]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;campanyName = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[2]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;edu = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[3]/div[1]/span[3]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;岗位要求与岗位职责在同一个&amp;lt;div&amp;gt;标签里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211925866-1789268325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    也爬出来：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;comment = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/article/div/p/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，最复杂的部分搞定。&lt;/p&gt;


&lt;p&gt;    我们将前三页的数据包地址比对一下就能看出问题：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;https:&lt;span&gt;//fe-api.zhaopin.com/c/i/sou?pageSize=60&amp;amp;cityId=489&amp;amp;workExperience=-1&amp;amp;education=-1&amp;amp;companyType=-1&amp;amp;employmentType=-1&amp;amp;jobWelfareTag=-1&amp;amp;kw=%E5%A4%A7%E6%95%B0%E6%8D%AE&amp;amp;kt=3&amp;amp;_v=0.14571817&amp;amp;x-zp-page-request-id=ce8cbb93b9ad4372b4a9e3330358fe7c-1541763191318-555474&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;https:&lt;span&gt;//fe-api.zhaopin.com/c/i/sou?start=60&amp;amp;pageSize=60&amp;amp;cityId=489&amp;amp;workExperience=-1&amp;amp;education=-1&amp;amp;companyType=-1&amp;amp;employmentType=-1&amp;amp;jobWelfareTag=-1&amp;amp;kw=%E5%A4%A7%E6%95%B0%E6%8D%AE&amp;amp;kt=3&amp;amp;_v=0.14571817&amp;amp;x-zp-page-request-id=ce8cbb93b9ad4372b4a9e3330358fe7c-1541763191318-555474&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;https:&lt;span&gt;//fe-api.zhaopin.com/c/i/sou?start=120&amp;amp;pageSize=60&amp;amp;cityId=489&amp;amp;workExperience=-1&amp;amp;education=-1&amp;amp;companyType=-1&amp;amp;employmentType=-1&amp;amp;jobWelfareTag=-1&amp;amp;kw=%E5%A4%A7%E6%95%B0%E6%8D%AE&amp;amp;kt=3&amp;amp;_v=0.14571817&amp;amp;x-zp-page-request-id=ce8cbb93b9ad4372b4a9e3330358fe7c-1541763191318-555474&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;https:&lt;span&gt;//fe-api.zhaopin.com/c/i/sou?start=180&amp;amp;pageSize=60&amp;amp;cityId=489&amp;amp;workExperience=-1&amp;amp;education=-1&amp;amp;companyType=-1&amp;amp;employmentType=-1&amp;amp;jobWelfareTag=-1&amp;amp;kw=%E5%A4%A7%E6%95%B0%E6%8D%AE&amp;amp;kt=3&amp;amp;_v=0.14571817&amp;amp;x-zp-page-request-id=ce8cbb93b9ad4372b4a9e3330358fe7c-1541763191318-555474&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;1.我们可以看出第一页的url结构与后面的url结构有明显的不同。&lt;/p&gt;
&lt;p&gt;2.非首页的url有明显的规律性。&lt;/p&gt;
&lt;p&gt;3.'kw=*&amp;amp;kt'里的字符为'大数据'的UTF-8编码。&lt;/p&gt;

&lt;p&gt;所以我们对数据包有如下的操作：&lt;/p&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; __name__ == &lt;span&gt;'__main__'&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    key = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;大数据&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;    url = &lt;span&gt;'https://fe-api.zhaopin.com/c/i/sou?pageSize=60&amp;amp;cityId=489&amp;amp;workExperience=-1&amp;amp;education=-1&amp;amp;companyType=-1&amp;amp;employmentType=-1&amp;amp;jobWelfareTag=-1&amp;amp;kw='&lt;span&gt; + key + &lt;span&gt;'&amp;amp;kt=3&amp;amp;lastUrlQuery=%7B%22pageSize%22:%2260%22,%22jl%22:%22489%22,%22kw%22:%22%E5%A4%A7%E6%95%B0%E6%8D%AE%22,%22kt%22:%223%22%7D'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    infoUrl(url)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;    urls = [&lt;span&gt;'https://fe-api.zhaopin.com/c/i/sou?start={}&amp;amp;pageSize=60&amp;amp;cityId=489&amp;amp;kw='&lt;span&gt;.format(i*60)+key+&lt;span&gt;'&amp;amp;kt=3&amp;amp;lastUrlQuery=%7B%22p%22:{},%22pageSize%22:%2260%22,%22jl%22:%22489%22,%22kw%22:%22java%22,%22kt%22:%223%22%7D'&lt;span&gt;.format(i) &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; i &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; range(1,50)]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; url &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; urls:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        infoUrl(url)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    1、截取整个结果界面的JSON数据包，从中提取出各个招聘栏的url。&lt;/p&gt;
&lt;p&gt;    2、进入招聘详细信息页面，提取移动端url。&lt;/p&gt;
&lt;p&gt;    3、进入移动端界面，抓取需要的信息。&lt;/p&gt;


&lt;ol readability=&quot;70&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;''&lt;span&gt;'''&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;智联招聘&lt;/span&gt;&lt;span&gt;——&lt;/span&gt;&lt;span&gt;爬虫源码&lt;/span&gt;&lt;span&gt;————2018.11&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;'''&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;span&gt; requests  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;span&gt; re  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;span&gt; time  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;from&lt;/strong&gt;&lt;span&gt; lxml &lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;span&gt; etree  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;span&gt; csv  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;span&gt; random  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;fp = open(&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;智联招聘&lt;/span&gt;&lt;span&gt;.csv'&lt;span&gt;,&lt;span&gt;'wt'&lt;span&gt;,newline=&lt;span&gt;''&lt;span&gt;,encoding=&lt;span&gt;'UTF-8'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;writer = csv.writer(fp)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;''&lt;span&gt;'''&lt;/span&gt;&lt;/span&gt;&lt;span&gt;地区，公司名，学历，岗位描述，薪资，福利，发布时间，工作经验，链接&lt;/span&gt;&lt;span&gt;'''&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;writer.writerow((&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;职位&lt;/span&gt;&lt;span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;公司&lt;/span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;地区&lt;/span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;学历&lt;/span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;岗位&lt;/span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;薪资&lt;/span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;福利&lt;/span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;'&lt;span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;链接&lt;/span&gt;&lt;span&gt;'&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;span&gt; info(url):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    res = requests.get(url)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    u = re.findall(&lt;span&gt;'&amp;lt;meta name=&quot;mobile-agent&quot; content=&quot;format=html5; url=(.*?)&quot; /&amp;gt;'&lt;span&gt;, res.text)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; len(u) &amp;gt; 0:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        u = u[-1]  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    u = &lt;span&gt;'http:'&lt;span&gt; + u  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    headers ={  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;'User-Agent'&lt;span&gt;: &lt;span&gt;'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    res = requests.get(u,headers=headers)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    selector = etree.HTML(res.text)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;岗位名称&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    title = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[1]/h1/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;岗位薪资&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    pay = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[1]/div[1]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;工作地点&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    place = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[3]/div[1]/span[1]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;公司名称&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    companyName = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[2]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;学历&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    edu = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[3]/div[1]/span[3]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;福利&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    walfare = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[3]/span/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    siteUrl = res.url  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    workEx = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/div[1]/div[3]/div[1]/span[2]/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# # &lt;/span&gt;&lt;/span&gt;&lt;span&gt;岗位详细&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    comment = selector.xpath(&lt;span&gt;'//*[@id=&quot;r_content&quot;]/div[1]/div/article/div/p/text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;    writer.writerow((title, companyName, place, edu, comment, pay, walfare, workEx, siteUrl))  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(title, companyName, place, edu, comment, pay, walfare, workEx, siteUrl)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;span&gt; infoUrl(url):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    res = requests.get(url)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    selector = res.json()  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    code = selector[&lt;span&gt;'code'&lt;span&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; code == 200:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        data = selector[&lt;span&gt;'data'&lt;span&gt;][&lt;span&gt;'results'&lt;span&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; i &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; data:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            href = i[&lt;span&gt;'positionURL'&lt;span&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            info(href)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            time.sleep(random.randrange(1,4))  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; __name__ == &lt;span&gt;'__main__'&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    key = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;大数据&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;    url = &lt;span&gt;'https://fe-api.zhaopin.com/c/i/sou?pageSize=60&amp;amp;cityId=489&amp;amp;workExperience=-1&amp;amp;education=-1&amp;amp;companyType=-1&amp;amp;employmentType=-1&amp;amp;jobWelfareTag=-1&amp;amp;kw='&lt;span&gt; + key + &lt;span&gt;'&amp;amp;kt=3&amp;amp;lastUrlQuery=%7B%22pageSize%22:%2260%22,%22jl%22:%22489%22,%22kw%22:%22%E5%A4%A7%E6%95%B0%E6%8D%AE%22,%22kt%22:%223%22%7D'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    infoUrl(url)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;    urls = [&lt;span&gt;'https://fe-api.zhaopin.com/c/i/sou?start={}&amp;amp;pageSize=60&amp;amp;cityId=489&amp;amp;kw='&lt;span&gt;.format(i*60)+key+&lt;span&gt;'&amp;amp;kt=3&amp;amp;lastUrlQuery=%7B%22p%22:{},%22pageSize%22:%2260%22,%22jl%22:%22489%22,%22kw%22:%22java%22,%22kt%22:%223%22%7D'&lt;span&gt;.format(i) &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; i &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; range(1,50)]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; url &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; urls:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        infoUrl(url)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201811/1219242-20181109211926071-1277916250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ps.因为某些原因，我打算每个月爬取智联招聘、51job的岗位信息一次，源码、优化都会以博客的形式写出来，欢迎关注~&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;源码地址：&lt;/em&gt;智联招聘_爬虫源码&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Nov 2018 13:17:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<og:description>最近一直在关注秋招，虽然还没轮到我，不过提前准备总是好的。近期听闻今年秋招形势严峻，为了更好的准备将来的实习、工作，我决定在招聘网站上爬取一些与数据有关的岗位信息，借以给自己将来的职业道路选择提供参考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/9937244.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第二章网关篇-重构Ocelot来满足需求 - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/9937213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/9937213.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这篇文章，我们将从Ocelot的中间件源码分析，目前Ocelot已经实现那些功能，还有那些功能在我们实际项目中暂时还未实现，如果我们要使用这些功能，应该如何改造等方面来说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;7.1907216494845&quot;&gt;
&lt;p&gt;在使用一个组件前，最好我们要了解其中的一些原理，否则在使用过程中遇到问题，也无从下手，今天我带着大家一起来解读下Ocelot源码，并梳理出具体实现的原理和流程，便于我们根据需求扩展应用。&lt;br/&gt;Ocelot源码地址[&lt;a href=&quot;https://github.com/ThreeMammals/Ocelot&quot; class=&quot;uri&quot;&gt;https://github.com/ThreeMammals/Ocelot&lt;/a&gt;],&lt;br/&gt;Ocelot文档地址[&lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/&quot; class=&quot;uri&quot;&gt;https://ocelot.readthedocs.io/en/latest/&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看&lt;code&gt;.NETCORE&lt;/code&gt;相关中间件源码，我们优先找到入口方法，比如Ocelot中间件使用的是&lt;code&gt;app.UseOcelot()&lt;/code&gt;,我们直接搜索UserOcelot,我们会找到&lt;code&gt;OcelotMiddlewareExtensions&lt;/code&gt;方法，里面是Ocelot中间件实际运行的方式和流程。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181109210810221-1380218739.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继续顺藤摸瓜，查看详细的实现，我们会发现如下代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;IApplicationBuilder&amp;gt; UseOcelot(this IApplicationBuilder builder, OcelotPipelineConfiguration pipelineConfiguration)
        {   
            //创建配置信息
            var configuration = await CreateConfiguration(builder);
            //监听配置信息
            ConfigureDiagnosticListener(builder);
            //创建执行管道
            return CreateOcelotPipeline(builder, pipelineConfiguration);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们继续跟踪到创建管道方法，可以发现Ocelot的执行流程已经被找到，现在问题变的简单了，直接查看&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private static IApplicationBuilder CreateOcelotPipeline(IApplicationBuilder builder, OcelotPipelineConfiguration pipelineConfiguration)
{
    var pipelineBuilder = new OcelotPipelineBuilder(builder.ApplicationServices);
    //详细创建的管道顺序在此方法
    pipelineBuilder.BuildOcelotPipeline(pipelineConfiguration);

    var firstDelegate = pipelineBuilder.Build();

    /*
            inject first delegate into first piece of asp.net middleware..maybe not like this
            then because we are updating the http context in ocelot it comes out correct for
            rest of asp.net..
            */

    builder.Properties[&quot;analysis.NextMiddlewareName&quot;] = &quot;TransitionToOcelotMiddleware&quot;;

    builder.Use(async (context, task) =&amp;gt;
                {
                    var downstreamContext = new DownstreamContext(context);
                    await firstDelegate.Invoke(downstreamContext);
                });

    return builder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;管道创建流程及实现，会不会感觉到摸到大动脉了，核心的功能及原理基本找到了，那以后动手术也就可以避开一些坑了，我们可以对着这个执行顺序，再查看详细的源码，按照这个执行顺序查看源码，您就会发现整个思路非常清晰，每一步的实现一目了然。为了更直观的介绍源码的解读方式，这里我们就拿我们后续要操刀的中间件来讲解下中间件的具体实现。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class OcelotPipelineExtensions
    {
        public static OcelotRequestDelegate BuildOcelotPipeline(this IOcelotPipelineBuilder builder,
            OcelotPipelineConfiguration pipelineConfiguration)
        {
            // This is registered to catch any global exceptions that are not handled
            // It also sets the Request Id if anything is set globally
            builder.UseExceptionHandlerMiddleware();

            // If the request is for websockets upgrade we fork into a different pipeline
            builder.MapWhen(context =&amp;gt; context.HttpContext.WebSockets.IsWebSocketRequest,
                app =&amp;gt;
                {
                    app.UseDownstreamRouteFinderMiddleware();
                    app.UseDownstreamRequestInitialiser();
                    app.UseLoadBalancingMiddleware();
                    app.UseDownstreamUrlCreatorMiddleware();
                    app.UseWebSocketsProxyMiddleware();
                });

            // Allow the user to respond with absolutely anything they want.
            builder.UseIfNotNull(pipelineConfiguration.PreErrorResponderMiddleware);

            // This is registered first so it can catch any errors and issue an appropriate response
            builder.UseResponderMiddleware();

            // Then we get the downstream route information
            builder.UseDownstreamRouteFinderMiddleware();

            // This security module, IP whitelist blacklist, extended security mechanism
            builder.UseSecurityMiddleware();

            //Expand other branch pipes
            if (pipelineConfiguration.MapWhenOcelotPipeline != null)
            {
                foreach (var pipeline in pipelineConfiguration.MapWhenOcelotPipeline)
                {
                    builder.MapWhen(pipeline);
                }
            }

            // Now we have the ds route we can transform headers and stuff?
            builder.UseHttpHeadersTransformationMiddleware();

            // Initialises downstream request
            builder.UseDownstreamRequestInitialiser();

            // We check whether the request is ratelimit, and if there is no continue processing
            builder.UseRateLimiting();

            // This adds or updates the request id (initally we try and set this based on global config in the error handling middleware)
            // If anything was set at global level and we have a different setting at re route level the global stuff will be overwritten
            // This means you can get a scenario where you have a different request id from the first piece of middleware to the request id middleware.
            builder.UseRequestIdMiddleware();

            // Allow pre authentication logic. The idea being people might want to run something custom before what is built in.
            builder.UseIfNotNull(pipelineConfiguration.PreAuthenticationMiddleware);

            // Now we know where the client is going to go we can authenticate them.
            // We allow the ocelot middleware to be overriden by whatever the
            // user wants
            if (pipelineConfiguration.AuthenticationMiddleware == null)
            {
                builder.UseAuthenticationMiddleware();
            }
            else
            {
                builder.Use(pipelineConfiguration.AuthenticationMiddleware);
            }

            // The next thing we do is look at any claims transforms in case this is important for authorisation
            builder.UseClaimsToClaimsMiddleware();

            // Allow pre authorisation logic. The idea being people might want to run something custom before what is built in.
            builder.UseIfNotNull(pipelineConfiguration.PreAuthorisationMiddleware);

            // Now we have authenticated and done any claims transformation we 
            // can authorise the request
            // We allow the ocelot middleware to be overriden by whatever the
            // user wants
            if (pipelineConfiguration.AuthorisationMiddleware == null)
            {//使用自定义认证，移除默认的认证方式
                //builder.UseAuthorisationMiddleware();
            }
            else
            {
                builder.Use(pipelineConfiguration.AuthorisationMiddleware);
            }

            // Now we can run the claims to headers transformation middleware
            builder.UseClaimsToHeadersMiddleware();

            // Allow the user to implement their own query string manipulation logic
            builder.UseIfNotNull(pipelineConfiguration.PreQueryStringBuilderMiddleware);

            // Now we can run any claims to query string transformation middleware
            builder.UseClaimsToQueryStringMiddleware();

            // Get the load balancer for this request
            builder.UseLoadBalancingMiddleware();

            // This takes the downstream route we retrieved earlier and replaces any placeholders with the variables that should be used
            builder.UseDownstreamUrlCreatorMiddleware();

            // Not sure if this is the best place for this but we use the downstream url 
            // as the basis for our cache key.
            builder.UseOutputCacheMiddleware();

            //We fire off the request and set the response on the scoped data repo
            builder.UseHttpRequesterMiddleware();

            return builder.Build();
        }
    private static void UseIfNotNull(this IOcelotPipelineBuilder builder,
            Func&amp;lt;DownstreamContext, Func&amp;lt;Task&amp;gt;, Task&amp;gt; middleware)
        {
            if (middleware != null)
            {
                builder.Use(middleware);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;限流中间件实现解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现代码如下&lt;code&gt;builder.UseRateLimiting();&lt;/code&gt;，我们转到定义，得到如下代码，详细的实现逻辑在&lt;code&gt;ClientRateLimitMiddleware&lt;/code&gt;方法里，继续转定义到这个方法，我把方法里用到的内容注释了下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class RateLimitMiddlewareExtensions
{
    public static IOcelotPipelineBuilder UseRateLimiting(this IOcelotPipelineBuilder builder)
    {
        return builder.UseMiddleware&amp;lt;ClientRateLimitMiddleware&amp;gt;();
    }
}

public class ClientRateLimitMiddleware : OcelotMiddleware
{
        private readonly OcelotRequestDelegate _next;
        private readonly IRateLimitCounterHandler _counterHandler;
        private readonly ClientRateLimitProcessor _processor;

        public ClientRateLimitMiddleware(OcelotRequestDelegate next,
            IOcelotLoggerFactory loggerFactory,
            IRateLimitCounterHandler counterHandler)
                :base(loggerFactory.CreateLogger&amp;lt;ClientRateLimitMiddleware&amp;gt;())
        {
            _next = next;
            _counterHandler = counterHandler;
            _processor = new ClientRateLimitProcessor(counterHandler);
        }
        //熟悉的Tnvoke方法，所有的逻辑都在此方法里。
        public async Task Invoke(DownstreamContext context)
        {
            var options = context.DownstreamReRoute.RateLimitOptions;

            // 校验是否启用限流配置
            if (!context.DownstreamReRoute.EnableEndpointEndpointRateLimiting)
            {//未启用直接进入下一个中间件
                Logger.LogInformation($&quot;EndpointRateLimiting is not enabled for {context.DownstreamReRoute.DownstreamPathTemplate.Value}&quot;);
                await _next.Invoke(context);
                return;
            }

            // 获取配置的校验客户端的方式
            var identity = SetIdentity(context.HttpContext, options);

            // 校验是否为白名单
            if (IsWhitelisted(identity, options))
            {//白名单直接放行
                Logger.LogInformation($&quot;{context.DownstreamReRoute.DownstreamPathTemplate.Value} is white listed from rate limiting&quot;);
                await _next.Invoke(context);
                return;
            }

            var rule = options.RateLimitRule;
            if (rule.Limit &amp;gt; 0)
            {//限流数是否大于0
                // 获取当前客户端请求情况，这里需要注意_processor是从哪里注入的，后续重
                var counter = _processor.ProcessRequest(identity, options);

                // 校验请求数是否大于限流数
                if (counter.TotalRequests &amp;gt; rule.Limit)
                {
                    //获取下次有效请求的时间，就是避免每次请求，都校验一次
                    var retryAfter = _processor.RetryAfterFrom(counter.Timestamp, rule);

                    // 写入日志
                    LogBlockedRequest(context.HttpContext, identity, counter, rule, context.DownstreamReRoute);

                    var retrystring = retryAfter.ToString(System.Globalization.CultureInfo.InvariantCulture);

                    // 抛出超出限流异常并把下次可请求时间写入header里。
                    await ReturnQuotaExceededResponse(context.HttpContext, options, retrystring);

                    return;
                }
            }

            //如果启用了限流头部
            if (!options.DisableRateLimitHeaders)
            {
                var headers = _processor.GetRateLimitHeaders(context.HttpContext, identity, options);
                context.HttpContext.Response.OnStarting(SetRateLimitHeaders, state: headers);
            }
            //进入下一个中间件
            await _next.Invoke(context);
        }

        public virtual ClientRequestIdentity SetIdentity(HttpContext httpContext, RateLimitOptions option)
        {
            var clientId = &quot;client&quot;;
            if (httpContext.Request.Headers.Keys.Contains(option.ClientIdHeader))
            {
                clientId = httpContext.Request.Headers[option.ClientIdHeader].First();
            }

            return new ClientRequestIdentity(
                clientId,
                httpContext.Request.Path.ToString().ToLowerInvariant(),
                httpContext.Request.Method.ToLowerInvariant()
                );
        }

        public bool IsWhitelisted(ClientRequestIdentity requestIdentity, RateLimitOptions option)
        {
            if (option.ClientWhitelist.Contains(requestIdentity.ClientId))
            {
                return true;
            }

            return false;
        }

        public virtual void LogBlockedRequest(HttpContext httpContext, ClientRequestIdentity identity, RateLimitCounter counter, RateLimitRule rule, DownstreamReRoute downstreamReRoute)
        {
            Logger.LogInformation(
                $&quot;Request {identity.HttpVerb}:{identity.Path} from ClientId {identity.ClientId} has been blocked, quota {rule.Limit}/{rule.Period} exceeded by {counter.TotalRequests}. Blocked by rule { downstreamReRoute.UpstreamPathTemplate.OriginalValue }, TraceIdentifier {httpContext.TraceIdentifier}.&quot;);
        }

        public virtual Task ReturnQuotaExceededResponse(HttpContext httpContext, RateLimitOptions option, string retryAfter)
        {
            var message = string.IsNullOrEmpty(option.QuotaExceededMessage) ? $&quot;API calls quota exceeded! maximum admitted {option.RateLimitRule.Limit} per {option.RateLimitRule.Period}.&quot; : option.QuotaExceededMessage;

            if (!option.DisableRateLimitHeaders)
            {
                httpContext.Response.Headers[&quot;Retry-After&quot;] = retryAfter;
            }

            httpContext.Response.StatusCode = option.HttpStatusCode;
            return httpContext.Response.WriteAsync(message);
        }

        private Task SetRateLimitHeaders(object rateLimitHeaders)
        {
            var headers = (RateLimitHeaders)rateLimitHeaders;

            headers.Context.Response.Headers[&quot;X-Rate-Limit-Limit&quot;] = headers.Limit;
            headers.Context.Response.Headers[&quot;X-Rate-Limit-Remaining&quot;] = headers.Remaining;
            headers.Context.Response.Headers[&quot;X-Rate-Limit-Reset&quot;] = headers.Reset;

            return Task.CompletedTask;
        }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码解析，发现实现一个限流还是很简单的吗！再进一步解析，&lt;code&gt;IRateLimitCounterHandler&lt;/code&gt; &lt;code&gt;ClientRateLimitProcessor里的相关接口&lt;/code&gt;又是怎么实现的呢？这时候我们就需要了解下.NETCORE 的运行原理，其中&lt;code&gt;ConfigureServices&lt;/code&gt;方法实现了&lt;strong&gt;依赖注入(DI)的配置&lt;/strong&gt;。这时候我们看下&lt;code&gt;Ocelot&lt;/code&gt;是在哪里进行注入的呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;services.AddOcelot()&lt;/code&gt;是不是印象深刻呢？原来所有的注入信息都写在这里，那么问题简单了，&lt;code&gt;Ctrl+F&lt;/code&gt;查找&lt;code&gt;AddOcelot&lt;/code&gt;方法，马上就能定位到&lt;code&gt;ServiceCollectionExtensions&lt;/code&gt;方法，然后再转到定义&lt;code&gt;OcelotBuilder&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class ServiceCollectionExtensions
{
    public static IOcelotBuilder AddOcelot(this IServiceCollection services)
    {
        var service = services.First(x =&amp;gt; x.ServiceType == typeof(IConfiguration));
        var configuration = (IConfiguration)service.ImplementationInstance;
        return new OcelotBuilder(services, configuration);
    }

    public static IOcelotBuilder AddOcelot(this IServiceCollection services, IConfiguration configuration)
    {
        return new OcelotBuilder(services, configuration);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又摸到大动脉啦，现在问题迎刃而解，原来所有的注入都写在这里，从这里可以找下我们熟悉的几个接口注入。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public OcelotBuilder(IServiceCollection services, IConfiguration configurationRoot)
{
    Configuration = configurationRoot;
    Services = services;
    Services.Configure&amp;lt;FileConfiguration&amp;gt;(configurationRoot);

    Services.TryAddSingleton&amp;lt;IOcelotCache&amp;lt;FileConfiguration&amp;gt;, InMemoryCache&amp;lt;FileConfiguration&amp;gt;&amp;gt;();
    Services.TryAddSingleton&amp;lt;IOcelotCache&amp;lt;CachedResponse&amp;gt;, InMemoryCache&amp;lt;CachedResponse&amp;gt;&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHttpResponseHeaderReplacer, HttpResponseHeaderReplacer&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHttpContextRequestHeaderReplacer, HttpContextRequestHeaderReplacer&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHeaderFindAndReplaceCreator, HeaderFindAndReplaceCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IInternalConfigurationCreator, FileInternalConfigurationCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IInternalConfigurationRepository, InMemoryInternalConfigurationRepository&amp;gt;();
    Services.TryAddSingleton&amp;lt;IConfigurationValidator, FileConfigurationFluentValidator&amp;gt;();
    Services.TryAddSingleton&amp;lt;HostAndPortValidator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IReRoutesCreator, ReRoutesCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IAggregatesCreator, AggregatesCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IReRouteKeyCreator, ReRouteKeyCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IConfigurationCreator, ConfigurationCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDynamicsCreator, DynamicsCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;ILoadBalancerOptionsCreator, LoadBalancerOptionsCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;ReRouteFluentValidator&amp;gt;();
    Services.TryAddSingleton&amp;lt;FileGlobalConfigurationFluentValidator&amp;gt;();
    Services.TryAddSingleton&amp;lt;FileQoSOptionsFluentValidator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IClaimsToThingCreator, ClaimsToThingCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IAuthenticationOptionsCreator, AuthenticationOptionsCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IUpstreamTemplatePatternCreator, UpstreamTemplatePatternCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IRequestIdKeyCreator, RequestIdKeyCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IServiceProviderConfigurationCreator,ServiceProviderConfigurationCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IQoSOptionsCreator, QoSOptionsCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IReRouteOptionsCreator, ReRouteOptionsCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IRateLimitOptionsCreator, RateLimitOptionsCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IBaseUrlFinder, BaseUrlFinder&amp;gt;();
    Services.TryAddSingleton&amp;lt;IRegionCreator, RegionCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IFileConfigurationRepository, DiskFileConfigurationRepository&amp;gt;();
    Services.TryAddSingleton&amp;lt;IFileConfigurationSetter, FileAndInternalConfigurationSetter&amp;gt;();
    Services.TryAddSingleton&amp;lt;IServiceDiscoveryProviderFactory, ServiceDiscoveryProviderFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;ILoadBalancerFactory, LoadBalancerFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;ILoadBalancerHouse, LoadBalancerHouse&amp;gt;();
    Services.TryAddSingleton&amp;lt;IOcelotLoggerFactory, AspDotNetLoggerFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;IRemoveOutputHeaders, RemoveOutputHeaders&amp;gt;();
    Services.TryAddSingleton&amp;lt;IClaimToThingConfigurationParser, ClaimToThingConfigurationParser&amp;gt;();
    Services.TryAddSingleton&amp;lt;IClaimsAuthoriser, ClaimsAuthoriser&amp;gt;();
    Services.TryAddSingleton&amp;lt;IScopesAuthoriser, ScopesAuthoriser&amp;gt;();
    Services.TryAddSingleton&amp;lt;IAddClaimsToRequest, AddClaimsToRequest&amp;gt;();
    Services.TryAddSingleton&amp;lt;IAddHeadersToRequest, AddHeadersToRequest&amp;gt;();
    Services.TryAddSingleton&amp;lt;IAddQueriesToRequest, AddQueriesToRequest&amp;gt;();
    Services.TryAddSingleton&amp;lt;IClaimsParser, ClaimsParser&amp;gt;();
    Services.TryAddSingleton&amp;lt;IUrlPathToUrlTemplateMatcher, RegExUrlMatcher&amp;gt;();
    Services.TryAddSingleton&amp;lt;IPlaceholderNameAndValueFinder, UrlPathPlaceholderNameAndValueFinder&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDownstreamPathPlaceholderReplacer, DownstreamTemplatePathPlaceholderReplacer&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDownstreamRouteProvider, DownstreamRouteFinder&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDownstreamRouteProvider, DownstreamRouteCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDownstreamRouteProviderFactory, DownstreamRouteProviderFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHttpRequester, HttpClientHttpRequester&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHttpResponder, HttpContextResponder&amp;gt;();
    Services.TryAddSingleton&amp;lt;IErrorsToHttpStatusCodeMapper, ErrorsToHttpStatusCodeMapper&amp;gt;();
    Services.TryAddSingleton&amp;lt;IRateLimitCounterHandler, MemoryCacheRateLimitCounterHandler&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHttpClientCache, MemoryHttpClientCache&amp;gt;();
    Services.TryAddSingleton&amp;lt;IRequestMapper, RequestMapper&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHttpHandlerOptionsCreator, HttpHandlerOptionsCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDownstreamAddressesCreator, DownstreamAddressesCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDelegatingHandlerHandlerFactory, DelegatingHandlerHandlerFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;IHttpRequester, HttpClientHttpRequester&amp;gt;();

    // see this for why we register this as singleton http://stackoverflow.com/questions/37371264/invalidoperationexception-unable-to-resolve-service-for-type-microsoft-aspnetc
    // could maybe use a scoped data repository
    Services.TryAddSingleton&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;();
    Services.TryAddSingleton&amp;lt;IRequestScopedDataRepository, HttpDataRepository&amp;gt;();
    Services.AddMemoryCache();
    Services.TryAddSingleton&amp;lt;OcelotDiagnosticListener&amp;gt;();
    Services.TryAddSingleton&amp;lt;IMultiplexer, Multiplexer&amp;gt;();
    Services.TryAddSingleton&amp;lt;IResponseAggregator, SimpleJsonResponseAggregator&amp;gt;();
    Services.TryAddSingleton&amp;lt;ITracingHandlerFactory, TracingHandlerFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;IFileConfigurationPollerOptions, InMemoryFileConfigurationPollerOptions&amp;gt;();
    Services.TryAddSingleton&amp;lt;IAddHeadersToResponse, AddHeadersToResponse&amp;gt;();
    Services.TryAddSingleton&amp;lt;IPlaceholders, Placeholders&amp;gt;();
    Services.TryAddSingleton&amp;lt;IResponseAggregatorFactory, InMemoryResponseAggregatorFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDefinedAggregatorProvider, ServiceLocatorDefinedAggregatorProvider&amp;gt;();
    Services.TryAddSingleton&amp;lt;IDownstreamRequestCreator, DownstreamRequestCreator&amp;gt;();
    Services.TryAddSingleton&amp;lt;IFrameworkDescription, FrameworkDescription&amp;gt;();
    Services.TryAddSingleton&amp;lt;IQoSFactory, QoSFactory&amp;gt;();
    Services.TryAddSingleton&amp;lt;IExceptionToErrorMapper, HttpExeptionToErrorMapper&amp;gt;();

    //add security 
    this.AddSecurity();

    //add asp.net services..
    var assembly = typeof(FileConfigurationController).GetTypeInfo().Assembly;

    Services.AddMvcCore()
        .AddApplicationPart(assembly)
        .AddControllersAsServices()
        .AddAuthorization()
        .AddJsonFormatters();

    Services.AddLogging();
    Services.AddMiddlewareAnalysis();
    Services.AddWebEncoders();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此&lt;code&gt;Ocelot&lt;/code&gt;源码解析就到这里了，其他的具体实现代码就根据流程一个一个查看即可，这里就不详细讲解了，因为我们已经掌握整个Ocelot代码的运行原理和实现方式及流程，项目里其他的一大堆的代码都是围绕这个流程去一步一步实现的。&lt;/p&gt;
&lt;p&gt;有没有感觉添加一个中间件不是很复杂呢，是不是都跃跃欲试，准备尝试开发自己的自定义中间件啦，本篇就不介绍中间件的具体开发流程了，后续实战中会包含部分项目中需要用到的中间件，到时候会详细讲解如何规划和开发一个满足自己项目需求的中间件。&lt;/p&gt;

&lt;p&gt;在完整学习完Ocelot文档和源码后，我们基本掌握了Ocelot目前已经实现的功能，再结合我们实际项目需求，我们梳理下还有哪些功能可能需要自己扩展实现。&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;项目设计网关基本需求包括路由、认证、授权、限流、缓存，仔细学习文档和源码后发现功能都已经存在，那是不是我们就可以直接拿来使用呢？这时候我们需要拿出一些复杂业务场景来对号入座，看能否实现复杂场景的一些应用。&lt;/p&gt;
&lt;p&gt;1、授权&lt;/p&gt;
&lt;p&gt;能否为每一个客户端设置独立的访问权限，如果客户端A可以访问服务A、服务B，客户端B只能访问服务A，从网关层面直接授权，不满足需求不路由到具体服务。从文档和代码分析后发现暂时未实现。&lt;/p&gt;
&lt;p&gt;2、限流&lt;/p&gt;
&lt;p&gt;能否为每一个客户端设置不能限流规则，例如客户端A为我们内容应用，我希望对服务A不启用限流，客户端B为第三方接入应用，我需要B访问服务A访问进行单独限流（30次/分钟），看能否通过配置实现自定义限流。从文档和代码分析后发现暂时未实现。&lt;/p&gt;
&lt;p&gt;3、缓存&lt;/p&gt;
&lt;p&gt;通过代码发现目前缓存实现的只是Dictionary方式实现的缓存，不能实现分布式结构的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过分析我们发现列举的5个基本需求，尽然有3个在我们实际项目应用中可能会存在问题，如果不解决这些问题，很难直接拿这个完美的网关项目应用到正式项目，所以我们到通过扩展Ocelot方法来实现我们的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何扩展呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了满足我们项目应用的需要，我们需要为每一个路由进行单独设置，如果还采用配置文件的方式，肯定无法满足需求，且后续网关动态增加路由、授权、限流等无法控制，所以我们需要把网关配置信息从配置文件中移到数据库中，由数据库中的路由表、限流表、授权表等方式记录当前网关的应用，且后续扩展直接在数据库中增加或减少相关配置，然后动态更新网关配置实现网关的高可用。&lt;/p&gt;
&lt;p&gt;想一想是不是有点小激动，原来只要稍微改造下宝骏瞬间变宝马，那接下来的课程就是网关改造之旅，我会从设计、思想、编码等方面讲解下如何实现我们的第一辆宝马。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本系列文章我也是边想边写边实现，如果发现中间有任何描述或实现不当的地方，也请各位大神批评指正，我会第一时间整理并修正，避免让后续学习的人走弯路。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 09 Nov 2018 13:09:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/9937213.html</dc:identifier>
</item>
</channel>
</rss>