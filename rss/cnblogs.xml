<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET Core的依赖注入[1]: 控制反转 - Artech</title>
<link>http://www.cnblogs.com/artech/p/net-core-di-01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/net-core-di-01.html</guid>
<description>&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;我之前写过一系列关于.NET Core依赖注入的文章，由于.NET Core依赖注入框架的实现原理发生了很大的改变，加上我对包括IoC和DI这些理论层面的东西又有了一些新的理解，所以我在此基础上写了8篇文章详细介绍.NET Core的DI。我将这些文章发布到我的微信公众账号（大内老A）下，很多人留言说还是博客具有更好的阅读体验，所以我将在未来8天时间将它们同步到这里。&lt;/p&gt;
&lt;p&gt;软件设计中由一些所谓的理念都没有一个明确的定义，比如之前流行的SOA和现在炒的火热的微服务（Micro Service）和无服务器（Serverless），我们都不能通过一个明确的“内涵”给它们一个准确地定义，只能从“外延”上描述这些架构设计应该具有怎样的特性。正因为无法给出一个明确的界定，造成了人们针对同一个概念出现了很多不同的理解。针对IoC也是这种情况，所以本章所诉的仅仅代表作者的一家之言，读者朋友姑妄听之，仅作参考。&lt;/p&gt;

&lt;p&gt;我听到很多人将IoC说成是一种“面向对象的设计模式”，但在我个人看来IoC不能算作 一种“设计模式”，其自身也与“面向对象”没有直接的关系。我觉得很多人之所以不能很准确地理解IoC源于他们忽略了一个最根本的东西，那就是IoC这个短语，也就是他们之所以对IoC产生了诸多误解是因为他们忽略了IoC的定义。&lt;/p&gt;
&lt;p&gt;IoC的全名Inverse of Control，翻译成中文就是“控制反转”或者“控制倒置”。控制反转也好，控制倒置也罢，它体现的意思是控制权的转移，即原来控制权在A手中，现在需要B来接管。那么具体对于软件设计来说，IoC所谓的控制权的转移具有怎样的体现呢？要回答这个问题，就需要先了解IoC的C（Control）究竟指的是怎样一种控制。对于我们所在的任何一件事，不论其大小，其实可以分解成相应的步骤，所以任何一件事都有其固有的流程，IoC涉及的所谓控制可以理解为“针对流程的控制”。&lt;/p&gt;
&lt;p&gt;我们通过一个具体事例来说明传统的设计在采用了IoC之后针对流程的控制是如何实现反转的。比如说现在设计一个针对Web的MVC类库，我们不妨将其命名为MvcLib。简单起见，这个类库中只包含如下这个同名的静态类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcLib
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Task ListenAsync(Uri address);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task&amp;lt;Request&amp;gt;&lt;span&gt; ReceiveAsync();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task&amp;lt;Controller&amp;gt;&lt;span&gt; CreateControllerAsync(Request request);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task&amp;lt;View&amp;gt;&lt;span&gt; ExecuteControllerAsync(Controller controller);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Task RenderViewAsync(View view);
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MvcLib提供了如上5个方法帮助我们完成整个HTTP请求流程中的5个核心任务。具体来说，ListenAsync方法启动一个监听器并将其绑定到指定的地址进行HTTP请求的监听，抵达的请求通过ReceiveAsync方法进行接收，我们将接收到的请求通过一个Request对象来表示。CreateControllerAsync方法根据接收到的请求解析并激活请求的目标Controller对象。ExecuteControllerAsync方法执行激活的Controller并返回一个表示视图的View对象。RenderViewAsync最终将View对象转换成HTML并作为当前请求响应的内容返回给请求的客户端。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;现在我们在这个MvcLib的基础上创建一个真正的MVC应用，那么除了按照MvcLib的规范自定义具体的Controller和View之外，我们还需要自行控制从请求的监听与接收、Controller的激活与执行以及View的最终呈现在内的整个流程，这样一个执行流程反映在如下所示的代码中。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Main()
    {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            Uri address &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0:8080/mvcapp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; MvcLib.ListenAsync(address);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; MvcLib.ReceiveAsync();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; MvcLib.CreateControllerAsync(request);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; MvcLib.ExecuteControllerAsync(controller);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; MvcLib.RenderViewAsync(view);
            }
        }
    }
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;这个例子体现了如图1所示的流程控制方式（应用的代码完全采用异步的方式来处理请求，为了让流程图显得更加简单，我们在流程图中画成了同步的形式，读者不必纠结这个问题）。我们设计的类库（MvcLib）仅仅通过API的形式提供某种单一功能的实现，作为类库消费者的应用程序（App）则需要自行编排整个工作流程。如果从重用的角度来讲，这里被重用的仅限于实现某个环节单一功能的代码，编排整个工作流程的代码并没有得到重用。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;img alt=&quot;&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot;/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725074439608-796671133.png&quot;&gt;&lt;img width=&quot;388&quot; height=&quot;303&quot; title=&quot;3-1&quot; alt=&quot;3-1&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725074439880-1773680458.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;图1 流程控制掌握在应用程序手中&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;但是当我们构建一个应用的时候，我们需要的不仅仅是一个能够提供单一API的类库，我们希望的理想形式是能够直接在一个现有的框架上构建我们的应用。类库（Library）和框架（Framework）的不同之处在于，前者往往只是提供实现某种单一功能的API，而后者则针对一个目标任务对这些单一功能进行编排形成一个完整的流程，这个流程在一个引擎的驱动下自动执行。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;对于我们上面演示MvcLib来说，作为消费者的应用程序需要自行控制整个HTTP请求的处理流程，但这是实际上这是一个很“泛化”的工作流程，几乎所有的MVC应用均采用这样的流程监听、接收请求并最终对请求予以响应。如果我们将这个流程实现在一个MVC框架之中，由它构建的所有MVC应用就可以直接使用这个请求处理流程，而不需要自行重复实现它。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;现在我们将MvcLib从类库改造成一个框架，并姑且将其称为MvcFrame。如图2所示，MvcFrame的核心是一个被称为MvcEngine的执行引擎，它驱动一个编排好的工作流对HTTP请求进行一致性处理。如果我们利用MvcFrame构建一个具体的MVC应用，除了根据我们的业务需求定义相应的Controller和View之外，我们只需要初始化这个引擎并直接启动它即可。如果你曾经开发过ASP.NET MVC应用，你会发现ASP.NET MVC就是这么一个框架。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725074440132-888555764.png&quot;&gt;&lt;img width=&quot;392&quot; height=&quot;214&quot; title=&quot;3-2&quot; alt=&quot;3-2&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725074440291-1913684517.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;img alt=&quot;&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot;/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;图2 流程控制反转到框架手中&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;有了上面演示的这个例子作为铺垫，我们应该很容易理解IoC所谓的控制反转。总的来说，IoC是我们设计框架所采用的一种基本思想，所谓的控制反转就是将对应用流程的控制转移到框架中。拿上面这个例子来说，在传统面向类库编程的时代，针对HTTP请求处理的流程牢牢控制在应用程序手中。在引入框架之后，请求处理的控制权转移到了框架手上。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;在好莱坞，把简历递交给演艺公司后就只有回家等待。由演艺公司对整个娱乐项目的完全控制，演员只能被动式的接受电影公司的工作，在需要的环节中，完成自己的演出。“不要给我们打电话，我们会给你打电话(don‘t call us, we‘ll call you)”这是著名的好莱坞法则（ Hollywood Principle或者 Hollywood Low），IoC完美地体现了这一法则。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;img alt=&quot;&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot;/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725073428842-1811494061.png&quot;&gt;&lt;img width=&quot;285&quot; height=&quot;214&quot; title=&quot;3-3&quot; alt=&quot;3-3&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725073429094-1886008005.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;图3 好莱坞法则&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在IoC的应用语境中，框架就像是掌握整个电影制片流程的电影公司，由于它是整个工作流程的实际控制者，所以只有它知道哪个环节需要哪些组件。应用程序就像是演员，它只需要按照框架定制的规则注册这些组件就可以了，因为框架会在适当的时机字典加载并执行注册的组件。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;以熟悉的ASP.NET Core MVC或者ASP.NET MVC应用开发来说，我们只需要按照约定规则（比如目录结构和命名等）定义相应的Controller类型和View文件就可以了。当ASP.NET （Core ）MVC框架在进行处理请求的过程中，它会根据解析生成的路由参数定义为对应的Controller类型，并按照预定义的规则找到我们定义的Controller，然后自动创建并执行它。如果定义在当前Action方法需要呈现一个View，框架自身会根据预定义的目录约定找到我们定义的View文件，并对它实施动态编译和执行。整个流程处处体现了“&lt;strong&gt;框架Call应用&lt;/strong&gt;”的好莱坞法则。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总的来说，我们在一个框架的基础上进行应用开发，就相当于在一条调试好的流水线上生成某种商品，我们只需要在相应的环节准备对应的原材料，最终下线的就是我们希望得到的最终产品。IoC几乎是所有框架均具有的一个固有属性，从这个意义上讲，“IoC框架”的说法其实是错误的，世界上并没有什么IoC框架，或者说几乎所有的框架都是IoC框架。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;我们采用IoC实现了流程控制从应用程序向框架自身的反转，但是这个被反转的仅仅是一个泛化的流程，任何一个具体的应用都可能需要对组成该流程的某些环节进行定制。还是以我们的MVC框架来说，可能默认的请求处理流程只考虑到针对HTTP 1.1的支持，但是当我们在设计框架的时候应该提供相应的扩展点来支持HTTP 2。作为一个Web框架，用户认证功能是必备的，但是框架自身不能限制于某一种或者几种固定的认证方式，应该通过扩展的方式让用户可以自由地定制任意的认证模式。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;我们可以说得更加宽泛点。如图4所示，我们将一个泛化的工作流程（A=&amp;gt;B=&amp;gt;C）被定义在框架之中，建立在该框架的两个应用需要对组成这个流程的某些环节进行定制。比如步骤A和C可以被App1重用，但是步骤B却需要被定制（B1），App2则重用步骤A和B，但是需要按照自己的方式处理步骤C。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;img alt=&quot;&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot;/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725074440499-71035316.png&quot;&gt;&lt;img width=&quot;302&quot; height=&quot;189&quot; title=&quot;3-4&quot; alt=&quot;3-4&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180725074440689-198834942.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;图4 应用程序对流程的定制&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IoC将对流程的控制从应用程序转移到框架之中，框架利用一个引擎驱动整个流程的执行，应用程序无需关心该工作流程的细节，它只需要启动这个引擎即可。但是这个引擎一旦被启动，框架就会完全按照预先编排好的流程进行工作，如果应用程序希望整个流程按照自己希望的方式被执行，针对流程的定制一般在发生在启动引擎之前。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;一般来说，框架会以相应的形式提供一系列的扩展点，应用程序则通过定义扩展的方式实现对流程某个环节的定制。在引擎被启动之前，应用程序将所需的扩展注册到框架之中。一旦引擎被正常启动，这些注册的扩展会自动参与到整个流程的执行过程中。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;综上所述，IoC一方面通过流程控制从应用程序向框架的反转实现了针对流程自身的重用，另一方面通过内置的扩展机制这个被重用的流程可能自由地被定制，这两个因素决定了框架自身的价值。重用让框架不仅仅是为应用程序提供实现单一功能的API，而是提供一整套可执行的解决方案，可定制则使我们可以为不同的应用程序对框架进行定制，这无疑让框架可以使用到更多的应用之中。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;依赖注入[1]: 控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;依赖注入[2]: 基于IoC的设计模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;依赖注入[3]: 依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-04.html&quot;&gt;依赖注入[4]: 创建一个简易版的DI框架[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-05.html&quot;&gt;依赖注入[5]: 创建一个简易版的DI框架[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-06.html&quot;&gt;依赖注入[6]: .NET Core DI框架[编程体验]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-07.html&quot;&gt;依赖注入[7]: .NET Core DI框架[服务注册]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-08html&quot;&gt;依赖注入[8]: .NET Core DI框架[服务消费]&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 23:35:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/net-core-di-01.html</dc:identifier>
</item>
<item>
<title>Java核心技术第五章——1.类、超类、子类（2） - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/9333747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/9333747.html</guid>
<description>&lt;p&gt;继上一篇&lt;a href=&quot;https://www.cnblogs.com/Johnson-lin/p/9216797.html&quot;&gt;Java核心技术第五章——1.类、超类、子类（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.重载解析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假如调用ClassName.Method(args)&lt;/p&gt;
&lt;p&gt;1.编译器列出类ClassName所有名为Method的方法。&lt;/p&gt;
&lt;p&gt;2.编译器将查看调用方法提供的参数类型（args）。&lt;/p&gt;
&lt;p&gt;3.根据参数类型匹配所有名为Method的方法。&lt;/p&gt;
&lt;p&gt;4.如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.阻止继承：final类和方法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.final类：当你不希望别人利用某个类定义子类。那么则使用final去修饰类。此类则不允许扩展，称为final类。（final类的方法默认为final方法）&lt;/p&gt;
&lt;p&gt;2.final方法：类中的方法也可以被声明为final。如果这样做，那么子类就不能覆盖这个方法（前提不是final类）&lt;/p&gt;

&lt;p&gt;8.强制类型转换&lt;/p&gt;
&lt;p&gt;例如 : double x = 6.66;   int nx = (int) x;  //转换成功  此表达式x的值转成整数类型，舍弃了小数部分。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        List&amp;lt;Object&amp;gt; obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();

        obj.add(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;);
        obj.add(&lt;/span&gt;666&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = (Integer)obj.get(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;error 类型转换错误 ClassCastException&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如你不清楚obj数组引用的对象。那么可以使用instanceof进行检查&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt;( obj.get(0) &lt;span&gt;instanceof&lt;/span&gt; Integer){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果属于Integer类型再进行强制类型转换。&lt;/span&gt;

            &lt;span&gt;int&lt;/span&gt; i = (Integer) obj.get(0&lt;span&gt;);

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综上所述：&lt;/p&gt;
&lt;p&gt;1.只能在继承层次内进行强制类型转换&lt;/p&gt;
&lt;p&gt;2.在将超类转换成子类之前，应该使用instanceof进行检查。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.抽象类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;抽象方法充当占位符的角色，它们的具体实现在子类中。扩展抽象类（子类）可以有两种选择。一种是在子类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法。这样子类就不是抽象的了。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;抽象类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getDescription();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抽象子类：没有重写抽象父类的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person {&lt;/span&gt;&lt;span&gt;　　 public&lt;/span&gt;&lt;span&gt; Student(String name) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);&lt;/span&gt;&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;非抽象子类：重写了抽象父类的所有方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Employee &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person{&lt;/span&gt;&lt;span&gt;　　 public&lt;/span&gt; Employee(String name&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);&lt;/span&gt;&lt;span&gt;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; String.format(&quot;我的名字是xxx&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1. 抽象类不能被实例化，只有抽象类的非抽象子类可以创建对象。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;3. 抽象类中的抽象方法不会具体实现该方法。可实现部分或不实现方法。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;4. 构造方法和类方法不能声明为抽象方法。若抽象父类含有有参的构造方法。那么在子类的构造方法必须显示调用super(param)&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;18.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot;&gt;
&lt;p&gt;&lt;strong&gt;抽象类&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;默认的方法实现&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;它可以有默认的方法实现&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;接口完全是抽象的。它根本不存在方法的实现&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;子类使用&lt;strong&gt;extends&lt;/strong&gt;关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;子类使用关键字&lt;strong&gt;implements&lt;/strong&gt;来实现接口。它需要提供接口中所有声明的方法的实现&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;构造器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;抽象类可以有构造器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;接口不能有构造器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;与正常&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;类的区别&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;除了你不能实例化抽象类之外，它和普通&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;类没有任何区别&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;接口是完全不同的类型&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;访问修饰符&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;抽象方法可以有&lt;strong&gt;public&lt;/strong&gt;、&lt;strong&gt;protected&lt;/strong&gt;和&lt;strong&gt;default&lt;/strong&gt;这些修饰符&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;接口方法默认修饰符是&lt;strong&gt;public&lt;/strong&gt;。你不可以使用其它修饰符。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;main&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;抽象方法可以有&lt;span&gt;main&lt;/span&gt;&lt;span&gt;方法并且我们可以运行它&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;接口没有&lt;span&gt;main&lt;/span&gt;&lt;span&gt;方法，因此我们不能运行它。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;多继承&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;抽象方法可以继承一个类和实现多个接口&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;接口只可以继承一个或多个其它接口&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;速度&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot;&gt;
&lt;p&gt;它比接口速度要快&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;166&quot;&gt;
&lt;p&gt;添加新方法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;220&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;166&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;如果你往接口中添加方法，那么你必须改变实现该接口的类。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;此表格取自&lt;/span&gt;http://www.importnew.com/12399.html&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;9.受保护访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1. private　　仅对本类可见 &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2.不需要修饰符/defa　　对本包可见 &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;3.protected　　对本包和所有子类可见(包括不在本包的子类) &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;4.public 　　对所有类可见 &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;希望大家指出文章的不足之处，Thanks♪(･ω･)ﾉ&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 22:36:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Johnson-lin/p/9333747.html</dc:identifier>
</item>
<item>
<title>Nginx系列二：（Nginx Rewrite 规则、Nginx 防盗链、Nginx 动静分离、Nginx+keepalived  实现高可用） - 小不点啊</title>
<link>http://www.cnblogs.com/leeSmall/p/9356535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leeSmall/p/9356535.html</guid>
<description>&lt;h2&gt;1. Nginx rewrite规则&lt;/h2&gt;
&lt;p&gt;Rewrite规则含义就是某个URL重写成特定的URL（类似于Redirect），从某种意义上说为了美观或者对搜索引擎友好，提高收录量及排名等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;rewrite&lt;/td&gt;
&lt;td&gt;&amp;lt;regex&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;replacement&amp;gt;&lt;/td&gt;
&lt;td&gt;[flag]&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;关键字&lt;/td&gt;
&lt;td&gt;正则&lt;/td&gt;
&lt;td&gt;替代内容&lt;/td&gt;
&lt;td&gt;flag标记&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;Rewrite规则的flag标记主要有以下几种：&lt;br/&gt;1) last ： 相当于Apache里的(L)标记，表示完成rewrite；&lt;br/&gt;2) break： 本条规则匹配完成后，终止匹配，不再匹配后面的规则&lt;br/&gt;3) redirect： 返回302临时重定向，浏览器地址会显示跳转后的URL地址&lt;br/&gt;4) permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址&lt;br/&gt;&lt;strong&gt;&lt;span&gt;last和break用来实现URL重写，浏览器地址栏URL地址不变&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2. Nginx rewrite例子&lt;/h2&gt;
&lt;p&gt;a) 例如用户访问www.dbspread.com，想直接跳转到网站下面的某个页面，www.dbspread.com/new.index.html如何来实现呢？   我们可以使用Nginx Rewrite 来实现这个需求，具体如下：在server中加入如下语句即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
    listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;; #监听80端口
    server_name  www.dbspread.com; #域名
    #rewrite规则
    &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.jsp &lt;span&gt;index&lt;/span&gt;.html &lt;span&gt;index&lt;/span&gt;&lt;span&gt;.htm;
    root   &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;nginx&lt;span&gt;/&lt;/span&gt;&lt;span&gt;html; #定义服务器的默认网站根目录位置
    
    

    #监听完成以后通过斜杆(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;)拦截请求转发到后端的tomcat服务器
    location &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt; 
        {
            #如果后端的服务器返回502、&lt;/span&gt;&lt;span&gt;504&lt;/span&gt;&lt;span&gt;、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。
            proxy_next_upstream http_502 http_504 error timeout invalid_header;
            proxy_set_header Host  $host; #获取客户端的主机名存到变量Host里面,从而让tomcat取到客户端机器的信息
            proxy_set_header X&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Real&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;IP $remote_addr; #获取客户端的主机名存到变量X&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Real&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;IP里面,从而让tomcat取到客户端机器的信息
            proxy_set_header X&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;Forwarded&lt;span&gt;-&lt;/span&gt;&lt;span&gt;For&lt;/span&gt;&lt;span&gt; $proxy_add_x_forwarded_for;
            &lt;strong&gt;&lt;span&gt;rewrite     &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;^/$    http://www.dbspread.com/new.index.html  permanent&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;;&lt;/span&gt;&lt;/strong&gt;
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;web1; #跳转到对应的应用web1
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180723193651243-2077023488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                rewrite     &lt;span&gt;^/&lt;/span&gt;$    http:&lt;span&gt;//www.dbspread.com/new.index.html&lt;/span&gt;  &lt;span&gt;permanent&lt;/span&gt;&lt;span&gt;;
对应如下语法：
                rewrite    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;regex&lt;span&gt;&amp;gt;&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;replacement&lt;span&gt;&amp;gt;&lt;/span&gt;                 &lt;span&gt;[&lt;/span&gt;&lt;span&gt;flag&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;
                关键字      正则        替代内容                    flag标记&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正则表达式说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;*&lt;/span&gt;代表前面0或更多个字符                &lt;span&gt;+&lt;/span&gt;&lt;span&gt;代表前面1或更多个字符
？代表前面0或1个字符                  &lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;代表字符串的开始位置
$代表字符串结束的位置                 。为通配符，代表任何字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b)例如多个域名跳转到同一个域名，nginx rewrite规则写法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
    listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;; #监听80端口
    server_name  www.dbspread.com; #域名
    #rewrite规则
    &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.jsp &lt;span&gt;index&lt;/span&gt;.html &lt;span&gt;index&lt;/span&gt;&lt;span&gt;.htm;
    root   &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;nginx&lt;span&gt;/&lt;/span&gt;&lt;span&gt;html; #定义服务器的默认网站根目录位置
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($host &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.dbspread.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ){ 
            rewrite &lt;/span&gt;&lt;span&gt;^/&lt;/span&gt;(.&lt;span&gt;*&lt;/span&gt;)$  http:&lt;span&gt;//&lt;/span&gt;www.dbspread.com&lt;span&gt;/&lt;/span&gt;$&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;permanent&lt;/span&gt;&lt;span&gt;;
            }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;格式：&lt;br/&gt;rewrite &amp;lt;regex&amp;gt; &amp;lt;replacement&amp;gt; [flag];&lt;br/&gt;关键字     正则          替代内容 flag标记&lt;br/&gt;说明：&lt;br/&gt;rewrite为固定关键字，表示开始进行rewrite匹配规则、&lt;br/&gt;regex部分是 ^/(.*) ，这是一个正则表达式，匹配完整的域名和后面的路径地址&lt;br/&gt;replacement部分是http://www.dbspread.com/$1，$1是取自regex部分( )里的内容。匹配成功后跳转到的URL。&lt;br/&gt;flag部分 permanent表示永久301重定向标记，即跳转到新的 http://www.dbspread.com/$1 地址上&lt;/p&gt;

&lt;h2&gt;1. 什么是防盗链&lt;/h2&gt;
&lt;p&gt;比如http://www.dbspread.com/download/av123.rmvb 这个视频下载地址被其他网站引用，比如在www.test.com的index.html引用download/av123.rmvb就叫盗链，我们要禁止这种引用就&lt;span&gt;&lt;strong&gt;叫做防盗链&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. 怎么实现防盗链&lt;/h2&gt;
&lt;p&gt;在nginx的nginx.conf的server里面配置如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen       80;
        server_name  www.dbspread.com *.dbspread.com;
        &lt;strong&gt;&lt;span&gt;location ~* \.(rmvb|jpg|png|swf|flv)$ { #rmvb|jpg|png|swf|flv表示对rmvb|jpg|png|swf|flv后缀的文件实行防盗链
                valid_referers none blocked  www.dbspread.com; #表示对www.dbspread.com此域名开通白名单，比如在www.test.com的index.html引用download/av123.rmvb,无效
                root   html/b;
                if ($invalid_referer) { #如果请求不是从www.dbspread.com白名单发出来的请求，直接重定向到403.html这个页面或者返回403 
                     #rewrite ^/ http://www.dbspread.com/403.html;
                     return 403;
                }
        }&lt;/span&gt;&lt;/strong&gt;
 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1. 动静分离是什么&lt;/h2&gt;
&lt;p&gt;Nginx动静分离是让动态网站里的动态网页根据一定规则把&lt;span&gt;&lt;strong&gt;不变的资源和经常变的资源&lt;/strong&gt;&lt;/span&gt;区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。&lt;/p&gt;
&lt;h2&gt;2. 动静分离原理图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180723222726319-282783059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. Nginx动静分离应该注意的地方&lt;/h2&gt;
&lt;p&gt;1). WEB项目开发时要注意，将静态资源尽量放在一个static文件夹&lt;br/&gt;2). 将static静态资源文件夹放到Nginx可以取到的位置&lt;br/&gt;3). 页面要建立全局变量路径，方便修改路径&lt;br/&gt;4). 修改nginx.conf的location， 匹配静态资源请求&lt;/p&gt;
&lt;h2&gt;4. Nginx动静分离步骤&lt;/h2&gt;
&lt;h3&gt;4.1 准备一个静态资源button.css&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body &lt;/span&gt;{&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 10px 20px&lt;/span&gt;;&lt;span&gt;
    text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
    font-family&lt;/span&gt;:&lt;span&gt; Arial, sans-serif&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2  在/var/local下新建一个static文件夹用来存放静态资源button.css&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180723232025200-321814850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.3 在tomcat-8080/webapps/ROOT下的index.html里面引入button.css&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;strong&gt;&lt;span&gt; &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://www.static.com/button.css&quot; /&amp;gt;&lt;/span&gt;&lt;/strong&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge,chrome=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;renderer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;webkit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    欢迎来到8080端口tomcat
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 4.4 在nginx的nginx.conf中server节点新增静态资源分离的配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
    listen       80; #监听80端口
    server_name  www.dbspread.com; #域名
    #rewrite规则
    index  index.jsp index.html index.htm;
    root   /usr/local/nginx/html; #定义服务器的默认网站根目录位置
    #重定向
    if ($host != 'www.dbspread.com' ){ 
            rewrite ^/(.*)$  http://www.dbspread.com/$1  permanent;
            }

    #防盗链
     location ~* \.(rmvb|jpg|png|swf|flv)$ { #rmvb|jpg|png|swf|flv表示对rmvb|jpg|png|swf|flv后缀的文件实行防盗链
                valid_referers none blocked  www.dbspread.com; #表示对www.dbspread.com此域名开通白名单，比如在www.test.com的index.html引用download/av123.rmvb,无效
                root   html/b;
                if ($invalid_referer) { #如果请求不是从www.dbspread.com白名单发出来的请求，直接重定向到403.html这个页面或者返回403 
                     #rewrite ^/ http://www.dbspread.com/403.html;
                     return 403;
                }
        }
        
    #监听完成以后通过斜杆(/)拦截请求转发到后端的tomcat服务器
    location / 
        {
            #如果后端的服务器返回502、504、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。
            proxy_next_upstream http_502 http_504 error timeout invalid_header;
            proxy_set_header Host  $host; #获取客户端的主机名存到变量Host里面,从而让tomcat取到客户端机器的信息
            proxy_set_header X-Real-IP $remote_addr; #获取客户端的主机名存到变量X-Real-IP里面,从而让tomcat取到客户端机器的信息
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            #rewrite     ^/$    http://www.dbspread.com/new.index.html  permanent;#用户访问www.dbspread.com，想直接跳转到网站下面的某个页面:www.dbspread.com/new.index.html
            proxy_pass http://web1; #跳转到对应的应用web1
        }

       # location ~ .*\.(php|jsp|cgi|shtml)?$ #动态分离 ~匹配 以.*结尾（以PHP JSP结尾走这段）
       #  {
       #     proxy_set_header Host  $host;
       #        proxy_set_header X-Real-IP $remote_addr;
       #        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       #        proxy_pass http://jvm_web2;
       # }

        &lt;strong&gt;&lt;span&gt;#静态分离 ~匹配 以.*结尾（以html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css结尾走这段），当然不是越久越好，如果有10000个用户在线，都保存几个月，系统托跨
        location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ 
        {
            root /var/local/static; #静态资源存放在nginx的安装机器上
            #proxy_pass http://www.static.com; #静态资源也可存放在远程服务器上
            expires    30d; #30天之内只要访问过一次就从缓存拿
        }&lt;/span&gt;&lt;/strong&gt;

        #日志级别有[debug|info|notice|warn|error|crit]  error_log 级别分为 debug, info, notice, warn, error, crit  默认为crit, 生产环境用error 
        #crit 记录的日志最少,而debug记录的日志最多
        access_log  /usr/local/logs/web2/access.log main;
        error_log   /usr/local/logs/web2/error.log  crit;

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.5 访问页面查看效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180723233432591-1289632891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1. keepalived是什么&lt;/h2&gt;
&lt;p&gt;Keepalived软件起初是专为LVS负载均衡软件设计的，用来管理并监控LVS集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP (Virtual Router Redundancy Protocol ,虚拟路由器冗余协议）功能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件&lt;/p&gt;
&lt;h2&gt;2. keepalived主要功能&lt;/h2&gt;
&lt;p&gt;管理LVS负载均衡软件&lt;br/&gt;实现LVS集群节点的健康检查&lt;br/&gt;作为系统网络服务的高可用性（failover）&lt;/p&gt;
&lt;h2&gt;3. keepalived故障转移&lt;/h2&gt;
&lt;p&gt;Keepalived高可用服务之间的故障切换转移，是通过 VRRP 来实现的。&lt;br/&gt;在 Keepalived服务正常工作时，主 Master节点会不断地向备节点发送（多播的方式）心跳消息，用以告诉备Backup节点自己还活着，当主 Master节点发生故障时，就无法发送心跳消息，备节点也就因此无法继续检测到来自主 Master节点的心跳了，于是调用自身的接管程序，接管主Master节点的 IP资源及服务。而当主 Master节点恢复时，备Backup节点又会释放主节点故障时自身接管的IP资源及服务，恢复到原来的备用角色。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：keepalived的主从切换和redis的主从切换是不一样的，keepalived的主节点挂了以后，从节点变为主节点，之前的主节点恢复以后继续做主节点。redis的主节点挂了以后，重新恢复以后变为从节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. keepalived高可用架构示意图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180724235329796-1624335743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;虚拟ip(VIP):192.168.152.200，对外提供服务的ip，也可称作浮动ip&lt;br/&gt;192.168.152.130：nginx + keepalived master 主&lt;br/&gt;192.168.152.129：nginx + keepalived backup 从&lt;br/&gt;192.168.152.129：tomcat-8080&lt;br/&gt;192.168.152.129：tomcat-8081&lt;/p&gt;
&lt;h2&gt;5. keepalived安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;环境准备：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;centos6、jdk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟ip(VIP):192.168.152.200，对外提供服务的ip，也可称作浮动ip&lt;br/&gt;192.168.152.130：nginx + keepalived master 主&lt;br/&gt;192.168.152.129：nginx + keepalived backup 从&lt;br/&gt;192.168.152.129：tomcat-8080&lt;br/&gt;192.168.152.129：tomcat-8081&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx和tomca的环境准备&lt;/strong&gt;&lt;strong&gt;请查看我的前一篇关于nginx的文章&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.1 安装keepalived的步骤：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;注：192.168.152.129（keepalived从节点） 与 192.168.152.130（keepalived主节点）先安装好nginx + keepalived&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下载压缩包：&lt;/p&gt;
&lt;p&gt;wget www.keepalived.org/software/keepalived-1.3.5.tar.gz&lt;/p&gt;
&lt;p&gt;解压缩：&lt;/p&gt;
&lt;p&gt;tar -zxvf keepalived-1.3.5.tar.gz&lt;/p&gt;
&lt;p&gt;进入解压缩以后的文件目录：&lt;/p&gt;
&lt;p&gt;cd keepalived-1.3.5&lt;/p&gt;
&lt;p&gt;编译安装：&lt;br/&gt;./configure --prefix=/usr/local/keepalived&lt;br/&gt;系统提示警告 *** WARNING - this build will not support IPVS with IPv6. Please install libnl/libnl-3 dev libraries to support IPv6 with IPVS.&lt;br/&gt;yum -y install libnl libnl-devel&lt;br/&gt;再次执行&lt;br/&gt;./configure --prefix=/usr/local/keepalived&lt;br/&gt;系统提示错误 configure: error: libnfnetlink headers missing&lt;br/&gt;yum install -y libnfnetlink-devel&lt;br/&gt;再次执行&lt;br/&gt;./configure --prefix=/usr/local/keepalived&lt;/p&gt;
&lt;p&gt; make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;到此keepalived安装完成，&lt;strong&gt;&lt;span&gt;但是接下来还有最关键的一步，如果这一步没有做后面启动keepalived的时候会报找不到配置文件的错误&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Configuration file '/etc/keepalived/keepalived.conf' is not a regular non-executable file&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725010523490-1557936385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，进入安装目录的etc目录下，将keepalived相应的配置文件拷贝到系统相应的目录当中。keepalived启动时会从/etc/keepalived目录下查找keepalived.conf配置文件&lt;/p&gt;
&lt;p&gt;mkdir /etc/keepalived&lt;/p&gt;
&lt;p&gt;cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived&lt;/p&gt;
&lt;h3&gt;5.2 修改keepalived主节点192.168.152.130的/etc/keepalived/keepalived.conf配置文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#全局配置
global_defs {             
    notification_email {
        leeSmall&lt;/span&gt;&lt;span&gt;@qq&lt;/span&gt;&lt;span&gt;.com  #设置报警邮件地址，可以设置多个，每行一个。需要开启sendmail服务。
    }
    notification_email_from sns&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;lvs&lt;span&gt;@gmail&lt;/span&gt;&lt;span&gt;.com
    smtp_server smtp.hysec.com   #设置SMTP Server地址
    smtp_connection_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;   #设置SMTP Server的超时时间
    router_id nginx_master       #表示运行Keepalived服务器的一个标识，唯一的
}
#检测脚本
vrrp_script chk_http_port {
    script &quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;src&lt;span&gt;/&lt;/span&gt;&lt;span&gt;check_nginx_pid.sh&quot; #心跳执行的脚本，检测nginx是否启动
    interval &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;                          #（检测脚本执行的间隔，单位是秒）
    weight &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;                            #权重
}
#vrrp 实例定义部分
vrrp_instance VI_1 {        
    state MASTER            # 指定keepalived的角色，MASTER为主，BACKUP为备
    interface eth0         # 当前进行vrrp通讯的网络接口卡(当前centos的网卡) 用ifconfig查看你具体的网卡
    virtual_router_id &lt;/span&gt;&lt;span&gt;66&lt;/span&gt;&lt;span&gt;    # 虚拟路由编号，主从要一直
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;            # 优先级，数值越大，获取处理请求的优先级越高
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;            # 检查间隔，默认为1s(vrrp组播周期秒数)
    #授权访问
    authentication {
        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信
        auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
    }
    track_script {
        chk_http_port            #（调用检测脚本）
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;152.200&lt;/span&gt;&lt;span&gt;            # 定义虚拟ip(VIP)，可多设，每行一个
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.3 修改keepalived从节点192.168.152.129的/etc/keepalived/keepalived.conf配置文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#全局配置
global_defs {
    notification_email {
         leeSmall&lt;/span&gt;&lt;span&gt;@qq&lt;/span&gt;&lt;span&gt;.com  #设置报警邮件地址，可以设置多个，每行一个。需要开启sendmail服务。
    }
    notification_email_from sns&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;lvs&lt;span&gt;@gmail&lt;/span&gt;&lt;span&gt;.com
    smtp_server smtp.hysec.com #设置SMTP Server地址
    smtp_connection_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt; #设置SMTP Server的超时时间
    router_id nginx_backup              # 设置nginx backup的id，在一个网络应该是唯一的
}
#检测脚本
vrrp_script chk_http_port {
    script &quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;src&lt;span&gt;/&lt;/span&gt;&lt;span&gt;check_nginx_pid.sh&quot; #心跳执行的脚本，检测nginx是否启动
    interval &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;                          #（检测脚本执行的间隔）
    weight &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;                            #权重
}
#vrrp 实例定义部分
vrrp_instance VI_1 {
    state &lt;/span&gt;&lt;span&gt;BACKUP&lt;/span&gt;&lt;span&gt;                        # 指定keepalived的角色，MASTER为主，BACKUP为备
    interface eth0                      # 当前进行vrrp通讯的网络接口卡(当前centos的网卡) 用ifconfig查看你具体的网卡
    virtual_router_id &lt;/span&gt;&lt;span&gt;66&lt;/span&gt;&lt;span&gt;                # 虚拟路由编号，主从要一直
    priority &lt;/span&gt;&lt;span&gt;99&lt;/span&gt;&lt;span&gt;                         # 优先级，数值越大，获取处理请求的优先级越高
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;                        # 检查间隔，默认为1s(vrrp组播周期秒数)
    #授权访问
    authentication {
        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信
        auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
    }
    track_script {
        chk_http_port                   #（调用检测脚本）
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;152.200&lt;/span&gt;&lt;span&gt;                   # 定义虚拟ip(VIP)，可多设，每行一个
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.4 检查nginx是否启动的shell脚本&lt;/h3&gt;
&lt;p&gt;/usr/local/src/check_nginx_pid.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!&lt;span&gt;/&lt;/span&gt;bin&lt;span&gt;/&lt;/span&gt;&lt;span&gt;bash
#检测nginx是否启动了
A&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;`ps &lt;span&gt;-&lt;/span&gt;C nginx &lt;span&gt;--&lt;/span&gt;&lt;span&gt;no-header |wc -l`        &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt; $A -eq 0 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;    #如果nginx没有启动就启动nginx                        
      &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;nginx&lt;span&gt;/&lt;/span&gt;sbin&lt;span&gt;/&lt;/span&gt;&lt;span&gt;nginx                #重启nginx
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt; `ps -C nginx --no-header |wc -l` -eq 0 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;    #nginx重启失败，则停掉keepalived服务，进行VIP转移
              killall keepalived                    
      fi
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5 192.168.152.130（keepalived主节点）和 192.168.152.129（keepalived从节点）的nginx的配置文件nginx.conf&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;user&lt;/span&gt;&lt;span&gt; root root; #使用什么用户启动NGINX 在运行时使用哪个用户哪个组
worker_processes &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;; #启动进程数，一般是1或8个，根据你的电脑CPU数，一般8个
worker_cpu_affinity &lt;/span&gt;&lt;span&gt;00000001&lt;/span&gt; &lt;span&gt;00000010&lt;/span&gt; &lt;span&gt;00000100&lt;/span&gt; &lt;span&gt;00001000&lt;/span&gt;&lt;span&gt;; #CPU逻辑数——把每个进程分别绑在CPU上面，为每个进程分配一个CPU
#pid &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;nginx&lt;span&gt;/&lt;/span&gt;logs&lt;span&gt;/&lt;/span&gt;&lt;span&gt;nginx.pid
worker_rlimit_nofile &lt;/span&gt;&lt;span&gt;102400&lt;/span&gt;&lt;span&gt;; #一个进程打开的最大文件数目，与NGINX并发连接有关系

#工作模式及连接数上限
events
{
  &lt;/span&gt;&lt;span&gt;use&lt;/span&gt; epoll; #多路复用IO 基于LINUX2.6以上内核，可以大大提高NGINX的性能 uname &lt;span&gt;-&lt;/span&gt;&lt;span&gt;a查看内核版本号
  worker_connections &lt;/span&gt;&lt;span&gt;102400&lt;/span&gt;; #单个worker process最大连接数,其中NGINX最大连接数＝连接数&lt;span&gt;*&lt;/span&gt;&lt;span&gt;进程数,一般1GB内存的机器上可以打开的最大数大约是10万左右
  multi_accept &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;;   #尽可能多的接受请求，默认是关闭状态
}

#处理http请求的一个应用配置段
http
{
  #引用mime.types,这个类型定义了很多，当web服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的MIME配置文件中找到对应的MIME #Type，根据MIMETYPE设置并response响应类型（Content&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;type）
  include       mime.types; 
  default_type  application&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;octet&lt;span&gt;-&lt;/span&gt;&lt;span&gt;stream; #定义的数据流，有的时候默认类型可以指定为text,这跟我们的网页发布还是资源下载是有关系的
  fastcgi_intercept_errors &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;; #表示接收fastcgi输出的http &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt; response code
  charset utf&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
  server_names_hash_bucket_size &lt;/span&gt;&lt;span&gt;128&lt;/span&gt;&lt;span&gt;; #保存服务器名字的hash表
  #用来缓存请求头信息的，容量4K，如果header头信息请求超过了，nginx会直接返回400错误，先根据client_header_buffer_size配置的值分配一个buffer，如果##分配的buffer无法容纳request_line&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;request_header，那么就会##再次根据large_client_header_buffers配置的参数分配large_buffer，如果large_buffer还是无#法容纳，那么就会返回414（处理request_line）&lt;span&gt;/&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;（处理request_header）错误。
  client_header_buffer_size 4k; 
  large_client_header_buffers &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt; 32k;
  client_max_body_size 300m; #允许客户端请求的最大单文件字节数 上传文件时根据需求设置这个参数
  #指定NGINX是否调用这个函数来输出文件，对于普通的文件我们必须设置为ON，如果NGINX专门做为一个下载端的话可以关掉，好处是降低磁盘与网络的IO处理数及#系统的UPTIME
  sendfile &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;; 
  #autoindex &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;;开启目录列表访问，适合下载服务器
  tcp_nopush &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;; #防止网络阻塞
  #非常重要，根据实际情况设置值，超时时间，客户端到服务端的连接持续有效时间，60秒内可避免重新建立连接，时间也不能设太长，太长的话，若请求数10000##，都占用连接会把服务托死
  keepalive_timeout &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
  tcp_nodelay &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;; #提高数据的实时响应性
  client_body_buffer_size 512k; #缓冲区代理缓冲用户端请求的最大字节数（请求多）
  
  proxy_connect_timeout   &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;; #nginx跟后端服务器连接超时时间（代理连接超时）
  proxy_read_timeout      &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;; #连接成功后，后端服务器响应时间(代理接收超时)
  proxy_send_timeout      &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;; #后端服务器数据回传时间(代理发送超时)
  proxy_buffer_size       16k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小
  proxy_buffers           &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt; 64k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
  proxy_busy_buffers_size 128k; #高负荷下缓冲大小
  proxy_temp_file_write_size 128k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传

  gzip &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;; #NGINX可以压缩静态资源，比如我的静态资源有10M，压缩后只有2M，那么浏览器下载的就少了
  gzip_min_length  1k;
  gzip_buffers     &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt; 16k;
  gzip_http_version &lt;/span&gt;&lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;;
  gzip_comp_level &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;; #压缩级别大小,最小1,最大9.值越小,压缩后比例越小,CPU处理更快,为1时,原10M压缩完后8M,但设为9时,压缩完可能只有2M了。一般设置为2
  gzip_types       &lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;plain application&lt;span&gt;/&lt;/span&gt;x&lt;span&gt;-&lt;/span&gt;javascript &lt;span&gt;text&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;css application&lt;span&gt;/&lt;/span&gt;xml; #压缩类型:&lt;span&gt;text&lt;/span&gt;&lt;span&gt;,js css xml 都会被压缩
  gzip_vary &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;; #作用是在http响应中增加一行目的是改变反向代理服务器的缓存策略

#日志格式 
log_format  main &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; #ip 远程用户 当地时间  请求URL
                 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$status $body_bytes_sent &quot;$http_referer&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; #状态  发送的大小  响应的头
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;$http_user_agent&quot; $request_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; #客户端使用的浏览器  页面响应的时间

#动态转发         
upstream web1 {
    #每个请求按访问ip的hash结果分配,这样每个访客固定访问一个后端服务器,可以解决session的问题。配置了ip_hash就没有负载均衡的效果了，每次访问的都是同一个tomcat
    #ip_hash; 
    #转发的后端的tomcat服务器,weight表示转发的权重,越大转发的次数越多,机器性能不一样配置的weight值不一样     
     server   &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;152.129&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; weight&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; max_fails&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fail_timeout&lt;span&gt;=&lt;/span&gt;&lt;span&gt;30s;
     server   &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;152.129&lt;/span&gt;:&lt;span&gt;8081&lt;/span&gt; weight&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; max_fails&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fail_timeout&lt;span&gt;=&lt;/span&gt;&lt;span&gt;30s;
}
upstream web2 {
     server   &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;152.129&lt;/span&gt;:&lt;span&gt;8090&lt;/span&gt; weight&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; max_fails&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fail_timeout&lt;span&gt;=&lt;/span&gt;&lt;span&gt;30s;
     server   &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;152.129&lt;/span&gt;:&lt;span&gt;8091&lt;/span&gt; weight&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; max_fails&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fail_timeout&lt;span&gt;=&lt;/span&gt;&lt;span&gt;30s;
}

server {
    listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;; #监听80端口
    server_name  www.dbspread.com; #域名
    #rewrite规则
    &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;  &lt;span&gt;index&lt;/span&gt;.jsp &lt;span&gt;index&lt;/span&gt;.html &lt;span&gt;index&lt;/span&gt;&lt;span&gt;.htm;
    root   &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;nginx&lt;span&gt;/&lt;/span&gt;&lt;span&gt;html; #定义服务器的默认网站根目录位置
    #重定向
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($host &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.dbspread.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ){ 
            rewrite &lt;/span&gt;&lt;span&gt;^/&lt;/span&gt;(.&lt;span&gt;*&lt;/span&gt;)$  http:&lt;span&gt;//&lt;/span&gt;www.dbspread.com&lt;span&gt;/&lt;/span&gt;$&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;permanent&lt;/span&gt;&lt;span&gt;;
            }

    #防盗链
     location &lt;/span&gt;&lt;span&gt;~*&lt;/span&gt; \.(rmvb&lt;span&gt;|&lt;/span&gt;jpg&lt;span&gt;|&lt;/span&gt;png&lt;span&gt;|&lt;/span&gt;swf&lt;span&gt;|&lt;/span&gt;flv)$ { #rmvb&lt;span&gt;|&lt;/span&gt;jpg&lt;span&gt;|&lt;/span&gt;png&lt;span&gt;|&lt;/span&gt;swf&lt;span&gt;|&lt;/span&gt;flv表示对rmvb&lt;span&gt;|&lt;/span&gt;jpg&lt;span&gt;|&lt;/span&gt;png&lt;span&gt;|&lt;/span&gt;swf&lt;span&gt;|&lt;/span&gt;&lt;span&gt;flv后缀的文件实行防盗链
                valid_referers none blocked  www.dbspread.com; #表示对www.dbspread.com此域名开通白名单，比如在www.test.com的index.html引用download&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;av123.rmvb,无效
                root   html&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;b;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ($invalid_referer) { #如果请求不是从www.dbspread.com白名单发出来的请求，直接重定向到403.html这个页面或者返回403 
                     #rewrite &lt;/span&gt;&lt;span&gt;^/&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;www.dbspread.com&lt;span&gt;/&lt;/span&gt;&lt;span&gt;403&lt;/span&gt;&lt;span&gt;.html;
                     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;403&lt;/span&gt;&lt;span&gt;;
                }
        }
        
    #监听完成以后通过斜杆(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;)拦截请求转发到后端的tomcat服务器
    location &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt; 
        {
            #如果后端的服务器返回502、&lt;/span&gt;&lt;span&gt;504&lt;/span&gt;&lt;span&gt;、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。
            proxy_next_upstream http_502 http_504 error timeout invalid_header;
            proxy_set_header Host  $host; #获取客户端的主机名存到变量Host里面,从而让tomcat取到客户端机器的信息
            proxy_set_header X&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Real&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;IP $remote_addr; #获取客户端的主机名存到变量X&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Real&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;IP里面,从而让tomcat取到客户端机器的信息
            proxy_set_header X&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;Forwarded&lt;span&gt;-&lt;/span&gt;&lt;span&gt;For&lt;/span&gt;&lt;span&gt; $proxy_add_x_forwarded_for;
            #rewrite     &lt;/span&gt;&lt;span&gt;^/&lt;/span&gt;$    http:&lt;span&gt;//&lt;/span&gt;www.dbspread.com&lt;span&gt;/&lt;/span&gt;new.&lt;span&gt;index&lt;/span&gt;.html  &lt;span&gt;permanent&lt;/span&gt;;#用户访问www.dbspread.com，想直接跳转到网站下面的某个页面:www.dbspread.com&lt;span&gt;/&lt;/span&gt;new.&lt;span&gt;index&lt;/span&gt;&lt;span&gt;.html
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;web1; #跳转到对应的应用web1
        }

       # location &lt;/span&gt;&lt;span&gt;~&lt;/span&gt; .&lt;span&gt;*&lt;/span&gt;\.(php&lt;span&gt;|&lt;/span&gt;jsp&lt;span&gt;|&lt;/span&gt;cgi&lt;span&gt;|&lt;/span&gt;shtml)?$ #动态分离 &lt;span&gt;~&lt;/span&gt;匹配 以.&lt;span&gt;*&lt;/span&gt;&lt;span&gt;结尾（以PHP JSP结尾走这段）
       #  {
       #     proxy_set_header Host  $host;
       #        proxy_set_header X&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Real&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;IP $remote_addr;
       #        proxy_set_header X&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;Forwarded&lt;span&gt;-&lt;/span&gt;&lt;span&gt;For&lt;/span&gt;&lt;span&gt; $proxy_add_x_forwarded_for;
       #        proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jvm_web2;
       # }

        #静态分离 &lt;/span&gt;&lt;span&gt;~&lt;/span&gt;匹配 以.&lt;span&gt;*&lt;/span&gt;结尾（以html&lt;span&gt;|&lt;/span&gt;htm&lt;span&gt;|&lt;/span&gt;gif&lt;span&gt;|&lt;/span&gt;jpg&lt;span&gt;|&lt;/span&gt;jpeg&lt;span&gt;|&lt;/span&gt;bmp&lt;span&gt;|&lt;/span&gt;png&lt;span&gt;|&lt;/span&gt;ico&lt;span&gt;|&lt;/span&gt;txt&lt;span&gt;|&lt;/span&gt;js&lt;span&gt;|&lt;/span&gt;&lt;span&gt;css结尾走这段），当然不是越久越好，如果有10000个用户在线，都保存几个月，系统托跨
        location &lt;/span&gt;&lt;span&gt;~&lt;/span&gt; .&lt;span&gt;*&lt;/span&gt;\.(html&lt;span&gt;|&lt;/span&gt;htm&lt;span&gt;|&lt;/span&gt;gif&lt;span&gt;|&lt;/span&gt;jpg&lt;span&gt;|&lt;/span&gt;jpeg&lt;span&gt;|&lt;/span&gt;bmp&lt;span&gt;|&lt;/span&gt;png&lt;span&gt;|&lt;/span&gt;ico&lt;span&gt;|&lt;/span&gt;txt&lt;span&gt;|&lt;/span&gt;js&lt;span&gt;|&lt;/span&gt;&lt;span&gt;css)$ 
        {
            root &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;&lt;span&gt;static; #静态资源存放在nginx的安装机器上
            #proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.static.com; #静态资源也可存放在远程服务器上
            expires    30d;
        }

        #日志级别有&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;debug|info|notice|warn|error|crit&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  error_log 级别分为 debug, info, notice, warn, error, crit  默认为crit, 生产环境用error 
        #crit 记录的日志最少,而debug记录的日志最多
        access_log  &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;logs&lt;span&gt;/&lt;/span&gt;web2&lt;span&gt;/&lt;/span&gt;access.&lt;span&gt;log&lt;/span&gt;&lt;span&gt; main;
        error_log   &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;logs&lt;span&gt;/&lt;/span&gt;web2&lt;span&gt;/&lt;/span&gt;error.&lt;span&gt;log&lt;/span&gt;&lt;span&gt;  crit;

    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 到这一步环境准备已完成，相关的配置也修改完成，下面我们来查看效果&lt;/p&gt;
&lt;h2&gt;5.6 配置hosts域名映射&lt;/h2&gt;
&lt;p&gt;192.168.152.129 www.dbspread.com&lt;br/&gt;192.168.152.130 www.dbspread.com&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：这里一定要配置域名www.dbspread.com映射到129和130两个虚拟机的ip，因为nginx.conf里面配置了rewrite重定向，如果不配置就看不到效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;到这一步环境准备已完成，相关的配置也修改完成，下面我们来查看效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;5.7 分别启动192.168.152.129的两个tomcat&lt;/h2&gt;
&lt;h3&gt;5.8 分别启动192.168.152.130（keepalived主节点）和 192.168.152.129（keepalived从节点）的keepalived的&lt;/h3&gt;
&lt;p&gt; 启动命令：/usr/local/keepalived/sbin/keepalived&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725013221058-424087780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到keepalived和nginx都启动了&lt;/p&gt;
&lt;p&gt;在浏览器输入www.dpspread.com域名访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725013403536-980729159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.9 下面我们停掉主节点192.168.152.130的keepalived和nginx&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725013853649-564478841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到从节点变为主节点了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725013824287-1372115709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在浏览器输入地址www.dpspread.com访问，可以看到访问正常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725013938452-1484556033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.10 下面我们重新启动主节点192.168.152.130&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725014146299-1601238959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到主节点重新启动以后变为主节点了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725014237088-1325937661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前变为主节点的从节点又变回从节点了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201807/1227483-20180725014342539-739812152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 24 Jul 2018 17:50:00 +0000</pubDate>
<dc:creator>小不点啊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leeSmall/p/9356535.html</dc:identifier>
</item>
<item>
<title>Optaplanner规划引擎的工作原理及简单示例(2) - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/9362859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/9362859.html</guid>
<description>&lt;h2&gt;开篇&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在前面一篇关于规划引擎Optapalnner的文章里（&lt;a href=&quot;https://www.jianshu.com/p/f9ec79916794&quot; target=&quot;_blank&quot;&gt;Optaplanner规划引擎的工作原理及简单示例(1)&lt;/a&gt;），老农介绍了应用Optaplanner过程中需要掌握的一些基本概念，这些概念有且于后面的内容的理解，特别是关于将约束应用于业务规则上的理解。承上一文，在本篇中将会减一些理论，而是偏向于实践，但过程中，借助实际的场景对一些相关的理论作一些更细致的说明，也是必要的。本文将会假设我们需要对一个车间，需要制定生产计划.我们为生产计划员们设计一套智能的、自动的计划系统；并通过Optaplanner把这个自动计划系统开发出来。当然，里面的业务都是经过高度抽象形成的，去除了复杂的业务规则，仅保留可以体现规划引擎作用的一些业务需求。因此，这次我们只用一个简单的小程序即可以演绎一个自动计划系统，来呈现规划引擎Optaplanner在自动计划上的魅力。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;“项目”背景与业务规则的分类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;假如我们接到一个项目，经过需求调研之后，发现其业务逻辑非常简单；但细想一下业务操作却又是异常复杂（先别砸砖，听老农缪缪道来）。它是一个生产计划系统（应该说是一个生产计划辅助系统，毕竟最终的计划，应该是人来决定，而非系统），在没有这个系统之前，计划人员（生产调试员）每天收到需要加工的生产任务之后，根据当时的机台产能情况，将这些待处理的任务&lt;strong&gt;合理地&lt;/strong&gt;分配到&lt;strong&gt;适合的&lt;/strong&gt;机台。对于前面这句对计划制定工作的描述，其实可以细作提练，其隐含了两个意义，分别是&lt;strong&gt;“合理地”&lt;/strong&gt;和分配到&lt;strong&gt;“合适的”&lt;/strong&gt;机台。对于这两个意义，我们可以把它区分为两种个方面的业务要求：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;“合适的机台” - 表示&lt;strong&gt;确定性的条件&lt;/strong&gt;判断，是一个定性的断言，也就是非对即错。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;“合理地” - 表示&lt;strong&gt;非确定性的条件&lt;/strong&gt;，也就是定量的，可以是非常合理，60%的合理，或完全合理，也就是说是否合理，还是有议论空间的，并没有一个完全固定的标准。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面将对上述两项进行更深入的讨论。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;确定性条件（定性）&lt;/h2&gt;
&lt;p&gt;　 &lt;span&gt;对于上述提到的这两个条件，其中“分配到合理机台”是相对确定的命题，只要向计划人员提供合理机台的条件指引，计划人员根据这些条件进行操作，总有一天能把所有的任务，匹配上所有条件的，只是时间问题。例如：A类任务只能放在可以处理A类任务的机台上加工；但也可能会更复杂，例如：来自某些客户的、且具有特定工一要求的、且生产量在指定范围内的, 且...,且.....，你可以一直&quot;且&quot;下去，令这些条件非常复杂。但无论怎么复杂，这些条件是具有确定性的判断标准，也就是说，不管有多复杂，只要能识别出来的条件，生产计划人员就可以根据这些条件进行分配；当然实际生产活动中，必然会遇到一些问题，当一些任务与机台的匹配条件非常复杂时：一来会令工作效率骤降；再就是人是有可能出错的，比较容易出问题的；甚至超出人的处理能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在本文，我们仅仅是为了让程序可以体现这种确定性条件的处理方法，我们把这类条件简化到最极端的情况：只有一个条件，只要机台可处理的任务类型，与任务自己的类型合适即表示机台与任务匹配。例如：有个机台M1可以做的T1, T2,这两种任务，机台2可以做T2，T3两种任务；那么，如果一个任务它是属于T1类型，则合适的机台只有M1, 如果这个任务是T3类型，则它的合适机台只有M2；如果这个任务是T2类型，则合适的机台有M1,M3两台。凡是把任务分配应类别的机台上去，都是合适的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;非确定性条件（定量）    &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;非确定性条件，相对复杂一点，因为这类条件是没有绝对的对错，只有相对的优劣。例如本文中我们会使用&lt;em&gt;&lt;strong&gt;成本&lt;/strong&gt;&lt;/em&gt;这个条件因素，在确保上面的确定性因素（任务类型与机台匹配）前提下，成本越低越好。那么就存在多个可行方案的的可能，就会涉及到应该如何计算成本，用哪些方案的成本进行对比才是合理的问题。要理清这些问题，需要对业务模型有深入的理解，并能很准确地对这些因素进行归纳，把它们抽象成约束条件。为了简化问题，在本例中，成本反映在机台的启用成本上。也就是说，每个机台一旦启动它都会产生固定成本，而不会随着任务量增多而成本上升。所以作为计划定制人员，如果这是一个计划的重要指标的话，在制定计划时，就需要考虑应该如何统计一个机台的成本。本例中我们假定生个机台一旦启动，即产生固定的成本，所以我们的目标是：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;用尽量小的机台来完成尽量多的任务.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这些被启用的机台，其成本尽可能低；即优先使用低成本的机台来处理任务。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;当然，因应不同的场景，会有其它的要求，例如产能平衡：令尽可能多的机台被启用，以减少少空置率，搞提生产效率。本例中我们并没有使用此规则。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;设计与测试数据&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;为了满足上述条件，我们先建立业务模型。我们先识别出业务实体。可以识别出来的实体也只有两个，&lt;strong&gt;机台&lt;/strong&gt;和&lt;strong&gt;任务&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;机台&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;我们假设有6个机台，分别是M1- M6, 它们分别有自己可处理的任务类型：Type_A，Type_B, Type_C 和 Type_D, 且分别有自己的&lt;strong&gt;产能&lt;/strong&gt;和&lt;strong&gt;成本&lt;/strong&gt;。产能表示这个机台在固定时间段内，最多可以处理的任务量；成本表示如果这个机台一旦开启，即产生相应的货币成本。例如：机台M1, &lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;它可以处理类型为Type_A的任务（也就是说，它可以和产类型为Type_A的产品）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在固定时间段内（例如一个班次，或一天）可以处理300个任务，即产能为300。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;它的成本为100, 即它一旦被启动，即产生100元的成本.&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;所有机台资料如下图，可以看到，有些机台它的可处理的任务类型是相同的，但两者的产能不同；有些可处理的任务类型相同，产能也相同，但成本不同；这样就进一步贴近实况。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/5496267-8634760b3f9348e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;&lt;span&gt;机台列表&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;任务(产品)&lt;/h2&gt;
&lt;p&gt;　 &lt;span&gt;对于需要加工的产品(工称工件)，我们把它抽象成任务，因为对于一个车间中的机台而言，以任务来识别它更贴切一些，在实际的业务建模中，一个产品不一定是一个任务，也有可能是一个产品的工序路线中的其中一个工序被定义为一个任务，即表示一个生产单位的一个生产指令, 例如：对机器外壳打孔。而在本例中，我们了为简化问题，我们假设一个任务就一个产品，每个产品只需一个任务即可。而关于一个产品存在一条完整且复杂的工序路线，从而产生多个生产任务的情况，我将在以后的文章中，关于Optaplanner的更高级的应用中，将会有相关的详细讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于任务（产品），我们的假设它具有类型和生产量两个属性。类型-表示它是属于哪一类的产品，用于识别它可以被分配到哪一个机台进行加工处理。生产量-表示这个产品需要生产多少个，当这个产品被分配到指定的机台上生产的时候，生产量这个属性将会与对应机台的产能作出对比与限制，即一个任务如果生产量超过了一个机台的产能，那么这个任务就无法放在这个机台上处理。所有任务（10个）的资料如下图：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/5496267-7901dc6f457baafc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;&lt;span&gt;任务列表&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;约束&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;假如我们已经通过需求调研，确定了我们上述机台与任务两个业务实体，那么，下一步的调研目标，就是要识别出在这些任务分配到机台上的过程中，按照生产业务要求，我们需要遵循哪些规则了。本例我们假设有以下业务规则，以下称为约束，其中包括硬约束（不可违反），和软约束（尽量不要违反，但将不可避免；如果违反，尽可能令违反的程度减到最小）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;硬约束：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;任务只能被分配到可以处理它的机台上，以机台的“可处理任务类型”字段与任务的“类型”字段作识别，两者一致才符合条件；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个机台处理的任务的生产量总和不能超过其产能。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;软约束：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt; 整个排产计划中，所有启用的机台成本之和尽量小。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;通过上述约束的描述，可以得知，其中两个硬约束是可以避免的，但软约束是不可避免的，因为你处理任务必须启动机台，一旦启动任意机台，都会产生成本。因此，软约束的要求是尽量小，而不是不违反，不是0.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;任务分本问题的解决方法(暴力穷举法与Optaplanner)&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;以下为理论部分，无兴趣探讨的同学可以跳过本小节。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本“项目”的业务场景、业务实体和业务规则，我们都已经构建完成，接下来就是如何在上述给定条件的基础上，构建一个快速可用的解决方案，用于解决任务的分配问题了。至此，可能有些同学在想，其实这并不难呀，根据给定的两个硬约束和一个软件约束，以两个硬约束作为限制条件，通过暴力穷举的方法，找出一个无限趋近于符合软约束，也可以找出一个令成本最低的任务分配方案出来呀。这是对的，只要我们有明确的软硬约束要求，理论上是可以写出对应的程序，通过强大的CPU算法，甚至可以将程序写成并发运算，集成数量庞大的GPU算力，兴许能找最终方案的。但是，有这种想法，其实忽略了问题的规模与时间复杂度的关系。我们需要探讨，随着数据量(即问题规模)的增大，找到可用分配方案的耗时增长有多大，与问题规模的增长呈何种比例关系。通过上述的条件，及排列组合的知识得知，通常这类问题的时间复杂度是指数级复杂度，即O(a^n)，甚至是阶乘级复杂度的,即O(n!)。当数据量有限增大之后，所需的运行时间增长，对目前技术上的计算机算力来讲，增长是指数级，甚至以今天的技术水平，是永远都无法找到最终方案的。这个在关于NPC或NP-Hard问题的文章中已有介绍，这里不再重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面对这类NP问题时，人类是如何解决的呢。其实人类目前也是无解的，如果哪位同学如果找到一个算法来解决这类问题，它的时间复杂度是常数级的，那么恭喜你，你已经为人类解决了不少难题了。而所谓的无解是指，无法在任何情况下找出一个绝对最优的解决方案（如果本例中的业务规则及数据量，用草稿纸都可以把所有情况列出来了，当然可以找出最优解,前提是你有足够耐性）.所以,人们想到的还是通过穷举的方法，一个一个的组合方案去尝试，直找到最佳方案。但这种方法在数据量增大，或更多判断条件的时候是不可行的，而我们日常处理这类问题（例如排生产计划），当找到的排产方案只要满足了所有硬约束(其实光是满足硬约束的方案，如果不通过程序来实现，人类也很难很快找到)；软约束方面只要找出一个差不多的，我们即可视作一个可用的方案并付诸执行了；因为我们不可能无限地找下去。而Optaplanner其实跟我们一样，问题规模足够大的情况下，它也是不可能找出绝对最优方案的。但是它相对人类聪明之处在于，它集成了寻找最优方案的过程诸多专门的算法。过程中使用了分阶段，分步骤的方法将问题归约成一些数学模型可处理的形式。且在寻找最佳方案（应该是寻找更佳方案）的过程中，它集成了一堆已被证明卓有成效的数学寻优算法，例如在问题初始化阶段可以使用First Fit, First Fit Decreasing等算法，在寻优阶段使用禁忌搜索法、模拟退火法等算法。从而极大地提高寻找更优方案的效率。令其在相同的时间内，找到的方案相对人类，或者相对不使用任何算法的暴力穷举法而言，质量高得多，更趋近于最优方案。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;用Optaplanner解决任务分配问题&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;通过Optaplanner寻找更佳分配方案，需要建立相关的类和模型，英语还可以的同学，可以直接上去它的使用说明中查看&lt;a href=&quot;https://docs.optaplanner.org/7.8.0.Final/optaplanner-docs/html_single/index.html#quickStart&quot; target=&quot;_blank&quot;&gt;Cloud Balance&lt;/a&gt;示例，是一个非常好的示例，从最简单的Hellow world, 到使用了Real-time planning等近几个版本新功能，都有详细的说明与教程。我们现在这个示例也是参它来设计的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在开始设计之前，我们需要构思一下，我们的任务分配是如何实现的。在我们的实际计划制定的业务操作中，也就是工厂的车间里，计划员是把一个产品的实物，喂进一个机台，让机台对它进行处理。所以我们会理解为：分配就是把上面10个任务分配到6个机台中。其实这样做是可行的，但我们更深入地思考一下，其实我们需要处理的是任务，而不是机台，也就是说，每个任务必须都被分配到一个机台中处理，而机台不一定。在最小化成本的原则底下，好的方案有可能出现有部分机台并没有分得任务的情况。所以，我们需要把任务与机台的关系倒过来，把任务作为我们的研究目标，理解为把一个机台分给一个任务。做过生产计划或生产管理的同学就很清楚知道，机台也是一种生产资源，针对不同的生产任务，将资源应用到这些任务上去，其中机台（或产线）是一个很常见的资源类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们的设计思路是：针对一个任务，把一个适合的机台分配给它，令它满足两个条件：1. 满足所有硬约束； 2.分配好所有任务的机台之后，这些机台的成本加总尽量低。好了，理清了思路，下面我们就可以开始设计了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;按Optaplanner规范建模&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;要使用Optaplanner规划引擎，就需要按它的要求建立对应的模型，包括各种类及其关系。我们这个示例跟官网上的Cloud Balance几乎一致，在它的类图基础上修改就可以了。我们先看看建立好的class diagrame如下图：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/5496267-4250eab5ef2b2c70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;要建立的类分别是&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Task，表示任务的实体类，它被注解为@PlanningEntity， 它有三个属性：taskType - 当前任务的类型； quantity - 生产量；machine - 任务将要被分配到的机台。其中machine属性被注解为@PlanningVariable, 表示规划过程中，这个属性的值将被plan的，即通过调整这个属性来得到不同的方案。另外，作为一个Planning Entity, 它必须有一个ID属性，用于在规划运行过程中识别不同的对象，这个ID属性被注解为@PlanningId。 本例中所有实体类都继承了一个通用的类 - AbstractPersistable， 该父类负责维护此所有对象的ID。Task类也继承于它，因此，将该类的ID属性注解为@PlanningId即可。另外，作为Planning Entity, 它必须有一无参构造函数，若你在此类实现了有参构造的话，需要显式地实现一个无参构造函数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Machine, 表示机台的实体类，它属于&lt;a href=&quot;https://docs.optaplanner.org/7.8.0.Final/optaplanner-docs/html_single/index.html#problemFact&quot; target=&quot;_blank&quot;&gt;ProblemFact&lt;/a&gt;，在其中保存了在规划过程中会用到的属性，此类反映一个机台相关信息的属性： taskType - 可处理的任务类型； capacity - 当前机台的产能; cost -当前机台的成本。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;TaskAssignment, 此类用来描述整个解决方案的固定类，它的结构描述了问题的各种信息，在Optaplanner术语中，在执行规划前，它的对象被称作一个Problem, 完成规划并获得输出之后，输出的TaskAssignment对象被称作一个Solution。它具有固定的特性要求： 必须被注解为@PlanningSolution；本例中，它至少有三个属性： machineList - 机台列表，就是可以用于分配任务的机台，本例中指的就是上述那6个机台；taskList - 就是需要被规划（或称分配机台）的10个任务，这个属性需要被注解为@PlanningEntityCollectionPropery. 还有一个是score属性，它用于在规划过程中对各种约束的违反情况进行打分，因为本例中存在了硬约束与软约束。因此我们使用的Score为 &lt;a href=&quot;https://docs.optaplanner.org/7.8.0.Final/optaplanner-docs/html_single/index.html#hardSoftScore&quot; target=&quot;_blank&quot;&gt;HardSoftScore&lt;/a&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;另外，上述提到了一个的有实体类（本例只有Task与Machine为实体类）的父类AbstractPersistable， 它负责维护ID属性，对实体类的compareTo方法，toString方法进行重载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的代码如下,没有Maven基础的同学，请先自补一下Maven的知识，以下内容都是基于Maven的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Task类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_639f10e2-5b96-4ec3-97ed-99022530d88e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_639f10e2-5b96-4ec3-97ed-99022530d88e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_639f10e2-5b96-4ec3-97ed-99022530d88e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.entity.PlanningEntity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.variable.PlanningVariable;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@PlanningEntity
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Task  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractPersistable{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String requiredYarnType;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Machine machine;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRequiredYarnType() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; requiredYarnType;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRequiredYarnType(String requiredYarnType) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.requiredYarnType =&lt;span&gt; requiredYarnType;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAmount() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; amount;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAmount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.amount =&lt;span&gt; amount;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     @PlanningVariable(valueRangeProviderRefs={&quot;machineRange&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Machine getMachine() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; machine;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMachine(Machine machine) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.machine =&lt;span&gt; machine;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task(){}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Task(&lt;span&gt;int&lt;/span&gt; id, String requiredYarnType, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(id);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.requiredYarnType =&lt;span&gt; requiredYarnType;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.amount =&lt;span&gt; amount;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;Machine类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_1c418d39-da5d-4158-b06b-0f56ea5145e4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1c418d39-da5d-4158-b06b-0f56ea5145e4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1c418d39-da5d-4158-b06b-0f56ea5145e4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Machine &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractPersistable{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String yarnType;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cost;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getYarnType() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; yarnType;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setYarnType(String yarnType) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.yarnType =&lt;span&gt; yarnType;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCapacity() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCapacity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCost() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cost;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCost(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cost) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cost =&lt;span&gt; cost;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Machine(&lt;span&gt;int&lt;/span&gt; id, String yarnType, &lt;span&gt;int&lt;/span&gt; capacity, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cost) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(id);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.yarnType =&lt;span&gt; yarnType;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cost =&lt;span&gt; cost;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;TaskAssignment类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_85aabb95-9a65-4db1-a993-0af08caeb3c3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_85aabb95-9a65-4db1-a993-0af08caeb3c3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_85aabb95-9a65-4db1-a993-0af08caeb3c3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.solution.PlanningScore;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.solution.PlanningSolution;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;

@PlanningSolution
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TaskAssignment &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractPersistable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HardSoftScore score;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Machine&amp;gt;&lt;span&gt; machineList;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Task&amp;gt;&lt;span&gt; taskList;
    
    @PlanningScore
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HardSoftScore getScore() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; score;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setScore(HardSoftScore score) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.score =&lt;span&gt; score;
    }
    @ProblemFactCollectionProperty
    @ValueRangeProvider(id &lt;/span&gt;= &quot;machineRange&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Machine&amp;gt;&lt;span&gt; getMachineList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; machineList;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMachineList(List&amp;lt;Machine&amp;gt;&lt;span&gt; machineList) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.machineList =&lt;span&gt; machineList;
    }
    
    @PlanningEntityCollectionProperty
    @ValueRangeProvider(id &lt;/span&gt;= &quot;taskRange&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Task&amp;gt;&lt;span&gt; getTaskList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; taskList;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTaskList(List&amp;lt;Task&amp;gt;&lt;span&gt; taskList) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskList =&lt;span&gt; taskList;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TaskAssignment(List&amp;lt;Machine&amp;gt; machineList, List&amp;lt;Task&amp;gt;&lt;span&gt; taskList) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;super(0);&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.machineList =&lt;span&gt; machineList;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskList =&lt;span&gt; taskList;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TaskAssignment(){}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;AbstractPersistable类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_b44ce4d6-af16-454b-b605-a6cef1f242e7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b44ce4d6-af16-454b-b605-a6cef1f242e7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b44ce4d6-af16-454b-b605-a6cef1f242e7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.builder.CompareToBuilder;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.domain.lookup.PlanningId;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractPersistable &lt;span&gt;implements&lt;/span&gt; Serializable, Comparable&amp;lt;AbstractPersistable&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Long id;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AbstractPersistable() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; AbstractPersistable(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @PlanningId
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getId() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Long id) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(AbstractPersistable other) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompareToBuilder().append(getClass().getName(), other.getClass().getName()).append(id, other.id)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                .toComparison();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; getClass().getName().replaceAll(&quot;.*\\.&quot;, &quot;&quot;) + &quot;-&quot; +&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到目前为止，我们已完成了所有的Java代码了，注意，这里指的是Java代码,事实上要成功启动Optaplanner的规划引擎，只有Java代码是远远不够的。还需要更多的配置与其它内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于上述代码，眼尖的同学应该会看到，在TaskAssignment类中，machineList的getter - getMachineList(),除了被注解为@ProblemFactCollectionProperty, 还有另外一个注解@ValueRangeProvider(id=&quot;machineRange&quot;), 满脑疑惑的同学先不急，大家再看看Task类的machine成员的getter - getMachine()。奇怪了上文不是提到，它只需被注解为@PlanningVariable的吗？怎么后面还有个参数呢，整个注解是@PlanningEntity(valueRangeProviderRefs={&quot;machineRange&quot;}), 没错了，大家应该猜到，这两个注解的意义了。它们的意义是：对于每个Planning Entity (task) 对象中的PlanningVariable(machine)，它的取值范围是TaskAssignment对象中的machineList中的内容。从业务上讲，就是说，对于每一个任务而言，它可以分配的机台，是那6个机台之一。这样大家是否恍然大悟呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，上面已经巧妙地通过各个注解，将Planning Entity, Problem Fact和Problem等对象关联起来，那么大家是不是觉得有些地方漏了？对了，那就是约束规则（2硬1软的约束）如何在这些类的关系中体现呢？其实上面这些类关系是没办法表达这些业务约束的；如果需要表达这些约束，还需要创建一些用于计分数的类，用于对每个约束的违反情况进行记分。但自从Optaplanner与&lt;a href=&quot;https://www.drools.org/&quot; target=&quot;_blank&quot;&gt;Drools(一个开源规则引擎)&lt;/a&gt;结合之后，就不再需要自己通过Java代码编写算分逻辑了（当然你也可以不用Drools，自行编写算分逻辑）,只需要通过Drools表达业务约束，Optaplanner在规划过程中，会启自行启动Drools规划引擎对这些约束进行判断，从而进行计分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们只需要在resource里添加一个Drools脚本文件，用于描述这些约束即可。至于Drools的应用，不在本文范围，同学们可以自行学习Drools，如有需要，我将会撰写另外一个Drools应用相关的系列文章 .&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rules.drl文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.solver;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain.Task;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain.Machine;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain.TaskAssignment;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;global HardSoftScoreHolder scoreHolder;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; rule &quot;yarnTypeMatch&quot;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;when
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Task(machine != &lt;span&gt;null&lt;/span&gt;, machine.yarnType !=&lt;span&gt; requiredYarnType)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;then
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     scoreHolder.addHardConstraintMatch(kcontext, -10000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; rule &quot;machineCapacity&quot;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;when
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    $machine : Machine($capacity : capacity)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    accumulate(
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        Task(
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             machine ==&lt;span&gt; $machine,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            $amount : amount);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        $amountTotal : sum($amount);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         $amountTotal &amp;gt;&lt;span&gt; $capacity
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;then
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     scoreHolder.addHardConstraintMatch(kcontext, $capacity -&lt;span&gt; $amountTotal);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; rule &quot;machineCost_used&quot;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;when
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    $machine : Machine($cost : cost)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     exists Task(machine ==&lt;span&gt; $machine)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;then
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     scoreHolder.addSoftConstraintMatch(kcontext, -&lt;span&gt;$cost);            
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好了，实体模型我们创建好了，约束也已通过Drools脚本表达出来了，Optapalnner是如何将两者结合起来，从而达到计分效果的呢？其实我们还是缺了一块，那就是Optaplanner的配置，因为需要创建Optaplanner的引擎对象进行规划的时候，是有一大堆参数需要指定给引擎的。按照Optaplanner的接口设计要求，需要设计一个称作Solvder Configuration的XML文件，用于描述引擎的参数及行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;taskassignmentConfiguration.xml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;solver&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Domain model configuration &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;solutionClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.apsbyoptaplanner.domain.TaskAssignment&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;solutionClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entityClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.apsbyoptaplanner.domain.Task&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entityClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Score configuration &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scoreDirectorFactory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scoreDrl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;taskAssignmentDools.drl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scoreDrl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scoreDirectorFactory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Optimization algorithms configuration &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;termination&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;secondsSpentLimit&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;secondsSpentLimit&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;termination&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;solver&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;好了，通过上述的步骤，一个Optaplanner程序基本上就完成了。且慢！一个Java程序竟然没有main入口？没错&lt;/span&gt;&lt;span&gt;，除了main入口外，我们还没有构建引擎对象并启动它呢。因为是示例，我就将构造引擎对象，业务实体对象都放在入口程序App里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;App.java代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.stream.Collectors;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.solver.Solver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.optaplanner.core.api.solver.SolverFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain.Machine;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain.Task;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.apsbyoptaplanner.domain.TaskAssignment;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        startPlan();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startPlan(){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         List&amp;lt;Machine&amp;gt; machines =&lt;span&gt; getMachines();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         List&amp;lt;Task&amp;gt; tasks =&lt;span&gt; getTasks();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         InputStream ins = App.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;/taskassignmentConfiguration.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         SolverFactory&amp;lt;TaskAssignment&amp;gt; solverFactory =&lt;span&gt; SolverFactory.createFromXmlInputStream(ins);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Solver&amp;lt;TaskAssignment&amp;gt; solver =&lt;span&gt; solverFactory.buildSolver();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         TaskAssignment unassignment = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskAssignment(machines, tasks);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;         TaskAssignment assigned =&lt;span&gt; solver.solve(unassignment);&lt;span&gt;//启动引擎
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt;         List&amp;lt;Machine&amp;gt; machinesAssigned =&lt;span&gt; assigned.getTaskList().stream().map(Task::getMachine).distinct().collect(Collectors.toList());
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Machine machine : machinesAssigned) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             System.out.print(&quot;\n&quot; + machine + &quot;:&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             List&amp;lt;Task&amp;gt; tasksInMachine = assigned.getTaskList().stream().filter(x -&amp;gt;&lt;span&gt; x.getMachine().equals(machine)).collect(Collectors.toList());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Task task : tasksInMachine) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 System.out.print(&quot;-&amp;gt;&quot; +&lt;span&gt; task);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;     
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Machine&amp;gt;&lt;span&gt; getMachines() {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 六个机台&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         Machine m1 = &lt;span&gt;new&lt;/span&gt; Machine(1, &quot;Type_A&quot;, 300, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         Machine m2 = &lt;span&gt;new&lt;/span&gt; Machine(2, &quot;Type_A&quot;, 1000, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         Machine m3 = &lt;span&gt;new&lt;/span&gt; Machine(3, &quot;TYPE_B&quot;, 1000, 300&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         Machine m4 = &lt;span&gt;new&lt;/span&gt; Machine(4, &quot;TYPE_B&quot;, 1000, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         Machine m5 = &lt;span&gt;new&lt;/span&gt; Machine(5, &quot;Type_C&quot;, 1100, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         Machine m6 = &lt;span&gt;new&lt;/span&gt; Machine(6, &quot;Type_D&quot;, 900, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;         List&amp;lt;Machine&amp;gt; machines = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Machine&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        machines.add(m1);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        machines.add(m2);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        machines.add(m3);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        machines.add(m4);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        machines.add(m5);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        machines.add(m6);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; machines;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Task&amp;gt;&lt;span&gt; getTasks(){
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10个任务&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;         Task t1 = &lt;span&gt;new&lt;/span&gt; Task(1, &quot;Type_A&quot;, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         Task t2 = &lt;span&gt;new&lt;/span&gt; Task(2, &quot;Type_A&quot;, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         Task t3 = &lt;span&gt;new&lt;/span&gt; Task(3, &quot;Type_A&quot;, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         Task t4 = &lt;span&gt;new&lt;/span&gt; Task(4, &quot;Type_A&quot;, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         Task t5 = &lt;span&gt;new&lt;/span&gt; Task(5, &quot;TYPE_B&quot;, 800&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         Task t6 = &lt;span&gt;new&lt;/span&gt; Task(6, &quot;TYPE_B&quot;, 500&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         Task t7 = &lt;span&gt;new&lt;/span&gt; Task(7, &quot;Type_C&quot;, 800&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         Task t8 = &lt;span&gt;new&lt;/span&gt; Task(8, &quot;Type_C&quot;, 300&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         Task t9 = &lt;span&gt;new&lt;/span&gt; Task(9, &quot;Type_D&quot;, 400&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         Task t10 = &lt;span&gt;new&lt;/span&gt; Task(10, &quot;Type_D&quot;, 500&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         List&amp;lt;Task&amp;gt; tasks = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Task&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        tasks.add(t1);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        tasks.add(t2);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        tasks.add(t3);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        tasks.add(t4);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        tasks.add(t5);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        tasks.add(t6);
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;        tasks.add(t7);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;        tasks.add(t8);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        tasks.add(t9);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;        tasks.add(t10);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tasks;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　 &lt;span&gt;好了，上述代码懂的同学应该不难理解，就是先构建一个Solver对象，一个taskList, 一个machineList；及一个taskAssignment对象，并taskAssignment对象对应的成员分别指向taskList与machineList. 然后就启动solver对象的solver方法。引擎就哄哄地被启动，去帮我们找最优解了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果配置好log组件，大家将会看到如下输出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;25.687&lt;/span&gt; [main] DEBUG     LS step (&lt;span&gt;26556&lt;/span&gt;), time spent (&lt;span&gt;9999&lt;/span&gt;), score (0hard/-800soft),     best score (0hard/-700soft), accepted/selected move count (&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;5&lt;/span&gt;), picked move (Task-&lt;span&gt;1&lt;/span&gt; {Machine-&lt;span&gt;2&lt;/span&gt;} &amp;lt;-&amp;gt; Task-&lt;span&gt;4&lt;/span&gt; {Machine-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}).
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;25.687&lt;/span&gt; [main] DEBUG     LS step (&lt;span&gt;26557&lt;/span&gt;), time spent (&lt;span&gt;9999&lt;/span&gt;), score (0hard/-800soft),     best score (0hard/-700soft), accepted/selected move count (&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;), picked move (Task-&lt;span&gt;3&lt;/span&gt; {Machine-&lt;span&gt;2&lt;/span&gt; -&amp;gt; Machine-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}).
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;25.688&lt;/span&gt; [main] DEBUG     LS step (&lt;span&gt;26558&lt;/span&gt;), time spent (&lt;span&gt;10000&lt;/span&gt;), score (0hard/-800soft),     best score (0hard/-700soft), accepted/selected move count (&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;22&lt;/span&gt;), picked move (Task-&lt;span&gt;3&lt;/span&gt; {Machine-&lt;span&gt;1&lt;/span&gt;} &amp;lt;-&amp;gt; Task-&lt;span&gt;4&lt;/span&gt; {Machine-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;}).
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;25.688&lt;/span&gt; [main] INFO  Local Search phase (&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;ended:&lt;/span&gt; time spent (&lt;span&gt;10000&lt;/span&gt;), best score (0hard/-700soft), score calculation speed (&lt;span&gt;31205&lt;/span&gt;/sec), step total (&lt;span&gt;26559&lt;/span&gt;&lt;span&gt;).
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;25.689&lt;/span&gt; [main] INFO  Solving &lt;span&gt;ended:&lt;/span&gt; time spent (&lt;span&gt;10001&lt;/span&gt;), best score (0hard/-700soft), score calculation speed (&lt;span&gt;30447&lt;/span&gt;/sec), phase total (&lt;span&gt;2&lt;/span&gt;&lt;span&gt;), environment mode (REPRODUCIBLE).

Machine-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;:-&amp;gt;Task-&lt;span&gt;1&lt;/span&gt;-&amp;gt;Task-&lt;span&gt;2&lt;/span&gt;-&amp;gt;Task-&lt;span&gt;3&lt;/span&gt;-&amp;gt;Task-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
Machine-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;:-&amp;gt;Task-&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
Machine-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;:-&amp;gt;Task-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
Machine-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;:-&amp;gt;Task-&lt;span&gt;7&lt;/span&gt;-&amp;gt;Task-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
Machine-&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;:-&amp;gt;Task-&lt;span&gt;9&lt;/span&gt;-&amp;gt;Task-&lt;span&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;从上面的日志内容，我们可以看到，以时间开始的行，是Optaplanner引擎在一步一步帮我们找最优方案时的过程输出。到最后结束时，它显示 best score (0hard/-700soft)。 意思是说，它帮我们找到的方案的评价是：没有违反任何硬约束(0hard), 软约束的违反分数是700分(-700soft). 也就是我们用这些机台做完这10个任务需要700元的要台成本.那么这700元是怎么来的呢？那就得看看它给出我们的分配方案是什么了：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;15&quot;&gt;
&lt;span&gt;Machine-2:-&amp;gt;Task-1-&amp;gt;Task-2-&amp;gt;Task-3-&amp;gt;Task-4&lt;span&gt;
Machine-4:-&amp;gt;Task-5&lt;span&gt;
Machine-3:-&amp;gt;Task-6&lt;span&gt;
Machine-5:-&amp;gt;Task-7-&amp;gt;Task-8&lt;span&gt;
Machine-6:-&amp;gt;Task-9-&amp;gt;Task-10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;p&gt;意思是说 M2(Machine-2)上分配了Task1, Task2, Task3, Task4; 其它机台如此类推。即应用了M2,M3,M4,M5,M6共5个台机，大家可以回到上面的机台列表，这5个机台的成本加起来就是700元。&lt;br/&gt;至此，Optaplanner已经帮大家找到最佳方案了，大家可以自行验证一下，试试如何将上面分配方案的一些任务移到其它机台，它能否保持不违反2个硬约束的前提下，得到比700更小的机台成本？
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt; 另外，关于Maven需要的依赖包，我将POM文件的内容也贴出来。大家照着上，应该可以运行起来了。&lt;/p&gt;
&lt;p&gt;POM.XML文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.optaplanner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;optaplanner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;7.8.0.Final&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.apsbyoptaplanner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OptaplannerTest&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.optaplanner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;optaplanner-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.kie&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;kie-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.thoughtworks.xstream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xstream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ch.qos.logback&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;logback-classic&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;runtime&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;此文经历了超过两个星期的时间才完成，其实思路与目标在行文前均已很明确，耐何近段时间确定太忙无法抽身。还请各位见谅。接下来，该系列文章将按两个方案开展，一方面按Optaplanner的各个特性，详细讲解各种功能的使用方法与工作原理。另一方面将会类似于本文，将撰写数篇相对深入的应用文章，分享给对Optaplanner有一定认识的同学。如果对此，大家有何建议，欢迎大家加我企鹅一起探讨：12977379或V信：13631823503。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;其实 Optaplanner不需要对Java过份精通即可使用,因为它使用到的都是Java最基本的知道，但还是需要有基本的Java知识才行，希望大家找我研究讨论时，如果Java, Maven等方面仍接触较少，请大家先行自补该方面的知识，本猿暂时只能跟大家探讨Optaplanner, Drools的应用，而Java相关的知识，恕无法提供有效的帮助，毕竟本猿也只是个Java新手。先谢了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，若对此文(或本系列任何内容)感兴趣，欢迎转载，但请尊重艰辛劳动，注明出处。为谢！&lt;/p&gt;

&lt;p&gt;另外帮Optaplanner老大Geoffrey推广一下，望大家多多关注Optaplanner - http://www.optaplanner.org&lt;/p&gt;


</description>
<pubDate>Tue, 24 Jul 2018 17:27:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/9362859.html</dc:identifier>
</item>
<item>
<title>Netty源码—三、select - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/9363593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/9363593.html</guid>
<description>&lt;h2 id=&quot;nioeventloop功能&quot;&gt;NioEventLoop功能&lt;/h2&gt;
&lt;p&gt;前面channel已经准备好了，可以接收来自客户端的请求了，NioEventLoop作为一个线程池，只有一个线程，但是有一个queue存储了待执行的task，由于只有一个线程，所以run方法是死循环，除非线程池shutdown。&lt;/p&gt;
&lt;p&gt;这个run方法的主要作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行selector.select，监听IO事件，并处理IO事件&lt;/li&gt;
&lt;li&gt;由于NioEventLoop兼有线程池的功能，执行线程池中任务&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.channel.nio.NioEventLoop#run
protected void run() {
    // loop，循环处理IO事件或者处理线程池中的task任务
    for (;;) {
        try {
            // 判断接下来是是执行select还是直接处理IO事件和执行队列中的task
            // hasTask判断当前线程的queue中是否还有待执行的任务
            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
                case SelectStrategy.CONTINUE:
                    // NioEventLoop默认不会有这种状态
                    continue;
                case SelectStrategy.SELECT:
                    // 说明当前queue中没有task待执行
                    select(wakenUp.getAndSet(false));
                    // 唤醒epoll_wait
                    if (wakenUp.get()) {
                        selector.wakeup();
                    }
                    // fall through
                default:
            }

            cancelledKeys = 0;
            needsToSelectAgain = false;
            // 这个比例是处理IO事件所需的时间和花费在处理task时间的比例
            final int ioRatio = this.ioRatio;
            if (ioRatio == 100) {
                // 如果比例是100，表示每次都处理完IO事件后，执行所有的task
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    // 保证能执行所有的task
                    runAllTasks();
                }
            } else {
                // 记录处理IO事件开始的时间
                final long ioStartTime = System.nanoTime();
                try {
                    // 处理IO事件
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    // 当前时间减去处理IO事件开始的时间就是处理IO事件花费的时间
                    final long ioTime = System.nanoTime() - ioStartTime;
                    // 执行task的时间taskTime就是ioTime * (100 - ioRatio) / ioRatio
                    // 如果taskTime时间到了还有未执行的task，runAllTasks也会返回
                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
        // Always handle shutdown even if the loop processing threw an exception.
        try {
            // 如果已经shutdown则关闭所有资源
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    return;
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
    }
}

// io.netty.channel.DefaultSelectStrategy#calculateStrategy
public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {
    // 如果还有task待执行则先执行selectNow，selectNow是立即返回的，不是阻塞等待
    // 如果没有待执行的task则执行select，有可能是阻塞等待IO事件
    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;
}

// io.netty.channel.nio.NioEventLoop#selectNowSupplier
private final IntSupplier selectNowSupplier = new IntSupplier() {
    @Override
    public int get() throws Exception {
        // epoll_wait的参数timeout可以指定超时时间，selectNow传入的参数是0，也就是不超时等待立即返回
        return selectNow();
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;select过程&quot;&gt;select过程&lt;/h2&gt;
&lt;p&gt;epoll模型中最重要的一部分来了，Java把epoll_wait封装成了一个selector，可以理解为多路复用选择器，所以在调用selector.select过程中最后都是通过epoll_wait实现的，下面先看看SelectorImpl的两个select方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int select(long timeout)
    throws IOException {
    if (timeout &amp;lt; 0)
        throw new IllegalArgumentException(&quot;Negative timeout&quot;);
    // timeout = 0，传递给epoll_wait的参数是-1，表示阻塞等待
    // timeout &amp;gt; 0，表示超时等待timeout时间后返回
    return lockAndDoSelect((timeout == 0) ? -1 : timeout);
}

// 调用epoll_wait阻塞等待
public int select() throws IOException {
    return select(0);
}

// 调用epoll_wait立即返回
public int selectNow() throws IOException {
    return lockAndDoSelect(0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面三个select方法都调用了lockAndDoSelect，只是timeout参数不同，其实最后就是调用epoll_wait参数不同，epoll_wait有一个timeout参数，表示超时时间&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-1:阻塞&lt;/li&gt;
&lt;li&gt;0:立即返回，非阻塞&lt;/li&gt;
&lt;li&gt;大于0:指定微秒&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// sun.nio.ch.EPollSelectorImpl#doSelect
protected int doSelect(long timeout) throws IOException {
    if (closed)
        throw new ClosedSelectorException();
    // 省略中间代码...
    // 开始poll，这里的pollWrapper是EPollArrayWrapper
    pollWrapper.poll(timeout);
    // 省略中间代码...

    int numKeysUpdated = updateSelectedKeys();
    // 如果epoll_wait是因为wakeup pipe解除阻塞返回
    if (pollWrapper.interrupted()) {
        // Clear the wakeup pipe
        // 清除中断文件描述符接收到的IO事件
        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);
        synchronized (interruptLock) {
            pollWrapper.clearInterrupted();
            // 读取完管道中的数据
            IOUtil.drain(fd0);
            interruptTriggered = false;
        }
    }
    return numKeysUpdated;
}

int poll(long timeout) throws IOException {
    // 这里会向epoll注册每个socket需要监听的事件
    updateRegistrations();
    // 调用epollWait，这是一个native方法
    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);
    for (int i=0; i&amp;lt;updated; i++) {
        if (getDescriptor(i) == incomingInterruptFD) {
            interruptedIndex = i;
            interrupted = true;
            break;
        }
    }
    return updated;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看epollWait的native实现&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// jdk/src/solaris/native/sun/nio/ch/EPollArrayWrapper.c
JNIEXPORT jint JNICALL
Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject this,
                                            jlong address, jint numfds,
                                            jlong timeout, jint epfd)
{
    struct epoll_event *events = jlong_to_ptr(address);
    int res;

    if (timeout &amp;lt;= 0) {           /* Indefinite or no wait */
        // epoll_wait参数的含义是
        // epfd，创建的epoll句柄
        // events是一个结构体指针，如果有IO事件发生，linux会将事件放在这个结构体中返回
        // numfds是上面指针指向的结构体的个数，也就是最多能接收的IO事件的个数
        // timeout是超时时间
        RESTARTABLE(epoll_wait(epfd, events, numfds, timeout), res);
    } else {                      /* Bounded wait; bounded restarts */
        res = iepoll(epfd, events, numfds, timeout);
    }

    if (res &amp;lt; 0) {
        JNU_ThrowIOExceptionWithLastError(env, &quot;epoll_wait failed&quot;);
    }
    return res;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从native实现上可以看出最终调用了epoll_wait（在timeout &amp;gt;= 0），接着看看epoll_wait的里一个参数events的来源。在上一篇文章里面我们说了channel注册的时候会将自己需要监听的事件类型保存在sun.nio.ch.EPollArrayWrapper#eventsLow中，而上面EPollArrayWrapper#poll中又调用了updateSelectedKeys来注册每个socket监听的事件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// sun.nio.ch.EPollArrayWrapper#getUpdateEvents
// 获取需要监听的文件描述符对应的事件
private byte getUpdateEvents(int fd) {
    // 如果没有超出预定义的数组大小则直接从数组中获取
    if (fd &amp;lt; MAX_UPDATE_ARRAY_SIZE) {
        return eventsLow[fd];
    } else {
        // 超出预订单数组大小的部分从map中获取
        Byte result = eventsHigh.get(Integer.valueOf(fd));
        // result should never be null
        return result.byteValue();
    }
}

// sun.nio.ch.EPollArrayWrapper#updateRegistrations
// 这个方法是在epoll_wait前把需要监听的文件描述符及其需要监听的事件注册到epoll上
private void updateRegistrations() {
    synchronized (updateLock) {
        int j = 0;
        // 每调用一次setInterest，updateCount加1
        while (j &amp;lt; updateCount) {
            // 需要监听的文件描述符
            int fd = updateDescriptors[j];
            // 需要监听的事件，比如channel注册之后的事件是
            short events = getUpdateEvents(fd);
            boolean isRegistered = registered.get(fd);
            int opcode = 0;

            if (events != KILLED) {
                if (isRegistered) {
                    opcode = (events != 0) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;
                } else {
                    opcode = (events != 0) ? EPOLL_CTL_ADD : 0;
                }
                if (opcode != 0) {
                    // 调用epollCtl来add、update或者delete对应文件描述符坚挺的事件
                    epollCtl(epfd, opcode, fd, events);
                    if (opcode == EPOLL_CTL_ADD) {
                        registered.set(fd);
                    } else if (opcode == EPOLL_CTL_DEL) {
                        registered.clear(fd);
                    }
                }
            }
            j++;
        }
        updateCount = 0;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面epollCtl又是一个native方法&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// jdk/src/solaris/native/sun/nio/ch/EPollArrayWrapper.c
JNIEXPORT void JNICALL
Java_sun_nio_ch_EPollArrayWrapper_epollCtl(JNIEnv *env, jobject this, jint epfd,
                                           jint opcode, jint fd, jint events)
{
    struct epoll_event event;
    int res;

    event.events = events;
    event.data.fd = fd;

    // opcode，EPOLL_CTL_ADD(注册新的fd到epfd)， EPOLL_CTL_MOD(修改已经注册的fd的监听事件)， EPOLL_CTL_DEL(从epfd删除一个fd);
    // fd，需要监听的socket对应的文件描述符
    // event，该文件描述符监听的事件
    RESTARTABLE(epoll_ctl(epfd, (int)opcode, (int)fd, &amp;amp;event), res);
    // 省略中间代码...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于select过程中的中断说明&quot;&gt;关于select过程中的中断说明&lt;/h2&gt;
&lt;h3 id=&quot;这里的中断是什么&quot;&gt;这里的中断是什么？&lt;/h3&gt;
&lt;p&gt;这里中断并不是操作系统层面的中断，只是中断epoll_wait。由于epoll_wait可能会阻塞等待IO事件(timeout = -1)，这里的中断就是指中断epoll_wait，即时返回。也就是让select即时返回&lt;/p&gt;
&lt;h3 id=&quot;这里的中断是怎么实现的&quot;&gt;这里的中断是怎么实现的？&lt;/h3&gt;
&lt;p&gt;由于epoll_wait处在等待的情况下的时候，如果有文件描述符上有事件发生，epoll_wait就会返回，所以基本思路就是在epoll监控的文件描述符上产生IO事件，具体实现原理就是使用管道创建两个文件描述符fd0，fd1（EPollSelectorImpl），fd0用来作为读描述符，fd1作为写描述符，然后将读描述符注册到epoll上，如果向fd1写内容，epoll发现fd0有IO事件就会返回，起到了让epoll_wait及时返回的作用。&lt;/p&gt;
&lt;h3 id=&quot;什么时候会中断&quot;&gt;什么时候会中断&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;调用Thread.interrupt()&lt;/li&gt;
&lt;li&gt;selector关闭的时候&lt;/li&gt;
&lt;li&gt;可以直接调用sun.nio.ch.EPollSelectorImpl#wakeup，这是一个public方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;中断的方法是sun.nio.ch.EPollArrayWrapper#interrupt()，这个方法会调用一个native方法&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// jdk/src/solaris/native/sun/nio/ch/EPollArrayWrapper.c
JNIEXPORT void JNICALL
Java_sun_nio_ch_EPollArrayWrapper_interrupt(JNIEnv *env, jobject this, jint fd)
{
    int fakebuf[1];
    fakebuf[0] = 1;
    // 传入的文件描述符是sun.nio.ch.EPollArrayWrapper#outgoingInterruptFD，也就是创建的pipe的写文件描述符fd1，向pipe的fd1写入一个字节的1
    if (write(fd, fakebuf, 1) &amp;lt; 0) {
        JNU_ThrowIOExceptionWithLastError(env,&quot;write to interrupt fd failed&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候epoll_wait就收到中断文件描述符sun.nio.ch.EPollArrayWrapper#incomingInterruptFD，也就是创建的pipe的读文件描述符上有IO事件产生，epoll_wait可以返回。&lt;/p&gt;
&lt;p&gt;所以调用到方法EPollArrayWrapper#interrupt()就可以中断文件描述符，而方法EPollSelectorImpl#wakeup调用了EPollArrayWrapper#interrupt()。&lt;/p&gt;
&lt;p&gt;那么为什么调用Thread.interrupt()的时候也会中断epoll_wait呢？&lt;/p&gt;
&lt;p&gt;因为在Thread.interrupt()方法中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess();

    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // Just to set the interrupt flag
            // 上面设置完中断标志位后，会调用当前线程的blocker的interrupt方法
            b.interrupt(this);
            return;
        }
    }
    interrupt0();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在sun.nio.ch.EPollSelectorImpl#doSelect方法中，开始poll之前会调用begin方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final void begin() {
    if (interruptor == null) {
        // 新建一个interruptor
        interruptor = new Interruptible() {
            public void interrupt(Thread ignore) {
                // 此时Thread.interrupt()中的blocker就是这个匿名内部类，也就是调用的这个interrupt方法
                AbstractSelector.this.wakeup();
            }};
    }
    // 设置当前线程的interruptor
    AbstractInterruptibleChannel.blockedOn(interruptor);
    Thread me = Thread.currentThread();
    if (me.isInterrupted())
        interruptor.interrupt(me);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以Thread.interrupt()会调用到EPollSelectorImpl#wakeup方法，也就可以起到中断select的作用。&lt;/p&gt;
&lt;h3 id=&quot;什么时候清除中断标志&quot;&gt;什么时候清除中断标志？&lt;/h3&gt;
&lt;p&gt;可以不止一次的中断select，为了实现这个功能，每次在中断之后斗湖清除相关的中断标志。在sun.nio.ch.EPollSelectorImpl#doSelect方法中pollWrapper.poll完成之后&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int poll(long timeout) throws IOException {
    updateRegistrations();
    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);
    for (int i=0; i&amp;lt;updated; i++) {
        // epollWait返回之后会判断有没有中断文件描述符
        if (getDescriptor(i) == incomingInterruptFD) {
            // 设置中断的文件描述符处于返回的pollArray的index
            interruptedIndex = i;
            interrupted = true;
            break;
        }
    }
    return updated;
}
protected int doSelect(long timeout) throws IOException {
    // 省略中间代码...
        pollWrapper.poll(timeout);
    // // 省略中间代码...
    // 如果
    if (pollWrapper.interrupted()) {
        // Clear the wakeup pipe
        // 将返回的中断文件描述符的IO事件清空，也就是用户不会读取到用做中断的文件描述符
        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);
        synchronized (interruptLock) {
            // sun.nio.ch.EPollArrayWrapper#interrupted设置为false，可再次中断
            pollWrapper.clearInterrupted();
            // 读取用以中断的文件描述符上所有的数据
            IOUtil.drain(fd0);
            interruptTriggered = false;
        }
    }
    return numKeysUpdated;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;到目前为止已经看清了Java对应linux中epoll相关api的封装&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 创建epoll文件描述符
// 对应到Java就是创建selector
int epoll_create(int size);

// 打开一个网络通讯端口，也就是创建一个socket，创建返回一个文件描述符
// 对应到Java就是创建一个socketChannel
int socket(int domain, int type, int protocol);

// 将socket对应的文件描述符和ip:port绑定在一起
// 对应于Java中绑定ip:port
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

// 表明socket对应的文件描述符处于监听状态，并且最多允许有backlog个客户端处于连接等待状态
// 对应于Java中bind中调用listen方法
int listen(int sockfd, int backlog);

// 控制某个文件描述符上的事件：add、update、delete事件
// 对应于Java中调用select过程中添加每个channel关注的事件
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

// 等待监控的所有描述符有事件发生
// 对应于Java中select的时候等待有IO事件发生
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 24 Jul 2018 16:54:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/9363593.html</dc:identifier>
</item>
<item>
<title>Java语法之注解 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9363581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9363581.html</guid>
<description>&lt;p&gt;注解其实在其他语言也有，只是叫法不一样，在C#中叫特性，其实都是一个意思。今天就是了解下Java的注解。&lt;/p&gt;
&lt;p&gt;一、什么是注解&lt;/p&gt;
&lt;p&gt;我们先看官方解释:它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。&lt;/p&gt;
&lt;p&gt;看着上面的解释是不是还是一头雾水，其实我们可以更通俗的理解。最近几年出现一个词斜杠青年还有黄晓明拍摄的广告语:给人贴标签、下定义，总是很容易，而我却不会因为一件事被定性,这里的斜杠青年、贴标签都是把某些属性附加给对象,个人觉得和注解功能差不多，&lt;span&gt;它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。&lt;span&gt;我们可以再来理解下这句话，这里的程序元素可以理解为人，信息或元数据理解为标签,把标签属性(信息或元数据)给赋给人(程序元素)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;二、元注解&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们在新建注解时，会有下图的一些选项，这里我们可以看到@Retention、@Target、@Documented这几个词，还有这几个对应的复选框，那这些是什么呢？这些其实就是元注解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201807/733213-20180725000641381-1022821661.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;java.lang.annotation提供了五种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解)：&lt;/p&gt;
&lt;p&gt;@Documented –注解是否将包含在JavaDoc中&lt;br/&gt;@Retention –什么时候使用该注解&lt;br/&gt;@Target –注解用于什么地方&lt;br/&gt;@Inherited – 是否允许子类继承该注解&lt;br/&gt;@Repeatable - 指定注解可重复使用&lt;/p&gt;
&lt;p&gt;1.@Retention– 定义该注解的生命周期&lt;/p&gt;
&lt;p&gt;      RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都   属于这类注解。&lt;br/&gt;     RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式&lt;br/&gt;     RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。&lt;br/&gt;2.Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括&lt;/p&gt;
&lt;p&gt;     ElementType.CONSTRUCTOR:用于描述构造器&lt;br/&gt;     ElementType.FIELD:成员变量、对象、属性（包括enum实例）&lt;br/&gt;     ElementType.LOCAL_VARIABLE:用于描述局部变量&lt;br/&gt;     ElementType.METHOD:用于描述方法&lt;br/&gt;     ElementType.PACKAGE:用于描述包&lt;br/&gt;     ElementType.PARAMETER:用于描述参数&lt;br/&gt;     ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明&lt;br/&gt;3.@Documented–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。&lt;br/&gt;4.@Inherited – 定义该注释和子类的关系&lt;/p&gt;
&lt;p&gt;    @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。&lt;br/&gt;5.@Repeatable - 指定该注解可重复使用&lt;/p&gt;
&lt;p&gt;    使用@Repeatable修饰表示该注解可以为重复使用。&lt;/p&gt;
&lt;p&gt;三、内置注解&lt;/p&gt;
&lt;p&gt;@Deprecated&lt;br/&gt;编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。&lt;br/&gt;@Override&lt;br/&gt;提示子类要复写父类中被 @Override 修饰的方法&lt;br/&gt;@SuppressWarnings&lt;br/&gt;阻止警告的意思。调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。&lt;br/&gt;@SafeVarargs&lt;br/&gt;参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。&lt;br/&gt;@FunctionalInterface&lt;br/&gt;函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。函数式接口 (Functional Interface) 就是一个具有一个方法的普通接口。&lt;/p&gt;
&lt;p&gt;四、自定义注解&lt;/p&gt;
&lt;p&gt;这里参考了写&lt;a href=&quot;https://www.cnblogs.com/5ishare/p/5768464.html&quot; target=&quot;_blank&quot;&gt;C#特性&lt;/a&gt;使用的例子。用来演示自定义注解以及注解的继承。&lt;/p&gt;
&lt;p&gt;1.这个定义了CustormDescription注解，相当于标签，为了能多贴标签又定义了注解容器CustormDescriptions.&lt;/p&gt;
&lt;p&gt;CustormDescription注解:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; CusAnnontation;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy.RUNTIME;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType.TYPE;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Documented;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Inherited;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Repeatable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Documented
@Retention(RUNTIME)
@Target(TYPE)
@Inherited
@Repeatable(CustormDescriptions.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustormDescription {
    String description() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CustormDescriptions容器:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; CusAnnontation;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType.TYPE;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy.RUNTIME;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Documented;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Inherited;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Documented
@Retention(RUNTIME)
@Target(TYPE)
@Inherited
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustormDescriptions {
    CustormDescription[] value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.实现继承关系&lt;/p&gt;
&lt;p&gt;这里还是创建了Person和Student类，Studnet继承Person。&lt;/p&gt;
&lt;p&gt;Person:这里为Person定义了多个注解，相当于为它贴了多个标签。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; CusAnnontation;

@CustormDescription(description&lt;/span&gt;=&quot;基类&quot;&lt;span&gt;)
@CustormDescription(description&lt;/span&gt;=&quot;人&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Name;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Age;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        Name &lt;/span&gt;=&lt;span&gt; name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Age;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        Age &lt;/span&gt;=&lt;span&gt; age;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Student:这里Student也贴了一个标签。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; CusAnnontation;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@CustormDescription(description=&quot;基类&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@CustormDescription(description=&quot;人&quot;)&lt;/span&gt;
@CustormDescription(description=&quot;学生&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String StudentId;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getStudentId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StudentId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStudentId(String studentId) {
        StudentId &lt;/span&gt;=&lt;span&gt; studentId;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.获取注解属性值&lt;/p&gt;
&lt;p&gt;这里来获取出Student类的CustormDescriptions的注解值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; CusAnnontation;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnontationTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        
        CustormDescriptions  custormDescriptions &lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Student().getClass().getAnnotation(CustormDescriptions.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(CustormDescription h: custormDescriptions.value()){

        System.out.println(&lt;/span&gt;&quot;description:&quot; +&lt;span&gt; h.description());

        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那问题来了，按照上面增加的注解会打印出什么呢？因为是获取学生的注解，会不会打印出description:学生呢？我们可以打印一下，看下结果.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
description:基类
description:人
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实，这里只打印出了上面父类的注解信息，并未打印出子类的，如果要打印出子类的，需要在子类上加上一个父类的注解，这样就会覆盖掉父类的注解。例如修改下Student类如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; CusAnnontation;

@CustormDescription(description&lt;/span&gt;=&quot;基类&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@CustormDescription(description=&quot;人&quot;)&lt;/span&gt;
@CustormDescription(description=&quot;学生&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String StudentId;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getStudentId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StudentId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStudentId(String studentId) {
        StudentId &lt;/span&gt;=&lt;span&gt; studentId;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改之后再运行，就会输出学生注解了，结果为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
description:基类
description:学生
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.@Retention生命周期&lt;/p&gt;
&lt;p&gt;在上面的demo中我们也可以验证下@Retention的生命周期，在自定义注解一般使用@Retention(RUNTIME)，如果我们把上面的改成CLASS，那就会直接报错，因为&lt;span data-mce-=&quot;&quot;&gt;custormDescriptions 对象是一个null空值。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 16:46:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9363581.html</dc:identifier>
</item>
<item>
<title>运维自动化平台实践之路 - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/9363560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/9363560.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;导读&quot;&gt;导读&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;引&lt;/li&gt;
&lt;li&gt;什么是运维&lt;/li&gt;
&lt;li&gt;自动化运维体系&lt;/li&gt;
&lt;li&gt;后记&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;引&quot;&gt;引&lt;/h2&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;      &lt;br/&gt;运维自动化已经不再是新鲜名词,特别是随着Devops思想的影响下,越来越多的互联网产品公司已经开始搭建属于自己的运维自动化平台,甚至个别公司已经走在了AIDevOps实践的路上。那么,运维自动化的到底是什么,为什么需要自动化？如何落地呢?&lt;br/&gt;       当然本文是基于中小型互联网公司自动化平台实践,大型公司的自动化不在讨论之列。另外,由于涉及数据安全等原因,每个公司都趋向于搭建各自的自动化运维体系,仁者见仁,智者见智。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;什么是运维&quot;&gt;什么是运维&lt;/h2&gt;
&lt;p&gt;  &lt;br/&gt;在不同的企业中，关于运维的这个岗位的理解也有很多不同。有的说是网管、有的说是搞网络相关的、有的说是搞机房监控相关的、有的说负责备份与上线的、也有的说是写脚本和程序的，还有的人说是专业背锅的，其实所有的理解都是都对，这些都属于运维工作的一部分，只不过是不同层次、不同岗位的人负责而已，每一项技术都可以说是运维工作，所以不能否认任何人对运维的理解。&lt;br/&gt;   运维的主要工作职责是保障业务的正常运行,不断的更新和提高产品技术的稳定性和安全性。运维部与研发部、测试部和系统管理部门统称为互联网产品技术支撑的四大部门。运维部门又可以大方向的分为：业务实施、应用实施、架构实施、自动化实施和安全管理实施。运维工程师是集合网络、系统、安全、监控、日志、数据、脚本、程序、虚拟化、云计算和集群分布式等所有技术为一体的自动化、结构化、智能化和全面化的岗位&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;传统运维&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  传统运维部门在制订IT设备和信息化系统管理目标时，关注的是一台台IT设备的故障率和一套套应用系统的可用性，在基础设施、数据库、中间件、灾备、存储等环节通常大量采用商业闭源的软硬件产品及其解决方案，设备的开放性差、标准也不统一，管理时遵循严格的ITIL管理体系，喜欢采用两地三中心这种典型的重量级、集中式运维管理方式。&lt;/p&gt;
&lt;p&gt;  随着IT规模越来越大、系统越来越复杂，运维保障工作由最初的硬件运维不断细分，网络工程师、系统运维工程师、DBA、安全工程师等岗位加入到运维体系中。&lt;/p&gt;
&lt;p&gt;  当业务系统发生故障时，IT主管首先召集自扫门前雪的各个运维岗位进行自检，查看各自负责的设备、应用组件、系统是否运行正常。&lt;/p&gt;
&lt;p&gt;  所以，传统运维部门常常被称为“救火”队员，依靠人工巡检的工作方式，不但工作被动，而且效率低下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;互联网运维&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;   到了互联网时代，一切以互联网为核心，IT的边界被完全打开，IT系统不再是为企业内部管理提供支撑，而是为亿万互联网用户提供各种线上服务。因此，IT部门成为了互联网企业的核心，而保障线上业务持续、稳定运行，也是互联网企业的第一使命。&lt;/p&gt;
&lt;p&gt;  互联网运维最关注互联网用户体验，重视响应时间、可用率等性能指标，常常会要求系统可用性达到四个九。因此，互联网运维在基础设施、数据库、中间件、分布式存储、自动化部署等环节通常大量采用开源或基于SaaS的自动化运维监控工具，如Zabbix、Nagios和云智慧监控宝等，这些产品的横向扩展能力很强，具有分布式、轻量级、模块化、去中心化等特点。&lt;/p&gt;
&lt;p&gt;  故障发生时，要求互联网运维能够第一时间发现问题，并快速定位问题。依靠人工巡检的传统运维管理方式严重落后，因此,自动化运维逐渐流行。这就对互联网运维工程师的开发能力提出了更高的要求，熟悉Python之类的脚本语言只是基础，玩得转各种开源监控系统，能够根据业务特点和企业需求定制开发自动化监控和告警工具。&lt;/p&gt;
&lt;p&gt;  这一时期，运维和开发之间的边界变得模糊起来，DevOps成为互联网产品从开发到上线维护的新选择。同时,传统运维部门已经开始组建专业的运维开发团队来支撑自动化体系平台的搭建。运维人员也将通过自动化平台来完成服务器操作,从手工运维到自动化,到无人值守。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;自动化运维体系&quot;&gt;自动化运维体系&lt;/h2&gt;
&lt;p&gt;  以下是笔者针对公司某个阶段运维场景整合的自动化体系(公司处于快速成长期),这里仅供参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B9%B3%E5%8F%B0.png&quot; alt=&quot;自动化运维体系&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  运维体系采用自建服务器+云服务模式&lt;/li&gt;
&lt;li&gt;  ETCP基础数据管理中心&lt;/li&gt;
&lt;li&gt;  工单系统属于一个平台+工具套件,从入口到终端,实现一条龙运维。&lt;/li&gt;
&lt;li&gt;  同时还有多种监控报警体系,实现人机互动,事前可预知,事后可追溯。&lt;/li&gt;
&lt;li&gt;平台的建立,解放运维,让更多相关人进入系统,基本实现自助式,自动化运维。&lt;/li&gt;
&lt;li&gt;不断整合,形成一个平台,让运维工作更聚焦。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  一幅小图,旨在抛砖引玉。往往看似简单的道理,每一点进步都或背后大量精细的的实践。其中涉及的技术和细节也是蛮多的多种主流操作系统,数据库,云平台,开发语言,安全，架构，算法等...&lt;/p&gt;
&lt;p&gt;以下是平台的截图,可以吐槽一下，哈哈&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%B7%A5%E5%8D%951.png&quot; alt=&quot;自动化运维体系&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;运维知识体系&quot;&gt;运维知识体系&lt;/h2&gt;
&lt;p&gt;  这是一位互联网运维老兵总结的运维知识体系,感谢他的分享,希望对新人有所帮助。&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png&quot; alt=&quot;自动化运维体系&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;任重道远&quot;&gt;任重道远&lt;/h2&gt;
&lt;p&gt;  坊间此前流行一句话,&quot;能程序完成的事情尽量不要用人去干&quot;。运维自动化道路并不是一帆风顺的,很多时候是需要自己造轮子。 每个公司发展状况不同,并且涉及各自公司的隐私,基本都有定制化的成分，你所要的工具网上可能都会有相关开源项目,但是需要自己整合到体系中。&lt;br/&gt;自动化的下一步是智能化,未来还有更多的路要走。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;  鲁迅说过:&quot;世界上本没有路,走的人多了,也就变成了路。&quot;想做一个统一的运维自动化平台的产品或许不太可能, 但是做一点表准化自动化插件或者小工具,是有可能的,这个其实也是商机,你做到了,这条路便可以走的更远。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E8%BF%90%E7%BB%B4%E4%BA%BA.png&quot; alt=&quot;自动化运维体系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;据说今天是724运维日,祝各位互联网的幕后英雄节日快乐！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E7%A0%81%E5%86%9C%E5%95%86%E4%B8%9A%E5%8F%82%E8%B0%8B%20%282%29.jpg&quot; alt=&quot;自动化运维体系&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 16:31:00 +0000</pubDate>
<dc:creator>戎&amp;quot;码&amp;quot;一生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lucky_hu/p/9363560.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之开源项目CAP的初步使用 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/9363244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/9363244.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt; &lt;/em&gt;此篇已加入&lt;a title=&quot;find more ?&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础系列文章索引&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;CAP&quot; src=&quot;https://camo.githubusercontent.com/452505edb71d41f2c1bd18907275b76291621e46/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3235303431372f3230313730372f3235303431372d32303137303730353137353832373132382d313230333239313436392e706e67&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;下面的文字来自CAP的Wiki文档：&lt;a title=&quot;wiki&quot; href=&quot;https://github.com/dotnetcore/CAP/wiki&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/CAP/wiki&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CAP 是一个在分布式系统中（SOA，MicroService）实现事件总线及最终一致性（分布式事务）的一个开源的 C# 库，她具有轻量级，高性能，易使用等特点。我们可以轻松的在基于 .NET Core 技术的分布式系统中引入CAP，包括但限于 ASP.NET Core 和 ASP.NET Core on .NET Framework。&lt;/p&gt;
&lt;p&gt;　　CAP 的应用场景主要有以下两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式事务中的最终一致性（异步确保）的方案&lt;/li&gt;
&lt;li&gt;具有高可用性的 EventBus&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　CAP 同时支持使用 RabbitMQ 或 Kafka 进行底层之间的消息发送，我们不需要具备 RabbitMQ 或者 Kafka 的使用经验，仍然可以轻松的将CAP集成到项目中。&lt;/p&gt;
&lt;p&gt;　　CAP 目前支持使用 Sql Server，MySql，PostgreSql 数据库的项目；&lt;/p&gt;
&lt;p&gt;　　CAP 同时支持使用 EntityFrameworkCore 和 Dapper 的项目，可以根据需要选择不同的配置方式；&lt;/p&gt;
&lt;p&gt;　　CAP的作者为园友&lt;a href=&quot;https://www.cnblogs.com/savorboard&quot; target=&quot;_blank&quot;&gt;savorboard&lt;/a&gt;（杨晓东），成都地区的.NET社区领导者，棒棒哒！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180724232338836-1039271373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此次试验仍然和上一篇&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dnc_microservice_masstransit_foundation_part2.html&quot; target=&quot;_blank&quot;&gt;基于MassTransit的案例&lt;/a&gt;一样（其实是我懒得再改，直接拿来复用），共有四个MicroService应用程序，当用户下订单时会通过CAP作为事件总线发布消息，作为订阅者的库存和配送服务会接收到消息并消费消息。此次试验会采用RabbitMQ作为消息队列，采用MSSQL作为关系型数据库（同时CAP也是支持MSSQL的）。&lt;/p&gt;
&lt;p&gt;　　准备工作：为所有服务通过NuGet安装CAP及其相关包&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　下面是RabbitMQ的支持包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP.RabbitMQ&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　下面是MSSQL的支持包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP.SqlServer&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2&gt;3.1 OrderService&lt;/h2&gt;
&lt;p&gt;　　（1）启动配置：这里主要需要给CAP指定数据库（它会在这个数据库中创建本地消息表Published和Received）以及使用到的消息队列（这里是RabbitMQ）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Repository&lt;/span&gt;
        services.AddScoped&amp;lt;IOrderRepository, OrderRepository&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; EF DbContext&lt;/span&gt;
        services.AddDbContext&amp;lt;OrderDbContext&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dapper-ConnString&lt;/span&gt;
        services.AddSingleton(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DB:OrderDB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAP&lt;/span&gt;
        services.AddCap(x =&amp;gt;&lt;span&gt;
        {
            x.UseEntityFramework&lt;/span&gt;&amp;lt;OrderDbContext&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; EF&lt;/span&gt;
&lt;span&gt;
            x.UseSqlServer(Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DB:OrderDB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SQL Server&lt;/span&gt;
&lt;span&gt;
            x.UseRabbitMQ(cfg &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                cfg.HostName &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                cfg.VirtualHost &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:VirtualHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                cfg.Port &lt;/span&gt;= Convert.ToInt32(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                cfg.UserName &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                cfg.Password &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]; 
            }); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RabbitMQ

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Below settings is just for demo&lt;/span&gt;
            x.FailedRetryCount = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            x.FailedRetryInterval &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
        });

        ......
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime lifetime)
    {
        ......

        app.UseMvc();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAP&lt;/span&gt;
&lt;span&gt;        app.UseCap();

        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）Controller：这里会调用Repository去实现业务逻辑和发送消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOrderRepository OrderRepository { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OrderController(IOrderRepository OrderRepository)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.OrderRepository =&lt;span&gt; OrderRepository;
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Post([FromBody]OrderDTO orderDTO)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; OrderRepository.CreateOrderByDapper(orderDTO).GetAwaiter().GetResult();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; result ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Post Order Success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Post Order Failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）Repository：这里实现了两种方式：EF和Dapper（基于ADO.NET），其中EF方式中不需要传transaction（当CAP检测到 Publish 是在EF事务区域内的时候，将使用当前的事务上下文进行消息的存储），而基于ADO.NET方式中需要传transaction（由于不能获取到事务上下文，所以需要用户手动的传递事务上下文到CAP中）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderRepository : IOrderRepository
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OrderDbContext DbContext { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICapPublisher CapPublisher { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ConnStr { &lt;span&gt;get&lt;/span&gt;; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For Dapper use&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; OrderRepository(OrderDbContext DbContext, ICapPublisher CapPublisher, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ConnStr)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DbContext =&lt;span&gt; DbContext;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CapPublisher =&lt;span&gt; CapPublisher;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ConnStr =&lt;span&gt; ConnStr;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; CreateOrderByEF(IOrder order)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; trans =&lt;span&gt; DbContext.Database.BeginTransaction())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; orderEntity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order()
                {
                    ID &lt;/span&gt;=&lt;span&gt; GenerateOrderID(),
                    OrderUserID &lt;/span&gt;=&lt;span&gt; order.OrderUserID,
                    OrderTime &lt;/span&gt;=&lt;span&gt; order.OrderTime,
                    OrderItems &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                    ProductID &lt;/span&gt;= order.ProductID &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For demo use&lt;/span&gt;
&lt;span&gt;                };

                DbContext.Orders.Add(orderEntity);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; DbContext.SaveChangesAsync();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; When using EF, no need to pass transaction&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; orderMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderMessage()
                {
                    ID &lt;/span&gt;=&lt;span&gt; orderEntity.ID,
                    OrderUserID &lt;/span&gt;=&lt;span&gt; orderEntity.OrderUserID,
                    OrderTime &lt;/span&gt;=&lt;span&gt; orderEntity.OrderTime,
                    OrderItems &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                    ProductID &lt;/span&gt;= orderEntity.ProductID &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For demo use&lt;/span&gt;
&lt;span&gt;                };
                
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; CapPublisher.PublishAsync(EventConstants.EVENT_NAME_CREATE_ORDER, orderMessage);

                trans.Commit();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; CreateOrderByDapper(IOrder order)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; conn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection(ConnStr))
            {
                conn.Open();
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; trans =&lt;span&gt; conn.BeginTransaction())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; business code here&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt; sqlCommand = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO [dbo].[Orders](OrderID, OrderTime, OrderUserID, ProductID)
                                                                VALUES(@OrderID, @OrderTime, @OrderUserID, @ProductID)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    order.ID &lt;/span&gt;=&lt;span&gt; GenerateOrderID();
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; conn.ExecuteAsync(sqlCommand, param: &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                    {
                        OrderID &lt;/span&gt;=&lt;span&gt; order.ID,
                        OrderTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                        OrderUserID &lt;/span&gt;=&lt;span&gt; order.OrderUserID,
                        ProductID &lt;/span&gt;=&lt;span&gt; order.ProductID
                    }, transaction: trans);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For Dapper/ADO.NET, need to pass transaction&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; orderMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderMessage()
                    {
                        ID &lt;/span&gt;=&lt;span&gt; order.ID,
                        OrderUserID &lt;/span&gt;=&lt;span&gt; order.OrderUserID,
                        OrderTime &lt;/span&gt;=&lt;span&gt; order.OrderTime,
                        OrderItems &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                        MessageTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                        ProductID &lt;/span&gt;= order.ProductID &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For demo use&lt;/span&gt;
&lt;span&gt;                    };

                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; CapPublisher.PublishAsync(EventConstants.EVENT_NAME_CREATE_ORDER, orderMessage, trans);

                    trans.Commit();
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GenerateOrderID()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Some business logic to generate Order ID&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Guid.NewGuid().ToString();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GenerateEventID()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Some business logic to generate Order ID&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Guid.NewGuid().ToString();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里摘抄一段CAP wiki中关于事务的一段介绍：&lt;/p&gt;
&lt;p&gt;　　事务在 CAP 具有重要作用，它是保证消息可靠性的一个基石。 在发送一条消息到消息队列的过程中，如果不使用事务，我们是没有办法保证我们的业务代码在执行成功后消息已经成功的发送到了消息队列，或者是消息成功的发送到了消息队列，但是业务代码确执行失败。&lt;/p&gt;
&lt;p&gt;　　这里的失败原因可能是多种多样的，比如连接异常，网络故障等等。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;span&gt;&lt;strong&gt;只有业务代码和CAP的Publish代码必须在同一个事务中，才能够保证业务代码和消息代码同时成功或者失败&lt;/strong&gt;&lt;/span&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt;换句话说，CAP会确保我们这段逻辑中业务代码和消息代码都成功了，才会真正让事务commit。&lt;/p&gt;
&lt;h2&gt;3.2 StorageService&lt;/h2&gt;
&lt;p&gt;　　（1）启动配置：这里主要是指定Subscriber&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; EF DbContext&lt;/span&gt;
        services.AddDbContext&amp;lt;StorageDbContext&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dapper-ConnString&lt;/span&gt;
        services.AddSingleton(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DB:StorageDB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Subscriber&lt;/span&gt;
        services.AddTransient&amp;lt;IOrderSubscriberService, OrderSubscriberService&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAP&lt;/span&gt;
        services.AddCap(x =&amp;gt;&lt;span&gt;
        {
            x.UseEntityFramework&lt;/span&gt;&amp;lt;StorageDbContext&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; EF&lt;/span&gt;
&lt;span&gt;
            x.UseSqlServer(Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DB:StorageDB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SQL Server&lt;/span&gt;
&lt;span&gt;
            x.UseRabbitMQ(cfg &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                cfg.HostName &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                cfg.VirtualHost &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:VirtualHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                cfg.Port &lt;/span&gt;= Convert.ToInt32(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                cfg.UserName &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                cfg.Password &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MQ:Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            }); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RabbitMQ

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Below settings is just for demo&lt;/span&gt;
            x.FailedRetryCount = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            x.FailedRetryInterval &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
        });

        ......
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IServiceProvider serviceProvider, IHostingEnvironment env, IApplicationLifetime lifetime)
    {
        ......

        app.UseMvc();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAP&lt;/span&gt;
&lt;span&gt;        app.UseCap();

        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）实现Subscriber&lt;/p&gt;
&lt;p&gt;　　首先定义一个接口，建议放到公共类库中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOrderSubscriberService
    {
        Task ConsumeOrderMessage(OrderMessage message);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后实现这个接口，记得让其实现ICapSubscribe接口，然后我们就可以使用 &lt;code&gt;CapSubscribeAttribute&lt;/code&gt; 来订阅 CAP 发布出来的消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderSubscriberService : IOrderSubscriberService, ICapSubscribe
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _connStr;
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OrderSubscriberService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connStr)
        {
            _connStr &lt;/span&gt;=&lt;span&gt; connStr;
        }

        [CapSubscribe(EventConstants.EVENT_NAME_CREATE_ORDER)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ConsumeOrderMessage(OrderMessage message)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Console.Out.WriteLineAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[StorageService] Received message : {JsonHelper.SerializeObject(message)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; UpdateStorageNumberAsync(message);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; UpdateStorageNumberAsync(OrderMessage order)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;throw new Exception(&quot;test&quot;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; just for demo use&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; conn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection(_connStr))
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sqlCommand = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UPDATE [dbo].[Storages] SET StorageNumber = StorageNumber - 1
                                                                WHERE StorageID = @ProductID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;await&lt;/span&gt; conn.ExecuteAsync(sqlCommand, param: &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    ProductID &lt;/span&gt;=&lt;span&gt; order.ProductID
                });

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;*.CAP约定消息端在方法实现的过程中需要实现幂等性&lt;/strong&gt;，所谓幂等性就是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。&lt;strong&gt;这里我没有考虑，实际中需要首先进行验证，避免二次更新&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;3.3 DeliveryService&lt;/h2&gt;
&lt;p&gt;　　（1）启动配置：与StorageService高度类似，只是使用的不是同一个数据库&lt;/p&gt;
&lt;p&gt;　　（2）实现Subscriber&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderSubscriberService : IOrderSubscriberService, ICapSubscribe
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _connStr;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OrderSubscriberService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connStr)
        {
            _connStr &lt;/span&gt;=&lt;span&gt; connStr;
        }

        [CapSubscribe(EventConstants.EVENT_NAME_CREATE_ORDER)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ConsumeOrderMessage(OrderMessage message)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Console.Out.WriteLineAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[DeliveryService] Received message : {JsonHelper.SerializeObject(message)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; AddDeliveryRecordAsync(message);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; AddDeliveryRecordAsync(OrderMessage order)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;throw new Exception(&quot;test&quot;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; just for demo use&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; conn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection(_connStr))
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sqlCommand = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO [dbo].[Deliveries] (DeliveryID, OrderID, ProductID, OrderUserID, CreatedTime)
                                                            VALUES (@DeliveryID, @OrderID, @ProductID, @OrderUserID, @CreatedTime)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;await&lt;/span&gt; conn.ExecuteAsync(sqlCommand, param: &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    DeliveryID &lt;/span&gt;=&lt;span&gt; Guid.NewGuid().ToString(),
                    OrderID &lt;/span&gt;=&lt;span&gt; order.ID,
                    OrderUserID &lt;/span&gt;=&lt;span&gt; order.OrderUserID,
                    ProductID &lt;/span&gt;=&lt;span&gt; order.ProductID,
                    CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now
                });

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.4 快速测试&lt;/h2&gt;
&lt;p&gt;　　（1）启动3个微服务，Check 数据库表状态&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180725000701085-243697630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先会看到在各个数据库中均创建了本地消息表，这两个表的含义如下：&lt;/p&gt;
&lt;p&gt;　　Cap.Published：这个表主要是用来存储 CAP 发送到MQ(Message Queue)的客户端消息，也就是说你使用 &lt;code&gt;ICapPublisher&lt;/code&gt; 接口 Publish 的消息内容。&lt;/p&gt;
&lt;p&gt;　　Cap.Received：这个表主要是用来存储 CAP 接收到 MQ(Message Queue) 的客户端订阅的消息，也就是使用 &lt;code&gt;CapSubscribe[]&lt;/code&gt; 订阅的那些消息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180725000846660-828776293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后看看各个表的数据，目前只有库存表有数据，因为我们要做的只是更新。&lt;/p&gt;
&lt;p&gt;　　（2）通过Postman发一个Post请求&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180725000957983-2015440992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）Check控制台输出的日志信息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180725001234612-1861183893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180725001244277-1830491443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）Check数据库中的业务表和消息表数据：可以看到发送者和接收者都执行成功了，如果其中任何一个参与者发生了异常或者连接不上，CAP会有默认的重试机制（默认是50次最大重试次数，每次重试间隔60s），当失败总次数达到默认失败总次数后，就不会进行重试了，我们可以在 Dashboard 中查看消息失败的原因，然后进行人工重试处理。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180725001524995-2070418929.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180725001426461-1036927697.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外，由于CAP会在数据库中创建消息表，因此难免会考虑到其性能。CAP提供了一个数据清理的机制，默认情况下会每隔一个小时将消息表的数据进行清理删除，避免数据量过多导致性能的降低。清理规则为 ExpiresAt （字段名）不为空并且小于当前时间的数据。&lt;/p&gt;

&lt;p&gt;　　本篇首先简单介绍了一下CAP这个开源项目，然后基于上一篇中的下订单的小案例来进行了基于CAP的改造，并通过一个实例的运行来看到了结果。当然，这个实例并不完美，很多点都没有考虑（比如消息端消费时的幂等性）和失败重试的场景实践等等等等。由于时间和精力的关系，目前只使用到这儿，以后有机会能够应用上会研究下CAP的源码，最后感谢杨晓东为.NET社区带来了一个优秀的开源项目！&lt;/p&gt;

&lt;p&gt;　　Click Here =&amp;gt; &lt;a href=&quot;https://github.com/EdisonChou/EDC.CAP.Demo&quot; target=&quot;_blank&quot;&gt;点我点我&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　CAP - GitHub : &lt;a href=&quot;https://github.com/dotnetcore/CAP&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/CAP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　CAP - Wiki : &lt;a href=&quot;https://github.com/dotnetcore/CAP/wiki&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/CAP/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　杨晓东，《&lt;a href=&quot;http://www.cnblogs.com/savorboard/p/base-an-acid-alternative.html&quot; target=&quot;_blank&quot;&gt;BASE：一种ACID的替代方案&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 24 Jul 2018 16:27:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/9363244.html</dc:identifier>
</item>
<item>
<title>ABP  开发（一） - 清风笑</title>
<link>http://www.cnblogs.com/KevinMO/p/9363466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KevinMO/p/9363466.html</guid>
<description>
&lt;p&gt;rh &lt;/p&gt;




&lt;p&gt;    最近搞Angular ,使用Abp+Angular建项目，遇到部分问题，记录一下，以备查：&lt;/p&gt;
&lt;p&gt;一、Abp官网： https://aspnetboilerplate.com/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32982/201807/32982-20180722184037577-1747139456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点Get started 转到生成模块页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32982/201807/32982-20180722184233521-618514026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择Angular &lt;/p&gt;
&lt;p&gt;勾选： Include login ,register,user,role and tenant management pages。&lt;/p&gt;
&lt;p&gt;输入验证码。&lt;/p&gt;
&lt;p&gt;输入项目名称，点击Create my project! 就可以建立项目模板了&lt;/p&gt;
&lt;p&gt;我建的时候，APB版本是：3.9.0&lt;/p&gt;
&lt;p&gt;二、解压文件，得到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32982/201807/32982-20180723001355887-1647125352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; angular 就是Angular 前端项目&lt;/p&gt;
&lt;p&gt;aspnet-core 就是API 后台项目&lt;/p&gt;

&lt;p&gt;三、打开aspnet-core 找到解决方案，解决方案的名称，就是刚开建模块时输入的项目名。&lt;/p&gt;
&lt;p&gt;四、编译解决方案，&lt;/p&gt;
&lt;p&gt;五、还原数据库：（注意：数据库版本：sql 2008不行，因为abp.dll 使用了下面这样的分页，2008不支持：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exec&lt;/span&gt; sp_executesql N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT [x].[Id], [x].[AccessFailedCount], [x].[AuthenticationSource], [x].[ConcurrencyStamp], [x].[CreationTime], [x].[CreatorUserId], [x].[DeleterUserId], [x].[DeletionTime], [x].[EmailAddress], [x].[EmailConfirmationCode], [x].[IsActive], [x].[IsDeleted], [x].[IsEmailConfirmed], [x].[IsLockoutEnabled], [x].[IsPhoneNumberConfirmed], [x].[IsTwoFactorEnabled], [x].[LastLoginTime], [x].[LastModificationTime], [x].[LastModifierUserId], [x].[LockoutEndDateUtc], [x].[Name], [x].[NormalizedEmailAddress], [x].[NormalizedUserName], [x].[Password], [x].[PasswordResetCode], [x].[PhoneNumber], [x].[SecurityStamp], [x].[Surname], [x].[TenantId], [x].[UserName]
FROM [AbpUsers] AS [x]
WHERE (([x].[IsDeleted] = 0) OR ([x].[IsDeleted] &amp;lt;&amp;gt; @__ef_filter__IsSoftDeleteFilterEnabled_0)) AND ([x].[TenantId] IS NULL OR (CASE
    WHEN [x].[TenantId] IS NULL
    THEN CAST(1 AS BIT) ELSE CAST(0 AS BIT)
END = @__ef_filter__IsMayHaveTenantFilterEnabled_3))
ORDER BY [x].[UserName], [x].[Id]
OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@__ef_filter__IsSoftDeleteFilterEnabled_0 bit,@__ef_filter__IsMayHaveTenantFilterEnabled_3 bit,@__p&lt;br/&gt;_0 int,@__p_1 int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@__ef_filter__IsSoftDeleteFilterEnabled_0&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;@__ef_filter__IsMayHaveTenantFilterEnabled_3&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;@__p_0&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;@__p_1&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我使用的是：sql 2014&lt;/p&gt;
&lt;p&gt;（再次说明，必须是项目编译通过之后，把MyHotelApp.Web.Host设为启动项目）&lt;/p&gt;
&lt;p&gt;在VS打开，程序包管理器控制台，并设：EntityFrameworkCore为默认项目，在命令行，输入:update-database  ,并回车，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32982/201807/32982-20180724011436929-467601799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 这里，点运行：等待程序运行，将会在浏览器出现下面界面：表示成功，就可以测试各API是否正常：&lt;/p&gt;
&lt;p&gt;登录：admin&lt;/p&gt;
&lt;p&gt;密码：123qwe&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32982/201807/32982-20180724234122277-152966493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;六、Angular项目使用VSCode打开，并在控制台运行：&lt;/p&gt;
&lt;p&gt;npm install &lt;/p&gt;
&lt;p&gt;（还原程序依赖包）&lt;/p&gt;
&lt;p&gt;成功后再运行：&lt;/p&gt;
&lt;p&gt;npm start&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32982/201807/32982-20180724234159284-487969987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 看到以上界面表示启动Angular成功。&lt;/p&gt;

&lt;p&gt;这时打开浏览器：在地址输入：localhost:4200&lt;/p&gt;
&lt;p&gt;即可看到界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32982/201807/32982-20180724234543958-708433918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户名：admin&lt;/p&gt;
&lt;p&gt;密码：123qwe&lt;/p&gt;

&lt;p&gt;至此已完成环境搭建。&lt;/p&gt;

&lt;p&gt;六、以下说一下配置：&lt;/p&gt;
&lt;p&gt;1、Angular&lt;/p&gt;
&lt;p&gt;   在 文件夹：angular\src\assets  中有一个appconfig.json, 内容如下：&lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;&quot;remoteServiceBaseUrl&quot;: &quot;http://localhost:21021&quot;,&lt;/p&gt;
&lt;p&gt;&quot;appBaseUrl&quot;: &quot;http://localhost:4200&quot;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&quot;remoteServiceBaseUrl&quot;: &quot;http://localhost:21021&quot;,   这个就是配黑齿这套代码的：API访问的地址&lt;/p&gt;

&lt;p&gt;2、网站：在XXX.Web.Host 配置的参数（开发可以用默），文件名：appsettings.json中&lt;/p&gt;

&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;{&lt;br/&gt;&quot;ConnectionStrings&quot;: {&lt;br/&gt;&quot;Default&quot;: &quot;Server=localhost\\sql2014; Database=MyHotelAppDb; Trusted_Connection=True;&quot;&lt;br/&gt;},&lt;br/&gt;&quot;App&quot;: {&lt;br/&gt;&quot;ServerRootAddress&quot;: &quot;http://localhost:21021/&quot;,&lt;br/&gt;&quot;ClientRootAddress&quot;: &quot;http://localhost:4200/&quot;,&lt;br/&gt;&quot;CorsOrigins&quot;: &quot;http://localhost:4200,http://localhost:8080,http://localhost:8081&quot;&lt;br/&gt;},&lt;br/&gt;&quot;Authentication&quot;: {&lt;br/&gt;&quot;JwtBearer&quot;: {&lt;br/&gt;&quot;IsEnabled&quot;: &quot;true&quot;,&lt;br/&gt;&quot;SecurityKey&quot;: &quot;MyHotelApp_C421AAEE0D114E9C&quot;,&lt;br/&gt;&quot;Issuer&quot;: &quot;MyHotelApp&quot;,&lt;br/&gt;&quot;Audience&quot;: &quot;MyHotelApp&quot;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;返回有点像这个。&lt;/p&gt;
&lt;p&gt;暂时写这么多&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Tue, 24 Jul 2018 15:54:00 +0000</pubDate>
<dc:creator>清风笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KevinMO/p/9363466.html</dc:identifier>
</item>
<item>
<title>从windows10迁移到Linux Deepin - qingshanli</title>
<link>http://www.cnblogs.com/qingshanli/p/9361840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingshanli/p/9361840.html</guid>
<description>&lt;p&gt;如题, 这几天从windows系统迁移到deepin的linux系统花了很多时间, 以致最近都没时间来博客园。现在将这几天的成果分享出来, 顺便也做个记录。先不多说, 上一张新系统界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180724180004748-50331983.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实在装deepin之前, 我是装的&lt;a href=&quot;https://www.manjaro.cn&quot; target=&quot;_blank&quot;&gt;基于Arch Linux的Manjaro&lt;/a&gt;, 先是参照&lt;a href=&quot;https://www.cnblogs.com/demonxian3/p/9259912.html&quot; target=&quot;_blank&quot;&gt;完美脱离Windows!! Linux发行版第一系统 Manjaro 开箱教程&lt;/a&gt;装了Manjaro Deepin社区版, 发现系统在我电脑上很不稳定, 经常卡死机, 然后就去官方下载了 &lt;a href=&quot;https://www.manjaro.cn/153&quot; target=&quot;_blank&quot;&gt;稳定版Manjaro XFCE&lt;/a&gt;重装, 却又发现XFCE界面和windows相似, 非常不美观。到此我已对Manjaro失去耐心, 不想再浪费时间，就转投了Deepin的怀抱。此次换系统可谓是一波三折, 中间遇到的问题如果网上已经有解决方案, 我会直接贴出亲测过的有用链接, 不再重复造轮子。&lt;/p&gt;
&lt;p&gt;换系统之前, 首先对windows10系统进行磁盘清理:  &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/beatkirito/p/4986979.html&quot;&gt;释放你的硬盘空间！——Windows 磁盘清理技巧&lt;/a&gt;   &lt;a href=&quot;https://blog.csdn.net/yy763496668/article/details/71773584&quot; target=&quot;_blank&quot;&gt;清理C盘空间，给Win7释放更多C盘容量&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果装的是Manjaro, 可以参考: &lt;a href=&quot;https://www.cnblogs.com/demonxian3/p/9259912.html&quot; target=&quot;_blank&quot;&gt;完美脱离Windows!! Linux发行版第一系统 Manjaro 开箱教程&lt;/a&gt;         &lt;a href=&quot;https://blog.csdn.net/daerzei/article/details/79501000&quot; target=&quot;_blank&quot;&gt;VMware虚拟机下Manjaro17.1.6安装详细教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果装的是Deepin, 可以参考: &lt;a href=&quot;https://www.deepin.org/installation/&quot; target=&quot;_blank&quot;&gt;如何安装&lt;/a&gt;             &lt;a href=&quot;https://wiki.deepin.org&quot; target=&quot;_blank&quot;&gt;深度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有个好处就是, 如果你安装的是Deepin, 在安装过程中以及装好后如有遇到解决不了的问题, 可以去 &lt;a href=&quot;https://bbs.deepin.org&quot; target=&quot;_blank&quot;&gt;深度社区&lt;/a&gt; 提问, 会有热心人解答。当然了Manjaro也有自己的社区, 但是在国内没有Deepin活跃........&lt;/p&gt;
&lt;p&gt;装好deepin之后, 好多软件都是给我们预装好的, 但是有些windows平台的软件没有linux版本, 这就用到了 Deepin商店的 &lt;a href=&quot;https://baike.baidu.com/item/crossover/7672017&quot; target=&quot;_blank&quot;&gt;CrossOver&lt;/a&gt; , CrossOver能帮我们将一些windows平台的软件移植到linux平台上运行, 但不是所有的多能移植, 这个得自己去尝试。&lt;/p&gt;
&lt;p&gt;之后就是开发工具 &lt;span&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/download/previous.html&quot; target=&quot;_blank&quot;&gt;IntelliJ IDEA&lt;/a&gt; &lt;/span&gt; 的安装和配置转移了, Idea的linux版本分为不带JDK的运行环境和自带JDK的运行环境两个选项可供下载:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180724213956828-1941988929.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重点来了! 重要的事情说三遍! 说三遍! 说三遍!  &lt;strong&gt;不要下载 &lt;span&gt;不带JDK&lt;/span&gt; 的IDEA, 不然后面会遇到很多麻烦&lt;/strong&gt;。我一开始是下载的 不带JDK 的IDEA, 且本地使用的jdk1.7, 这时启动 IDEA 启动不起来, 报异常显示 当前的jdk环境不能编译 类版本号为52 的类(jdk1.7对应类版本为51, jdk1.8对应类版本为52), 这是因为 IDEA  从2016年后面的版本都需要 jdk1.8 的运行环境支撑才能运行, 所以需要另外给 IDEA 配置 JDK1.8 的运行环境。&lt;/p&gt;
&lt;p&gt;另外 不带JDK 的IDEA, 比自带JDK 的IDEA少了一个&lt;span&gt;jre64&lt;/span&gt;目录, 并且linux的IDEA比windows平台上少了好多字体, 比如我们常用的等宽字体 &lt;span&gt;consolas&lt;/span&gt; 和 &lt;span&gt;courier new&lt;/span&gt; 字体就没有, 而后面我们添加新字体都要在下图中的 &lt;span&gt;jre64\lib\fonts&lt;/span&gt; 目录下操作, 所以这里建议直接下载 自带JDK 的IDEA, 少折腾浪费时间多敲代码赚钱。。。。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180724220339864-1694431385.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装IDEA的破解教程请看这里:   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.igs.cc/03/30/593/&quot; target=&quot;_blank&quot;&gt;IntelliJ IDEA 软件离线破解教程（转）已更新到2018.1.6版本&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/shengshengshiwo/article/details/79599761&quot; target=&quot;_blank&quot;&gt;Intellij IDEA的激活（使用破解补丁永久激活）&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;补丁请去下载最新的2.9版本, 低版本补丁已失效, 使用低版本注册激活码会报 invalid key 错误。&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;一切就绪后, 可以按照 &lt;a href=&quot;https://blog.csdn.net/dancing_power/article/details/62949737&quot; target=&quot;_blank&quot;&gt;linux 下创建idea的桌面快捷方式&lt;/a&gt; 为我们的IDEA创建桌面快捷方式。&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;为IDEA安装热部署插件Jrebel, 按照 &lt;a href=&quot;https://blog.csdn.net/cjwcjwwjcwjc/article/details/80050633&quot; target=&quot;_blank&quot;&gt;Jrebel 激活服务&lt;/a&gt; 破解插件。&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;按照  &lt;a href=&quot;https://blog.csdn.net/u012078554/article/details/80675729&quot; target=&quot;_blank&quot;&gt;Linux IntelliJ IDEA 2018 版本 SVN配置&lt;/a&gt; 为IDEA集成 SVN版本控制， 命令：&lt;span&gt; sudo apt install subversion&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;在IDEA中添加&lt;span&gt;consolas&lt;/span&gt; 和 &lt;span&gt;courier new &lt;span&gt;字体: 首先在 &lt;a href=&quot;https://linux.linuxidc.com/index.php?folder=MjAxM8Tq18rBzy8xMdTCLzExyNUvSW50ZWxsaUogSURFQSDX1szlw8C7ryhhbnRpLWFsaWFzZWQpus3X1szlzO280w==&quot; target=&quot;_blank&quot;&gt;IntelliJ IDEA 字体美化(anti-aliased)和字体添加&lt;/a&gt; 中下载 这两种字体, 解压后将字体文件复制到你自己的IDEA安装目录下的对应子目录中, 下面是我复制的字体:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180724223623015-83282240.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;这里其实我们刚复制进来时, 文件是没有读取权限的 , 所以启动IDEA后是读取不到这几个新添加的字体的。还需要用命令: &lt;span&gt; sudo chmod 644 consola* cour* &lt;/span&gt; 给这几个文件添加读的权限, 添加权限后,  IDEA设置出现新的字体: &lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180724224825659-1083723831.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;另外字体还可以参照 &lt;a href=&quot;https://www.v2ex.com/t/176310&quot; target=&quot;_blank&quot;&gt;以前你们说 Jetbrains 在 Linux 下字体差，我以为是真的&lt;/a&gt; 修改抗锯齿效果, 让字体更加美观。&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;IDEA配置好tomcat、maven后, 启动项目时报类似 Error running Tomcat 8.5.31: Error copying configuration files from /usr/local/apache-tomcat-8.5.3/conf to /Users/zhouyuchen/Library/Caches/IntelliJIdea2016.1/tomcat/Tomcat_8_5_31_ttt/conf: Directory is invalid /usr/local/apache-tomcat-8.5.3/conf/Catalina 的异常, 参照 &lt;a href=&quot;https://blog.csdn.net/sunshinegirl168660/article/details/72674305&quot; target=&quot;_blank&quot;&gt;Ubuntu 系统中运行idea出现error running问题&lt;/a&gt; , 修改tomcat主目录权限, 命令: &lt;span&gt;chmod -R 755 tomcat主目录&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;span&gt;&lt;span&gt;上面问题解决后, 启动项目报 org.springframework.jndi.JndiLookupFailureException: JndiObjectTargetSource failed to obtain new target object; nested exception is javax.naming.NameNotFoundException: Name [XXXXX] is not bound in this Context. Unable to find [jboss] 异常, 按网上普遍方案在项目中的web.xml下添加几行配置还是报错, 后面是将本地的tomcat8.0.53换成低版本的 tomcat8.0.47 就解决异常了......&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;span&gt;&lt;span&gt;上面一切完成后, IDEA才算是基本的配置好, 可以再讲我们之前的 IDEA 的&lt;strong&gt;个性化配置目录&lt;/strong&gt;(这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置)拷贝到我们新的IDEA开发环境中, 具体该目录的位置及功能介绍参照:   &lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/installation-directory-introduce.md&quot; target=&quot;_blank&quot;&gt;IntelliJ IDEA 相关核心文件和目录介绍&lt;/a&gt; 。另外, 如果需要重新对IDEA进行个性化设置, 可以参照  &lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial&quot; target=&quot;_blank&quot;&gt;IntelliJ IDEA 简体中文专题教程&lt;/a&gt; 。&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;linux下命令参考: &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/wangkongming/p/4531341.html&quot;&gt;Linux查看系统信息的一些命令及查看已安装软件包的命令&lt;/a&gt;    &lt;a href=&quot;https://blog.csdn.net/a8039974/article/details/76977278/&quot; target=&quot;_blank&quot;&gt;整理了一下linux/ubuntu里面卸载软件的方法&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;因为linux下svn图形界面客户端都不怎么好用, 试了好几种直接转命令行了:   &lt;a href=&quot;https://blog.csdn.net/prettyshuang/article/details/38421205&quot; target=&quot;_blank&quot;&gt;svn常用命令详解（很全，很实用）&lt;/a&gt;      &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lushilin/p/6100997.html&quot;&gt;linux下svn命令使用大全&lt;/a&gt;  &lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;安装包时可能会遇到  &lt;span&gt;apt-get install XXX: 无法定位软件包 &lt;/span&gt;问题, 参考  &lt;a href=&quot;https://blog.csdn.net/printwsl/article/details/80454285&quot; target=&quot;_blank&quot;&gt;telnet服务器与客户端配置（以及常见问题） &lt;/a&gt;    &lt;a href=&quot;http://www.baiyuxiong.com/?p=529&quot; target=&quot;_blank&quot;&gt;ubuntu sudo update与upgrade的作用及区别&lt;/a&gt;    &lt;a href=&quot;https://opsx.alibaba.com/mirror?lang=zh-cn&quot; target=&quot;_blank&quot;&gt;linux软件包镜像源&lt;/a&gt; , 在 /etc/apt/sources.list 中添加镜像源, 然后命令  &lt;span&gt;sudo apt-get update &lt;/span&gt; 更新软件包列表即可。&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;span&gt;..............................................................................................................未完待续, 后面遇到的问题会陆续完善到本篇文章中, 如有错误欢迎指正。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 15:44:00 +0000</pubDate>
<dc:creator>qingshanli</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingshanli/p/9361840.html</dc:identifier>
</item>
</channel>
</rss>