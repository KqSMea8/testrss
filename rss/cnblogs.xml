<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Entity Framework Core 2.1，添加种子数据 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9868501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9868501.html</guid>
<description>&lt;p&gt;EFCore 2.1出来有一段时间了，里面的新功能还没怎么用，今天研究下如何使用EF Core 2.1添加种子数据。&lt;/p&gt;
&lt;p&gt;这部分的官方文档地址是：&lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding&lt;/a&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-2.1&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们在开发时总是需要添加一些种子数据的，所以这个功能还是比较有用的。&lt;/p&gt;


&lt;p&gt;我建立了一个ASP.NET Core项目，里面有几个Model，其中一个是省份Province，另一个是城市City：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029054017324-1922275577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029054051403-1230467215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;里面还涉及到其它的Model，不过本文用不到，就不贴了。&lt;/p&gt;

&lt;p&gt;该项目使用的数据库是&lt;strong&gt;MSSQL LocalDB&lt;/strong&gt;。并已经做好了上述Models的迁移工作。&lt;/p&gt;
&lt;p&gt;该数据库里面存在过一些数据，但是现在都被我删除了。&lt;/p&gt;


&lt;p&gt;直接在DBContext的OnModelCreating方法里使用&lt;span&gt;&lt;strong&gt;HasData()&lt;/strong&gt;&lt;/span&gt;方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029055330532-1889179323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我添加了一个省份的种子数据，并&lt;span&gt;&lt;strong&gt;写上了主键Id的值&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;数据库该表的主键Id是int自增的。Id为1的数据曾经存在过，但是被我删除了。&lt;/p&gt;
&lt;p&gt;然后看看会发生什么&lt;/p&gt;

&lt;h2&gt;生成的迁移类&lt;/h2&gt;
&lt;p&gt;命令：Add-Migration Xxx&lt;/p&gt;
&lt;p&gt;看一下生成的迁移类的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029055531648-492282651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;生成的SQL脚本&lt;/h2&gt;
&lt;p&gt;命令：Script-Migration&lt;/p&gt;
&lt;p&gt;这是里面关于插入数据的部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029055724239-749616151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 迁移到数据库&lt;/h2&gt;
&lt;p&gt;命令：Update-Database -Verbose&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029060122384-1157086397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果是成功的。&lt;/p&gt;
&lt;p&gt;看红线那两句话，EFCore在执行的过程中临时更改了设置，可以插入主键的值，然后又禁用了插入主键。&lt;/p&gt;

&lt;h2&gt;数据库里面的数据&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029060317728-863638801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然曾经存在过Id为1的数据（然后被删除了），但是Id为1的种子数据仍然可以插入进去。&lt;/p&gt;


&lt;p&gt;我再添加一个没有主键Id值的种子数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029060650222-1335732742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后Add-Migration，看看会发生什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029060733333-552886915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报错了，所以&lt;strong&gt;主键值是必填&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;当我填写了主键值之后，一切都是好用的了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029060837166-113214507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029060922343-725474163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;更改现有的种子数据&lt;/h2&gt;
&lt;p&gt;我在HasData方法里更改了现有的种子数据，但是主键的值并没有改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029061120587-1299294566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行Update-Database时的SQL语句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029061247018-441599168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到是根据主键对数据库里面的数据进行Update动作。&lt;/p&gt;

&lt;p&gt;其结果也和我想的一样，就是更新了现有的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029061335115-1008723872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;如果我把HasData里种子数据的主键值修改了&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029061442783-256995046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我把四川的主键从2改为3。&lt;/p&gt;

&lt;p&gt;看下生成的迁移文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029061537848-828641056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先删除了之前添加的Id为2的种子数据，然后把插入了一笔Id为3的数据。&lt;/p&gt;

&lt;p&gt;看下SQL：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029061655111-452077279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是先Delete，再Insert。&lt;/p&gt;

&lt;p&gt;数据库里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029061733480-2018292166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;种子数据为什么要指定主键的值？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; 因为在团队开发时，这样可以确保不同的开发人员、电脑、服务器上，在同一个迁移版本具有相同的种子数据&lt;/strong&gt;。&lt;/p&gt;


&lt;p&gt;Province和City是一对多的关系，也就是说一个Province可以有多个City，而且它们之间有导航属性。&lt;/p&gt;
&lt;p&gt;下面看看一次性添加Province和City是否可以行，我直接在HasData方法里这样写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029062633863-2124927858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后Add-Migration&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029062713551-1267141332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样做不行。我&lt;strong&gt;必须单独添加City的种子数据，并且设置好外键&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以正确的做法是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029063131500-311753475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次Add-Migration没有报错，迁移也成功了，看一下最后的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029063323497-659654522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;


&lt;p&gt;有时，我们在主从关系的Model里不明确定义外键；有时候我们Model的主键是private set的；&lt;/p&gt;
&lt;p&gt;这时我们就无法在HasData里设置主键/外键的值了，那么如何来添加种子数据呢？&lt;/p&gt;
&lt;p&gt;答案就是使用&lt;span&gt;&lt;strong&gt;匿名类&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;我把City Model里的外键去掉（导航属性仍然保留，和Province的主从关系依然存在）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029064424641-875825792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后就可以这样添加种子数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029064143506-585369666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;迁移后的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029064447576-1124298715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果仍然如预期一样。&lt;/p&gt;

&lt;h2&gt;如果主键是Guid类型呢？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029064941091-415449221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029065016080-1836545853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;貌似没问题。&lt;/p&gt;

&lt;p&gt;如果我不修改这个种子数据，再执行一次迁移呢？&lt;/p&gt;
&lt;p&gt;看一下这时的迁移文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029065106759-1210515666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除原来的数据，再插入一个新的数据。。&lt;/p&gt;
&lt;p&gt;数据库里也是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029065157655-1474703448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以最好的办法是&lt;strong&gt;把Guid的值放在一个变量里&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029065449630-1598699688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再操作一遍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201810/986268-20181029065526709-1735013459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就不会出现“把原有数据删掉，再重新插入”这种操作了。&lt;/p&gt;


&lt;p&gt;使用context.Database.&lt;strong&gt;EnsureCreated()&lt;/strong&gt;会创建一个新的数据库，并包含有种子数据。但是如果数据库已经存在了，那么EnsureCreated()不会更新数据库，也不会添加种子数据了。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Oct 2018 23:00:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>EFCore 2.1出来有一段时间了，里面的新功能还没怎么用，今天研究下如何使用EF Core 2.1添加种子数据。 这部分的官方文档地址是：https://docs.microsoft.com/en</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9868501.html</dc:identifier>
</item>
<item>
<title>我为什么写博客？ - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/9863466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/9863466.html</guid>
<description>&lt;p&gt;　　写博客也有一年多了，随着时间的推移，短短的一年多，我写博客的目的、方法也在不断的变化中。&lt;/p&gt;
&lt;p&gt;　　本来，写博客这个动作本应该提前至少十年，可是却一拖再拖，也一直没有去写。一年半之前，因为一些变化，突然觉得自己确实应该写一点，目的也很简单，就是单纯的觉得别人都在写，我还是写点什么吧，似乎这样才像一个搞信息技术的。想来，如果早个十年来写这些文章，怕是当网红都有可能。其实，自己还算有大把时间，为什么不写，也只能归结于思想上的懒。&lt;/p&gt;
&lt;p&gt;　　最开始的时候写博客，也就是想随便可能分享点什么，于是就按自己可能分享的东西给出了几个很粗的分类——“软件”、“数学”、“硬件”，再加个发水文的“随想”吧。为了体现算法多少有一定工程的意义，又独立出一个“算法”类别。于是最开始的几篇文章塞到这几个分类里就这么发出去了。&lt;/p&gt;
&lt;p&gt;　　再后来，想想似乎某些要解决的工程问题题材的文章很难归入到其中，于是加了一类叫“解决方案”，所有我不知道该如何分类而牵涉面又广的文章都放到“解决方案”里。&lt;/p&gt;
&lt;p&gt;　　再看看别人的博客，大多分类比我细的多，牵涉到一个个细小的技术。我也曾觉得我是不是分类太过于粗线条，是不是也该和别人一样，引入细的分类，分上个很多个。但慢慢的，我的博客写作风格正在形成，现在看来，似乎觉得没有这个必要了。我喜欢写的文章似乎不是针对某种具体的技术，而是可能由一个问题引发一堆小问题，这些小问题看起来都很散，无法规范为到底是哪一类小问题，一个很大的分类完全就适合我。另外，在我解决某些问题的时候，可能喜欢使用好几种不同的计算机语言，这可能源于我长期以来形成的混编思维，我觉得合适的语言干合适的事情，所有计算机问题的解决都是开发效率、运行效率、维护效率之间的博弈。虽然一篇博文的分类可以填多个，但我就是固执的每次只选择一个，绝不选择第二个。&lt;/p&gt;
&lt;p&gt;　　再者，我不是很赞成纯粹的知识点式阶梯学习，学习过程似乎并不应该是这样。想想我学习计算机的过程，那是从一个信息技术的荒漠开始，慢慢开始发几个芽，然后慢慢的开始理解到某些东西是一个系统化的东西，于是每个点开始开花结果，然后各个点互相渗透、打通各个关节，形成一大片的学科认知体系。这个过程就如同造跨海大桥一般，先是抽水打一个个的桥墩，然后以每个桥墩为中心延伸，直到形成大桥。完整知识体系的学习过程，应该更接近于我的描述，而并非由显而易见的一堆阶梯构成。从而，在这样的认为下，我们最重要的学习不在于知识点本身，而在于知识点和知识点之间的作用与联系，合多个知识点之力如何解决一个问题，而每一次解决一个横跨多个知识点的问题都是一次对于彼此作用与联系的训练。这跟神经网络很像，单个的神经元功能实在单一，但很多神经元彼此联系在一起构成神经网络，却可以爆发出巨大的威力。&lt;/p&gt;
&lt;p&gt;　　而我现在写博客的目的，却也未必是单纯的供给他人学习。首先写博客前，选材，选好材之后，对之进行探索，等探索出了东西，才可以开始提笔，然后探索和写作并行，直到博文完成。这个过程，完全是自己在训练自己，对知识的再次巩固过程。所以，写博客的目的，首先在于自己通过问题整理思路，巩固知识。其次，才是分享给大家。&lt;/p&gt;
&lt;p&gt;　　而对于分享这点，想起很多年前，公司里培训，我每次都精心准备我的培训话题以及讲解时的ppt，很多东西是和当前工作看起来无关的东西。有朋友问我，这些东西看起来就难，真的指望培训的时候有人愿意听的进去？我说，到了工程师，的确很多人的思维都定型了，的确很难扭转他们什么，听课时也不用太指望一帮工程师们可以按着你的思维走，从头到尾明白在讲什么，这些太不现实了。但是，我可以尽量讲的精彩一点点，让工程师们哪怕抓住其中的一个片段，或者记住其中的几个关键字，产生那么一点点兴趣，这样就有自己日后去自我学习乃至提升的可能。于是，如果培训能给工程师们甚至一个工程师带来一点点不一样的惊喜，那么培训的目的也就达到了。&lt;/p&gt;
&lt;p&gt;　　其实，我写博客也一样是这样，只要打动人一点点，带给人一点点思考，其实也就足够。当然，顺带的，如果可以当个网红当然再好不过，只可惜遥遥无期，哈哈。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 16:35:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<og:description>写博客也有一年多了，随着时间的推移，短短的一年多，我写博客的目的、方法也在不断的变化中。 本来，写博客这个动作本应该提前至少十年，可是却一拖再拖，也一直没有去写。一年半之前，因为一些变化，突然觉得自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/9863466.html</dc:identifier>
</item>
<item>
<title>es6划重点 - IT-caijw</title>
<link>http://www.cnblogs.com/caijw/p/9868181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caijw/p/9868181.html</guid>
<description>&lt;h2 id=&quot;作用域变量&quot;&gt;1.作用域变量&lt;/h2&gt;
&lt;h3 id=&quot;let和var对比&quot;&gt;1.1.&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;var&lt;/code&gt;对比&lt;/h3&gt;
&lt;h4 id=&quot;变量不提升&quot;&gt;1.变量不提升&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 可能会造成变量提升&lt;/p&gt;&lt;p&gt;这里变量提升了,先声明&lt;code&gt;a&lt;/code&gt;然后打印再赋值,结果是&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(a);//undefined
var a = 1;

//相当于
var a;
console.log(a);
a = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt;的话，变量不会提升，打印的时候，会&lt;code&gt;报错&lt;/code&gt;，因为还没声明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(a);//a is not defined
let a = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;不能重复定义&quot;&gt;2.不能重复定义&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 可能会被重新赋值, &lt;code&gt;let&lt;/code&gt;不能重复声明一个变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var a = 1;
var a = 2;
console.log(a);//2&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;let a = 1;
let a = 2;//Identifier 'a' has already been declared 这里是说它已经被声明了，不能重复声明
console.log(a);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;暂存死区&quot;&gt;3.暂存死区&lt;/h4&gt;
&lt;p&gt;var的作用域问题 (函数作用域 全局作用域) (let 暂存死区)&lt;/p&gt;&lt;p&gt;只要块级作用域内存在&lt;code&gt;let&lt;/code&gt;命令，它所声明的变量就“绑定”（&lt;code&gt;binding&lt;/code&gt;）这个区域，不再受外部的影响。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    let a = 1;
}
console.log(a);//a is not defined&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{
    var a = 1;
}
console.log(a)//1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;闭包新写法&quot;&gt;4.闭包新写法&lt;/h4&gt;
&lt;p&gt;以前&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;;(function () {

})();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;const常量&quot;&gt;2.const(常量)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;声明一个只读的常量。一旦声明，常量的值就不能改变。&lt;/p&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt;命令声明的&lt;code&gt;常量&lt;/code&gt;也是&lt;code&gt;不提升&lt;/code&gt;，同样存在&lt;code&gt;暂时性死区&lt;/code&gt;，只能在&lt;code&gt;声明的位置后面使用&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const PI = 3.141593
PI &amp;gt; 3.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;es5写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object.defineProperty(typeof global === &quot;object&quot; ? global : window, &quot;PI&quot;, {
    value:        3.141593,
    enumerable:   true,//对象属性是否可通过for-in循环，flase为不可循环，默认值为true
    writable:     false,//对象属性是否可修改,flase为不可修改，默认值为true
    configurable: false//能否使用delete、能否需改属性特性、或能否修改访问器属性
})
PI &amp;gt; 3.0;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解构&quot;&gt;3.解构&lt;/h2&gt;
&lt;h3 id=&quot;数组解构&quot;&gt;1.数组解构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let [,b,c,d=100] = [1,2,3];
console.log(b,d);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对象解构&quot;&gt;2.对象解构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let obj = {name:'cjw',age:18};
//这里重新命名了
let {name:Name,age,address=&quot;默认&quot;} = obj;
console.log(Name, age, address)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;混合解构&quot;&gt;3.混合解构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let [{name}] =  [{name:'cjw'}];&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;传递参数结果解构&quot;&gt;4.传递参数，结果解构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Promise.all(['cjw','9']).then(([name,age])=&amp;gt;{
  console.log(name, age);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;拷贝&quot;&gt;4.拷贝&lt;/h2&gt;
&lt;h3 id=&quot;浅拷贝&quot;&gt;4.1.浅拷贝&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let arr1 = [1,2,3,[1,2,3]];
let arr2 = [1,2,3];
let arr = [...arr1,...arr2];
console.log(arr)
arr1[3][0] = 100;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对象合并&quot;&gt;4.2.对象合并&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let school = {name:'zfpx',a:{a:1}};
let my  = {age:18};
let newObj = {...school,a:{...school.a},...my}; 
console.log(newObj)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;json.parsejson.stringify&quot;&gt;4.3.JSON.parse(JSON.stringify())&lt;/h3&gt;
&lt;p&gt;这个只能拷贝普通对象，new Date之类不能拷贝&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let school = { name: 'zfpx', a: { a: 1 } ,date:new Date(),reg:new RegExp(/\d+/),fn:function(){}};
let s = JSON.parse(JSON.stringify(school));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;深拷贝递归拷贝&quot;&gt;4.4.深拷贝（递归拷贝）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;function deepClone(obj) { // 递归拷贝 深拷贝
  if(obj == null) return null;
  if (obj instanceof Date) return new Date(obj);
  if(obj instanceof RegExp) return new RegExp(obj);
  if(typeof obj !== 'object') return obj;
  let t = new obj.constructor
  for(let key in obj ){
    t[key] = deepClone(obj[key])
  }
  return t;
}
let o = { a: [1, 2, 3] }
let r = deepClone(o);
o.a[1] = 1000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;展开运算符&quot;&gt;4.5.展开运算符&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 剩余运算符只能用在最后一个参数
function test(a, b,...c) { // c = [5,6,7]
  // 将类数组转化成数组
  let d = Array.prototype.slice.call(arguments,2)
  // a,b,...c
  let e =  Array.from(arguments).slice(2);
  let arr = [...arguments].slice(2);
  console.log(e);
}
test(1,2,3,5,6,7);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把多个对象的属性复制到一个对象中,第一个参数是复制的对象,从第二个参数开始往后,都是复制的源对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Object.assign  {...} 
let name ={name:'zfpx'}
let age = {age:9}
let obj = Object.assign(name,age); // {...}
console.log(obj);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代理proxy&quot;&gt;5. 代理proxy&lt;/h2&gt;
&lt;h3 id=&quot;普通函数defineproperty&quot;&gt;5.1.普通函数（defineProperty）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Object.defineProperty(obj, 'PI', {
    enumerable: true,
    configurable: false,
    get(){
        console.log('get');
    },
    set(){
        console.log('set');
        val = v;
    }
})
obj.PI = 3.15;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mvvm&quot;&gt;5.2.mvvm&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let obj = {name: {name: 'cjw'}, age: 18};
function observer(obj){
    if(typeof obj != 'object') return obj;
    for(let key in obj){
        defineReactive(obj, key, obj[key]);
    }
}
function defineReactive(obj, key, value){
    observer(value);
    Object.defineProperty(obj, key, {
        get(){
            return value;
        },
        set(){
            console.log('update');
        }
    })
}
observer(obj);
obj.name.name = 'cjw';&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;普通代理&quot;&gt;5.3 普通代理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let proxy = new Proxy(obj, {
    set(target, key, value){
        if(key === 'length') return true;
        console.log('update');
        return Reflect.set(target, key, value);
    },
    get(target, key){
        return Reflect.get(target, key);
    }
})
proxy.push('123');
console.log(proxy.length);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多层代理&quot;&gt;5.4 多层代理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let obj = {name: {name: 'cjw'}, age : 18};
function set(obj, callback){
    let proxy = new Proxy(obj, {
        set(target, key ,value){
            if(key === 'length') return true;
            console.log('更新');
            return Reflect.set(target, key, value);
        },
        get(target, key){
            return Reflect.get(target, key);
        }
    })
    callback(proxy);
}
set(obj, function(proxy){
    proxy.age = '100';
    console.log(proxy);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;箭头函数&quot;&gt;6.箭头函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 指向&lt;/p&gt;&lt;p&gt;去掉&lt;code&gt;function&lt;/code&gt; 关键字&lt;/p&gt;&lt;p&gt;去掉&lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;普通剪头函数&quot;&gt;6.1 普通剪头函数&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;function a(a) {
  return function (b) {
    return a + b;
  }
}
let a = a =&amp;gt; b =&amp;gt; a + b;
console.log(a(1)(2));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类数组&quot;&gt;6.2 类数组&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let a = (...arguments) =&amp;gt; {
  console.log(arguments)
}
a(1, 2, 3);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;this指向问题&quot;&gt;6.3 this指向问题&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// this指向问题
let obj = {
  a: 1,
  b() { // obj = this
    console.log(this);
    setTimeout(() =&amp;gt; { // 箭头函数中没有this指向 从而解决了this的问题
      this.a = 100;
    }, 1000);
  }
}
obj.b();
setTimeout(() =&amp;gt; {
  console.log(obj.a)
}, 2000);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;let不会将变量放在window上&quot;&gt;6.4 let不会将变量放在window上&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let a = 1000; // let不会将变量放在window上
let obj = {
  a: 1,
  b: () =&amp;gt; {
    this.a = 100; // window
  }
}
obj.b();
console.log(obj.a,a);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;arr数组新方法&quot;&gt;7.arr(数组新方法)&lt;/h2&gt;
&lt;p&gt;filter过滤 forEach 循环 map 映射 reduce 收敛 some every 反义&lt;/p&gt;
&lt;h3 id=&quot;reduce收敛&quot;&gt;7.1 reduce(收敛)&lt;/h3&gt;
&lt;p&gt;原生写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1,2,3,4,5];
Array.prototype.myReduce = function (callback,prev) {
  for(let i = 0 ; i&amp;lt;this.length;i++){
    if(!prev){
      // 0 1
      prev = callback(this[i],this[i+1],i+1,this);
      i++;
    }else{
      prev = callback(prev,this[i],i+1,this);
    }
  }
  return prev
}
let r = arr.myReduce((prev,next,currentIndex,arr)=&amp;gt;{
  return prev+next
},100)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;filter过滤&quot;&gt;7.2 filter(过滤)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1,2,3]
let arr1 = arr.filter(item=&amp;gt;item&amp;lt;=2);
console.log(arr1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map&quot;&gt;7.3 map&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let arr =[1,2,3];
let arr1 = arr.map(item=&amp;gt;item*2);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;every&quot;&gt;7.3 every&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1,2,3];
let flag = arr.every(item=&amp;gt;item==3);
console.log(arr.includes(3)); //es7&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;findindex&quot;&gt;7.4 findIndex&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3];
let item = arr.find(item =&amp;gt; item == 4);
console.log(item); //es7&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;array.from&quot;&gt;7.5 Array.from&lt;/h3&gt;
&lt;p&gt;将一个数组或者类数组变成数组,会复制一份&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let newArr = Array.from(oldArr);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;array.of&quot;&gt;7.6 Array.of()&lt;/h3&gt;
&lt;p&gt;of是为了将一组数值,转换为数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(Array(3), Array(3).length);
console.log(Array.of(3), Array.of(3).length);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;copywithin&quot;&gt;7.7 copyWithin&lt;/h3&gt;
&lt;p&gt;Array.prototype.copyWithin(target, start = 0, end = this.length) 覆盖目标的下标 开始的下标 结束的后一个的下标&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1, 2, 3, 4, 5].copyWithin(0, 1, 2)//[ 2, 2, 3, 4, 5 ]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;object.keys&quot;&gt;7.8 Object.keys&lt;/h3&gt;
&lt;p&gt;Object.keys可以把对象取出来key组成数组 for of 可以迭代数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (var a of Object.values({ name: 'cjw', age: 9 }) ){ // forEach不能return 
  console.log(a);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;symbol&quot;&gt;8.Symbol&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;let s = Symbol();
let q = Symbol();

console.log(s === q);//false

let s = Symbol.for('cjw');
let q = Symbol.for('cjw');
console.log(s);//Symbol(cjw)
console.log(q);//Symbol(cjw)

console.log(Symbol.keyFor(q));
console.log(s === q);//ture&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;template&quot;&gt;9.template&lt;/h2&gt;
&lt;h3 id=&quot;模板字符串&quot;&gt;9.1 模板字符串&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let name = 'cjw';
let age = 9;

let str = `${name}今年${age}`;
console.log(str);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模板字符串实现原理&quot;&gt;9.2 模板字符串实现原理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let newStr = str.replace(/\$\{([\s\S])\}/g, function(){
    return eval(arguments);
})
console.log(newStr);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;集合&quot;&gt;10.集合&lt;/h2&gt;
&lt;h3 id=&quot;set&quot;&gt;10.1 Set&lt;/h3&gt;
&lt;p&gt;set可以做去重 set不能放重复的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let set = new Set([1,2,3,3,2,1]);
console.log([...set]);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map-1&quot;&gt;10.2 Map&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let map = new Map();
map.set('js','123');
map.set('node','456');
map.forEach(item=&amp;gt;{
  console.log(item);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;class&quot;&gt;11 class&lt;/h2&gt;
&lt;h3 id=&quot;es5-实现的类&quot;&gt;11.1 es5 实现的类&lt;/h3&gt;
&lt;p&gt;// call 构造函数里面的属性方法复制&lt;br/&gt;// Object.crate 复制原型里面的属性和方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Animal(type) {
  this.type = { t: type};
}
Animal.prototype.eat = function () {
  console.log('eat');
}
function Cat(type) {
   Animal.call(this,type); // 让父类在子类中执行，并且this指向子类
}
// 原型上还有一个属性
// 4.继承实例上和原型上的方法
function create(proto) {
  let Fn = function () { }
  Fn.prototype = proto;
  return new Fn();
}
Cat.prototype = Object.create(Animal.prototype,{constructor:{value:Cat}});
let cat = new Cat('哺乳类')
console.log(cat.type);
cat.eat();
console.log(cat.constructor);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;es6-写法&quot;&gt;11.2 es6 写法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class Animal {
    constructor(type){
        this.type = type;
    }
    static flag(){
        return 'animal';
    }
    eat(){
        console.log('eat');
    }
}
class Cat extends Animal{
    constructor(type){
        super(type);
    }
}

let cat = new Cat('哺乳类');
console.log(cat.type);
cat.eat();
console.log(Cat.flag);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;get-与-set&quot;&gt;11.3 get 与 set&lt;/h3&gt;
&lt;p&gt;getter可以用来得获取属性，setter可以去设置属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person {
    constructor(){
        this.hobbies = [];
    }
    set hobby(hobby){
        this.hobbies.push(hobby);
    }
    get hobby(){
        return this.hobbies;
    }
}
let person = new Person();
person.hobby = 'basketball';
person.hobby = 'football';
console.log(person.hobby);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot;&gt;ECMAScript 6 入门 let 和 const 命令--阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://es6-features.org/#Constants&quot;&gt;es6-features.org&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 16:26:00 +0000</pubDate>
<dc:creator>IT-caijw</dc:creator>
<og:description>&lt;! TOC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caijw/p/9868181.html</dc:identifier>
</item>
<item>
<title>聊聊分布式开发 Spring Cloud - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/9813986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/9813986.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;本文章只是简单介绍了微服务开发的一些关键词，如果需要知道具体实现和可以评论留言 我会及时的增加连接写出具体实现(感觉没人看 就没写具体实现)。&lt;/p&gt;
&lt;p&gt;持续更新中。。。。。。&lt;/p&gt;
&lt;h3&gt;SpringCloud和Dubbo的区别&lt;/h3&gt;
&lt;p&gt;Dubbo的定位始终是一款&lt;span&gt;基于传输层(TCP&lt;/span&gt;)的RPC框架，RPC(Remote Procedure Call)通信过程在传输层中完成(HTTP通信在应用层完成)，&lt;/p&gt;
&lt;p&gt;所以RPC调用方式需要服务端与客户端之间建立Socket连接来实现二进制数据的交换&lt;/p&gt;
&lt;p&gt;SpringCloud抛弃了Dubbo的RPC通信，采用的是&lt;span&gt;基于HTTP&lt;/span&gt;的REST方式&lt;span&gt;(Spring Cloud就真正的将整个Rest作为RPC实现技术)。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而SpringCloud的目标是微服务架构下的一站式解决方案。&lt;/p&gt;
&lt;h3&gt;服务治理和服务发现Eureka&lt;/h3&gt;
&lt;p&gt;Spring的服务治理是使用Netflix的Eureka作为服务治理的，它是我们构建Spring Cloud分布式最为核心和最为基础的模块，&lt;/p&gt;
&lt;p&gt;他的作用是&lt;span&gt;注册&lt;/span&gt;和&lt;span&gt;发现&lt;/span&gt;Spring Boot服务，并提供监控管理功能。&lt;/p&gt;
&lt;p&gt;每一个微服务都可以像服务治理中心注册多个节点(服务名称相同，更改端口号 在启动一次即可)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多时候 我们也希望服务治理中心也是多个节点，这才可能满足高可用和负载均衡的要求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决办法: 我们可以采用服务治理中心互相注册来保持相互监控&lt;/p&gt;
&lt;p&gt;服务治理中心名称保持不变，将当前的服务治理中心节点A注册到服务治理中心节点B，然后将服务治理中心节点B注册到服务治理中心节点A。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Eureka心跳机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;微服务客户端之所以可以和Eureka保持联系，依靠的是心跳机制，也就是说你客户端可以自己来进行心跳的配置处理。&lt;/p&gt;
&lt;p&gt;如果最大心跳时间间隔微服务没有进行心跳(如配置2s心跳心跳一次 最大心跳时间间隔5s)，则因为该微服务已经死宕机了(Eureka会默认出现红字提醒)&lt;/p&gt;
&lt;h3&gt;微服务之间的调用&lt;/h3&gt;
&lt;p&gt;Rabbion实际上是一个RestTemplate对象。&lt;/p&gt;
&lt;p&gt;通过注解@LoadBalance 可以让RestTemplete实现负载均衡，也就是通过这个restTemplete对象调用用户微服务请求的时候，Ribbon会自动给用户微服务实现负载均衡，请求会被分摊到微服务的各个节点上。&lt;/p&gt;
&lt;p&gt;Feign声明式调用。&lt;/p&gt;
&lt;p&gt;使用restTemplete对象调用除了编写URL，还需要注意这些参数的组装和结果的返回操作。为了克服这些不友好，Spring Cloud提供了声明式调用组件Feign。&lt;/p&gt;
&lt;p&gt;Feign是一个基于接口的编程方式，开发者只需要声明接口和配置注解，在调度接口方法时，Spring Cloud就根据配置来调度对应的REST风格的请求。&lt;/p&gt;
&lt;h3&gt;断路器—Hystrix&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在互联网中，某一个微服务可能出现故障，为了不蔓延到其他微服务上面导致雪崩效应。断路器会将产生故障的服务节点进行&quot;熔断&quot;，保持各个微服务持续可用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理熔断的方式有 限流、缓存、服务降级，下面介绍服务降级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所谓降级服务，就是当请求发生超时或者发生故障时，就会使用自身服务的其他方法进行相应。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于Hystrix，Spring Cloud还提供了一个仪表盘进行监控短路的情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;路由网关Zuul&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;网关的功能对分布式网站十分重要，首先他可以将请求路由到真是服务器的IP地址，避免直接的攻击真实服务器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其次它也可以作为一种负载均衡的手段，使请求按照一定的算法平摊到多个节点上，减缓单点的压力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;类似Nginx的反向代理和负载均衡&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;SpringCloud Stream&lt;/h3&gt;
&lt;p&gt;Spring Boot之中为了方便开发者，已经整合了消息组件，也提供了有一系列的处理支持。如果按照这样的方式在Spring Cloud之中进行消息处理，有些人会认为比较麻烦。&lt;/p&gt;
&lt;p&gt;所以在Spring Cloud里面将消息整合的处理操作进行了进一步的抽象操作，实现了更加简化的消息处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单总结：SpringCloud Stream就是实现了MDB功能，同时可以增加更加简化方便的整合消息组件。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Docker&lt;/h3&gt;
&lt;p&gt;几乎每个有趣的应用都至少有一个类似数据库或者消息中间件的基础设施服务，我们可以选择把这些基础设施服务安装在自己的机器上。&lt;/p&gt;
&lt;p&gt;不幸的是安装起来并不容易，就比如说之前在window上安装mysql各种问题。如果有一键安装的配置就完美了，并且我们并不喜欢在自己的机器上装满各种乱七八糟的服务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此我们要用docker容器，docker将作为一个容器运行我们需要的所有的服务。(Nginx Mq Redis Mysql 等等等等)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Docker几个重要的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，我们首先需要将程序打包到Docker镜像中，随后才能将镜像交给其他人使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们获取到Docker镜像以后，可以随时运行该Docker镜像，此时变会启动一个Docker容器，该容器将运行镜像中封装的程序&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果我们把Docker镜像理解为JAVA类的话，那么Docker容器就相当于Java实列。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集中存放镜像文件的地方(可以理解为GitHub这样的托管服务器)&lt;/p&gt;
&lt;h3&gt;Jenkins&lt;/h3&gt;
&lt;p&gt;我们使用Git管理代码，使用Maven构建项目，使用Docker封装服务，这些事情都需要通过手工方式一步一步的完成，能否让这些步骤自动的去执行呢？&lt;/p&gt;
&lt;p&gt;也就是说开发人员将源代码推送到Git远程仓库，自动进行Maven构建，并自动将构建生成的程序包放入Docker容器中。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 16:11:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<og:description>概述 本文章只是简单介绍了微服务开发的一些关键词，如果需要知道具体实现和可以评论留言 我会及时的增加连接写出具体实现(感觉没人看 就没写具体实现)。 持续更新中。。。。。。 SpringCloud和D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssskkk/p/9813986.html</dc:identifier>
</item>
<item>
<title>F#语言入门之什么是F#语言 - MSDNER</title>
<link>http://www.cnblogs.com/bruceday/p/9868061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bruceday/p/9868061.html</guid>
<description>&lt;p&gt;F＃是一种函数式编程语言，可以轻松编写正确且可维护的代码。&lt;/p&gt;
&lt;p&gt;F＃编程主要涉及定义类型推断和自动泛化的类型和函数。 这使您可以将焦点保留在问题域上并操纵其数据，而不是编程的细节。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;open&lt;/span&gt; System &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Gets access to functionality in System namespace.

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Defines a function that takes a name and produces a greeting.&lt;/span&gt;
&lt;span&gt;let&lt;/span&gt;&lt;span&gt; getGreeting name =
    sprintf &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, %s! Isn't F# great?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; name

[&amp;lt;EntryPoint&lt;/span&gt;&amp;gt;]
&lt;span&gt;let&lt;/span&gt;&lt;span&gt; main args =
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Defines a list of names&lt;/span&gt;
    &lt;span&gt;let&lt;/span&gt; names = [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Don&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Julia&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Xi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Prints a greeting for each name!&lt;/span&gt;
&lt;span&gt;    names
    &lt;/span&gt;|&lt;span&gt;&amp;gt; List.map getGreeting
    &lt;/span&gt;|&amp;gt; List.iter (&lt;span&gt;fun&lt;/span&gt; greeting -&amp;gt; printfn &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; greeting)

    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;F＃有许多功能，包括：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;轻量级语法&lt;/li&gt;
&lt;li&gt;默认不变&lt;/li&gt;
&lt;li&gt;类型推断和自动泛化&lt;/li&gt;
&lt;li&gt;一流的功能&lt;/li&gt;
&lt;li&gt;强大的数据类型&lt;/li&gt;
&lt;li&gt;模式匹配&lt;/li&gt;
&lt;li&gt;异步编程&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;丰富的数据类型&lt;/strong&gt;&lt;/h3&gt;
&lt;h5&gt;记录和识别联合等数据类型允许您表示复杂的数据和域。&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Group data with Records&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt; SuccessfulWithdrawal = {
    Amount: &lt;/span&gt;&lt;span&gt;decimal&lt;/span&gt;&lt;span&gt;
    Balance: &lt;/span&gt;&lt;span&gt;decimal&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; FailedWithdrawal = {
    Amount: &lt;/span&gt;&lt;span&gt;decimal&lt;/span&gt;&lt;span&gt;
    Balance: &lt;/span&gt;&lt;span&gt;decimal&lt;/span&gt;&lt;span&gt;
    IsOverdraft: &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use discriminated unions to represent data of 1 or more forms&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt; WithdrawalResult =
    &lt;/span&gt;| Success &lt;span&gt;of&lt;/span&gt;&lt;span&gt; SuccessfulWithdrawal
    &lt;/span&gt;| InsufficientFunds &lt;span&gt;of&lt;/span&gt;&lt;span&gt; FailedWithdrawal
    &lt;/span&gt;| CardExpired &lt;span&gt;of&lt;/span&gt;&lt;span&gt; System.DateTime
    &lt;/span&gt;| UndisclosedFailure
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;F＃记录和区分联合在默认情况下是非null，不可变和可比较的，使它们非常容易使用。完整教程阅读&lt;a title=&quot;F#语言入门之什么是F#语言&quot; href=&quot;http://www.wemedia.guru/Blog/Article/FSharp-What-Is-FSharp&quot; target=&quot;_blank&quot;&gt;http://nopapp.com/Blog/Article/FSharp-What-Is-FSharp&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 16:05:00 +0000</pubDate>
<dc:creator>MSDNER</dc:creator>
<og:description>F＃是一种函数式编程语言，可以轻松编写正确且可维护的代码。 F＃编程主要涉及定义类型推断和自动泛化的类型和函数。 这使您可以将焦点保留在问题域上并操纵其数据，而不是编程的细节。 F＃有许多功能，包括：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bruceday/p/9868061.html</dc:identifier>
</item>
<item>
<title>Spark Streaming核心概念与编程 - eat.u</title>
<link>http://www.cnblogs.com/uzies/p/9868013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uzies/p/9868013.html</guid>
<description>&lt;h2 id=&quot;核心概念&quot;&gt;1. 核心概念&lt;/h2&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;15.5&quot;&gt;StreamingContext
&lt;ul&gt;&lt;li&gt;Create StreamingContext&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;import org.apache.spark._
import org.apache.spark.streaming._

val conf = new SparkConf().setAppName(appName).setMaster(master)
//Second(1) #表示处理的批次, 当前1秒处理一次
val ssc = new StreamingContext(conf, Second(1))&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;StreamingContext的构造函数&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;//StreamingContext构造函数-最常用的两个
/**
 * Create a StreamingContext using an existing SparkContext.
 * @param sparkContext existing SparkContext
 * @param batchDuration the time interval at which streaming data will be divided into batches
 */
def this(sparkContext: SparkContext, batchDuration: Duration) = {
  this(sparkContext, null, batchDuration)
}

/**
 * Create a StreamingContext by providing the configuration necessary for a new SparkContext.
 * @param conf a org.apache.spark.SparkConf object specifying Spark parameters
 * @param batchDuration the time interval at which streaming data will be divided into batches
 */
def this(conf: SparkConf, batchDuration: Duration) = {
  this(StreamingContext.createNewSparkContext(conf), null, batchDuration)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;batch interval&lt;/strong&gt;可以根据你的应用程序需求的延迟要求以及集群可用的资源状况来设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490928/201810/1490928-20181028234755360-1695939628.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; Any operation applied on a DStream translates to operations on the underlying RDDs. For example, in the earlier example of converting a stream of lines to words, the flatMap operation is applied on each RDD in the lines DStream to generate the RDDs of the words DStream. This is shown in the following figure.
&amp;gt; 对DStream操作算子，比如map/flatMap，其实底层会被翻译为对DStream中的每个RDD做相同的操作。因为一个DStream是由不同批次的RDD构成的。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490928/201810/1490928-20181028234807214-1470555990.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;transformations&quot;&gt;2. Transformations&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Similar to that of RDDs, transformations allow the data from the input DStream to be modified. DStreams support many of the transformations available on normal Spark RDD’s. Some of the common ones are as follows.&lt;br/&gt;和RDD操作很相似，可以从input DStream 转换成一个新的。函数和RDD操作差不多！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;34.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;map(func)&lt;/td&gt;
&lt;td&gt;Return a new DStream by passing each element of the source DStream through a function func.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;flatMap(func)&lt;/td&gt;
&lt;td&gt;Similar to map, but each input item can be mapped to 0 or more output items.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;filter(func)&lt;/td&gt;
&lt;td&gt;Return a new DStream by selecting only the records of the source DStream on which func returns true.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;repartition(numPartitions)&lt;/td&gt;
&lt;td&gt;Changes the level of parallelism in this DStream by creating more or fewer partitions.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;union(otherStream)&lt;/td&gt;
&lt;td&gt;Return a new DStream that contains the union of the elements in the source DStream and otherDStream.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;count()&lt;/td&gt;
&lt;td&gt;Return a new DStream of single-element RDDs by counting the number of elements in each RDD of the source DStream.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;reduce(func)&lt;/td&gt;
&lt;td&gt;Return a new DStream of single-element RDDs by aggregating the elements in each RDD of the source DStream using a function func (which takes two arguments and returns one). The function should be associative and commutative so that it can be computed in parallel.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;countByValue()&lt;/td&gt;
&lt;td&gt;When called on a DStream of elements of type K, return a new DStream of (K, Long) pairs where the value of each key is its frequency in each RDD of the source DStream.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;13&quot;&gt;&lt;td&gt;reduceByKey(func, [numTasks])&lt;/td&gt;
&lt;td&gt;When called on a DStream of (K, V) pairs, return a new DStream of (K, V) pairs where the values for each key are aggregated using the given reduce function. Note: By default, this uses Spark's default number of parallel tasks (2 for local mode, and in cluster mode the number is determined by the config property spark.default.parallelism) to do the grouping. You can pass an optional numTasks argument to set a different number of tasks.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;11&quot;&gt;&lt;td&gt;join(otherStream, [numTasks])&lt;/td&gt;
&lt;td&gt;When called on two DStreams of (K, V) and (K, W) pairs, return a new DStream of (K, (V, W)) pairs with all pairs of elements for each key.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;11&quot;&gt;&lt;td&gt;cogroup(otherStream, [numTasks])&lt;/td&gt;
&lt;td&gt;When called on a DStream of (K, V) and (K, W) pairs, return a new DStream of (K, Seq[V], Seq[W]) tuples.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;transform(func)&lt;/td&gt;
&lt;td&gt;Return a new DStream by applying a RDD-to-RDD function to every RDD of the source DStream. This can be used to do arbitrary RDD operations on the DStream.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;updateStateByKey(func)&lt;/td&gt;
&lt;td&gt;Return a new &quot;state&quot; DStream where the state for each key is updated by applying the given function on the previous state of the key and the new values for the key. This can be used to maintain arbitrary state data for each key.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;output-operations&quot;&gt;3. Output Operations&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Output operations allow DStream’s data to be pushed out to external systems like a database or a file systems. Since the output operations actually allow the transformed data to be consumed by external systems, they trigger the actual execution of all the DStream transformations (similar to actions for RDDs). Currently, the following output operations are defined:&lt;br/&gt;Output operations可以把数据写到外部的数据源(database, file system)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;print()&lt;/td&gt;
&lt;td&gt;Prints the first ten elements of every batch of data in a DStream on the driver node running the streaming application. This is useful for development and debugging. Python API This is called pprint() in the Python API.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;saveAsTextFiles(prefix, [suffix])&lt;/td&gt;
&lt;td&gt;Save this DStream's contents as text files. The file name at each batch interval is generated based on prefix and suffix: &quot;prefix-TIME_IN_MS[.suffix]&quot;.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;saveAsObjectFiles(prefix, [suffix])&lt;/td&gt;
&lt;td&gt;Save this DStream's contents as SequenceFiles of serialized Java objects. The file name at each batch interval is generated based on prefix and suffix: &quot;prefix-TIME_IN_MS[.suffix]&quot;. Python API This is not available in the Python API.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;saveAsHadoopFiles(prefix, [suffix])&lt;/td&gt;
&lt;td&gt;Save this DStream's contents as Hadoop files. The file name at each batch interval is generated based on prefix and suffix: &quot;prefix-TIME_IN_MS[.suffix]&quot;. Python API This is not available in the Python API.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;foreachRDD(func)&lt;/td&gt;
&lt;td&gt;The most generic output operator that applies a function, func, to each RDD generated from the stream. This function should push the data in each RDD to an external system, such as saving the RDD to files, or writing it over the network to a database. Note that the function func is executed in the driver process running the streaming application, and will usually have RDD actions in it that will force the computation of the streaming RDDs.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;实战案例&quot;&gt;4. 实战案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基础 &lt;strong&gt;Maven pom.xml&lt;/strong&gt; 依赖配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
  &amp;lt;groupId&amp;gt;org.ko&amp;lt;/groupId&amp;gt;
  &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;artifactId&amp;gt;spark-streaming&amp;lt;/artifactId&amp;gt;
  &amp;lt;inceptionYear&amp;gt;2008&amp;lt;/inceptionYear&amp;gt;
  &amp;lt;properties&amp;gt;
      &amp;lt;scala.version&amp;gt;2.11.12&amp;lt;/scala.version&amp;gt;
      &amp;lt;kafka.version&amp;gt;2.0.0&amp;lt;/kafka.version&amp;gt;
      &amp;lt;spark.version&amp;gt;2.2.1&amp;lt;/spark.version&amp;gt;
      &amp;lt;hadoop.version&amp;gt;3.1.0&amp;lt;/hadoop.version&amp;gt;
      &amp;lt;hbase.version&amp;gt;2.1.0&amp;lt;/hbase.version&amp;gt;
      &amp;lt;jackson.version&amp;gt;2.9.2&amp;lt;/jackson.version&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
      &amp;lt;!--Hadoop 依赖--&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;hadoop-client&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${hadoop.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!--Spark Streaming 依赖--&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spark-streaming_2.11&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spark.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!--HBase Client 依赖--&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.apache.hbase&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;hbase-client&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${hbase.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!--Jackson json处理工具包--&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;com.fasterxml.jackson.module&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;jackson-module-scala_2.11&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!--HBase Server 依赖--&amp;gt;
      &amp;lt;!--&amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.apache.hbase&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;hbase-server&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${hbase.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;--&amp;gt;

      &amp;lt;!--Scala Library--&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.scala-lang&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;scala-library&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${scala.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!--Kafka 依赖--&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;kafka_2.11&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${kafka.version}&amp;lt;/version&amp;gt;
          &amp;lt;exclusions&amp;gt;
              &amp;lt;exclusion&amp;gt;
                  &amp;lt;groupId&amp;gt;org.xerial.snappy&amp;lt;/groupId&amp;gt;
                  &amp;lt;artifactId&amp;gt;snappy-java&amp;lt;/artifactId&amp;gt;
              &amp;lt;/exclusion&amp;gt;
              &amp;lt;exclusion&amp;gt;
                  &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
                  &amp;lt;artifactId&amp;gt;*&amp;lt;/artifactId&amp;gt;
              &amp;lt;/exclusion&amp;gt;
          &amp;lt;/exclusions&amp;gt;
      &amp;lt;/dependency&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.xerial.snappy&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;snappy-java&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.1.2.6&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;

  &amp;lt;!--cdh hadoop repository--&amp;gt;
  &amp;lt;!--&amp;lt;repositories&amp;gt;
      &amp;lt;repository&amp;gt;
          &amp;lt;id&amp;gt;cloudera&amp;lt;/id&amp;gt;
          &amp;lt;url&amp;gt;https://repository.cloudera.com/artifactory/cloudera-repos/&amp;lt;/url&amp;gt;
      &amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;--&amp;gt;

  &amp;lt;build&amp;gt;
      &amp;lt;sourceDirectory&amp;gt;src/main/scala&amp;lt;/sourceDirectory&amp;gt;
      &amp;lt;testSourceDirectory&amp;gt;src/test/scala&amp;lt;/testSourceDirectory&amp;gt;
      &amp;lt;plugins&amp;gt;
          &amp;lt;plugin&amp;gt;
              &amp;lt;groupId&amp;gt;org.scala-tools&amp;lt;/groupId&amp;gt;
              &amp;lt;artifactId&amp;gt;maven-scala-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;version&amp;gt;2.15.1&amp;lt;/version&amp;gt;
              &amp;lt;executions&amp;gt;
                  &amp;lt;execution&amp;gt;
                      &amp;lt;goals&amp;gt;
                          &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt;
                          &amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt;
                      &amp;lt;/goals&amp;gt;
                  &amp;lt;/execution&amp;gt;
              &amp;lt;/executions&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;scalaVersion&amp;gt;${scala.version}&amp;lt;/scalaVersion&amp;gt;
                  &amp;lt;args&amp;gt;
                      &amp;lt;arg&amp;gt;-target:jvm-1.5&amp;lt;/arg&amp;gt;
                  &amp;lt;/args&amp;gt;
              &amp;lt;/configuration&amp;gt;
          &amp;lt;/plugin&amp;gt;
          &amp;lt;plugin&amp;gt;
              &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
              &amp;lt;artifactId&amp;gt;maven-eclipse-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;downloadSources&amp;gt;true&amp;lt;/downloadSources&amp;gt;
                  &amp;lt;buildcommands&amp;gt;
                      &amp;lt;buildcommand&amp;gt;ch.epfl.lamp.sdt.core.scalabuilder&amp;lt;/buildcommand&amp;gt;
                  &amp;lt;/buildcommands&amp;gt;
                  &amp;lt;additionalProjectnatures&amp;gt;
                      &amp;lt;projectnature&amp;gt;ch.epfl.lamp.sdt.core.scalanature&amp;lt;/projectnature&amp;gt;
                  &amp;lt;/additionalProjectnatures&amp;gt;
                  &amp;lt;classpathContainers&amp;gt;
                      &amp;lt;classpathContainer&amp;gt;org.eclipse.jdt.launching.JRE_CONTAINER&amp;lt;/classpathContainer&amp;gt;
                      &amp;lt;classpathContainer&amp;gt;ch.epfl.lamp.sdt.launching.SCALA_CONTAINER&amp;lt;/classpathContainer&amp;gt;
                  &amp;lt;/classpathContainers&amp;gt;
              &amp;lt;/configuration&amp;gt;
          &amp;lt;/plugin&amp;gt;
          &amp;lt;plugin&amp;gt;
              &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
              &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;source&amp;gt;8&amp;lt;/source&amp;gt;
                  &amp;lt;target&amp;gt;8&amp;lt;/target&amp;gt;
              &amp;lt;/configuration&amp;gt;
          &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
  &amp;lt;reporting&amp;gt;
      &amp;lt;plugins&amp;gt;
          &amp;lt;plugin&amp;gt;
              &amp;lt;groupId&amp;gt;org.scala-tools&amp;lt;/groupId&amp;gt;
              &amp;lt;artifactId&amp;gt;maven-scala-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;scalaVersion&amp;gt;${scala.version}&amp;lt;/scalaVersion&amp;gt;
              &amp;lt;/configuration&amp;gt;
          &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
  &amp;lt;/reporting&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;Spark Streaming处理socket数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.代码实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;/**
  * Spark Streaming 处理socket数据
  *
  * 测试： nc -lk 6789
  */
object NetworkWordCount {

  def main(args: Array[String]): Unit = {
    //1. 创建spark conf配置
    val sparkConf = new SparkConf()
      .setMaster(&quot;local[2]&quot;)
      .setAppName(&quot;NetworkWordCount&quot;)

    //2. 创建StreamingContext需要两个参数: SparkConf 和 batch interval
    val ssc = new StreamingContext(sparkConf, Seconds(5))
    val lines = ssc.socketTextStream(&quot;192.168.37.128&quot;, 6789)

    val result = lines.flatMap(_.split(&quot; &quot;)).map((_, 1)).reduceByKey(_+_)

    result.print()

    ssc.start()
    ssc.awaitTermination()
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.为什么local[?], 一定要设置为2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490928/201810/1490928-20181028234832150-374047085.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Receiver&lt;/strong&gt; 和 &lt;strong&gt;Spark Core&lt;/strong&gt; 处理都需要系统资源，所有2个是最低的数量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;Spark Streaming 处理 &lt;strong&gt;HDFS&lt;/strong&gt; 文件数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;/**
  * &amp;lt;p&amp;gt;
  *   使用Spark Streaming 处理文件系统(local/HDFS)的数据
  * &amp;lt;/p&amp;gt;
  */
object FileWordCount {

  def main(args: Array[String]): Unit = {
    val sparkConf = new SparkConf()
      .setMaster(&quot;local&quot;)
      .setAppName(&quot;FileWordCount&quot;)

    val ssc = new StreamingContext(sparkConf, Seconds(5))

    val lines = ssc.textFileStream(&quot;D:\\tmp&quot;)

    val result = lines.flatMap(_.split(&quot; &quot;)).map((_, 1)).reduceByKey(_+_)

    result.print()

    ssc.start()
    ssc.awaitTermination()
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Spark Streaming会持续监控数据文件夹变化，现在不支持递归嵌套文件夹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;注意事项
&lt;ul&gt;&lt;li&gt;The files must have the same data format.(文件格式必须一样)&lt;/li&gt;
&lt;li&gt;The files must be create in the dataDirectory by atomically moving or renaming them into the data directory.(这个文件必须创建在数据文件夹，并且是原子性的移动或者改变名字到监控文件夹)&lt;/li&gt;
&lt;li&gt;Once moved, the files must not be changed. So if the files are being continuously appended, the new data will not be read.(一但移动就不可以再改变，是持久的被添加进去，新写入数据不会被处理。)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 28 Oct 2018 15:49:00 +0000</pubDate>
<dc:creator>eat.u</dc:creator>
<og:description>Spark Streaming核心概念与编程 1. 核心概念 StreamingContext Create StreamingContext StreamingContext的构造函数 batch</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uzies/p/9868013.html</dc:identifier>
</item>
<item>
<title>全新定义！免费开源ERP平台如何玩转工业互联网 - 企业IT专家老杨</title>
<link>http://www.cnblogs.com/yangxunbo/p/9868006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangxunbo/p/9868006.html</guid>
<description>
&lt;p&gt;IoT Box通过Wifi、蓝牙、USB、网线等方式连接设备。IoT再通过互联网连接到Odoo服务器&lt;/p&gt;
&lt;p&gt;Odoo的各种应用通过IoT操作各种设备。例如，PoS应用通过IoT操作小票打印机、银行刷卡机。又如，车间生产的工序应用Work Order，操作工序上的摄像头、测量仪器等，完成拍照、测量等工作，并获取工作结果（照片、测量结果）到Odoo系统中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181028/fec5437ff388429583542146e8058989.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181028/345bf69fea814d36b38f8ba6d2fd24dc.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181028/2dde37a5c9a94025bf694079942d5919.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工序上选择关联的设备：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181028/186b51a7408b4d298a4f41dbd67dec73.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Take Picture控制摄像头拍照：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181028/de9e4ca75fe743cca745254dd6470b59.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章编辑：开源智造(OSCG) - 源自欧洲，业界领先的免费开源ERP专业服务商&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 15:47:00 +0000</pubDate>
<dc:creator>企业IT专家老杨</dc:creator>
<og:description>简述 IoT Box通过Wifi、蓝牙、USB、网线等方式连接设备。IoT再通过互联网连接到Odoo服务器 Odoo的各种应用通过IoT操作各种设备。例如，PoS应用通过IoT操作小票打印机、银行刷卡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangxunbo/p/9868006.html</dc:identifier>
</item>
<item>
<title>[原创]分布式系统之缓存的微观应用经验谈（四） 【交互场景篇】 - AutumnBing</title>
<link>http://www.cnblogs.com/bsfz/p/9867952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bsfz/p/9867952.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式系统之缓存的微观应用经验谈（四） 【交互场景篇】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　近几个月一直在忙些琐事，几乎年后都没怎么闲过。忙忙碌碌中就进入了2018年的秋天了，不得不感叹时间总是如白驹过隙，也不知道收获了什么和失去了什么。最近稍微休息，买了两本与技术无关的书，其一是 Yann Martel 写的《The High Mountains of Portugal》（葡萄牙的高山），发现阅读此书是需要一些耐心的，对人生暗喻很深，也有足够的留白，有兴趣的朋友可以细品下。好了，下面回归正题，尝试写写工作中缓存技术相关的一些实战经验和思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　在分布式Web程序设计中，解决高并发以及内部解耦的关键技术离不开缓存和队列，而缓存角色类似计算机硬件中CPU的各级缓存。如今的业务规模稍大的互联网项目，即使在最初beta版的开发上，都会进行预留设计。但是在诸多应用场景里，也带来了某些高成本的技术问题，需要细致权衡。本系列主要围绕分布式系统中服务端缓存相关技术，也会结合朋友间的探讨提及自己的思考细节。文中若有不妥之处，恳请指正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　为了方便独立成文，原谅在内容排版上的一点点个人强迫症。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　第四篇打算作为系列最后一篇，这里尝试谈谈缓存的一些并发交互场景，包括与数据库（特指 RDBMS）交互，和一些独立的高并发场景相关补充处理方案（若涉及具体应用同样将主要以Redis举例）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　另见：分布式系统之缓存的微观应用经验谈（三）（数据分片和集群篇）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（&lt;a href=&quot;https://www.cnblogs.com/bsfz/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/&lt;/a&gt;）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　（&lt;a href=&quot;https://yq.aliyun.com/u/autumnbing&quot; target=&quot;_blank&quot;&gt;https://yq.aliyun.com/u/autumnbing&lt;/a&gt;）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;strong&gt;一、简单谈下缓存和数据库的交互流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　为了便于后面的相关讨论，这里约定文中的数据库（Database）均指传统的 RDBMS，使用DB标识，同时需区别于缓存（Cache）里的DB划分空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　我在早前一篇缓存设计细节的文章里，有阐述关于 Cache 自身 CURD 时的一些具体细节，而这里将结合DB，就 DB 和 Cache 之间的并行 CURD 操作进行一些讨论。当然，这里面在交互层面上是一定会涉及到分布式事务（Distributed Transaction）相关的一致性话题，但为了避免表述出现模糊和不必要的边界放大，这里我尽可能剥离开来，专注在基于 Cache 的处理上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　预先抽象这样一个基础场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　DB中存在一张资金关联表（FT），这里 FT 里存储的都是热点条目（属于极高频访问数据），在系统设计时，FT里的数据将与对应的 Cache 服务 C1 进行关联存储（这里仅指一级缓存），以达到提升一定的并发查询性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　1.1 向 FT 中新增（Create）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　通过 SQL 向 FT中插入一条数据：如果插入失败，则不需要对 C1有任何操作；如果插入成功，则此时需要判断，考虑是否在 C1中同步插入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这种情景一般比较简单，如果没有特别的情况，此刻不需对 C1 做主动插入，而是后续被动插入（后面会提到）。但是如果插入 FT 中的数据往后操作只有删除这个动作，并且 FT的数据经常被批量操作，那么个人建议同步执行对 C1的插入操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　（PS：这里也顺便申明下，如果需要往C1插入，但插入失败，请根据业务场景加入重试机制，后面对Cache的操作均包含这个潜在的动作。至于重试处理失败的情况，如往C1插入一条数据，个人建议是不再过度处理，最终默认是整体操作成功，并进行对应状态返回。这里注意不要与分布式事务的一致性进行混合类比，后面不再赘述。）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　　&lt;strong&gt;1.2 准备更新（Update）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　当需要更新 FT 中的一条数据时，意味着之前 C1 中的数据已经无效，而在一个高并发环境中这里无法做到统一的直接更新 C1。首先就需要考虑的是 C1 的数据是主动更新还是被动更新，主动更新即更新完 FT后，同时将数据覆盖进 C1，而被动更新指的是更新完 FT 后，立即淘汰 C1 中的数据，并等待下次查询时重新写入C1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　只要上述请求动作出现了任何并发，比如两个相同动作，动作1和动作2同时发生请求，那么会出现一个不一致的问题：动作1先操作 FT，动作2后操作 FT，然后动作2先操作了C1，动作1后操作了C1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这样存在不止一个线程并发的更新 FT 数据时，无法确认更新 FT 的顺序和最终更新 C1 的顺序是否保持一致，结果是一定会出现大量 FT 和 C1 中数据出现幻读，而这个在存在主从Cache的情况下这种概率会大大提升（可参见上一章主从复制的部分）。推荐的方式是，如果不考虑Cache 多次需要重写的损耗，在没有其他特殊要求下，可以直接淘汰 C1 中的数据，也额外照顾到了Cache在合适的时候完全命中（Hit）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　其实到这里还没结束，当决定是淘汰 C1 的数据，那么就要选择一个淘汰时机：一种是先更新 FT，然后对C1 执行淘汰；一种则是，先对 C1 执行淘汰，然后才更新FT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　虽然两种方式都有合适的场景，但这里需要权衡一种概率性问题：当对C1执行淘汰时，又并发了一个对C1的查询操作，此时，C1会从DB拉取数据重新写入，那么C1中即为脏数据，当并发越大，存在数据一直“脏”下去的概率更大。所以，这里更推荐的做法是选择前者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　（注意，这里还有一些去讨论的细节并不打算在此话题延伸，比如关于 C1和FT之间的原子性问题，是否可以采用二阶段/三阶段提交等模拟事务方式和对业务造成的影响。）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　1.3 开始读取（Read）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这里就没有太多特别，毕竟应用Cache 的目的就已经说明了读取数据时，只需要遵循“先读Cache再读DB”。即先从C1里拿取数据，如果C1里不存在该数据，则从FT中搜索，搜索完成如果依然不存在该数据，则直接返回Empty状态。如果存在，则同时将该数据保存进C1中，并返回对应状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　顺带提一下，可能有人会说，在某些场景下，即使 C1中有数据，也要先从 FT里优先获取。我赞同，没错，但注意这里不要混淆讨论的主题了，这本质是属于基于一种业务结果的导向，就类似在传统 RDBMS 读写分离情况下，在关键数据的验证处，直接请求主库获取并操作。所以上面说的其实并没有矛盾，我们讨论时要明确清晰，不要混淆。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　1.4 从FT 中删除（Delete）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　与Create相反的操作，通过 SQL 向 FT中移除一条数据：如果移除失败，则不需要对 C1 有任何操作，如删除成功，则将对应C1中数据移除（另外请类比1.2中的一些细节）。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　&lt;strong&gt;　二、谈谈缓存的穿透雪崩等相关问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　　在项目发展到后期，一些业务场景整体都处于高并发状态，大量QPS对整体业务的负载要求很高，为了避免很多时候脱离架构优化的初衷，还需要在项目中做到很多预先性的规避和细节把控。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　2.1 优化防止缓存击穿&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　当请求发来的查询 Key 在 Cache 中存在，但某一时刻数据过期了，并且此时出现了大量并发请求，那么这里因为 Cache 中 Miss，就会统一去 DB 中搜索，直接造成在很短的时间内，DB 的 QPS 压力会陡增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　对于这种问题的预防和优化，往往从两方面入手：一是程序中加小粒度的锁/信号（去年有写过一篇关于商城系统里库存并发管控杂记，里面有具体话题的细节扩展，详见：&lt;a href=&quot;https://www.cnblogs.com/bsfz/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/&lt;/a&gt; ）；二是将 DB的读取延迟 和 Cache的写入时间尽可能拉到最低；三是对其中过于热点的数据采取一个较大的过期时间并做一定的随机性（这里非必要，可自行权衡）。其实还有一点，少数情况下，可根据场景是否限制，可以增加适当的到期自动刷新的策略，这里也可以考虑在程序中开启固定的线程通知维护。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　2.2 预防大量缓存穿透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　当请求发来的查询 Key 在 Cache 中 Miss，自然就会去 DB 里搜索，这里本身没问题，但是假如查询的 Key 在 DB 中也不存在，那么意味着每次请求实际上都是实打实落在了 DB 上。这种问题比较常见，并且即使并发不是很大的时候 DB 的连接数也轻松达到上限，而且本身也不符合我们设计为了提高QPS的初衷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　对于这种漏洞性问题的解决方式，同样可以从两方面入手：一是程序可以在第一次从DB搜索数据为 NULL 的时候，直接将 NULL 或者一个标识符 Sign 缓存起来，同时个人建议尽量设置一个小范围的随机过期时间，避免不必要的长期内存占用；二是程序里限制过滤一些不可能存在的数据KEY，如借鉴 Bloom filter 思想，特别是在前端请求到后端的这里，尽量进行一次中间判断处理（如有时对不合法KEY直接返回NULL）。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　　　2.3 控制缓存雪崩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这里会有某些细节和上面类似，但不完全。当Cache出现不可用，再或者大量数据同一场景里同一时刻失效，批量请求直接访问DB，并且此刻也等同于没有任何Cache措施了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　为了规避这种偏极端的问题，主要可以考虑从三个方面入手：一是增加完善Cache 的高可用机制，并最好有单独的运维监控预警；二是类似上面针对Cache的时间再次作随机，特别是包含预热和批量的场景里。（ps：你看很多地方都有类似设计来降低一定概率，个人在设计时，即使是项目初期阶段的简化版本里也会包含进去。）；三是，在部分场景增加多级Cache，但是在很多时候会增加其他的问题（如多级之前的同步问题），所以个人推荐优先增加到二级即可，然后稍微调整下时间尽量不高于一级Cache。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　由于个人能力和经验均有限，自己也在持续学习和实践，文中若有不妥之处，恳请指正。 本系列告一段落，正好也要去忙一些事情，暂时可能不写相关的东西了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　个人目前备用地址：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　社区1：&lt;a href=&quot;https://yq.aliyun.com/u/autumnbing&quot; target=&quot;_blank&quot;&gt;https://yq.aliyun.com/u/autumnbing&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　社区2：&lt;a href=&quot;https://www.cnblogs.com/bsfz/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;End.  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 15:32:00 +0000</pubDate>
<dc:creator>AutumnBing</dc:creator>
<og:description>第四篇打算作为系列最后一篇，这里尝试谈谈缓存的一些并发交互场景，包括与数据库（特指 RDBMS）交互，和一些独立的高并发场景相关补充处理方案（若涉及具体应用同样将主要以Redis举例）。 另见：分布式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bsfz/p/9867952.html</dc:identifier>
</item>
<item>
<title>python爬虫实战：利用scrapy，短短50行代码下载整站短视频 - 马鸣谦</title>
<link>http://www.cnblogs.com/mamingqian/p/9867697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mamingqian/p/9867697.html</guid>
<description>&lt;p&gt;近日，有朋友向我求助一件小事儿，他在一个短视频app上看到一个好玩儿的段子，想下载下来，可死活找不到下载的方法。这忙我得帮，少不得就抓包分析了一下这个app，找到了视频的下载链接，帮他解决了这个小问题。&lt;/p&gt;
&lt;p&gt;因为这个事儿，勾起了我另一个念头，这不最近一直想把python爬虫方面的知识梳理梳理吗，干脆借机行事，正凑着短视频火热的势头，做一个短视频的爬虫好了，中间用到什么知识就理一理。&lt;/p&gt;
&lt;p&gt;我喜欢把事情说得很直白，如果恰好有初入门的朋友想了解爬虫的技术，可以将就看看，或许对你的认识会有提升。如果有高手路过，最好能指点一二，本人不胜感激。&lt;/p&gt;

&lt;h2&gt;爬虫是什么&lt;/h2&gt;
&lt;p&gt;爬虫就是一段能够从互联网上高效获取数据的程序。&lt;/p&gt;
&lt;p&gt;我们每天都在从互联网上获取数据。当打开浏览器访问百度的时候，我们就从百度的服务器获取数据，当拿起手机在线听歌的时候，我们就从某个app的服务器上获取数据。简单的归纳，这些过程都可以描述为：我们提交一个Request请求，服务器会返回一个Response数据，应用根据Response来渲染页面，给我们展示数据结果。&lt;/p&gt;
&lt;p&gt;爬虫最核心的也是这个过程，提交Requests——〉接受Response。就这样，很简单，当我们在浏览器里打开一个页面，看到页面内容的时候，我们就可以说这个页面被我们采集到了。&lt;/p&gt;
&lt;p&gt;只不过当我们真正进行数据爬取时，一般会需要采集大量的页面，这就需要提交许多的Requests，需要接受许多的Response。数量大了之后，就会涉及到一些比较复杂的处理，比如并发的，比如请求序列，比如去重，比如链接跟踪，比如数据存储，等等。于是，随着问题的延伸和扩展，爬虫就成为了一个相对独立的技术门类。&lt;/p&gt;
&lt;p&gt;但它的本质就是对一系列网络请求和网络响应的处理。&lt;/p&gt;
&lt;h2&gt;爬虫能做什么&lt;/h2&gt;
&lt;p&gt;爬虫的作用和目的只有一个，获取网络数据。我们知道，互联网是个数据的海洋，大量的信息漂浮在其中，想把这些资源收归己用，爬虫是最常用的方式。特别是最近几年大树据挖掘技术和机器学习以及知识图谱等技术的兴盛，更是对数据提出了更大的需求。另外也有很多互联网创业公司，在起步初期自身积累数据较少的时候，也会通过爬虫快速获取数据起步。&lt;/p&gt;

&lt;p&gt;如果你刚刚接触爬虫的概念，我建议你暂时不要使用scrapy框架。或者更宽泛的说，如果你刚刚接触某一个技术门类，我都不建议你直接使用框架，因为框架是对许多基础技术细节的高级抽象，如果你不了解底层实现原理就直接用框架多半会让你云里雾里迷迷糊糊。&lt;/p&gt;
&lt;p&gt;在入门爬虫之初，看scrapy的文档，你会觉得“太复杂了”。当你使用urllib或者Requests开发一个python的爬虫脚本，并逐个去解决了请求头封装、访问并发、队列去重、数据清洗等等问题之后，再回过头来学习scrapy，你会觉得它如此简洁优美，它能节省你大量的时间，它会为一些常见的问题提供成熟的解决方案。&lt;/p&gt;
&lt;h2&gt;scrapy数据流程图&lt;/h2&gt;
&lt;p&gt;这张图是对scrapy框架的经典描述，一时看不懂没有关系，用一段时间再回来看。或者把本文读完再回来看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028212232936-163927190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在一些书上会把爬虫的基本抓取流程概括为UR&lt;sup&gt;2&lt;/sup&gt;IM，意思是数据爬取的过程是围绕URL、Request（请求）、Response（响应）、Item（数据项）、MoreUrl（更多的Url）展开的。上图的&lt;span&gt;绿色箭头&lt;/span&gt; &lt;span&gt;体现的正是这几个要素的流转过程。图中涉及的四个模块正是用于处理这几类对象的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Spider模块：负责生成Request对象、解析Response对象、输出Item对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Scheduler模块：负责对Request对象的调度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Downloader模块：负责发送Request请求，接收Response响应&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ItemPipleline模块：负责数据的处理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;scrapy Engine负责模块间的通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;各个模块和scrapy引擎之间可以添加一层或多层中间件，负责对出入该模块的UR&lt;sup&gt;2&lt;/sup&gt;IM对象进行处理。&lt;/p&gt;
&lt;h2&gt;scrapy的安装&lt;/h2&gt;
&lt;p&gt;参考官方文档，不再赘述。官方文档：https://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/install.html&lt;/p&gt;

&lt;p&gt;python的优雅之处在于能够让开发者专注于业务逻辑，花更少的时间在枯燥的代码编写调试上。scrapy无疑完美诠释了这一精神。&lt;/p&gt;
&lt;p&gt;开发爬虫的一般步骤是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定要爬取的数据（item）&lt;/li&gt;
&lt;li&gt;找到数据所在页面的url&lt;/li&gt;
&lt;li&gt;找到页面间的链接关系，确定如何跟踪（follow）页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，我们一步一步来。&lt;/p&gt;
&lt;p&gt;既然是使用scrapy框架，我们先创建项目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
scrapy startproject DFVideo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 紧接着，我们创建一个爬虫：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
scrapy genspider -t crawl DfVideoSpider eastday.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是我们发现在当前目录下已经自动生成了一个目录：DFVideo&lt;/p&gt;
&lt;p&gt;目录下包括如图文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028220359686-2058101611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;








&lt;p&gt;spiders文件夹下，自动生成了名为DfVideoSpider.py的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028220555579-1038540780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;爬虫项目创建之后，我们来确定需要爬取的数据。在items.py中编辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import scrapy


class DfvideoItem(scrapy.Item):
    # define the fields for your item here like:
    # name = scrapy.Field()
    video_url = scrapy.Field()#视频源url
    video_title = scrapy.Field()#视频标题
    video_local_path = scrapy.Field()#视频本地存储路径
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，我们需要确定视频源的url，这是很关键的一步。&lt;/p&gt;
&lt;p&gt;现在许多的视频播放页面是把视频链接隐藏起来的，这就使得大家无法通过右键另存为，防止了视频别随意下载。&lt;/p&gt;
&lt;p&gt;但是只要视频在页面上播放了，那么必然是要和视频源产生数据交互的，所以只要稍微抓下包就能够发现玄机。&lt;/p&gt;
&lt;p&gt;这里我们使用fiddler抓包分析。&lt;/p&gt;
&lt;p&gt;发现其视频播放页的链接类似于：video.eastday.com/a/180926221513827264568.html?index3lbt&lt;/p&gt;
&lt;p&gt;视频源的数据链接类似于：mvpc.eastday.com/vyule/20180415/20180415213714776507147_1_06400360.mp4&lt;/p&gt;
&lt;p&gt;有了这两个链接，工作就完成了大半：&lt;/p&gt;
&lt;p&gt;在DfVideoSpider.py中编辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# -*- coding: utf-8 -*-
import scrapy
from scrapy.loader import ItemLoader
from scrapy.loader.processors import MapCompose,Join
from DFVideo.items import DfvideoItem
from scrapy.linkextractors import LinkExtractor
from scrapy.spiders import CrawlSpider, Rule
import time
from os import path
import os


class DfvideospiderSpider(CrawlSpider):
    name = 'DfVideoSpider'
    allowed_domains = ['eastday.com']
    start_urls = ['http://video.eastday.com/']

    rules = (
        Rule(LinkExtractor(allow=r'video.eastday.com/a/\d+.html'),
             callback='parse_item', follow=True),
    )

    def parse_item(self, response):
        item = DfvideoItem()
        try:
            item[&quot;video_url&quot;] = response.xpath('//input[@id=&quot;mp4Source&quot;]/@value').extract()[0]
            item[&quot;video_title&quot;] = response.xpath('//meta[@name=&quot;description&quot;]/@content').extract()[0]
            #print(item)
            item[&quot;video_url&quot;] = 'http:' + item['video_url']
            yield scrapy.Request(url=item['video_url'], meta=item, callback=self.parse_video)
        except:
            pass


    def parse_video(self, response):

        i = response.meta
        file_name = Join()([i['video_title'], '.mp4'])
        base_dir = path.join(path.curdir, 'VideoDownload')
        video_local_path = path.join(base_dir, file_name.replace('?', ''))
        i['video_local_path'] = video_local_path

        if not os.path.exists(base_dir):
            os.mkdir(base_dir)

        with open(video_local_path, &quot;wb&quot;) as f:
            f.write(response.body)

        yield i
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 至此，一个简单但强大的爬虫便完成了。&lt;/p&gt;
&lt;p&gt;如果你希望将视频的附加数据保存在数据库，可以在pipeline.py中进行相应的操作，比如存入mongodb中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from scrapy import log
import pymongo

class DfvideoPipeline(object):
    def __init__(self):

        self.mongodb = pymongo.MongoClient(host='127.0.0.1', port=27017)
        self.db = self.mongodb[&quot;DongFang&quot;]

        self.feed_set = self.db[&quot;video&quot;]
        # self.comment_set=self.db[comment_set]

        self.feed_set.create_index(&quot;video_title&quot;, unique=1)
        # self.comment_set.create_index(comment_index,unique=1)

    def process_item(self, item, spider):
        try:
            self.feed_set.update({&quot;video_title&quot;: item[&quot;video_title&quot;]}, item, upsert=True)
        except:
            log.msg(message=&quot;dup key: {}&quot;.format(item[&quot;video_title&quot;]), level=log.INFO)
        return item

    def on_close(self):
        self.mongodb.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当然，你需要在setting.py中将pipelines打开：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
ITEM_PIPELINES = {
    'TouTiaoVideo.pipelines.ToutiaovideoPipeline': 300,
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;视频文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028222328833-489006776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;今天讲了爬虫的一些基础的概念，不深也不透，主要是通过一个案例给大家一个直观的认识。一些细节上的点后续会专门开文细讲，喜欢的朋友可以关注，一起探讨。&lt;/p&gt;
&lt;p&gt;本文所公布代码仅作为学习交流之用，请勿用于非法用途，负责后果自负。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Oct 2018 14:31:00 +0000</pubDate>
<dc:creator>马鸣谦</dc:creator>
<og:description>近日，有朋友向我求助一件小事儿，他在一个短视频app上看到一个好玩儿的段子，想下载下来，可死活找不到下载的方法。这忙我得帮，少不得就抓包分析了一下这个app，找到了视频的下载链接，帮他解决了这个小问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mamingqian/p/9867697.html</dc:identifier>
</item>
<item>
<title>webpack4.x最详细入门讲解 - Better-Man</title>
<link>http://www.cnblogs.com/BetterMan-/p/9867642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BetterMan-/p/9867642.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;Webpack其实没有想象中的那么难，用得多了，其实套路都一样，本文主要是针对webpack4.x版本，会对平时常用的Webpack配置一一讲解，所以本文也比较长，但如果你能动手跟着本文中的例子完整写一次，相信你会觉得Webpack也不过如此。&lt;/p&gt;
&lt;h4 id=&quot;一什么是webpack为什么使用它&quot;&gt;一、什么是webpack，为什么使用它？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215850562-752614317.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;什么是webpack&quot;&gt;1.1 什么是webpack？&lt;/h6&gt;
&lt;p&gt;简单来说，它其实就是一个&lt;strong&gt;模块打包器&lt;/strong&gt;。&lt;/p&gt;
&lt;h6 id=&quot;为什么使用它&quot;&gt;1.2 为什么使用它？&lt;/h6&gt;
&lt;p&gt;如果像以前开发时一个html文件可能会引用十几个js文件,而且顺序还不能乱，因为它们存在依赖关系，同时对于ES6+等新的语法，less, sass等CSS预处理都不能很好的解决……，此时就需要一个处理这些问题的工具。&lt;/p&gt;
&lt;p&gt;Webpack就是为处理这些问题而生的，它就是把你的项目当成一个整体，通过一个入口主文件（如：index.js）,从这个文件开始找到你的项目所有的依赖文件并处理它们，最后打包成一个（或多个）浏览器可识别的JavaScript文件。&lt;/p&gt;
&lt;h4 id=&quot;二一个简单的打包例子&quot;&gt;二、一个简单的打包例子&lt;/h4&gt;
&lt;h6 id=&quot;准备工作&quot;&gt;2.1 准备工作&lt;/h6&gt;
&lt;p&gt;首先新建一个空文件夹，用于创建项目，在终端中进入文件夹，如下我在桌面建了一个名为webpack-project的文件夹，使用终端进入文件夹后（如果对命令行不太熟悉，可参考我的博客：&lt;a href=&quot;https://www.cnblogs.com/BetterMan-/p/9699325.html&quot;&gt;前端常用命令行&lt;/a&gt;），使用&lt;code&gt;npm init&lt;/code&gt;命令创建一个package.json文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm init&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215924815-1440033072.png&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过如果你不打算发布这个模块，直接一路回车就好。（也可以使用&lt;code&gt;npm init -y&lt;/code&gt;这个命令来一次生成package.json文件，这样终端不会询问你问题）。&lt;/p&gt;
&lt;h6 id=&quot;安装webpack&quot;&gt;2.2 安装webpack&lt;/h6&gt;
&lt;p&gt;如果你想一步到位的话，就把全局webpack和本地项目webpack全都先装了，因为后面一些模块会用到。安装本地项目webapck时把webpack-cli也装上，因为webpack模块把一些功能分到了webpack-cli模块，安装方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install webpack --global                //这是安装全局webpack命令
npm install webpack webpack-cli --save-dev  //这是安装本地项目模块&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;tips&quot;&gt;tips:&lt;/h6&gt;
&lt;blockquote readability=&quot;9.7352941176471&quot;&gt;
&lt;p&gt;上述命令可采用简写，&lt;code&gt;install&lt;/code&gt;可简写为&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;--global&lt;/code&gt;可简写为&lt;code&gt;-g&lt;/code&gt;,&lt;code&gt;--save-dev&lt;/code&gt;可简写为&lt;code&gt;-D&lt;/code&gt;(这个命令是用于把配置添加到package.json的开发环境配置列表中，后面会提到)，&lt;code&gt;--save&lt;/code&gt;可简写为&lt;code&gt;-S&lt;/code&gt;，同时国内我们可以采用cnpm，配置方法可&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;去这里&lt;/a&gt;查看，这样安装速度会相对较快。如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i webpack -g               //这是安装全局webpack命令
cnpm i webpack webpack-cli -D   //这是安装本地项目模块&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;新建文件&quot;&gt;2.3 新建文件&lt;/h6&gt;
&lt;p&gt;在&lt;code&gt;webpack-project&lt;/code&gt;文件夹中新建两个文件夹，分别为src文件夹和dist文件夹，接下来再创建三个文件:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;index.html&lt;/code&gt; --放在dist文件夹中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hello.js&lt;/code&gt; --放在src文件夹中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index.js&lt;/code&gt; --放在src文件夹中；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时，项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215939056-440061193.png&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在&lt;code&gt;index.html&lt;/code&gt;中写下&lt;code&gt;html&lt;/code&gt;代码，它的作用是为了引入我们打包后的js文件：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Webpack Project&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id='root'&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;   &amp;lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;hello.js&lt;/code&gt;中导出一个模块：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// hello.js
module.exports = function() {
    let hello = document.createElement('div');
    hello.innerHTML = &quot;Long time no see!&quot;;
    return hello;
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;index.js&lt;/code&gt;中引入这个模块（&lt;code&gt;hello.js&lt;/code&gt;）:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
const hello = require('./hello.js');
document.querySelector(&quot;#root&quot;).appendChild(hello());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述操作就相当于我们把&lt;code&gt;hello.js&lt;/code&gt;模块合并到了&lt;code&gt;index.js&lt;/code&gt;模块，之后我们打包时就只需把&lt;code&gt;index.js&lt;/code&gt;模块打包成&lt;code&gt;bundle.js&lt;/code&gt;，然后供&lt;code&gt;index.html&lt;/code&gt;引用即可，这就是最简单的webpack打包原理。&lt;/p&gt;
&lt;h6 id=&quot;开始进行webpack打包&quot;&gt;2.4 开始进行webpack打包&lt;/h6&gt;
&lt;p&gt;在终端中使用如下命令进行打包：&lt;br/&gt;&lt;code&gt;// webpack全局安装的情况下 webpack src/index.js --output dist/bundle.js // --output可简写为-o&lt;/code&gt;&lt;br/&gt;上述就相当于把&lt;code&gt;src&lt;/code&gt;文件夹下的&lt;code&gt;index.js&lt;/code&gt;文件打包到&lt;code&gt;dist&lt;/code&gt;文件下的&lt;code&gt;bundle.js&lt;/code&gt;，这时就生成了&lt;code&gt;bundle.js&lt;/code&gt;供&lt;code&gt;index.html&lt;/code&gt;文件引用。&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215953601-1648062544.png&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出webpack同时编译了&lt;code&gt;index.js&lt;/code&gt;和&lt;code&gt;hello.js&lt;/code&gt;,现在打开&lt;code&gt;index.html&lt;/code&gt;,可以看到如下结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220007236-1204768022.png&quot; alt=&quot;5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错，我们已经成功使用webpack进行打包，原来webpack也不过如此嘛！但是，每次都在终端中输入这么长的命令，感觉好烦啊，还好有懒人方法，让我们看看。&lt;/p&gt;
&lt;h6 id=&quot;通过配置文件来使用webpack&quot;&gt;2.5 通过配置文件来使用webpack&lt;/h6&gt;
&lt;p&gt;其实webpack是有很多功能的，也是很方便的，我们可以在当前项目的根目录下新建一个配置文件&lt;code&gt;webpack.config.js&lt;/code&gt;，我们写下如下简单配置代码，目前只涉及入口配置（相当于我们的&lt;code&gt;index.js&lt;/code&gt;，从它开始打包）和出口配置（相当于我们打包生成的&lt;code&gt;bundle.js&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
module.exports = {
    entry: __dirname + &quot;/src/index.js&quot;, // 入口文件
    output: {
        path: __dirname + &quot;/dist&quot;, //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：&lt;code&gt;__dirname&lt;/code&gt;是node.js中的一个全局变量，它指向当前执行脚本所在的目录，即C:\Users\sjt\DeskTop\webpack-project（这是我当前的目录）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但平时我们看到的脚手架配置也比较喜欢采用node.js的&lt;code&gt;path&lt;/code&gt;模块来处理绝对路径，所以我们也可以采用如下的写法，和上述的效果是一样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：&lt;code&gt;path.join&lt;/code&gt;的功能是拼接路径片段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了这个配置文件，我们只需在终端中运行&lt;code&gt;webpack&lt;/code&gt;命令就可进行打包，这条命令会自动引用webpack.config.js文件中的配置选项，示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220025425-148053992.png&quot; alt=&quot;6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搞定，是不是这样更方便了，感觉没那么low了，但还能不能更便捷智能呢？那必须的！&lt;/p&gt;
&lt;h6 id=&quot;更智能的打包方式&quot;&gt;2.6 更智能的打包方式&lt;/h6&gt;
&lt;p&gt;我们现在只在终端中使用&lt;code&gt;webpack&lt;/code&gt;命令来进行打包，要是以后在打包的同时还有更多的操作呢，那不是还得写上更多的命令？所以我们得想办法把这些命令都集成起来，这时候之前的&lt;code&gt;package.json&lt;/code&gt;文件就派上用场了。&lt;br/&gt;现在的package.json文件大概就是如下这样：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot; //我们要修改的是这里，JSON文件不支持注释，引用时请清除
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack&quot;, //改成这样，注意使用时把注释删掉
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：package.json中的script会按你设置的命令名称来执行对应的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样我们就可以在终端中直接执行&lt;code&gt;npm start&lt;/code&gt;命令来进行打包，&lt;code&gt;start&lt;/code&gt;命令比较特殊，可以直接&lt;code&gt;npm&lt;/code&gt;加上&lt;code&gt;start&lt;/code&gt;就可以执行，如果我们想起其他的名称，如&lt;code&gt;build&lt;/code&gt;时，就需要使用&lt;code&gt;npm run&lt;/code&gt;加上&lt;code&gt;build&lt;/code&gt;，即&lt;code&gt;npm run build&lt;/code&gt;命令。&lt;br/&gt;现在我们执行&lt;code&gt;npm start&lt;/code&gt;命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220037449-1046667047.png&quot; alt=&quot;7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，搞定，是不是很简单，但webpack的功能远不止于此，下面我们继续。&lt;/p&gt;
&lt;h4 id=&quot;三构建本地服务器&quot;&gt;三、构建本地服务器&lt;/h4&gt;
&lt;p&gt;现在我们是通过打开本地文件来查看页面的，看起来总感觉比较low，看别人用vue，react框架时都是运行在本地服务器上的，那我们能不能也那样呢？那必须的！&lt;/p&gt;
&lt;h6 id=&quot;webpack-dev-server配置本地服务器&quot;&gt;3.1 webpack-dev-server配置本地服务器&lt;/h6&gt;
&lt;p&gt;Webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js构建，它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;cnpm i webpack-dev-server -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;devServer作为webpack配置选项中的一项，以下是它的一些配置选项:&lt;br/&gt;| devServer配置选项 | 功能描述 |&lt;br/&gt;| ------ | ------ |&lt;br/&gt;| contentBase | 设置服务器所读取文件的目录，当前我们设置为&quot;./dist&quot; |&lt;br/&gt;| port | 设置端口号，如果省略，默认为&lt;code&gt;8080&lt;/code&gt; |&lt;br/&gt;| inline | 设置为&lt;code&gt;true&lt;/code&gt;，当源文件改变时会自动刷新页面 |&lt;br/&gt;| historyApiFallback | 设置为&lt;code&gt;true&lt;/code&gt;，所有的跳转将指向&lt;code&gt;index.html&lt;/code&gt; |&lt;/p&gt;
&lt;p&gt;现在我们把这些配置加到&lt;code&gt;webpack.config.js&lt;/code&gt;文件上，如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,   // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续在&lt;code&gt;package.json&lt;/code&gt;文件中添加启动命令：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把&lt;code&gt;start&lt;/code&gt;命令名称改为了&lt;code&gt;build&lt;/code&gt;，这样比较语义化，平时的脚手架也多数采用这个名称，我们用&lt;code&gt;dev&lt;/code&gt;（development的缩写，意指开发环境）来启动本地服务器，&lt;code&gt;webpack-dev-server&lt;/code&gt;就是启动服务器的命令，&lt;code&gt;--open&lt;/code&gt;是用于启动完服务器后自动打开浏览器，这时候我们自定义命令方式的便捷性就体现出来了，可以多个命令集成在一起运行，即我们定义了一个&lt;code&gt;dev&lt;/code&gt;命令名称就可以同时运行了&lt;code&gt;webpack-dev-server&lt;/code&gt;和&lt;code&gt;--open&lt;/code&gt;两个命令。&lt;/p&gt;
&lt;p&gt;现在在终端输入&lt;code&gt;npm run dev&lt;/code&gt;运行服务器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220051243-1068981107.png&quot; alt=&quot;8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们即可在http://localhost:8088/中查看页面(退出服务器，可使用&lt;code&gt;ctrl+c&lt;/code&gt;后，再按&lt;code&gt;y&lt;/code&gt;确认，即可退出服务器运行)&lt;/p&gt;
&lt;h6 id=&quot;source-maps调试配置&quot;&gt;3.2 Source Maps调试配置&lt;/h6&gt;
&lt;p&gt;作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，&lt;code&gt;Source Map&lt;/code&gt;就是用来解决这个问题的。&lt;/p&gt;
&lt;p&gt;通过如下配置，我们会在打包时生成对应于打包文件的&lt;code&gt;.map&lt;/code&gt;文件，使得编译后的代码可读性更高，更易于调试。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map'  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置好后，我们再次运行&lt;code&gt;npm run build&lt;/code&gt;进行打包，这时我们会发现在&lt;code&gt;dist&lt;/code&gt;文件夹中多出了一个&lt;code&gt;bundle.js.map&lt;/code&gt;文件如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220103471-2022126498.png&quot; alt=&quot;9&quot;/&gt;&lt;br/&gt;如果我们的代码有bug，在浏览器的调试工具中会提示错误出现的位置，这就是&lt;code&gt;devtool: 'source-map'&lt;/code&gt;配置项的作用。&lt;/p&gt;
&lt;h4 id=&quot;四loaders&quot;&gt;四、Loaders&lt;/h4&gt;
&lt;p&gt;loaders是webpack最强大的功能之一，通过不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把&lt;code&gt;scss&lt;/code&gt;转为&lt;code&gt;css&lt;/code&gt;，将ES66、ES7等语法转化为当前浏览器能识别的语法，将JSX转化为js等多项功能。&lt;/p&gt;
&lt;p&gt;Loaders需要单独安装并且需要在&lt;code&gt;webpack.config.js&lt;/code&gt;中的&lt;code&gt;modules&lt;/code&gt;配置项下进行配置，Loaders的配置包括以下几方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;test&lt;/code&gt;：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loader&lt;/code&gt;：loader的名称（必须）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include/exclude&lt;/code&gt;：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt;：为loaders提供额外的设置选项（可选）&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;配置css-loader&quot;&gt;4.1 配置css-loader&lt;/h6&gt;
&lt;p&gt;如果我们要加载一个css文件，需要安装配置&lt;code&gt;style-loader&lt;/code&gt;和&lt;code&gt;css-loader&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i style-loader css-loader -D&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在src文件夹下新建&lt;code&gt;css&lt;/code&gt;文件夹，该文件夹内新建&lt;code&gt;style.css&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: gray;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;index.js&lt;/code&gt;中引用它：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
import './css/style.css';  //导入css

const hello = require('./hello.js');
document.querySelector(&quot;#root&quot;).appendChild(hello());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们运行&lt;code&gt;npm run dev&lt;/code&gt;，会发现页面背景变成了灰色。&lt;/p&gt;
&lt;p&gt;如果是要编译sass文件呢？&lt;/p&gt;
&lt;h6 id=&quot;配置sass&quot;&gt;4.2 配置sass&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i sass-loader node-sass -D // 因为sass-loader依赖于node-sass，所以还要安装node-sass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加sass的rules:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在css文件夹中新建&lt;code&gt;blue.scss&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;scss&quot;&gt;
&lt;code&gt;/* blue.scss */
$blue: blue;
body{
    color: $blue;
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;index.js&lt;/code&gt;中引入&lt;code&gt;blue.scss&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
import './css/style.css';   // 导入css
import './css/blue.scss';   // 导入scss

const hello = require('./hello.js');
document.querySelector(&quot;#root&quot;).appendChild(hello());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时&lt;code&gt;npm run dev&lt;/code&gt;重新启动服务器，应该会出现如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220114674-2019467125.png&quot; alt=&quot;10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有诸如图片loader、字体loader等就不一一列出来了，感兴趣的可前往&lt;a href=&quot;https://www.webpackjs.com/guides/asset-management/&quot;&gt;webpack官网&lt;/a&gt;查看，都是一样的套路。&lt;/p&gt;
&lt;h4 id=&quot;五babel&quot;&gt;五、Babel&lt;/h4&gt;
&lt;p&gt;Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；&lt;/li&gt;
&lt;li&gt;让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;babel的安装与配置&quot;&gt;5.1 Babel的安装与配置&lt;/h6&gt;
&lt;p&gt;Babel其实是几个模块化的包，其核心功能位于称为&lt;code&gt;babel-core&lt;/code&gt;的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的&lt;code&gt;babel-preset-env&lt;/code&gt;包和解析JSX的&lt;code&gt;babel-preset-react&lt;/code&gt;包）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i babel-core babel-loader babel-preset-env babel-preset-react -D
// babel-preset-env的env表示是对当前环境的预处理，而不是像以前使用babel-preset-es2015只能针对某个环境&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;,
                    options: {
                        presets: [
                            &quot;env&quot;, &quot;react&quot;
                        ]
                    }
                },
                exclude: /node_modules/
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们已经可以支持ES6及JSX的语法了，我们用react来试试，但使用react还得先安装两个模块&lt;code&gt;react&lt;/code&gt;和&lt;code&gt;react-dom&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i react react-dom -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们把&lt;code&gt;hello.js&lt;/code&gt;文件修改一下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// hello.js
import React, {Component} from 'react'; // 这两个模块必须引入

let name = Alan;

export default class Hello extends Component{
    render() {
        return (
            &amp;lt;div&amp;gt;
                {name}
            &amp;lt;/div&amp;gt;
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;index.js&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
import './css/style.css';  // 导入css
import './css/blue.scss';  // 导入scss

import React from 'react';
import {render} from 'react-dom';
import Hello from './hello'; // 可省略.js后缀名

render(&amp;lt;Hello /&amp;gt;, document.getElementById('root'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行&lt;code&gt;npm run dev&lt;/code&gt;后你可能会发现如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220127040-1188524929.png&quot; alt=&quot;11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为官方默认&lt;code&gt;babel-loader | babel&lt;/code&gt;对应的版本需要一致: 即&lt;code&gt;babel-loader&lt;/code&gt;需要搭配最新版本&lt;code&gt;babel&lt;/code&gt;，详细可参考&lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9554565.html&quot;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;两种解决方案:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回退低版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cnpm i babel-loader@7 babel-core babel-preset-env -D&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更新到最高版本:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cnpm i babel-loader @babel/core @babel/preset-env webpack -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里采取的是第一个方案，回退后，再此运行&lt;code&gt;npm run dev&lt;/code&gt;，得到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220138019-1372767647.png&quot; alt=&quot;12&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里了是不是感觉很爽，不就是配置嘛，想要使用什么就配置什么。&lt;/p&gt;
&lt;h6 id=&quot;优化babel配置&quot;&gt;5.2 优化babel配置&lt;/h6&gt;
&lt;p&gt;虽然babel完全可以在&lt;code&gt;webpack.config.js&lt;/code&gt;中进行配置，但现在不是都提倡模块化嘛，也许之后babel膨胀了，增加了更多的配置项呢？&lt;br/&gt;那我们不如把它提取出来，把它放到根目录下的&lt;code&gt;.babelrc&lt;/code&gt;文件下（webpack会自动调用&lt;code&gt;.babelrc&lt;/code&gt;里的babel配置选项）。&lt;/p&gt;
&lt;p&gt;我们在项目根目录下新建&lt;code&gt;.babelrc&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220149499-1836743362.png&quot; alt=&quot;13&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// .babelrc 使用时把注释删掉，该文件不能添加注释
{
    &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时不出问题的话应该一切运行正常，接下来让我们进入强大的插件模块。&lt;/p&gt;
&lt;h4 id=&quot;六插件plugins&quot;&gt;六、插件（Plugins）&lt;/h4&gt;
&lt;p&gt;插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。&lt;br/&gt;Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。&lt;/p&gt;
&lt;h6 id=&quot;如何使用&quot;&gt;6.1 如何使用&lt;/h6&gt;
&lt;p&gt;使用某个插件，需要通过&lt;code&gt;npm&lt;/code&gt;进行安装，然后在&lt;code&gt;webpack.config.js&lt;/code&gt;配置文件的&lt;code&gt;plugins&lt;/code&gt;(是一个数组)配置项中添加该插件的实例，下面我们先来使用一个简单的版权声明插件。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块

module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    },
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究')  // new一个插件的实例 
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;npm run build&lt;/code&gt;打包后我们看到&lt;code&gt;bundle.js&lt;/code&gt;文件显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220201562-1891928150.png&quot; alt=&quot;14&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;自动生成html文件htmlwebpackplugin&quot;&gt;6.2 自动生成html文件(HtmlWebpackPlugin)&lt;/h6&gt;
&lt;p&gt;到目前为止我们都是使用一开始建好的&lt;code&gt;index.html&lt;/code&gt;文件，而且也是手动引入&lt;code&gt;bundle.js&lt;/code&gt;，要是以后我们引入不止一个js文件，而且更改js文件名的话，也得手动更改&lt;code&gt;index.html&lt;/code&gt;中的js文件名，所以能不能自动生成&lt;code&gt;index.html&lt;/code&gt;且自动引用打包后的js呢？&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;插件就是用来解决这个问题的：&lt;/p&gt;
&lt;p&gt;首先安装该插件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i html-webpack-plugin -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们对项目结构进行一些更改：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;dist&lt;/code&gt;整个文件夹删除；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;src&lt;/code&gt;文件夹下新建一个&lt;code&gt;index.template.html&lt;/code&gt;(名称自定义)文件模板（当然这个是可选的，因为就算不设置模板，&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;插件也会生成默认&lt;code&gt;html&lt;/code&gt;文件，这里我们设置模块会让我们的开发更加灵活），如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- index.template.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Here is Template&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id='root'&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;中我们引入了&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;插件，并配置了引用了我们设置的模板，如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');  // 路径处理模块
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 引入HtmlWebpackPlugin插件

module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    },
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        })
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们使用&lt;code&gt;npm run build&lt;/code&gt;进行打包，你会发现，&lt;code&gt;dist&lt;/code&gt;文件夹和&lt;code&gt;html&lt;/code&gt;文件都会自动生成，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220214163-970720656.png&quot; alt=&quot;15&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么会自动生成&lt;code&gt;dist&lt;/code&gt;文件夹呢？因为我们在&lt;code&gt;output&lt;/code&gt;出口配置项中定义了出口文件所在的位置为&lt;code&gt;dist&lt;/code&gt;文件夹，且出口文件名为&lt;code&gt;bundle.js&lt;/code&gt;，所以&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;会自动帮你在&lt;code&gt;index.html&lt;/code&gt;中引用名为&lt;code&gt;bundle.js&lt;/code&gt;文件，如果你在&lt;code&gt;webpack.config.js&lt;/code&gt;文件中更改了出口文件名，&lt;code&gt;index.html&lt;/code&gt;中也会自动更改该文件名，这样以后修改起来是不是方便多了？&lt;/p&gt;
&lt;h6 id=&quot;清理dist文件夹cleanwebpackplugin&quot;&gt;6.3 清理&lt;code&gt;/dist&lt;/code&gt;文件夹(CleanWebpackPlugin)&lt;/h6&gt;
&lt;p&gt;你可能已经注意到，在我们删掉&lt;code&gt;/dist&lt;/code&gt;文件夹之前，由于前面的代码示例遗留，导致我们的&lt;code&gt;/dist&lt;/code&gt;文件夹比较杂乱。&lt;code&gt;webpack&lt;/code&gt;会生成文件，然后将这些文件放置在&lt;code&gt;/dist&lt;/code&gt;文件夹中，但是&lt;code&gt;webpack&lt;/code&gt;无法追踪到哪些文件是实际在项目中用到的。&lt;/p&gt;
&lt;p&gt;通常，在每次构建前清理&lt;code&gt;/dist&lt;/code&gt;文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到&lt;code&gt;CleanWebpackPlugin&lt;/code&gt;插件了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i clean-webpack-plugin -D&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
...
const CleanWebpackPlugin = require('clean-webpack-plugin'); // 引入CleanWebpackPlugin插件

module.exports = {
    ...
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        }),
        new CleanWebpackPlugin(['dist']),  // 所要清理的文件夹名称
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。&lt;/p&gt;
&lt;p&gt;现在我们运行&lt;code&gt;npm run build&lt;/code&gt;后就会发现，webpack会先将&lt;code&gt;/dist&lt;/code&gt;文件夹删除，然后再生产新的&lt;code&gt;/dist&lt;/code&gt;文件夹。&lt;/p&gt;
&lt;h6 id=&quot;热更新hotmodulereplacementplugin&quot;&gt;6.4 热更新(HotModuleReplacementPlugin)&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;HotModuleReplacementPlugin&lt;/code&gt;（HMR）是一个很实用的插件，可以在我们修改代码后自动刷新预览效果。&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;devServer&lt;/code&gt;配置项中添加&lt;code&gt;hot: true&lt;/code&gt;参数。&lt;/li&gt;
&lt;li&gt;因为&lt;code&gt;HotModuleReplacementPlugin&lt;/code&gt;是&lt;code&gt;webpack&lt;/code&gt;模块自带的，所以引入&lt;code&gt;webpack&lt;/code&gt;后，在&lt;code&gt;plugins&lt;/code&gt;配置项中直接使用即可。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
...
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块

module.exports = {
    ...
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
        hot: true // 热更新
    },
    ...
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        }),
        new CleanWebpackPlugin(['dist']),  // 传入所要清理的文件夹名称
        new webpack.HotModuleReplacementPlugin() // 热更新插件 
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们重新启动项目&lt;code&gt;npm run dev&lt;/code&gt;后，修改&lt;code&gt;hello.js&lt;/code&gt;的内容，会发现浏览器预览效果会自动刷新（也许反应会比较慢，因为我们使用了&lt;code&gt;source-map&lt;/code&gt;和其他配置的影响，后面代码分离的时候我们再处理）。&lt;/p&gt;
&lt;h3 id=&quot;七项目优化及拓展&quot;&gt;七、项目优化及拓展&lt;/h3&gt;
&lt;h6 id=&quot;代码分离&quot;&gt;7.1 代码分离&lt;/h6&gt;
&lt;p&gt;在当前的开发环境都是提倡模块化，webpack自然不例外，我们前面的&lt;code&gt;webpack.config.js&lt;/code&gt;配置文件，其实也没配置多少东西就这么多了，要是以后增加了更多配置，岂不是看得眼花缭乱，所以最好的方法就是把它拆分，方便管理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们在根目录下新建三个文件，分别为&lt;code&gt;webpack.common.js&lt;/code&gt;、&lt;code&gt;webpack.dev.js&lt;/code&gt;、&lt;code&gt;webpack.prod.js&lt;/code&gt;，分别代表公共配置文件、开发环境配置文件、生产环境（指项目上线时的环境）配置文件。&lt;/li&gt;
&lt;li&gt;安装一个合并模块插件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;cnpm i webpack-merge -D&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;将&lt;code&gt;webpack.config.js&lt;/code&gt;的代码拆分到上述新建的三个文件中，然后把&lt;code&gt;webpack.config.js&lt;/code&gt;文件删除，具体如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
const path = require('path');  // 路径处理模块
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 引入HtmlWebpackPlugin插件

module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    },
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        }),
        new webpack.HotModuleReplacementPlugin()
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.dev.js
const merge = require('webpack-merge');  // 引入webpack-merge功能模块
const common = require('./webpack.common.js'); // 引入webpack.common.js

module.exports = merge(common, {   // 将webpack.common.js合并到当前文件
    devServer: {
        contentBase: &quot;./dist&quot;,   // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true,  // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
        hot: true     //热加载
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.prod.js
const merge = require('webpack-merge');
const common = require('./webpack.common.js');
const CleanWebpackPlugin = require('clean-webpack-plugin'); // 引入CleanWebpackPlugin插件

module.exports = merge(common, { // 将webpack.common.js合并到当前文件
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    plugins: [
        new CleanWebpackPlugin(['dist']),  // 所要清理的文件夹名称
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们的项目目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220227193-1234902752.png&quot; alt=&quot;17&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.26.3&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.5&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,
    &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,
    &quot;clean-webpack-plugin&quot;: &quot;^0.1.19&quot;,
    &quot;css-loader&quot;: &quot;^1.0.0&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;node-sass&quot;: &quot;^4.9.4&quot;,
    &quot;react&quot;: &quot;^16.6.0&quot;,
    &quot;react-dom&quot;: &quot;^16.6.0&quot;,
    &quot;sass-loader&quot;: &quot;^7.1.0&quot;,
    &quot;style-loader&quot;: &quot;^0.23.1&quot;,
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.4&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把&lt;code&gt;build&lt;/code&gt;命令改为了&lt;code&gt;webpack --config webpack.prod.js&lt;/code&gt;，意思是把打包配置指向&lt;code&gt;webpack.prod.js&lt;/code&gt;配置文件，而之前我们只需要使用一个&lt;code&gt;webpack&lt;/code&gt;命令为什么就可以运行了？因为&lt;code&gt;webpack&lt;/code&gt;命令是默认指向&lt;code&gt;webpack.config.js&lt;/code&gt;这个文件名称了，现在我们把文件名称改了，所以就需要自定义指向新的文件，&lt;code&gt;dev&lt;/code&gt;命令中的指令也同理。&lt;/p&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;和&lt;code&gt;npm run dev&lt;/code&gt;，效果应该和我们分离代码前是一样的。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注：说道&lt;code&gt;package.json&lt;/code&gt;文件，顺便就多提几句，因为也许有些朋友可能对我们安装模块时加的&lt;code&gt;-D&lt;/code&gt;、&lt;code&gt;-S&lt;/code&gt;或&lt;code&gt;-g&lt;/code&gt;命令存在一些疑惑，因为不知道什么时候加什么尾缀。&lt;br/&gt;其实这个&lt;code&gt;package.json&lt;/code&gt;文件是用于我们安装依赖的，可以把它当成一份依赖安装说明表，就是如果我们把项目上传或者发给其他的开发同事，肯定不会把&lt;code&gt;/node_modules&lt;/code&gt;文件夹也发送过去，因为这太大了，不现实也没必要。&lt;br/&gt;开发同事只需要有这份&lt;code&gt;package.json&lt;/code&gt;文件，然后&lt;code&gt;npm install&lt;/code&gt;就可以把我们所需要的依赖都安装下来，但前提是&lt;code&gt;package.json&lt;/code&gt;文件上有记录，这就是安装模块时加上&lt;code&gt;-D&lt;/code&gt;,&lt;code&gt;-S&lt;/code&gt;命令的原因。&lt;br/&gt;&lt;code&gt;-D&lt;/code&gt;的全称是&lt;code&gt;--save-dev&lt;/code&gt;指开发环境时需要用到的依赖，会记录在&lt;code&gt;package.json&lt;/code&gt;文件中的&lt;code&gt;devDependencies&lt;/code&gt;选项中，而&lt;code&gt;-S&lt;/code&gt;是&lt;code&gt;--save&lt;/code&gt;是指生产环境也就是上线环境中需要用到的依赖，会记录在&lt;code&gt;package.json&lt;/code&gt;文件中的&lt;code&gt;dependencies&lt;/code&gt;选项中，&lt;code&gt;-g&lt;/code&gt;的全称是&lt;code&gt;--global&lt;/code&gt;指安装全局命令，就是我们在本电脑的任何项目中都能使用到的命令，比如安装&lt;code&gt;cnpm&lt;/code&gt;这个淘宝镜像命令就会用到&lt;code&gt;-g&lt;/code&gt;命令。&lt;br/&gt;所以我们在安装模块时一定不要忘了加上对应的尾缀命令，让我们的模块有迹可循，否则其他的开发同事接手你的项目的话，会不会下班后（放学后）在门口等你就不知道了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扯远了，希望不要嫌弃，也是想讲得更详细嘛！&lt;/p&gt;
&lt;h6 id=&quot;多入口多出口&quot;&gt;7.2 多入口多出口&lt;/h6&gt;
&lt;p&gt;到目前为止我们都是一个入口文件和一个出口文件，要是我不止一个入口文件呢？下面我们来试试：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;webpack.common.js&lt;/code&gt;中的&lt;code&gt;entry&lt;/code&gt;入口有三种写法，分别为字符串、数组和对象，平时我们用得比较多的是对象，所以我们把它改为对象的写法，首先我们在&lt;code&gt;src&lt;/code&gt;文件夹下新建&lt;code&gt;two.js&lt;/code&gt;文件，名称任意。因为有多个入口，所以肯定得多个出口来进行一一对应了，所以&lt;code&gt;entry&lt;/code&gt;和&lt;code&gt;output&lt;/code&gt;配置如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    entry: {
        index: path.join(__dirname, &quot;/src/index.js&quot;),
        two: path.join(__dirname, &quot;/src/two.js&quot;)
    }, 
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;[name].js&quot; //打包后输出文件的文件名
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// two.js
function two() {
    let element = document.createElement('div');
    element.innerHTML = '我是第二个入口文件';
    return element;
}

document.getElementById('root').appendChild(two());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;打包后发现&lt;code&gt;/dist&lt;/code&gt;文件夹下会多出&lt;code&gt;two.js&lt;/code&gt;文件，同时&lt;code&gt;index.html&lt;/code&gt;也会自动将&lt;code&gt;two.js&lt;/code&gt;引入，然后我们运行&lt;code&gt;npm run dev&lt;/code&gt;显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220237558-1724532675.png&quot; alt=&quot;18&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;增加css前缀分离css消除冗余css分离图片&quot;&gt;7.3 增加css前缀、分离css、消除冗余css、分离图片&lt;/h6&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;增加css前缀&lt;/strong&gt;&lt;br/&gt;平时我们写css时，一些属性需要手动加上前缀，比如&lt;code&gt;-webkit-border-radius: 10px;&lt;/code&gt;，在webpack中我们能不能让它自动加上呢？那是必须的，首先肯定得安装模块了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;cnpm i postcss-loader autoprefixer -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装好这两个模块后，在项目根目录下新建&lt;code&gt;postcss.config.js&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// postcss.config.js
module.exports = {
    plugins: [
        require('autoprefixer')  // 引用autoprefixer模块
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;style.css&lt;/code&gt;中增加以下样式：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: #999;
}

#root div{
    width: 200px;
    margin-top: 50px;
    transform: rotate(45deg); /* 这个属性会产生前缀 */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;webpack.common.js&lt;/code&gt;文件中的&lt;code&gt;css-loader&lt;/code&gt;配置：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: [            
                    {loader: 'style-loader'}, // 这里采用的是对象配置loader的写法
                    {loader: 'css-loader'},
                    {loader: 'postcss-loader'} // 使用postcss-loader
                ]  
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run dev&lt;/code&gt;后css样式中会自动添加前缀，显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220250613-127989039.png&quot; alt=&quot;19&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;分离css&lt;/strong&gt;&lt;br/&gt;虽然webpack的理念是把css、js全都打包到一个文件里，但要是我们想把css分离出来该怎么做呢？&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;cnpm i extract-text-webpack-plugin@next -D  // 加上@next是为了安装最新的，否则会出错&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完以上插件后在&lt;code&gt;webpack.common.js&lt;/code&gt;文件中引入并使用该插件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
const ExtractTextPlugin = require('extract-text-webpack-plugin') //引入分离插件

module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({  // 这里我们需要调用分离插件内的extract方法
                    fallback: 'style-loader',  // 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理
                    use: ['css-loader', 'postcss-loader']
                })
            },
            ...
        ]
    },
    plugins: [
        ...
        new ExtractTextPlugin('css/index.css') // 将css分离到/dist文件夹下的css文件夹中的index.css
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;npm run build&lt;/code&gt;后会发现&lt;code&gt;/dist&lt;/code&gt;文件夹内多出了&lt;code&gt;/css&lt;/code&gt;文件夹及&lt;code&gt;index.css&lt;/code&gt;文件。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;消除冗余css&lt;/strong&gt;&lt;br/&gt;有时候我们css写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，上线前又忘了检查，对于这方面，我们应该尽量去优化它，webpack就有这个功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;cnpm i purifycss-webpack purify-css glob -D&lt;/code&gt;&lt;br/&gt;安装完上述三个模块后，因为正常来说是在生产环境中优化代码，所以我们应该是在&lt;code&gt;webpack.prod.js&lt;/code&gt;文件中进行配置，引入&lt;code&gt;clean-webpack-plugin&lt;/code&gt;及&lt;code&gt;glob&lt;/code&gt;插件并使用它们：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.prod.js
const merge = require('webpack-merge');
const common = require('./webpack.common.js');
const CleanWebpackPlugin = require('clean-webpack-plugin'); // 引入CleanWebpackPlugin插件

const path = require('path');
const PurifyCssWebpack = require('purifycss-webpack'); // 引入PurifyCssWebpack插件
const glob = require('glob');  // 引入glob模块,用于扫描全部html文件中所引用的css

module.exports = merge(common, {   // 将webpack.common.js合并到当前文件
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    plugins: [
        new CleanWebpackPlugin(['dist']),  // 所要清理的文件夹名称
        new PurifyCssWebpack({
            paths: glob.sync(path.join(__dirname, 'src/*.html')) // 同步扫描所有html文件中所引用的css
        })
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;style.css&lt;/code&gt;文件中增加一些多余的代码试试：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: #999;
}

#root div{
    width: 200px;
    margin-top: 50px;
    transform: rotate(45deg); /* 这个属性会产生前缀 */
}

.a{                 /* 冗余css */
    color: black;     
}

.b{                 /* 冗余css */
    width: 50px;
    height: 50px;
    background: yellow;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;后发现打包后的&lt;code&gt;index.css&lt;/code&gt;中是没有多余的&lt;code&gt;.a&lt;/code&gt;和&lt;code&gt;.b&lt;/code&gt;代码的：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* index.css */

body {
  background: #999;
}

#root div {
  width: 200px;
  margin-top: 50px;
  -webkit-transform: rotate(45deg);
  transform: rotate(45deg);
  /* 这个属性会产生前缀 */
}
/*# sourceMappingURL=index.css.map*/&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;处理图片&lt;/strong&gt;&lt;br/&gt;到目前为止我们还没讲到图片的问题，如果要使用图片，我们得安装两个loader：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 虽然我们只需使用url-loader，但url-loader是依赖于file-loader的，所以也要安装
cnpm i url-loader file-loader -D &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;webpack.common.js&lt;/code&gt;中配置&lt;code&gt;url-loader&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({
                    fallback: 'style-loader',
                    use: ['css-loader', 'postcss-loader']
                })
            },
            {
                test: /\.(png|jpg|svg|gif)$/,  // 正则匹配图片格式名
                use: [
                    {
                        loader: 'url-loader'  // 使用url-loader
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们修改一下&lt;code&gt;style.css&lt;/code&gt;，把背景改为图片背景：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: url(../images/coffee.png) top right repeat-y;  /* 设为图片背景 */
}

#root div{
    width: 200px;
    margin-top: 50px;
    transform: rotate(45deg); /* 这个属性会产生前缀 */
}

.a{
    color: black;
}

.b{
    width: 50px;
    height: 50px;
    background: yellow;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;npm run dev&lt;/code&gt;后显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220304534-246820192.png&quot; alt=&quot;20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是背景图片变成了&lt;code&gt;base64&lt;/code&gt;，因为webpack会自动优化图片，减少发送请求，但是如果我想把它变成路径的该怎么做？&lt;/p&gt;
&lt;p&gt;我们可以把&lt;code&gt;webpack.common.js&lt;/code&gt;的loader配置更改一下，增加&lt;code&gt;options&lt;/code&gt;选项：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({
                    fallback: 'style-loader',
                    use: ['css-loader', 'postcss-loader']
                })
            },
            {
                test: /\.(png|jpg|svg|gif)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1000  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化
                        }
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;后，再运行&lt;code&gt;npm run dev&lt;/code&gt;，额，图片是没有转成base64了，但是图片怎么不显示了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220316736-1997271601.png&quot; alt=&quot;21&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题就出在路径上，我们之前图片的路径是在&lt;code&gt;../images&lt;/code&gt;文件夹下，但是打包出来后没有这个路径了，图片直接和文件同级了，所以我们需要在&lt;code&gt;webpack.common.js&lt;/code&gt;中给它设置一个文件夹：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            ...
            {
                test: /\.(png|jpg|svg|gif)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1000,  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化
                            outputPath: 'images'  // 设置打包后图片存放的文件夹名称
                        }
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续&lt;code&gt;npm run build&lt;/code&gt;打包再&lt;code&gt;npm run dev&lt;/code&gt;运行，我的天！图片还是不显示！&lt;br/&gt;调试工具上看图片路径有&lt;code&gt;images&lt;/code&gt;文件夹了，但是我的&lt;code&gt;../&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220328695-22813844.png&quot; alt=&quot;22&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这又涉及到配置路径的问题上了，我们还需要在css-loader中给背景图片设置一个公共路径&lt;code&gt;publicPath: '../'&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({
                    fallback: 'style-loader',
                    use: ['css-loader', 'postcss-loader'],
                    publicPath: '../'  // 给背景图片设置一个公共路径
                })
            },
            {
                test: /\.(png|jpg|svg|gif)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1000,  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化
                            outputPath: 'images'  // 设置打包后图片存放的文件夹名称
                        }
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再&lt;code&gt;npm run build&lt;/code&gt;打包再&lt;code&gt;npm run dev&lt;/code&gt;启动，OK！没毛病！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220341623-450034724.png&quot; alt=&quot;23&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很热闹？到现在我们不知不觉中也同时解决了图片分离的问题，偷偷高兴一下吧！&lt;/p&gt;
&lt;h6 id=&quot;压缩代码&quot;&gt;7.4 压缩代码&lt;/h6&gt;
&lt;p&gt;在webpack4.x版本中当你打包时会自动把js压缩了，而且&lt;code&gt;npm run dev&lt;/code&gt;运行服务器时，当你修改代码时，热更新很慢，这是因为你修改后webpack又自动为你打包，这就导致了在开发环境中效率很慢，所以我们需要把开发环境和生产环境区分开来，这时就体现出我们代码分离的便捷性了，&lt;code&gt;webpack.dev.js&lt;/code&gt;代表开发环境的配置，&lt;code&gt;webpack.prod.js&lt;/code&gt;代表生产环境的配置，这时我们只要在&lt;code&gt;package.json&lt;/code&gt;文件中配置对应环境的命令即可：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  ...
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.prod.js --mode production&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.dev.js --mode development&quot;
  },
  ...
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--mode production&lt;/code&gt;表示打包时是生产环境，会自己将js进行压缩，而&lt;code&gt;--mode development&lt;/code&gt;表示当前是开发环境，不需要进行压缩。这同时也解决了之前一直遗留的警告问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220354432-15442521.png&quot; alt=&quot;24&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;好了，到现在我们基本把webapck常用的功能都走了一遍，写得有点长，感谢你能仔细的看到这里，希望能对你有所帮助，如果有发现不对的地方，也请多多指教。其实webpack还有很多功能，这里也没讲述完全，但相信你现在对webpack也有了一定的了解，更多的webpack探索一定难不倒你！&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 14:21:00 +0000</pubDate>
<dc:creator>Better-Man</dc:creator>
<og:description>本文主要是针对webpack4.x版本，会对平时常用的Webpack配置一一讲解，各个功能点都有对应的详细例子，所以本文也比较长，但如果你能动手跟着本文中的例子完整写一次，相信你会觉得Webpack也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BetterMan-/p/9867642.html</dc:identifier>
</item>
</channel>
</rss>