<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MyBatis(4)动态SQL - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9741325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9741325.html</guid>
<description>&lt;p&gt;动态SQL&lt;/p&gt;
&lt;p&gt;动态SQLMyBatis最强大的特性之一就是它的动态SQL功能。&lt;/p&gt;
&lt;p&gt;如果您有任何JDBC或类似框架的经验，那么您就会理解有条件地将SQL字符串连接在一起是多么痛苦，确保不要忘记空格或在列列表末尾省略al逗号。&lt;/p&gt;
&lt;p&gt;动态SQL处理起来可能非常痛苦，而使用动态SOL永远都不会是一件很麻烦的事情，MyBatis使用一种强大的动态SQL语言(可以在任何映射的SQL语句中使用)无疑改善了这种情况。&lt;/p&gt;
&lt;p&gt;使用JSTL或任何类似的基于XML的文本处理器的人都应该熟悉动态SOL元素。&lt;/p&gt;
&lt;p&gt;在以前的MyBatis版本中，有很多元素需要了解和理解。MyBatis 3在此基础上有了很大的改进，现在只有不到一半的元素。&lt;/p&gt;
&lt;p&gt;一起工作。MyBatis使用了强大的基于OGNL的表达式来消除大多数其他元素&lt;/p&gt;

&lt;p&gt;---&amp;gt;if&lt;/p&gt;
&lt;p&gt;---&amp;gt;choose(when,otherwise)&lt;/p&gt;
&lt;p&gt;---&amp;gt;trim(where,set)&lt;/p&gt;
&lt;p&gt;---&amp;gt;foreach&lt;/p&gt;

&lt;div readability=&quot;25&quot;&gt;

&lt;p&gt;&lt;span&gt;此文章及以后不带结果的截图，影响整体文章的布局美感！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他的一些可以简单看一下之前的博文！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先来看看本次工程的目录吧：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181003232314519-67576586.png&quot; alt=&quot;&quot; width=&quot;113&quot; height=&quot;172&quot;/&gt;&lt;p&gt;mybatis-config.xml:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE configuration
 PUBLIC &lt;/span&gt;&quot;-//mybatis.org//DTD Config 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
     &amp;lt;properties resource=&quot;db.properties&quot; &amp;gt;&amp;lt;/properties&amp;gt;
     &amp;lt;environments &lt;span&gt;default&lt;/span&gt;=&quot;development&quot;&amp;gt;
           &amp;lt;environment id=&quot;development&quot;&amp;gt;
                &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt;
                &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                     &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&amp;gt;
                &amp;lt;/dataSource&amp;gt;
           &amp;lt;/environment&amp;gt;
     &amp;lt;/environments&amp;gt;
     &amp;lt;mappers&amp;gt;
           &amp;lt;mapper resource=&quot;DynamicSQL.xml&quot;/&amp;gt;
     &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Employee.java(getter&amp;amp;setter&amp;amp;toString)&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee {
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String gender;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String email;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Department dept;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在基本的布局已经完成！！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1）if&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A.在DynamicMapper.java接口中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;携带了哪个字段的查询条件就携带这个字段的值&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIf(Employee emp);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 在Dynamic'SQl.xml文件&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- &lt;span&gt;if&lt;/span&gt; --&amp;gt;
 &amp;lt;!-- 查询员工，要求，携带了那个字段查询条件就带上那个字段的字段值 --&amp;gt;
 &amp;lt;!--      &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIf(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     where
          &lt;/span&gt;&amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
          &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
          &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
          &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;id!=null&quot;&amp;gt;&lt;span&gt;
           id&lt;/span&gt;=&lt;span&gt;#{id}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           and name like #{name}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           and email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个文件的内容简要的进行说明一下：&lt;/p&gt;
&lt;p&gt; and &lt;span&gt;name&lt;/span&gt; like #{name}&lt;/p&gt;
&lt;p&gt;这里的&lt;span&gt;红色&lt;/span&gt;的name是我们查询的name值，不是数据库中的name&lt;/p&gt;
&lt;p&gt;#{name}是把我们手动输入的&lt;span&gt;红色name&lt;/span&gt;传递过去，进行数据库的查询&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt; 测试类：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; SqlSessionFactory getSqlSessionFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
           String resource &lt;/span&gt;= &quot;mybatis-config.xml&quot;&lt;span&gt;;
           InputStream inputStream &lt;/span&gt;=&lt;span&gt; Resources.getResourceAsStream(resource);   
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
     }
     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入的红色name值进行数据库的查询&lt;/span&gt;
                Employee emp = &lt;span&gt;new&lt;/span&gt; Employee(5, &quot;%Mr%&quot;, &quot;boy&quot;, &quot;%1287%&quot;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpByIf(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查询之后的显示代码&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 12:13:49,806 ==&amp;gt;  Preparing: select * from test &lt;span&gt;where id=? and name like ? and email like ?&lt;/span&gt;   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 12:13:49,843 ==&amp;gt; Parameters: 5(Integer), %Mr%(String), %1287%(String)  (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 12:13:49,873 &amp;lt;==      Total: 1  (BaseJdbcLogger.java:159&lt;span&gt;)
[Employee [id&lt;/span&gt;=5, name=MrChengs, gender=boy, email=1287xxxxxx@xx.com, dept=&lt;span&gt;null&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; B.在查询的时候，如果某些时候某些条件没带可能导致sql拼装有问题&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     where
          &lt;/span&gt;&amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
          &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
          &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
          &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
     &amp;lt;!--此时我们假设忘记把id传进来 --&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           and name like #{name}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           and email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; look：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
show message:DEBUG 10-02 12:18:30,831 ==&amp;gt;  Preparing: select * from test where and name like ? and email like ? &lt;br/&gt;(BaseJdbcLogger.java:159)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div readability=&quot;36.5&quot;&gt;
&lt;p&gt;solution ①：&lt;span&gt;  where 1=1&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
    &lt;/span&gt;&amp;lt;!-- 加入固定的条件，怎么拼装都行 --&amp;gt;&lt;span&gt;
     where &lt;/span&gt;&lt;span&gt;1=1&lt;/span&gt;
          &amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
          &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
          &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
          &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           and name like #{name}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           and email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;solution ②：使用&amp;lt;where&amp;gt;&amp;lt;/where&amp;gt;  只会去掉一个and  或者or&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     &lt;/span&gt;&lt;span&gt;&amp;lt;where&amp;gt;&lt;/span&gt;
                &amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
                &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
                &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
                &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
          &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
                and name like #{name}
          &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
          &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
                and email like #{email}
          &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &lt;span&gt;   &amp;lt;/where&amp;gt;&lt;/span&gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 注意使用and&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.使用trim标签进行，字符串截取&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;先看一个案例的错误代码展示：&lt;/p&gt;

&lt;p&gt;DynamicSQLMapper.java&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试Trim&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIfTrim(Employee emp);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在DynamicSQL.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 测试Trim（） --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIfTrim(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpByIfTrim&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
    select &lt;/span&gt;*&lt;span&gt; from test
    where
     &lt;/span&gt;&amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;id!=null&quot;&amp;gt;&lt;span&gt;
           id&lt;/span&gt;=&lt;span&gt;#{id} and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           name like #{name}    and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;假设我们此时传参为name属性一个&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpByIfTrim() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
              &lt;span&gt;  Employee emp &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new Employee(&quot;%Mr%&quot;, null, null&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpByIfTrim(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 拼串结果&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 13:31:59,995 ==&amp;gt;  Preparing: select * from test where id=? and name like ? and
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;开始使用trim标签：（一些用法都在注释中，请注意看注释）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 测试Trim（） --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIfTrim(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpByIfTrim&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
    select &lt;/span&gt;*&lt;span&gt; from test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!-- prefix:前缀， trim标签体中是整个字符串拼串后的结果     给拼串后的整体字符串加一个前缀--&amp;gt;
    &amp;lt;!-- prefixOverrides:前缀覆盖，    去点整个前缀前面多余的字符串 --&amp;gt;
    &amp;lt;!-- suffix:后缀，  给拼串后的整个字符串加一个后缀 --&amp;gt;
    &amp;lt;!-- suffixOverrides:后缀覆盖，去掉整个字符串后面多余的字符串 --&amp;gt;&lt;/span&gt;
    &amp;lt;trim prefix=&quot;where&quot;  suffixOverrides=&quot;and&quot;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           name like #{name}    and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           email like #{email} and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;gender!=null&quot;&amp;gt;&lt;span&gt;
           gender&lt;/span&gt;=&lt;span&gt;#{gender}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;/trim&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpByIfTrim() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                Employee emp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Employee(&quot;%Mr%&quot;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpByIfTrim(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果拼串：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 13:43:25,216 ==&amp;gt; &lt;span&gt; Preparing: select * from test where name like ?&lt;/span&gt;   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 13:43:25,266 ==&amp;gt; Parameters: %Mr%(String)  (BaseJdbcLogger.java:159)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意：在测试id的时候，不写则默认为零，博主自己测试的时候遇到的，所以把id的查询条件拿掉了！&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;3.choose分支选择&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;如果带了id使用id进行查询，带了name就是用name进行查询&lt;/p&gt;
&lt;p&gt;只能使用一个进行查询&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;接口类的代码：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试choose&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpBychoose(Employee emp);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; DynamicSQL.xml:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- choose --&amp;gt;
 &amp;lt;!-- 如果带了id使用id进行查询，带了name就是用name进行查询,只能使用一个进行查询 --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpBychoose(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpBychoose&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     &lt;/span&gt;&amp;lt;where&amp;gt;
           &amp;lt;choose&amp;gt;
                &amp;lt;when test=&quot;name!=null&quot;&amp;gt;&lt;span&gt;
                     name like #{name}
                &lt;/span&gt;&amp;lt;/when&amp;gt;    
                &amp;lt;when test=&quot;email!=null&quot;&amp;gt;&lt;span&gt;
                     email &lt;/span&gt;=&lt;span&gt; #{email}
                &lt;/span&gt;&amp;lt;/when&amp;gt;
                &amp;lt;when test=&quot;id!=null&quot;&amp;gt;&lt;span&gt;
                     id&lt;/span&gt;=&lt;span&gt;#{id}
                &lt;/span&gt;&amp;lt;/when&amp;gt;    
                &amp;lt;otherwise&amp;gt;&lt;span&gt;
                     d_id&lt;/span&gt;=1
                &amp;lt;/otherwise&amp;gt;
           &amp;lt;/choose&amp;gt;
     &amp;lt;/where&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试代码：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试choose&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpBychoose() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
 &lt;span&gt;               Employee emp &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new Employee(&quot;%Mr%&quot;, null, null);
                emp.setId(5&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpBychoose(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 14:07:35,311 ==&amp;gt;  Preparing: select * from test WHERE name like ?   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 14:07:35,363 ==&amp;gt; Parameters: %Mr%(String)  (BaseJdbcLogger.java:159)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此时我们不仅传入了name同时还传入了id，但是拼串之后是使用name进行查询的&lt;/p&gt;


&lt;p&gt;&lt;span&gt;3.更新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A.&amp;lt;set&amp;gt;&amp;lt;/set&amp;gt;版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在接口中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新方法&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updataEmp(Employee emp);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在DynamicSQl.xml文件：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- update更新 --&amp;gt;
  &amp;lt;!-- 更新 --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updataEmp(Employee emp); --&amp;gt;
 &amp;lt;update id=&quot;updataEmp&quot;&amp;gt;&lt;span&gt;
  update test
  &lt;/span&gt;&amp;lt;set&amp;gt;
  &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null&quot;&amp;gt;name=#{name},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null&quot;&amp;gt;  email=#{email},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &amp;lt;/set&amp;gt;&lt;span&gt;
  where  id&lt;/span&gt;=&lt;span&gt;#{id}
 &lt;/span&gt;&amp;lt;/update&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 使用&amp;lt;set&amp;gt;标签，可以自动为我们解决存在的    ”,“   问题&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt; 测试：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新upddate&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpupdate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
         &lt;span&gt;       Employee emp &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new Employee(&quot;MrChengsR&quot;, &quot;gril&quot;, null);
                emp.setId(7&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                mapper.updataEmp(emp);
                System.out.println(emp);
                session.commit();
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此时修改数据成功&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;15&quot;&gt;

&lt;p&gt;B.&amp;lt;trim&amp;gt;&amp;lt;trim&amp;gt; version&lt;/p&gt;
&lt;p&gt;仅仅是修改xml文件，其余的都不变&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;update id=&quot;updataEmp&quot;&amp;gt;&lt;span&gt;
       update test
           &lt;/span&gt;&amp;lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&amp;gt;
                &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null&quot;&amp;gt;name=#{name},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
                &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null&quot;&amp;gt;  email=#{email},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
                &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
           &amp;lt;/trim&amp;gt;&lt;span&gt;
       where  id&lt;/span&gt;=&lt;span&gt;#{id}
      &lt;/span&gt;&amp;lt;/update&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4.foreach&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt; A)foreach：&lt;/p&gt;
&lt;p&gt;DynamicSQLMapper.java&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpsByCollection(List&amp;lt;Integer&amp;gt; list);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; DynamicSQL.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- foreach: --&amp;gt;
      &amp;lt;!--      &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpsByCollection(Employee emp); --&amp;gt;
     &amp;lt;select id=&quot;getEmpsByCollection&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; &amp;gt;&lt;span&gt;
           select &lt;/span&gt;*&lt;span&gt; from test where id in(
           &lt;/span&gt;&lt;span&gt;&amp;lt;!-- collection:指定遍历的集合 --&amp;gt;
           &amp;lt;!-- list类型的参数会做特殊的处理封装在map中，map的key叫list --&amp;gt;
           &amp;lt;!-- item:将当前遍历出的元素赋值给指定的变量 --&amp;gt;
           &amp;lt;!-- #{变量名} 就能取出当前遍历的元素 --&amp;gt;
           &amp;lt;!-- separator:每个元素之间的分隔符    此时是in(a,b,c,d)这里面的   ， --&amp;gt;
           &amp;lt;!-- open:遍历出所有结果拼接一个开始的字符 --&amp;gt;
           &amp;lt;!-- close:便利的所有结果拼出结尾 --&amp;gt;
           &amp;lt;!-- index:遍历list是索引，遍历map就是map的key --&amp;gt;&lt;/span&gt;
           &amp;lt;foreach collection=&quot;list&quot; item=&quot;item_id&quot; separator=&quot;,&quot;&amp;gt;&lt;span&gt;
                #{item_id}
           &lt;/span&gt;&amp;lt;/foreach&amp;gt;&lt;span&gt;
           )
     &lt;/span&gt;&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div readability=&quot;35&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpForeach() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps = mapper.getEmpsByCollection(Arrays.asList(5,7,8&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Employee emp : emps){
                     System.out.println(emp);
                }
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 得到结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 19:16:01,838 ==&amp;gt;  Preparing: select * from test where id in( ? , ? , ? )   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 19:16:01,887 ==&amp;gt; Parameters: 5(Integer), 7(Integer), 8(Integer)  (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 19:16:01,909 &amp;lt;==      Total: 3  (BaseJdbcLogger.java:159&lt;span&gt;)
Employee [id&lt;/span&gt;=5, name=MrChengs, gender=boy, email=xxxxxxxx@qq.com, dept=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
Employee [id&lt;/span&gt;=7, name=MrChengs, gender=gril, email=zhangsan@qq.com, dept=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
Employee [id&lt;/span&gt;=8, name=MrChen, gender=gril, email=xxxxxx@xx.xxx, dept=&lt;span&gt;null&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;B.批量保存&lt;/p&gt;
&lt;p&gt;方法1：&lt;/p&gt;
&lt;p&gt;接口类中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量存取&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEmps(@Param(&quot;emps&quot;)List&amp;lt;Employee&amp;gt; employee);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; xml文件：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- &lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量存取--&amp;gt;&lt;/span&gt;
     &amp;lt;!--  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEmps(@Param(&quot;emps&quot;)Employee employee); --&amp;gt;
     &amp;lt;insert id=&quot;addEmps&quot;&amp;gt;&lt;span&gt;
           insert into test(name,gender,email,d_id)
           values
           &lt;/span&gt;&amp;lt;foreach collection=&quot;emps&quot; separator=&quot;,&quot; item=&quot;emp&quot;&amp;gt;
           &lt;span&gt; &amp;lt;!-- 传参数之前是我们new的一个对象，传参数之后是插入数据库的数据 --&amp;gt;&lt;/span&gt;&lt;span&gt;
           (#{emp.name},#{emp.gender},#{emp.email},#{emp.dept.id})
           &lt;/span&gt;&amp;lt;/foreach&amp;gt;
     &amp;lt;/insert&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量存取&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpaddEmps() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; employee = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Employee&amp;gt;&lt;span&gt;();
                employee.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Employee(&quot;Ma&quot;, &quot;gril&quot;, &quot;Ma@Ma&quot;, &lt;span&gt;new&lt;/span&gt; Department(1&lt;span&gt;)));
                employee.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Employee(&quot;Mb&quot;, &quot;boy&quot;, &quot;Mb@Mb&quot;, &lt;span&gt;new&lt;/span&gt; Department(2&lt;span&gt;)));
                mapper.addEmps(employee);
                session.commit();
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时是成功插入数据&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;方法二：&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 方法二 --&amp;gt;
     &amp;lt;!-- 需要加上 --&amp;gt;
    &lt;span&gt; &amp;lt;!-- jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&amp;gt;&lt;/span&gt;
     &amp;lt;insert id=&quot;addEmps&quot;&amp;gt;
           &amp;lt;foreach collection=&quot;emps&quot; separator=&quot;;&quot; item=&quot;emp&quot;&amp;gt;&lt;span&gt;
           insert into test(name,gender,email,d_id)
           values
           (#{emp.name},#{emp.gender},#{emp.email},#{emp.dept.id})
           &lt;/span&gt;&amp;lt;/foreach&amp;gt;
     
     &amp;lt;/insert&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其余不变可以进行测试&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;c.两个重要的参数&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;     &amp;lt;!-- 两个重要的参数 --&amp;gt;&lt;/p&gt;
&lt;p&gt;     &amp;lt;!-- _parameter:代表整个参数，单个参数就是这个参数，多个参数就是封装成的map --&amp;gt;&lt;/p&gt;
&lt;p&gt;     &amp;lt;!-- _databaseId:配置了databaseIdProvider标签，就是代表当前数据库的别名 --&amp;gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;_databaseId：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mybatis-config.xml&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&amp;gt;
           &amp;lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&amp;gt;
           &amp;lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&amp;gt;
     &amp;lt;/databaseIdProvider&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接口类中&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试两个属性&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpselect();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; DynamicMapper.xml&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 两个重要的参数 --&amp;gt;
     &amp;lt;!-- _parameter:代表整个参数，单个参数就是这个参数，多个参数就是封装成的map --&amp;gt;
     &amp;lt;!-- _databaseId:配置了databaseIdProvider标签，就是代表当前数据库的别名 --&amp;gt;
     
     &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; Employee getEmpselect(&lt;span&gt;int&lt;/span&gt; id); --&amp;gt;

    &amp;lt;!-- 修改if中的test条件即可实现不同数据库之间的查询 --&amp;gt;
     &amp;lt;select id=&quot;getEmpselect&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; &lt;span&gt;databaseId=&quot;mysql&quot;&lt;/span&gt;&amp;gt;
           &lt;span&gt;&amp;lt;if test=&quot;_databaseId=='mysql'&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
           &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
           &lt;span&gt;&amp;lt;if test=&quot;_databaseId=='oracle'&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
           &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个重要的参数&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpselect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps=&lt;span&gt; mapper.getEmpselect();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Employee emp : emps){
                     System.out.println();
                }
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 此时可以成功查询数据！！&lt;/p&gt;


&lt;p&gt;&lt;span&gt;_parameter&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;在接口类中：把刚刚测试代码加上id&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试两个属性&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpselect(&lt;span&gt;int&lt;/span&gt; id);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在xnl文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- &lt;span&gt;public&lt;/span&gt; Employee getEmpselect(&lt;span&gt;int&lt;/span&gt; id); --&amp;gt;
     &amp;lt;select id=&quot;getEmpselect&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; databaseId=&quot;mysql&quot;&amp;gt;
           &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;_databaseId=='mysql'&quot;&amp;gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
                &lt;/span&gt;&lt;span&gt;&amp;lt;if test=&quot;_parameter!=null&quot;&amp;gt;
                     where id=#{id}
                &amp;lt;/if&amp;gt;&lt;/span&gt;
           &amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
           &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;_databaseId=='oracle'&quot;&amp;gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
           &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 测试类：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpselect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
               &lt;span&gt; DynamicSQLMapper mapper &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= session.getMapper(DynamicSQLMapper.class);
                List&amp;lt;Employee&amp;gt; emps= mapper.getEmpselect(5&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;此时的查询成功！！！&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;D.bind标签的使用&lt;/p&gt;
&lt;p&gt;接口类中：&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试两个属性
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public List&amp;lt;Employee&amp;gt; getEmpselect();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public List&amp;lt;Employee&amp;gt; getEmpselect(int id);&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpselect(Employee em);
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
xml文件：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;select id=&quot;getEmpselect&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; databaseId=&quot;mysql&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;span&gt;&amp;lt;!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便引用这个变量的值 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          &lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;!-- name ：是我们指定的绑定参数--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;!-- value ：指定参数的值 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;bind name=&quot;_name&quot; value=&quot;'%'+name+'%'&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;if test=&quot;_databaseId=='mysql'&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                select * from test&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;if test=&quot;_parameter!=null&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                     where name like #{_name}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;/if&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;/if&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;if test=&quot;_databaseId=='oracle'&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                select * from test&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;/if&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;/select&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 测试类:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpselect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;List&amp;lt;Employee&amp;gt; emps= mapper.getEmpselect();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;List&amp;lt;Employee&amp;gt; emps= mapper.getEmpselect(5);&lt;/span&gt;
                Employee emp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Employee();
                emp.setName(&lt;/span&gt;&quot;M&quot;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps=&lt;span&gt; mapper.getEmpselect(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E.SQL标签&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;27&quot;&gt; 
&lt;p&gt;     &amp;lt;!-- &amp;lt;include refid=&quot;&quot;&amp;gt;&amp;lt;/include&amp;gt; --&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;!-- SQL:抽取可重用的sql字段，方便后面引用 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;!-- include:就是引用外部标签 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;!--&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;   1.sql抽取：经常要查询的列名，或者插入用的列名抽取出来方便引用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2.include来引用已经抽取的sql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3.include还可以自定义一些property，sql标签内部只能使用自定义的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 include-property:取值正确方式  ${prop}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 #{不可以使用这种方式}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      --&amp;gt;&lt;/p&gt;
&lt;p&gt;     &amp;lt;sql id=&quot;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;!-- 同时这里面还可以使用   if进行判断 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           &amp;lt;if test=&quot;&quot;&amp;gt;&amp;lt;/if&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;/sql&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;










&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 03 Oct 2018 15:46:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>动态SQL 动态SQLMyBatis最强大的特性之一就是它的动态SQL功能。 如果您有任何JDBC或类似框架的经验，那么您就会理解有条件地将SQL字符串连接在一起是多么痛苦，确保不要忘记空格或在列列表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9741325.html</dc:identifier>
</item>
<item>
<title>生成器、迭代器的区别？ - Python有话说</title>
<link>http://www.cnblogs.com/hellohorld/p/9741291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellohorld/p/9741291.html</guid>
<description>&lt;p&gt;&lt;br/&gt;迭代器是一个更抽象的概念，任何对象，如果它的类有 next 方法和 iter 方法返回自己本身，对于 string、list、&lt;br/&gt;dict、tuple 等这类容器对象，使用 for 循环遍历是很方便的。在后台 for 语句对容器对象调用 iter()函数，iter()&lt;br/&gt;是 python 的内置函数。iter()会返回一个定义了 next()方法的迭代器对象，它在容器中逐个访问容器内元素，next()&lt;br/&gt;也是 python 的内置函数。在没有后续元素时，next()会抛出一个 StopIteration 异常。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;生成器（Generator）是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数&lt;br/&gt;据的时候使用 yield 语句。每次 next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置&lt;br/&gt;和所有的数据值）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;区别：生成器能做到迭代器能做的所有事,而且因为自动创建了 iter()和 next()方法,生成器显得特别简洁,而且&lt;br/&gt;生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当&lt;br/&gt;发生器终结时,还会自动抛出 StopIteration 异常。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 15:31:00 +0000</pubDate>
<dc:creator>Python有话说</dc:creator>
<og:description>迭代器是一个更抽象的概念，任何对象，如果它的类有 next 方法和 iter 方法返回自己本身，对于 string、list、dict、tuple 等这类容器对象，使用 for 循环遍历是很方便的。在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellohorld/p/9741291.html</dc:identifier>
</item>
<item>
<title>CDN使用心得：加速双刃剑 - GodBMW</title>
<link>http://www.cnblogs.com/geyouneihan/p/9741021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9741021.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章图片存储在&lt;code&gt;GitHub&lt;/code&gt;，网速不佳的朋友，请看&lt;a href=&quot;https://godbmw.com/passage/60&quot;&gt;《CDN 使用心得：加速双刃剑》&lt;/a&gt; 或者 来我的技术小站 &lt;a href=&quot;https://godbmw.com/&quot;&gt;godbmw.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文以腾讯云平台的 CDN 服务为例，记录下在个人网站开发和公司项目实战中的对 CDN 使用的心得：便宜没好货。&lt;/p&gt;
&lt;h2 id=&quot;什么是-cdn&quot;&gt;1. 什么是 CDN？&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;CDN 的全称是 Content Delivery Network，即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;可以简单理解成：CDN 就是一个能让用户以最快速度访问到相应资源的网盘。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何访问-cdn-资源&quot;&gt;2. 如何访问 CDN 资源？&lt;/h2&gt;
&lt;p&gt;在云平台的控制台开启“对象存储”服务后，开启对应的“加速域名”，此时，针对这个存储桶，就开启了 CDN 加速。&lt;/p&gt;
&lt;p&gt;如下图所示，“加速域名”就是 CDN 域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在存储桶下可以进行各种文件操作，比如我将友链的图片都放在了&lt;code&gt;/friend&lt;/code&gt;文件夹下面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，&lt;code&gt;birdteam.png&lt;/code&gt;的 URL 是：&lt;code&gt;https://blog-1255463368.cos.ap-guangzhou.myqcloud.com/friend/birdteam.png&lt;/code&gt;；CDN 对应的 URL：&lt;code&gt;https://blog-1255463368.file.myqcloud.com/friend/birdteam.png&lt;/code&gt;。&lt;strong&gt;任何资源都可以用文件路径拼接的方式来获得 URL，进而获得资源&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;如何在-spa-应用中使用-cdn&quot;&gt;3. 如何在 SPA 应用中使用 CDN？&lt;/h2&gt;
&lt;p&gt;时下火热的&lt;code&gt;vuejs&lt;/code&gt;,&lt;code&gt;reactjs&lt;/code&gt;等 SPA 框架以及衍生出来的脚手架，均有利用&lt;code&gt;webpack&lt;/code&gt;进行打包操作。&lt;strong&gt;最无脑的操作就是将打包后的文件直接扔到服务器上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后，用户访问网站的时候，从服务器拉取资源，速度慢到另人发指。除此之外，还得考虑做后端缓存，更是出力不讨好:)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，借助 CDN 可以极大缩小用户等待时间，提高访问体验。同时，云平台 CDN 还自带前端缓存，简单方便。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;vue-cli&lt;/code&gt;搭建的&lt;code&gt;vuejs&lt;/code&gt;应用中，可以通过修改&lt;code&gt;/config/index.js&lt;/code&gt;中的配置来更改打包后&lt;code&gt;index.html&lt;/code&gt;文件中资源的地址。如下图所示，更改&lt;code&gt;build.assetsSubDirectory&lt;/code&gt;为存储桶的文件名称，更改 &lt;code&gt;build.assetsPublicPath&lt;/code&gt;为 CDN 的域名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令行执行&lt;code&gt;npm run build&lt;/code&gt;后，打包后的项目文件都放在了&lt;code&gt;/dist/&lt;/code&gt;文件下。根据前面的配置，将&lt;code&gt;/dist/static/&lt;/code&gt;文件夹直接上传到云平台的对应存储桶的跟目录下即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看网站&lt;a href=&quot;https://godbmw.com/&quot;&gt;&lt;code&gt;godbmw.com&lt;/code&gt;&lt;/a&gt;的源码，可以看到资源都是从 CDN 上获取了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/5.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不要乱用第三方-cdn&quot;&gt;4. 不要乱用第三方 CDN&lt;/h2&gt;
&lt;p&gt;在搭建博客之初，因为想节省一些 CDN 资源，所以，一些第三方 JS 库并没有利用&lt;code&gt;npm&lt;/code&gt;来进行管理，而是通过第三方 CDN 来引入的。比如博客下方的播放组件&lt;code&gt;Aplayer&lt;/code&gt;，评论系统&lt;code&gt;Valine&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;这样做的好处就是打包体积小了很多（从&lt;code&gt;800+kb&lt;/code&gt;降低到了&lt;code&gt;500+kb&lt;/code&gt;）。本来以为可以提高用户访问速度，&lt;strong&gt;但事实是：免费的 CDN 是不稳定的。&lt;/strong&gt;&lt;code&gt;Valine&lt;/code&gt;CDN 资源的获取，有时候会阻塞 3s，在网络不稳定的移动端，浏览体验非常差。&lt;/p&gt;
&lt;p&gt;除了速度不稳定，不通过&lt;code&gt;npm&lt;/code&gt;管理的项目难以维护。隔了 2 个月，就忘记用了什么库，只能通过翻代码和查看&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中 CDN 的资源地址来确定。&lt;/p&gt;
&lt;p&gt;因此，尽量在项目中使用&lt;code&gt;npm&lt;/code&gt;安装第三方库，而不是通过第三方平台的 CDN 服务加载对应的库代码。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;5. 写在最后&lt;/h2&gt;
&lt;p&gt;CDN 的理解和应用都非常简单，没什么深度，只是经验之谈（所以文章结构有点散，请谅解）。&lt;/p&gt;
&lt;p&gt;目前，各大平台的 CDN 免费额度对于个人项目甚至是小型商业项目是够用的。例如我的博客打包后才&lt;code&gt;800+kb&lt;/code&gt;，而免费额度是&lt;code&gt;10G/月&lt;/code&gt;，如果能用光免费额度，那么也说明网站可以盈利了。此时，更应该使用 CDN 来提速。这是一个良性循环。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;完&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:59:00 +0000</pubDate>
<dc:creator>GodBMW</dc:creator>
<og:description>文章图片存储在 ，网速不佳的朋友，请看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9741021.html</dc:identifier>
</item>
<item>
<title>python线程池ThreadPoolExecutor与进程池ProcessPoolExecutor - Harvard_Fly</title>
<link>http://www.cnblogs.com/FG123/p/9704233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FG123/p/9704233.html</guid>
<description>&lt;p&gt; &lt;span&gt;python中ThreadPoolExecutor(线程池)与ProcessPoolExecutor(进程池)&lt;/span&gt;&lt;span&gt;都是concurrent.futures模块下的，&lt;/span&gt;&lt;span&gt;主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过submit返回的是一个future对象，它是一个未来可期的对象，通过它可以获悉线程的状态&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ThreadPoolExecutor(线程池)&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;通过submit函数提交执行的函数到线程池中，done()判断线程执行的状态：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建线程池  指定最大容纳数量为4&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过submit提交执行的函数到线程池中&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; task1 = executor.submit(get_thread_time, (1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; task2 = executor.submit(get_thread_time, (2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; task3 = executor.submit(get_thread_time, (3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; task4 = executor.submit(get_thread_time, (4&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1:{} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task1.done()))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task2.done()))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3:{} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task3.done()))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task4.done()))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; time.sleep(2.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;after 3s {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*20&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; done_map =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task1.done(),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task2.done(),
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task3.done(),
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task4.done()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.5秒之后，线程的执行状态&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; task_name,done &lt;span&gt;in&lt;/span&gt;&lt;span&gt; done_map.items():
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; done:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}:completed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(task_name))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;result：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;task1:False 
task2:False
task3:False 
task4:False
after 3s &lt;/span&gt;--------------------&lt;span&gt;
task1:completed
task2:completed&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;初始状态4个task都是未完成状态，2.5秒后task1和task2执行完成，task3和task由于是sleep(3) sleep(4)所以仍然是未完成的sleep状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过wait()判断线程执行的状态：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(fs, timeout=None, return_when=ALL_COMPLETED)，wait接受3个参数，fs表示执行的task序列；timeout表示等待的最长时间，超过这个时间即使线程未执行完成也将返回；return_when表示wait返回结果的条件，默认为ALL_COMPLETED全部执行完成再返回：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    ThreadPoolExecutor, wait
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; start =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; task_list = [executor.submit(get_thread_time, times) &lt;span&gt;for&lt;/span&gt; times &lt;span&gt;in&lt;/span&gt; [1, 2, 3, 4&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; i = 1
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; task_list:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(i, task))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     i += 1
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(wait(task_list, timeout=2.5))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;wait在2.5秒后返回线程的状态，result：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task1:&amp;lt;Future at 0x7ff3c885f208 state=running&amp;gt;&lt;span&gt;
task2:&lt;/span&gt;&amp;lt;Future at 0x7ff3c885fb00 state=running&amp;gt;&lt;span&gt;
task3:&lt;/span&gt;&amp;lt;Future at 0x7ff3c764b2b0 state=running&amp;gt;&lt;span&gt;
task4:&lt;/span&gt;&amp;lt;Future at 0x7ff3c764b9b0 state=running&amp;gt;&lt;span&gt;
DoneAndNotDoneFutures(&lt;br/&gt;done&lt;/span&gt;={&amp;lt;Future at 0x7ff3c885f208 state=finished returned int&amp;gt;, &amp;lt;Future at 0x7ff3c885fb00 state=finished returned int&amp;gt;}, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;not_done={&amp;lt;Future at 0x7ff3c764b2b0 state=running&amp;gt;, &amp;lt;Future at 0x7ff3c764b9b0 state=running&amp;gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到在timeout 2.5时，task1和task2执行完毕，task3和task4仍在执行中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过map返回线程的执行结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; start =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; i = 1
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt; executor.map(get_thread_time,[2,3,1,4&lt;span&gt;]):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(i, result))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     i += 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;map(fn, *iterables, timeout=None)，第一个参数fn是线程执行的函数；第二个参数接受一个可迭代对象；第三个参数timeout跟wait()的timeout一样，但由于map是返回线程执行的结果，如果timeout小于线程执行时间会抛异常TimeoutError。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
    time.sleep(times)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; times


start &lt;/span&gt;=&lt;span&gt; time.time()
executor &lt;/span&gt;= ThreadPoolExecutor(max_workers=4&lt;span&gt;)

i &lt;/span&gt;= 1
&lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt; executor.map(get_thread_time,[2,3,1,4&lt;span&gt;]):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(i, result))
    i &lt;/span&gt;+= 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;map的返回是有序的，它会根据第二个参数的顺序返回执行的结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task1:2&lt;span&gt;
task2:&lt;/span&gt;3&lt;span&gt;
task3:&lt;/span&gt;1&lt;span&gt;
task4:&lt;/span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;as_completed返回线程执行结果：&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; OrderedDict
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    ThreadPoolExecutor, as_completed
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; start =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; task_list = [executor.submit(get_thread_time, times) &lt;span&gt;for&lt;/span&gt; times &lt;span&gt;in&lt;/span&gt; [2, 3, 1, 4&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; task_to_time = OrderedDict(zip([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],[2, 3, 1, 4&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; task_map = OrderedDict(zip(task_list, [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; as_completed(task_list):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     task_name =&lt;span&gt; task_map.get(result)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(task_name,task_to_time.get(task_name)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;task1、task2、task3、task4的等待时间分别为2s、3s、1s、4s，通过as_completed返回执行完的线程结果，as_completed(fs, timeout=None)接受2个参数，第一个是执行的线程列表，第二个参数timeout与map的timeout一样，当timeout小于线程执行时间会抛异常TimeoutError。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task3:1&lt;span&gt;
task1:&lt;/span&gt;2&lt;span&gt;
task2:&lt;/span&gt;3&lt;span&gt;
task4:&lt;/span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过执行结果可以看出，as_completed返回的顺序是线程执行结束的顺序，最先执行结束的线程最早返回。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ProcessPoolExecutor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于频繁的cpu操作，由于GIL锁的原因，多个线程只能用一个cpu，这时多进程的执行效率要比多线程高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程池操作斐波拉切：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 1
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; fib(n - 1) + fib(n - 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; task_list = [executor.submit(fib, n) &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; range(3, 35&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; thread_results = [task.result() &lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; as_completed(task_list)]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(thread_results)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor time is: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(time.time() - start_time))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;result：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[8, 5, 3, 2, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 10946, 46368, 6765, 28657, 17711, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887&lt;span&gt;]
ThreadPoolExecutor time &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;: 4.998981237411499&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;进程池操作斐波拉切：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ProcessPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 1
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; fib(n - 1) + fib(n - 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; executor = ProcessPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; task_list = [executor.submit(fib, n) &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; range(3, 35&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; process_results = [task.result() &lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; as_completed(task_list)]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(process_results)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProcessPoolExecutor time is: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(time.time() - start_time))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;result:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 75025, 28657, 46368, 196418, 121393, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887&lt;span&gt;]
ProcessPoolExecutor time &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;: 3.3585257530212402&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出，对于频繁cpu操作进程是优于线程的，3.3s&amp;lt;4.9s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ProcessPoolExecutor在使用上和ThreadPoolExecutor大致是一样的，它们在futures中的方法也是相同的，但是对于map()方法ProcessPoolExecutor会多一个参数&lt;/span&gt;&lt;span&gt;chunksize(&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor中这个参数没有任何作用&lt;/span&gt;&lt;span&gt;)，&lt;/span&gt;&lt;span&gt;chunksize将迭代对象切成块，将其作为分开的任务提交给pool，对于很大的iterables，设置较大chunksize可以提高性能。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:55:00 +0000</pubDate>
<dc:creator>Harvard_Fly</dc:creator>
<og:description>python中ThreadPoolExecutor(线程池)与ProcessPoolExecutor(进程池)都是concurrent.futures模块下的，主线程(或进程)中可以获取某一个线程(进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FG123/p/9704233.html</dc:identifier>
</item>
<item>
<title>nginx实现反向代理、负载均衡-技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9740406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9740406.html</guid>
<description>&lt;p&gt;本篇博文是《&lt;a id=&quot;post_title_link_9738901&quot; href=&quot;https://www.cnblogs.com/kenken2018/p/9738901.html&quot;&gt;nginx实现动态/静态文件缓存-技术流ken&lt;/a&gt;》的二部曲。将详细介绍nginx如何实现反向代理以及负载均衡技术，并辅以实战案例。&lt;/p&gt;
&lt;p&gt;反向代理--“反向代理(Reverse Proxy)方式是指以&lt;a href=&quot;https://baike.so.com/doc/5335927-5571366.html&quot; target=&quot;_blank&quot;&gt;代理服务器&lt;/a&gt;来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的&lt;a href=&quot;https://baike.so.com/doc/4889711-5107810.html&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，此时代理服务器对外就表现为一个反向代理服务器。”&lt;/p&gt;
&lt;p&gt;负载均衡--“网络专用术语，负载均衡建立在现有网络结构之上，它提供了一种&lt;a href=&quot;https://baike.so.com/doc/6467569.html&quot; target=&quot;_blank&quot;&gt;廉价&lt;/a&gt;有效&lt;a href=&quot;https://baike.so.com/doc/6781847.html&quot; target=&quot;_blank&quot;&gt;透明&lt;/a&gt;的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的&lt;a href=&quot;https://baike.so.com/doc/1281694.html&quot; target=&quot;_blank&quot;&gt;灵活性&lt;/a&gt;和可用性。”&lt;/p&gt;

&lt;h2&gt;1.几个概念&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;反向代理：在收到客户端请求之后，会修目标&lt;/span&gt;IP&lt;span&gt;地址和端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正向代理：在收到客户端请求之后，会修源&lt;/span&gt;IP&lt;span&gt;地址和端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上游服务器：代理服务器后端的哪些真正给客户端提供服务的节点，这样的服务器称之为上游服务器&lt;/p&gt;
&lt;p&gt;下游服务器：客户端就是下游节点&lt;/p&gt;
&lt;h2&gt;2.反向代理指令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;模块：nginx_http_proxy_module
    指令
    proxy_pass：指定上游服务器的ip和端口
    proxy_set_header：指定在重新封装请求报文的时候，添加一个新的首部


    Syntax:     proxy_pass URL;
    Default:     —
    Context:     location, &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; location, limit_except
    例子：proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.220.5.200:80;&lt;/span&gt;
&lt;span&gt;

    Syntax:     proxy_set_header field value;
    Default:     proxy_set_header Host $proxy_host;
    Context:     http, server, location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.反向代理简单示例&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
location /&lt;span&gt; {
        proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.220.5.180;&lt;/span&gt;
        proxy_set_header X-Real-&lt;span&gt;IP $remote_addr  
        proxy_set_header Host $proxy_host;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.反向代理实战案例&lt;/h2&gt;
&lt;h3&gt;1.环境准备&lt;/h3&gt;
&lt;p&gt;centos7.5&lt;/p&gt;
&lt;p&gt;反向代理服务器IP：172.20.10.7/28&lt;/p&gt;
&lt;p&gt;web1服务器IP：172.20.10.8/28&lt;/p&gt;
&lt;p&gt;web2服务器IP:172.20.10.9/28&lt;/p&gt;
&lt;h3&gt;2.配置反向代理服务器端&lt;/h3&gt;
&lt;p&gt;yum安装nignx需要配置网络源，复制下面的代码到你的yum仓库中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[ken]
name&lt;/span&gt;=&lt;span&gt;ken
enabled&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgcheck&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
baseurl&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/epel/7Server/x86_64/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install nginx -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置nginx文件，我们实现这样一个效果，静态文件都被代理到172.20.10.8，动态文件都被调度到172.20.10.9，实现动静分离。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/nginx/&lt;span&gt;nginx.conf
# For more information on configuration, see:
#   &lt;/span&gt;* Official English Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/en/docs/&lt;/span&gt;
#   * Official Russian Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/ru/docs/&lt;/span&gt;
&lt;span&gt;
user nginx;
worker_processes auto;
error_log &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;error.log;
pid &lt;/span&gt;/run/&lt;span&gt;nginx.pid;

# Load &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; modules. See /usr/share/nginx/README.&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;.
include &lt;/span&gt;/usr/share/nginx/modules&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;
       # include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /var/www/html;
        index index.html index.php;
        # Load configuration files for the default server block.
   location / {
        proxy_pass &lt;/span&gt;&lt;span&gt;http://172.20.10.8&lt;/span&gt;&lt;span&gt;;
        proxy_set_header host $proxy_host;
        proxy_set_header realip $remote_addr;
        }
        location ~^/.*(\.php)$ {
        proxy_pass &lt;/span&gt;&lt;span&gt;http://172.20.10.9&lt;/span&gt;&lt;span&gt;;
        proxy_set_header host $proxy_host;
        proxy_set_header realip $remote_addr;
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
}
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行语法检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# nginx -&lt;span&gt;t
nginx: the configuration file &lt;/span&gt;/etc/nginx/nginx.conf syntax &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ok
nginx: configuration file &lt;/span&gt;/etc/nginx/nginx.conf test &lt;span&gt;is&lt;/span&gt; successful
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查没有问题之后进行重启&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl start nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.配置web服务器端&lt;/h2&gt;
&lt;p&gt;安装apache&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install httpd -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;准备测试文件，172.20.10.8准备静态文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is 172.20.10.8 for static test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;/&lt;span&gt;var&lt;/span&gt;/www/html/index.html 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;172.20.10.9需要下载php以便支持动态文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken html]# yum install php -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;172.20.10.9准备动态文件，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# cd /&lt;span&gt;var&lt;/span&gt;/www/html/&lt;span&gt;
[root@ken html]# vim index.php
&lt;/span&gt;&amp;lt;?&lt;span&gt;php
phpinfo();
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.web服务器重启&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken html]# systemctl restart httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.关闭安全服务&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# iptables -F
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.浏览器测试&lt;/h2&gt;
&lt;p&gt;请求静态文件测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003183921585-755015413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;静态文件请求已经成功转发至172.20.10.8。&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;请求动态文件测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003184043666-1960280722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动态文件请求已经成功转发至172.20.10.9.&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;h2&gt;7.补充&lt;/h2&gt;
&lt;h3&gt;补充一&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;补充1：
    location如下
        location &lt;/span&gt;/&lt;span&gt;admin {
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/; &lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com;    &lt;/span&gt;
&lt;span&gt;        }

    请求的url 是http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/admin/a.html&lt;/span&gt;
&lt;span&gt;
    如果代理方式是 proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/; 那么去www.ken.com的跟目录下找a.html,/代表完全代理。&lt;/span&gt;
    如果代理方式是 proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com; 那么去www.ken.com的跟目录下的admin找a.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;补充二&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;补充2：
    如果location中使用了模式匹配（正则），那么，location中的url会直接补充到代理节点的后面.

    此时，上游服务器的的后面不能有任何内容，包括 &lt;/span&gt;/&lt;span&gt;

        location &lt;/span&gt;~&lt;span&gt; \.php$ {
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com; [正则表达式proxy_pass转发的地址后面什么都不能加]       &amp;lt;&amp;lt;&amp;lt; 正确写法&lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com:80;     &amp;lt;&amp;lt;&amp;lt; 正确写法&lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/;       &amp;lt;&amp;lt;&amp;lt; 错误写法&lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/img;    &amp;lt;&amp;lt;&amp;lt; 错误写法&lt;/span&gt;
&lt;span&gt;        }

    此时，如果请求的url是 http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com/book/stu/a.php ，就会代理成 &lt;/span&gt;&lt;span&gt;http://www.ken.com/book/stu/a.php&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;补充三&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;补充3：
    在location中如果有重定向的话，那么就用重定向后的uri替换掉代理节点中的uri
        location &lt;/span&gt;/&lt;span&gt; {
            rewrite &lt;/span&gt;/(.*)$ /index.php?name=$&lt;span&gt;1&lt;/span&gt; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com:80/img;&lt;/span&gt;
&lt;span&gt;        }

    此时，如果请求的url是 http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/bajie ，就会代理成 www.baidu.com/index.php?name=bajie&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.几个概念&lt;/h2&gt;
&lt;p&gt;调度器：分发用户的请求到一个后端节点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上游服务器&lt;/span&gt;(&lt;span&gt;真实服务器&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：每个真正用来处理用户请求的节点都是一个上游服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CIP&lt;span&gt;：客户端的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RIP&lt;span&gt;：真实服务器的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;VIP&lt;span&gt;：虚拟&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;，用户所看到的是也是虚拟&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.指令&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;指令：upstream
    作用：定义一个上游服务器组
    格式
        upstream name ｛
            server  上游服务器1  参数 参数;
            server  上游服务器1  参数 参数;
            server  上游服务器1  参数 参数;
        ｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.重要参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    weight=&lt;span&gt;#：设置服务器的权重（数字越大，权重越高）
    backup: 设置服务器处于备用状态（其他节点出现故障，备用节点才开始工作）
    down：设置让一个节点处于离线状态（经常用在维护一个节点的情况下）
    max_fails&lt;/span&gt;=&lt;span&gt;number：设置连续几次转发失败就认为该节点出现故障，然后就不再向该节点转发用户请求了
    fail_timeout&lt;/span&gt;=time: 和上个参数组合使用，作用是设置等待上游服务器响应超时时间
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.nginx实现负载均衡实战案例&lt;/h2&gt;
&lt;h3&gt;1.环境准备&lt;/h3&gt;
&lt;p&gt;centos7.5&lt;/p&gt;
&lt;p&gt;nginx服务器IP:172.20.10.7/28&lt;/p&gt;
&lt;p&gt;web1服务器端IP：172.20.10.8/28&lt;/p&gt;
&lt;p&gt;web2服务器端IP：172.20.10.9/28&lt;/p&gt;
&lt;h3&gt;2.配置nginx服务器端&lt;/h3&gt;
&lt;p&gt;安装nginx略&lt;/p&gt;
&lt;p&gt;配置nginx文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/nginx/&lt;span&gt;nginx.conf
# For more information on configuration, see:
#   &lt;/span&gt;* Official English Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/en/docs/&lt;/span&gt;
#   * Official Russian Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/ru/docs/&lt;/span&gt;
&lt;span&gt;
user nginx;
worker_processes auto;
error_log &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;error.log;
pid &lt;/span&gt;/run/&lt;span&gt;nginx.pid;

# Load &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; modules. See /usr/share/nginx/README.&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;.
include &lt;/span&gt;/usr/share/nginx/modules&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
 access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;
       # include /etc/nginx/conf.d/*.conf;
    upstream ken {
        server 172.20.10.8 weight=1 max_fails=3 fail_timeout=5;
        server 172.20.10.9 weight=2 max_fails=3 fail_timeout=5;
    }
    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /var/www/html;
  index index.php index.html;

        # Load configuration files for the default server block.
        # include /etc/nginx/default.d/*.conf;

        location / {
        proxy_pass &lt;/span&gt;&lt;span&gt;http://ken/&lt;/span&gt;&lt;span&gt;;
        proxy_set_header host $proxy_host;
        proxy_set_header realip $remote_addr;
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
}
            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# nginx -&lt;span&gt;t
nginx: the configuration file &lt;/span&gt;/etc/nginx/nginx.conf syntax &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ok
nginx: configuration file &lt;/span&gt;/etc/nginx/nginx.conf test &lt;span&gt;is&lt;/span&gt; successful
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.配置web服务器端&lt;/h3&gt;
&lt;p&gt;略.和上面反向代理配置一样。&lt;/p&gt;
&lt;h3&gt;4.浏览器测试&lt;/h3&gt;
&lt;p&gt;输入nginx服务器端的IP地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003214438610-511728507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为172.20.10.9的权重为2，即出现两次172.20.10.9才会出现一次172.20.10.8.进行刷新测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003214624313-2055024697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;nginx的三大功能，缓存，反向代理，负载均衡，已经全部讲解完毕，是否对nginx有了全新的认识那？马上自己动手实验一下吧&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:53:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>1.简介 本篇博文是《nginx实现动态/静态文件缓存-技术流ken》的二部曲。将详细介绍nginx如何实现反向代理以及负载均衡技术，并辅以实战案例。 反向代理--“反向代理(Reverse Prox</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9740406.html</dc:identifier>
</item>
<item>
<title>【持续更新】一个简洁、易用的美赛LaTeX模板:easyMCM - 黑山雁</title>
<link>http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html</guid>
<description>&lt;blockquote readability=&quot;4.6666666666667&quot;&gt;
&lt;p&gt;若您无意阅读下面的这番引入性介绍，想直接下载模板，请点&lt;a href=&quot;http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html#download&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;当前美赛模板通行情况的概述&quot;&gt;1 当前美赛模板通行情况的概述&lt;/h2&gt;
&lt;p&gt;美赛是许多大学生第一次接触&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的机会，但是由于时间安排上的原因，很多人都是在赛前几天匆匆拾起&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;编译器决定用其排版论文。花了一下午安装编译器，又花了一晚上琢磨命令行里弹出来的各种莫名其妙的警告和错误……最终，一些队伍把美赛的时间浪费在对付“难用”的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;系统上，失去了许多宝贵的时间。除此以外，网上流传的各种参差不齐的美赛&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;模板、&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;入门教程，也常常弄得为美赛做准备的初学者们晕头转向，无所适从。&lt;/p&gt;
&lt;p&gt;目前互联网上最通行的美赛&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;模板是&lt;code&gt;mcmthesis&lt;/code&gt;，由&lt;strong&gt;王昭礼&lt;/strong&gt;（&lt;code&gt;343083553@qq.com&lt;/code&gt;）和&lt;strong&gt;黄晨成&lt;/strong&gt;（&lt;code&gt;liamhuang0205+mcmthesis@gmail.com&lt;/code&gt;）先后开发，并上传到&lt;strong&gt;CTAN&lt;/strong&gt;而成为一个标准的宏包/文档类，可直接在&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;中下载使用。这是一个比较专业、精良的模板，结构完整，接口也很完备。作者之一的黄晨成也非常耐心的撰写了一份优质的模板使用指南：&lt;a href=&quot;https://liam0205.me/2016/01/27/how-to-use-mcmthesis/&quot;&gt;如何使用美赛模板 mcmthesis&lt;/a&gt;。但是，该模板对于新手而言还有一定的问题（&lt;em&gt;以下仅仅是我自己的观点，可能有所偏颇&lt;/em&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该宏包已经有三年以上没有更新；最新的发布版本是&lt;code&gt;v6.2&lt;/code&gt;，时间为2016年1月29号。当然，可以说，这几年来美赛组委会要求的摘要页和正文格式都没有太大的调整，但是从&lt;code&gt;mcmthesis&lt;/code&gt;文档类提供的样例文档就可以看出其中有若干多余的成分——标题、作者名、定理证明、代码附录等。这些部分在目前绝大多数的美赛论文中是不需要——甚至是不应该出现的。由此导致的结果是：初学者接触到的&lt;strong&gt;第一份&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;排出来的美赛论文，并不是&lt;strong&gt;标准格式&lt;/strong&gt;的美赛论文。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mcmthesis&lt;/code&gt;文档类提供了完备的接口（&lt;code&gt;setup&lt;/code&gt;命令）来修改具体的参数，例如在该宏包下的控制序列&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\mcmsetup{tcn = 12345, problem = B, titlepage = true, abstract = true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能够将该份论文的队伍控制号设定为&lt;code&gt;12345&lt;/code&gt;、选题设置为&lt;code&gt;B&lt;/code&gt;、标题页单独显示、多显示一次摘要，等等。但是，对于一般的参赛队伍而言，许多接口可能是非必需的，因为似乎目前所有的美赛论文都有着&lt;strong&gt;一致&lt;/strong&gt;的页面设置要求，不太允许个性化的调整。这可能是由于&lt;code&gt;mcmthesis&lt;/code&gt;的作者不太熟悉近几年来的一般美赛论文格式，也有可能是原作者认为应当将宏包的功能设置的更加完备一些。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就我去年以来接触到的一些参赛队伍来看，许多打算使用&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;撰写论文的队伍实际上还没有弄清楚&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;中的一些基本概念。例如，很多队伍可能就不清楚文档类和宏包有何差异，或者以为&lt;code&gt;\maketitle&lt;/code&gt;命令是所有&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;文档中都必须的（但在诸如&lt;code&gt;mcmthesis&lt;/code&gt;这样的模板中，就并不需要这个系统预定的命令，文档中将自动实现标题的显示）。而对于宏包的设计者而言，这些问题显然不在考虑之列——宏包作者已经明确表明，&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的学习需要一定时间，因此“&lt;strong&gt;不推荐&lt;/strong&gt;毫无 LaTeX 使用经验的参赛者使用”。事实上，前面所提到的很多问题，不是由于参赛者“毫无经验”造成的，而是由于他们没能接触到比较好的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;入门教材，因此对于这个工具只是一知半解，遇到问题毫无手段。这个问题，主要是由于国内&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;教材相对“&lt;em&gt;匮乏&lt;/em&gt;”、&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;使用者较少所造成的。这是一个客观存在的问题，短期之内似乎难以解决。美赛的参赛人数还在逐年增加，但似乎无法指望大部分参赛者都能较早的开始学习&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;，并且还能用对教材（以免于片面的理解）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总体而言，我的观点是：由于当前国内的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;&lt;strong&gt;文化&lt;/strong&gt;仍不深厚，导致许多初学者无法以&lt;strong&gt;正确&lt;/strong&gt;的方式入门&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;，由此导致的结果便是参赛者的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;平均水准不够，即使是使用&lt;code&gt;mcmthesis&lt;/code&gt;这样相当完备的宏包仍然感到困难、错误频出（且还不论&lt;code&gt;mcmthesis&lt;/code&gt;宏包在功能上的一些冗余）。这不仅是我去年参赛时的亲身体会，也是我浏览网上各种关于&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;美赛模板使用中之问题时的一个总体观感。至于网上流传的其他各种修改自该宏包的模板，或爱好者自制的模板，就更不值得一提了——至少在最近两年，我没有搜到比较合用的其他模板文件。&lt;/p&gt;
&lt;h2 id=&quot;easymcm宏包说明&quot;&gt;2 easymcm宏包说明&lt;/h2&gt;
&lt;h3 id=&quot;与mcmthesis的关系之说明&quot;&gt;2.1 与mcmthesis的关系之说明&lt;/h3&gt;
&lt;p&gt;我本人是去年国庆期间开始学习&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的。到2018年赛前时，我仍感自己的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;水准不足，为此开始寻找合适的美赛&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;模板。当时我搜到的是&lt;code&gt;mcmthesis&lt;/code&gt;的&lt;code&gt;v5.0&lt;/code&gt;版本，在&lt;a href=&quot;http://www.latexstudio.net/wp-content/uploads/2017/01/mcmthesis-20170116.zip&quot;&gt;LaTeXStudio&lt;/a&gt;网站上（该网站的维护者就是宏包作者之一的王昭礼）。下载下来后，发现其许多设置不完全符合当年组委会的要求，为此做了大量修改，同时也将模板中的&lt;code&gt;mcmthesis.sty&lt;/code&gt;宏包文件进行了细致的检查和修改。最后，我将这个经过修改的文件随手丢在自己的&lt;a href=&quot;https://www.cnblogs.com/xjtu-blacksmith/p/8310107.html&quot;&gt;博客页面&lt;/a&gt;上，起初也并没有预料到会有许多人下载使用。这就是之前那个所谓&lt;code&gt;5.0y&lt;/code&gt;版本的宏包的来历。&lt;/p&gt;
&lt;p&gt;比赛结束几个月后，我才在互联网上搜到&lt;code&gt;mcmthesis&lt;/code&gt;原来是一个已经持续维护到&lt;code&gt;v6.2&lt;/code&gt;版本的文档类，而我下载到和用于改进的那个&lt;code&gt;v5.0&lt;/code&gt;版本只是2013年的一个比较原始的宏包。因此，我的博客上所给出的模板，事实上是从&lt;code&gt;mcmthesis&lt;/code&gt;的老版本上偶然修改出来的一个比较粗糙的宏包文件。&lt;/p&gt;
&lt;h3 id=&quot;easymcm宏包的简介&quot;&gt;2.2 easymcm宏包的简介&lt;/h3&gt;
&lt;p&gt;2019年美赛又即将到来。本人作为一个曾经的美赛参赛者，希望自己博客上所发布的美赛模板能够继续帮助到新一年（乃至以后）的参赛者；为此，重新检查了&lt;code&gt;v5.0y&lt;/code&gt;版本的宏包文件，加以完善和改进，并最终制成了一个新的宏包文件&lt;code&gt;easymcm.sty&lt;/code&gt;（不是文档类）。该宏包相对于前面所介绍的&lt;code&gt;mcmthesis&lt;/code&gt;有以下的独特之处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;easymcm&lt;/code&gt;是由&lt;code&gt;mcmthesis&lt;/code&gt;的老版本直接改进过来的，没有做标准化的处理，总体比较简单——因此，其没有太多的接口，基本功能都已具备，不需要用户做个性化的调整。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;easymcm&lt;/code&gt;经改进后同时支持&lt;code&gt;pdflatex&lt;/code&gt;和&lt;code&gt;xelatex&lt;/code&gt;等多种编译方式。考虑到目前许多参赛队伍仍然习惯于使用&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{C}\TeX\)&lt;/span&gt;套装下的&lt;code&gt;pdfTexify&lt;/code&gt;模式（本质就是&lt;code&gt;pdflatex&lt;/code&gt;）进行编译，这一改进是有一定意义的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;easymcm.sty&lt;/code&gt;文件中有完备详细的中文注释。对于&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;宏包的设计而言，这一做法是不必要的（甚至可能是愚蠢的，因为这显得不专业），但我认为美赛恰是许多大学生学习&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的最佳机会——因此，这一安排使得初学者自己&lt;strong&gt;查看&lt;/strong&gt;和&lt;strong&gt;修改&lt;/strong&gt;宏包内的若干参数成为可能。&lt;/li&gt;
&lt;li&gt;由于作者我本人参加了2018年的美赛，因此可以保证&lt;code&gt;easymcm&lt;/code&gt;宏包提供的页面设计是符合近几年来美赛组委会的规范要求的。同时，我也会持续关注之后几年美赛的情况，及时的改进页面设计以符合组委会的规范。&lt;/li&gt;
&lt;li&gt;宏包文件的结构非常简单，实现的功能也并不繁复，因此容错率较高（&lt;em&gt;经得起各位初学者以乱七八糟的命令来折腾&lt;/em&gt;）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本人制作和改进&lt;code&gt;easymcm&lt;/code&gt;这个美赛模板文件，并无任何功利企图，纯粹是为了分享给需要的人。我的想法仅仅是：目前中文互联网上的相关内容仍显缺乏，倘我的这一点点工作能够起到一定帮助，则其意义便已达成。（&lt;code&gt;mcmthesis&lt;/code&gt;作者之一黄晨成在博客中提到将宏包分享出来提供了一定的成就感，而对于我这个业余的学生而言甚至连这一点也提不上了。我仅认为是举手之劳。）同时，鉴于本模板文件的性质比较特殊（&lt;em&gt;偶然的二次开发&lt;/em&gt;），因此我将和原来一样，仅将这个模板文件扔在网上，供大家自行取用（而没有更多打算）。仅此。&lt;/p&gt;

&lt;h3 id=&quot;美赛模板下载地址&quot;&gt;2.3 美赛模板下载地址&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：发布版中附带有一篇&lt;strong&gt;样例论文&lt;/strong&gt;，是我们队赛前做的2017年MCM的A题论文，排版样式、代码结构仅供参考和学习。（&lt;em&gt;论文内容就别在意了……&lt;/em&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最新版本：&lt;code&gt;v5.01&lt;/code&gt;（2018.10.3发布）&lt;/p&gt;
&lt;p&gt;作者将持续关注比赛动态，若出现问题将及时更新。也欢迎各位读者直接联系我反映问题！&lt;/p&gt;
&lt;h2 id=&quot;常见问题-qa&quot;&gt;3 常见问题 Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;原则上我似乎应该把这些内容集成为一个说明文档，但是由于时间和精力有限，所以暂时无法做到。希望在有余力时可以把这件事情做好。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Q1: 如何将页眉顶部的MCM改成ICM？或者，如何修改\删除顶部的那两句话？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answer: 这两部分内容在&lt;code&gt;easymcm&lt;/code&gt;宏包中分别有两个&lt;strong&gt;简易接口&lt;/strong&gt;来修改：&lt;code&gt;\content&lt;/code&gt;和&lt;code&gt;\notes&lt;/code&gt;。若要将MCM的题头改为ICM的题头，请在主代码文件&lt;code&gt;PAPER.tex&lt;/code&gt;中的导言区（具体是&lt;code&gt;\begin{document}&lt;/code&gt;命令之前）加入以下命令：&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\renewcommand{\contest}{Interdisciplinary Contest in Modeling (ICM) Summary Sheet}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能够将上面的MCM题头改为ICM的题头。类似地，如果需要将其改为其他类似的内容，替换上面的参数即可。下方的括号说明则可由&lt;code&gt;\notes&lt;/code&gt;参数修改，例如在导言区加入命令&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\renewcommand{\notes}{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能够将summary sheet顶部的说明&lt;em&gt;(Attach a copy of this page to each copy of your solution paper.)&lt;/em&gt;去掉。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Q2: 如何缩小summary sheet顶部的空白？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answer: 原来我是建议使用者去把宏包里面的间距参数修改一下。现在，我的建议是：&lt;strong&gt;没必要改，用宏包就不要关注这种细枝末节，内容比格式更重要。&lt;/strong&gt;Summary sheet上的字体大小和行距我都已经设置的很小了，如果还嫌顶部空大，估计是摘要写太多了。自己再删减一下。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Q3: 我在&lt;code&gt;PAPER.tex&lt;/code&gt;文件中应用了&lt;code&gt;geometry&lt;/code&gt;宏包修改页边距，结果页面上的布局出现了混乱。这是怎么一会事？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answer: 因为&lt;code&gt;easymcm&lt;/code&gt;宏包中已经应用&lt;code&gt;geometry&lt;/code&gt;宏包设置过页边距了，再用一次当然会出错。一般情况下，这个参数没有必要再改了，这对论文的评审&lt;strong&gt;没有任何影响&lt;/strong&gt;；实在需要修改，请到&lt;code&gt;easymcm.sty&lt;/code&gt;宏包文件中修改（&lt;em&gt;不推荐&lt;/em&gt;）。其他宏包类似，我个人认为&lt;code&gt;easymcm&lt;/code&gt;中已经集成了绝大多数的基础常用宏包，请使用者不要在源码中再增加宏包了。&lt;/p&gt;
&lt;p&gt;其他问题将陆续更新。最后，祝各位美赛大捷，保M冲O~&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:44:00 +0000</pubDate>
<dc:creator>黑山雁</dc:creator>
<og:description>若您无意阅读下面的这番引入性介绍，想直接下载模板，请点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html</dc:identifier>
</item>
<item>
<title>Java网络编程-URI和URL - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9740425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9740425.html</guid>
<description>&lt;p&gt;前面的一篇文章《Java中的Internet查询》分析完了如何通过IP地址或者主机名确定主机在因特网中的地址。任意给定主机上可能会有任意多个资源，这些资源需要有标识符方便主机之间访问对方的资源，因此这篇文章深入分析一下URL和URI。&lt;/p&gt;

&lt;p&gt;URI全称是Uniform Resource Identifier，也就是统一资源标识符，它是一种采用特定的语法标识一个资源的字符串表示。URI所标识的资源可能是服务器上的一个文件，也可能是一个邮件地址、图书、主机名等。简单记为：URI是标识一个资源的字符串(这里先不必纠结标识的目标资源到底是什么，因为使用者一般不会见到资源的实体)，从服务器接收到的只是资源的一种字节表示(二进制序列，从网络流中读取)。URI的语法构成是：一个模式和一个模式特定部分。表示形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;模式:模式特定部分

scheme:scheme specific part &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：模式特定部分的表示形式取决于所使用的模式&lt;/strong&gt;。URI当前的常用模式包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;data：链接中直接包含经过BASE64编码的数据。&lt;/li&gt;
&lt;li&gt;file：本地磁盘上的文件。&lt;/li&gt;
&lt;li&gt;ftp：FTP服务器。&lt;/li&gt;
&lt;li&gt;http：使用超文本传输协议。&lt;/li&gt;
&lt;li&gt;mailto：电子邮件的地址。&lt;/li&gt;
&lt;li&gt;magnet：可以通过对等网络(端对端P2P，如BitTorrent)下载的资源。&lt;/li&gt;
&lt;li&gt;telnet：基于Telnet的服务的连接。&lt;/li&gt;
&lt;li&gt;urn：统一资源名(Uniform Resource Name)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，Java中还大量使用了一些非标准的定制模式，如rmi、jar、jndi、doc、jdbc等，这些非标准的模式分别用于实现各种不同的用途。&lt;/p&gt;
&lt;p&gt;URI中的模式特定部分没有固定的语法，不过，很多时候都是采用一种层次结构形式，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//授权机构/路径?查询参数

//authority/path?query&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;URI的authority部分指定了负责解析该URI其他部分的授权机构(authority)，很多时候，URI都是使用Internet主机作为授权机构。例如http://www.baidu.com/s?ie=utf-8，授权机构是www.baidu.com(在URL角度来看，主机名是www.baidu.com)。&lt;/p&gt;
&lt;p&gt;URI的路径(path)是授权机构用来确定所标识资源的字符串。不同的授权机构可能会把相同的路径解析后指向不同的资源。其实这一点很明显，试下你写两个不同的项目，主页的路径都是/index.html，它们一定是完全相同的html文档。另外，路径是可以分层的，分层的各个部分使用斜线&quot;/&quot;进行分隔，而&quot;.&quot;和&quot;..&quot;操作符用于在分层层次结构中的导航(后面这两个操作符可能很少见到，了解即可)。&lt;/p&gt;
&lt;h2 id=&quot;uri的语法&quot;&gt;URI的语法&lt;/h2&gt;
&lt;p&gt;URI的模式的组成部分可以是小写字母、数字、加号、点(.)和连号(-)。典型的URI的其他三个部分(模式特定部分，也就是授权机构、路径和查询参数)分别由ASCII字母组成(也就是字母A-Z、a-z和数字0-9)，此外，还可以使用标点符号&lt;code&gt;-、_、.、!和~&lt;/code&gt;，而定界符(如/、?、&amp;amp;和=)有其预定义的用途。所有的其他字符，包括ASCII中拉丁字母，都需要使用百分号(%)转义，转义后的格式是：%+字符按照UTF-8编码再转成16进制的字符串表示。注意一点，如果前面提到的定界符没有作为定界符使用，也需要进行转义。举个简单的例子，如URI中存在中文字符&quot;木&quot;，木字的UTF-8编码为0xE6 0x9C 0xA8，那么它在URI中应该转义为%E6%9C%A8。Jdk中的URLEncoder或者apache-codec中的相关类库提供URI(URL)编码的功能。&lt;/p&gt;
&lt;p&gt;URI中还可以携带用户的口令，因为会有安全漏洞，所以并不常见，这里也不展开分析。&lt;/p&gt;
&lt;h2 id=&quot;uri类&quot;&gt;URI类&lt;/h2&gt;
&lt;p&gt;URI在Java中抽象为java.net.URI类。&lt;/p&gt;
&lt;h3 id=&quot;构造uri实例&quot;&gt;构造URI实例&lt;/h3&gt;
&lt;p&gt;URI实例构造方法有很多个：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public URI(String str) throws URISyntaxException

public URI(String scheme,String userInfo, String host, int port,
        String path, String query, String fragment) throws URISyntaxException

public URI(String scheme, String authority,
       String path, String query, String fragment)throws URISyntaxException

public URI(String scheme, String host, String path, String fragment) throws URISyntaxException

public URI(String scheme, String ssp, String fragment) throws URISyntaxException

//静态工厂方法，最终调用的是URI(String str)
public static URI create(String str)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意的是构造URI实例的时候会检查是否符合URI的语法，否则会抛出URISyntaxException异常。以上的所有方法都是基于URI的模式+模式特定部分或者URI的各个部分构造URI实例，而静态工厂方法&lt;code&gt;public static URI create(String str)&lt;/code&gt;主要是屏蔽了非检查型异常URISyntaxException，转化为检查型异常IllegalArgumentException，这样就不需要显式捕获异常。&lt;/p&gt;
&lt;h3 id=&quot;获取uri的属性&quot;&gt;获取URI的属性&lt;/h3&gt;
&lt;p&gt;前面也提到，URI引用包括最多三个部分：模式、模式特定部分和片段标识符，一般格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;模式:模式特定片段:片段标识符&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于这种语法规范，URI类提供了下面几个方法获取这些属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String getScheme()

public String getRawSchemeSpecificPart()

public String getSchemeSpecificPart()

public String getFragment()

public String getRawFragment()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：之所以没有&lt;code&gt;getRawScheme()&lt;/code&gt;方法，是因为URI规范中强制规定，所有的模式名称必须由URI规范中合法的ASCII字符组成，也就是模式名称中不允许存在百分号转义。上面的&lt;code&gt;getRawSchemeSpecificPart()&lt;/code&gt;是返回原始的模式特定部分，&lt;code&gt;getSchemeSpecificPart()&lt;/code&gt;返回了经过解码(decode)的模式特定部分。同理，&lt;code&gt;getRawFragment()&lt;/code&gt;返回原始的片段标识符，而&lt;code&gt;getFragment()&lt;/code&gt;返回经过解码(decode)的片段标识符。当然，还有其他方法获取URI的基础属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//是否绝对URI
public boolean isAbsolute()

//是否不透明的URI，如果isOpaque()返回true，URI是不透明的
//只能获取到模式、模式特定部分和片段标识符，获取不了host、port等
public boolean isOpaque()

public String getAuthority()

public String getRawAuthority()

public String getRawUserInfo()

public String getUserInfo()

public String getHost()

public int getPort()

public String getRawPath()

public String getPath()

public String getRawQuery()

public String getQuery()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：&lt;code&gt;isOpaque()&lt;/code&gt;方法为true的时候，说明URI是不透明的，不透明的URI无法获取授权机构、路径、端口和查询参数等。另外，上面的获取属性的方法有些方法存在&lt;code&gt;getRawFoo()&lt;/code&gt;的对应方法，这些&lt;code&gt;getRawFoo()&lt;/code&gt;方法就是获取原始属性的值，如果没有&lt;code&gt;Raw&lt;/code&gt;关键字，则返回解码后的字符串值。&lt;/p&gt;
&lt;h3 id=&quot;解析相对uri&quot;&gt;解析相对URI&lt;/h3&gt;
&lt;p&gt;URI中提供了三个方法用于绝对URI和相对URI之间的转换：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public URI resolve(URI uri)

public URI resolve(String str)

public URI relativize(URI uri)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;resolve&lt;/code&gt;方法是基于绝对URI和相对URI把相对URI补全为绝对URI，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception{
    URI absolute = URI.create(&quot;http://localhost:8080/index.html&quot;);
    URI relative = URI.create(&quot;/hello.html&quot;);
    URI resolve = absolute.resolve(relative);
    System.out.println(resolve);
}
//控制台输出
http://localhost:8080/hello.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;relativize&lt;/code&gt;方法是基于绝对URI和相对URI反解出绝对URI中的相对URI部分，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception{
    URI absolute = URI.create(&quot;http://localhost:8080/index.html&quot;);
    URI relative = URI.create(&quot;http://localhost:8080/&quot;);
    URI resolve = relative.relativize(absolute);
    System.out.println(resolve);
}

//控制台输出
index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;uri的比较&quot;&gt;URI的比较&lt;/h3&gt;
&lt;p&gt;URI类实现了Comparable接口，因此URI可以排序。URI的相等性不是基于字符串直接比较，相等的URI在透明性上必须是一致的，例如都是不透明的，其他部分才可以进行比较。URI比较的时候，模式和授权机构是忽略大小写的，其他部分必须区分大小写，用于转义无效字符串的十六进制数字除外。需要转义的字符在转义前和转义之后进行比较，会认为是不同的URI。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//1.
URI uri1 = URI.create(&quot;http://localhost:8000/index.html&quot;);
URI uri2 = URI.create(&quot;http://LOCALHOST:8000/index.html&quot;);
System.out.println(uri1.equals(uri2));
//输出:true

//2.
URI uri3 = URI.create(&quot;http://localhost:8000/index/A&quot;);
URI uri4 = URI.create(&quot;http://LOCALHOST:8000/index/%41&quot;);
System.out.println(uri3.equals(uri4));
//输出:false&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;uri的字符串表示&quot;&gt;URI的字符串表示&lt;/h3&gt;
&lt;p&gt;URI中有两个方法返回其字符串表示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String toString()

public String toASCIIString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt;方法返回未编码的字符串形式，也就是特殊的字符不使用百分号转义，因此这个方法的返回值不能保证符合URI的语法，尽管它的各个部分是遵循URI的语法规范的。&lt;code&gt;toASCIIString()&lt;/code&gt;方法返回经过编码的字符串形式(US-ACSII编码)，也就是特殊的字符一定经过了百分号转义。&lt;code&gt;toString()&lt;/code&gt;存在的意义是提高URI的可读性，&lt;code&gt;toASCIIString()&lt;/code&gt;方法存在的意义是提高URI的可用性。&lt;/p&gt;

&lt;p&gt;URL全称是Uniform Resource Location，也就是统一资源位置。实际上，URL就是一种特殊的URI，它除了标识一个资源，还会为资源提供一个特定的网络位置，客户端可以通过它来获取URL对应的资源。&lt;/p&gt;
&lt;p&gt;URL所表示的网络资源位置通常包括用于访问服务器的协议(如http、ftp等)、服务器的主机名或者IP地址、以及资源文件在该服务器上的路径。典型的URL例如http://localhost/myProject/index.html，它指示本地服务器的myProject目录下有一个名为index.html的文档，这个文档可以通过http协议访问(实际上，URL不一定是指服务器中的真实的物理路径，因为我们一般在服务器中部署应用，如Servlet应用，URL访问的很可能是应用的接口，至于最终映射到什么资源可以由应用自身决定)。&lt;/p&gt;
&lt;h2 id=&quot;url的语法&quot;&gt;URL的语法&lt;/h2&gt;
&lt;p&gt;URL的语法表示形式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protocol://userInfo@host:port/path?query#fragment

协议://用户信息@主机名:端口/路径?查询#片段&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;protocol&lt;/strong&gt;：URL中的协议(protocol)是相应于URI中的模式(schema)的另一个叫法。URL中，协议部分可以是file、ftp、http、https、magnet、telnet或者其他定制协议字符串(但是不包括urn)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;userInfo&lt;/strong&gt;：URL中的用户信息(userInfo)是服务器的登录信息，这部分信息是可选的。如果这部分信息存在，一般会包含一个用户名，极少情况下会包含一个口令。实际上URL携带用户信息是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;port&lt;/strong&gt;：URL中的端口号(port)是指服务器中应用的运行端口，默认端口为80，此部分信息是可选的(也就如果不指定端口号就使用默认端口80)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;path&lt;/strong&gt;：URL中的路径(path)用于表示服务器上的一个特定的目录(其实说一个特定的文件也可以)，这个特定的目录不一定是物理目录，也有可能是逻辑目录。这一点很容易说明，一般不可能把服务器上面的目录直接公开让所有人访问，服务器上面跑的一般是Web(Java的话一般是Servlet)应用，路径指向的实际数据来源甚至很大可能是在其他服务器上的MySQL中的查询结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;query&lt;/strong&gt;：查询参数(query)一般是一个字符串，它表示URL中向服务器提供的附加参数，一般只使用在http协议的URL中，其中包含了表单数据，来源于用户的输入，表示形式是key1=value1&amp;amp;key2=value2&amp;amp;keyn=valuen。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fragment&lt;/strong&gt;：片段(fragment)表示远程服务器资源的某个特定的部分。假如服务器资源是一个HTML文档，此片段标识符将制定为该HTML文档的一个锚(Anchor)。如果远程资源是一个XML文档，那么这个片段标识符是一个XPointer。(如果用Markdown写过博客就知道，添加了导航目录之后，片段就是目录将要导航到的目的章节)&lt;/p&gt;
&lt;h2 id=&quot;相对url&quot;&gt;相对URL&lt;/h2&gt;
&lt;p&gt;URL可以告知浏览器一个文档(Document，假设URL对应服务器上的资源统一叫做文档)的大量信息：获取文档所使用的协议、文档所在的主机、文档在该主机中的路径等。文档中可能也存在引用和当前URL相同的URL，因此，在该文档中使用URL的时候并不要求完整地指定每一个URL，URL可以继承其父文档的协议、主机名和路径。继承了父文档URL的部分信息的这类不完整的URL称为相对URL(Reletive URL)，相反，完整指定所有部分的URL称为绝对URL(Absolute URL)。在相对URL中，缺少的各个部分与请求该文档的URL对应的部分相同。举个例子，我们访问本地服务器的一个HTML文档，URL为http://localhost:8080/myProject/index.html，index.html文档中存在一个超链接&lt;code&gt;&amp;lt;a href=&quot;login.html&quot;&amp;gt;&lt;/code&gt;，当我们点击此超链接的时候，浏览器会从原始URL(http://localhost:8080/myProject/index.html)中截去index.html然后拼接login.html，最后访问http://localhost:8080/myProject/login.html。&lt;/p&gt;
&lt;p&gt;如果相对URL以&quot;/&quot;开头，那么它是相对于文档的根目录，而不是当前的文档。举个例子，我们访问本地服务器的一个HTML文档，URL为http://localhost:8080/myProject/index.html，index.html文档中存在一个超链接&lt;code&gt;&amp;lt;a href=&quot;/login.html&quot;&amp;gt;&lt;/code&gt;，当我们点击此超链接的时候，浏览器会跳转到http://localhost:8080/login.html。&lt;/p&gt;
&lt;p&gt;相对URL有两个显著的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、减少文档编写量，毕竟可以省略一部分URL内容，不过这个不是重要的优点。&lt;/li&gt;
&lt;li&gt;2、重要的优点是：相对URL允许使用多协议来提供一个文档树，例如http和ftp，使用相对URL编写的文档可以从一个网站直接复制或者迁移到另一个网站而不会破坏文档内部URL链接。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;url类&quot;&gt;URL类&lt;/h2&gt;
&lt;p&gt;java.net.URL类(后面直接叫URL)是JDK对URL的统一抽象，它是一个final修饰的类，也就是不允许派生子类。实际上，URL设计的时候采用了策略模式，不同的协议的处理器就是不同的策略，而URL类构成了上下文，通过它决定选用何种策略。URL的核心属性包括协议(或者叫模式)、主机名、端口、查询参数字符串和片段标识符(在JDK中被命名为ref)等，每个属性都可以单独设置。一旦一个URL对象被构造之后，它的所有属性都不能改变，也就是它的实例是线程安全的。&lt;/p&gt;
&lt;h3 id=&quot;构造url实例&quot;&gt;构造URL实例&lt;/h3&gt;
&lt;p&gt;URL实例的主要构造方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//基于URL的各个部分构造URL实例，其中file相当于path、query和fragment三个部分组成
public URL(String protocol, String host, int port, String file) throws MalformedURLException

//基于URL的各个部分构造URL实例，其中file相当于path、query和fragment三个部分组成，使用默认端口80
public URL(String protocol, String host, String file) throws MalformedURLException

//基于URL模式构造URL实例
public URL(String spec) throws MalformedURLException

//基于上下文(父)URL和URL模式构造相对URL实例
public URL(URL context, String spec) throws MalformedURLException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面基于上面几个构造URL实例的方法举几个简单的编码例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//1.
//注意file要带斜杆前缀/
URL url = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, 8080, &quot;/index&quot;);
//输出http://127.0.0.1:8080/index
System.out.println(url.toString());

//2.
URL url = new URL(&quot;http://127.0.0.1:8080/index&quot;);
//输出http://127.0.0.1:8080/index
System.out.println(url.toString());

//3.
URL url = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, &quot;/index&quot;);
//输出http://127.0.0.1/index
System.out.println(url.toString());

//4.
URL context = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, &quot;/index&quot;);
//构造相对URL，保留协议、host、port部分
URL url = new URL(context, &quot;/login&quot;);
//输出http://127.0.0.1/login
System.out.println(url);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面只说到通过URL类去构造对象，其实还有其他方法获取URL实例，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL systemResource = ClassLoader.getSystemResource(String name)

Enumeration&amp;lt;URL&amp;gt; systemResources = ClassLoader.getSystemResources(String name)

URL resource = UrlMain.class.getResource(String name)

URL resource = UrlMain.class.getClassLoader().getResource(String name)

Enumeration&amp;lt;URL&amp;gt; resources = UrlMain.class.getClassLoader().getResources(String name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;ClassLoader.getSystemResource(String name)&lt;/code&gt;和&lt;code&gt;ClassLoader.getSystemResources(String name)&lt;/code&gt;都是先判断是否存在SystemClassLoader，若存在则使用SystemClassLoader加载资源，否则使用BootstrapClassLoader(BootstrapClassPath)进行资源加载，简单来说，这两个方法就是使用系统类加载器加载资源，加载资源时候，从类路径中加载资源，例如使用IDEA，则从编译后的/target目录中加载资源，这一点可以使用&lt;code&gt;ClassLoader.getSystemResource(&quot;&quot;)&lt;/code&gt;进行验证。其他三个方法&lt;code&gt;Class#getResource(String name)&lt;/code&gt;、&lt;code&gt;Class#getClassLoader()#getResource(String name)&lt;/code&gt;和&lt;code&gt;Class#getClassLoader()#getResources(String name)&lt;/code&gt;本质上都是基于AppClassLoader进行资源加载，它们加载资源的时候是从当前的Class所在的类路径(包括类的包路径，如果使用IDEA一般也是/target/类所在的包目录)进行加载，例如有一个类&lt;code&gt;club.throwable.Main.class&lt;/code&gt;，如果目录club.throwable存在一张图片doge.jpg，则加载图片的时候可以这样子&lt;code&gt;club.throwable.Main.class.getResource(&quot;doge.jpg&quot;)&lt;/code&gt;。值得注意的一点是，如果需要加载的资源是在一个特定目录中，那么&lt;code&gt;Class#getResource(String name)&lt;/code&gt;中的name必须以文件路径分隔符开头，例如Window系统中用'/'，其他两个基于通过ClassLoader实例直接加载的不需要使用文件路径分隔符开头，这一点可以看&lt;code&gt;Class#getResource(String name)&lt;/code&gt;方法中的&lt;code&gt;resolveName(name)&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id=&quot;获取url的属性&quot;&gt;获取URL的属性&lt;/h3&gt;
&lt;p&gt;URL实例提供几个方法用于获取数据：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final InputStream openStream() throws java.io.IOException

public URLConnection openConnection() throws java.io.IOException

public URLConnection openConnection(Proxy proxy) throws java.io.IOException

public final Object getContent() throws java.io.IOException

public final Object getContent(Class[] classes) throws java.io.IOException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;InputStream openStream()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openStream()&lt;/code&gt;方法连接到URL所引用的资源，在客户端和服务器之间完成必要的握手之后，返回一个InputStream实例，用于读取网络流数据。此方法返回的InputStream实例读取到的内容是Http请求体的原始报文(如果使用Http协议的话)，因此有可能是一个原始文本片段或者是一个二进制的序列(例如图片)。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) throws Exception{
        URL url = new URL(&quot;https://www.baidu.com&quot;);
        InputStream inputStream = url.openStream();
        int c;
        while ((c= inputStream.read()) != -1){
            System.out.print(c);
        }
        inputStream.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;URLConnection openConnection()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openConnection()&lt;/code&gt;和&lt;code&gt;openConnection(Proxy proxy)&lt;/code&gt;是相似的，只是后者可以使用代理。&lt;code&gt;openConnection()&lt;/code&gt;方法为指定的URL新建一个socket，并且返回一个URLConnection实例，它表示一个网络资源打开的连接，我们可以从这个打开的连接获取一个InputStream实例，用于读取网络流数据。如果上面的过程出现调用失败，会抛出一个IOException。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object getContent()&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Object getContent()&lt;/code&gt;和&lt;code&gt;Object getContent(Class[] classes)&lt;/code&gt;是相似的，后者可以通过Class数组指定获取到的URL中的请求体内容转化为对应的类型的实体。&lt;code&gt;Object getContent()&lt;/code&gt;实际上是调用了URLConnection实例中的getContent方法，一般来说，不建议使用这两个方法，因为转换的逻辑执行后的结果一般是不合符我们预想的结果。&lt;/p&gt;
&lt;h3 id=&quot;获取url属性&quot;&gt;获取URL属性&lt;/h3&gt;
&lt;p&gt;URL的属性获取可以理解为分解URL成URL组成的各个部分，这些部分的信息可以单独获取。前面提到过URL的各个组成部分，这里重复一下，URL分别由下面的几个部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模式(schema)，也称协议(protocol)。&lt;/li&gt;
&lt;li&gt;用户信息(UserInfo)，这个并不常用。&lt;/li&gt;
&lt;li&gt;授权机构，一般是&quot;主机名(Host):port&quot;的格式。&lt;/li&gt;
&lt;li&gt;路径。&lt;/li&gt;
&lt;li&gt;片段标识符，在Java中称为段或者ref。&lt;/li&gt;
&lt;li&gt;查询字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;URL类中提供对应的方法分别是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
//获取模式(协议)
public String getProtocol()

//获取主机名
public String getHost()

//获取授权机构,一般是host:port的形式
public String getAuthority()

//获取端口号port
public int getPort()

//返回协议的默认端口，如http协议的默认端口号为80，如果没有指定协议的默认端口则返回-1
public int getDefaultPort()

//返回URL字符串中从主机名后的第一个斜杆/一直到片段标识符的#字符之前的所有字符
public String getFile()

//返回的值和getFile()相似，但是不包含查询字符串
public String getPath()

//返回URL的片段标识符部分
public String getRef()

//返回URL的查询字符串
public String getQuery()

//返回URL中的用户信息,不常用
public String getUserInfo()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中需要注意的是&lt;code&gt;getFile()&lt;/code&gt;和&lt;code&gt;getPath()&lt;/code&gt;，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL url = new URL(&quot;https://localhost:8080/search?name=doge#anchor-1&quot;);
System.out.println(String.format(&quot;path=%s&quot;, url.getPath()));
System.out.println(String.format(&quot;file=%s&quot;, url.getFile()));
//控制台输出
path=/search
file=/search?name=doge&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;比较&quot;&gt;比较&lt;/h3&gt;
&lt;p&gt;URL实例的比较通常是使用&lt;code&gt;equals()&lt;/code&gt;和&lt;code&gt;hashCode()&lt;/code&gt;方法，当且仅当两个URL指向相同的主机、端口和路径上的资源，并且两者的片段标识符和查询字符串都相同的时候，才会认为两个URL是相等的。&lt;code&gt;equals()&lt;/code&gt;调用的时候会尝试使用DNS解析主机，此方法有可能是一个阻塞的IO操作，会造成比较大的性能消耗，这个时候需要考虑使用缓存，或者把URL转化为URI进行比较。&lt;/p&gt;
&lt;h3 id=&quot;转换&quot;&gt;转换&lt;/h3&gt;
&lt;p&gt;URL类中有三个常用的实例方法用于转换为另一种形式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String toString()

public String toExternalForm()

public URI toURI()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，&lt;code&gt;toString()&lt;/code&gt;最终调用的是&lt;code&gt;toExternalForm()&lt;/code&gt;，而&lt;code&gt;toExternalForm()&lt;/code&gt;方法是使用StringBuilder把URL的各个组成部分拼接，返回的字符串可以方便直接使用在浏览器中。&lt;code&gt;toURI()&lt;/code&gt;方法就是把URL实例转化为URI实例。&lt;/p&gt;

&lt;p&gt;我们在做Web项目或者使用POSTMAN的时候经常会看到x-www-form-urlencoded，它是常用的媒体类型或者说内容类型(ContentType)，使用这种类型的时候，URL中的字符需要进行编码，那么为什么需要进行编码呢?这个是历史遗留原因，因为发明Web或者说Http(s)协议的时候，Unicode编码并未完全普及，URL中使用的字符必须来自ASCII的一个固定子集，这个固定子集是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大写字母A-Z。&lt;/li&gt;
&lt;li&gt;小写字母a-z。&lt;/li&gt;
&lt;li&gt;数字0-9。&lt;/li&gt;
&lt;li&gt;标点符号字符&lt;code&gt;-_.!~*'(和,)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他字符如：&lt;code&gt;/&amp;amp;?@#;$+=%&lt;/code&gt;也可以使用，但是它们限定于使用在特定的用途，如果这些字符串出现在URL路径或者查询字符串，它们以及路径和查询字符串的内容必须进行编码。&lt;/p&gt;
&lt;p&gt;这里有个需要注意的地方：URL编码只针对URL路径和URL路径之后的部分，因为URL规范中规定，路径之前的部分必须满足ASCII固定子集的内容。&lt;/p&gt;
&lt;p&gt;URL编码的方法很简单：除了ASCII数字、字母和部分指定的标点符号之外，所有的其他字符都要转化为字节表示，每个字节要转化为百分号(%)后面加2位十六进制数字。空格是一种特殊的字符，它使用得比较普遍，一般空格可以编码为%20或者加号(+)，但是加号本身的编码为%2B。而&lt;code&gt;/#=&amp;amp;和?&lt;/code&gt;不作为分隔符的时候，必须进行编码。&lt;/p&gt;
&lt;p&gt;解码过程就是上面编码过程的逆向操作，这里不具体展开。&lt;/p&gt;
&lt;p&gt;Java中提供两个类java.net.URLEncoder和java.net.URLDecoder分别用于URL的编码和解码，注意需要使用两个参数的静态方法&lt;code&gt;encode(String value,String charset)&lt;/code&gt;和&lt;code&gt;decode(String value,String charset)&lt;/code&gt;，单参数的方法已经过期，不建议使用。注意在使用java.net.URLEncoder和java.net.URLDecoder的时候，它们的API不会判断URL的什么部分需要编码和解码，什么部分不需要编码和解码，直接整个URL字符串丢进去编码一定会出现意料之外的结果。举个反面列子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String url = &quot;http://localhost:9090/index?name=张大doge&quot;;
String encode = URLEncoder.encode(url, &quot;UTF-8&quot;);
System.out.println(encode);
//输出:http%3A%2F%2Flocalhost%3A9090%2Findex%3Fname%3D%E5%BC%A0%E5%A4%A7doge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，我们只需要对Path和Path之后的字符进行编码和解码，例如对于URL&lt;code&gt;http://localhost:9090/index?name=张大doge&lt;/code&gt;，我们需要编码和解码的部分只有index、name和张大doge这三个部分，其他部分应该保持原样。正确的例子如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    String raw= &quot;http://localhost:9090/index?name=张大doge&quot;;
    String base = raw.substring(raw.lastIndexOf(&quot;//&quot;));
    String pathLeft = base.substring(base.lastIndexOf(&quot;/&quot;) + 1);
    String[] array = pathLeft.split(&quot;\\?&quot;);
    String path = array[0];
    String query = array[1];
    base = raw.substring(0,raw.lastIndexOf(path));
    path = URLEncoder.encode(path, &quot;UTF-8&quot;);
    String[] queryResult = query.split(&quot;=&quot;);
    String queryKey = URLEncoder.encode(queryResult[0], &quot;UTF-8&quot;);
    String queryValue = URLEncoder.encode(queryResult[1], &quot;UTF-8&quot;);
    System.out.println(base + path + &quot;?&quot; + queryKey + &quot;=&quot; + queryValue);
}
//输出结果：http://localhost:9090/index?name=%E5%BC%A0%E5%A4%A7doge
//其中UTF-8编码中张的十六进制表示为E5 BC A0，大的十六进制编码为E5 A4 A7&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;许多系统会通过代理服务器访问Web应用或者其他服务器中的资源，代理服务器接收从本地客户端发出的请求再转发请求到远程服务器，然后远程服务器返回请求的结果到代理服务器，代理服务器接收到结果之后会把结果回传到本地服务器。这样做有两个比较重要的原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、安全原因，防止远端的主机了解关于本地网络配置的细节。&lt;/li&gt;
&lt;li&gt;2、过滤出站请求，限制浏览一些禁用的网站。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Java中除了TCP连接使用传输层的SOCKET代理，其他应用层代理都不支持。Java对于SOCKET没有提供禁用代理的选项，但是可以通过下面三个系统属性配置来开启和限制代理：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;http.proxyHost：代理服务器的主机名，默认不设置此系统属性。
http.proxyPort:代理服务器的端口号，默认不设置此系统属性。
http.noneProxyHosts:不需要代理访问的主机名，多个用竖线|分隔，默认不设置此系统属性。

举个例子：
System.setProperty(&quot;http.proxyHost&quot;, &quot;localhost&quot;);
System.setProperty(&quot;http.proxyPort&quot;, 1080);
System.setProperty(&quot;http.noneProxyHosts&quot;, &quot;www.baidu.com|github.com&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;proxy类&quot;&gt;Proxy类&lt;/h2&gt;
&lt;p&gt;java.net.Proxy类提供了对代理服务器更细粒度的控制，也就是说这个类允许在编程的使用使用不同的远程服务器作为代理服务器，而不是通过系统属性全局配置代理。Proxy目前支持三种代理类型，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Proxy.Type.DIRECT：直连，也就是不使用代理。&lt;/li&gt;
&lt;li&gt;Proxy.Type.HTTP：HTTP代理。&lt;/li&gt;
&lt;li&gt;Proxy.Type.SOCKS：socket的V4或者V5版本的代理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用的时候如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SocketAddress socketAddress = new InetSocketAddress(&quot;localhost&quot;, 80);
Proxy proxy = new Proxy(Proxy.Type.HTTP, socketAddress);
Socket socket = new Socket(proxy);
//...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;proxyselector类&quot;&gt;ProxySelector类&lt;/h3&gt;
&lt;p&gt;每个运行中的Java虚拟机都会存在一个&lt;code&gt;java.net.ProxySelector&lt;/code&gt;实例对象，用来确定不同连接使用的代理服务器。默认的&lt;code&gt;java.net.ProxySelector&lt;/code&gt;的实现是&lt;code&gt;sun.net.spi.DefaultProxySelector&lt;/code&gt;的实例，它会检查各种系统属性和URL的协议，再决定如果连接到不同的远程代理服务器，当然，开发者也可以继承和实现自定义的&lt;code&gt;java.net.ProxySelector&lt;/code&gt;，从而可以根据协议、主机、路径日期等其他标准来选择不同的代理服务器。&lt;code&gt;java.net.ProxySelector&lt;/code&gt;的几个核心的抽象方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//获取默认的ProxySelector实例
public static ProxySelector getDefault()

//设置默认的ProxySelector实例
public static void setDefault(ProxySelector ps)

//通过URI获取可用的代理列表
public abstract List&amp;lt;Proxy&amp;gt; select(URI uri)

//告知ProxySelector不可用的代理和出现的异常
public abstract void connectFailed(URI uri, SocketAddress sa, IOException ioe)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要扩展的话，最好加入缓存的功能，缓存可用的Proxy列表，一旦出现Proxy不可用，通过&lt;code&gt;connectFailed&lt;/code&gt;进行清理和剔除不可用的代理节点即可。&lt;/p&gt;

&lt;p&gt;URL和URI是当前的网络世界或者系统中资源的重要标识符，了解它们的基础知识才能更好地进行网络编程。URI是统一资源标识符，它可以表示任何介质中的资源。而URL是统一资源位置，一般特指因特网中的网络资源位置，使用于Http或者Https协议中。很显然，URI可以表示的范围更大，URI实际上是包含了URL。而两者的区别可以参看上面的几个小节。&lt;/p&gt;
&lt;p&gt;(c-5-d e-20181003)&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 10:51:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 前面的一篇文章《Java中的Internet查询》分析完了如何通过IP地址或者主机名确定主机在因特网中的地址。任意给定主机上可能会有任意多个资源，这些资源需要有标识符方便主机之间访问对方的资源，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9740425.html</dc:identifier>
</item>
<item>
<title>论文笔记：目标检测算法（R-CNN，Fast R-CNN，Faster R-CNN，YOLOv1-v3） - PilgrimHui</title>
<link>http://www.cnblogs.com/liaohuiqiang/p/9740382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaohuiqiang/p/9740382.html</guid>
<description>[unable to retrieve full-text content]介绍几个经典的目标检测算法，R-CNN系列和YOLOv1-v3</description>
<pubDate>Wed, 03 Oct 2018 10:24:00 +0000</pubDate>
<dc:creator>PilgrimHui</dc:creator>
<og:description>介绍几个经典的目标检测算法，R-CNN系列和YOLOv1-v3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaohuiqiang/p/9740382.html</dc:identifier>
</item>
<item>
<title>教你用 jVectorMap 制作属于自己的旅行足迹 - 吴佳轶</title>
<link>http://www.cnblogs.com/hellowujiayi/p/9740293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellowujiayi/p/9740293.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4169639-d077819644f9ae8e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;我的足迹地图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jvectormap&quot;&gt;jVectorMap&lt;/h2&gt;
&lt;p&gt;JVectorMap 是一个优秀的、兼容性强的 jQuery 地图插件。&lt;/p&gt;
&lt;p&gt;它可以工作在包括 IE6 在内的各款浏览器中，矢量图输出，除官方提供各国地图数据外，用户可以使用数据转换程序定制地图数据。例如街道地图、小区地图等等。&lt;/p&gt;
&lt;p&gt;JVectorMap 官方网站提供了很多相关文档和使用示例，感兴趣的小伙伴可以自己研究一下。&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;http://jvectormap.com/&quot; class=&quot;uri&quot;&gt;http://jvectormap.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4169639-092e8986b08fa534.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;jVectorMap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天教大家通过 jVectorMap 制作旅行足迹地图，最终的效果可以查看下面的 Demo 演示（中国），并教大家如何将制作好的足迹地图嵌入到我们自己的博客中。&lt;/p&gt;
&lt;p&gt;Demo : &lt;a href=&quot;http://www.wujiayi.vip/footprint/&quot; class=&quot;uri&quot;&gt;http://www.wujiayi.vip/footprint/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4169639-84e298a6c20e792d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.42412451361868&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;红色框中的文件是必须要引入的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;绿色框中的文件是展示的地图，可自行到官网下载需要的地图 : &lt;a href=&quot;http://jvectormap.com/maps/world/world/&quot; class=&quot;uri&quot;&gt;http://jvectormap.com/maps/world/world/&lt;/a&gt;，拷贝到 js 目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;index.html 中需要添加足迹位置和相关样式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt; 分为三部分介绍：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何更换不同国家地图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何修改地图颜色等相关样式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何添加足迹位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第一部分如何更换不同国家地图&quot;&gt;第一部分：如何更换不同国家地图。&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;!--引入jQuery框架--&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.9.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;!--引入jVectorMap库--&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-jvectormap-1.2.2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;!--引入样式表--&amp;gt;
        &amp;lt;link href=&quot;js/jquery-jvectormap-1.2.2.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&amp;gt;


        &amp;lt;!--引入中国地图数据库--&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-jvectormap-cn-merc-en.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

        &amp;lt;!--引入美国地图数据库--&amp;gt;
        &amp;lt;!--script type=&quot;text/javascript&quot; src=&quot;js/jquery-jvectormap-us-aea.js&quot;&amp;gt;&amp;lt;/script--&amp;gt;
        &amp;lt;!--引入世界地图数据库--&amp;gt;
        &amp;lt;!--script type=&quot;text/javascript&quot; src=&quot;js/jquery-jvectormap-world-mill.js&quot;&amp;gt;&amp;lt;/script--&amp;gt;

    &amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提前下载需要的国家地图，拷贝到 js 目录下。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 标签里引入地图数据： &lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/地图文件名&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ：同时只能有一个地图库，注意不要引入多个地图数据。可以选择注释掉其他的，方便更改。&lt;/p&gt;
&lt;h2 id=&quot;第二部分如何修改地图颜色等相关样式&quot;&gt;第二部分：如何修改地图颜色等相关样式。&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;    &amp;lt;!--background-color: 地图背景颜色--&amp;gt;
    &amp;lt;div id=&quot;map&quot; style=&quot;background-color:#353535&quot;&amp;gt; &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        $('#map').vectorMap({

            // 此处更改地图
            map: 'cn_merc_en',   // 中国地图
            //map: 'us-aea',     // 美国地图
            //map: 'world-mill', // 世界地图


            backgroundColor: 'transparent',
            zoomMin: 0.9, // 鼠标缩放时的最小比例
            zoomMax: 2.4, // 鼠标缩放时的最大比例
            focusOn: {
                x: 0.55,
                y: 2,
                scale: 0.9
            },
            regionStyle: {
                initial: {
                    fill: '#e5e5e5',   // 地图颜色
                    &quot;fill-opacity&quot;: 1, // 省份（州）是否隐藏，鼠标滑动时显示; 1：显示，2：隐藏。
                    stroke: 'none',
                    &quot;stroke-width&quot;: 0,
                    &quot;stroke-opacity&quot;: 1
                },
                hover: {
                    fill: '#ccc',  // 鼠标滑动至某省份的高亮颜色。
                    &quot;fill-opacity&quot;: 0.8
                },
                selected: {
                    fill: 'yellow'
                },
                selectedHover: {}
            },
            markerStyle: {
                initial: {
                    fill: '#fd8888', // 足迹位置的填充颜色
                    stroke: '#fff'   // 足迹位置的描边颜色
                },
                hover: {
                    fill: '#fd2020', // 鼠标滑动至足迹位置后的填充颜色
                    stroke: '#fff',  // 鼠标滑动至足迹位置后的描边颜色
                    &quot;fill-opacity&quot;: 0.8
                },
            },
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参照代码注释修改颜色和相关样式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;千万注意&lt;/strong&gt; ：在更改地图时 &lt;code&gt;map: '地图名称'&lt;/code&gt; ，地图名称是地图数据文件名的后半部分。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;美国地图文件名：jquery-jvectormap-us-aea.js&lt;/p&gt;
&lt;p&gt;那地图的名称是：us-aea&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是要注意把 &lt;code&gt;-&lt;/code&gt; (横杠)更改成 &lt;code&gt;_&lt;/code&gt;（下划线）。 否则不会显示地图。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;第三部分如何添加足迹位置&quot;&gt;第三部分：如何添加足迹位置。&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;    markers: [ // 足迹位置

        // {latLng: [经度（保留两位小数）, 纬度（保留两位小数）], name: '城市名称'},
        // 推荐查询经纬度网站：http://www.gpsspg.com/maps.htm

        {latLng: [39.90, 116.41], name: '北京'},
        {latLng: [31.24, 121.50], name: '上海'},

        {latLng: [46.06, 122.06], name: '内蒙古 - 乌兰浩特'}
    ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;推荐查询经纬度网站：&lt;a href=&quot;http://www.gpsspg.com/maps.htm&quot; class=&quot;uri&quot;&gt;http://www.gpsspg.com/maps.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;{latLng: [经度（保留两位小数）, 纬度（保留两位小数）], name: '城市名称'},&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;如何嵌入式到博客中&quot;&gt;如何嵌入式到博客中&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;iframe style=&quot;max-width: 100%&quot; 
      frameborder=&quot;no&quot; 
      border=&quot;0&quot; 
      marginwidth=&quot;0&quot; 
      marginheight=&quot;0&quot; 
      width=&quot;100%&quot; 
      height=&quot;750px&quot; 
      src=&quot;替换成你的足迹地图链接&quot;&amp;gt;                                        
&amp;lt;/iframe&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把制作好的足迹地图文件放在服务器上，把访问连接放在 &lt;code&gt;src&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;然后将上面的代码复制到你的博客页面上即可。&lt;/p&gt;
&lt;p&gt;可适配手机端和等比例缩放。&lt;/p&gt;
&lt;h2 id=&quot;获取源码&quot;&gt;获取源码&lt;/h2&gt;
&lt;p&gt;GitHub : &lt;a href=&quot;https://github.com/HelloWuJiaYi/jVectorMap-Footprint&quot; class=&quot;uri&quot;&gt;https://github.com/HelloWuJiaYi/jVectorMap-Footprint&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;广告时间&quot;&gt;广告时间&lt;/h2&gt;
&lt;p&gt;欢迎访问我的个人博客:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.wujiayi.vip/&quot; class=&quot;uri&quot;&gt;http://www.wujiayi.vip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的微信公众号：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;吴佳轶同学&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 09:41:00 +0000</pubDate>
<dc:creator>吴佳轶</dc:creator>
<og:description>jVectorMap JVectorMap 是一个优秀的、兼容性强的 jQuery 地图插件。 它可以工作在包括 IE6 在内的各款浏览器中，矢量图输出，除官方提供各国地图数据外，用户可以使用数据转换</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellowujiayi/p/9740293.html</dc:identifier>
</item>
<item>
<title>Swashbuckle.AspNetCore3.0的二次封装与使用 - 易墨</title>
<link>http://www.cnblogs.com/morang/p/9740190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morang/p/9740190.html</guid>
<description>&lt;h2 id=&quot;关于-swashbuckle.aspnetcore3.0&quot;&gt;关于 Swashbuckle.AspNetCore3.0&lt;/h2&gt;
&lt;blockquote readability=&quot;4.8181818181818&quot;&gt;
&lt;p&gt;一个使用 ASP.NET Core 构建的 API 的 Swagger 工具。直接从您的路线，控制器和模型生成漂亮的 API 文档，包括用于探索和测试操作的 UI。&lt;br/&gt;项目主页：&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; class=&quot;uri&quot;&gt;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&lt;/a&gt;&lt;br/&gt;项目官方示例：&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/tree/master/test/WebSites&quot; class=&quot;uri&quot;&gt;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/tree/master/test/WebSites&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前写过一篇&lt;a href=&quot;https://www.cnblogs.com/morang/p/8325729.html&quot;&gt;Swashbuckle.AspNetCore-v1.10 的使用&lt;/a&gt;,现在 &lt;code&gt;Swashbuckle.AspNetCore&lt;/code&gt; 已经升级到 3.0 了，正好开新坑(博客重构)重新封装了下，将所有相关的一些东西抽取到单独的类库中,尽可能的避免和项目耦合，使其能够在其他项目也能够快速使用。&lt;/p&gt;
&lt;h2 id=&quot;运行示例&quot;&gt;运行示例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662652/201810/662652-20181003165553661-1257097179.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;封装代码&quot;&gt;封装代码&lt;/h2&gt;
&lt;p&gt;待博客重构完成再将完整代码开源，参考下面步骤可自行封装&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662652/201810/662652-20181003171716045-1402588702.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建类库并添加引用&quot;&gt;1. 新建类库并添加引用&lt;/h3&gt;
&lt;p&gt;我引用的版本如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Http.Abstractions&quot; Version=&quot;2.1.1&quot; /&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc&quot; Version=&quot;2.1.1&quot; /&amp;gt;
    &amp;lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;3.0.0&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构建参数模型-custsomswaggeroptions.cs&quot;&gt;2. 构建参数模型 CustsomSwaggerOptions.cs&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public class CustsomSwaggerOptions
    {
        /// &amp;lt;summary&amp;gt;
        /// 项目名称
        /// &amp;lt;/summary&amp;gt;
        public string ProjectName { get; set; } = &quot;My API&quot;;
        /// &amp;lt;summary&amp;gt;
        /// 接口文档显示版本
        /// &amp;lt;/summary&amp;gt;
        public string[] ApiVersions { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 接口文档访问路由前缀
        /// &amp;lt;/summary&amp;gt;
        public string RoutePrefix { get; set; } = &quot;swagger&quot;;
        /// &amp;lt;summary&amp;gt;
        /// 使用自定义首页
        /// &amp;lt;/summary&amp;gt;
        public bool UseCustomIndex { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// UseSwagger Hook
        /// &amp;lt;/summary&amp;gt;
        public Action&amp;lt;SwaggerOptions&amp;gt; UseSwaggerAction { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// UseSwaggerUI Hook
        /// &amp;lt;/summary&amp;gt;
        public Action&amp;lt;SwaggerUIOptions&amp;gt; UseSwaggerUIAction { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// AddSwaggerGen Hook
        /// &amp;lt;/summary&amp;gt;
        public Action&amp;lt;SwaggerGenOptions&amp;gt; AddSwaggerGenAction { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;版本控制默认参数接口实现-swaggerdefaultvaluefilter.cs&quot;&gt;3. 版本控制默认参数接口实现 SwaggerDefaultValueFilter.cs&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public class SwaggerDefaultValueFilter : IOperationFilter
    {
        public void Apply(Swashbuckle.AspNetCore.Swagger.Operation operation, OperationFilterContext context)
        {
            // REF: https://github.com/domaindrivendev/Swashbuckle.AspNetCore/issues/412
            // REF: https://github.com/domaindrivendev/Swashbuckle.AspNetCore/pull/413
            foreach (var parameter in operation.Parameters.OfType&amp;lt;NonBodyParameter&amp;gt;())
            {
                var description = context.ApiDescription.ParameterDescriptions.First(p =&amp;gt; p.Name == parameter.Name);

                if (parameter.Description == null)
                {
                    parameter.Description = description.ModelMetadata.Description;
                }

                if (parameter.Default == null)
                {
                    parameter.Default = description.RouteInfo.DefaultValue;
                }
                parameter.Required |= !description.RouteInfo.IsOptional;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;customswaggerservicecollectionextensions.cs&quot;&gt;4. CustomSwaggerServiceCollectionExtensions.cs&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public static class CustomSwaggerServiceCollectionExtensions
    {
        public static IServiceCollection AddCustomSwagger(this IServiceCollection services)
        {
            return AddCustomSwagger(services, new CustsomSwaggerOptions());
        }

        public static IServiceCollection AddCustomSwagger(this IServiceCollection services, CustsomSwaggerOptions options)
        {
            services.AddSwaggerGen(c =&amp;gt;
            {
                if (options.ApiVersions == null) return;
                foreach (var version in options.ApiVersions)
                {
                    c.SwaggerDoc(version, new Info { Title = options.ProjectName, Version = version });
                }
                c.OperationFilter&amp;lt;SwaggerDefaultValueFilter&amp;gt;();
                options.AddSwaggerGenAction?.Invoke(c);

            });
            return services;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;swaggerbuilderextensions.cs&quot;&gt;5. SwaggerBuilderExtensions.cs&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public static class SwaggerBuilderExtensions
    {
        public static IApplicationBuilder UseCustomSwagger(this IApplicationBuilder app)
        {
            return UseCustomSwagger(app, new CustsomSwaggerOptions());
        }
        public static IApplicationBuilder UseCustomSwagger(this IApplicationBuilder app, CustsomSwaggerOptions options)
        {
            app.UseSwagger(opt =&amp;gt;
            {
                if (options.UseSwaggerAction == null) return;
                options.UseSwaggerAction(opt);
            });
            app.UseSwaggerUI(c =&amp;gt;
            {
                if (options.ApiVersions == null) return;
                c.RoutePrefix = options.RoutePrefix;
                c.DocumentTitle = options.ProjectName;
                if (options.UseCustomIndex)
                {
                    c.UseCustomSwaggerIndex();
                }
                foreach (var item in options.ApiVersions)
                {
                    c.SwaggerEndpoint($&quot;/swagger/{item}/swagger.json&quot;, $&quot;{item}&quot;);
                }
                options.UseSwaggerUIAction?.Invoke(c);
            });

            return app;
        }
        /// &amp;lt;summary&amp;gt;
        /// 使用自定义首页
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static void UseCustomSwaggerIndex(this SwaggerUIOptions c)
        {
            var currentAssembly = typeof(CustsomSwaggerOptions).GetTypeInfo().Assembly;
            c.IndexStream = () =&amp;gt; currentAssembly.GetManifestResourceStream($&quot;{currentAssembly.GetName().Name}.index.html&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模型初始化&quot;&gt;6. 模型初始化&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    private CustsomSwaggerOptions CURRENT_SWAGGER_OPTIONS = new CustsomSwaggerOptions()
    {
        ProjectName = &quot;墨玄涯博客接口&quot;,
        ApiVersions = new string[] { &quot;v1&quot;, &quot;v2&quot; },//要显示的版本
        UseCustomIndex = true,
        RoutePrefix = &quot;swagger&quot;,
        AddSwaggerGenAction = c =&amp;gt;
        {
            var filePath = System.IO.Path.Combine(System.AppContext.BaseDirectory, typeof(Program).GetTypeInfo().Assembly.GetName().Name + &quot;.xml&quot;);
            c.IncludeXmlComments(filePath, true);
        },
        UseSwaggerAction = c =&amp;gt;
        {

        },
        UseSwaggerUIAction = c =&amp;gt;
        {

        }
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在-api-项目中使用&quot;&gt;7. 在 api 项目中使用&lt;/h3&gt;
&lt;p&gt;添加对新建类库的引用，并在 webapi 项目中启用版本管理需要为输出项目添加 Nuget 包：&lt;code&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/code&gt;，&lt;code&gt;Microsoft.AspNetCore.Mvc.Versioning.ApiExplorer&lt;/code&gt; (如果需要版本管理则添加)&lt;/p&gt;
&lt;p&gt;我引用的版本如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc.Versioning&quot; Version=&quot;2.3.0&quot; /&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc.Versioning.ApiExplorer&quot; Version=&quot;2.2.0&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Startup.cs 代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        //版本控制
        services.AddMvcCore().AddVersionedApiExplorer(o =&amp;gt; o.GroupNameFormat = &quot;'v'VVV&quot;);
        services.AddApiVersioning(option =&amp;gt;
        {
            // allow a client to call you without specifying an api version
            // since we haven't configured it otherwise, the assumed api version will be 1.0
            option.AssumeDefaultVersionWhenUnspecified = true;
            option.ReportApiVersions = false;
        });
        //custom swagger
        services.AddCustomSwagger(CURRENT_SWAGGER_OPTIONS);
    }

    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, IApiVersionDescriptionProvider provider)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        //custom swagger
        //自动检测存在的版本
        // CURRENT_SWAGGER_OPTIONS.ApiVersions = provider.ApiVersionDescriptions.Select(s =&amp;gt; s.GroupName).ToArray();
        app.UseCustomSwagger(CURRENT_SWAGGER_OPTIONS);
        app.UseMvc();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关键代码拆解&quot;&gt;关键代码拆解&lt;/h2&gt;
&lt;h3 id=&quot;action-方法的-xml-注释&quot;&gt;action 方法的 xml 注释&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;new CustsomSwaggerOptions(){
    AddSwaggerGenAction = c =&amp;gt;
    {
        var filePath = System.IO.Path.Combine(System.AppContext.BaseDirectory, typeof(Program).GetTypeInfo().Assembly.GetName().Name + &quot;.xml&quot;);
        //controller及action注释
        c.IncludeXmlComments(filePath, true);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然还需要生成xml，编辑解决方案添加(或者在vs中项目属性-&amp;gt;生成-&amp;gt;勾选生成xml文档文件)如下配置片段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;PropertyGroup Condition=&quot;'$(Configuration)|$(Platform)'=='Release|AnyCPU'&quot;&amp;gt;
    &amp;lt;DocumentationFile&amp;gt;.\项目名称.xml&amp;lt;/DocumentationFile&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;PropertyGroup Condition=&quot;'$(Configuration)|$(Platform)'=='Debug|AnyCPU'&quot;&amp;gt;
    &amp;lt;DocumentationFile&amp;gt;.\项目名称.xml&amp;lt;/DocumentationFile&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前.net core2.1我这会将此 xml 生成到项目目录，故可能需要将其加入.gitignore中。&lt;/p&gt;
&lt;h3 id=&quot;版本控制&quot;&gt;版本控制&lt;/h3&gt;
&lt;p&gt;添加 Nuget 包：&lt;code&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/code&gt;，&lt;code&gt;Microsoft.AspNetCore.Mvc.Versioning.ApiExplorer&lt;/code&gt;&lt;br/&gt;并在 ConfigureServices 中设置&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    //版本控制
    services.AddMvcCore().AddVersionedApiExplorer(o =&amp;gt; o.GroupNameFormat = &quot;'v'VVV&quot;);
    services.AddApiVersioning(option =&amp;gt;
    {
        // allow a client to call you without specifying an api version
        // since we haven't configured it otherwise, the assumed api version will be 1.0
        option.AssumeDefaultVersionWhenUnspecified = true;
        option.ReportApiVersions = false;
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller 使用&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 测试接口
    /// &amp;lt;/summary&amp;gt;
    [ApiVersion(&quot;1.0&quot;)]
    [Route(&quot;api/v{api-version:apiVersion}/test&quot;)]
    [ApiController]
    public class TestController : ControllerBase
    {
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义主题&quot;&gt;自定义主题&lt;/h3&gt;
&lt;p&gt;将 index.html 修改为内嵌资源就可以使用&lt;code&gt;GetManifestResourceStream&lt;/code&gt;获取文件流,使用此 html，可以自己使用&lt;code&gt;var configObject = JSON.parse('%(ConfigObject)');&lt;/code&gt;获取到 swagger 的配置信息，从而根据此信息去写自己的主题即可。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 使用自定义首页
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static void UseCustomSwaggerIndex(this SwaggerUIOptions c)
    {
        var currentAssembly = typeof(CustsomSwaggerOptions).GetTypeInfo().Assembly;
        c.IndexStream = () =&amp;gt; currentAssembly.GetManifestResourceStream($&quot;{currentAssembly.GetName().Name}.index.html&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若想注入 css，js 则在 UseSwaggerUIAction 委托中调用对应的方法接口，&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore#inject-custom-css&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，目前 swagger-ui 3.19.0 并不支持多语言，不过可以根据需要使用 js 去修改一些东西&lt;br/&gt;比如在 index.html 的 onload 事件中这样去修改头部信息&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;document.getElementsByTagName(
  'span'
)[0].innerText = document
  .getElementsByTagName('span')[0]
  .innerText.replace('swagger', '项目接口文档')
document.getElementsByTagName(
  'span'
)[1].innerText = document
  .getElementsByTagName('span')[1]
  .innerText.replace('Select a spec', '版本选择')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在找汉化解决方案时追踪到 Swashbuckle.AspNetCore3.0 主题时使用的&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/master/src/Swashbuckle.AspNetCore.SwaggerUI/package.json&quot;&gt;swagger-ui 为 3.19.0&lt;/a&gt;，从&lt;a href=&quot;https://github.com/swagger-api/swagger-ui/issues/2488#issuecomment-344077847&quot;&gt;issues2488&lt;/a&gt;了解到目前不支持多语言，其他的问题也可以&lt;a href=&quot;https://github.com/swagger-api/swagger-ui&quot;&gt;查看此仓库&lt;/a&gt;&lt;br/&gt;在使用过程中遇到的问题，基本上 readme 和 issues 都有答案，遇到问题多多阅读即可&lt;/p&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
</description>
<pubDate>Wed, 03 Oct 2018 09:38:00 +0000</pubDate>
<dc:creator>易墨</dc:creator>
<og:description>关于 Swashbuckle.AspNetCore3.0 一个使用 ASP.NET Core 构建的 API 的 Swagger 工具。直接从您的路线，控制器和模型生成漂亮的 API 文档，包括用于探</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morang/p/9740190.html</dc:identifier>
</item>
</channel>
</rss>