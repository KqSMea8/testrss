<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>常见的HTTP状态码 - xflonga</title>
<link>http://www.cnblogs.com/xflonga/p/9368993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xflonga/p/9368993.html</guid>
<description>&lt;p&gt;本内容摘抄自RESTful WebServices 中文译本附录B '42种常见的HTTP响应代码'。&lt;br/&gt;原文作者：Leonard Ricbardson &amp;amp; Sam Ruby&lt;br/&gt;翻译：徐涵、李红军、胡伟&lt;/p&gt;

&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;200(&quot;OK&quot;)&lt;br/&gt;一切正常。实体主体中的文档（若存在的话）是某资源的表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;500(&quot;Bad Request&quot;)&lt;br/&gt;客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;500(&quot;Internal Server Error&quot;)&lt;br/&gt;服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;301(&quot;Moved Permanently&quot;)&lt;br/&gt;当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;404(&quot;Not Found&quot;) 和410(&quot;Gone&quot;)&lt;br/&gt;当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，&lt;br/&gt;但现在已经不存在了的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;409(&quot;Conflict&quot;)&lt;br/&gt;当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SOAP Web服务只使用响应代码200(&quot;OK&quot;)和500(&quot;Internal Server Error&quot;)。无论是你发给SOAP服务器的数据有问题，还是服务器在处理数据的过程中出现问题，&lt;br/&gt;或者SOAP服务器出现内部问题，SOAP服务器均发送500(&quot;Internal Server Error&quot;)。客户端只有查看SOAP文档主体（body）（其中包含错误的描述）才能获知错误原因。&lt;br/&gt;客户端无法仅靠读取响应的前三个字节得知请求成功与否。&lt;/p&gt;

&lt;h2 id=&quot;xx通知&quot;&gt;1XX：通知&lt;/h2&gt;
&lt;p&gt;1XX系列响应代码仅在与HTTP服务器沟通时使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;100(&quot;Continue&quot;)&lt;br/&gt;重要程度：中等，但（写操作时）很少用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是对HTTP LBYL（look-before-you-leap）请求的一个可能的响应。该响应代码表明：客户端应重新发送初始请求，并在请求中附上第一次请求时未提供的&lt;br/&gt;（可能很大或者包含敏感信息的）表示。客户端这次发送的请求不会被拒绝。对LBYL请求的另一个可能的响应是417(&quot;Expectation Failed&quot;)。&lt;/p&gt;
&lt;p&gt;请求报头：要做一个LBYL请求，客户端必须把Expect请求报头设为字符串&quot;100-continue&quot;。除此以外，客户端还需要设置其他一些报头，服务器将根据这些报头决定是响应100还是417。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;101(&quot;Switching Protocols&quot;)&lt;br/&gt;重要程度：非常低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当客户端通过在请求里使用Upgrade报头，以通知服务器它想改用除HTTP协议之外的其他协议时，客户端将获得此响应代码。101响应代码表示“行，我现在改用另一个协议了”。&lt;br/&gt;通常HTTP客户端会在收到服务器发来的101响应后关闭与服务器的TCP连接。101响应代码意味着，该客户端不再是一个HTTP客户端，而将成为另一种客户端。&lt;br/&gt;尽管可以通过Upgrade报头从HTTP切换到HTTPS，或者从HTTP1.1切换到某个未来的版本，但实际使用Upgrade报头的情况比较少。Upgrade报头也可用于HTTP切换到一个完全不同&lt;br/&gt;的协议（如IRC）上，但那需要在Web服务器切换为一个IRC服务器的同时，Web客户端切换为一个IRC的客户端，因为服务器将立刻在同一个TCP连接上开始使用新的协议。&lt;/p&gt;
&lt;p&gt;请求报头：客户端把Upgrade报头设置为一组希望使用的协议。&lt;br/&gt;响应报头：如果服务器同意切换协议，它就返回一个Upgrade报头，说明它将切换到那个协议，并附上一个空白行。服务器不用关闭TCP链接，而是直接在该TCP连接上开始使用新的协议。&lt;/p&gt;
&lt;h2 id=&quot;xx-成功&quot;&gt;2XX: 成功&lt;/h2&gt;
&lt;p&gt;2XX系列响应代码表明操作成功了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;200(&quot;OK&quot;)&lt;br/&gt;重要程度：非常高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，这是客户端希望看到的响应代码。它表示服务器成功执行了客户端所请求的动作，并且在2XX系列里没有其他更适合的响应代码了。&lt;/p&gt;
&lt;p&gt;实体主体：对于GET请求，服务器应返回客户端所请求资源的一个表示。对于其他请求，服务器应返回当前所选资源的一个表示，或者刚刚执行的动作的一个描述。&lt;/p&gt;
&lt;p&gt;-201(&quot;Created&quot;)&lt;br/&gt;重要程度：高。&lt;/p&gt;
&lt;p&gt;当服务器依照客户端的请求创建了一个新资源时，发送此响应代码。&lt;/p&gt;
&lt;p&gt;响应报头：Location报头应包含指向新创建资源的规范URI。&lt;br/&gt;实体主体：应该给出新创建资源的描述与链接。若已经在Location报头里给出了新资源的URI，那么可以用新资源的一个表示作为实体主体。&lt;/p&gt;
&lt;p&gt;-202(&quot;Accepted&quot;)&lt;br/&gt;重要程度：中等。&lt;/p&gt;
&lt;p&gt;客户端的请求无法或将不被实时处理。请求稍后会被处理。请求看上去是合法的，但在实际处理它时有出现问题的可能。&lt;br/&gt;若一个请求触发了一个异步操作，或者一个需要现实世界参与的动作，或者一个需要很长时间才能完成且没必要让Web客户端一直等待的动作时，这个相应代码是一个合适的选择。&lt;/p&gt;
&lt;p&gt;响应报头：应该把未处理完的请求暴露为一个资源，以便客户端稍后查询其状态。Location报头可以包含指向该资源的URI。&lt;br/&gt;实体主体：若无法让客户端稍后查询请求的状态，那么至少应该提供一个关于何时能处理该请求的估计。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;203(&quot;Non-Authoritative Information&quot;)&lt;br/&gt;重要程度：非常低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个响应代码跟200一样，只不过服务器想让客户端知道，有些响应报头并非来自该服务器--他们可能是从客户端先前发送的一个请求里复制的，或者从第三方得到的。&lt;/p&gt;
&lt;p&gt;响应报头：客户端应明白某些报头可能是不准确的，某些响应报头可能不是服务器自己生成的，所以服务器也不知道其含义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;204(&quot;No Content&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。服务器也可以对GET请求返回此响应代码，这表明“客户端请求的资源存在，&lt;br/&gt;但其表示是空的”。注意与304(&quot;Not Modified&quot;)的区别。&lt;br/&gt;204常常用在Ajax应用里。服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素。&lt;/p&gt;
&lt;p&gt;实体主体：不允许。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;205(&quot;Reset Content&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它与204类似，但与204不同的是，它表明客户端应重置数据源的视图或数据结构。假如你在浏览器里提交一个HTML表单，并得到响应代码204，那么表单里的各个字段值不变，&lt;br/&gt;可以继续修改它们；但假如得到的响应代码205，那么表单里的各个字段将被重置为它们的初始值。从数据录入方面讲：204适合对单条记录做一系列编辑，而205适于连续输入一组记录。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;206(&quot;Partial Content&quot;)&lt;br/&gt;重要程度：对于支持部分GET（partial GET）的服务而言“非常高”，其他情况下“低”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它跟200类似，但它用于对部分GET请求（即使用Range请求报头的GET请求）的响应。部分GET请求常用于大型二进制文件的断点续传。&lt;/p&gt;
&lt;p&gt;请求报头：客户端为Range请求报头设置一个值。&lt;br/&gt;响应报头：需要提供Date报头。ETag报头与Content-Location报头的值应该跟正常GET请求相同。&lt;/p&gt;
&lt;p&gt;若实体主体是单个字节范围（byte range），那么HTTP响应里必须包含一个Content-Range报头，以说明本响应返回的是表示的哪个部分，若实体主体是一个多部分实体&lt;br/&gt;（multipart entity）（即该实体主体由多个字节范围构成），那么每一个部分都要有自己的Content-Range报头。&lt;br/&gt;实体主体：不是整个表示，而是一个或者多个字节范围。&lt;/p&gt;
&lt;h2 id=&quot;xx-重定向&quot;&gt;3XX 重定向&lt;/h2&gt;
&lt;p&gt;3XX系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。它们通常用于GET请求。他们通常告诉客户端需要向另一个URI发送GET请求，才能得到所需的表示。&lt;br/&gt;那个URI就包含在Location响应报头里。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;300(&quot;Multiple Choices&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若被请求的资源在服务器端存在多个表示，而服务器不知道客户端想要的是哪一个表示时，发送这个响应代码。或者当客户端没有使用Accept-*报头来指定一个表示，&lt;br/&gt;或者客户端所请求的表示不存在时，也发送这个响应代码。&lt;br/&gt;在这种情况下，一种选择是，服务器返回一个首选表示，并把响应代码设置为200，不过它也可以返回一个包含该资源各个表示的URI列表，并把响应代码设为300。&lt;/p&gt;
&lt;p&gt;响应报头：如果服务器有首选表示，那么它可以在Location响应报头中给出这个首选表示的URI。跟其他3XX响应代码一样，客户端可以自动跟随Location中的URI。&lt;br/&gt;实体主体：一个包含该资源各个表示的URI的列表。可以在表示中提供一些信息，以便用户作出选择。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;301(&quot;Moved Permanently&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务器知道客户端试图访问的是哪个资源，但它不喜欢客户端用当前URI来请求该资源。它希望客户端记住另一个URI，并在今后的请求中使用那个新的URI。&lt;br/&gt;你可以通过这个响应代码来防止由于URI变更而导致老URI失效。&lt;/p&gt;
&lt;p&gt;响应报头：服务器应当把规范URI放在Location响应报头里。&lt;br/&gt;实体主体：服务器可以发送一个包含新URI的信息，不过这不是必需的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;302(&quot;Found&quot;)&lt;br/&gt;重要程度：应该了解，特别市编写客户端时。但我不推荐使用它。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个响应代码市造成大多数重定向方面的混乱的最根本原因。它应该是像307那样被处理。实际上，在HTTP 1.0中，响应代码302的名称是”Moved Temporarily”，&lt;br/&gt;不幸的是，在实际生活中，绝大多数客户端拿它像303一样处理。它的不同之处在于当服务器为客户端的PUT，POST或者DELETE请求返回302响应代码时，客户端要怎么做。&lt;br/&gt;为了消除这一混淆，在HTTP 1.1中，该响应代码被重命名为&quot;Found&quot;，并新加了一个响应代码307。这个响应代码目前仍在广泛使用，但它的含义市混淆的，所以我建议你的&lt;br/&gt;服务发送307或者303，而不要发送302.除非你知道正在与一个不能理解303或307的HTTP 1.0客户端交互。&lt;/p&gt;
&lt;p&gt;响应报头：把客户端应重新请求的那个URI放在Location报头里。&lt;br/&gt;实体主体：一个包含指向新URI的链接的超文本文档（就像301一样）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;303(&quot;See Other&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请求已经被处理，但服务器不是直接返回一个响应文档，而是返回一个响应文档的URI。该响应文档可能是一个静态的状态信息，也可能是一个更有趣的资源。&lt;br/&gt;对于后一种情况，303是一种令服务器可以“发送一个资源的表示，而不强迫客户端下载其所有数据”的方式。客户端可以向Location报头里的URI发送GET请求，但它不是必须这么做。&lt;br/&gt;303响应代码是一种规范化资源URI的好办法。一个资源可以有多个URIs，但每个资源的规范URI只有一个，该资源的所有其他URIs都通过303指向该资源的规范URI，&lt;br/&gt;例如：303可以把一个对http://www.example.com/software/current.tar.gz的请求重定向到http://www.example.com/software/1.0.2.tar.gz。&lt;/p&gt;
&lt;p&gt;响应报头：Location报头里包含资源的URI。&lt;br/&gt;实体主体：一个包含指向新URI的链接的超文本文档。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;304(&quot;Not Modified&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个响应代码跟204(&quot;No Content&quot;)类似：响应实体主体都必须为空。但204用于没有主体数据的情况，而304用于有主体数据，但客户端已拥有该数据，没必要重复发送的情况。&lt;br/&gt;这个响应代码可用于条件HTTP请求（conditional HTTP request).如果客户端在发送GET请求时附上了一个值为Sunday的If-Modified-Since报头，而客户端所请求的表示在服务器端&lt;br/&gt;自星期日（Sunday）以来一直没有改变过，那么服务器可以返回一个304响应。服务器也可以返回一个200响应，但由于客户端已拥有该表示，因此重复发送该表示只会白白浪费宽带。&lt;/p&gt;
&lt;p&gt;响应报头：需要提供Date报头。Etag与Content-Location报头的值，应该跟返回200响应时的一样。&lt;br/&gt;若Expires, Cache-Control及Vary报头的值自上次发送以来已经改变，那么就要提供这些报头。&lt;br/&gt;实体主体：不允许。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;305(&quot;Use Proxy&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个响应代码用于告诉客户端它需要再发一次请求，但这次要通过一个HTTP代理发送，而不是直接发送给服务器。这个响应代码使用的不多，因为服务器很少在意客户端是否使用某一特定代理。&lt;br/&gt;这个代码主要用于基于代理的镜像站点。现在，镜像站点（如http://www.example.com.mysite.com/）包含跟原始站点（如 &lt;a href=&quot;http://www.example.com/%EF%BC%89%E4%B8%80%E6%A0%B7%E7%9A%84%E5%86%85%E5%AE%B9&quot; class=&quot;uri&quot;&gt;http://www.example.com/）一样的内容&lt;/a&gt;，&lt;br/&gt;但具有不同的URI，原始站点可以通过307把客户端重新定向到镜像站点上。&lt;br/&gt;假如有基于代理的镜像站点，那么你可以通过把 &lt;a href=&quot;http://proxy.mysite.com/%E8%AE%BE%E4%B8%BA%E4%BB%A3%E7%90%86%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%B7%9F%E5%8E%9F%E5%A7%8BURI%EF%BC%88http://www.example.com/%EF%BC%89%E4%B8%80%E6%A0%B7%E7%9A%84URI%E6%9D%A5%E8%AE%BF%E9%97%AE%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9&quot; class=&quot;uri&quot;&gt;http://proxy.mysite.com/设为代理，使用跟原始URI（http://www.example.com/）一样的URI来访问镜像站点&lt;/a&gt;。&lt;br/&gt;这里，原始站点example.com可以通过305把客户端路由到一个地理上接近客户端的镜像代理。&lt;br/&gt;web浏览器一般不能正确处理这个响应代码，这是导致305响应代码用的不多的另一个原因。&lt;/p&gt;
&lt;p&gt;响应报头：Location报头里包含代理的URI。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;306 未使用&lt;br/&gt;重要程度：无&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;306 响应代码没有在HTTP标准中定义过。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;307(&quot;Temporary Redirect&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请求还没有被处理，因为所请求的资源不在本地：它在另一个URI处。客户端应该向那个URI重新发送请求。&lt;br/&gt;就GET请求来说，它只是请求得到一个表示，该响应代码跟303没有区别。当服务器希望把客户端重新定向到一个镜像站点时，可以用307来响应GET请求。但对于POST，PUT及DELETE&lt;br/&gt;请求，它们希望服务器执行一些操作，307和303有显著区别。对POST，PUT或者DELETE请求响应303表明：操作已经成功执行，但响应实体将不随本响应一起返回，&lt;br/&gt;若客户端想要获取响应实体主体，它需要向另一个URI发送GET请求。而307表明：服务器尚未执行操作，客户端需要向Location报头里的那个URI重新提交整个请求。&lt;/p&gt;
&lt;p&gt;响应报头： 把客户端应重新请求的那个URI放在Location报头里。&lt;br/&gt;实体主体：一个包含指向新URI的链接的超文本文档。&lt;/p&gt;
&lt;h2 id=&quot;xx客户端错误&quot;&gt;4XX：客户端错误&lt;/h2&gt;
&lt;p&gt;这些响应代码表明客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;400(&quot;Bad Request&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是一个通用的客户端错误状态，当其他4XX响应代码不适用时，就采用400。此响应代码通常用于“服务器收到客户端通过PUT或者POST请求提交的表示，表示的格式正确，但服务器不懂它什么意思”的情况。&lt;/p&gt;
&lt;p&gt;实体主体：可以包含一个错误的描述文档。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;401(&quot;Unauthorized&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。客户端提供了错误的证书，或者根本没有提供证书。这里的证书（credential）可以是一个用户名/密码，&lt;br/&gt;也可以市一个API key，或者一个认证令牌。客户端常常通过向一个URI发送请求，并查看收到401响应，以获知应该发送哪种证书，以及证书的格式。&lt;br/&gt;如果服务器不想让未授权的用户获知某个资源的存在，那么它可以谎报一个404而不是401。这样做的缺点是：客户端需要事先知道服务器接受哪种认证--这将导致HTTP摘要认证无法工作。&lt;/p&gt;
&lt;p&gt;响应报头：WWW-Authenticate报头描述服务器将接受哪种认证。&lt;br/&gt;实体主体：一个错误的描述文档。假如最终用户可通过“在网站上注册”的方式得到证书，那么应提供一个指向该注册页面的链接。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;402(&quot;Payment Required&quot;)&lt;br/&gt;重要程度：无。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了它的名字外，HTTP标准没有对该响应的其他方面作任何定义。因为目前还没有用于HTTP的微支付系统，所以它被留作将来使用。尽管如此，若存在一个用于HTTP的微支付系统，&lt;br/&gt;那么这些系统将首先出现在web服务领域。如果想按请求向用户收费，而且你与用户之间的关系允许这么做的话，那么或许用得上这个响应代码。&lt;br/&gt;注：该书印于2008年&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;403(&quot;Forbidden&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端请求的结构正确，但是服务器不想处理它。这跟证书不正确的情况不同--若证书不正确，应该发送响应代码401。该响应代码常用于一个资源只允许在特定时间段内访问，&lt;br/&gt;或者允许特定IP地址的用户访问的情况。&lt;br/&gt;403暗示了所请求的资源确实存在。跟401一样，若服务器不想透露此信息，它可以谎报一个404。&lt;br/&gt;既然客户端请求的结构正确，那为什么还要把本响应代码放在4XX系列（客户端错误），而不是5XX系列（服务端错误）呢？因为服务器不是根据请求的结构，&lt;br/&gt;而是根据请求的其他方面（比如说发出请求的时间）作出的决定的。&lt;/p&gt;
&lt;p&gt;实体主体：一个描述拒绝原因的文档（可选）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;404(&quot;Not Found&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这也许是最广为人知的HTTP响应代码了。404表明服务器无法把客户端请求的URI转换为一个资源。相比之下，410更有用一些。web服务可以通过404响应告诉客户端所请求的URI&lt;br/&gt;是空的，然后客户端就可以通过向该URI发送PUT请求来创建一个新资源了。但是404也有可能是用来掩饰403或者401.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;405(&quot;Method Not Allowd&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端试图使用一个本资源不支持的HTTP方法。例如：一个资源只支持GET方法，但是客户端使用PUT方法访问。&lt;/p&gt;
&lt;p&gt;响应报头：Allow报头列出本资源支持哪些HTTP方法，例如：Allow：GET，POST&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;406(&quot;Not Acceptable&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当客户端对表示有太多要求，以至于服务器无法提供满足要求的表示，服务器可以发送这个响应代码。例如：客户端通过Accept头指定媒体类型为application/json+hic，&lt;br/&gt;但是服务器只支持application/json。服务器的另一个选择是：忽略客户端挑剔的要求，返回首选表示，并把响应代码设为200。&lt;/p&gt;
&lt;p&gt;实体主体：一个可选表示的链接列表。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;407(&quot;Proxy Authentication Required&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有HTTP代理会发送这个响应代码。它跟401类似，唯一区别在于：这里不是无权访问web服务，而是无权访问代理。跟401一样，可能是因为客户端没有提供证书，&lt;br/&gt;也可能是客户端提供的证书不正确或不充分。&lt;/p&gt;
&lt;p&gt;请求报头：客户端通过使用Proxy-Authorization报头（而不是Authorization）把证书提供给代理。格式跟Authrization一样。&lt;br/&gt;响应报头：代理通过Proxy-Authenticate报头（而不是WWW-Authenticate）告诉客户端它接受哪种认证。格式跟WWW-Authenticate一样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;408(&quot;Reqeust Timeout&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假如HTTP客户端与服务器建立链接后，却不发送任何请求（或从不发送表明请求结束的空白行），那么服务器最终应该发送一个408响应代码，并关闭此连接。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;409(&quot;Conflict&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此响应代码表明：你请求的操作会导致服务器的资源处于一种不可能或不一致的状态。例如你试图修改某个用户的用户名，而修改后的用户名与其他存在的用户名冲突了。&lt;/p&gt;
&lt;p&gt;响应报头：若冲突是因为某个其他资源的存在而引起的，那么应该在Location报头里给出那个资源的URI。&lt;br/&gt;实体主体：一个描述冲突的文档，以便客户端可以解决冲突。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;410(&quot;Gone&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个响应代码跟404类似，但它提供的有用信息更多一些。这个响应代码用于服务器知道被请求的URI过去曾指向一个资源，但该资源现在不存在了的情况。服务器不知道&lt;br/&gt;该资源的新URI，服务器要是知道该URI的话，它就发送响应代码301.&lt;br/&gt;410和310一样，都有暗示客户端不应该再请求该URI的意思，不同之处在于：410只是指出该资源不存在，但没有给出该资源的新URI。RFC2616建议“为短期的推广服务，&lt;br/&gt;以及属于个人但不继续在服务端运行的资源”采用410.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;411(&quot;Length Required&quot;)&lt;br/&gt;重要程度：低到中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若HTTP请求包含表示，它应该把Content-Length请求报头的值设为该表示的长度（以字节为单位）。对客户端而言，有时这不太方便（例如，当表示是来自其他来源的字节流时）。&lt;br/&gt;所以HTTP并不要求客户端在每个请求中都提供Content-Length报头。但HTTP服务器可以要求客户端必须设置该报头。服务器可以中断任何没有提供Content-Length报头的请求，&lt;br/&gt;并要求客户端重新提交包含Content-Length报头的请求。这个响应代码就是用于中断未提供Content-Lenght报头的请求的。&lt;br/&gt;假如客户端提供错误的长度，或发送超过长度的表示，服务器可以中断请求并关闭链接，并返回响应代码413。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;412(&quot;Precondition Failed&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端在请求报头里指定一些前提条件，并要求服务器只有在满足一定条件的情况下才能处理本请求。若服务器不满足这些条件，就返回此响应代码。&lt;br/&gt;If-Unmodified-Since是一个常见的前提条件。客户端可以通过PUT请求来修改一个资源，但它要求，仅在自客户端最后一次获取该资源后该资源未被别人修改过才能执行修改操作。&lt;br/&gt;若没有这一前提条件，客户端可能会无意识地覆盖别人做的修改，或者导致409的产生。&lt;/p&gt;
&lt;p&gt;请求报头：若客户但设置了If-Match，If-None-Match或If-Unmodified-Since报头，那就有可能得到这个响应代码。&lt;br/&gt;If-None-Match稍微特别一些。若客户端在发送GET或HEAD请求时指定了If-None-Match，并且服务器不满足该前提条件的话，那么响应代码不是412而是304，这是实现条件HTTP GET的基础。&lt;br/&gt;若客户端在发送PUT，POST或DELETE请求时指定了If-None-Match,并且服务器不满足该前提条件的话，那么响应代码是412.另外，若客户端指定了If-Match或If-Unmodified-Since(&lt;br/&gt;无论采用什么HTTP方法)，而服务器不满足该前提条件的话，响应代码也是412。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;413(&quot;Request Entity Too Large&quot;)&lt;br/&gt;重要程度：低到中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个响应代码跟411类似，服务器可以用它来中断客户端的请求并关闭连接，而不需要等待请求完成。411用于客户端未指定长度的情况，而413用于客户端发送的表示太大，以至于服务器无法处理。&lt;br/&gt;客户端可以先做一个LBYL（look-before-you-leap）请求，以免请求被413中断。若LBYL请求获得响应代码为100，客户端再提交完整的表示。&lt;/p&gt;
&lt;p&gt;响应报头：如果因为服务器方面临时遇到问题（比如资源不足），而不是因为客户端方面的问题而导致中断请求的话，服务器可以把Retry-After报头的值设为一个日期或一个间隔时间，&lt;br/&gt;以秒为单位，以便客户端可以过段时间重试。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;414(&quot;Request-URI Too Long&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HTTP标准并没有对URI长度作出官方限制，但大部分现有的web服务器都对URI长度有一个上限，而web服务可能也一样。导致URI超长的最常见的原因是：表示数据明明是该放在实体主体&lt;br/&gt;里的，但客户端却把它放在了URI里。深度嵌套的数据结构也有可能引起URI过长。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;415(&quot;Unsupported Media Type&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当客户端在发送表示时采用了一种服务器无法理解的媒体类型，服务器发送此响应代码。比如说，服务器期望的是XML格式，而客户端发送的确实JSON格式。&lt;br/&gt;如果客户端采用的媒体类型正确，但格式有问题，这时最好返回更通用的400。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;416(&quot;Requestd Range Not Satisfiable&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当客户端所请求的字节范围超出表示的实际大小时，服务器发送此响应代码。例如：你请求一个表示的1-100字节，但该表示总共只用99字节大小。&lt;/p&gt;
&lt;p&gt;请求报头：仅当原始请求里包含Range报头时，才有可能收到此响应代码。若原始请求提供的是If-Range报头，则不会收到此响应代码。&lt;br/&gt;响应报头：服务器应当通过Content-Range报头告诉客户端表示的实际大小。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;417(&quot;Expectation Failed&quot;)&lt;br/&gt;重要程度：中等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此响应代码跟100正好相反。当你用LBYL请求来考察服务器是否会接受你的表示时，如果服务器确认会接受你的表示，那么你将获得响应代码100，否则你将获得417。&lt;/p&gt;
&lt;h2 id=&quot;xx-服务端错误&quot;&gt;5XX 服务端错误&lt;/h2&gt;
&lt;p&gt;这些响应代码表明服务器端出现错误。一般来说，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。有时，服务器能够估计客户端应在多久之后重试。&lt;br/&gt;并把该信息放在Retry-After响应报头里。&lt;/p&gt;
&lt;p&gt;5XX系列响应代码在数量上不如4XX系列多，这不是因为服务器错误的几率小，而是因为没有必要如此详细--对于服务器方面的问题，客户端是无能为力的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;500(&quot;Internal Server Error&quot;)&lt;br/&gt;重要程度：高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是一个通用的服务器错误响应。对于大多数web框架，如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;501(&quot;Not Implemented&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端试图使用一个服务器不支持的HTTP特性。&lt;br/&gt;最常见的例子是：客户端试图做一个采用了拓展HTTP方法的请求，而普通web服务器不支持此请求。它跟响应代码405比较相似，405表明客户端所用的方法是一个可识别的方法，&lt;br/&gt;但该资源不支持，而501表明服务器根本不能识别该方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;502(&quot;Bad Gateway&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。&lt;br/&gt;若代理根本无法访问上行服务器，响应代码将是504。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;503(&quot;Service Unavailable&quot;)&lt;br/&gt;重要程度：中等到高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此响应代码表明HTTP服务器正常，只是下层web服务服务不能正常工作。最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理。&lt;br/&gt;由于此问题多半由客户端反复发送请求造成，因此HTTP服务器可以选择拒绝接受客户端请求而不是接受它，并发送503响应代码。&lt;/p&gt;
&lt;p&gt;响应报头：服务器可以通过Retry-After报头告知客户端何时可以重试。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;504(&quot;Gateway Timeout&quot;)&lt;br/&gt;重要程度：低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;跟502类似，只有HTTP代理会发送此响应代码。此响应代码表明代理无法连接上行服务器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;505(&quot;HTTP Version Not Supported&quot;)&lt;br/&gt;重要程度： 非常低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当服务器不支持客户端试图使用的HTTP版本时发送此响应代码。&lt;/p&gt;
&lt;p&gt;实体主体：一个描述服务器支持哪些协议的文档。&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 15:29:00 +0000</pubDate>
<dc:creator>xflonga</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xflonga/p/9368993.html</dc:identifier>
</item>
<item>
<title>JXl常用解析详解 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9368700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9368700.html</guid>
<description>&lt;h2&gt;目的：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;java解析 excel 无非就是apache poi 或者 jxl 两者在使用上其实都差不多，关键还是看你自己熟悉那个，用那个！我也是初次接触jxl 看很多博客说 jxl只适用于处理小数据量 excel，或者说是功能比较单一的，实际上我看了jxl的包，发现其实用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，功能还是很强大的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要了解：支持 Reads data from Excel 95, 97, 2000, &lt;span&gt;XP, and 2003&lt;/span&gt; workbooks&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;title-article&quot;&gt;&lt;span&gt;jxl.read.biff.BiffException: Unable to recognize OLE stream  出现这个错误就是excel 2007格式不符合引起的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;官网：http://jexcelapi.sourceforge.net/&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;java doc： http://jxl.sourceforge.net/javadoc/index.html&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;依赖管理：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.sourceforge.jexcelapi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jxl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.6.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;UML大纲：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725212957777-1356266150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;创建简单的excel：&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCreateExcel() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建xls文件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            file.createNewFile();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2:创建工作簿&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             WritableWorkbook workbook =&lt;span&gt; Workbook.createWorkbook(file);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3:创建sheet,设置第二三四..个sheet，依次类推即可&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             WritableSheet sheet = workbook.createSheet(&quot;测试&quot;, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4：设置titles&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             String[] titles = { &quot;编号&quot;, &quot;账号&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5:给第一行设置列名&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; titles.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 sheet.addCell(&lt;span&gt;new&lt;/span&gt; Label(i, 0&lt;span&gt;, titles[i]));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             sheet.setHeader(&quot;aa&quot;, &quot;cc&quot;, &quot;cc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6：模拟数据库导入数据 注意起始行为1&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; 100; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加编号&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 sheet.addCell(&lt;span&gt;new&lt;/span&gt; Label(0, i, &lt;span&gt;new&lt;/span&gt; String(&quot;编号&quot;+&lt;span&gt;i)));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加密码&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 sheet.addCell(&lt;span&gt;new&lt;/span&gt; Label(1, i, &lt;span&gt;new&lt;/span&gt; String(&quot;编号&quot;+&lt;span&gt;i)));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            workbook.write();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            workbook.close();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RowsExceededException e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (WriteException e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 效果：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725214909558-409499633.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h2&gt;简单读取Excel：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCreateExcel() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1:创建workbook&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             Workbook workbook =&lt;span&gt; Workbook.getWorkbook(file);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2:获取第一个工作表sheet&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             Sheet sheet = workbook.getSheet(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3:读取数据&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            System.out.println(sheet.getColumns());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            System.out.println(sheet.getRows());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.自己注意行列关系&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; sheet.getRows(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; sheet.getColumns(); j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     Cell cell =&lt;span&gt; sheet.getCell(j, i);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    System.out.println(cell.getContents());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (BiffException |&lt;span&gt; IOException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725220429111-1280536109.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 25 Jul 2018 14:22:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9368700.html</dc:identifier>
</item>
<item>
<title>基于webpack4搭建一个react脚手架 - Dante丶</title>
<link>http://www.cnblogs.com/DDante/p/9368694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DDante/p/9368694.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;React 16.0 boilerplate with react-router-dom, redux &amp;amp; webpack 4. (for javascript)&lt;br/&gt;&lt;a href=&quot;https://github.com/Dante-dan/react-sample-javascript&quot;&gt;github项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目初始化&quot;&gt;项目初始化&lt;/h2&gt;
&lt;h3 id=&quot;统一规范代码格式&quot;&gt;统一规范代码格式&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;配置 &lt;code&gt;.editorconfig&lt;/code&gt; 使得IDE的方式统一 (见代码)&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置 &lt;code&gt;.eslintrc.js&lt;/code&gt; 使得代码规范统一 (见代码)&lt;/p&gt;
&lt;h3 id=&quot;预期功能&quot;&gt;预期功能&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;管理资源： 能加载css、sccc、less、以及静态文件&lt;/li&gt;
&lt;li&gt;管理输出：将打包后的静态文件输出至static目录下，以各自的文件类型管理&lt;/li&gt;
&lt;li&gt;dev：使用source map，方便调试时代码定位&lt;/li&gt;
&lt;li&gt;dev：配置devServer，并配置热替换，热加载，自动刷新，自动打开浏览器，并预留proxyTable&lt;/li&gt;
&lt;li&gt;dev：设置默认打开8080，被占用则寻找下一个空接口&lt;/li&gt;
&lt;li&gt;production：代码分离，打包css文件，css代码压缩，js代码压缩，输出到模板html，配置gzip&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;analysis:：使用BundleAnalyzerPlugin 分析打包后的性能&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;首先使用npm init 初始化一个包含package.json的根目录&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;:.
│  .babelrc             #babel的规则以及插件
│  .editorconfig        #IDE/编辑器相关的配置
│  .eslintignore        #Eslint忽视的目录
│  .eslintrc.js         #Eslint的规则和插件
│  .gitignore           #Git忽视的目录
│  .postcssrc.js        #postcss的插件
│  package-lock.json
│  package.json         #项目相关的包
│  README.md
│  yarn.lock
│
├─build                 #webpack相关的配置
│      utils.js         #webpack配置中的通用方法
│      webpack.base.conf.js #webpack的基础配置
│      webpack.dev.conf.js  #webpack的开发环境配置
│      webpack.prod.conf.js #webpack的生产环境配置
│
└─src                   #主目录，业务代码
    │  app.css
    │  App.js
    │  favicon.ico
    │  index.ejs
    │  index.js
    │
    └─assets            #静态目录，存放静态资源
        │  config.json
        │
        └─img
                logo.svg&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;eslint-loader&lt;/li&gt;
&lt;li&gt;eslint&lt;/li&gt;
&lt;li&gt;eslint-config-airbnb&lt;/li&gt;
&lt;li&gt;eslint-plugin-import&lt;/li&gt;
&lt;li&gt;eslint-friendly-formatter&lt;/li&gt;
&lt;li&gt;eslint-plugin-flowtype&lt;/li&gt;
&lt;li&gt;eslint-plugin-jsx-a11y&lt;/li&gt;
&lt;li&gt;eslint-plugin-react&lt;/li&gt;
&lt;li&gt;babel-polyfill&lt;/li&gt;
&lt;li&gt;webpack&lt;/li&gt;
&lt;li&gt;jest&lt;/li&gt;
&lt;li&gt;friendly-errors-webpack-plugin &lt;code&gt;编译提示的webpack插件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;html-webpack-plugin &lt;code&gt;新建html入口文件的webpack插件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy-webpack-plugin &lt;code&gt;webpack配置合并模块&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;webpack-merge &lt;code&gt;webpack配置合并模块&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;webpack-dev-server&lt;/li&gt;
&lt;li&gt;webpack-bundle-analyzer&lt;/li&gt;
&lt;li&gt;webpack-cli&lt;/li&gt;
&lt;li&gt;portfinder 寻找接口的插件&lt;/li&gt;
&lt;li&gt;extract-text-webpack-plugin&lt;/li&gt;
&lt;li&gt;node-notifier&lt;/li&gt;
&lt;li&gt;optimize-css-assets-webpack-plugin&lt;/li&gt;
&lt;li&gt;autoprefixer&lt;/li&gt;
&lt;li&gt;mini-css-extract-plugin&lt;/li&gt;
&lt;li&gt;autoprefixer&lt;/li&gt;
&lt;li&gt;css-loader&lt;/li&gt;
&lt;li&gt;less-loader&lt;/li&gt;
&lt;li&gt;postcss-loader&lt;/li&gt;
&lt;li&gt;postcss-import&lt;/li&gt;
&lt;li&gt;postcss-loader&lt;/li&gt;
&lt;li&gt;style-loader&lt;/li&gt;
&lt;li&gt;babel-core&lt;/li&gt;
&lt;li&gt;babel-eslint&lt;/li&gt;
&lt;li&gt;babel-loader&lt;/li&gt;
&lt;li&gt;babel-plugin-transform-runtime&lt;/li&gt;
&lt;li&gt;babel-plugin-import&lt;/li&gt;
&lt;li&gt;babel-preset-env&lt;/li&gt;
&lt;li&gt;babel-preset-react&lt;/li&gt;
&lt;li&gt;babel-polyfill&lt;/li&gt;
&lt;li&gt;url-loader&lt;/li&gt;
&lt;li&gt;cross-env&lt;/li&gt;
&lt;li&gt;file-loader&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yarn add eslint eslint-loader eslint-config-airbnb eslint-plugin-import eslint-friendly-formatter eslint-plugin-flowtype eslint-plugin-jsx-a11y eslint-plugin-react babel-polyfill webpack jest webpack-merge copy-webpack-plugin html-webpack-plugin friendly-errors-webpack-plugin webpack-dev-server webpack-bundle-analyzer webpack-cli portfinder extract-text-webpack-plugin node-notifier optimize-css-assets-webpack-plugin autoprefixer mini-css-extract-plugin autoprefixer css-loader less-loader postcss-loader postcss-import postcss-loader style-loader babel-core babel-eslint babel-loader babel-plugin-transform-runtime babel-plugin-import babel-preset-env babel-preset-react babel-polyfill url-loader cross-env file-loader -D
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目配置&quot;&gt;项目配置&lt;/h2&gt;
&lt;h3 id=&quot;webpack-基础配置&quot;&gt;webpack 基础配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;为了控制开发环境和生产环境，我们可以新建build文件夹。分别书写开发环境和生产环境的webpack配置文件，这样也更可以方便我们分别控制生产环境和开发环境。&lt;/li&gt;
&lt;li&gt;为了提高代码的复用率，也为了区别 &lt;code&gt;基础配置&lt;/code&gt; 和 &lt;code&gt;个性配置&lt;/code&gt; ，可以分别新建&lt;code&gt;webpack.base&lt;/code&gt;、&lt;code&gt;webpack.dev&lt;/code&gt; 和 &lt;code&gt;webpack.prod&lt;/code&gt;三个配置文件。首先配置最基础的entry(入口)和output(出口)。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports = {
  context: path.resolve(__dirname, '../'),  //绝对路径。__dirname为当前目录。
    //基础目录用于从配置中解析入口起点。因为webpack配置在build下，所以传入 '../'
  entry: {
    app: ('./src/index.js') //项目的入口
  },
  output: {
    path: path.resolve(__dirname, '../dist'),
    filename: '[name].[hash:8].js',
    publicPath: '/',
    libraryTarget: 'umd',
  },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;entry&quot;&gt;entry&lt;/h4&gt;
&lt;p&gt;entry可以分别为字符串、数组和对象。&lt;/p&gt;
&lt;p&gt;倘若应用只有一个单一的入口，entry的值可以使用任意类型，不会影响输出结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry为字符串
{
    entry: './src/index.js',
    output: {
        path: '/dist',
        filename: 'bundle.js'
    }
}
// 结果会生成 '/dist/bundle.js'&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry为数组，可以添加多个彼此不互相依赖的文件。结合output.library选项，如果传入数组，则只导出最后一项。
{
    //如果你在html文件里引入了'bable-polyfill',可以通过数组将它加到bundle.js的最后。
    entry: ['./src/index.js', 'babel-polyfill'] ,
    output:{
        path: '/dist',
        filename: 'bundle.js'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry为对象，可以将页面配置为多页面的而不是SPA，有多个html文件。通过对象告诉webpack为每个入口，成一个bundle文件。
// 多页面的配置，可能还要借助于HtmlWebpackPlugin，来指定每个html需要引入的js
{
    entry: {
        index: './src/index.js'
        main: './src/index.js'
        login: './src/login.js'
    }
    output:{
        path: '/dist/pages'
        filename: '[name]-[hash:5].js' //文件名取自'entry'对象的键名，为了防止推送代码后浏览器读缓存，故再生成的文件之后加上hash码。
    }
}
// 会分别生成index.js,main.js,login.js三个文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://segmentfault.com/a/1190000004511992&quot;&gt;webpack构建多页面&lt;/a&gt; 可以参考这篇文章。不过现在webpack4.x也是一次断崖式升级，感兴趣的同学可以自行搜索。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry也可以传入混合类型
{
    entry:{
        vendor: ['jquery','amap','babel-polyfill'] //也可以借助CommonsChunkPlugin提取vendor的chunk。
        index: './src/index.js'
    }
    output: {
        path: '/dist'
        filename: '[name]-[hash:5].js'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.7913669064748&quot;&gt;
&lt;p&gt;CommonsChunkPlugin在webpack4.0之后移除了，可以使用splitChunksPlugin代替。&lt;/p&gt;
&lt;p&gt;可以参阅如下链接：&lt;a href=&quot;https://www.webpackjs.com/plugins/split-chunks-plugin/&quot;&gt;optimization.splitChunks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h4 id=&quot;output&quot;&gt;output&lt;/h4&gt;
&lt;p&gt;output最基础的两个配置为 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;path&lt;/code&gt; 告诉 webpack的输出目录在那里，一般我们会设置在根目录的 &lt;code&gt;dist&lt;/code&gt; 文件夹；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filename&lt;/code&gt; 用于指定输出文件的文件名，如果配置了创建了多个单独的 &lt;code&gt;chunk&lt;/code&gt; 则可以使用&lt;code&gt;[name].[hash]&lt;/code&gt; 这种占位符来确保每个文件有唯一的名称；&lt;/li&gt;
&lt;li&gt;另一个常见配置 &lt;code&gt;publicPath&lt;/code&gt; 则是用于更加复杂的场景。举例：在本地时，你可能会使用 &lt;code&gt;../assets/test.png&lt;/code&gt; 这种url来载入图片。而在生产环境下，你可能会使用CDN或者图床的地址。那么就需要配置 &lt;code&gt;publicPath = &quot;http://cdn.example.com/assets/&quot;&lt;/code&gt; 来实现生产模式下编译输出文件时自动更新url。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; output: {
    path: path.resolve(__dirname, '../dist'),
    filename: '[name].[hash:8].js',
    publicPath: '/',
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;resolve&quot;&gt;resolve&lt;/h4&gt;
&lt;p&gt;resolve常用的两个配置为 &lt;code&gt;alias&lt;/code&gt; 和 &lt;code&gt;extensions&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;alias&lt;/code&gt; 创建import或者require的别名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extensins&lt;/code&gt; 自动解析文件拓展名，补全文件后缀&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;resolve: {
    // 自动解析文件扩展名(补全文件后缀)(从左-&amp;gt;右)
    // import hello from './hello'  （!hello.js? -&amp;gt; !hello.jsx? -&amp;gt; !hello.json）
    extensions: ['.js', '.jsx', '.json'],
    alias: {
      '@': resolve('src')
    }
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;module&quot;&gt;module&lt;/h4&gt;
&lt;p&gt;module的选项决定了如何处理项目中的不同类型的模块。其中常用的有 &lt;code&gt;rules&lt;/code&gt; 和 &lt;code&gt;noParese&lt;/code&gt; 两个配置项。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;noParese&lt;/code&gt; 是为了防止weback解析与所有与rule相匹配的文件。目的是，忽略大型的library可以提高构建性能。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;noParse: function(content) {
  return /jquery|lodash/.test(content);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;rules&lt;/code&gt; 用于在创建模块是，匹配规则数组，以确定哪些规则能够对module应用loader，或者是修改parser。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module: {
    rules: [
    {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        enforce: 'pre',
        use: [{
          loader: 'babel-loader',
        }, {
          loader: 'eslint-loader', // 指定启用eslint-loader
          options: {
            formatter: require('eslint-friendly-formatter'),
            emitWarning: false
          }
        }]
      },
    {
        test: /\.css$/,
        include: /node_modules/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: () =&amp;gt; [autoprefixer({ browsers: 'last 5 versions' })],
              sourceMap: false,
            },
          },
        ],
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: ('assets/img/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: ('assets/media/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: ('assets/fonts/[name].[hash:7].[ext]')
        }
      }
    ]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如上述代码，就使用&lt;code&gt;eslint-lodaer&lt;/code&gt; 和 &lt;code&gt;babel-loader&lt;/code&gt; 处理了除了&lt;code&gt;node_modules&lt;/code&gt; 以外的 &lt;code&gt;js||jsx&lt;/code&gt;。同时配置了，解析图片、视频、字体文件等的解析，当rules匹配到的文件时，小于10000 byte 时，采用url-loader解析文件。&lt;strong&gt;（因为base64会让图片的体积变大，所以当文件较大时，使用base64并不明智）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;webpack开发配置&quot;&gt;Webpack开发配置&lt;/h3&gt;
&lt;p&gt;因为在webpack 4.X 中使用了流行的 ”约定大于配置“ 的做法，所以在新加入配置项 &lt;code&gt;mode&lt;/code&gt; ，可以告知webpack使用相应模式的内置优化。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;development&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;会将&lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 的值设为 &lt;code&gt;development&lt;/code&gt; 。启用&lt;code&gt;NamedChunksPlugin&lt;/code&gt; 和 &lt;code&gt;NamedMoudulesPlugin&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;production&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;会将&lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 的值设为 &lt;code&gt;production&lt;/code&gt; 。启用&lt;code&gt;FlagDependencyUsagePlugin&lt;/code&gt;，&lt;code&gt;FlagIncludedChunksPlugin&lt;/code&gt;，&lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt;，&lt;code&gt;NoEmitOnErrorsPlugin&lt;/code&gt;，&lt;code&gt;OccurrenceOrderPlugin&lt;/code&gt;，&lt;code&gt;SideEffectsFlagPlugin&lt;/code&gt; 和&lt;code&gt;UglifyJsPlugin&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果我们只设置NODE_ENV，则不会自动设置 &lt;code&gt;mode&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开发时，我们往往希望能看到当前开发的页面，并且能热加载。这时，我们可以借助webpack-dev-server 这个插件，来在项目中起一个应用服务器。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// package.json
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --mode development --config build/webpack.dev.conf.js&quot;,
}
// 设置当前的mode为development，同样这个配置也可以写在webpack.dev.conf.js中。然后使用build目录下的webpack.dev.conf.js 来配置相关的webpack。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;devServer: {
    clientLogLevel: 'warning',
    historyApiFallback: true, //在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html
    contentBase: path.resolve(__dirname, '../src'),
    compress: true,
    hot: true, // 热加载
    inline: true, //自动刷新
    open: true, //自动打开浏览器
    host: HOST||'localhost',
    port: PORT,
    overlay: { warnings: false, errors: true }, // 在浏览器上全屏显示编译的errors或warnings。
    publicPath: '/',
    proxy: {},
    quiet: true, // necessary for FriendlyErrorsPlugin // 终端输出的只有初始启动信息。 webpack 的警告和错误是不输出到终端的
    watchOptions: {
      poll: false
    }
  },
  plugins: [
    new webpack.DefinePlugin({
      ...process.env
    }),
    //开启HMR(热替换功能,替换更新部分,不重载页面！)
    new webpack.HotModuleReplacementPlugin(),// HMR shows correct file names in console on update.
    //显示模块相对路径
    new webpack.NamedModulesPlugin(),
    //不显示错误信息
    new webpack.NoEmitOnErrorsPlugin(),
    // https://github.com/ampedandwired/html-webpack-plugin
    ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实在开发时，我们可以设置 &lt;code&gt;contentBase: '/src'&lt;/code&gt; ，&lt;code&gt;contentBase&lt;/code&gt; 指定了devServer能访问的资源地址。因为我们开发时，资源大部分都放在&lt;code&gt;src&lt;/code&gt;目录下，所以可以直接指定资源路径为&lt;code&gt;src&lt;/code&gt;目录。因为我们在webpack基础配置时，配置了 &lt;code&gt;output&lt;/code&gt; 输出为 &lt;code&gt;dist&lt;/code&gt; 目录，所以我们也可以在devServer里，设置 &lt;code&gt;contentBase&lt;/code&gt; 为 &lt;code&gt;dist&lt;/code&gt; 目录。不过此时需要使用copyWebpackPlugin将一些静态资源复制到 &lt;code&gt;dist&lt;/code&gt; 目录下，手动新建dist目录，并复制也可以。&lt;/p&gt;
&lt;p&gt;另外，当使用 history 路由时，要配置 &lt;code&gt;historyApiFallback = true&lt;/code&gt; ，以此让服务器放弃路由权限，交由前端路由。而是用 hash 路由则不需要此配置。&lt;/p&gt;
&lt;h2 id=&quot;项目进阶&quot;&gt;项目进阶&lt;/h2&gt;
&lt;h3 id=&quot;生产环境配置&quot;&gt;生产环境配置&lt;/h3&gt;
&lt;p&gt;在使用webpack 4.x 的 mode 配置之后，需要我们手动配置的项已经减少了很多，像js代码压缩这种工具 &lt;code&gt;UglifyJsPlugin&lt;/code&gt; 就已经不用手动去配置。但是像很多前面提到的 &lt;code&gt;代码分离&lt;/code&gt; 、&lt;code&gt;css代码提取和压缩&lt;/code&gt; 、&lt;code&gt;html的生成&lt;/code&gt; 以及 &lt;code&gt;复制静态资源&lt;/code&gt; 还需要我们手动配置。&lt;/p&gt;
&lt;h4 id=&quot;代码分离&quot;&gt;代码分离&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 设置代码分离的输出目录
output: {
    path: path.resolve(__dirname, '../dist'),
    filename: ('js/[name].[hash:8].js'),
    chunkFilename: ('js/[name]-[id].[hash:8].js')
  },
 // 代码分离
 optimization: {
    runtimeChunk: {
      name: &quot;manifest&quot;
    },
    splitChunks: {
      chunks: 'all'
    }
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.6470588235294&quot;&gt;
&lt;p&gt;可以参阅如下链接：&lt;a href=&quot;https://www.webpackjs.com/plugins/split-chunks-plugin/&quot;&gt;optimization.splitChunks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h4 id=&quot;css代码压缩&quot;&gt;css代码压缩&lt;/h4&gt;
&lt;p&gt;借助 &lt;code&gt;MiniCssExtractPlugin&lt;/code&gt; 来实现压缩css和提取css。因为 &lt;code&gt;MiniCssExtractPlugin&lt;/code&gt; 无法与style-loader 共存，所以我们需要判断当前环境是生成环境还是开发环境。&lt;/p&gt;
&lt;p&gt;我们可以新建一个util.js的文件，在webpack当中一些共用的方法。考虑使用个别配置字段 &lt;code&gt;extract&lt;/code&gt; 来配置使用何种方式来配置css-loader。参见 &lt;code&gt;util.js&lt;/code&gt; 代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;new MiniCssExtractPlugin({
      filename: 'css/[name].[hash:8].css',
      chunkFilename: 'css/[name]-[id].[hash:8].css',
    }),&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;生成html&quot;&gt;生成HTML&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;htmlWebpackPlugin&lt;/code&gt;，配合ejs。可以使控制html 的生成。通过配置的方式，生成html。因为 &lt;code&gt;HtmlWebpackPlugin&lt;/code&gt; 本身可以解析ejs，所以不需要单独引入ejs的loader。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;new HtmlWebpackPlugin({
      filename: 'index.html',
      template: './src/index.ejs', // 设置目录
      title: 'React Demo',
      inject: true, // true-&amp;gt;'head' || false-&amp;gt;'body'
      minify: {
        //删除Html注释
        removeComments: true,
        //去除空格
        collapseWhitespace: true,
        //去除属性引号
        removeAttributeQuotes: true
        // more options:
        // https://github.com/kangax/html-minifier#options-quick-reference
      },
      // necessary to consistently work with multiple chunks via CommonsChunkPlugin
      chunksSortMode: 'dependency'
    }),&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;ejs&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
  &amp;lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&amp;gt;

  &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&amp;gt;
  &amp;lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&amp;gt;

  &amp;lt;% for (var chunk in htmlWebpackPlugin.files.css) { %&amp;gt;
  &amp;lt;link rel=&quot;preload&quot; href=&quot;&amp;lt;%= htmlWebpackPlugin.files.css[chunk] %&amp;gt;&quot;  as=&quot;style&quot;&amp;gt;
  &amp;lt;% } %&amp;gt;
  &amp;lt;% for (var chunk in htmlWebpackPlugin.files.chunks) { %&amp;gt;
  &amp;lt;link rel=&quot;preload&quot; href=&quot;&amp;lt;%= htmlWebpackPlugin.files.chunks[chunk].entry %&amp;gt;&quot; as=&quot;script&quot;&amp;gt;
  &amp;lt;% } %&amp;gt;

  &amp;lt;base href=&quot;/&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
  body {
    font-family: 'Source Sans Pro','Helvetica Neue',Helvetica,Arial,sans-serif;
  }
&amp;lt;/style&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;复制静态目录&quot;&gt;复制静态目录&lt;/h4&gt;
&lt;p&gt;将所以可能被请求的静态文件，分别放在assets目录下。那么在打包后，为了保证目录能正常访问（不使用CDN等加载静态资源时），我们可以配置 &lt;code&gt;publicPath = '/'&lt;/code&gt; 。然后借助于 &lt;code&gt;CopyWebpackPlugin&lt;/code&gt; 实现资源复制。&lt;/p&gt;
&lt;pre class=&quot;javas&quot;&gt;
&lt;code&gt;new CopyWebpackPlugin([{
      from: './src/assets/',
      to: 'assets'
    }]),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 &lt;code&gt;src/assets&lt;/code&gt; 复制到 &lt;code&gt;dist/assets&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;开启打包分析&quot;&gt;开启打包分析&lt;/h4&gt;
&lt;p&gt;借助插件 &lt;code&gt;BundleAnalyzerPlugin&lt;/code&gt; 直接在plugins中创建该插件：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// webpack.prod.conf.js
const BundleAnalyzerPlugin = process.env.NODE_ENV=== 'analysis' ? require('webpack-bundle-analyzer').BundleAnalyzerPlugin:null
process.env.NODE_ENV=== 'analysis' ? new BundleAnalyzerPlugin() : ()=&amp;gt;{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在package.json 中可做如下配置：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;analysis&quot;: &quot;cross-env NODE_ENV=analysis webpack -p --mode production --progress --config ./build/webpack.prod.conf.js &quot;,
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过注入环境变量，来控制是否运行打包分析。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;ssh部署&quot;&gt;ssh部署&lt;/h4&gt;
&lt;p&gt;打包后的dist文件夹，可以直接借助 node 的 ssh-node ，直接部署到服务器指定的目录下。 ssh-node既支持ssh，也支持密码登录。建议可以为在每个项目下，新建一个.ssh文件，存放项目的私钥。代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// usage: https://www.npmjs.com/package/node-ssh
var path, node_ssh, ssh, fs, opn, host

fs = require('fs')
path = require('path')
node_ssh = require('node-ssh')
opn = new require('opn')
ssh = new node_ssh()
host = 'localhost'
var localDir = './dist'
var remoteDir = '/opt/frontend/new'
var removeCommand = 'rm -rf ./*'
var pwdCommand = 'pwd'

ssh.connect({
  host: host,
  username: 'root',
  port: 22,
  // password,
  privateKey: &quot;./.ssh/id_rsa&quot;,
})
  .then(function() {
    ssh.execCommand(removeCommand, { cwd:remoteDir }).then(function(result) {
      console.log('STDOUT: ' + result.stdout)
      console.log('STDERR: ' + result.stderr)
      ssh.putDirectory(localDir, remoteDir).then(function() {
        console.log(&quot;The File thing is done&quot;)
        ssh.dispose()
        opn('http://'+host, {app:['chrome']})
      }, function(error) {
        console.log(&quot;Something's wrong&quot;)
        console.log(error)
        ssh.dispose()
      })
    })
  })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，在命令行直接 &lt;code&gt;node deploy.js&lt;/code&gt; 就可以运行以上脚本，我们也可以添加一个build + deploy的script脚本，便于启动。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;depoly&quot;: &quot;npm run build &amp;amp;&amp;amp; node ./deploy.js&quot;,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;本次从零到一，新建了一个react脚手架。过程中有很多问题，也参考了不少大牛的解释。代码里也有诸多问题。还望各位看官，不吝指教。&lt;br/&gt;记得留下你的足迹哦。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;参考了vue-cli v2.96的webpack配置。&lt;br/&gt;&lt;a href=&quot;https://github.com/chemdemo/chemdemo.github.io/issues/13&quot;&gt;【翻译】Webpack——令人困惑的地方&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.webpackjs.com/configuration/&quot;&gt;webpack中文文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 14:20:00 +0000</pubDate>
<dc:creator>Dante丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DDante/p/9368694.html</dc:identifier>
</item>
<item>
<title>自制操作系统Antz day01——Boot Sector - 奶BerBer</title>
<link>http://www.cnblogs.com/LexMoon/p/antz01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/antz01.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　　　　　Invalid partition table&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　Error loading operating system&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　Missing operating system&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;MBR是BIOS接力的第一棒，在他之后，会由分区引导扇区DBR接力，至于为什么不直接给DBR。那是因为BIOS大小有限，无法完成所有操作，在给DBR之前会通过MBR完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;81.5&quot;&gt;

&lt;p&gt;&lt;span&gt;　　&lt;span&gt;在BIOS自检等一系列工作完成后，要开始引导了。计算机会将硬盘0面0道1扇区512字节加载到07c00h（0000::7c00）处。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）为什么是0面0道1扇区？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这个可以理解为是规定，当Bios工作完成后会去将硬盘0面0道1扇区512字节进行加载。但是真实情况是根据“魔数”来确定的，魔数就是有特殊意义的数，更大作用是用来做标记，比如MBR就是在512个字节的最后两个字节填入 0x55 ，0xaa来进行标记的。放在第一个扇区是因为0面0道1扇区是磁盘最开始的地方，一开始检验出有 0x55 ，0xaa就直接开始加载。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）为什么是07c00h?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这个也可以当作是规定，在IBM文档中没有具体说明07c00h是为什么，但是在世界上第一台个人计算机诞生时，07c00h就是在它当中初次诞生的，那时的DOS最多也就是32K，为了实现MBR中的栈需要512B，为了满足需求取最大为1K，也就是32K-1K，就是07c00h了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;org 07c00h
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,cs
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ds,ax
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; es,ax
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;call&lt;/span&gt;&lt;span&gt; DispStr
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; $
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;DispStr:&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,BootMessage
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; bp,ax
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; cx,&lt;span&gt;16&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,01301h
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; bx,000ch
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; dl,&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; 10h
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;BootMessage:&lt;/span&gt;  db &lt;span&gt;&quot;Antz Uhl Kone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; times &lt;span&gt;510&lt;/span&gt;-($-$$) db &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; dw 0xaa55
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　第1行的org 07c00h已经做出讲解了，它规定了程序加载的区域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　第2-4行是将ds，es和cs指向相同的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　第5行call DispStr是调用了子程序实现字符串显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　在子程序DispStr中：　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　mov ax,BootMessage   取得显示字符串的地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　mov bp,ax　　　　　　es:ax 串地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　mov cx,16　　　　　　cx，串长度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　mov ax,01301h　　　  ah = 13 h al=01h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　mov bx,000ch　　　　　bh = 00 页号    bl = 0ch 字色&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　mov dl,0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　int 10h　　　　　　　  10h中断&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　ret&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　第6行的 jmp $是为了进行无限循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   $可以理解为当前行命令的起始地址，$$是表示当前段的起始地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   第18行的times 510-($-$$) db 0  是将剩下的地址全部填 0 ，在512个字节中，0x55,0xaa占两个字节，剩下的510个字节减去之前用过的（$-$$）个字节，身下的512-2-$-$$个字节全部填0。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;工具 ： NASM , FloppyWriter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214203877-1946208203.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;85&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;先对asm文件使用NASM编译成为bin文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
nasm os.asm -o os.img
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214313521-1398399584.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;此时在asm同级目录生成了一个os.bin文件。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　新建一个文件为 One_Antz.img&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214522322-865258088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214536267-417171601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此时生成了一个空的img文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　打开FloppyWriter.exe，选择第二个&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214625167-87510880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先选择我们生成的bin文件，点击下一步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214737037-2062736862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　再选择我们创建的img文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214903467-1409861112.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;　　镜像就制作成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725214922888-1180458987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;　　生成的镜像就是我们之前创建的img文件，内容被直接写入了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在可以使用虚拟机打开我们创建的镜像了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725215102579-532501041.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;设置好镜像后打开虚拟机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180725215333187-1916123019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;</description>
<pubDate>Wed, 25 Jul 2018 13:54:00 +0000</pubDate>
<dc:creator>奶BerBer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/antz01.html</dc:identifier>
</item>
<item>
<title>BlockingQueue（阻塞队列）详解 - 天天慕白</title>
<link>http://www.cnblogs.com/1657895829DHW/p/9368440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1657895829DHW/p/9368440.html</guid>
<description>&lt;p&gt;一. 前言&lt;/p&gt;
&lt;p&gt;　　在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。&lt;/p&gt;
&lt;p&gt;二. 认识BlockingQueue&lt;/p&gt;
&lt;p&gt;　　阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：&lt;br/&gt;&lt;img src=&quot;https://pic002.cnblogs.com/images/2010/161940/2010112414472791.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；&lt;/p&gt;
&lt;p&gt;　　常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）&lt;/p&gt;
&lt;p&gt;　　　　先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。&lt;/p&gt;
&lt;p&gt;　　　　后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。　　&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;      &lt;/em&gt;多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒），下面两幅图演示了BlockingQueue的两个常见阻塞场景：&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://pic002.cnblogs.com/images/2010/161940/2010112414442194.jpg&quot; alt=&quot;&quot;/&gt;&lt;em&gt;　　　　　　　&lt;strong&gt;如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。&lt;/strong&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://pic002.cnblogs.com/images/2010/161940/2010112414451925.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　　&lt;strong&gt;如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法：&lt;/p&gt;
&lt;p&gt;三. &lt;strong&gt;BlockingQueue的核心方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　1.放入数据&lt;/p&gt;
&lt;p&gt;　　　　（1）offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法&lt;/p&gt;
&lt;p&gt; 的线程）；　　　　　　 &lt;br/&gt;     　　（2）offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。&lt;/p&gt;
&lt;p&gt;　　　　（3）put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.&lt;/p&gt;
&lt;p&gt;　　2. 获取数据&lt;/p&gt;
&lt;p&gt;　　　　（1）poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;&lt;/p&gt;
&lt;p&gt;　　　　（2）poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间&lt;/p&gt;
&lt;p&gt;超时还没有数据可取，返回失败。&lt;/p&gt;
&lt;p&gt;　　　　（3）take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; &lt;/p&gt;
&lt;p&gt;　　　　（4）drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。&lt;/p&gt;
&lt;p&gt;四. &lt;strong&gt;常见BlockingQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在了解了BlockingQueue的基本功能后，让我们来看看BlockingQueue家庭大致有哪些成员？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/697611/201504/242030449842574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1. &lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。&lt;/p&gt;
&lt;p&gt;　　ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。&lt;/p&gt;
&lt;p&gt;　　2.&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。&lt;/p&gt;
&lt;p&gt;　　作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。&lt;/p&gt;
&lt;p&gt;　　ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。&lt;/p&gt;
&lt;p&gt;　　下面的代码演示了如何使用BlockingQueue：&lt;/p&gt;
&lt;p&gt;　　(1) 测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 import java.util.concurrent.BlockingQueue;
 2 import java.util.concurrent.ExecutorService;
 3 import java.util.concurrent.Executors;
 4 import java.util.concurrent.LinkedBlockingQueue; 
 5 
 6 public class BlockingQueueTest {
 7  
 8     public static void main(String[] args) throws InterruptedException {
 9         // 声明一个容量为10的缓存队列
10         BlockingQueue&amp;lt;String&amp;gt; queue = new LinkedBlockingQueue&amp;lt;String&amp;gt;(10);
11  
12         //new了三个生产者和一个消费者
13         Producer producer1 = new Producer(queue);
14         Producer producer2 = new Producer(queue);
15         Producer producer3 = new Producer(queue);
16         Consumer consumer = new Consumer(queue);
17  
18         // 借助Executors
19         ExecutorService service = Executors.newCachedThreadPool();
20         // 启动线程
21         service.execute(producer1);
22         service.execute(producer2);
23         service.execute(producer3);
24         service.execute(consumer);
25  
26         // 执行10s
27         Thread.sleep(10 * 1000);
28         producer1.stop();
29         producer2.stop();
30         producer3.stop();
31  
32         Thread.sleep(2000);
33         // 退出Executor
34         service.shutdown();
35     }
36 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　（2）生产者类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 import java.util.Random;
 2 import java.util.concurrent.BlockingQueue;
 3 import java.util.concurrent.TimeUnit;
 4 import java.util.concurrent.atomic.AtomicInteger;
 5  
 6 /**
 7  * 生产者线程
 8  * 
 9  * @author jackyuj
10  */
11 public class Producer implements Runnable {
12     
13     private volatile boolean  isRunning = true;//是否在运行标志
14     private BlockingQueue queue;//阻塞队列
15     private static AtomicInteger count = new AtomicInteger();//自动更新的值
16     private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;
17  
18     //构造函数
19     public Producer(BlockingQueue queue) {
20         this.queue = queue;
21     }
22  
23     public void run() {
24         String data = null;
25         Random r = new Random();
26  
27         System.out.println(&quot;启动生产者线程！&quot;);
28         try {
29             while (isRunning) {
30                 System.out.println(&quot;正在生产数据...&quot;);
31                 Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));//取0~DEFAULT_RANGE_FOR_SLEEP值的一个随机数
32  
33                 data = &quot;data:&quot; + count.incrementAndGet();//以原子方式将count当前值加1
34                 System.out.println(&quot;将数据：&quot; + data + &quot;放入队列...&quot;);
35                 if (!queue.offer(data, 2, TimeUnit.SECONDS)) {//设定的等待时间为2s，如果超过2s还没加进去返回true
36                     System.out.println(&quot;放入数据失败：&quot; + data);
37                 }
38             }
39         } catch (InterruptedException e) {
40             e.printStackTrace();
41             Thread.currentThread().interrupt();
42         } finally {
43             System.out.println(&quot;退出生产者线程！&quot;);
44         }
45     }
46  
47     public void stop() {
48         isRunning = false;
49     }
50 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　（3）消费者类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 import java.util.Random;
 2 import java.util.concurrent.BlockingQueue;
 3 import java.util.concurrent.TimeUnit;
 4  
 5 /**
 6  * 消费者线程
 7  * 
 8  * @author jackyuj
 9  */
10 public class Consumer implements Runnable {
11     
12     private BlockingQueue&amp;lt;String&amp;gt; queue;
13     private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;
14  
15     //构造函数
16     public Consumer(BlockingQueue&amp;lt;String&amp;gt; queue) {
17         this.queue = queue;
18     }
19  
20     public void run() {
21         System.out.println(&quot;启动消费者线程！&quot;);
22         Random r = new Random();
23         boolean isRunning = true;
24         try {
25             while (isRunning) {
26                 System.out.println(&quot;正从队列获取数据...&quot;);
27                 String data = queue.poll(2, TimeUnit.SECONDS);//有数据时直接从队列的队首取走，无数据时阻塞，在2s内有数据，取走，超过2s还没数据，返回失败
28                 if (null != data) {
29                     System.out.println(&quot;拿到数据：&quot; + data);
30                     System.out.println(&quot;正在消费数据：&quot; + data);
31                     Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));
32                 } else {
33                     // 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。
34                     isRunning = false;
35                 }
36             }
37         } catch (InterruptedException e) {
38             e.printStackTrace();
39             Thread.currentThread().interrupt();
40         } finally {
41             System.out.println(&quot;退出消费者线程！&quot;);
42         }
43     }
44  
45     
46 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;3. DelayQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。&lt;/p&gt;
&lt;p&gt;　　使用场景：&lt;/p&gt;
&lt;p&gt;　　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4. PriorityBlockingQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5. SynchronousQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。&lt;/p&gt;
&lt;p&gt;　　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:&lt;/p&gt;
&lt;p&gt;　　如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；&lt;/p&gt;
&lt;p&gt;　　但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。&lt;/p&gt;
&lt;p&gt;五. 小结&lt;/p&gt;
&lt;p&gt;　　BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 13:28:00 +0000</pubDate>
<dc:creator>天天慕白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1657895829DHW/p/9368440.html</dc:identifier>
</item>
<item>
<title>Docker 系列四（自定义仓库）. - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/9362633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/9362633.html</guid>
<description>&lt;h2&gt;一、Docker hub 交互&lt;/h2&gt;
&lt;p&gt;    Docker hub 是 Docker 官方维护的一个公共仓库，大部分需求都可以通过在 Docker hub 中直接下载镜像来完成。接下来，来看一下怎么与 Docker hub 进行交互，包括登陆登出以及将本地镜像推送到 Docker hub 等...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册&lt;/strong&gt;：&lt;span&gt;&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://hub.docker.com/&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;span&gt;注册的时候需要FQ~~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;登陆&lt;/strong&gt;：docker login &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180724195211168-357473967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;登出&lt;/strong&gt;：docker logout&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索镜像&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker&lt;/span&gt; search [name] --filter=stars=30
                     --filter=stars=N （参数可以指定仅显示收藏数量为 N 以上的镜像）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180724195725284-28556605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拉取镜像&lt;/strong&gt;：docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推送镜像&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、打镜像标签（username 表示Docker账号用户名）&lt;/span&gt;
&lt;span&gt;docker&lt;/span&gt; tag REPOSITORY[:tag] username/&lt;span&gt;REPOSITORY[:tag]
&lt;span&gt;docker&lt;/span&gt; tag myenv:&lt;/span&gt;1.0 jmcui/myenv:1.0

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2、推送到Docker hub&lt;/span&gt;
&lt;span&gt;docker&lt;/span&gt; push username/&lt;span&gt;REPOSITORY[:tag]
&lt;span&gt;docker&lt;/span&gt; push jmcui&lt;/span&gt;/myenv:1.0
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、创建 Docker 私库（基于HTTP）&lt;/h2&gt;
&lt;p&gt;    在企业中把内部的一些工具包放入 Nexus 中是比较常见的做法，最新版本 Nexus3.x 全面支持 Docker 的私有镜像。所以使用 Nexus3.x 一个软件来管理 Docker , Maven , Yum , PyPI 等是一个明智的选择。&lt;/p&gt;
&lt;h3&gt;1、使用 Docker 安装 Nexus&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker&lt;/span&gt; run -d --name nexus3 --restart=always -p 8081:8081 -p 8082:8082 -p 8083:8083 --mount src=nexus-data,target=/nexus-data sonatype/&lt;span&gt;nexus3
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 8081：nexus3网页端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 8082：docker(hosted)私有仓库，可以pull和push&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 8083：docker(proxy)代理远程仓库，只能pull &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、登陆&lt;/h3&gt;
&lt;p&gt;    访问 http:// ip地址:8081 默认账号：admin，默认密码：admin123&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180724203816716-963315511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 3、创建私有仓库&lt;/h3&gt;
&lt;p&gt;    页面上方的齿轮按钮 —&amp;gt; Repository —&amp;gt; Repositories —&amp;gt; Create repository —&amp;gt; 选择 docker (hosted)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180724211206936-2084539785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      还可以创建一个 docker (proxy) 类型的仓库链接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。&lt;/p&gt;
&lt;h3&gt;4、配置支持 HTTP&lt;/h3&gt;
&lt;p&gt;    Docker 默认不允许非 &lt;code&gt;HTTPS&lt;/code&gt; 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，（Ubuntu 16.04+, Debian 8+, centos 7）在 /etc/docker/daemon.json 中写入如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{
  &quot;registry-mirrors&quot;: [
    &quot;https://registry.docker-cn.com&quot;
  ],
  &quot;insecure-registries&quot;: [
    &quot;xx.xx.xx.xx:8082&quot;
  ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     重启 Docker ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;sudo&lt;/span&gt; systemctl daemon-&lt;span&gt;reload
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; systemctl restart docker
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、验证效果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、登陆&lt;/span&gt;
docker login xx.xx.xx.xx:8082
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2、私库标签&lt;/span&gt;
docker tag myenv:1.0  xx.xx.xx.xx:8082/&lt;span&gt;myenv
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3、推送镜像到私有仓库&lt;/span&gt;
docker push xx.xx.xx.xx:8082/&lt;span&gt;myenv
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4、查看私有仓库镜像，验证是否推送成功&lt;/span&gt;
curl xx.xx.xx.xx:8082/v2/&lt;span&gt;_catalog
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5、拉取私有仓库镜像&lt;/span&gt;
docker pull xx.xx.xx.xx:8082/myenv
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、私有仓库高级配置（HTTPS 认证）&lt;/h2&gt;
&lt;p&gt;    下面，我们将要搭建的私有仓库地址为 docker.domain.com，使用 openssl 自行签发 docker.domain.com 的站点 SSL 证书，并用 Docker Compose 搭建一个拥有权限认证、TLS 的私有仓库。&lt;/p&gt;
&lt;p&gt;    由于是在 Centos 7 下玩的 Docker ，首先要解决 Docker Compose 安装的问题。&lt;/p&gt;
&lt;h3&gt;1、安装 python-pip&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、检查linux有没有安装python-pip包&lt;/span&gt;
 pip -&lt;span&gt;V
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2、执行安装 epel-release 包&lt;/span&gt;
 yum -y install epel-&lt;span&gt;release
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3、执行安装 python-pip 包&lt;/span&gt;
 yum install python-&lt;span&gt;pip
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4、对安装好的pip进行升级&lt;/span&gt;
 pip install --&lt;span&gt;upgrade pip
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5、再次验证pip是否安装成功&lt;/span&gt;
 pip -&lt;span&gt;V
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;6、安装Docker-Compose（失败的话可重复多次）&lt;/span&gt;
 pip --default-timeout=300 install -U docker-compose --ignore-&lt;span&gt;installed requests
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;7、检查docker-compose 安装&lt;/span&gt;
 docker-compose -version
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 2、HTTPS 认证&lt;/h3&gt;
&lt;p&gt;    因为对 HTTPS 的那些证书认证什么的，着实没有什么大的概念，就不在这里大夸其辞了。国内各大云服务商均提供了免费的站点证书，常见的做法是：申请个域名，绑定服务器IP，然后下载云服务提供的证书，添加认证即可。&lt;/p&gt;
&lt;p&gt;    这里的做法是使用 openssl 自行签发 docker.domain.com 的站点 SSL 证书，也是看着步骤，一步步傻瓜式操作下来的，就不献丑了。具体步骤可以参考：&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/repository/registry_auth.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://yeasy.gitbooks.io/docker_practice/content/repository/registry_auth.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    至于坑，那还是有的，比如上面的 Docker Compose 安装就折腾了好久。另外需要注意的是，最后生成的文件都要放在 /etc/docker 相关目录下，目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180725205901864-62585159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180725210131170-376318762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;span&gt;&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;《Docker — 从入门到实践》&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 13:08:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/9362633.html</dc:identifier>
</item>
<item>
<title>吴恩达深度学习笔记 4.1~4.8  深层神经网络 - Dar_Alpha</title>
<link>http://www.cnblogs.com/Dar-/p/9368252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dar-/p/9368252.html</guid>
<description>&lt;p&gt;之前一章讲了 浅层神经网络,这一章讲的是深层神经网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725172301441-1720353436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;深层神经网络与浅层神经网络的区别是:隐藏层比浅层神经网络多,从命名规则上来说,有1,2,5个隐藏层的神经网络可以称为1 hidden layer,2 hidden layers,5 hidden layers&lt;/p&gt;
&lt;p&gt;深层神经网络中的正向传播与之前举例的浅层神经网络一样,只是层数变得更多了,如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725172926194-1776720013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725173019252-227843240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于每一层的正向传播我们可以用一个公式表示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725173133424-2024964363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中L表示层数,g表示激活函数,其中所涉及到的Z,W,A,b的维度为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725175354866-2015832170.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725175428823-1552417490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中n[l]表示第l层的隐藏单元个数,m表示样本数&lt;/p&gt;
&lt;p&gt;为什么要使用深层神经网络,以人脸识别与语音识别为例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725180159319-2084293091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 假设有一个人脸识别为4层的神经网络,神经网络第一层所做的事就是从原始图片中提取出人脸的轮廓与边缘，即边缘检测。这样每个神经元得到的是一些边缘信息。神经网络第二层所做的事情就是将前一层的边缘进行组合，组合成人脸一些局部特征，比如眼睛、鼻子、嘴巴等。再往后面，就将这些局部特征组合起来，融合成人脸的模样。可以看出，随着层数由浅到深，神经网络提取的特征也是从边缘到局部特征到整体，由简单到复杂。可见，如果隐藏层足够多，那么能够提取的特征就越丰富、越复杂，模型的准确率就会越高。&lt;/p&gt;

&lt;p&gt;语音识别模型也是这个道理。浅层的神经元能够检测一些简单的音调，然后较深的神经元能够检测出基本的音素，更深的神经元就能够检测出单词信息。如果网络够深，还能对短语、句子进行检测。记住一点，神经网络从左到右，神经元提取的特征从简单到复杂。特征复杂度与神经网络层数成正相关。特征越来越复杂，功能也越来越强大。&lt;/p&gt;

&lt;p&gt;除了从提取特征复杂度的角度来说明深层网络的优势之外，深层网络还有另外一个优点，就是能够减少神经元个数，从而减少计算量,以下面这个例子为例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725180651806-858557106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;要求使用电路理论计算逻辑输出:&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725180952767-2044623077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-104-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2295;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1510&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1511&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1512&quot; class=&quot;mo&quot;&gt;⊕ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;表示异或操作。如果使用深层神经网络,那么神经网络有log2(n)层,隐藏神经单元的总个数为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2295;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725181715654-1809352165.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果使用浅层神经网络,那么隐藏神经单元的个数会呈指数形式增加,为2^(n-1)个 (这里不懂为什么.......==)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Building blocks of deep neural networks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构建深层神经网络块,先来看他的流程图:&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725194759669-944738137.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;正向传播过程:&lt;/p&gt;
&lt;p&gt;输入：&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-111-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1613&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1614&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1616&quot; class=&quot;mi&quot;&gt;a &lt;span id=&quot;MathJax-Span-1617&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1618&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1619&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1620&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1621&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-1622&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-1623&quot; class=&quot;mo&quot;&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-112-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1624&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1625&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1627&quot; class=&quot;mi&quot;&gt;a &lt;span id=&quot;MathJax-Span-1628&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1629&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1630&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1631&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1632&quot; class=&quot;mo&quot;&gt;] &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-113-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1633&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1634&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1635&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1636&quot; class=&quot;mi&quot;&gt;W &lt;span id=&quot;MathJax-Span-1637&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1638&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1639&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1640&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1641&quot; class=&quot;mo&quot;&gt;] &lt;span id=&quot;MathJax-Span-1642&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-1643&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1644&quot; class=&quot;mi&quot;&gt;b &lt;span id=&quot;MathJax-Span-1645&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1646&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1647&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1648&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1649&quot; class=&quot;mo&quot;&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;缓存变量：&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-114-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1650&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1651&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1653&quot; class=&quot;mi&quot;&gt;z &lt;span id=&quot;MathJax-Span-1654&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1655&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1656&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1657&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1658&quot; class=&quot;mo&quot;&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;反向传播过程中：&lt;/p&gt;
&lt;p&gt;输入：&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-115-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1659&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1660&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1661&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1662&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1663&quot; class=&quot;mi&quot;&gt;a &lt;span id=&quot;MathJax-Span-1664&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1665&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1666&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1667&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1668&quot; class=&quot;mo&quot;&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-116-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1669&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1670&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1671&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1672&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1673&quot; class=&quot;mi&quot;&gt;a &lt;span id=&quot;MathJax-Span-1674&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1675&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1676&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1677&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1678&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-1679&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-1680&quot; class=&quot;mo&quot;&gt;] &lt;span id=&quot;MathJax-Span-1681&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-1682&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1683&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1684&quot; class=&quot;mi&quot;&gt;W &lt;span id=&quot;MathJax-Span-1685&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1686&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1687&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1688&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1689&quot; class=&quot;mo&quot;&gt;] &lt;span id=&quot;MathJax-Span-1690&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-1691&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1692&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1693&quot; class=&quot;mi&quot;&gt;b &lt;span id=&quot;MathJax-Span-1694&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1695&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1696&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1697&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1698&quot; class=&quot;mo&quot;&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-117-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1699&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1700&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1701&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1702&quot; class=&quot;mi&quot;&gt;W &lt;span id=&quot;MathJax-Span-1703&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1704&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1705&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1706&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1707&quot; class=&quot;mo&quot;&gt;] &lt;span id=&quot;MathJax-Span-1708&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-1709&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1710&quot; class=&quot;mi&quot;&gt;b &lt;span id=&quot;MathJax-Span-1711&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1712&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1713&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1714&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1715&quot; class=&quot;mo&quot;&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;正向传播和反向传播的流程图:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725201354808-830483273.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;关于深层网络中的正向传播与反向传播,如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725202729186-642310645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725202917824-1286682236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面开始讲参数和超参数:&lt;/p&gt;
&lt;h3 id=&quot;7-parameters-vs-hyperparameters&quot;&gt;&lt;strong&gt;Parameters vs Hyperparameters&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 参数和超参数如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725203706085-420432716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么叫超参数(Hyperparameter),因为它们决定了参数&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-148-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-2380&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2381&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2383&quot; class=&quot;mi&quot;&gt;W &lt;span id=&quot;MathJax-Span-2384&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-2385&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2386&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-2387&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-2388&quot; class=&quot;mo&quot;&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;和&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-149-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-2389&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2390&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2392&quot; class=&quot;mi&quot;&gt;b &lt;span id=&quot;MathJax-Span-2393&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-2394&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-2395&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-2396&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-2397&quot; class=&quot;mo&quot;&gt;] &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;的值&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;超参数的设置:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;设置最优的超参数是一个比较困难的、需要经验知识的问题。通常的做法是选择超参数一定范围内的值，分别代入神经网络进行训练，测试cost function随着迭代次数增加的变化，根据结果选择cost function最小时对应的超参数值。这类似于validation的方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 神经网络与人脑的关系:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;W&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180725204237000-1771814737.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;神经网络实际上可以分成两个部分：正向传播过程和反向传播过程。 &lt;/p&gt;

&lt;p&gt;人脑神经元可分为树突、细胞体、轴突三部分。树突接收外界电刺激信号（类比神经网络中神经元输入），传递给细胞体进行处理（类比神经网络中神经元激活函数运算），最后由轴突传递给下一个神经元（类比神经网络中神经元输出）。&lt;/p&gt;

&lt;p&gt;人脑神经元的结构和处理方式要复杂的多，神经网络模型只是非常简化的模型。人脑如何进行学习？是否也是通过反向传播和梯度下降算法现在还不清楚，可能会更加复杂&lt;/p&gt;

</description>
<pubDate>Wed, 25 Jul 2018 12:45:00 +0000</pubDate>
<dc:creator>Dar_Alpha</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dar-/p/9368252.html</dc:identifier>
</item>
<item>
<title>cocos creator入门 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/9362291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/9362291.html</guid>
<description>&lt;h2&gt; 前面的话&lt;/h2&gt;
&lt;p&gt;　　Cocos Creator 是一个完整的游戏开发解决方案，包括了 cocos2d-x 引擎的 JavaScript 实现，以及快速开发游戏所需要的各种图形界面工具。Cocos Creator 的编辑器完全为引擎定制打造，包含从设计、开发、预览、调试到发布的整个工作流所需的全功能，该编辑器提供面向设计和开发的两种工作流，提供简单顺畅的分工合作方式。Cocos Creator 目前支持发布游戏到 Web、Android 和 iOS，真正实现一次开发，全平台运行。Cocos Creator 是以内容创作为核心的游戏开发工具，在 Cocos2d-x 基础上实现了彻底脚本化、组件化和数据驱动等特点。本文将详细介绍cocos creator 入门知识&lt;/p&gt;

&lt;h3&gt;工作流程&lt;/h3&gt;
&lt;p&gt;　　cocos creator的流程如下所示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180724194902658-1163448686.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【创建或导入资源】&lt;/p&gt;
&lt;p&gt;　　将图片、声音等资源拖拽到编辑器的资源管理器面板中，即可完成资源导入&lt;/p&gt;
&lt;p&gt;　　此外，也可以在编辑器中直接创建场景、预制、动画、脚本、粒子等各类资源&lt;/p&gt;
&lt;p&gt;【建造场景内容】&lt;/p&gt;
&lt;p&gt;　　项目中有了一些基本资源后，就可以开始搭建场景了，场景是游戏内容最基本的组织方式，也是向玩家展示游戏的基本形态&lt;/p&gt;
&lt;p&gt;　　通过场景编辑器将添加各类节点，负责展示游戏的美术音效资源，并作为后续交互功能的承载&lt;/p&gt;
&lt;p&gt;【添加组件脚本，实现交互功能】&lt;/p&gt;
&lt;p&gt;　　可以为场景中的节点挂载各种内置组件和自定义脚本组件，来实现游戏逻辑的运行和交互，包括从最基本的动画播放、按钮响应，到驱动整个游戏逻辑的主循环脚本和玩家角色的控制&lt;/p&gt;
&lt;p&gt;　　几乎所有游戏逻辑功能都是通过挂载脚本到场景中的节点来实现的&lt;/p&gt;
&lt;p&gt;【一键预览和发布】&lt;/p&gt;
&lt;p&gt;　　搭建场景和开发功能的过程中，可以随时点击预览来查看当前场景的运行效果。使用手机扫描二维码，可以立即在手机上预览游戏&lt;/p&gt;
&lt;p&gt;　　当开发告一段落时，通过构建发布面板可以一键发布游戏到包括桌面、手机、Web 等多个平台&lt;/p&gt;

&lt;h3&gt;安装和启动&lt;/h3&gt;
&lt;p&gt;【windows】&lt;/p&gt;
&lt;p&gt;　　从 v1.3.0 开始，Windows 版 Cocos Creator 将不提供 32 位操作系统支持，Windows 所支持的最低版本是 Windows 7 64位&lt;/p&gt;
&lt;p&gt;　　Windows 版的安装程序是一个 .exe 可执行文件，通常命名会是 CocosCreator_vX.X.X_20XXXXXX_setup.exe，其中 vX.X.X 是 Cocos Creator 的版本号，如 v1.2.2，后面的一串数字是版本日期编号&lt;/p&gt;
&lt;p&gt;　　注意：日期编号在使用内测版时会更新的比较频繁，如果当前 PC 上已安装的版本号和安装包的版本号相同时，无法自动覆盖安装注意相同版本号的安装包，需要先卸载之前的版本才能继续安装&lt;/p&gt;
&lt;p&gt;　　Cocos Creator 将会占据系统盘中大约 1.25 GB 的空间，应用的安装路径默认选择了 &lt;code&gt;C:\CocosCreator&lt;/code&gt;，可以在安装过程中进行指定&lt;/p&gt;
&lt;p&gt;　　对于部分 windows 操作系统和显卡型号，可能会遇到如下报错信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
This browser does not support WebGL...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是显卡驱动对编辑器 WebGL 渲染模式的支持不正确导致的，如果出现这种情况，可以尝试使用命令行运行 &lt;code&gt;CocosCreator.exe&lt;/code&gt; 并加上 &lt;code&gt;--disable-gpu&lt;/code&gt; 运行参数，来禁用 GPU 加速功能，可以绕开部分显卡驱动的问题&lt;/p&gt;
&lt;p&gt;【mac】&lt;/p&gt;
&lt;p&gt;　　Mac OS X 所支持的最低版本是 OS X 10.9&lt;/p&gt;
&lt;p&gt;　　Mac 版 Cocos Creator 的安装程序是 DMG 镜像文件，双击 DMG 文件，然后将 &lt;code&gt;CocosCreator.app&lt;/code&gt; 拖拽到应用程序文件夹快捷方式，或任意其他位置。然后双击复制出来的 &lt;code&gt;CocosCreator.app&lt;/code&gt; 就可以开始使用了&lt;/p&gt;
&lt;p&gt;　　注意： 如果初次运行时出现下载的应用已损坏的提示，请前往并设置 系统偏好设置-&amp;gt;安全性与隐私-&amp;gt;允许任何来源的应用，首次打开后可以马上恢复安全与隐私设置&lt;/p&gt;
&lt;p&gt;【版本兼容】&lt;/p&gt;
&lt;p&gt;　　Cocos Creator 版本升级时，新版本的编辑器可以打开旧版本的项目，但当项目开发到一半时升级新版本的 Cocos Creator 时也可能会遇到一些问题。因为在早期版本中引擎和编辑器的实现可能存在 bug 和其他不合理的问题，这些问题可以通过用户项目和脚本的特定使用方法来规避，但当后续版本中修复了这些 bug 和问题时就可能会对现有项目造成影响&lt;/p&gt;
&lt;p&gt;　　在发现这种版本升级造成的问题时，除了联系开发团队寻求解决办法，也可以卸载新版本的 Cocos Creator 并重新安装旧版本&lt;/p&gt;
&lt;p&gt;　　安装旧版本过程中可能遇到的问题有：&lt;/p&gt;
&lt;p&gt;　　1、在Windows下，可能会遇到安装旧版本时提示「已经有一个更新版本的应用程序已安装」，如果确定已经通过控制面板正确卸载了新版本的 Cocos Creator 还不能安装旧版本，可以访问微软官方解决无法安装或卸载程序的帮助页，按照提示下载小工具并修复损坏的安装信息，即可继续安装旧版本了&lt;/p&gt;
&lt;p&gt;　　2、使用新版本 Cocos Creator 打开过的项目，在旧版本 Cocos Creator 中打开可能会遇到编辑器面板无法显示内容的问题，可以尝试选择主菜单中的「布局-&amp;gt;恢复默认布局」来进行修复&lt;/p&gt;

&lt;h3&gt;入门示例&lt;/h3&gt;
&lt;p&gt;【创建项目】&lt;/p&gt;
&lt;p&gt;　　在 Dashboard 中，打开 新建项目 选项卡，选中 Hello World 项目模板&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725104931568-254684627.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　然后在下面的项目路径栏中指定一个新项目即将被创建的位置，路径的最后一部分就是项目文件夹&lt;/p&gt;
&lt;p&gt;　　填好路径后点击右下角的 新建项目 按钮，就会自动以 Hello World 项目模板创建项目并打开&lt;/p&gt;
&lt;p&gt;【打开场景】&lt;/p&gt;
&lt;p&gt;　　Cocos Creator 的工作流程是以数据驱动和场景为核心的，初次打开一个项目时，默认不会打开任何场景，要看到 Hello World 模板中的内容，需要先打开场景资源文件&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725105606610-1251462261.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　在 资源管理器 中双击箭头所指的 &lt;code&gt;helloworld&lt;/code&gt; 场景文件。Cocos Creator 中所有场景文件都以火焰图作为图标&lt;/p&gt;
&lt;p&gt;【项目内容】&lt;/p&gt;
&lt;p&gt;　　打开 &lt;code&gt;helloworld&lt;/code&gt; 场景后，就可以看到这个模板项目中的全部内容了&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725105903918-752868126.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　场景中的内容会按照工作流分别呈现在 资源管理器、层级管理器、场景编辑器、属性检查器 四个核心面板中&lt;/p&gt;
&lt;p&gt;【预览场景】&lt;/p&gt;
&lt;p&gt;　　要预览游戏场景，点击编辑器窗口正上方的 预览游戏 按钮&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725110021033-2125313156.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　Cocos Creator 会使用默认浏览器运行当前游戏场景，效果如图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725110116776-823995916.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　点击预览窗口左上角的下拉菜单，可以选择不同设备屏幕的预览效果&lt;/p&gt;

&lt;h3&gt;项目结构&lt;/h3&gt;
&lt;p&gt;　　初次创建并打开一个 Cocos Creator 项目后，项目文件夹将会包括以下结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ProjectName（项目文件夹）
├──assets
├──library
├──local
├──settings
├──temp
└──project.json&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【assets】&lt;/p&gt;
&lt;p&gt;　　assets 将会用来放置游戏中所有本地资源、脚本和第三方库文件。只有在 assets 目录下的内容才能显示在资源管理器中&lt;/p&gt;
&lt;p&gt;　　assets 中的每个文件在导入项目后都会生成一个相同名字的 .meta 文件，用于存储该文件作为资源导入后的信息和与其他资源的关联&lt;/p&gt;
&lt;p&gt;　　一些第三方工具生成的工程或设计原文件，如 TexturePacker 的 .tps 文件，或 Photoshop 的 .psd 文件，可以选择放在 assets 外面来管理&lt;/p&gt;
&lt;p&gt;【library】&lt;/p&gt;
&lt;p&gt;　　library 是将 assets 中的资源导入后生成的。在这里，文件的结构和资源的格式将被处理成最终游戏发布时需要的形式。如果使用版本控制系统管理项目，这个文件夹是不需要进入版本控制的。 当 library 丢失或损坏的时候，只要删除整个 library 文件夹再打开项目，就会重新生成资源库&lt;/p&gt;
&lt;p&gt;【local】&lt;/p&gt;
&lt;p&gt;　　local 文件夹中包含该项目的本地设置，包括编辑器面板布局，窗口大小，位置等信息。不需要关心这里的内容，只要按照习惯设置编辑器布局，这些就会自动保存在这个文件夹。一般 local 也不需要进入版本控制&lt;/p&gt;
&lt;p&gt;【settings】&lt;/p&gt;
&lt;p&gt;　　settings 里保存项目相关的设置，如构建发布菜单里的包名、场景和平台选择等。这些设置需要和项目一起进行版本控制&lt;/p&gt;
&lt;p&gt;【Project.json】&lt;/p&gt;
&lt;p&gt;　　project.json 文件和 assets 文件夹一起，作为验证 Cocos Creator 项目合法性的标志。只有包括了这两个内容的文件夹才能作为 Cocos Creator 项目打开。而 project.json 本身目前只用来规定当前使用的引擎类型和插件存储位置，不需要用户关心其内容。这个文件也应该纳入版本控制&lt;/p&gt;
&lt;p&gt;【build】&lt;/p&gt;
&lt;p&gt;　　在使用主菜单中的 项目-&amp;gt;构建发布... 使用默认发布路径发布项目后，编辑器会在项目路径下创建 build 目录，并存放所有目标平台的构建工程。由于每次发布项目后资源 id 可能会变化，而且构建原生工程时体积很大，所以此目录建议不进入版本控制&lt;/p&gt;

&lt;h3&gt;编辑器界面&lt;/h3&gt;
&lt;p&gt;　　Cocos Creator 编辑器由多个面板组成，面板可以自由移动、组合，以适应不同项目和开发者的需要&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725192847678-1234627383.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【资源编辑器(assets)】&lt;/p&gt;
&lt;p&gt;　　资源管理器里显示了项目资源文件夹（&lt;code&gt;assets&lt;/code&gt;）中的所有资源。这里会以树状结构显示文件夹并自动同步在操作系统中对项目资源文件夹内容的修改&lt;/p&gt;
&lt;p&gt;　　可以将文件从项目外面直接拖拽进来，或使用菜单导入资源&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725193542385-476656842.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　资源列表中可以包括任意文件夹结构，文件夹在 资源管理器 中会以蓝色文件夹图标显示，点击图标左边的箭头就可以展开/折叠该文件夹中的内容&lt;/p&gt;
&lt;p&gt;　　除了文件夹之外列表中显示的都是资源文件，资源列表中的文件会隐藏扩展名，而以图标指示文件或资源的类型，比如HelloWorld模板创建出的项目中包括了三种核心资源：&lt;/p&gt;
&lt;p&gt;　　1、image图片资源：目前包括 jpg, png 等图像文件，图标会显示为图片的缩略图&lt;/p&gt;
&lt;p&gt;　　2、javascript脚本资源：程序员编写的 JavaScript 脚本文件，以js为文件扩展名。通过编辑这些脚本为添加组件功能和游戏逻辑&lt;/p&gt;
&lt;p&gt;　　3、scene场景资源：双击可以打开的场景文件，打开了场景文件才能继续进行内容创作和生产&lt;/p&gt;
&lt;p&gt;　　目前可以在 资源管理器 中创建的资源有以下几类：&lt;/p&gt;
&lt;p&gt;　　1、文件夹&lt;/p&gt;
&lt;p&gt;　　2、脚本文件&lt;/p&gt;
&lt;p&gt;　　3、场景&lt;/p&gt;
&lt;p&gt;　　4、动画剪辑&lt;/p&gt;
&lt;p&gt;　　注意：删除资源是不可撤销的操作，无法从回收站（Windows）或废纸篓（Mac）找回&lt;/p&gt;
&lt;p&gt;【场景编辑器(scene)】&lt;/p&gt;
&lt;p&gt;　　场景编辑器是内容创作的核心工作区域，使用它选择和摆放场景图像、角色、特效、UI 等各类游戏元素。在这个工作区域里，可以选中并通过变换工具修改节点的位置、旋转、缩放、尺寸等属性，并可以获得所见即所得的场景效果预览&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725194456601-1091960343.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过以下的操作来移动和定位场景编辑器的视图：&lt;/p&gt;
&lt;p&gt;　　1、鼠标右键拖拽：平移视图&lt;/p&gt;
&lt;p&gt;　　2、鼠标滚轮：以当前鼠标悬停位置为中心缩放视图&lt;/p&gt;
&lt;p&gt;　　场景视图的背景会显示一组标尺和网格，表示世界坐标系中各个点的位置信息。读数为(0,0)的点为场景中世界坐标系的原点&lt;/p&gt;
&lt;p&gt;　　视图中的紫色线框表示场景中默认会显示的内容区域，这块区域的大小由设计分辨率决定&lt;/p&gt;
&lt;p&gt;　　鼠标悬浮到场景中的节点上时，节点的约束框将会以灰色单线显示出来。此时单击鼠标，就会选中该节点。选择节点是使用变换工具设置节点位置、旋转、缩放等操作的前提，选中的节点周围将会有蓝色的线框提示节点的约束框&lt;/p&gt;
&lt;p&gt;　　工具栏中的变换工具从左到右分别是移动变换工具(W)、旋转变换工具(E)、缩放变换工具(E)、矩形变换工具（R）&lt;/p&gt;
&lt;p&gt;【层级管理器】&lt;/p&gt;
&lt;p&gt;　　层级管理器用树状列表的形式展示场景中的所有节点和他们的层级关系，所有在场景编辑器中看到的内容都可以在层级管理器中找到对应的节点条目，在编辑场景时这两个面板的内容会同步显示，一般会同时使用这两个面板来搭建场景&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725200559432-1992259767.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　层级管理器中包括当前打开场景中的所有节点，通过点击来选中节点，被选中的节点会以蓝底色高亮显示。当前选中的节点会在场景编辑器中显示蓝色边框，并更新属性检查器中的内容&lt;/p&gt;
&lt;p&gt;　　节点在列表中的排序决定了节点在场景中的显示次序。在层级管理器中位置越靠下的节点，在场景中的渲染就会更晚，也就会覆盖列表中位置较为靠上的节点&lt;/p&gt;
&lt;p&gt;【属性检查器】&lt;/p&gt;
&lt;p&gt;　　属性检查器是查看并编辑当前选中节点和组件属性的工作区域。在场景编辑器或层级管理器中选中节点，就会在属性检查器中显示该节点的属性和节点上所有组件的属性以供查询和编辑&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725201349093-677469836.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　属性检查器面板从上到下依次是：&lt;/p&gt;
&lt;p&gt;　　1、节点激活开关和节点名称&lt;/p&gt;
&lt;p&gt;　　2、节点属性&lt;/p&gt;
&lt;p&gt;　　3、组件属性&lt;/p&gt;
&lt;p&gt;　　左上角的复选框表示节点的激活状态，节点处于非激活状态时，节点上所有图像渲染相关的组件都会被关闭，整个节点包括子节点就会被有效的隐藏；节点激活开关右边显示的是节点的名称，和 层级管理器 中的节点显示名称一致&lt;/p&gt;
&lt;p&gt;　　属性检查器接下来会显示节点的属性，节点的属性排列在Node标题的下面，点击Node可以将节点的属性折叠或展开&lt;/p&gt;
&lt;p&gt;　　节点的属性除了位置（Position）、旋转（Rotation）、缩放（Scale）、尺寸（Size）等变换属性以外，还包括锚点（Anchor）、颜色（Color）、不透明度（Opacity）。修改节点的属性通常可以立刻在场景编辑器中看到节点的外观或位置变化&lt;/p&gt;
&lt;p&gt;　　节点属性下面，会列出节点上挂载的所有组件和组件的属性。用户通过脚本创建的组件，其属性是由脚本声明的。不同类型的属性在属性检查器中有不同的控件外观和编辑方式&lt;/p&gt;
&lt;p&gt;　　属性是组件脚本中声明的公开并可被序列化存储在场景和动画数据中的变量，通常可以根据变量使用内存位置不同将属性分为值类型和引用类型两大类&lt;/p&gt;
&lt;p&gt;　　1、值类型包括数值(Number)、向量(Vec2)、字符串(String)、布尔值(Boolean)、枚举(Enum)、颜色(Color)等简单的占用很少内存的变量类型&lt;/p&gt;
&lt;p&gt;　　2、引用类型包括更复杂的对象，比如节点、组件或资源。和值类型各式各样的编辑方式不同，引用类型通常只有一种编辑方式：拖拽节点或资源到属性栏中&lt;/p&gt;
&lt;p&gt;　　需要拖拽节点来赋值的属性栏上会显示绿色的标签，标签上可能会显示&lt;code&gt;Node&lt;/code&gt;，表示任意节点都可以拖拽上去，或者标签显示组件名如&lt;code&gt;Sprite&lt;/code&gt;，&lt;code&gt;Animation&lt;/code&gt;等，这时需要拖拽挂载了相应组件的节点才行&lt;/p&gt;
&lt;p&gt;　　需要拖拽资源赋值的属性栏上会显示黄色的标签，标签上显示的是资源的类型，如&lt;code&gt;sprite-frame&lt;/code&gt;，&lt;code&gt;prefab&lt;/code&gt;，&lt;code&gt;font&lt;/code&gt;等。只要从 资源管理器 中拖拽相应类型的资源过来就可以完成赋值&lt;/p&gt;
&lt;p&gt;【控制台】&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180725202854439-379153432.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　控制台会显示报错、警告或其他 Cocos Creator 编辑器和引擎生成的日志信息。不同重要级别的信息会以不同颜色显示：&lt;/p&gt;
&lt;p&gt;　　1、日志（Log）：灰色文字，通常用来显示正在进行的操作&lt;/p&gt;
&lt;p&gt;　　2、提示（Info）：蓝色文字，用来显示重要提示信息&lt;/p&gt;
&lt;p&gt;　　3、成功（Success）：绿色文字，表示当前执行的操作已成功完成&lt;/p&gt;
&lt;p&gt;　　4、警告（Warn）：黄色文字，用来提示用户最好进行处理的异常情况，但不处理也不会影响运行&lt;/p&gt;
&lt;p&gt;　　5、报错（Error）：红色文字，表示出现了严重错误，必须解决才能进行下一步操作或运行游戏&lt;/p&gt;

</description>
<pubDate>Wed, 25 Jul 2018 12:32:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/9362291.html</dc:identifier>
</item>
<item>
<title>最短路问题（——模板习题与总结） - Reqaw</title>
<link>http://www.cnblogs.com/wenzhixin/p/9368170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenzhixin/p/9368170.html</guid>
<description>&lt;p&gt;　　摘要：本文主要讲解在竞赛中如何求解图中存在环的最短路问题。其中涉及的算法有Floyd算法，Dijkstra算法，使用邻接表和优先队列优化的Dijkstra算法，Bellman-Ford算法，简要总结各算法的基本思想和实现以及使用注意事项。&lt;/p&gt;
&lt;p&gt;　　最短路问题主要分为单源最短路问题和多源最短路问题。给出顶点数和边数，以及边的权值，让我们计算从某个顶点到某个顶点的最短路径，单源最短路就是求其中一个顶点到其他各个顶点的最短路，多源最短路就是求解任意两点间的最短路。&lt;/p&gt;
&lt;p&gt;　　先总结一下只有五行的Floyd算法，一句话概括就是：从i号顶点到j号顶点只经过前k号顶点松弛过的最短路径。&lt;/p&gt;
&lt;p&gt;　　模板习题：&lt;a href=&quot;http://www.cnblogs.com/wenzhixin/p/7327981.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/wenzhixin/p/7327981.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　AC代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_8744a951-dfcc-4076-bf44-15da3d6291c2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8744a951-dfcc-4076-bf44-15da3d6291c2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8744a951-dfcc-4076-bf44-15da3d6291c2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; n,m,e[&lt;span&gt;210&lt;/span&gt;][&lt;span&gt;210&lt;/span&gt;],inf=&lt;span&gt;99999999&lt;/span&gt;&lt;span&gt;,t1,t2,t3,s,t,i,j,k;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;m) !=&lt;span&gt; EOF)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(i==&lt;span&gt;j)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 e[i][j]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 e[i][j]=&lt;span&gt;inf;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;t1,&amp;amp;t2,&amp;amp;&lt;span&gt;t3);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(e[t1][t2] &amp;gt; t3)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;道路可能存在重复，去最小值即可 &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             e[t1][t2]=e[t2][t1]=&lt;span&gt;t3;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;s,&amp;amp;&lt;span&gt;t);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(k=&lt;span&gt;0&lt;/span&gt;;k&amp;lt;n;k++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(e[i][j] &amp;gt; e[i][k]+&lt;span&gt;e[k][j])
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 e[i][j]=e[i][k]+&lt;span&gt;e[k][j];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(e[s][t]==&lt;span&gt;inf)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-1\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,e[s][t]);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　该算法的优势在于可以计算顶点数不太多的图的任意两点的最短路径，很容易实现求解多源最短路径。&lt;/p&gt;
&lt;p&gt;　　缺点在于不能计算顶点数太多的图的最短路径，一是二维数组开不了那么大，二是该算法时间复杂度太高，达到O（n*n*n），很容易超时（超过1000个顶点就不能使用）。另外该算法可以解决带负权边的图，并且均摊到每一对点上，但是不能解决带有负权回路的图（其实如果一个图中存在负权回路，那么该图就不存在最短路径了）。&lt;/p&gt;
&lt;p&gt;　　接下来，总结一下求解单源最短路径常用的Dijkstra算法。&lt;/p&gt;
&lt;p&gt;　　基本步骤：1. 将所有的顶点分为两个集合，已知最短路径的顶点集合P和未知最短路径的顶点集合Q。起初，已知最短路径的顶点集合P中只有一个源点这一个顶点，我们还需要有一个数组来记录哪些顶点在集合P中，哪些在集合Q中。比如可以用book数组进行标记，当book[i]=1;表示i号顶点在集合P中，当book[i]=0;表示i号顶点在集合Q中。&lt;/p&gt;
&lt;p&gt;　　　　　　　2. 设置源点s到自己的最短路径为0即dis[s]=0;,如果存在有源点能够直接到达的顶点i，则将dis[i]赋值为e[s][i]；如果不存在该源点直接到达的顶点i，则将&lt;/p&gt;
&lt;p&gt;dis[i]赋值正无穷大。&lt;/p&gt;
&lt;p&gt;　　　　　　　3. 在集合Q的所有顶点中选择一个离源点最近的顶点u加入到集合P。并考察所有以u为起点的边，对每一条路径进行松弛操作。&lt;/p&gt;
&lt;p&gt;　　　　　　　4. 重复第3步，如果P集合为空，算法结束。&lt;/p&gt;
&lt;p&gt;　　模板习题：&lt;a href=&quot;http://www.cnblogs.com/wenzhixin/p/7387613.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/wenzhixin/p/7387613.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　AC代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_a6b43da8-942f-4935-bb38-d6c9ff72434a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a6b43da8-942f-4935-bb38-d6c9ff72434a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a6b43da8-942f-4935-bb38-d6c9ff72434a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; e[&lt;span&gt;1010&lt;/span&gt;][&lt;span&gt;1010&lt;/span&gt;],dis[&lt;span&gt;1010&lt;/span&gt;],bk[&lt;span&gt;1010&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j,min,t,t1,t2,t3,n,u,v;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; inf=&lt;span&gt;99999999&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;t,&amp;amp;n)!=&lt;span&gt;EOF)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=n;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(i==&lt;span&gt;j)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 e[i][j]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 e[i][j]=&lt;span&gt;inf;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=t;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;t1,&amp;amp;t2,&amp;amp;&lt;span&gt;t3);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(e[t1][t2]&amp;gt;&lt;span&gt;t3)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 e[t1][t2]=&lt;span&gt;t3;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 e[t2][t1]=&lt;span&gt;t3;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             dis[i]=e[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;][i];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         memset(bk,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(bk));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         bk[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n-&lt;span&gt;1&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             min=&lt;span&gt;inf;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=n;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(bk[j]==&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;dis[j]&amp;lt;&lt;span&gt;min)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     min=&lt;span&gt;dis[j];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     u=&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             bk[u]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(v=&lt;span&gt;1&lt;/span&gt;;v&amp;lt;=n;v++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(e[u][v]&amp;lt;inf &amp;amp;&amp;amp; dis[v]&amp;gt;dis[u]+&lt;span&gt;e[u][v])
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         dis[v]=dis[u]+&lt;span&gt;e[u][v];
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,dis[n]);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　不过竞赛题大多是对Dijkstra算法的变形应用，例如求解最短路径的最大权值，最长路径的最小权值。&lt;/p&gt;
&lt;p&gt;　　最长路径的最小权值：&lt;a href=&quot;http://www.cnblogs.com/wenzhixin/p/7336948.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/wenzhixin/p/7336948.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　最短路径的最大权值：&lt;a href=&quot;http://www.cnblogs.com/wenzhixin/p/7412176.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/wenzhixin/p/7412176.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　其实懂得了算法基本思想，根据要求稍微变化一下就好了。&lt;/p&gt;
&lt;p&gt; 　  上述算法的时间复杂度为O（n*n），还是很高的，对于一些要求高的题目需要使用进一步优化的算法，时间复杂度是O（mlogn），下面借鉴《算法入门经典》中的优化算法进行讲解。具体的优化方法是使用邻接表存图，再使用优先队列优化。使用vector数组保存边的编号，遍历从某一顶点出发的所有边，更新d数组，就可以写成“for(int i = 0; i &amp;lt; G[u].size(); i++) 更新操作;”。使用优先队列保证没出弹出的是d值最小的结点，并弹出结点编号，方便后序松弛操作。&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include&amp;lt;vector&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include&amp;lt;queue&amp;gt; 
&lt;span&gt;  3&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt;  4&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INF = &lt;span&gt;99999999&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;1001&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Edge{
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt;, to, dist;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     Edge(&lt;span&gt;int&lt;/span&gt; u, &lt;span&gt;int&lt;/span&gt; v, &lt;span&gt;int&lt;/span&gt; d) :&lt;span&gt;from&lt;/span&gt;(u), to(v), dist(d) { };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注释1 &lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用优先队列存储的结点 &lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HeapNode {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; d, u;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小的d值及其结点编号&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; &amp;lt; (&lt;span&gt;const&lt;/span&gt; HeapNode&amp;amp; a) &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注释2 &lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; d &amp;gt;&lt;span&gt; a.d;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;}; 
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了使用方便，将算法中用到的数据结构封装在一个结构体中，有点类的意思，实际上结构体和类只是在权限上有一点差别&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Dijkstra{
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     vector&amp;lt;Edge&amp;gt; edges; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用vector数组存储邻接表，更容易理解，&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     vector&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; G[maxn];
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; done[maxn];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记数组&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; d[maxn];        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;s到各个顶点的最短路径&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; p[maxn];        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最短路中的上一条弧&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;     
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; init(&lt;span&gt;int&lt;/span&gt; n){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化 &lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;n = n; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注释3 &lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             G[i].clear();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空邻接表 &lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         edges.clear();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空边表 &lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; AddEdge(&lt;span&gt;int&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; to, &lt;span&gt;int&lt;/span&gt; dist) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加边 &lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         edges.push_back(Edge(&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, to, dist));
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         m = edges.size();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每加入一条边对其进行编号&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         G[&lt;span&gt;from&lt;/span&gt;].push_back(m - &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以from为起点的边的编号分别是多少 &lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; dijkstra(&lt;span&gt;int&lt;/span&gt; s){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Dijkstra &lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         priority_queue&amp;lt;HeapNode&amp;gt;&lt;span&gt; q;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++)    d[i] =&lt;span&gt; INF;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         d[s] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         
&lt;span&gt; 51&lt;/span&gt;         memset(done, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(done));
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         q.push((HeapNode){&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, s});
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;q.empty()){
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             HeapNode x =&lt;span&gt; q.top();
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            q.pop();
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; u =&lt;span&gt; x.u;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             
&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(done[u])    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             done[u] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             
&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G[u].size(); i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历所有从u出发的边 &lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;                 Edge e =&lt;span&gt; edges[G[u][i]];
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(d[e.to] &amp;gt; d[u] + e.dist){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新s到e.to的最短距离 &lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;                     d[e.to] = d[u] +&lt;span&gt; e.dist;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                     
&lt;span&gt; 67&lt;/span&gt;                     p[e.to] = G[u][i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录使用编号为G[u][i]的边走到e.to这个顶点 &lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;                     q.push((HeapNode){d[e.to], e.to});&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入d[e.to]及其结点的编号表示可以从这个点松弛其他路径 &lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有了结构体的封装，使用的时候操作如下 &lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; Dijkstra solver;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似定义一个求解单源最短路的对象，有一点需要特别注意，当图特别大的时候要将此语句放在主函数外
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原因是局部变量没有太大的存储空间，所以需要变成全局变量 &lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n, &amp;amp;m); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读入顶点数和边的条数&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;     solver.init(n);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将邻接表清空 &lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;      
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; u, v, w;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;u, &amp;amp;v, &amp;amp;w);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意点的编号是从0开始还是从1开始&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         u--; v--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是从1开始计数的，需要减1&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         solver.AddEdge(u, v, w);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果双向路需要反过来再调用一次即可 &lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     
&lt;span&gt; 91&lt;/span&gt;     solver.dijkstra(&lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求顶点0到其他各个顶点的最短距离,注意减1 
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如何使用p数组打印最短路径的方案&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; solver.n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;从1到%d的最短路径方案是：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         
&lt;span&gt; 97&lt;/span&gt;         vector&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; path;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出路径编号，倒序输出结点 &lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; tmp =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             tmp =&lt;span&gt; solver.p[tmp];
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            path.push_back(tmp);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         }&lt;span&gt;while&lt;/span&gt;(solver.edges[tmp].&lt;span&gt;from&lt;/span&gt; != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = path.size() - &lt;span&gt;1&lt;/span&gt;; j &amp;gt;= &lt;span&gt;1&lt;/span&gt;; j--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d-&amp;gt;%d,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, solver.edges[path[j]].&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, solver.edges[path[j]].to);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d-&amp;gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, solver.edges[path[&lt;span&gt;0&lt;/span&gt;]].&lt;span&gt;from&lt;/span&gt;, solver.edges[path[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]].to);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         
&lt;span&gt;109&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最短距离是%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, solver.d[i]);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;5 5
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;1 2 20
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;2 3 30
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;3 4 20
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;4 5 20
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;1 5 100
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　程序中有三个注释分别如下：&lt;/p&gt;
&lt;p&gt;　　注释1，&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;初始化列表&lt;/a&gt;，作用就是给边的各个属性赋值。&lt;/p&gt;
&lt;p&gt;　　注释2，&lt;a href=&quot;https://www.cnblogs.com/ECJTUACM-873284962/p/6771262.html&quot; target=&quot;_blank&quot;&gt;操作符重载重const的使用&lt;/a&gt;，第一个const保证这个结构体中的变量不被修改，第二个const保证之前的结构体const不被修改。&lt;/p&gt;
&lt;p&gt;　　注释3，&lt;a href=&quot;https://baike.baidu.com/item/C++this%E6%8C%87%E9%92%88/637012&quot; target=&quot;_blank&quot;&gt;this指针&lt;/a&gt;，当参数与成员变量名相同时使用this指针，如this-&amp;gt;n = n （不能写成n = n）。&lt;/p&gt;
&lt;p&gt;　　测试样例结果如图：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1143109/201807/1143109-20180725174408614-240995264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里给出一道练习题&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1535&quot; target=&quot;_blank&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=1535&lt;/a&gt;，参考解答&lt;a href=&quot;https://www.cnblogs.com/wenzhixin/p/9062574.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wenzhixin/p/9062574.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　可以发现，当一个图中存在负权边的时候，不一定存在最短路，当存在最短路的时候，Dijkstra算法就不适用了，因为松弛过程中会不断找到更短的“松弛路径”，导致最短路径为负，显然是不正确的。这就需要Bellman-Ford算法来解决图中带有负权边的单源最短路问题了。&lt;/p&gt;
&lt;p&gt;　　如果说Dijkstra算法是操作结点来进行路径松弛的话，那么Bellman-Ford算法就是操作边来松弛路径了。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_e910afdb-6de4-45c2-a525-f118466bc2da&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e910afdb-6de4-45c2-a525-f118466bc2da&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e910afdb-6de4-45c2-a525-f118466bc2da&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;n为顶点数，m为边数
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;边的描述为u[i]-&amp;gt;v[i]的权值为w[i] 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= n-&lt;span&gt;1&lt;/span&gt;; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= m; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(d[v[i]] &amp;gt; d[u[i]] +&lt;span&gt; w[i])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             d[v[i]] &amp;gt; d[u[i]] +&lt;span&gt; w[i];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　内层循环m次，意思就是依次枚举每一条边，如果u[i]-&amp;gt;v[i]这条边能使源点到v[i]的距离变短，就更新d[v[i]]的值。为什么外层循环需要n-1次呢，因为在一个含有n个顶点的，不包含负环的图中，最短路最多经过n-1个点（因为不包括起点），通过n-1轮松弛就可以得到。&lt;/p&gt;
&lt;p&gt;　　不过可惜的是这个算法时间复杂度太高，在竞赛中我们利用队列非空循环一直进行松弛，如果出现某一个点被用了n+1次，就直接判定存在环，如果不存在负环，结点的标记不会取消，计算最短路径，直至队列为空，返回不存在负环。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_c7fc3173-95f9-4c0b-acd2-9efa58e914e5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c7fc3173-95f9-4c0b-acd2-9efa58e914e5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c7fc3173-95f9-4c0b-acd2-9efa58e914e5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; bellman_ford(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     queue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; q;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     memset(inq, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(inq));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     memset(cnt, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cnt));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         d[i] =&lt;span&gt; INF;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     d[s] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     inq[s] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    q.push(s);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;q.empty()){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; u =&lt;span&gt; q.front();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         q.pop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出一个点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         intq[u] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G[u].size(); i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;枚举以该点为起点的每一条边&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             Edge e =&lt;span&gt; edges[G[u][i]];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(d[u] &amp;lt; INF &amp;amp;&amp;amp; d[e.to] &amp;gt; d[u] + e.dist) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该边能够使源点到d[e.to]的距离变小，就更新  &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 d[e.to] = d[u] +&lt;span&gt; e.dist;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 p[e.to] =&lt;span&gt; G[u][i];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(!inq[e.to]){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有被标记过 &lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    q.push(e.to);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     inq[e.to] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(++cnt[e.to] &amp;gt; n)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果弹出过程中，某一个点出现了n+1次，直接判定存在负环 &lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　上面的写法和优化后Dijkstra算法很像，不同的是它能让一个节点多次进入队列，从而判断是否存在负环，同时也能计算最短路径。使用的时候也用结构体封装一下就能想优化后的Dijkstra算法一样使用了。Bellman-Ford算法不论从思想上还是实现上都很成熟，在实际应用中也很广泛。&lt;/p&gt;
&lt;p&gt;　　至此，最短路问题的求解的几种常见算法就介绍完了，各有个的优点，Foley算法，精简，能解决带负权边但不存在负环的图的最短路问题，但时间复杂度高，Dijkstra算法时间复杂度低，但是不能求解有负权边的图的最短路问题，Bellman-Ford算法相对比较完美，但是代码量大，不易实现。因此需要根据具体问题，选择合适的算法才行。&lt;/p&gt;

</description>
<pubDate>Wed, 25 Jul 2018 12:31:00 +0000</pubDate>
<dc:creator>Reqaw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenzhixin/p/9368170.html</dc:identifier>
</item>
<item>
<title>调度器简介，以及Linux的调度策略 - Vamei</title>
<link>http://www.cnblogs.com/vamei/p/9364382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vamei/p/9364382.html</guid>
<description>&lt;p&gt;进程是操作系统虚拟出来的概念，用来组织计算机中的任务。但随着进程被赋予越来越多的任务，进程好像有了真实的生命，它从诞生就随着CPU时间执行，直到最终消失。不过，进程的生命都得到了操作系统内核的关照。就好像疲于照顾几个孩子的母亲内核必须做出决定，如何在进程间分配有限的计算资源，最终让用户获得最佳的使用体验。内核中安排进程执行的模块称为调度器（scheduler）。这里将介绍调度器的工作方式。&lt;/p&gt;
&lt;h3&gt;进程状态&lt;/h3&gt;
&lt;p&gt;调度器可以切换进程状态（process state）。一个Linux进程从被创建到死亡，可能会经过很多种状态，比如执行、暂停、可中断睡眠、不可中断睡眠、退出等。我们可以把Linux下繁多的进程状态，归纳为三种基本状态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就绪（Ready）: 进程已经获得了CPU以外的所有必要资源，如进程空间、网络连接等。就绪状态下的进程等到CPU，便可立即执行。&lt;/li&gt;
&lt;li&gt;执行（Running）：进程获得CPU，执行程序。&lt;/li&gt;
&lt;li&gt;阻塞（Blocked）：当进程由于等待某个事件而无法执行时，便放弃CPU，处于阻塞状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725144330851-836316939.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1 进程的基本状态&lt;/p&gt;
&lt;p&gt;进程创建后，就自动变成了就绪状态。如果内核把CPU时间分配给该进程，那么进程就从就绪状态变成了执行状态。在执行状态下，进程执行指令，最为活跃。正在执行的进程可以主动进入阻塞状态，比如这个进程需要将一部分硬盘中的数据读取到内存中。在这段读取时间里，进程不需要使用CPU，可以主动进入阻塞状态，让出CPU。当读取结束时，计算机硬件发出信号，进程再从阻塞状态恢复为就绪状态。进程也可以被迫进入阻塞状态，比如接收到SIGSTOP信号。&lt;/p&gt;
&lt;p&gt;调度器是CPU时间的管理员。Linux调度器需要负责做两件事：一件事是选择某些就绪的进程来执行；另一件事是打断某些执行中的进程，让它们变回就绪状态。不过，并不是所有的调度器都有第二个功能。有的调度器的状态切换是单向的，只能让就绪进程变成执行状态，不能把正在执行中的进程变回就绪状态。支持双向状态切换的调度器被称为抢占式（pre-emptive）调度器。&lt;/p&gt;
&lt;p&gt;调度器在让一个进程变回就绪时，就会立即让另一个就绪的进程开始执行。多个进程接替使用CPU，从而最大效率地利用CPU时间。当然，如果执行中进程主动进入阻塞状态，那么调度器也会选择另一个就绪进程来消费CPU时间。所谓的上下文切换（context switch）就是指进程在CPU中切换执行的过程。内核承担了上下文切换的任务，负责储存和重建进程被切换掉之前的CPU状态，从而让进程感觉不到自己的执行被中断。应用程序的开发者在编写计算机程序时，就不用专门写代码处理上下文切换了。 &lt;/p&gt;
&lt;h3&gt;进程的优先级&lt;/h3&gt;
&lt;p&gt;调度器分配CPU时间的基本依据，就是进程的优先级。根据程序任务性质的不同，程序可以有不同的执行优先级。根据优先级特点，我们可以把进程分为两种类别。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实时进程（Real-Time Process）：优先级高、需要尽快被执行的进程。它们一定不能被普通进程所阻挡，例如视频播放、各种监测系统。&lt;/li&gt;
&lt;li&gt;普通进程（Normal Process）：优先级低、更长执行时间的进程。例如文本编译器、批处理一段文档、图形渲染。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;普通进程根据行为的不同，还可以被分成互动进程（interactive process）和批处理进程（batch process）。互动进程的例子有图形界面，它们可能处在长时间的等待状态，例如等待用户的输入。一旦特定事件发生，互动进程需要尽快被激活。一般来说，图形界面的反应时间是50到100毫秒。批处理进程没有与用户交互的，往往在后台被默默地执行。&lt;/p&gt;
&lt;p&gt;实时进程由Linux操作系统创造，普通用户只能创建普通进程。两种进程的优先级不同，实时进程的优先级永远高于普通进程。进程的优先级是一个0到139的整数。数字越小，优先级越高。其中，优先级0到99留给实时进程，100到139留给普通进程。&lt;/p&gt;

&lt;p&gt;一个普通进程的默认优先级是120。我们可以用命令nice来修改一个进程的默认优先级。例如有一个可执行程序叫app，执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$&lt;span&gt;nice&lt;/span&gt; -n -&lt;span&gt;20&lt;/span&gt; ./app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令中的-20指的是从默认优先级上减去20。通过这个命令执行app程序，内核会将app进程的默认优先级设置成100，也就是普通进程的最高优先级。命令中的-20可以被换成-20至19中任何一个整数，包括-20 和 19。默认优先级将会变成执行时的静态优先级（static priority）。调度器最终使用的优先级根据的是进程的动态优先级：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;动态优先级 = 静态优先级 – Bonus + 5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这个公式的计算结果小于100或大于139，将会取100到139范围内最接近计算结果的数字作为实际的动态优先级。公式中的Bonus是一个估计值，这个数字越大，代表着它可能越需要被优先执行。如果内核发现这个进程需要经常跟用户交互，将会把Bonus值设置成大于5的数字。如果进程不经常跟用户交互，内核将会把进程的Bonus设置成小于5的数。&lt;/p&gt;

&lt;h3&gt;O(n)和O(1)调度器&lt;/h3&gt;
&lt;p&gt;下面介绍Linux的调度策略。最原始的调度策略是按照优先级排列好进程，等到一个进程运行完了再运行优先级较低的一个，但这种策略完全无法发挥多任务系统的优势。因此，随着时间推移，操作系统的调度器也多次进化。&lt;/p&gt;
&lt;p&gt;先来看Linux 2.4内核推出的O(n)调度器。O(n)这个名字，来源于算法复杂度的大O表示法。大O符号代表这个算法在最坏情况下的复杂度。字母n在这里代表操作系统中的活跃进程数量。O(n)表示这个调度器的时间复杂度和活跃进程的数量成正比。&lt;/p&gt;
&lt;p&gt;O(n)调度器把时间分成大量的微小时间片（Epoch）。在每个时间片开始的时候，调度器会检查所有处在就绪状态的进程。调度器计算每个进程的优先级，然后选择优先级最高的进程来执行。一旦被调度器切换到执行，进程可以不被打扰地用尽这个时间片。如果进程没有用尽时间片，那么该时间片的剩余时间会增加到下一个时间片中。&lt;/p&gt;
&lt;p&gt;O(n)调度器在每次使用时间片前都要检查所有就绪进程的优先级。这个检查时间和进程中进程数目n成正比，这也正是该调度器复杂度为O(n)的原因。当计算机中有大量进程在运行时，这个调度器的性能将会被大大降低。也就是说，O(n)调度器没有很好的可拓展性。O(n)调度器是Linux 2.6之前使用的进程调度器。当Java语言逐渐流行后，由于Java虚拟机会创建大量进程，调度器的性能问题变得更加明显。&lt;/p&gt;
&lt;p&gt;为了解决O(n)调度器的性能问题，O(1)调度器被发明了出来，并从Linux 2.6内核开始使用。顾名思义，O(1)调度器是指调度器每次选择要执行的进程的时间都是1个单位的常数，和系统中的进程数量无关。这样，就算系统中有大量的进程，调度器的性能也不会下降。O(1)调度器的创新之处在于，它会把进程按照优先级排好，放入特定的数据结构中。在选择下一个要执行的进程时，调度器不用遍历进程，就可以直接选择优先级最高的进程。&lt;/p&gt;
&lt;p&gt;和O(n)调度器类似，O(1)也是把时间片分配给进程。优先级为120以下的进程时间片为：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;(140–priority)×20毫秒&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;优先级120及以上的进程时间片为：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;(140–priority)×5 毫秒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;O(1)调度器会用两个队列来存放进程。一个队列称为活跃队列，用于存储那些待分配时间片的进程。另一个队列称为过期队列，用于存储那些已经享用过时间片的进程。O(1)调度器把时间片从活跃队列中调出一个进程。这个进程用尽时间片，就会转移到过期队列。当活跃队列的所有进程都被执行过后，调度器就会把活跃队列和过期队列对调，用同样的方式继续执行这些进程。&lt;/p&gt;
&lt;p&gt;上面的描述没有考虑优先级。加入优先级后，情况会变得复杂一些。操作系统会创建140个活跃队列和过期队列，对应优先级0到139的进程。一开始，所有进程都会放在活跃队列中。然后操作系统会从优先级最高的活跃队列开始依次选择进程来执行，如果两个进程的优先级相同，他们有相同的概率被选中。执行一次后，这个进程会被从活跃队列中剔除。如果这个进程在这次时间片中没有彻底完成，它会被加入优先级相同的过期队列中。当140个活跃队列的所有进程都被执行完后，过期队列中将会有很多进程。调度器将对调优先级相同的活跃队列和过期队列继续执行下去。过期队列和活跃队列，如图2所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725144434573-872846112.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2 过期队列和活跃队列（需要替换）&lt;/p&gt;

&lt;p&gt;我们下面看一个例子，有五个进程，如表1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725144523716-1704587582.png&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表1 进程&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Linux操作系统中的进程队列（run queue），如表2所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725144626219-966853615.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表2 进程队列&lt;/p&gt;
&lt;p&gt;那么在一个执行周期，被选中的进程依次是先A，然后B和C，随后是D，最后是E。&lt;/p&gt;
&lt;p&gt;注意，普通进程的执行策略并没有保证优先级为100的进程会先被执行完进入结束状态，再执行优先级为101的进程，而是在每个对调活跃和过期队列的周期中都有机会被执行，这种设计是为了避免进程饥饿（starvation）。所谓的进程饥饿，就是优先级低的进程很久都没有机会被执行。&lt;/p&gt;
&lt;p&gt;我们看到，O(1)调度器在挑选下一个要执行的进程时很简单，不需要遍历所有进程。但是它依然有一些缺点。进程的运行顺序和时间片长度极度依赖于优先级。比如，计算优先级为100、110、120、130和139这几个进程的时间片长度，如表3所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725144742343-1568609510.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表3 进程的时间片长度&lt;/p&gt;
&lt;p&gt;从表格中你会发现，优先级为110和120的进程的时间片长度差距比120和130之间的大了10倍。也就是说，进程时间片长度的计算存在很大的随机性。O(1)调度器会根据平均休眠时间来调整进程优先级。该调度器假设那些休眠时间长的进程是在等待用户互动。这些互动类的进程应该获得更高的优先级，以便给用户更好的体验。一旦这个假设不成立，O(1)调度器对CPU的调配就会出现问题。&lt;/p&gt;
&lt;h3&gt;完全公平调度器&lt;/h3&gt;
&lt;p&gt;从2007年发布的Linux 2.6.23版本起，完全公平调度器（CFS，Completely Fair Scheduler）取代了O(1)调度器。CFS调度器不对进程进行任何形式的估计和猜测。这一点和O(1)区分互动和非互动进程的做法完全不同。&lt;/p&gt;
&lt;p&gt;CFS调度器增加了一个虚拟运行时（virtual runtime）的概念。每次一个进程在CPU中被执行了一段时间，就会增加它虚拟运行时的记录。在每次选择要执行的进程时，不是选择优先级最高的进程，而是选择虚拟运行时最少的进程。完全公平调度器用一种叫红黑树的数据结构取代了O(1)调度器的140个队列。红黑树可以高效地找到虚拟运行最小的进程。&lt;/p&gt;
&lt;p&gt;我们先通过例子来看CFS调度器。假如一台运行的计算机中本来拥有A、B、C、D四个进程。内核记录着每个进程的虚拟运行时，如表4所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725144939496-559298460.png&quot; alt=&quot;&quot; width=&quot;418&quot; height=&quot;153&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表4 每个进程的虚拟运行时&lt;/p&gt;
&lt;p&gt;系统增加一个新的进程E。新创建进程的虚拟运行时不会被设置成0，而会被设置成当前所有进程最小的虚拟运行时。这能保证该进程被较快地执行。在原来的进程中，最小虚拟运行时是进程A的1 000纳秒，因此E的初始虚拟运行时会被设置为1 000纳秒。新的进程列表如表5所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725145044339-1878279359.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表5 新的进程列表&lt;/p&gt;
&lt;p&gt;假如调度器需要选择下一个执行的进程，进程A会被选中执行。进程A会执行一个调度器决定的时间片。假如进程A运行了250纳秒，那它的虚拟运行时增加。而其他的进程没有运行，所以虚拟运行时不变。在A消耗完时间片后，更新后的进程列表，如表6所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180725145129131-289173370.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表6 更新后的进程列表&lt;/p&gt;
&lt;p&gt;可以看到，进程A的排序下降到了第三位，下一个将要被执行的进程是进程E。从本质上看，虚拟运行时代表了该进程已经消耗了多少CPU时间。如果它消耗得少，那么理应优先获得计算资源。&lt;/p&gt;
&lt;p&gt;按照上述的基本设计理念，CFS调度器能让所有进程公平地使用CPU。听起来，这让进程的优先级变得毫无意义。CFS调度器也考虑到了这一点。CFS调度器会根据进程的优先级来计算一个时间片因子。同样是增加250纳秒的虚拟运行时，优先级低的进程实际获得的可能只有200纳秒，而优先级高的进程实际获得可能有300纳秒。这样，优先级高的进程就获得了更多的计算资源。&lt;/p&gt;
&lt;p&gt;以上就是调度器的基本原理，以及Linux用过的几种调度策略。调度器可以更加合理地把CPU时间分配给进程。现代计算机都是多任务系统，调度器在多任务系统中起着顶梁柱的作用。&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 12:30:00 +0000</pubDate>
<dc:creator>Vamei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vamei/p/9364382.html</dc:identifier>
</item>
</channel>
</rss>