<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Windows与Linux相互远程桌面连接 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/9847001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/9847001.html</guid>
<description>&lt;p&gt;    对于远程桌面连接Linux，大家可能会第一时间想到使用VNC,，远程桌面Windows，大家第一时间会想到使用Windows自带的远程桌面。那么有没有办法，使得在Linux中可以远程Windows，在Windows中远程桌面Linux？今天就跟大家一起探讨一下Linux与Windows相互远程。以CentOS6.6为例，步骤如下所示：&lt;/p&gt;
&lt;h4 id=&quot;使用windows远程桌面连接linux&quot;&gt;使用Windows远程桌面连接Linux&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、检查服务器是否安装GNome&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# rpm -qa | grep desktop&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果在查询的结果中未出现gnome-desktop，则需要配置安装源，安装GNOME图形界面，命令：yum -y groupinstall &quot;X Window System&quot; &quot;Chinese Support&quot; &quot;Desktop&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;2、安装VNCServer，并进行配置VNCServer和设置密码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# rpm -ivh tigervnc-server-1.1.0-18.el6.x86_64.rpm #本地安装VNCServer
[root@admin /]# vncpasswd #设置VNC登录密码
[root@admin /]# vim /etc/sysconfig/vncservers #修改配置VNC
[root@admin /]# chkconfig vncserver on #配置开机启动
[root@admin /]# service vncserver restart #启动VNC服务&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install epel-release&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;5、安装xrdp&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install xrdp&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;6、修改xrdp配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# vim /etc/xrdp/xrdp.ini
max_bpp=32 #将默认的24修改为32&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;7、启动xrdp服务并设置为开机启动&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /] chkconfig xrdp on
[root@admin /] service xrdp start&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上均为在线安装，如需要离线安装，可到网站中：http://www.rpmfind.net/ 搜索xrdp选择适合自己系统的版本下载&lt;br/&gt;[root@admin /] rpm -ivh xrdp-0.6.1-5.el6.x86_64.rpm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;8、测试远程桌面&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-7a0ebf14973ef55e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;01Windows远程Linux桌面.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用linux远程桌面连接windows&quot;&gt;使用Linux远程桌面连接Windows&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、确认Linux已经安装GNome图形桌面&lt;/li&gt;
&lt;li&gt;2、配置需要被远程的Windows允许远程桌面连接&lt;/li&gt;
&lt;li&gt;3、在Windows防火墙中放行远程桌面端口（Windows默认端口为3389）&lt;/li&gt;
&lt;li&gt;4、在Linux安装远程连接包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install rdesktop
[root@admin /]# yum -y install tsclient&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;5、在&lt;strong&gt;应用程序&lt;/strong&gt;-&amp;gt;&lt;strong&gt;Internet&lt;/strong&gt;-&amp;gt;打开&lt;strong&gt;终端服务器客户机&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;6、点击&lt;strong&gt;Add Connection&lt;/strong&gt;，选择&lt;strong&gt;Windows Terminal Service&lt;/strong&gt;，依次填写Name、Host、Username、Password&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果Windows远程桌面端口不是3389，则填写时使用格式&lt;strong&gt;IP:端口&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;7、保存配置后，在主界面双击刚才保存的会话配置即可&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-f4d112d279819c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;02Linux远程Windows.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用linux远程桌面连接linux&quot;&gt;使用Linux远程桌面连接Linux&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、确认Linux已经安装GNome图形桌面&lt;/li&gt;
&lt;li&gt;2、在Linux防火墙中放行远程桌面端口（默认端口初始值为5900+连接ID）并在被远程服务器中安装配置VNCServer&lt;/li&gt;
&lt;li&gt;3、在Linux安装远程连接包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install rdesktop
[root@admin /]# yum -y install tsclient&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小提示&quot;&gt;小提示&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;在Linux中不管是远程Windows还是Linux，如果出现全屏，不知道如何退出全屏时，可使用以下方法
1、Linux远程Linux
   使用 F8 键，此时会弹出VNC菜单，点击&quot;Exit Viewer&quot;或去掉&quot;Full Screen&quot;前面的勾选即可
2、Linux远程Windows
   使用组合键Crtl+Alt+Enter即可退出全屏&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:48:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>    对于远程桌面连接Linux，大家可能会第一时间想到使用VNC,，远程桌面Windows，大家第一时间会想到使用Windows自带的远程桌面。那么有没有办法，使得在Linux</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/9847001.html</dc:identifier>
</item>
<item>
<title>Java解析XML文件的常用方法介绍 - 闵立</title>
<link>http://www.cnblogs.com/min-li/p/9773201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/min-li/p/9773201.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　XML是一个可扩展标记语言。很多时候我们需要进行数据交换，同时也存在跨平台使用，XML文件对这些需求提供了很好的帮助！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于Java来说，XML常见的用途就是保存数据和配置，这就涉及了对XML文件的增删改查操作！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　Java常见的XML解析方式分为DOM解析、SAX解析、DOM4j解析，下面是这三种解析方式的优缺点：&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;　　1、DOM解析 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　方便遍历，随机访问某一个节点，修改XML。缺点是一次性读取到内存。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　2、SAX解析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　从上至下一个个节点去解析，触发事件（调用相应的方法）来进行处理。不能对xml进行修改。占用内存小。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　3、DOM4j&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　第三方的开源的解析工具，方便使用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;XML文件：(src/name.xml)&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　下面我就来介绍DOM和DOM4j来解析上面的XML文件的方法：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.parsers.DocumentBuilder;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.parsers.DocumentBuilderFactory;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.parsers.ParserConfigurationException;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.Transformer;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.TransformerConfigurationException;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.TransformerException;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.TransformerFactory;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.dom.DOMSource;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.stream.StreamResult;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.Document;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.Element;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.Node;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.NodeList;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.xml.sax.SAXException;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DOM {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             DocumentBuilderFactory dbf =&lt;span&gt; DocumentBuilderFactory.newInstance();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建DOM解析器工厂&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;             DocumentBuilder db =&lt;span&gt; dbf.newDocumentBuilder();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用DOM解析器工厂的newDocumentBuilder()方法得到DOM解析器对象&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;             Document doc = db.parse(&quot;src\\name.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用DOM解析器对象parse(String uri)方法得到Document对象&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;             NodeList nl = doc.getElementsByTagName(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Document对象的getElementsByTagName(String tagname)方法得到NodeList对象&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;             * 遍历XML中的元素
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                 Node node =&lt;span&gt; nl.item(i);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过NodeList的item(int index)方法得到NodeList中的Node对象&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;                 Element element =&lt;span&gt; (Element) node;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Node对象强制转换的方法得到Element对象&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;                 String id = element.getAttribute(&quot;id&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Element对象的getgetAttribute(String name)方法得到id属性值&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;                System.out.println(id);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印id属性值&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;                 String age = element.getElementsByTagName(&quot;age&quot;).item(0&lt;span&gt;).getTextContent();
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Element对象的getElementsByTagName(String name)方法得到age的属性值&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;                System.out.println(age);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印age&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;             * 添加元素到XML中
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;             Element root =&lt;span&gt; doc.getDocumentElement();
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Document对象的getDocumentElement()方法得到根节点&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;             Element newname = doc.createElement(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Document对象的createElement(String tagName)方法得到新的name元素&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;             newname.setAttribute(&quot;id&quot;, &quot;小明&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过调用Element对象的setAttribute(String name,String value)方法为id赋值&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;             Element newage = doc.createElement(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Document对象的createElement(String tagName)方法得到新的age元素&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             newage.setTextContent(&quot;18&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过调用Element对象的setTextContent(String textContent)方法为age赋值&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            newname.appendChild(newage);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加age到name中&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            root.appendChild(newname);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加name到根节点中&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;             * 修改XML中的元素
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 Element fixname =&lt;span&gt; (Element) nl.item(i);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到要修改的Element对象&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;                 String fixnewname = fixname.getAttribute(&quot;id&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取到要修改对象的id属性值&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                 * 判断name是否为要修改的对象
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fixnewname.equals(&quot;小明&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                     Element sex = doc.createElement(&quot;sex&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新的Element对象&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;                     sex.setAttribute(&quot;sex&quot;, &quot;男&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给新的Element对象的属性赋值&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                    fixname.appendChild(sex);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加新的Element(sex)对象到Element(fixname)对象中&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;             * 删除XML中的元素
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;             root.removeChild(root.getChildNodes().item(7&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先通过根节点访问子节点，得到Node对象，然后调用根节点的removeChild(Node oldChild)方法删除元素&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;             * 将更改写入到XML文件中
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;             TransformerFactory tf =&lt;span&gt; TransformerFactory.newInstance();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用TransformerFactory的newInstance()方法得到TransformerFactory对象&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             Transformer t =&lt;span&gt; tf.newTransformer();
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用TransformerFactory对象的newTransformer()方法得到Transformer对象&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             t.transform(&lt;span&gt;new&lt;/span&gt; DOMSource(doc), &lt;span&gt;new&lt;/span&gt; StreamResult(&quot;src\\name.xml&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Transformer对象的transform(Source xmlSource,Result
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; outputTarget)方法将修改写入到name.xml文件中&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParserConfigurationException e) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SAXException e) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TransformerConfigurationException e) {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TransformerException e) {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;遍历运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;张三
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 20
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;李四
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 25
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;王五
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 30
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;小明&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;18&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;小明&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;18&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sex &lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;=&quot;男&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用DOM4j解析需要添加第三方工具包，具体网址：&lt;a href=&quot;https://dom4j.github.io/&quot;&gt;DOM4j&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.Document;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.DocumentException;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.Element;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.io.SAXReader;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.io.XMLWriter;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.UnsupportedEncodingException;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DOM4j {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             SAXReader sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SAXReader();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             Document doc = sr.read(&quot;src\\name.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Element root =&lt;span&gt; doc.getRootElement();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             List&amp;lt;Element&amp;gt; name = root.elements(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Element names : name) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 System.out.println(names.attributeValue(&quot;id&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 List&amp;lt;Element&amp;gt; age = names.elements(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Element ages : age) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    System.out.println(ages.getText());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             Element newname = root.addElement(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             newname.addAttribute(&quot;id&quot;, &quot;小明&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Element newage = newname.addElement(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             newage.setText(&quot;18&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             root.remove(name.get(3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写入&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             XMLWriter xw = &lt;span&gt;new&lt;/span&gt; XMLWriter(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;src\\name.xml&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            xw.write(doc);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DocumentException e) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;运行结果上同。&lt;/h3&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:46:00 +0000</pubDate>
<dc:creator>闵立</dc:creator>
<og:description>XML是一个可扩展标记语言。很多时候我们需要进行数据交换，同时也存在跨平台使用，XML文件对这些需求提供了很好的帮助！ 对于Java来说，XML常见的用途就是保存数据和配置，这就涉及了对XML文件的增</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/min-li/p/9773201.html</dc:identifier>
</item>
<item>
<title>Spring Boot + Spring Cloud 构建微服务系统（八）：分布式链路追踪（Sleuth、Zipkin） - 朝雨忆轻尘</title>
<link>http://www.cnblogs.com/xifengxiaoma/p/9838067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xifengxiaoma/p/9838067.html</guid>
<description>&lt;h2&gt;技术背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在微服务架构中，随着业务发展，系统拆分导致系统调用链路愈发复杂，一个看似简单的前端请求可能最终需要调用很多次后端服务才能完成，那么当整个请求出现问题时，我们很难得知到底是哪个服务出了问题导致的，这时就需要解决一个问题，如何快速定位服务故障点，于是，分布式系统调用链追踪技术就此诞生了。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;zipkin&quot;&gt;ZipKin&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Zipkin 是一个由Twitter公司提供并开放源代码分布式的跟踪系统，它可以帮助收集服务的时间数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个服务向zipkin报告定时数据，zipkin会根据调用关系通过Zipkin UI生成依赖关系图，展示了多少跟踪请求经过了哪些服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可非常方便的监测系统中存在的瓶颈。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Zipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。我们可以跟根据需求选择不同的存储方式，生成环境一般都需要持久化。我们这里采用elasticsearch作为zipkin的数据存储器。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-sleuth&quot;&gt;Spring Cloud Sleuth&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一般而言，一个分布式服务追踪系统，主要有三部分组成：数据收集、数据存储和数据展示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring Cloud Sleuth为服务之间的调用提供链路追踪，通过Sleuth可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。此外，Sleuth还可以帮助我们：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;耗时分析: 通过Sleuth可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可视化错误: 对于程序未捕捉的异常，可以通过集成Zipkin服务界面上看到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链路优化: 对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;spring cloud sleuth可以结合zipkin，将信息发送到zipkin，利用zipkin的存储来存储信息，利用zipkin ui来展示数据。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-sleuth&quot;&gt;实现案例&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在早前的Spring Cloud版本里是需要自建zipkin服务端的，但是从SpringCloud2.0 以后，官方已经不支持自建Server了，改成提供编译好的jar包供用户使用。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为我用的是2.0以后的版本，自建Servcer的方式请自行百度。这里我们是使用docker方式部署zipkin服务，并采用elasticsearch作为zipkin的数据存储器。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;下载镜像&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 此前请先安装好docker环境，使用以下命令分别拉取zipkin和elasticsearch镜像。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull openzipkin/&lt;span&gt;zipkin
docker pull docker.elastic.co&lt;/span&gt;/elasticsearch/elasticsearch:&lt;span&gt;6.3&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过 docker images 查看下载镜像。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023175917378-795615735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;编写启动文件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;创建如下文件夹结构。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dockerfile
    &lt;/span&gt;|-&lt;span&gt; elasticsearch
    &lt;/span&gt;|    |-&lt;span&gt; data
    &lt;/span&gt;|- docker-compose.yml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;docker-compose.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
services:

  elasticsearch:
    image:  docker.elastic.co&lt;/span&gt;/elasticsearch/elasticsearch:&lt;span&gt;6.3&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    container_name: elasticsearch
    restart: always
    networks:
      &lt;/span&gt;-&lt;span&gt; elk
    ports:
      &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9200:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
      - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9300:9300&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    volumes:
       &lt;/span&gt;- ../elasticsearch/data:/usr/share/elasticsearch/&lt;span&gt;data

  zipkin:
    image: openzipkin&lt;/span&gt;/&lt;span&gt;zipkin:latest
    container_name: zipkin
    restart: always
    networks:
      &lt;/span&gt;-&lt;span&gt; elk
    ports:
      &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9411:9411&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    environment:
      &lt;/span&gt;- STORAGE_TYPE=&lt;span&gt;elasticsearch
      &lt;/span&gt;- ES_HOSTS=&lt;span&gt;elasticsearch

networks:
    elk:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于docker-compose.yml 文件格式及相关内容请自行百度了解。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动服务&quot;&gt;启动服务&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;命令模式进入dockerfile目录，执行启动命令如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行过程如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023180914441-550778626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行完成之后，通过 docker ps 命令查看，发现zipkin和elasticsearch确实启动起来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023181024523-1903628665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，zipkin服务端就搭建起来了，访问 &lt;a href=&quot;http://localhost:9411/&quot; target=&quot;_blank&quot;&gt;http://localhost:9411&lt;/a&gt;，效果如下，因为还没有客户端，所以还没有数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023183311160-1565397107.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;zipkin服务端已经搭建完成了，接下来我们来实现客户端。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;添加依赖&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;修改 spring-cloud-consul-consumer 项目Maven配置，添加zipkin依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pom.xml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加配置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;修改配置文件，添加如下zipkin配置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  zipkin:
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;-url: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9411/&lt;/span&gt;
&lt;span&gt;  sleuth:
    sampler:
      probability: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; #样本采集量，默认为0.&lt;span&gt;1&lt;/span&gt;，为了测试这里修改为1，正式环境一般使用默认值。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;application.yml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023182301712-874693967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试效果&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;先后启动注册中心、服务提供者、服务消费者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反复访问几次 &lt;a href=&quot;http://localhost:8521/ribbon/call&quot; target=&quot;_blank&quot;&gt;http://localhost:8521/ribbon/call&lt;/a&gt;，产生zipkin数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023183743036-1166860662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再次访问 &lt;a href=&quot;http://localhost:9411/&quot; target=&quot;_blank&quot;&gt;http://localhost:9411&lt;/a&gt;， 发现出现了我们刚刚访问的服务，选择并点击追踪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023183936285-1127654176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 点击追踪之后，页面显示了相关的服务调用信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023184247825-1110368264.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击调用记录查看详情页面，可以看到每一个服务所耗费的时间和顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023185137607-1402828876.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;源码下载&lt;/h2&gt;
&lt;p&gt;码云：&lt;a href=&quot;https://gitee.com/liuge1988/spring-cloud-demo.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/liuge1988/spring-cloud-demo.git&lt;/a&gt;&lt;a href=&quot;https://gitee.com/liuge1988/kitty&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/xifengxiaoma/&quot; target=&quot;_blank&quot;&gt;朝雨忆轻尘&lt;/a&gt;&lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/xifengxiaoma/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xifengxiaoma/ &lt;/a&gt;&lt;br/&gt;版权所有，欢迎转载，转载请注明原文作者及出处。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:11:00 +0000</pubDate>
<dc:creator>朝雨忆轻尘</dc:creator>
<og:description>技术背景 在微服务架构中，随着业务发展，系统拆分导致系统调用链路愈发复杂，一个看似简单的前端请求可能最终需要调用很多次后端服务才能完成，那么当整个请求出现问题时，我们很难得知到底是哪个服务出了问题导致</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xifengxiaoma/p/9838067.html</dc:identifier>
</item>
<item>
<title>朱晔和你聊Spring系列S1E9：聊聊Spring的那些注解 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/9846846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/9846846.html</guid>
<description>&lt;p&gt;本文我们来梳理一下Spring的那些注解，如下图所示，大概从几方面列出了Spring的一些注解：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/24/166a687687198766?w=830&amp;amp;h=762&amp;amp;f=png&amp;amp;s=310293&quot;/&gt;&lt;br/&gt;如果此图看不清楚也没事，请运行下面的代码输出所有的结果。&lt;br/&gt;Spring目前的趋势是使用注解结合Java代码而不是配置来定义行为、属性、功能、规则和扩展点，因此梳理注解也是梳理Spring功能点的很好的方式，全面的梳理可以补足我们知识点的漏洞。&lt;/p&gt;
&lt;h2 id=&quot;查找所有注解&quot;&gt;查找所有注解&lt;/h2&gt;
&lt;p&gt;首先，我们来创建一个项目，使用SPRING INITIALIZR生成一个引入Spring各种组件的项目模板，然后引入如下工具包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.reflections&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;reflections&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.9.11&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个反射工具包，我们可以创建一个Spring Boot应用程序，以一行代码打印出所有Spring框架的注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.reflections.Reflections;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.lang.annotation.Annotation;

@Component
public class ScanAnnotationRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        new Reflections(&quot;org.springframework&quot;)
                .getSubTypesOf(Annotation.class)
                .stream()
                .map(clazz-&amp;gt;clazz.getName())
                .sorted()
                .forEach(System.out::println);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果这里就不给出了，下面我们逐一进行梳理其中的一些重要注解。&lt;/p&gt;
&lt;h2 id=&quot;有关注解&quot;&gt;有关注解&lt;/h2&gt;
&lt;p&gt;Java的Annotation注解（类似于C#的Attribute特性），说白了就是给代码打上标签的能力。我们可以配置这个标签的保留阶段，仅源代码，源代码+字节码，源代码+字节码+运行时。通过引入注解，我们可以简单快速赋予代码生命力，大大提高代码可读性和扩展性。注解本身不具有任何能力，只是一个标签，但是我们可以定义各种标签然后实现各种标签处理器来对类、方法、属性甚至参数等进行功能扩展、功能开启、属性定义、行为定义、规则定义、关联处理、元数据定义等等。在实现各种框架的时候，我们经常会自定义标签方便框架使用者仅仅通过在合适的地方引入合适的注解来启用（或自定义）框架的一些能力并应用到我们的程序中。&lt;/p&gt;
&lt;p&gt;不仅仅是框架的作者会大量使用注解，在之前的系列文章中我们也多次自定义注解，我们有通过定义@Metrics注解配合Spring AOP来为程序启动打点、日志、异常等功能，我们有通过定义@Sign注解配合Spring MVC的ResponseBodyAdvice进行数据签名功能，我们还经常会定义各种自定义注解配合Spring MVC的HandlerMethodArgumentResolver进行权限的校验等等功能。采用这种模式，我们的核心业务逻辑可以保持清晰干净，通过注解配合AOP赋予代码额外的能力。&lt;/p&gt;
&lt;p&gt;你可能会说，注解还是有侵入性，我们需要耦合框架定义的那些注解，这个问题其实是无解的，100%无侵入性也代表了可读性的降低，代码的功能和能力应当聚合在一起，这也就是为什么Spring现在也不建议采用XML来做配置。Java核心类库并没有什么注解，好在Spring已经有了大量注解，而Spring也变为了Java开发的标准，所以其实我们很多时候如果希望自己的框架（RPC啥的）完全没有侵入性的话可以借用Spring的那些注解@Autowired、@Controller、@Service等注解，配合各种包的规范其实我们可以对目标元素的功能识别个八九不离十，完全有可能实现0侵入的功能增强。&lt;/p&gt;
&lt;p&gt;有关如何实现自定义注解不赘述，这里我们简单回顾一下几个元注解（注解的注解）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@Documented&lt;/strong&gt;：将会在被此注解注解的元素的javadoc文档中列出注解，一般都打上这个注解没坏处&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Target&lt;/strong&gt;：注解能被应用的目标元素，比如类、方法、属性、参数等等，需要仔细思考&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Retention&lt;/strong&gt;：仅在源码保留，还是保留到编译后的字节码，还是到运行时也去加载，超过90%的应用会在运行时去解析注解进行额外的处理，所以大部分情况我们都会设置配置为RetentionPolicy.RUNTIME&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Inherited&lt;/strong&gt;：如果子类没有定义注解的话，能自动从父类获取定义了继承属性的注解，比如Spring的@Service是没有继承特性的，但是@Transactional是有继承特性的，在OO继承体系中使用Spring注解的时候请特别注意这点，理所当然认为注解是能被子类继承的话可能会引起不必要的Bug，需要仔细斟酌是否开启继承&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Repeatable&lt;/strong&gt;：Java 8 引入的特性，通过关联注解容器定义可重复注解，小小语法糖提高了代码可读性，对于元素有多个重复注解其实是很常见的事情，比如某方法可以是A角色可以访问也可以是B角色可以访问，某方法需要定时任务执行，要在A条件执行也需要在B条件执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Native&lt;/strong&gt;：是否在.h头文件中生成被标记的字段，除非原生程序需要和Java程序交互，否则很少会用到这个元注解&lt;br/&gt;现在我们来从几个方面逐一温习一下Spring的那些常用的值得关注的注解。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring核心注解&quot;&gt;Spring核心注解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先来看一下各种stereotype：按分类定义了由Spring管理的各种组件，&lt;strong&gt;@Controller&lt;/strong&gt;定义表现层组件，&lt;strong&gt;@Service&lt;/strong&gt;定义业务逻辑层组件，&lt;strong&gt;@Repository&lt;/strong&gt;定义数据访问层资源库组件，&lt;strong&gt;@Component&lt;/strong&gt;定义其它组件（比如访问外部服务的组件），之前也说过了随着这些注解功能无区别，但是对组件进行合适的分类意义重大，不仅仅增加可读性而且方便我们通过AOP对不同类型的组件进行更多自动增强&lt;/li&gt;
&lt;li&gt;再来看看IOC相关的一些注解：&lt;strong&gt;@Autowired&lt;/strong&gt;自动装配不用多说了；&lt;strong&gt;@Required&lt;/strong&gt;用于在setter方法标记属性值需要由Spring进行装配，对于目前版本的Spring这个注解已经废弃，现在Spring更推荐使用构造方法注入；&lt;strong&gt;@Qualifier&lt;/strong&gt;用于通过给Bean定义修饰语来注入相应的Bean，和@Autowired一起使用相当于@Resource的效果，当然还有一种常见用法是嵌入其它注解用于对Bean进行区分，然后配合@Autowired一起使用，参见后面提到的Spring Cloud的@LoadBalanced注解；&lt;strong&gt;@Value&lt;/strong&gt;用于注入属性配置或SpEL表达式（前者是我们常见用法，后者可以从其它对象获取值，功能更强大一点）；&lt;strong&gt;@Lookup&lt;/strong&gt;可以实现方法注入，如果我们的类是单例的，但是又希望Spring注入的依赖的对象是Prototype生命周期（每次new一个出来）的，这个时候可以通过此注解进行方法注入&lt;/li&gt;
&lt;li&gt;然后来看一下有关事务的几个注解：&lt;strong&gt;@EnableTransactionManagement&lt;/strong&gt;用于开启事务管理，使用Spring Boot如果引入Spring Data的话不需要手动开启（不过建议大家在使用事务的时候还是通过日志来验证事务管理是否生效）；&lt;strong&gt;@Transactional&lt;/strong&gt;大家都知道用于开启事务以及设置传播性、隔离性、回滚条件等；&lt;strong&gt;@TransactionalEventListener&lt;/strong&gt;用于配置事务的回调方法，可以在事务提交前、提交后、完成后以及回滚后几个阶段接受回调事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Order&lt;/strong&gt;注解可以设置Spring管理对象的加载顺序，在之前介绍AOP的文章中我们看到有的时候我们必须通过设置合理的@Order来合理安排切面的切入顺序避免一些问题，还有在一些业务场景中，我们往往会去定义一组类似于Filter的@Component，然后会从容器获得一组Bean，这个时候业务组件的运行顺序往往会比较重要，也可以通过这个方式进行排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@AliasFor&lt;/strong&gt;注解可以设置一组注解属性相互作为别名，对于有歧义的时候会使代码更清晰，此外还有一个用途是创建复合注解，Spring MVC的@GetMapping注解就是基于@RequestMapping这个注解创建的复合注解，我们可以很方便得通过这种方式来实现注解的继承&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring上下文注解&quot;&gt;Spring上下文注解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先来看一下配置相关的一些注解：&lt;strong&gt;@Configuration&lt;/strong&gt;用于标注配置类，启用Java配置方式的Bean配置；&lt;strong&gt;@Bean&lt;/strong&gt;用于配置一个Bean；&lt;strong&gt;@ComponentScan&lt;/strong&gt;（&lt;strong&gt;@ComponentScans&lt;/strong&gt;用于配置一组@ComponentScan，Java 8可以直接使用重复注解特性配置多个@ComponentScan）用于扫描包方式配置Bean；&lt;strong&gt;@PropertySource&lt;/strong&gt;以及 &lt;strong&gt;@PropertySources&lt;/strong&gt;用于导入配置文件；&lt;strong&gt;@Conditional&lt;/strong&gt;用于设置关联的条件类，在合适的时候启用Bean的配置（Spring Boot自动配置根基）；&lt;strong&gt;@Import&lt;/strong&gt;用于导入其它配置类； &lt;strong&gt;@ImportResource&lt;/strong&gt;用于导入非Java配置方式的XML配置；&lt;strong&gt;@Profile&lt;/strong&gt;用于指定在合适的Profile下启用配置；&lt;strong&gt;@Lazy&lt;/strong&gt;用于告知容器延迟到使用的时候实例化Bean（默认情况下容器启动的时候实例化Bean来检查所有的问题）；&lt;strong&gt;@Description&lt;/strong&gt;用于给Bean设置描述；&lt;strong&gt;@Scope&lt;/strong&gt;用于设置Bean的生命周期；&lt;strong&gt;@Primary&lt;/strong&gt;用于在定义了多个Bean的时候指定首选的Bean&lt;/li&gt;
&lt;li&gt;其它一些注解包括：&lt;strong&gt;@EventListener&lt;/strong&gt;用于设置回调方法监听Spring制定的以及自定义的各种事件；&lt;strong&gt;@EnableAspectJAutoProxy&lt;/strong&gt;用于开启支持AspectJ的 &lt;strong&gt;@Aspect&lt;/strong&gt;切面配置支持，使用Spring Boot引入了AOP启动器的话不需要显式开启&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-web注解&quot;&gt;Spring Web注解&lt;/h2&gt;
&lt;p&gt;Spring MVC的各种注解对应了Spring MVC各方面的功能，下面我们来了解一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是三个定义了Bean特殊生命周期的复合注解：&lt;strong&gt;@RequestScope&lt;/strong&gt;、&lt;strong&gt;@SessionScope&lt;/strong&gt;和 &lt;strong&gt;@ApplicationScope&lt;/strong&gt;。在Web应用中，我们可能需要Bean跟随请求、会话和应用程序的声明周期来进行创建，这个时候可以直接使用这三个快捷的复合注解&lt;/li&gt;
&lt;li&gt;接下去可以看到各种 &lt;strong&gt;@XXXMapping&lt;/strong&gt;的注解，分别用于配置HandlerMethod匹配到不同的Http Method，当然不使用这些快捷的注解也是可以的，直接使用@RequestMapping然后手动设置method&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@ResponseStatus&lt;/strong&gt;可以用到方法上也可以用到异常上，前者会直接使请求得到指定的响应代码或原因（可以配合@ExceptionHandler使用），后者可以实现遇到指定异常的时候给出指定的响应代码或原因，&lt;strong&gt;@ResponseBody&lt;/strong&gt;我们实现Restful接口的时候（@RestController）最常用了，把返回内容（序列化后）输出到请求体&lt;/li&gt;
&lt;li&gt;Spring MVC给了我们各种注解方便我们从HTTP请求各种地方获取参数，&lt;strong&gt;@RequestBody&lt;/strong&gt;从请求体（处理复杂数据，比如JSON），&lt;strong&gt;@RequestHeader&lt;/strong&gt;从请求头，&lt;strong&gt;@CookieValue&lt;/strong&gt;从cookie中，&lt;strong&gt;@SessionAttribute&lt;/strong&gt;从会话中，&lt;strong&gt;@RequestAttribute&lt;/strong&gt;从请求的Attribute中（比如过滤器和拦截器手动设置的一些临时数据），&lt;strong&gt;@RequestParam&lt;/strong&gt;从请求参数（处理简单数据，键值对），&lt;strong&gt;@PathVariable&lt;/strong&gt;从路径片段，&lt;strong&gt;@MatrixAttribute&lt;/strong&gt;矩阵变量允许我们采用特殊的规则在URL路径后加参数（分号区分不同参数，逗号为参数增加多个值）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@ControllerAdvice&lt;/strong&gt;是一个重要注解，允许我们在集中的地方配置控制器（有@RequestMapping的方法）相关的增强（&lt;strong&gt;@RestControllerAdvice&lt;/strong&gt;也是差不多的，只是相当于为@ExceptionHandler加上了@ResponseBody）。那么可以应用哪些增强呢？首先是可以用 &lt;strong&gt;@ExceptionHandler&lt;/strong&gt;进行统一的全局异常处理；第二是 &lt;strong&gt;@InitBinder&lt;/strong&gt;用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中；第三是 &lt;strong&gt;@ModelAttribute&lt;/strong&gt;让全局的@RequestMapping都能获得在此处设置的键值对。当然，这里说的@InitBinder和@ExceptionHandler也可以不定义在@ControllerAdvice内部（作为全局开启），定义在Controller内部应用到某个Controller也是可以的&lt;/li&gt;
&lt;li&gt;其它还有一些注解比如：&lt;strong&gt;@CrossOrigin&lt;/strong&gt;可以用到Controller或Method上（需要配合@RequestMapping）设置细粒度的跨域行为&lt;br/&gt;在之前的文章中我们也提到，对于Spring MVC，定义自己的注解应用到参数、方法、控制器上，配合HandlerMethodArgumentResolver、XXAdvise、以及Interceptor实现具体的功能来使用太太常见了，几乎所有的非业务横切关注点，我们都不应该在方法实现中重复任何一行代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-boot注解&quot;&gt;Spring Boot注解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;来看一下上下文相关的注解：&lt;strong&gt;@ConfigurationProperties&lt;/strong&gt;很常用（配合 &lt;strong&gt;@EnableConfigurationProperties&lt;/strong&gt;注解来设置需要启用的配置类），用来自定义配置类和配置文件进行关联；&lt;strong&gt;@DeprecatedConfigurationProperty&lt;/strong&gt;用于标记废弃的配置以及设置替代配置和告知废弃原因；&lt;strong&gt;@ConfigurationPropertiesBinding&lt;/strong&gt;用于指定自定义的转换器用于配置解析的时的类型转换； &lt;strong&gt;@NestedConfigurationProperty&lt;/strong&gt;用于关联外部的类型作为嵌套配置类&lt;/li&gt;
&lt;li&gt;再看看自动配置相关的注解，自动配置是Spring Boot最重要的特性，在之前的系列文章中我有提到一个观点，IOC是好事情，但是把组件内部的一些默认配置以及组件和组件的组装交给外部用户来配置其实是不合理的，组件应当可以自动进行自我配置实现开箱急用，只有需要自定义组件的时候才要求外部来进行个性化配置：&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;注解可以启用自动配置，Spring Boot应用程序一般我们会直接使用复合注解@SpringBootApplication；&lt;strong&gt;@AutoConfigureOrder&lt;/strong&gt;（值越小优先级越高）、&lt;strong&gt;@AutoConfigureAfter&lt;/strong&gt;、&lt;strong&gt;@AutoConfigureBefore&lt;/strong&gt;用于设置自动配置类加载顺序，以及精确控制加载依赖关系，有的时候我们的自动配置需要相互依赖或者会相互干扰，需要手动调节&lt;/li&gt;
&lt;li&gt;最后来看一下十几种配置条件，用好这些注解是实现完善的自动配置的关键：&lt;strong&gt;@ConditionalOnBean&lt;/strong&gt;用于仅当容器中已经包含指定的Bean类型或名称时才匹配条件；&lt;strong&gt;@ConditionalOnClass&lt;/strong&gt;仅当classpath上存在指定类时条件匹配；&lt;strong&gt;@ConditionalOnCloudPlatform&lt;/strong&gt;仅当指定的云平台处于活动状态时条件匹配；&lt;strong&gt;@ConditionalOnExpression&lt;/strong&gt;依赖于SpEL表达式的值的条件元素的配置注解；&lt;strong&gt;@ConditionalOnJava&lt;/strong&gt;基于应用运行的JVM版本的条件匹配；&lt;strong&gt;@ConditionalOnJndi&lt;/strong&gt;基于JNDI可用和可以查找指定位置的条件匹配；&lt;strong&gt;@ConditionalOnMissingBean&lt;/strong&gt;仅当容器中不包含指定的Bean类型或名称时条件匹配；&lt;strong&gt;@ConditionalOnMissingClass&lt;/strong&gt;仅当classpath上不存在指定类时条件匹配；&lt;strong&gt;@ConditionalOnNotWebApplication&lt;/strong&gt; 仅当不是WebApplicationContext（非Web项目）时条件匹配，对应 &lt;strong&gt;@ConditionalOnWebApplication&lt;/strong&gt;；&lt;strong&gt;@ConditionalOnProperty&lt;/strong&gt;是检查指定的属性是否具有指定的值；&lt;strong&gt;@ConditionalOnResource&lt;/strong&gt;表示仅当 classpath 上存在指定资源时条件匹配；&lt;strong&gt;@ConditionalOnSingleCandidate&lt;/strong&gt;仅当容器中包含指定的Bean类并且可以判断只有单个候选者时条件匹配。其实所有这些实现原理都是扩展SpringBootCondition抽象类（实现之前提到的Condition接口），我们完全可以实现自己的条件注解（配合 &lt;strong&gt;@Conditional&lt;/strong&gt;注解关联到自己实现的SpringBootCondition）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-cloud注解&quot;&gt;Spring Cloud注解&lt;/h2&gt;
&lt;p&gt;在介绍本系列文章的第一篇中我们就提到了，Spring Cloud整齐划一通过各种EnableXXX注解开启某个功能，这里就不对这些注解进行说明了，使用Spring Boot组件的功能非常简单，基本就是引POM+EnableXXX+设置配置文件三部曲。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是 Netflix包下的一些注解，各种EnableXXX就不说了，参考前一篇文章，之前没介绍过 &lt;strong&gt;@RibbonClient&lt;/strong&gt;，这个注解用来为负载均衡客户端做一些自定义的配置，可以进一步配置或自定义从哪里获取服务端列表、负载均衡策略、Ping也就是服务鉴活策略等等&lt;/li&gt;
&lt;li&gt;client包下的 &lt;strong&gt;@SpringCloudApplication&lt;/strong&gt;之前文章中我们也没有使用到，这是一个复合注解就是 &lt;strong&gt;@SpringBootApplication&lt;/strong&gt;+ &lt;strong&gt;@EnableDiscoveryClient&lt;/strong&gt;+ &lt;strong&gt;@EnableCircuitBreaker&lt;/strong&gt;，Spring Cloud那堆东西很多，还是自己亲手定义一个一个功能的注解来的踏实； &lt;strong&gt;@LoadBalanced&lt;/strong&gt;注解用于和RestTemplate配合使用构成一个负载均衡的Http客户端，实现原理上其实这个注解是一个@Qualifier注解，Spring会为所有@LoadBalanced的RestTemplate加入一个LoadBalancerInterceptor（实现ClientHttpRequestInterceptor）实现负载均衡&lt;/li&gt;
&lt;li&gt;sleuth包下面的注解和链路跟踪相关，比较常用的是通过 &lt;strong&gt;@SpanName&lt;/strong&gt;手动设置span的名称，其它注解对于业务开发并不常用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，写了本文我发现我看到@已经Markdown的**就眼花，请点赞支持。本文我们通过代码打印出了大部分Spring相关的注解，你也可以通过这个方式熟悉其它框架的注解（毕竟注解是框架赋予我们各种便捷功能的一个重要入口，对注解了解个八九成也往往可以对框架赋予我们的丰富功能了解六七成）。然后我们梳理了一下Spring相关的各种注解，其中主要需要关注的是几方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;元注解，也就是注解的注解&lt;/li&gt;
&lt;li&gt;Spring容器相关的一些注解，包括@Qualifier、@AliasFor、@Order等看似不重要但其实很重要的注解&lt;/li&gt;
&lt;li&gt;Spring Java配置相关的一些注解，包括条件注解&lt;/li&gt;
&lt;li&gt;Spring Boot自动配置相关的一些注解&lt;/li&gt;
&lt;li&gt;很多注解可以同时应用到类型、方法、参数上，有的时候应用到不同的地方作用会略微不一样，这个需要重点关注&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们知道注解其实只是一个标识，注解如何起作用背后的实现原理还是比较多样的，你可以进一步结合本文介绍的Spring的各种注解探寻一下背后实现的原理。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:03:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>本文我们来梳理一下Spring的那些注解，如下图所示，大概从几方面列出了Spring的一些注解： 如果此图看不清楚也没事，请运行下面的代码输出所有的结果。 Spring目前的趋势是使用注解结合Java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/9846846.html</dc:identifier>
</item>
<item>
<title>Python对HDFS的操作(一) - dong66</title>
<link>http://www.cnblogs.com/songdongdong6/p/9846837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songdongdong6/p/9846837.html</guid>
<description>&lt;h2&gt;hdfs的定义:&lt;/h2&gt;
&lt;p&gt;　　Hadoop的分布式文件系统（HDFS）被设计成适合运行通用硬件上的分布式文件系统，它和现有的分布式文件系统有很多的共同点。但同时，它和其它的分布式文件系统的区别也是很明显的，hdfs是一个高容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上使用。HDFS放宽了一部分POSIX(&lt;a href=&quot;https://baike.baidu.com/item/POSIX/3792413?fr=aladdin&quot;&gt;https://baike.baidu.com/item/POSIX/3792413?fr=aladdin&lt;/a&gt;)约束,来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS现在是Apache Hadoop Core项目的一部分，这个项目的地址是：&lt;a href=&quot;http://hadoop.apache.org/core/&quot; target=&quot;_blank&quot;&gt;http://hadoop.apache.org/core/&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;安装：&lt;/h2&gt;
&lt;p&gt;　　因为这里介绍的是python版本的使用，所以需要安装相应的包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
　pip install hdfs
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 基础使用方法：&lt;/h2&gt;
&lt;h3&gt;　　Client---创建集群链接:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; hdfs &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
client&lt;/span&gt;=Client(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://hdfsip:50070&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　&lt;em class=&quot;property&quot;&gt;class  &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;hdfs.client.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;Client&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;url&lt;/em&gt;, &lt;em&gt;root=None&lt;/em&gt;, &lt;em&gt;proxy=None&lt;/em&gt;, &lt;em&gt;timeout=None&lt;/em&gt;, &lt;em&gt;session=None&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　url: ip:端口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt; 　　　　　  root：指定hdfs根目录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　proxy：制定登陆用户的身份&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　timout： 设置超时时间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　session：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333418/201810/1333418-20181024220929960-126998217.png&quot; alt=&quot;&quot;/&gt;(官方解释，没弄明白具体意思，也暂时没有用到这个参数，等用到之后再进行补充)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　dir---查看Client所有支持的方法：&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; dir(client)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt;&lt;code class=&quot;java plain&quot;&gt;[&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__class__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__delattr__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__dict__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__dir__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__doc__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__eq__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__format__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__ge__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__getattribute__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__gt__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;java string&quot;&gt;　　'__hash__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__init__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__le__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__lt__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__module__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__ne__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__new__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__reduce__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__reduce_ex__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__registry__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__repr__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__setattr__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__sizeof__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__str__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__subclasshook__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__weakref__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_append'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_create'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_delete'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_content_summary'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_file_checksum'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_file_status'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_home_directory'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_list_status'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_mkdirs'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_open'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_proxy'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_rename'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_request'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_session'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_owner'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_permission'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_replication'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_times'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_timeout'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java string&quot;&gt;　　'checksum'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'content'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'delete'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'download'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'from_options'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'list'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'makedirs'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'parts'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'read'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'rename'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'resolve'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'root'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_owner'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_permission'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_replication'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_times'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'status'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'upload'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'url'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'walk'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'write'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;　　status---获取指定路径的具体信息：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.status(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accessTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pathSuffix&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;supergroup&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DIRECTORY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;owner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;childrenNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blockSize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,

 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fileId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 16385, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;replication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;storagePolicy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;modificationTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1473023149031, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;permission&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　status(hdfs_path,strict=True)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　hdfs_path:就是hdfs的路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　strict：当设置为True时，hdfs的路径不存在时，返回异常信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　　当设置为False时，hdfs的路径不存在时，返回None&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　list---获取指定路径的子目录信息：&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&quot;test01&quot;,&quot;test02&quot;,&quot;test03&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;       参数说明:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　list(hdfs_path,status=False)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　hdfs_path: hdfs的路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　status：为True时，同时反hi子目录的状态信息，默认为False&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　makedirs--创建目录&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
client.makedirs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test06&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　makedirs(hdfs_path,permission=None)&lt;/p&gt;
&lt;p&gt;　　　　hdfs_path: 要创建目录&lt;/p&gt;
&lt;p&gt;　　　　permission：对创建的文件夹设置权限&lt;/p&gt;
&lt;h3&gt;　　rename—重命名&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;highlighter_449617&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.rename(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/new_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gyt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　rename(hdfs_path, local_path）&lt;/p&gt;
&lt;h3&gt;　delete—删除&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gyt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.delete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/new_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gyt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;highlighter_242521&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　delete(hdfs_path,recursive=False)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　　　recursive：删除文件和其子目录，设置为False如果不存在，则会抛出异常，默认为False&lt;/p&gt;
&lt;h3&gt;　upload——上传数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.upload(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/bigdata/hadoop/NOTICE.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/NOTICE.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NOTICE.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　upload(hdfs_path,local_path,overwrite=False,n_threads=1,temp_dir=None,&lt;/p&gt;
&lt;p&gt;　　　　chunk_size=65536,progress=None,cleanup=True,**kwargs)&lt;/p&gt;
&lt;p&gt;　　　　overwrite：是否是覆盖性上传文件&lt;/p&gt;
&lt;p&gt;　　　　n_threads：启动的线程数目&lt;/p&gt;
&lt;p&gt;　　　　temp_dir：当overwrite=true时，远程文件一旦存在，则会在上传完之后进行交换&lt;/p&gt;
&lt;p&gt;　　　　chunk_size：文件上传的大小区间&lt;/p&gt;
&lt;p&gt;　　　　progress：回调函数来跟踪进度，为每一chunk_size字节。它将传递两个参数，文件上传的路径和传输的字节数。一旦完成，-1将作为第二个参数&lt;/p&gt;
&lt;p&gt;　　　　cleanup：如果在上传任何文件时发生错误，则删除该文件&lt;/p&gt;
&lt;h3&gt;　　download——下载&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.download(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test/NOTICE.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/NOTICE.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; os.system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ls /home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
lost&lt;/span&gt;+&lt;span&gt;found  NOTICE.txt  thinkgamer
0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　download(hdfs_path,local_path,overwrite=False,n_threads=1,temp_dir=None,**kwargs)&lt;/p&gt;
&lt;p&gt;　　　　和上传的参数一样&lt;/p&gt;
&lt;h3&gt;　　read——读取文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; with client.read(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test/NOTICE.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as reader:
...     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; reader.read()
...
This product includes software developed by The Apache Software
Foundation (https:&lt;/span&gt;//www.apache.org/&lt;span&gt;).
 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;　　read(*args,**kwds)&lt;/p&gt;
&lt;p&gt;　　hdfs_path：hdfs路径&lt;/p&gt;
&lt;p&gt;　　offset：设置开始的字节位置&lt;/p&gt;
&lt;p&gt;　　length：读取的长度（字节为单位）&lt;/p&gt;
&lt;p&gt;　　buffer_size：用于传输数据的字节的缓冲区的大小。默认值设置在HDFS配置。&lt;/p&gt;
&lt;p&gt;　　encoding：制定编码&lt;/p&gt;
&lt;p&gt;　　chunk_size：如果设置为正数，上下文管理器将返回一个发生器产生的每一chunk_size字节而不是一个类似文件的对象&lt;/p&gt;
&lt;p&gt;　　delimiter：如果设置，上下文管理器将返回一个发生器产生每次遇到分隔符。此参数要求指定的编码。&lt;/p&gt;
&lt;p&gt;　　progress：回调函数来跟踪进度，为每一chunk_size字节（不可用，如果块大小不是指定）。它将传递两个参数，文件上传的路径和传输的字节数。称为一次与- 1作为第二个参数。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div id=&quot;highlighter_457657&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;10&quot;&gt;

&lt;p&gt;　　解决办法是：在配置文件hdfs-site.xml中加入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.permissions&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 重启集群&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


</description>
<pubDate>Wed, 24 Oct 2018 15:01:00 +0000</pubDate>
<dc:creator>dong66</dc:creator>
<og:description>HDFS hdfs的定义: Hadoop的分布式文件系统（HDFS）被设计成适合运行通用硬件上的分布式文件系统，它和现有的分布式文件系统有很多的共同点。但同时，它和其它的分布式文件系统的区别也是很明显</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songdongdong6/p/9846837.html</dc:identifier>
</item>
<item>
<title>Decorator模式（装饰器模式） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9846783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9846783.html</guid>
<description>&lt;h4 id=&quot;decorator模式&quot;&gt;Decorator模式？&lt;/h4&gt;
&lt;p&gt;假如现在有一块蛋糕，如果只涂上奶油，其他什么都不加，就是奶油蛋糕。如果加上草莓，就是草莓奶油蛋糕。如果再加上一块黑色巧克力板，上面用白色巧克力写上姓名，然后插上代表年龄的蜡烛，就变成了一块生日蛋糕&lt;br/&gt;&lt;strong&gt;像这样不断地为对象添加装饰的设计模式被称为Decorator模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单描述：一个基础共有的对象，你想赋予它什么责者那么你添加相关的职责修饰，这就是装饰器模式&lt;/li&gt;
&lt;li&gt;Java I/O 中使用适配器的：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224711956-398105312.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224715878-1300642282.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;理清职责&quot;&gt;理清职责&lt;/h4&gt;
&lt;p&gt;作用：对普通的字符串，通过加入边框进行描述&lt;br/&gt;名字============》》说明&lt;br/&gt;Display ||| 用于显示字符串的抽象类&lt;br/&gt;stringDisplay ||| 用于显示单行字符串的类&lt;br/&gt;Border ||| 用于显示装饰边框的抽象类&lt;br/&gt;sideBorder ||| 用于只显示左右边框的类&lt;br/&gt;Fu11Border ||| 用于显示上下左右边框的类&lt;br/&gt;Main ||| 测试程序行为的类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关系对象图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224722956-289640359.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224828851-1449443897.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class MainT {

    public static void main(String[] args) {

        Display display=new StringDisplay(&quot;hello decorator&quot;);

        display.show();

        Display display1=new SideBorder(display,'#');

        display1.show();

        Display fullBorder = new FullBorder(display1);

        fullBorder.show();

        Display display2=new SideBorder(
                new FullBorder(
                        new FullBorder(
                                new SideBorder(
                                        new FullBorder(
                                                new StringDisplay(&quot;Lets it go&quot;)
                                        ),
                                        '*'
                                )
                        )
                )
        ,'/');
        display2.show();



    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Display {

    // 获取横向字符数
    public abstract int getColumns();

    // 获取纵向行数
    public abstract int getRows();

    // 获取row行字符
    public abstract String getRowText(int row);

    // 显示
    public final void show(){
        for (int i = 0; i &amp;lt; getRows(); i++) {
            System.out.println(getRowText(i));
        }
    }

}


&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;StringDisplay&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public class StringDisplay extends Display {

    private String string;

    public StringDisplay(String string) {
        this.string = string;
    }

    @Override
    public int getColumns() {
        return string.getBytes().length;
    }

    @Override
    public int getRows() {
        return 1;
    }

    @Override
    public String getRowText(int row) {
        return row==0? string: null;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;FullBorder&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class FullBorder extends Border {


    public FullBorder(Display display) {
        super(display);
    }

    @Override
    public int getColumns() {
        return display.getColumns()+2;
    }

    @Override
    public int getRows() {
        return display.getRows()+2;
    }

    @Override
    public String getRowText(int row) {

        if(row==0)
            return &quot;+&quot;+makeLine(&quot;-&quot;,display.getColumns())+&quot;+&quot;;
        else if(row==display.getRows()+1)
            return &quot;+&quot;+makeLine(&quot;-&quot;,display.getColumns())+&quot;+&quot;;
        else
            return &quot;|&quot;+display.getRowText(row-1)+&quot;|&quot;;
    }

    private String makeLine(String s, int columns) {
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i &amp;lt; columns; i++) {
            buffer.append(s);
        }
        return buffer.toString();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;SideBorder&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class SideBorder extends Border {

    private char aChar;

    public SideBorder(Display display,char ch) {
        super(display);
        this.aChar=ch;

    }

    @Override
    public int getColumns() {
        return display.getColumns()+2;
    }

    @Override
    public int getRows() {
        return display.getRows();
    }

    @Override
    public String getRowText(int row) {
        return aChar+display.getRowText(row)+aChar;
    }
}


&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Oct 2018 14:49:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Decorator模式？ 假如现在有一块蛋糕，如果只涂上奶油，其他什么都不加，就是奶油蛋糕。如果加上草莓，就是草莓奶油蛋糕。如果再加上一块黑色巧克力板，上面用白色巧克力写上姓名，然后插上代表年龄的蜡烛</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9846783.html</dc:identifier>
</item>
<item>
<title>HTTPS（SSL / TLS）免费证书申请及网站证书部署实战总结 - 其善-从之</title>
<link>http://www.cnblogs.com/RoyalBlue/p/9843218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RoyalBlue/p/9843218.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;服务器环境：windows server 2008  +  tomcat7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;废话不多说，先看部署效果：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024134418322-1205631103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024134750098-2107395261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 一、免费证书申请&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/&quot; target=&quot;_blank&quot;&gt;Let's Encrypt&lt;/a&gt;  简介：let's Encrypt 是一个免费的开放的非盈利证书颁发机构，&lt;span&gt;截至2018年7月底，Let's Encrypt root（ISRG Root X1）直接受到Microsoft产品的信任。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前受到所有主要root程序的信任，包括Microsoft，Google，Apple，Mozilla，Oracle和Blackberry&lt;/span&gt;。即所有主流操作系统环境及浏览器均已信任该机构颁发的证书。&lt;/p&gt;
&lt;p&gt;******************************************************************&lt;/p&gt;
&lt;p&gt;根据官方的要求，我们在VPS、服务器上部署Let's Encrypt免费SSL证书之前，需要系统支持Python2.7以上版本以及支持GIT工具。这种方式没有研究过，有兴趣的&lt;/p&gt;
&lt;p&gt;小伙伴可以研究下。&lt;/p&gt;
&lt;p&gt;这里我们采用LEGainer - windows下Let's Encrypt证书申请工具来申请证书（申请成功的前提是网址能通过域名正常访问，如果还没有搭建好网址，可以先搭建网址，再申请ssl证书）&lt;/p&gt;
&lt;p&gt;第一步：工具下载地址：&lt;a href=&quot;https://pan.baidu.com/s/1BVKwXccF7m2AkDWgWh480A&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1BVKwXccF7m2AkDWgWh480A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二步：解压工具，修改配置&lt;/p&gt;
&lt;p&gt;         解压文件后打开LEGainer.exe.config 修改配置节点&lt;/p&gt;
&lt;p&gt;        如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024211640274-728163182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Mail：是你的联系邮箱&lt;/p&gt;
&lt;p&gt;　　Domain：是你要申请证书的域名&lt;/p&gt;
&lt;p&gt;　　WebDir：是你网站的本地目录，LEGainer在申请证书过程中会在此目录生成文件，Let's Encrypt会通过域名访问生成的文件，所以请确保域名正确解析和绑定。&lt;/p&gt;
&lt;p&gt;　　CertificateSaveDir：是证书申请下来后的保存目录。&lt;/p&gt;
&lt;p&gt;　　PFXPassword：是pfx证书的密码。&lt;/p&gt;
&lt;p&gt;第三步：在域名所在的主机，运行LEGainer.exe 生成证书；&lt;/p&gt;
&lt;p&gt;       出现“success!~Enter press any key exit!”字样时，证书就生成成功了。&lt;/p&gt;
&lt;p&gt;       假设你申请证书的域名为：www.travellight.xyz，那么LEGainer会生成如下几个证书文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024213156154-501815060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　_certificate.der  是证书文件，der格式&lt;/p&gt;
&lt;p&gt;　　_certificate.pem  是证书pem格式&lt;/p&gt;
&lt;p&gt;　　_csr.pem  是证书签名请求文件&lt;/p&gt;
&lt;p&gt;　　_key.pem  是私钥文件&lt;/p&gt;
&lt;p&gt;　　_pkcs12.pfx  是iis用的存放证书和私钥的文件&lt;/p&gt;
&lt;p&gt;　　_chain.pem  是证书链&lt;/p&gt;
&lt;p&gt;第四步：合成tomcat需要的.jks证书&lt;/p&gt;
&lt;p&gt;　　这里我采用在线生成 当然也可以自己用工具生成&lt;/p&gt;
&lt;p&gt;　　在线合成地址：&lt;a href=&quot;https://www.myssl.cn/tools/merge-jks-cert.html&quot; target=&quot;_blank&quot;&gt;https://www.myssl.cn/tools/merge-jks-cert.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　密钥文件(KEY文件)：www.travellight.xyz_key.pem&lt;/p&gt;
&lt;p&gt;　　证书文件(CRT/CER文件):www.travellight.xyz_certificate.pem&lt;br/&gt;       合成时需填写JKS密码（一定要记住，tomcat配置中需要填写），合成后会生成JKS文件  我生成的是 travellight.jks&lt;/p&gt;
&lt;p&gt;第五步：将travellight.jks 文件拷贝至服务器tomcat conf 目录中，修改tomcat配置&lt;/p&gt;
&lt;p&gt;　　打开 tomcat/conf 目录下server.xml文件修改配置：&lt;/p&gt;
&lt;p&gt;       （1）一般tomcat7中该段配置默认是注释掉的，去掉注释，按如下添加配置并将默认端口8443改为443（修改原因：实测如果使用8443作为ssl端      　　　　　　                                     口,http[http://www.travellight.xyz]重定向时浏览器网址栏中会在域名后带上8443端口如：https://www.travellight.xyz:8443,&lt;/p&gt;
&lt;p&gt;　　　　直接用https://www.travellight.xyz无法访问网站，使用443端口则不存在此问题）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024221104728-578416542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（2）修改以下两处重定向端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024220613984-386063318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024220652646-2133397434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第六步： 开启443外网端口&lt;/p&gt;
&lt;p&gt;　　如果不开启443端口，则无法使用https证书功能，我使用的是阿里云服务器ECS，通过管理控制台-安全组规则可开放外网端口，&lt;/p&gt;
&lt;p&gt;　　如果是其他云服务器或自己的路由器请自行搜索开启外网端口方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024223230164-1079219597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第七步： 重启tomcat,浏览器访问网址&lt;/p&gt;
&lt;p&gt;　　前缀自动显示为https.谷歌浏览器地址栏中有个锁的图标&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891645/201810/891645-20181024221317459-2118340208.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;       至此完成！！！&lt;/p&gt;

&lt;p&gt;**************************************************************&lt;/p&gt;
&lt;p&gt;  参考内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/&quot; target=&quot;_blank&quot;&gt;https://letsencrypt.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laozuo.org/7676.html&quot; target=&quot;_blank&quot;&gt;http://www.laozuo.org/7676.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/asminfo/p/6801558.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/asminfo/p/6801558.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/l_ai_yi/article/details/81671946&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/l_ai_yi/article/details/81671946&lt;/a&gt;&lt;/p&gt;








</description>
<pubDate>Wed, 24 Oct 2018 14:40:00 +0000</pubDate>
<dc:creator>其善-从之</dc:creator>
<og:description>服务器环境：windows server 2008 + tomcat7 废话不多说，先看部署效果： 一、免费证书申请 Let's Encrypt 简介：let's Encrypt 是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RoyalBlue/p/9843218.html</dc:identifier>
</item>
<item>
<title>Java入门系列-20-异常 - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/9846642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/9846642.html</guid>
<description>&lt;h2 id=&quot;为什么要进行异常处理&quot;&gt;为什么要进行异常处理&lt;/h2&gt;
&lt;p&gt;下面这段代码能否正常执行&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DemoCalc {
    public static void main(String[] args) {
        int a=0;
        int b=0;
        int c=a/b;
        System.out.println(&quot;运算结果为:&quot;+c);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是我们在控制台中看到一段错误提示，那是因为除数不能为0。异常就是在程序运行过程中发生的不正常事件，会&lt;strong&gt;中断运行的程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Java 使用了异常处理机制为程序提供了错误处理的能力，在程序中预先设置好对付异常的处理办法，待程序发生异常时对异常进行处理，处理完毕后，程序便可以继续运行。&lt;/p&gt;
&lt;p&gt;下面来看一下Java中是如何进行异常处理的&lt;/p&gt;
&lt;h2 id=&quot;如何进行异常处理&quot;&gt;如何进行异常处理&lt;/h2&gt;
&lt;p&gt;Java 的异常处理是通过5个关键字实现的：try、catch、finally、throw、throws&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;try&lt;/td&gt;
&lt;td&gt;执行可能产生异常的代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;catch&lt;/td&gt;
&lt;td&gt;捕获异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;finally&lt;/td&gt;
&lt;td&gt;无论是否发生异常，代码总能执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;throws&lt;/td&gt;
&lt;td&gt;声明方法要抛出的异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;throw&lt;/td&gt;
&lt;td&gt;手动抛出异常&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;常见异常及异常分类&quot;&gt;常见异常及异常分类&lt;/h3&gt;
&lt;p&gt;Throwable 是Java 中所有错误和异常的父类&lt;/p&gt;
&lt;p&gt;Error类：Throwable的子类，仅靠程序本身无法恢复的严重的错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exception&lt;/strong&gt;类：Throwable的子类，由Java应用程序抛出和处理的非严重错误&lt;/p&gt;
&lt;p&gt;RuntimeException类：Exception的子类，运行时异常，不要求程序必须做出处理。&lt;/p&gt;
&lt;p&gt;Checked异常：Exception的子类，程序必须处理该类异常。&lt;/p&gt;
&lt;p&gt;常见异常类型&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Exception&lt;/td&gt;
&lt;td&gt;异常层次结构的父类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ArithmeticException&lt;/td&gt;
&lt;td&gt;算数错误情形，如以零作除数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ArrayIndexOutOfBoundsException&lt;/td&gt;
&lt;td&gt;数组下标越界&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NullPointerException&lt;/td&gt;
&lt;td&gt;尝试访问null对象成员&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ClassNotFoundException&lt;/td&gt;
&lt;td&gt;不能加载所需的类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IllegalArgumentException&lt;/td&gt;
&lt;td&gt;方法接收到非法参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ClassCastException&lt;/td&gt;
&lt;td&gt;对象强制类型转换出错&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NumberFormatException&lt;/td&gt;
&lt;td&gt;数字格式转换异常，如把&quot;abc&quot;转换成数字&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;try-catch&quot;&gt;try-catch&lt;/h3&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void method(){
    try{
        //代码段1
        //可能产生异常的代码段
        //代码段2
    }catch(异常类型 ex){
        //对异常进行处理的代码段
    }
    //代码段
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;try-catch块捕获异常有三种情况：&lt;/p&gt;
&lt;p&gt;1、try块中没有任何异常，try中正常，catch不会执行，正常执行try-catch后的代码。&lt;/p&gt;
&lt;p&gt;2、try块中可能发生异常的代码段发生异常，代码段2不会执行，而是执行catch中异常处理的代码，正常执行try-catch后的代码。&lt;/p&gt;
&lt;p&gt;catch中异常类型的printStackTrace() 方法能进行堆栈跟踪显示出程序运行到当前类的执行流程，异常堆栈信息中包含了异常的类型及异常出现的位置。&lt;/p&gt;
&lt;p&gt;3、异常类型不匹配，程序将中断。比如try产生的异常为ArithmeticException，catch却用了 ClassCastException。&lt;/p&gt;
&lt;p&gt;在控制台中接收数字做除法运算&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Scanner;

public class DemoInput {
    public static void main(String[] args) {
        Scanner input=new Scanner(System.in);
        try{
            System.out.println(&quot;请输入被除数(整数)：&quot;);
            int a=input.nextInt();
            System.out.println(&quot;请输入除数(整数)：&quot;);
            int b=input.nextInt();
            int c=a/b;
            System.out.println(&quot;结果：&quot;+c);
        }catch(Exception ex) {
            ex.printStackTrace();
        }
        System.out.println(&quot;程序结束&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;try-catch-finally&quot;&gt;try-catch-finally&lt;/h3&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void method(){
    try{
        //可能会发生异常的代码
    }catch(异常类型 ex){
        //异常处理
    }finally{
        //无论如何都要执行的代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;finally块：是否发生异常都执行&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;finllay块不执行的唯一情况：之前的代码中执行了 System.exit(1); 退出虚拟机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;try-catch-finally的使用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.FileNotFoundException;
import java.util.Scanner;

public class DemoInput {
    public static void main(String[] args) {
        Scanner input=new Scanner(System.in);
        try{
            System.out.println(&quot;请输入被除数(整数)：&quot;);
            int a=input.nextInt();
            System.out.println(&quot;请输入除数(整数)：&quot;);
            int b=input.nextInt();
            int c=a/b;
            System.out.println(&quot;结果：&quot;+c);
        }catch(Exception ex) {
            ex.printStackTrace();
        }finally {
            System.out.println(&quot;感谢您的使用&quot;);
        }
        System.out.println(&quot;程序结束&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在try块或catch块中有return语句，finally是否还会执行？运行下面代码断点调试观察结果。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestReturn {

    public static void main(String[] args) {
        try {
            int a=1+1;
            System.out.println(&quot;try执行&quot;);
            return;
        } catch (Exception e) {
            System.out.println(&quot;catch执行&quot;);
        }finally {
            System.out.println(&quot;finally执行&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;try块或catch块中可以有return语句，如果有return语句会先执行finally最后再执行return。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;多重catch&quot;&gt;多重catch&lt;/h3&gt;
&lt;p&gt;try块中可能会发生多种异常，如果要不同的异常进行不同的处理，需要使用多重catch进行处理。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void method(){
    try{
        //可能发生异常的代码段
    }catch(异常类型1 e){
        //对异常类型1进行的处理的代码段
    }catch(异常类型2 e){
        //对异常类型2进行的处理的代码段
    }catch(异常类型n e){
        //对异常类型n进行的处理的代码段
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当try块中发生异常后，会逐个与catch中的异常类型进行匹配，匹配成功后，进入对应的catch进行异常处理，处理完成后不再进入其他catch，程序继续执行。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;排列catch语句的顺序是：先子类后父类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;发生异常时按顺序逐个匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只执行第一个与异常类型匹配的catch语句&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将之前的代码 DemoInput.java 改造成多重catch&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.FileNotFoundException;
import java.util.InputMismatchException;
import java.util.Scanner;

public class DemoInput {
    public static void main(String[] args) {
        Scanner input=new Scanner(System.in);
        try{
            System.out.println(&quot;请输入被除数(整数)：&quot;);
            int a=input.nextInt();
            System.out.println(&quot;请输入除数(整数)：&quot;);
            int b=input.nextInt();
            int c=a/b;
            System.out.println(&quot;结果：&quot;+c);
        }catch(InputMismatchException e) {
            System.out.println(&quot;输入的数有误！&quot;);
        }catch(ArithmeticException e) {
            System.out.println(&quot;除数不能为0&quot;);
        }catch(Exception ex) {
            System.out.println(&quot;发生未知异常&quot;);
        }finally {
            System.out.println(&quot;感谢您的使用&quot;);
        }
        System.out.println(&quot;程序结束&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;声明异常-throws&quot;&gt;声明异常 throws&lt;/h3&gt;
&lt;p&gt;如果一个方法体内抛出了异常如何通知调用者，可以在方法上声明异常。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class TestThrows {
    
    //声明异常，多个异常可以用逗号隔开
    public void test()throws Exception,ClassNotFoundException{
        //可能会发生异常的代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理方式一：调用者处理异常&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    TestThrows t=new TestThrows();
    try {
        t.test();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理方式二：调用者继续声明异常&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws ClassNotFoundException, Exception {
    TestThrows t=new TestThrows();
    t.test();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;main方法继续声明异常，调用者就变成虚拟机了，发生异常则按默认方式处理，打印出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;抛出异常-throw&quot;&gt;抛出异常 throw&lt;/h3&gt;
&lt;p&gt;除了系统自动抛出的异常外，有些问题需要程序员自行抛出异常&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestThrow {
    public void inputAge(int age) throws Exception {
        if (age&amp;lt;1) {
            throw new Exception(&quot;还有这种年龄？&quot;);
        }
    }
    
    public static void main(String[] args) {
        TestThrow t=new TestThrow();
        try {
            t.inputAge(-1);
        } catch (Exception e) {
            System.out.println(&quot;年龄有误：&quot;+e.getMessage());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;自行抛出异常后，还需要在方法上声明异常&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 24 Oct 2018 14:26:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>为什么要进行异常处理 下面这段代码能否正常执行 结果是我们在控制台中看到一段错误提示，那是因为除数不能为0。异常就是在程序运行过程中发生的不正常事件，会 中断运行的程序 。 Java 使用了异常处理机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/9846642.html</dc:identifier>
</item>
<item>
<title>填坑：Java 中的日期转换 - 一只阿木木</title>
<link>http://www.cnblogs.com/yizhiamumu/p/9846609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yizhiamumu/p/9846609.html</guid>
<description>&lt;p data-source-line=&quot;2&quot;&gt;我们之前讨论过时间，在Java 中有一些方法会出现横线？比如Date 过期方法。&lt;/p&gt;
&lt;p data-source-line=&quot;2&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;2&quot;&gt;参考文章：&lt;a href=&quot;https://www.cnblogs.com/yizhiamumu/p/9075468.html/&quot; target=&quot;_blank&quot;&gt;知识点：java一些方法会有横线？以Date 过期方法为例&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;java中的日期和时间处理方法&quot; data-source-line=&quot;6&quot;&gt;Java中的日期和时间处理方法&lt;/h3&gt;
&lt;ul data-source-line=&quot;7&quot;&gt;&lt;li&gt;Date类（官方不再推荐使用,官方解释Date类不利于国际化，推荐使用Calendar类）&lt;/li&gt;
&lt;li&gt;Calendar类&lt;/li&gt;
&lt;li&gt;DateFormat类 使用此类来时间初始化&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;13&quot;&gt;我们发现，时间toLocalString 会有横线：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vo.setSubmitDate(&lt;span&gt;new&lt;/span&gt; Date().toLocaleString());
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;18&quot;&gt;可以改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vo.setSubmitDate(&lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT+08:00&quot;)).getTime()));
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;23&quot;&gt;在最近的项目中，用SimpleDateFormat出现一些奇奇怪怪的BUG：&lt;/p&gt;
&lt;ul data-source-line=&quot;25&quot;&gt;&lt;li&gt;1.结果值不对：转换的结果值经常和预期不同。&lt;/li&gt;
&lt;li&gt;2.内存泄漏: 由于转换的结果值不对，后续的一些操作会导致系统内存泄漏，频繁触发GC（垃圾回收），造成系统不可用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;1-什么是simpledateformat&quot; data-source-line=&quot;28&quot;&gt;1 什么是SimpleDateFormat&lt;/h3&gt;
&lt;p data-source-line=&quot;30&quot;&gt;在java doc对SimpleDateFormat的解释如下:&lt;/p&gt;
&lt;p data-source-line=&quot;32&quot;&gt;SimpleDateFormatis a concrete class for formatting and parsing dates in a locale-sensitive manner. It allows for formatting(date → text), parsing (text → date), and normalization.&lt;/p&gt;
&lt;p data-source-line=&quot;34&quot;&gt;SimpleDateFormat是一个用来对位置敏感的格式化和解析日期的实体类。他允许把日期格式化成text，把text解析成日期和规范化。&lt;/p&gt;
&lt;h4 id=&quot;11-使用simpledateformat&quot; data-source-line=&quot;36&quot;&gt;1.1 使用SimpleDateFormat&lt;/h4&gt;
&lt;p data-source-line=&quot;38&quot;&gt;simpleDateFormat的使用方法比较简单:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception { 

    SimpleDateFormat simpleDateFormat &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-mm-dd  HH:mm:ss&quot;&lt;span&gt;);

    System.out.println(simpleDateFormat.format(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date())); 

    System.out.println(simpleDateFormat.parse(&lt;/span&gt;&quot;2018-10-24  12:10:24&quot;&lt;span&gt;)); 
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul data-source-line=&quot;52&quot;&gt;&lt;li&gt;1.定义一个日期&quot;yyyy-mm-dd HH:mm:ss&quot;的pattern, 也就是我们这个simpleDateFormat不管是格式化还是解析都需要按照这个pattern。&lt;/li&gt;
&lt;li&gt;2.对于format需要传递Date的对象，会返回一个String类型，这个String会按照我们上面的格式生成。&lt;/li&gt;
&lt;li&gt;3.对于parse需要传递一个按照上面pattern的字符串，如果传递错误的pattern会抛出java.text.ParseException异常，如果传递正确的会生成一个Date对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;56&quot;&gt;附：格式占位符 G 年代标志符 y 年 M 月 d 日 h 时 在上午或下午 (1~12) H 时 在一天中 (0~23) m 分 s 秒 S 毫秒 E 星期 D 一年中的第几天 F 一月中第几个星期几 w 一年中第几个星期 W 一月中第几个星期 a 上午 / 下午 标记符 k 时 在一天中 (1~24) K 时 在上午或下午 (0~11) z 时区复制代码&lt;/p&gt;
&lt;p data-source-line=&quot;58&quot;&gt;回到我们遇到的坑：&lt;/p&gt;
&lt;h5 id=&quot;2-为什么simpledateformat会线程不安全呢&quot; data-source-line=&quot;59&quot;&gt;2 为什么SimpleDateFormat会线程不安全呢？&lt;/h5&gt;
&lt;p data-source-line=&quot;61&quot;&gt;在SimpleDateFormat源码中,所有的格式化和解析都需要通过一个中间对象Calendar进行转换，而这将会出现线程不安全的操作&lt;/p&gt;
&lt;p data-source-line=&quot;63&quot;&gt;比如当多个线程操作同一个Calendar的时候后来的线程会覆盖先来线程的数据，那最后其实返回的是后来线程的数据，这样就导致我们上面所述的BUG的产生&lt;/p&gt;
&lt;h5 id=&quot;为什么会出现这么多问题呢&quot; data-source-line=&quot;66&quot;&gt;为什么会出现这么多问题呢？&lt;/h5&gt;
&lt;p data-source-line=&quot;68&quot;&gt;因为SimpleDateFormat线程不安全，很多人都会写个Util类，然后把SimpleDateFormat定义成全局的一个常量，所有线程都共享这个常量:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleDateFormat dayFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Date formatDate(String date) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ParseException {

    returndayFormat.parse(date);
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;3如何避坑&quot; data-source-line=&quot;82&quot;&gt;3.如何避坑&lt;/h3&gt;
&lt;p data-source-line=&quot;84&quot;&gt;对于SimpleDateFormat的解决方法有下面几种:&lt;/p&gt;
&lt;h4 id=&quot;31-新建simpledateformat&quot; data-source-line=&quot;86&quot;&gt;3.1 新建SimpleDateFormat&lt;/h4&gt;
&lt;p data-source-line=&quot;88&quot;&gt;原因：所有线程都共用一个SimpleDateFormat，&lt;/p&gt;
&lt;p data-source-line=&quot;90&quot;&gt;解决办法：每次使用的时候都创建一个新的SimpleDateFormat,我们可以在DateUtils中将创建SimpleDateFormat放在方法内部:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Date formatDate(String date) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ParseException { 

    SimpleDateFormat dayFormat &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dayFormat.parse(date);
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;102&quot;&gt;上面这个方法虽然能解决我们的问题但是引入了另外一个问题就是，如果这个方法使用量比较大，有可能会频繁造成Young gc，整个系统还是会受一定的影响。&lt;/p&gt;
&lt;h4 id=&quot;32-使用threadlocal&quot; data-source-line=&quot;104&quot;&gt;3.2 使用ThreadLocal&lt;/h4&gt;
&lt;p data-source-line=&quot;106&quot;&gt;使用ThreadLocal能避免造成Young gc，我们对每个线程都使用ThreadLocal进行保存&lt;/p&gt;
&lt;p data-source-line=&quot;108&quot;&gt;由于ThreadLocal是线程之间隔离开的，所以不会出现线程安全问题:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal simpleDateFormatThreadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Date formatDate(String date) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ParseException { 

    SimpleDateFormat dayFormat &lt;/span&gt;=&lt;span&gt; getSimpleDateFormat();
    returndayFormat.parse(date); 
    
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SimpleDateFormatgetSimpleDateFormat() {     
    SimpleDateFormat simpleDateFormat &lt;/span&gt;=&lt;span&gt; simpleDateFormatThreadLocal.get();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(simpleDateFormat == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){ 
    
    simpleDateFormat &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-mm-dd  HH:mm:ss&quot;&lt;span&gt;) simpleDateFormatThreadLocal.set(simpleDateFormat); 
        
    }
    
    returnsimpleDateFormat; 
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;33使用第三方工具包&quot; data-source-line=&quot;134&quot;&gt;3.3使用第三方工具包&lt;/h4&gt;
&lt;p data-source-line=&quot;136&quot;&gt;虽然上面的ThreadLocal能解决我们出现的问题，但是第三方工具包提供的功能更加强大,在java中有两个类库比较出名一个是Joda-Time，一个是Apache common包&lt;/p&gt;
&lt;h5 id=&quot;331-joda-time推荐&quot; data-source-line=&quot;138&quot;&gt;3.3.1 Joda-Time(推荐)&lt;/h5&gt;
&lt;p data-source-line=&quot;140&quot;&gt;Joda-Time 令时间和日期值变得易于管理、操作和理解。对于我们复杂的操作都可以使用Joda-Time操作，下面我列举两个例子,对于把日期加上90天，如果使用原生的Jdk我们需要这样写:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Calendar calendar = Calendar.getInstance();calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0);SimpleDateFormat sdf = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;E MM/dd/yyyy HH:mm:ss.SSS&quot;&lt;span&gt;);

calendar.add(Calendar.DAY\_OF\_MONTH, &lt;/span&gt;90&lt;span&gt;);

System.out.println(sdf.format(calendar.getTime()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;149&quot;&gt;但是在我们的joda-time中只需要两句话，并且api也比较通俗易懂，所以你为什么不用Joda-Time呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
DateTime dateTime = &lt;span&gt;new&lt;/span&gt; DateTime(2000, 1, 1, 0, 0, 0, 0&lt;span&gt;);

System.out.println(dateTime.plusDays(&lt;/span&gt;90).toString(&quot;E MM/dd/yyyy HH:mm:ss.SSS&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;332-common-lang包&quot; data-source-line=&quot;156&quot;&gt;3.3.2 common-lang包&lt;/h5&gt;
&lt;p data-source-line=&quot;158&quot;&gt;在common-lang包中有个类叫FastDateFormat，由于common-lang这个包基本被很多Java项目都会引用，所以你可以不用专门去引用处理时间包，即可处理时间，在FastDateFormat中每次处理时间的时候会创建一个calendar,使用方法比较简单代码如下所示:&lt;/p&gt;
&lt;p data-source-line=&quot;160&quot;&gt;FastDateFormat.getInstance().format(new Date());&lt;/p&gt;
&lt;h5 id=&quot;34升级jdk8推荐&quot; data-source-line=&quot;162&quot;&gt;3.4升级jdk8(推荐)&lt;/h5&gt;
&lt;p data-source-line=&quot;164&quot;&gt;在java8中Date这个类中的很多方法包括构造方法都被打上了@Deprecated废弃的注解，取而代之的是LocalDateTime,&lt;/p&gt;
&lt;p data-source-line=&quot;166&quot;&gt;LocalDate LocalTime这三个类：&lt;/p&gt;
&lt;ul data-source-line=&quot;168&quot;&gt;&lt;li&gt;LocalDate无法包含时间；&lt;/li&gt;
&lt;li&gt;LocalTime无法包含日期；&lt;/li&gt;
&lt;li&gt;LocalDateTime才能同时包含日期和时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;172&quot;&gt;知识点：Java8 在日期的格式化和解析方面不用考虑线程安全性&lt;/p&gt;
&lt;p data-source-line=&quot;174&quot;&gt;代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String formatTime(LocalDateTime time,String pattern) {

returntime.format(DateTimeFormatter.ofPattern(pattern)); 
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;184&quot;&gt;localDateTime不仅解决了线程安全的问题，同样也提供了一些其他的运算比如加减天数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期加上一个数,根据field不同加不同值,field为ChronoUnit.* &lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LocalDateTime plus(LocalDateTime time, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; number, TemporalUnit field) {

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; time.plus(number, field); 
    
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期减去一个数,根据field不同减不同值,field参数为ChronoUnit.* &lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LocalDateTime minu(LocalDateTime time, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; number, TemporalUnit field){

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; time.minus(number,field); 
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;延伸&quot; data-source-line=&quot;204&quot;&gt;延伸&lt;/h5&gt;
&lt;p data-source-line=&quot;205&quot;&gt;使用LocalDateTime 会改变现有的代码，我们可以将他们两进行互转:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Date转换为LocalDateTime &lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LocalDateTime convertDateToLDT(Date date) {

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()); 
    
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LocalDateTime转换为Date &lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Date convertLDTToDate(LocalDateTime time) {
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Date.from(time.atZone(ZoneId.systemDefault()).toInstant()); 
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;224&quot;&gt;【公众号】：一只阿木木&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 14:21:00 +0000</pubDate>
<dc:creator>一只阿木木</dc:creator>
<og:description>我们之前讨论过时间，在Java 中有一些方法会出现横线？比如Date 过期方法。 参考文章：知识点：java一些方法会有横线？以Date 过期方法为例 Java中的日期和时间处理方法 Date类（官方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yizhiamumu/p/9846609.html</dc:identifier>
</item>
<item>
<title>终于明白了 C# 中  Task.Yield 的用途 - dudu</title>
<link>http://www.cnblogs.com/dudu/p/task-yield.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dudu/p/task-yield.html</guid>
<description>&lt;p&gt;最近在阅读 &lt;a href=&quot;http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/&quot;&gt;.NET Threadpool starvation, and how queuing makes it worse&lt;/a&gt; 这篇博文时发现文中代码中的一种 Task 用法之前从未见过，在网上看了一些资料后也是云里雾里不知其解，很是困扰。今天在程序员节的大好日子里终于想通了，于是写下这篇随笔分享给大家，也过过专心写博客的瘾。&lt;/p&gt;
&lt;p&gt;这种从未见过的用法就是下面代码中的 &lt;code&gt;await Task.Yield()&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static async Task Process()
{
    await Task.Yield();

    var tcs = new TaskCompletionSource&amp;lt;bool&amp;gt;();

    Task.Run(() =&amp;gt;
    {
        Thread.Sleep(1000);
        tcs.SetResult(true);
    });

    tcs.Task.Wait();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（注：上面的代码不是示例，只是因为这段代码而初遇 await Task.Yield）&lt;/p&gt;
&lt;p&gt;Task.Yield 简单来说就是创建时就已经完成的 Task ，或者说执行时间为0的 Task ，或者说是空任务，也就是在创建时就将 Task 的 IsCompeted 值设置为0。&lt;/p&gt;
&lt;p&gt;那 await 一个空任务会怎样？我们知道在 await 时会释放当前线程，等所 await 的 Task 完成时会从线程池中申请新的线程继续执行 await 之后的代码，这本来是为了解决异步操作（比如IO操作）霸占线程实际却用不到线程的问题，而 Task.Yield 却产生了一个不仅没有异步操作而且什么也不干的 Task ，不是吃饱了撑着吗？&lt;/p&gt;
&lt;p&gt;今天吃晚饭的时候终于想明白了——吃饱了没有撑。Task.Yield 产生的空任务仅仅是为 await 做嫁衣，而真正的图谋是借助 await 实现线程的切换，让 await 之后的操作重新排队从线程池中申请线程继续执行。这样做有什么好处呢？线程是非常非常宝贵的资源，千金难买一线程，而且有优先级，提高线程利用率的重要手段之一就是及时将线程分配给最需要的地方，而最奢侈的之一是让一个优先级低执行时间长的操作一直占用着一个线程，await Task.Yield 可以让你巧妙地借助 await 的线程切换能力，将不太重要的比较耗时的操作放在新的线程（重新排队从线程池中申请到的线程）中执行。打个比方，很多人排队在外婆家就餐，你来的时候比较巧，正好有位置，但你本来就不着急肚子也不太饿准备慢慢吃慢慢聊，而排队的人当中有些人很饿很着急吃完还有事，这时你如果先点几个招牌菜解解馋，然后将座位让出来，重新排队，并且排队的人当中像你这样的都这么做，那些排队中心急如焚的人真是是幸福感爆棚，外婆家的老板也笑弯了腰。你让出座位重新排队的爱心行为就是 &lt;code&gt;await Task.Yield()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;祝大家程序员节快乐！&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 14:19:00 +0000</pubDate>
<dc:creator>dudu</dc:creator>
<og:description>最近在阅读 .NET Threadpool starvation, and how queuing makes it worse 这篇博文时发现文中代码中的一种 Task 用法之前从未见过，在网上看了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dudu/p/task-yield.html</dc:identifier>
</item>
</channel>
</rss>