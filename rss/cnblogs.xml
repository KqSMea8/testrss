<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>clang的线程安全分析模块 thread safety analysis - jicanghai</title>
<link>http://www.cnblogs.com/jicanghai/p/9472001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jicanghai/p/9472001.html</guid>
<description>&lt;p&gt;线程安全分析&lt;/p&gt;

&lt;p&gt;介绍&lt;/p&gt;
&lt;p&gt;Clang的线程安全分析模块是C++语言的一个扩展，能对代码中潜在的竞争条件进行警告。这种分析是完全静态的（即编译时进行），没有运行时的消耗。当前这个功能还在开发中，但它已经具备了足够的成熟度，可以被部署到生产环境中。它由Google开发，同时受到CERT（United States Computer Emergency Readiness Team，美国互联网应急中心）/SEI（Software Engineering Institute，软件工程中心）的协助，并在Google的内部代码中被广泛应用。&lt;/p&gt;
&lt;p&gt;对于多线程的程序来说，线程安全分析很像一个类型系统。在一个多线程的环境中，程序员除了可以声明一个数据的类型（比如，int, float等）之外，还可以声明对数据的访问是如何被控制的。例如，如果变量foo受到互斥锁mu的监控，那么如果如果一段代码在读或者写foo之前没有加锁，就会发出警告。同样，如果一段仅应被GUI线程访问的代码被其它线程访问了，也会发出警告。&lt;/p&gt;

&lt;p&gt;入门&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mutex.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BankAccount {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
  Mutex mu;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;   balance GUARDED_BY(mu);

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; depositImpl(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount) {
    balance &lt;/span&gt;+= amount;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; WARNING! Cannot write balance without locking mu.&lt;/span&gt;
&lt;span&gt;  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; withdrawImpl(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount) REQUIRES(mu) {
    balance &lt;/span&gt;-= amount;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OK. Caller must have locked mu.&lt;/span&gt;
&lt;span&gt;  }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; withdraw(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount) {
    mu.Lock();
    withdrawImpl(amount);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OK.  We've locked mu.&lt;/span&gt;
  }                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; WARNING!  Failed to unlock mu.&lt;/span&gt;

  &lt;span&gt;void&lt;/span&gt; transferFrom(BankAccount&amp;amp; b, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount) {
    mu.Lock();
    b.withdrawImpl(amount);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; WARNING!  Calling withdrawImpl() requires locking b.mu.&lt;/span&gt;
    depositImpl(amount);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OK.  depositImpl() has no requirements.&lt;/span&gt;
&lt;span&gt;    mu.Unlock();
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这段代码说明了线程安全分析背后的基本概念。GUARDED_BY属性声明，一个线程在读或写balance变量之前，必须先锁住mu，由此保证对balance的增加和降低操作都是原子的。同样，REQUIRES声明了在调用线程调用withdrawImpl方法之前，必须先锁住mu。因为调用者已经在方法调用之前锁住了mu，因此在方法体内部修改balance就是安全的了。&lt;/p&gt;
&lt;p&gt;depositeImpl方法没有REQUIRES生命，因此分析模块给出了一个警告。线程安全分析模块并不是进程内部的，因此对调用者的需求必须被显式的声明。在transferFrom方法内部也有一个警告，因为尽管方法锁住了this-&amp;gt;mu，它没有锁住b.mu，分析模块知道这是两个不同的锁，分属两个不同的对象。&lt;/p&gt;
&lt;p&gt;最后，在withdraw方法内部也有一个警告，因为它没有解锁mu。每一个上锁操作必须有一个配对的解锁操作，分析模块将检测成对的上锁和解锁操作。一个函数可以仅上锁而不解锁（反之亦然），但这必须被显式标注（使用ACQUIRE/RELEASE）。&lt;/p&gt;

&lt;p&gt;运行分析&lt;/p&gt;
&lt;p&gt;为了运行分析模块，只需要加入编译选项 -Wthread-safety，比如&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
clang -c -Wthread-safety example.&lt;span&gt;cpp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;注意，这段代码假设已经有一个正确的标注文件mutex.h存在，这个文件中声明了哪个方法执行了上锁、解锁的操作。&lt;/p&gt;

&lt;p&gt;基本概念：监护权&lt;/p&gt;
&lt;p&gt;线程安全分析提供了一种使用“监护权”保护资源的方法。“资源”可以是数据成员，或者可以访问底层资源的过程或方法。分析模块保证了，除非调用者线程拥有了对于资源的监护权（调用一个方法，或者读/写一个数据），否则它是无法访问到资源的。监护权被绑定到一些具名的C++对象上，这些对象声明了专用的方法来获取和释放监护权。这些对象的名称被用来识别监护权。最常见的例子就是互斥锁。例如，如果mu是一个互斥锁，那么调用mu.Lock()使得调用者线程拥有了mu所保护的数据的监护权。同样的，调用mu.Unlock()释放监护权。&lt;/p&gt;
&lt;p&gt;线程可以排他的或者共享的拥有监护权。一个排他的监护权每次仅能被一个线程拥有，而一个共享的监护权可以同时被多个线程拥有。这个机制使得多读一写的模式成为可能。写操作需要排他的监护权，而读操作仅需要共享的监护权。&lt;/p&gt;
&lt;p&gt;在程序执行的给定时刻，每个线程拥有各自的监护权集合（该线程锁住的互斥锁的集合）。它们类似于钥匙或者令牌，允许线程访问这些资源。跟物理上的安全钥匙一样，线程不能复制、也不能销毁监护权。一个线程只能把监护权释放给另外一个线程，或者从另外一个线程获得监护权。安全起见，分析模块的标识不清楚具体获取和释放监护权的机制，它假设底层实现（例如，互斥锁的实现）能够恰当的完成这个任务。&lt;/p&gt;
&lt;p&gt;在程序运行的某个具体时刻，某个线程拥有的监护权集合是一个运行时的概念。静态的任务是对这个集合（也被称为监护权环境）进行估计。分析模块会通过静态分析描述程序任何执行节点的监护权环境。这个估计，是对实际运行时监护权环境的保守估计。&lt;/p&gt;

&lt;p&gt;应用指导&lt;/p&gt;
&lt;p&gt;线程安全分析模块使用属性来声明线程约束。属性必须被绑定到具名的声明，比如类、方法、数据成员。我们强烈建议用户为这些不同的属性定义宏，示例请参见以下的mutex.h文件。接下来的说明将假设使用了宏。&lt;/p&gt;
&lt;p&gt;由于历史原因，线程安全分析模块的早期版本是用了以锁为中心的宏名称。为了适应更普适的模型，这些宏被更改了名称。之前的名称仍然在使用，在接下来的文档里会特别指明。&lt;/p&gt;

&lt;p&gt;GUARDED_BY(c) 和 PT_GUARDED_BY(c)&lt;/p&gt;
&lt;p&gt;GUARDED_BY是一个应用在数据成员上的属性，它声明了数据成员被给定的监护权保护。对于数据的读操作需要共享的访问权限，而写操作需要独占的访问权限。&lt;/p&gt;
&lt;p&gt;PT_GUARDED_BY与之类似，只不过它是为指针和智能指针准备的。对数据成员（指针）本身没有任何限制，它保护的是指针指向的数据。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Mutex mu;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;p1             GUARDED_BY(mu);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;p2             PT_GUARDED_BY(mu);
unique_ptr&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; p3  PT_GUARDED_BY(mu);

void test() {
  p1 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Warning!&lt;/span&gt;

  *p2 = &lt;span&gt;42&lt;/span&gt;;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Warning!&lt;/span&gt;
  p2 = new &lt;span&gt;int&lt;/span&gt;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OK.&lt;/span&gt;

  *p3 = &lt;span&gt;42&lt;/span&gt;;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Warning!&lt;/span&gt;
  p3.reset(new &lt;span&gt;int&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OK.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;REQUIRES(...)，REQUIRES_SHARED(...)&lt;/p&gt;
&lt;p&gt;早期的版本是EXCLUSIVE_LOCKS_REQUIRED，SHARED_LOCKS_REQUIRED&lt;/p&gt;
&lt;p&gt;REQUIRES是作用于方法或者函数上的属性，它表明了调用线程必须独享给定的监护权。可以指定不止一个监护权。监护权必须在函数的入口处、出口处同时被声明。&lt;/p&gt;
&lt;p&gt;REQUIRES_SHARED与之类似，只不过仅需要共享的访问权限。&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Mutex mu1, mu2;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a GUARDED_BY(mu1);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b GUARDED_BY(mu2);

void foo() REQUIRES(mu1, mu2) {
  a &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  b &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

void test() {
  mu1.Lock();
  foo();         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Warning!  Requires mu2.&lt;/span&gt;
&lt;span&gt;  mu1.Unlock();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;
&lt;p&gt;原文地址：https://clang.llvm.org/docs/ThreadSafetyAnalysis.html&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 17:13:00 +0000</pubDate>
<dc:creator>jicanghai</dc:creator>
<og:description>线程安全分析 介绍 Clang的线程安全分析模块是C++语言的一个扩展，能对代码中潜在的竞争条件进行警告。这种分析是完全静态的（即编译时进行），没有运行时的消耗。当前这个功能还在开发中，但它已经具备了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jicanghai/p/9472001.html</dc:identifier>
</item>
<item>
<title>学以致用，通过字节码理解：Java的内部类与外部类之私有域访问 - 西楼有酒</title>
<link>http://www.cnblogs.com/JunFengChan/p/9465036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JunFengChan/p/9465036.html</guid>
<description>&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内部类的定义及用处&lt;/li&gt;
&lt;li&gt;打开字节码理解内部类&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;一、内部类的定义及用处&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;内部类（inner class）是定义在另一个类中的类。使用内部类，我们可以：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问该类定义所在的作用域中的数据，包括私有的数据&lt;/li&gt;
&lt;li&gt;可以对同一个包中的其他类隐藏起来&lt;/li&gt;
&lt;li&gt;当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文旨在讲解&lt;strong&gt;内部类与外部类可以相互访问对方的私有域的原理&lt;/strong&gt;，内部类的用法等大家可以自行查阅（官网介绍简单明了：&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html&quot; target=&quot;_blank&quot;&gt;Nested Class&lt;/a&gt;）；&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;&lt;strong&gt;二、打开字节码理解内部类&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;我们知道，内部类其实是Java语言的一种语法糖。经过编译会生成一个&quot;外部类名$内部类名.class&quot;的class文件。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201808/435918-20180814001550016-235800968.png&quot; alt=&quot;&quot; width=&quot;1034&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
非常简单的一个类OuterCls，包含了一个InnerCls内部类。通过javac编译，我们可以看到列表中多了一个文件：OuterCls$InnerCls.class。&lt;/p&gt;
&lt;p&gt;接着，我们通过javap -verbose查看生成的OuterCls.class：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2cd5db08-5c19-472a-95da-8cadb0c77090')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_2cd5db08-5c19-472a-95da-8cadb0c77090&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2cd5db08-5c19-472a-95da-8cadb0c77090&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2cd5db08-5c19-472a-95da-8cadb0c77090',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2cd5db08-5c19-472a-95da-8cadb0c77090&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; $ javap -&lt;span&gt;verbose OuterCls
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Warning: File ./OuterCls.&lt;span&gt;class&lt;/span&gt; does not contain &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OuterCls
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Classfile /Users/ntchan/code/demo/concepts/src/com/ntchan/nestedcls/OuterCls.&lt;span&gt;class&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   Last modified Aug 14, 2018; size 434&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  MD5 checksum b9a1f41c67c8ae3be427c578ea205d20
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   Compiled from &quot;OuterCls.java&quot;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; com.ntchan.nestedcls.OuterCls
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   minor version: 0
&lt;span&gt; 9&lt;/span&gt;   major version: 53
&lt;span&gt;10&lt;/span&gt;   flags: (0x0021&lt;span&gt;) ACC_PUBLIC, ACC_SUPER
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   this_class: #3                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   super_class: #4                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   interfaces: 0, fields: 1, methods: 2, attributes: 2
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;Constant pool:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    #1 = Fieldref           #3.#18         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls.outerField:I&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;    #2 = Methodref          #4.#19         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;    #3 = Class              #20            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;    #4 = Class              #21            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;    #5 = Class              #22            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls$InnerCls&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    #6 =&lt;span&gt; Utf8               InnerCls
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    #7 =&lt;span&gt; Utf8               InnerClasses
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    #8 =&lt;span&gt; Utf8               outerField
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;    #9 =&lt;span&gt; Utf8               I
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   #10 = Utf8               &amp;lt;init&amp;gt;
&lt;span&gt;25&lt;/span&gt;   #11 =&lt;span&gt; Utf8               ()V
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;   #12 =&lt;span&gt; Utf8               Code
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   #13 =&lt;span&gt; Utf8               LineNumberTable
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   #14 = Utf8               access$000
&lt;span&gt;29&lt;/span&gt;   #15 = Utf8               (Lcom/ntchan/nestedcls/&lt;span&gt;OuterCls;)I
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;   #16 =&lt;span&gt; Utf8               SourceFile
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;   #17 =&lt;span&gt; Utf8               OuterCls.java
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;   #18 = NameAndType        #8:#9          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; outerField:I&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;   #19 = NameAndType        #10:#11        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;   #20 = Utf8               com/ntchan/nestedcls/&lt;span&gt;OuterCls
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;   #21 = Utf8               java/lang/&lt;span&gt;Object
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;   #22 = Utf8               com/ntchan/nestedcls/&lt;span&gt;OuterCls$InnerCls
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; com.ntchan.nestedcls.OuterCls();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    descriptor: ()V
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     flags: (0x0001&lt;span&gt;) ACC_PUBLIC
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    Code:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;       stack=2, locals=1, args_size=1
&lt;span&gt;43&lt;/span&gt;          0&lt;span&gt;: aload_0
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;          1: invokespecial #2                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;          4&lt;span&gt;: aload_0
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;          5&lt;span&gt;: iconst_5
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;          6: putfield      #1                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Field outerField:I&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;          9: &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;      LineNumberTable:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         line 3: 0
&lt;span&gt;51&lt;/span&gt;         line 4: 4
&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;   &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; access$000&lt;span&gt;(com.ntchan.nestedcls.OuterCls);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     descriptor: (Lcom/ntchan/nestedcls/&lt;span&gt;OuterCls;)I
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     flags: (0x1008&lt;span&gt;) ACC_STATIC, ACC_SYNTHETIC
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    Code:
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;       stack=1, locals=1, args_size=1
&lt;span&gt;58&lt;/span&gt;          0&lt;span&gt;: aload_0
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;          1: getfield      #1                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Field outerField:I&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;          4&lt;span&gt;: ireturn
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;      LineNumberTable:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         line 3: 0
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; SourceFile: &quot;OuterCls.java&quot;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;InnerClasses:
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;   #6= #5 of #3;                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; InnerCls=class com/ntchan/nestedcls/OuterCls$InnerCls of class com/ntchan/nestedcls/OuterCls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中，我们发现OuterCls多了一个静态方法access$000：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201808/435918-20180814003324047-519183735.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一下这个静态方法做了什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缺省修饰符，表示这个方法的域是包可见&lt;/li&gt;
&lt;li&gt;这个静态方法只有一个参数：OuterCls&lt;/li&gt;
&lt;li&gt;ACC_SYNTHETIC：表示这个方法是由编译器自动生成的&lt;/li&gt;
&lt;li&gt;aload_0表示把局部变量表的第一个变量加载到操作栈&lt;/li&gt;
&lt;li&gt;getfield 访问实例字段 outerField&lt;/li&gt;
&lt;li&gt;ireturn 返回传参进来的OuterCls的outerFiled的值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好像发现了什么，对比代码，我们在内部类使用了外部类的私有域outerField，编译器就自动帮我们生成了一个仅包可见的静态方法来返回outerField的值。&lt;/p&gt;
&lt;p&gt;接着，我们继续查看内部类InnerCls的字节码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4246e246-80b6-4002-a19c-ff0a75a0a47f')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_4246e246-80b6-4002-a19c-ff0a75a0a47f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4246e246-80b6-4002-a19c-ff0a75a0a47f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4246e246-80b6-4002-a19c-ff0a75a0a47f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4246e246-80b6-4002-a19c-ff0a75a0a47f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; $ javap -&lt;span&gt;verbose OuterCls\$InnerCls
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Warning: File ./OuterCls$InnerCls.&lt;span&gt;class&lt;/span&gt; does not contain &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OuterCls$InnerCls
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Classfile /Users/ntchan/code/demo/concepts/src/com/ntchan/nestedcls/OuterCls$InnerCls.&lt;span&gt;class&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   Last modified Aug 14, 2018; size 648&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  MD5 checksum 344420034b48389a027a2f303cd2617c
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   Compiled from &quot;OuterCls.java&quot;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; com.ntchan.nestedcls.OuterCls$InnerCls
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   minor version: 0
&lt;span&gt; 9&lt;/span&gt;   major version: 53
&lt;span&gt;10&lt;/span&gt;   flags: (0x0020&lt;span&gt;) ACC_SUPER
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   this_class: #6                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls$InnerCls&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   super_class: #7                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   interfaces: 0, fields: 1, methods: 2, attributes: 2
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;Constant pool:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    #1 = Fieldref           #6.#18         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls$InnerCls.this$0:Lcom/ntchan/nestedcls/OuterCls;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;    #2 = Methodref          #7.#19         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;    #3 = Fieldref           #20.#21        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/System.out:Ljava/io/PrintStream;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;    #4 = Methodref          #22.#23        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls.access$000:(Lcom/ntchan/nestedcls/OuterCls;)I&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;    #5 = Methodref          #24.#25        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/io/PrintStream.println:(I)V&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    #6 = Class              #26            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls$InnerCls&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;    #7 = Class              #29            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;    #8 = Utf8               &lt;span&gt;this&lt;/span&gt;$0
&lt;span&gt;23&lt;/span&gt;    #9 = Utf8               Lcom/ntchan/nestedcls/&lt;span&gt;OuterCls;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   #10 = Utf8               &amp;lt;init&amp;gt;
&lt;span&gt;25&lt;/span&gt;   #11 = Utf8               (Lcom/ntchan/nestedcls/&lt;span&gt;OuterCls;)V
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;   #12 =&lt;span&gt; Utf8               Code
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   #13 =&lt;span&gt; Utf8               LineNumberTable
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   #14 =&lt;span&gt; Utf8               printOuterField
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;   #15 =&lt;span&gt; Utf8               ()V
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;   #16 =&lt;span&gt; Utf8               SourceFile
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;   #17 =&lt;span&gt; Utf8               OuterCls.java
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;   #18 = NameAndType        #8:#9          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this$0:Lcom/ntchan/nestedcls/OuterCls;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;   #19 = NameAndType        #10:#15        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;   #20 = Class              #30            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/System&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;   #21 = NameAndType        #31:#32        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; out:Ljava/io/PrintStream;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;   #22 = Class              #33            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/ntchan/nestedcls/OuterCls&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;   #23 = NameAndType        #34:#35        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; access$000:(Lcom/ntchan/nestedcls/OuterCls;)I&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;   #24 = Class              #36            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/io/PrintStream&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;   #25 = NameAndType        #37:#38        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; println:(I)V&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;   #26 = Utf8               com/ntchan/nestedcls/&lt;span&gt;OuterCls$InnerCls
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;   #27 =&lt;span&gt; Utf8               InnerCls
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;   #28 =&lt;span&gt; Utf8               InnerClasses
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;   #29 = Utf8               java/lang/&lt;span&gt;Object
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;   #30 = Utf8               java/lang/&lt;span&gt;System
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;   #31 =&lt;span&gt; Utf8               out
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;   #32 = Utf8               Ljava/io/&lt;span&gt;PrintStream;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;   #33 = Utf8               com/ntchan/nestedcls/&lt;span&gt;OuterCls
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;   #34 = Utf8               access$000
&lt;span&gt;49&lt;/span&gt;   #35 = Utf8               (Lcom/ntchan/nestedcls/&lt;span&gt;OuterCls;)I
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;   #36 = Utf8               java/io/&lt;span&gt;PrintStream
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;   #37 =&lt;span&gt; Utf8               println
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;   #38 =&lt;span&gt; Utf8               (I)V
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;   &lt;span&gt;final&lt;/span&gt; com.ntchan.nestedcls.OuterCls &lt;span&gt;this&lt;/span&gt;$0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     descriptor: Lcom/ntchan/nestedcls/&lt;span&gt;OuterCls;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     flags: (0x1010&lt;span&gt;) ACC_FINAL, ACC_SYNTHETIC
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;  com.ntchan.nestedcls.OuterCls$InnerCls(com.ntchan.nestedcls.OuterCls);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     descriptor: (Lcom/ntchan/nestedcls/&lt;span&gt;OuterCls;)V
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     flags: (0x0000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    Code:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;       stack=2, locals=2, args_size=2
&lt;span&gt;63&lt;/span&gt;          0&lt;span&gt;: aload_0
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;          1&lt;span&gt;: aload_1
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;          2: putfield      #1                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Field this$0:Lcom/ntchan/nestedcls/OuterCls;&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;          5&lt;span&gt;: aload_0
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;          6: invokespecial #2                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;          9: &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;      LineNumberTable:
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         line 5: 0
&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printOuterField();
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    descriptor: ()V
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     flags: (0x0001&lt;span&gt;) ACC_PUBLIC
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;    Code:
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;       stack=2, locals=1, args_size=1
&lt;span&gt;77&lt;/span&gt;          0: getstatic     #3                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Field java/lang/System.out:Ljava/io/PrintStream;&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;          3&lt;span&gt;: aload_0
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;          4: getfield      #1                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Field this$0:Lcom/ntchan/nestedcls/OuterCls;&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;          7: invokestatic  #4                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method com/ntchan/nestedcls/OuterCls.access$000:(Lcom/ntchan/nestedcls/OuterCls;)I&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;         10: invokevirtual #5                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/io/PrintStream.println:(I)V&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;         13: &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;      LineNumberTable:
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;         line 7: 0
&lt;span&gt;85&lt;/span&gt;         line 8: 13
&lt;span&gt;86&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; SourceFile: &quot;OuterCls.java&quot;
&lt;span&gt;88&lt;/span&gt; &lt;span&gt;InnerClasses:
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;   #27= #6 of #22;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; InnerCls=class com/ntchan/nestedcls/OuterCls$InnerCls of class com/ntchan/nestedcls/OuterCls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;首先，我们发现编译器自动生成了一个声明为final的成员：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201808/435918-20180814004914919-1758151948.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道，&lt;strong&gt;final修饰的成员都是编译器可以确定的常量。&lt;/strong&gt;经过final修饰的变量，都会放到class的常量池。&lt;/p&gt;
&lt;p&gt;然后再看一下编译器自动生成的构造函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201808/435918-20180814005406862-546148836.png&quot; alt=&quot;&quot; width=&quot;717&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的字节码指令我就不再一一贴出来，我简单解释一下，这个构造函数通过外部传参OuterCls实例，赋值给this$0（上面那个被final修饰的变量）&lt;/p&gt;
&lt;p&gt;最后看一下我们的printOutField方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201808/435918-20180814005701003-231676132.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，原本调用outerField的地方，变成了OuterField.access$000(this$0)，意思就是，通过OuterField的静态方法，返回this$0的OuterField。&lt;/p&gt;

&lt;p&gt;总的来讲，内部类访问外部类的私有成员的原理，是通过编译器分别给外部类自动生成访问私有成员的静态方法access$000及给内部类自动生成外部类的final引用、外部类初始化的构造函数及修改调用外部类私有成员的代码为调用外部类包可见的access$000实现的。同理，匿名内部类、静态内部类都可以通过这种方法分析实现原理&lt;/p&gt;

</description>
<pubDate>Mon, 13 Aug 2018 17:10:00 +0000</pubDate>
<dc:creator>西楼有酒</dc:creator>
<og:description>目录： 内部类的定义及用处 打开字节码理解内部类 一、内部类的定义及用处 内部类（inner class）是定义在另一个类中的类。使用内部类，我们可以： 访问该类定义所在的作用域中的数据，包括私有的数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JunFengChan/p/9465036.html</dc:identifier>
</item>
<item>
<title>补习系列- springboot 整合 shiro 一指禅 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9471950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9471950.html</guid>
<description>&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;了解ApacheShiro是什么，能做什么；&lt;/li&gt;
&lt;li&gt;通过QuickStart 代码领会 Shiro的关键概念；&lt;/li&gt;
&lt;li&gt;能基于SpringBoot 整合Shiro 实现URL安全访问；&lt;/li&gt;
&lt;li&gt;掌握基于注解的方法，以实现灵活定制。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一apache-shiro是什么&quot;&gt;一、Apache Shiro是什么&lt;/h2&gt;
&lt;p&gt;Apache Shiro 是一个强大且易用的Java安全框架，用于实现身份认证、鉴权、会话管理及加密功能。&lt;br/&gt;框架提供了非常简单且易于上手的API，可以支持快速为web应用程序实现安全控制能力。&lt;br/&gt;&lt;a href=&quot;http://shiro.apache.org/&quot;&gt;官网地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/apache/shiro&quot;&gt;github 地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;shiro-能做什么&quot;&gt;Shiro 能做什么&lt;/h3&gt;
&lt;p&gt;Apache Shiro 的设计初衷是让安全管理变得易于上手和容易理解，它可以实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;鉴别用户身份，是否本系统注册的A用户；&lt;/li&gt;
&lt;li&gt;管理用户权限，是否有某个角色，或某些权限；&lt;/li&gt;
&lt;li&gt;即使没有web或EJB容器，也可以使用Session API&lt;/li&gt;
&lt;li&gt;可以聚合一个或多个用户权限数据源并且以用户视图的形式统一表现出来&lt;/li&gt;
&lt;li&gt;实现单点登录功能（SSO）&lt;/li&gt;
&lt;li&gt;无需登录便可实现&lt;strong&gt;记住我&lt;/strong&gt;这一功能&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;有什么特性&quot;&gt;有什么特性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;官网-Features&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180814004044378-1133938597.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要概念&lt;/strong&gt; 包括了&lt;br/&gt;Authentication（身份鉴别）、Authorization（权限管理）、Session Management（会话管理）、Cryptography（加密）&lt;br/&gt;这号称软件安全的四大基石.. 关于几个概念，用下面的表格说明：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Authentication(身份鉴别)&lt;/td&gt;
&lt;td&gt;指鉴别登录用户的身份&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Authorization(权限认证)&lt;/td&gt;
&lt;td&gt;决定用户是否有权访问某物&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Session Management(会话管理)&lt;/td&gt;
&lt;td&gt;支持独立的会话管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Cryptography(加密)&lt;/td&gt;
&lt;td&gt;利用加密算法保证数据安全&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;其他特性&lt;/strong&gt;非核心，但是非常有用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;web应用支持&lt;br/&gt;如JavaEE、Spring的整合支持&lt;/li&gt;
&lt;li&gt;缓存&lt;br/&gt;用于提升安全管理的效率&lt;/li&gt;
&lt;li&gt;并发&lt;br/&gt;可支持多线程应用&lt;/li&gt;
&lt;li&gt;测试&lt;br/&gt;可以通过单元测试和集成测试验证程序的安全性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Run As&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;允许用户将某一身份赋予另一用户（在一些行政管理软件中常用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Remember Mes&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;在Session（会话）期间记住用户身份，当只有强制要求登录是才需要用户登录&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;架构说明&quot;&gt;架构说明&lt;/h3&gt;
&lt;p&gt;看看下面的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180814004054155-1711042951.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中涉及了若干个模块，关于每个模块的大致作用如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Subject&lt;/strong&gt;&lt;br/&gt;交互实体，对应于当前用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SecurityManager&lt;/strong&gt;&lt;br/&gt;安全管理器，Shiro最核心的模块，管理各安全模块的工作；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Authenticator&lt;/strong&gt;&lt;br/&gt;身份鉴别组件，执行和反馈用户的认证(登录)，&lt;br/&gt;该组件从Realm中获取用户信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Authentication Strategy&lt;/strong&gt;&lt;br/&gt;如果配置了多个Realm，该怎么协调？这就用到策略&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Authorizer&lt;/strong&gt;&lt;br/&gt;权限认证，顾名思义，就是用于负责用户访问控制的模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SessionManager&lt;/strong&gt;&lt;br/&gt;会话管理器，在Web环境中Shiro一般会沿用Servlet容器的会话。&lt;br/&gt;但脱离了Web环境就会使用独立的会话管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SessionDAO&lt;/strong&gt;&lt;br/&gt;执行会话持久化的工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CacheManager&lt;/strong&gt;&lt;br/&gt;一个缓存管理器，可为 Shiro 的其他组件提供缓存能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cryptography&lt;/strong&gt;&lt;br/&gt;加密组件，提供了大量简单易用的安全加密API&lt;/p&gt;
&lt;p&gt;到这里，不需要为这么多的模块而苦恼，在使用Shiro时，只需要&lt;strong&gt;牢牢记住下面的实体关系&lt;/strong&gt;，便不会产生理解上的困难。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180814004108234-1943679446.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;&lt;br/&gt;应用程序依赖于 Subject 实体来标识当前的用户，而SecurityManager 则通过Realm接口读取数据，进而实现 Subject 的关联管理。&lt;/p&gt;
&lt;h2 id=&quot;二快速入门&quot;&gt;二、快速入门&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为了帮助读者更快速理解Shiro，下面上一段QuickStart的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 加载 shiro.ini并构造 SecurityManager
Factory&amp;lt;org.apache.shiro.mgt.SecurityManager&amp;gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);
org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();

// 设置当前的 SecurityManager对象
SecurityUtils.setSecurityManager(securityManager);

// 获取当前用户
Subject currentUser = SecurityUtils.getSubject();

// 操作会话
Session session = currentUser.getSession();
session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);
String value = (String) session.getAttribute(&quot;someKey&quot;);
if (value.equals(&quot;aValue&quot;)) {
    log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);
}

// 执行登录
if (!currentUser.isAuthenticated()) {
    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);
    token.setRememberMe(true);
    try {
        currentUser.login(token);
    } catch (UnknownAccountException uae) {
        log.info(&quot;There is no user with username of &quot; + token.getPrincipal());
    } catch (IncorrectCredentialsException ice) {
        log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);
    } catch (LockedAccountException lae) {
        log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot;
                + &quot;Please contact your administrator to unlock it.&quot;);
    } catch (AuthenticationException ae) {
        // unexpected condition? error?
    }
}

// 输出用户信息
log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);

// 检查角色
if (currentUser.hasRole(&quot;schwartz&quot;)) {
    log.info(&quot;May the Schwartz be with you!&quot;);
} else {
    log.info(&quot;Hello, mere mortal.&quot;);
}

// 检查权限
if (currentUser.isPermitted(&quot;lightsaber:weild&quot;)) {
    log.info(&quot;You may use a lightsaber ring. Use it wisely.&quot;);
} else {
    log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);
}

// 结束，执行注销
currentUser.logout();

System.exit(0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码来自 shiro-sample/&lt;strong&gt;&lt;em&gt;QuickStart.java&lt;/em&gt;&lt;/strong&gt;，&lt;br/&gt;关于代码的解释.. 老司机认为看下注释是一定能懂的了。&lt;/p&gt;
&lt;h2 id=&quot;三springboot-整合-shiro&quot;&gt;三、SpringBoot 整合 Shiro&lt;/h2&gt;
&lt;p&gt;我们尝试将 Shiro 整合到 SpringBoot 项目，翻了下官网并没有太多介绍，&lt;br/&gt;猜想这可能与 SpringBoot 框架还比较新有关系，Shiro是个老框架(2010年出的第一个版本)..&lt;br/&gt;但最终老司机还是成功找到了 胶合组件：&lt;strong&gt;shiro-spring-boot-starter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，为项目引入依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;shiro-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们将完成一个 &lt;strong&gt;URL访问安全控制&lt;/strong&gt; 的示例，通过这个案例&lt;br/&gt;读者可以了解到如何根据业务定制必要的功能模块。&lt;/p&gt;
&lt;h3 id=&quot;系统设计&quot;&gt;系统设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180814004120275-830582253.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图示中，名为lilei 的用户拥有 normal (普通用户)的角色，而相应的具备customer.profile的读写权限。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以上是基于RBAC(基于角色的权限控制) 的设计，RBAC 目前的应用非常广泛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 web应用访问中，某些页面是允许任何人访问的，某些需要登录用户，比如个人中心&lt;br/&gt;而某些页面需要具备一些特权，比如vip资料.. 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180814004131603-1295205771.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户模块&quot;&gt;用户模块&lt;/h3&gt;
&lt;p&gt;通常，在设计用户权限时都会考虑用户信息、角色信息以及对应的权限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户实体&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class UserInfo {
    private String username;
    private String passwordHash;
    private String salt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意到 &lt;strong&gt;salt&lt;/strong&gt;是用于密码存储的&lt;strong&gt;加盐值&lt;/strong&gt;(用于防止暴力破解)&lt;br/&gt;&lt;strong&gt;passwordHash&lt;/strong&gt; 是原始密码经过加盐哈希计算后的值(16进制形式)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;角色实体&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class RoleInfo {
    private String roleName;
    private List&amp;lt;String&amp;gt; perms;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简化，我们直接将权限用字符串形式表示，一个角色RoleInfo包含了一组权限perm。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户管理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们的样例中，需要实现一个UserManager类，用于做用户信息、权限信息的管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ShiroUserManager {

    // 用户表
    private final Map&amp;lt;String, UserInfo&amp;gt; users = new HashMap&amp;lt;String, UserInfo&amp;gt;();
    // 角色权限表
    private final Map&amp;lt;String, List&amp;lt;RoleInfo&amp;gt;&amp;gt; userRoles = new HashMap&amp;lt;String, List&amp;lt;RoleInfo&amp;gt;&amp;gt;();

    private static final Logger logger = LoggerFactory.getLogger(ShiroUserManager.class);

    // 密钥匹配类
    private ShiroHashMatcher matcher;

    public ShiroUserManager(ShiroHashMatcher matcher) {
        this.matcher = matcher;
    }

    public ShiroHashMatcher getMatcher() {
        return this.matcher;
    }

    @PostConstruct
    private void init() {

        // 预置信息
        register(&quot;lilei&quot;, &quot;111111&quot;, &quot;123&quot;);
        grant(&quot;normal&quot;, new RoleInfo(&quot;customer&quot;, &quot;customer.profile.read&quot;));
        grant(&quot;normal&quot;, new RoleInfo(&quot;customer&quot;, &quot;customer.profile.write&quot;));
    }

    /**
     * 获取用户信息
     * 
     * @param username
     * @return
     */
    public UserInfo getUser(String username) {
        if (StringUtils.isEmpty(username)) {
            return null;
        }
        return users.get(username);
    }

    /**
     * 获取权限信息
     * 
     * @param username
     * @return
     */
    public List&amp;lt;RoleInfo&amp;gt; getRoles(String username) {
        if (StringUtils.isEmpty(username)) {
            return Collections.emptyList();
        }
        return userRoles.get(username);
    }

    /**
     * 添加用户
     * 
     * @param username
     * @param password
     * @param salt
     * @return
     */
    public UserInfo register(String username, String password, String salt) {
        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password) || StringUtils.isEmpty(salt)) {
            return null;
        }

        // 生成加盐密码Hash值
        String passwordHash = matcher.getCredentialHash(password, salt);

        logger.info(&quot;user {} register with passHash :{}&quot;, username, passwordHash);
        UserInfo user = new UserInfo(username, passwordHash, salt);
        users.put(username, user);

        return user;
    }

    /**
     * 授权操作
     * 
     * @param username
     * @param role
     */
    public void grant(String username, RoleInfo role) {
        if (userRoles.containsKey(username)) {

            userRoles.get(username).add(role);
        } else {
            List&amp;lt;RoleInfo&amp;gt; roleList = new ArrayList&amp;lt;RoleInfo&amp;gt;();
            roleList.add(role);
            userRoles.put(username, roleList);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的实现中，我们仅仅将用户、角色信息放在内存中管理，并内置了名为&lt;strong&gt;lilei&lt;/strong&gt;的用户角色。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;在真实应用中，用户权限需要通过持久层(DB)实现&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;密钥算法&quot;&gt;密钥算法&lt;/h3&gt;
&lt;p&gt;我们基于Shiro的基础类&lt;strong&gt;HashedCredentialsMatcher&lt;/strong&gt;进行了扩展。&lt;br/&gt;选用SHA-256哈希算法，设置迭代次数为1024。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ShiroHashMatcher extends HashedCredentialsMatcher {

    public ShiroHashMatcher() {
        setHashAlgorithmName(Sha256Hash.ALGORITHM_NAME);
        setHashIterations(1024);
        setStoredCredentialsHexEncoded(true);
    }

    public String getCredentialHash(Object credentials, Object salt) {
        return new SimpleHash(this.getHashAlgorithmName(), credentials, salt, this.getHashIterations()).toHex();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;realm实现&quot;&gt;Realm实现&lt;/h3&gt;
&lt;p&gt;在Shiro 框架中， Realm 是用作用户权限信息查询的接口，我们的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ShiroRealm extends AuthorizingRealm {

    private static final Logger logger = LoggerFactory.getLogger(ShiroRealm.class);

    private ShiroUserManager userManager;

    public ShiroRealm(ShiroUserManager userManager) {
        this.setCredentialsMatcher(userManager.getMatcher());
        this.userManager = userManager;
    }

    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        logger.info(&quot;check authorization info&quot;);

        SimpleAuthorizationInfo authInfo = new SimpleAuthorizationInfo();

        // 获取当前用户
        UserInfo userInfo = (UserInfo) principals.getPrimaryPrincipal();

        // 查询角色信息
        List&amp;lt;RoleInfo&amp;gt; roleInfos = userManager.getRoles(userInfo.getUsername());

        if (roleInfos != null) {
            for (RoleInfo roleInfo : roleInfos) {

                authInfo.addRole(roleInfo.getRoleName());

                if (roleInfo.getPerms() != null) {
                    for (String perm : roleInfo.getPerms()) {
                        authInfo.addStringPermission(perm);
                    }
                }
            }
        }

        return authInfo;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        logger.info(&quot;check authentication info&quot;);

        String username = (String) token.getPrincipal();

        // 获取用户信息
        UserInfo user = userManager.getUser(username);

        if (user == null) {
            return null;
        }

        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user, user.getPasswordHash(),
                ByteSource.Util.bytes(user.getSalt()), getName());
        return authenticationInfo;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bean-注册&quot;&gt;Bean 注册&lt;/h3&gt;
&lt;p&gt;将实现好的 ShiroRealm 注册为Bean，并初始化 WebSecurityManager&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Bean
    public DefaultWebSecurityManager securityManager() {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(realm());
        return securityManager;
    }


    @Bean
    public ShiroRealm realm() {
        ShiroRealm realm = new ShiroRealm(userManager());
        return realm;
    }

   
    @Bean
    public ShiroUserManager userManager() {
        return new ShiroUserManager(matcher());
    }


    @Bean
    public ShiroHashMatcher matcher() {
        return new ShiroHashMatcher();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义拦截链&quot;&gt;定义拦截链&lt;/h3&gt;
&lt;p&gt;拦截器链通过 &lt;strong&gt;ShiroFilterFactoryBean&lt;/strong&gt;实现定制，实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Bean
    public ShiroFilterFactoryBean filter(org.apache.shiro.mgt.SecurityManager securityManager) {
        logger.info(&quot;config shiro filter&quot;);
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);

        // 定义URL拦截链
        Map&amp;lt;String, String&amp;gt; filterChainDefinitionMap = new LinkedHashMap&amp;lt;String, String&amp;gt;();
        // 允许匿名用户访问首页
        filterChainDefinitionMap.put(&quot;/shiro/index&quot;, &quot;anon&quot;);
        // 定义注销路径
        filterChainDefinitionMap.put(&quot;/shiro/logout&quot;, &quot;logout&quot;);
        // 所有用户界面都需要身份验证，否则会跳转到loginurl，由FormAuthenticationFilter处理
        filterChainDefinitionMap.put(&quot;/shiro/user/**&quot;, &quot;authc&quot;);
        // 为login路径定义拦截，由FormAuthenticationFilter处理
        filterChainDefinitionMap.put(&quot;/shiro/login&quot;, &quot;authc&quot;);
        // 所有vip路径要求具备vip角色权限
        filterChainDefinitionMap.put(&quot;/shiro/vip/**&quot;, &quot;roles[vip]&quot;);
        // 指定loginurl 路径
        shiroFilterFactoryBean.setLoginUrl(&quot;/shiro/login&quot;);
        // 登录成功后跳转路径
        shiroFilterFactoryBean.setSuccessUrl(&quot;/shiro/user/&quot;);
        // for un authenticated
        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/shiro/unauth&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);

        // 自定义filters，可覆盖默认的Filter列表，参考 DefaultFilter
        Map&amp;lt;String, Filter&amp;gt; filters = new LinkedHashMap&amp;lt;String, Filter&amp;gt;();

        // 定制logout 过滤，指定注销后跳转到登录页(默认为根路径)
        LogoutFilter logoutFilter = new LogoutFilter();
        logoutFilter.setRedirectUrl(&quot;/shiro/login&quot;);
        filters.put(&quot;logout&quot;, logoutFilter);

        // 定制authc 过滤，指定登录表单参数
        FormAuthenticationFilter authFilter = new FormAuthenticationFilter();
        authFilter.setUsernameParam(&quot;username&quot;);
        authFilter.setPasswordParam(&quot;password&quot;);
        filters.put(&quot;authc&quot;, authFilter);

        shiroFilterFactoryBean.setFilters(filters);
        return shiroFilterFactoryBean;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟着老司机的注释，上面代码应该不难理解(尽管有点冗长)，filterChainDefinitionMap的定义中，&lt;br/&gt;key对应于url路径，而value则对应了过滤器的缩写，Shiro内置的过滤器可参考&lt;strong&gt;DefaultFilter枚举&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;anon&lt;/td&gt;
&lt;td&gt;AnonymousFilter&lt;/td&gt;
&lt;td&gt;可匿名访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;authc&lt;/td&gt;
&lt;td&gt;FormAuthenticationFilter&lt;/td&gt;
&lt;td&gt;form表单登录拦截&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;authcBasic&lt;/td&gt;
&lt;td&gt;BasicHttpAuthenticationFilter&lt;/td&gt;
&lt;td&gt;basic登录拦截&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;logout&lt;/td&gt;
&lt;td&gt;LogoutFilter&lt;/td&gt;
&lt;td&gt;注销处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;noSessionCreation&lt;/td&gt;
&lt;td&gt;NoSessionCreationFilter&lt;/td&gt;
&lt;td&gt;禁止创建会话&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;perms&lt;/td&gt;
&lt;td&gt;PermissionsAuthorizationFilter&lt;/td&gt;
&lt;td&gt;指定权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;PortFilter&lt;/td&gt;
&lt;td&gt;指定端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;rest&lt;/td&gt;
&lt;td&gt;HttpMethodPermissionFilter&lt;/td&gt;
&lt;td&gt;HttpMethod转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;roles&lt;/td&gt;
&lt;td&gt;RolesAuthorizationFilter&lt;/td&gt;
&lt;td&gt;指定角色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ssl&lt;/td&gt;
&lt;td&gt;SslFilter&lt;/td&gt;
&lt;td&gt;需要https&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;UserFilter&lt;/td&gt;
&lt;td&gt;已登录或Rememberme&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;深入一点&lt;/strong&gt;&lt;br/&gt;FormAuthenticationFilter 实现了表单登录的拦截逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果当前没有登录，则跳转到 loginUrl；&lt;/li&gt;
&lt;li&gt;如果是登录请求，则执行登录操作，成功后跳转到 loginSuccessUrl&lt;/li&gt;
&lt;li&gt;如果登录失败，将当前的异常信息写入请求上下文，由业务处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;扒一扒源码，可以看到相应的逻辑实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {
        if (isLoginRequest(request, response)) {
            if (isLoginSubmission(request, response)) {
                if (log.isTraceEnabled()) {
                    log.trace(&quot;Login submission detected.  Attempting to execute login.&quot;);
                }
                return executeLogin(request, response);
            } else {
                if (log.isTraceEnabled()) {
                    log.trace(&quot;Login page view.&quot;);
                }
                //allow them to see the login page ;)
                return true;
            }
        } else {
            if (log.isTraceEnabled()) {
                log.trace(&quot;Attempting to access a path which requires authentication.  Forwarding to the &quot; +
                        &quot;Authentication url [&quot; + getLoginUrl() + &quot;]&quot;);
            }
            saveRequestAndRedirectToLogin(request, response);
            return false;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;isLoginSubmission 方法的判断中，认为来自 loginUrl 的 POST 请求就是登录操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected boolean isLoginSubmission(ServletRequest request, ServletResponse response) {
        return (request instanceof HttpServletRequest) &amp;amp;&amp;amp; WebUtils.toHttp(request).getMethod().equalsIgnoreCase(POST_METHOD);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在登录失败后，写入上下文信息，这里使用的是异常类的名称&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e,
                                     ServletRequest request, ServletResponse response) {
        if (log.isDebugEnabled()) {
            log.debug( &quot;Authentication exception&quot;, e );
        }
        setFailureAttribute(request, e);
        //login failed, let request continue back to the login page:
        return true;
    }

    protected void setFailureAttribute(ServletRequest request, AuthenticationException ae) {
        String className = ae.getClass().getName();
        request.setAttribute(getFailureKeyAttribute(), className);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，你应该能理解为什么在过滤链定义中，loginUrl 也需要被拦截了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;filterChainDefinitionMap.put(&quot;/shiro/login&quot;, &quot;authc&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;controller-类&quot;&gt;Controller 类&lt;/h3&gt;
&lt;p&gt;基于上面的分析后，我们便可以轻松的完成Controller的编写，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Controller
@RequestMapping(&quot;/shiro&quot;)
public class ShiroController {

    /**
     * 登录界面，展示登录表单
     * 
     * @return
     */
    @GetMapping(&quot;/login&quot;)
    public String login() {
        return &quot;shiro/login&quot;;
    }

    /**
     * 登录表单处理
     * 
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    public String doLogin(HttpServletRequest servletRequest, final RedirectAttributes redirectAttrs) {

        // FormAuthenticationFilter已经做了登录校验处理，
        // 若登录成功会跳转到loginSuccessUrl，这里只做异常处理
        String errorException = (String) servletRequest
                .getAttribute(FormAuthenticationFilter.DEFAULT_ERROR_KEY_ATTRIBUTE_NAME);

        // 登录失败，errorException 非空
        if (!StringUtils.isEmpty(errorException)) {
            // 设置错误消息，执行跳转
            redirectAttrs.addFlashAttribute(&quot;loginErrorMsg&quot;, &quot;LoginFailed:&quot; + errorException);
            return &quot;redirect:/shiro/login&quot;;
        }
        return &quot;OK&quot;;
    }

    /**
     * 用户信息界面
     * 
     * @return
     */
    @GetMapping(&quot;/user&quot;)
    @ResponseBody
    public String user() {
        Subject subject = SecurityUtils.getSubject();
        UserInfo user = (UserInfo) subject.getPrincipals().getPrimaryPrincipal();
        return &quot;Welcome back, &quot; + user.getUsername();
    }
    
    /**
     * VIP 用户信息界面
     * 
     * @return
     */
    @GetMapping(&quot;/vip&quot;)
    @ResponseBody
    public String userVip() {
        Subject subject = SecurityUtils.getSubject();
        UserInfo user = (UserInfo) subject.getPrincipals().getPrimaryPrincipal();
        return &quot;Hi, &quot; + user.getUsername() + &quot;, This is for the vip&quot;;
    }
    
    /**
     * 匿名访问界面
     * 
     * @return
     */
    @GetMapping(&quot;/annon/*&quot;)
    @ResponseBody
    public String annon() {
        return &quot;this is the content anyone can access&quot;;
    }

    /**
     * 无权限界面
     * 
     * @return
     */
    @GetMapping(&quot;/unauth&quot;)
    @ResponseBody
    public String unauth() {
        return &quot;you are no allow to access&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;登录页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;登录页面为一个简单的HTML界面，包含一个POST表单，使用username/password作为请求参数。&lt;br/&gt;在登录失败时由Controller跳转回登录页，并显示出错信息，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180814004201507-1636276409.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四注解的使用&quot;&gt;四、注解的使用&lt;/h2&gt;
&lt;p&gt;前面的例子演示了 Shiro的经典用法，然而，老司机认为注解会更好用。&lt;br/&gt;Shiro 的注解是基于AOP实现的，在方法上声明所需要的权限，相比URL拦截要更加灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;shiro-spring-boot-starter&lt;/strong&gt; 为我们自动注入了AOP 代理配置，可直接使用注解。&lt;/p&gt;
&lt;p&gt;如果使用了注解，我们可以对url 启用匿名访问，这样访问控制则通过注解和异常处理来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        // 对于所有shiroan路径一律不拦截
        filterChainDefinitionMap.put(&quot;/shiroan/**&quot;, &quot;anon&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;权限注解&quot;&gt;权限注解&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * vip 界面，需要vip角色
     * 
     * @return
     */
    @RequiresRoles(&quot;vip&quot;)
    @GetMapping(&quot;/vip&quot;)
    @ResponseBody
    public String vip() {
        return &quot;this is the vip info&quot;;
    }

    /**
     * home 界面，需要登录
     * 
     * @return
     */
    @RequiresAuthentication
    @GetMapping(&quot;/home&quot;)
    @ResponseBody
    public String home() {
        return &quot;this is the home page&quot;;
    }

    /**
     * 资料界面，需要资料权限
     * 
     * @return
     */
    @RequiresPermissions(&quot;customer.profile.read&quot;)
    @GetMapping(&quot;/profile&quot;)
    @ResponseBody
    public String profile() {
        return &quot;this is the profile info&quot;;
    }

    /**
     * 读取相册界面，需要详情权限
     * 
     * @return
     */
    @RequiresPermissions(&quot;customer.album.read&quot;)
    @GetMapping(&quot;/album&quot;)
    @ResponseBody
    public String album() {
        return &quot;this is the album info&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@RequiredRoles、@RequiredPermissions、@RequiredAuthentication 定义了方法执行所需的权限。&lt;br/&gt;除此之外，Shiro还内置了其他注解，如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@RequiresRoles&lt;/td&gt;
&lt;td&gt;指定的角色可以访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@RequiresPermissions&lt;/td&gt;
&lt;td&gt;指定的权限可以访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@RequiresAuthentication&lt;/td&gt;
&lt;td&gt;登录用户可以访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@RequiresGuest&lt;/td&gt;
&lt;td&gt;仅游客可以访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@RequiresUser&lt;/td&gt;
&lt;td&gt;已登录或 &quot;记住我&quot;的用户&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在访问方法未通过权限检查时，会抛出AuthorizationException，我们需要定义一个拦截器进行处理&lt;/p&gt;
&lt;h3 id=&quot;拦截器&quot;&gt;拦截器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 自定义拦截，处理鉴权异常
     * 
     * @author atp
     *
     */
    @ControllerAdvice(assignableTypes = ShiroAnnotateController.class)
    public static class AuthExceptionHandler {

        @ExceptionHandler(value = { AuthorizationException.class })
        public ResponseEntity&amp;lt;String&amp;gt; handle(AuthorizationException e, HandlerMethod m) {

            logger.info(&quot;Authorization Failed {} -- {}&quot;, e.getClass(), e.getMessage());

            String msg = &quot;not allow to access&quot;;
            if (e instanceof UnauthorizedException) {

                // 没有权限
                msg = &quot;you have no permissions&quot;;
            } else if (e instanceof UnauthenticatedException) {

                // 未登录
                msg = &quot;you must login first&quot;;
            }
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(msg);
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;登录逻辑&quot;&gt;登录逻辑&lt;/h3&gt;
&lt;p&gt;同样，由于没有了过滤链，我们需要自行实现 login 逻辑，代码非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 模拟登录接口
     * 
     * @param username
     * @param password
     * @return
     */
    @RequestMapping(&quot;/login&quot;)
    @ResponseBody
    public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password) {

        Subject subject = SecurityUtils.getSubject();
        AuthenticationToken token = new UsernamePasswordToken(username, password.toCharArray());

        try {
            // 执行登录
            subject.login(token);

        } catch (UnknownAccountException e) {

            // 未知用户
            logger.warn(&quot;the account {}  is not found&quot;, username);

            return &quot;account not found&quot;;
        } catch (IncorrectCredentialsException e) {

            // 用户或密码不正确
            logger.warn(&quot;the account or password is not correct&quot;);
            return &quot;account or password not correct&quot;;

        }
        return &quot;login success&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一些常见的&lt;strong&gt;登录异常&lt;/strong&gt;如下表，可按业务需要使用：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;UnknownAccountException&lt;/td&gt;
&lt;td&gt;找不到用户&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IncorrectCredentialsException&lt;/td&gt;
&lt;td&gt;用户名密码不正确&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;LockedAccountException&lt;/td&gt;
&lt;td&gt;用户被锁定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ExcessiveAttemptsException&lt;/td&gt;
&lt;td&gt;密码重试超过次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ExpiredCredentialsException&lt;/td&gt;
&lt;td&gt;密钥已经过期&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;登出的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @RequestMapping(&quot;/logout&quot;)
    @ResponseBody
    public String logout() {

        Subject subject = SecurityUtils.getSubject();

        // 执行注销
        if (subject.isAuthenticated()) {
            subject.logout();
        }
        return &quot;OK&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;深入一点&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;shiro-spring-boot-starter&lt;/strong&gt; 为我们实现了大量的自动装配功能，如以下代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SuppressWarnings(&quot;SpringFacetCodeInspection&quot;)
@Configuration
@ConditionalOnProperty(name = &quot;shiro.annotations.enabled&quot;, matchIfMissing = true)
public class ShiroAnnotationProcessorAutoConfiguration extends AbstractShiroAnnotationProcessorConfiguration {

    @Bean
    @DependsOn(&quot;lifecycleBeanPostProcessor&quot;)
    @ConditionalOnMissingBean
    @Override
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        return super.defaultAdvisorAutoProxyCreator();
    }

    @Bean
    @ConditionalOnMissingBean
    @Override
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {
        return super.authorizationAttributeSourceAdvisor(securityManager);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;strong&gt;DefaultAdvisorAutoProxyCreator&lt;/strong&gt; 是AOP实现的关键类，有兴趣可以继续深入了解&lt;/p&gt;
&lt;h3 id=&quot;进一步扩展&quot;&gt;进一步扩展&lt;/h3&gt;
&lt;p&gt;Shiro 的功能非常灵活，本文中的样例仅供参考，如果要在生产环境中使用，你需要思考更多方面的东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户信息、权限的存储需要数据库支持；&lt;/li&gt;
&lt;li&gt;为了加速权限校验的性能，你可以使用Cache模块；&lt;/li&gt;
&lt;li&gt;更安全的检查，比如动态校验码，密码失败重试次数检查；&lt;/li&gt;
&lt;li&gt;更通用的方案，比如JWT/OAUTH2.0 ，非常适用于微服务架构。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://shiro.apache.org/spring.html&quot;&gt;Shiro-integrating-with-spring&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://shiro.apache.org/spring-boot.html&quot;&gt;Shiro-integrating-with-springboot&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://waylau.gitbooks.io/apache-shiro-1-2-x-reference/content/&quot;&gt;Shiro-1.2.x-refence-waylau&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014479154&quot;&gt;Shirot-SprintBoot优雅整合&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;Apache Shiro 是一个强大易用的安全框架，其本身也提供了非常多的特性模块。&lt;br/&gt;本文旨在介绍如何将Shiro与当前流行的SpringBoot 框架结合使用，并提供了极简单的案例。&lt;br/&gt;笔者在问题求证过程中通过阅读部分源码，更深入理解了其框架原理。目前认为，Shiro强大之处&lt;br/&gt;还在于框架保持了简单易用、灵活扩展的特点，相信这也是许多人青睐它的原因吧。&lt;/p&gt;
&lt;p&gt;最后，欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，如果觉得老司机的文章还不赖，请多多分享转发^-^&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 16:49:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>目标 1. 了解ApacheShiro是什么，能做什么； 2. 通过QuickStart 代码领会 Shiro的关键概念； 3. 能基于SpringBoot 整合Shiro 实现URL安全访问； 4.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9471950.html</dc:identifier>
</item>
<item>
<title>SpringMVC请求参数和响应结果全局加密和解密 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9471938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9471938.html</guid>
<description>&lt;p&gt;前段时间在做一个对外的网关项目，涉及到加密和解密模块，这里详细分析解决方案和适用的场景。为了模拟真实的交互场景，先定制一下整个交互流程。第三方传输(包括请求和响应)数据报文包括三个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、timestamp，long类型，时间戳。&lt;/li&gt;
&lt;li&gt;2、data，String类型，实际的业务请求数据转化成的Json字符串再进行加密得到的密文。&lt;/li&gt;
&lt;li&gt;3、sign，签名，生成规则算法伪代码是SHA-256(data=xxx&amp;amp;timestamp=11111)，防篡改。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了简单起见，加密和解密采用AES，对称秘钥为&quot;throwable&quot;。上面的场景和加解密例子仅仅是为了模拟真实场景，安全系数低，切勿直接用于生产环境。&lt;/p&gt;
&lt;p&gt;现在还有一个地方要考虑，就是无法得知第三方如何提交请求数据，假定都是采用POST的Http请求方法，提交报文的时候指定ContentType为application/json或者application/x-www-form-urlencoded，两种ContentType提交方式的请求体是不相同的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//application/x-www-form-urlencoded
timestamp=xxxx&amp;amp;data=yyyyyy&amp;amp;sign=zzzzzzz

//application/json
{&quot;timestamp&quot;:xxxxxx,&quot;data&quot;:&quot;yyyyyyyy&quot;,&quot;sign&quot;:&quot;zzzzzzz&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一个要考虑的地方是，第三方强制要求部分接口需要用明文进行请求，在提供一些接口方法的时候，允许使用明文交互。总结一下就是要做到以下三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、需要加解密的接口请求参数要进行解密，响应结果要进行加密。&lt;/li&gt;
&lt;li&gt;2、不需要加解密的接口可以用明文请求。&lt;/li&gt;
&lt;li&gt;3、兼容ContentType为application/json或者application/x-www-form-urlencoded两种方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面三种情况要同时兼容算是十分严苛的场景，在生产环境中可能也是极少情况下才遇到，不过还是能找到相对优雅的解决方案。先定义两个特定场景的接口：&lt;/p&gt;
&lt;p&gt;1、下单接口(加密)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URL：/order/save&lt;/li&gt;
&lt;li&gt;HTTP METHOD：POST&lt;/li&gt;
&lt;li&gt;ContentType：application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;原始参数：orderId=yyyyyyyyy&amp;amp;userId=xxxxxxxxx&amp;amp;amount=zzzzzzzzz&lt;/li&gt;
&lt;li&gt;加密参数：timestamp=xxxx&amp;amp;data=yyyyyy&amp;amp;sign=zzzzzzz&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、订单查询接口(明文)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URL：/order/query&lt;/li&gt;
&lt;li&gt;ContentType：application/json&lt;/li&gt;
&lt;li&gt;HTTP METHOD：POST&lt;/li&gt;
&lt;li&gt;原始参数：{&quot;userId&quot;:&quot;xxxxxxxx&quot;}&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两个接口的ContentType不相同是为了故意复杂化场景，在下面的可取方案中，做法是把application/x-www-form-urlencoded中的形式如xxx=yyy&amp;amp;aaa=bbb的表单参数和application/json中形式如{&quot;key&quot;:&quot;value&quot;}的请求参数统一当做application/json形式的参数处理，这样的话，我们就可以直接在控制器方法中使用@RequestBody。&lt;/p&gt;

&lt;p&gt;我们首先基于上面说到的加解密方案，提供一个加解密工具类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum EncryptUtils {

    /**
     * SINGLETON
     */
    SINGLETON;

    private static final String SECRET = &quot;throwable&quot;;
    private static final String CHARSET = &quot;UTF-8&quot;;

    public String sha(String raw) throws Exception {
        MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;);
        messageDigest.update(raw.getBytes(CHARSET));
        return Hex.encodeHexString(messageDigest.digest());
    }

    private Cipher createAesCipher() throws Exception {
        return Cipher.getInstance(&quot;AES&quot;);
    }
    
    public String encryptByAes(String raw) throws Exception {
        Cipher aesCipher = createAesCipher();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGenerator.init(128, new SecureRandom(SECRET.getBytes(CHARSET)));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        aesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] bytes = aesCipher.doFinal(raw.getBytes(CHARSET));
        return Hex.encodeHexString(bytes);
    }

    public String decryptByAes(String raw) throws Exception {
        byte[] bytes = Hex.decodeHex(raw);
        Cipher aesCipher = createAesCipher();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGenerator.init(128, new SecureRandom(SECRET.getBytes(CHARSET)));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
        return new String(aesCipher.doFinal(bytes), CHARSET);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意为了简化加解密操作引入了apache的codec依赖：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-codec&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-codec&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.11&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的加解密过程中要注意两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、加密后的结果是byte数组，要把二进制转化为十六进制字符串。&lt;/li&gt;
&lt;li&gt;2、解密的时候要把原始密文由十六进制转化为二进制的byte数组。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面两点必须注意，否则会产生乱码，这个和编码相关，具体可以看之前写的一篇博客。&lt;/p&gt;
&lt;h2 id=&quot;不推荐的方案&quot;&gt;不推荐的方案&lt;/h2&gt;
&lt;p&gt;其实最暴力的方案是直接定制每个控制器的方法参数类型，因为我们可以和第三方磋商哪些请求路径需要加密，哪些是不需要加密，甚至哪些是application/x-www-form-urlencoded，哪些是application/json的请求，这样我们可以通过大量的硬编码达到最终的目标。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class Controller1 {

    @Autowired
    private ObjectMapper objectMapper;

    @PostMapping(value = &quot;/order/save&quot;,
            consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE,
            produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public ResponseEntity&amp;lt;EncryptModel&amp;gt; saveOrder(@RequestParam(name = &quot;sign&quot;) String sign,
                                                  @RequestParam(name = &quot;timestamp&quot;) Long timestamp,
                                                  @RequestParam(name = &quot;data&quot;) String data) throws Exception {
        EncryptModel model = new EncryptModel();
        model.setData(data);
        model.setTimestamp(timestamp);
        model.setSign(sign);
        String inRawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, model.getData(), model.getTimestamp());
        String inSign = EncryptUtils.SINGLETON.sha(inRawSign);
        if (!inSign.equals(model.getSign())){
            throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
        }
        //这里忽略实际的业务逻辑,简单设置返回的data为一个map
        Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;(8);
        result.put(&quot;code&quot;, &quot;200&quot;);
        result.put(&quot;message&quot;, &quot;success&quot;);
        EncryptModel out = new EncryptModel();
        out.setTimestamp(System.currentTimeMillis());
        out.setData(EncryptUtils.SINGLETON.encryptByAes(objectMapper.writeValueAsString(result)));
        String rawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, out.getData(), out.getTimestamp());
        out.setSign(EncryptUtils.SINGLETON.sha(rawSign));
        return ResponseEntity.ok(out);
    }

    @PostMapping(value = &quot;/order/query&quot;,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public ResponseEntity&amp;lt;Order&amp;gt;  queryOrder(@RequestBody User user){
        Order order = new Order();
        //这里忽略实际的业务逻辑
        return ResponseEntity.ok(order);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种做法能在短时间完成对应的加解密功能，不需要加解密的接口不用引入相关的代码即可。缺陷十分明显，存在硬编码、代码冗余等问题，一旦接口增多，项目的维护难度大大提高。因此，这种做法是不可取的。&lt;/p&gt;
&lt;h2 id=&quot;混合方案之filter和springmvc的http消息转换器&quot;&gt;混合方案之Filter和SpringMVC的Http消息转换器&lt;/h2&gt;
&lt;p&gt;这里先说一点，这里是在SpringMVC中使用Filter。因为要兼容两种contentType，我们需要做到几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、修改请求头的contentType为application/json。&lt;/li&gt;
&lt;li&gt;2、修改请求体中的参数，统一转化为InputStream。&lt;/li&gt;
&lt;li&gt;3、定制URL规则，区别需要加解密和不需要加解密的URL。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用Filter有一个优点：不需要理解SpringMVC的流程，也不需要扩展SpringMVC的相关组件。缺点也比较明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、如果需要区分加解密，只能通过URL规则进行过滤。&lt;/li&gt;
&lt;li&gt;2、需要加密的接口的SpringMVC控制器的返回参数必须是加密后的实体类，无法做到加密逻辑和业务逻辑完全拆分，也就是解密逻辑对接收的参数是无感知，但是加密逻辑对返回结果是有感知的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：上面提到的几个需要修改请求参数、请求头等是因为特殊场景的定制，所以如果无此场景可以直接看下面的&quot;单纯的Json请求参数和Json响应结果&quot;小节。流程大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-ed-1.png&quot; alt=&quot;sp-ed-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编写Filter的实现和HttpServletRequestWrapper的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//CustomEncryptFilter
@RequiredArgsConstructor
public class CustomEncryptFilter extends OncePerRequestFilter {

    private final ObjectMapper objectMapper;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        //Content-Type
        String contentType = request.getContentType();
        String requestBody = null;
        boolean shouldEncrypt = false;
        if (StringUtils.substringMatch(contentType, 0, MediaType.APPLICATION_FORM_URLENCODED_VALUE)) {
            shouldEncrypt = true;
            requestBody = convertFormToString(request);
        } else if (StringUtils.substringMatch(contentType, 0, MediaType.APPLICATION_JSON_VALUE)) {
            shouldEncrypt = true;
            requestBody = convertInputStreamToString(request.getInputStream());
        }
        if (!shouldEncrypt) {
            filterChain.doFilter(request, response);
        } else {
            CustomEncryptHttpWrapper wrapper = new CustomEncryptHttpWrapper(request, requestBody);
            wrapper.putHeader(&quot;Content-Type&quot;, MediaType.APPLICATION_PROBLEM_JSON_UTF8_VALUE);
            filterChain.doFilter(wrapper, response);
        }
    }

    private String convertFormToString(HttpServletRequest request) {
        Map&amp;lt;String, String&amp;gt; result = new HashMap&amp;lt;&amp;gt;(8);
        Enumeration&amp;lt;String&amp;gt; parameterNames = request.getParameterNames();
        while (parameterNames.hasMoreElements()) {
            String name = parameterNames.nextElement();
            result.put(name, request.getParameter(name));
        }
        try {
            return objectMapper.writeValueAsString(result);
        } catch (JsonProcessingException e) {
            throw new IllegalArgumentException(e);
        }
    }

    private String convertInputStreamToString(InputStream inputStream) throws IOException {
        return StreamUtils.copyToString(inputStream, Charset.forName(&quot;UTF-8&quot;));
    }
}

//CustomEncryptHttpWrapper
public class CustomEncryptHttpWrapper extends HttpServletRequestWrapper {

    private final Map&amp;lt;String, String&amp;gt; headers = new HashMap&amp;lt;&amp;gt;(8);
    private final byte[] data;

    public CustomEncryptHttpWrapper(HttpServletRequest request, String content) {
        super(request);
        data = content.getBytes(Charset.forName(&quot;UTF-8&quot;));
        Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String key = headerNames.nextElement();
            headers.put(key, request.getHeader(key));
        }
    }

    public void putHeader(String key, String value) {
        headers.put(key, value);
    }

    @Override
    public String getHeader(String name) {
        return headers.get(name);
    }

    @Override
    public Enumeration&amp;lt;String&amp;gt; getHeaders(String name) {
        return Collections.enumeration(Collections.singletonList(headers.get(name)));
    }

    @Override
    public Enumeration&amp;lt;String&amp;gt; getHeaderNames() {
        return  Collections.enumeration(headers.keySet());
    }

    @Override
    public ServletInputStream getInputStream() throws IOException {
        ByteArrayInputStream inputStream = new ByteArrayInputStream(data);
        return new ServletInputStream() {
            @Override
            public boolean isFinished() {
                return !isReady();
            }

            @Override
            public boolean isReady() {
                return inputStream.available() &amp;gt; 0;
            }

            @Override
            public void setReadListener(ReadListener listener) {

            }

            @Override
            public int read() throws IOException {
                return inputStream.read();
            }
        };
    }

    @Override
    public BufferedReader getReader() throws IOException {
        return super.getReader();
    }
}

//CustomEncryptConfiguration
@Configuration
public class CustomEncryptConfiguration {

    @Bean
    public FilterRegistrationBean&amp;lt;CustomEncryptFilter&amp;gt; customEncryptFilter(ObjectMapper objectMapper){
        FilterRegistrationBean&amp;lt;CustomEncryptFilter&amp;gt; bean = new FilterRegistrationBean&amp;lt;&amp;gt;(new CustomEncryptFilter(objectMapper));
        bean.addUrlPatterns(&quot;/e/*&quot;);
        return bean;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制器代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//可加密的，空接口
public interface Encryptable {
}


@Data
public class Order implements Encryptable{

    private Long userId;
}

@Data
public class EncryptResponse&amp;lt;T&amp;gt; implements Encryptable {
    
    private Integer code;
    private T data;
}

@RequiredArgsConstructor
@RestController
public class Controller {

    private final ObjectMapper objectMapper;

    @PostMapping(value = &quot;/e/order/save&quot;,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public EncryptResponse&amp;lt;Order&amp;gt; saveOrder(@RequestBody Order order) throws Exception {
        //这里忽略实际的业务逻辑,简单设置返回的data为一个map
        EncryptResponse&amp;lt;Order&amp;gt; response = new EncryptResponse&amp;lt;&amp;gt;();
        response.setCode(200);
        response.setData(order);
        return response;
    }

    @PostMapping(value = &quot;/c/order/query&quot;,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public ResponseEntity&amp;lt;Order&amp;gt; queryOrder(@RequestBody User user) {
        Order order = new Order();
        //这里忽略实际的业务逻辑
        return ResponseEntity.ok(order);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可能有人有疑问，为什么不在Filter做加解密的操作？因为考虑到场景太特殊，要兼容两种形式的表单提交参数，如果在Filter做加解密操作，会影响到Controller的编码，这就违反了全局加解密不影响到里层业务代码的目标。上面的Filter只会拦截URL满足/e/*的请求，因此查询接口/c/order/query不会受到影响。这里使用了标识接口用于决定请求参数或者响应结果是否需要加解密，也就是只需要在HttpMessageConverter中判断请求参数的类型或者响应结果的类型是否加解密标识接口的子类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequiredArgsConstructor
public class CustomEncryptHttpMessageConverter extends MappingJackson2HttpMessageConverter {

    private final ObjectMapper objectMapper;

    @Override
    protected Object readInternal(Class&amp;lt;?&amp;gt; clazz, HttpInputMessage inputMessage)
            throws IOException, HttpMessageNotReadableException {
        if (Encryptable.class.isAssignableFrom(clazz)) {
            EncryptModel in = objectMapper.readValue(StreamUtils.copyToByteArray(inputMessage.getBody()), EncryptModel.class);
            String inRawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, in.getData(), in.getTimestamp());
            String inSign;
            try {
                inSign = EncryptUtils.SINGLETON.sha(inRawSign);
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            if (!inSign.equals(in.getSign())) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            try {
                return objectMapper.readValue(EncryptUtils.SINGLETON.decryptByAes(in.getData()), clazz);
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;解密失败!&quot;);
            }
        } else {
            return super.readInternal(clazz, inputMessage);
        }
    }

    @Override
    protected void writeInternal(Object object, Type type, HttpOutputMessage outputMessage)
            throws IOException, HttpMessageNotWritableException {
        Class&amp;lt;?&amp;gt; clazz = (Class) type;
        if (Encryptable.class.isAssignableFrom(clazz)) {
            EncryptModel out = new EncryptModel();
            out.setTimestamp(System.currentTimeMillis());
            try {
                out.setData(EncryptUtils.SINGLETON.encryptByAes(objectMapper.writeValueAsString(object)));
                String rawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, out.getData(), out.getTimestamp());
                out.setSign(EncryptUtils.SINGLETON.sha(rawSign));
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;参数签名失败!&quot;);
            }
            super.writeInternal(out, type, outputMessage);
        } else {
            super.writeInternal(object, type, outputMessage);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自实现的HttpMessageConverter主要需要判断请求参数的类型和返回值的类型，从而判断是否需要进行加解密。&lt;/p&gt;

&lt;p&gt;一般情况下，对接方的请求参数和响应结果是完全规范统一使用Json(contentType指定为application/json，使用@RequestBody接收参数)，那么所有的事情就会变得简单，因为不需要考虑请求参数由xxx=yyy&amp;amp;aaa=bbb转换为InputStream再交给SpringMVC处理，因此我们只需要提供一个MappingJackson2HttpMessageConverter子类实现(继承它并且覆盖对应方法，添加加解密特性)。我们还是使用标识接口用于决定请求参数或者响应结果是否需要加解密：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequiredArgsConstructor
public class CustomEncryptHttpMessageConverter extends MappingJackson2HttpMessageConverter {

    private final ObjectMapper objectMapper;

    @Override
    protected Object readInternal(Class&amp;lt;?&amp;gt; clazz, HttpInputMessage inputMessage)
            throws IOException, HttpMessageNotReadableException {
        if (Encryptable.class.isAssignableFrom(clazz)) {
            EncryptModel in = objectMapper.readValue(StreamUtils.copyToByteArray(inputMessage.getBody()), EncryptModel.class);
            String inRawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, in.getData(), in.getTimestamp());
            String inSign;
            try {
                inSign = EncryptUtils.SINGLETON.sha(inRawSign);
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            if (!inSign.equals(in.getSign())) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            try {
                return objectMapper.readValue(EncryptUtils.SINGLETON.decryptByAes(in.getData()), clazz);
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;解密失败!&quot;);
            }
        } else {
            return super.readInternal(clazz, inputMessage);
        }
    }

    @Override
    protected void writeInternal(Object object, Type type, HttpOutputMessage outputMessage)
            throws IOException, HttpMessageNotWritableException {
        Class&amp;lt;?&amp;gt; clazz = (Class) type;
        if (Encryptable.class.isAssignableFrom(clazz)) {
            EncryptModel out = new EncryptModel();
            out.setTimestamp(System.currentTimeMillis());
            try {
                out.setData(EncryptUtils.SINGLETON.encryptByAes(objectMapper.writeValueAsString(object)));
                String rawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, out.getData(), out.getTimestamp());
                out.setSign(EncryptUtils.SINGLETON.sha(rawSign));
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;参数签名失败!&quot;);
            }
            super.writeInternal(out, type, outputMessage);
        } else {
            super.writeInternal(object, type, outputMessage);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，代码是拷贝上一节提供的HttpMessageConverter实现，然后控制器方法的参数使用@RequestBody注解并且类型实现加解密标识接口Encryptable即可，返回值的类型也需要实现加解密标识接口Encryptable。这种做法可以让控制器的代码对加解密完全无感知。当然，也可以不改变原来的MappingJackson2HttpMessageConverter实现，使用RequestBodyAdvice和ResponseBodyAdvice完成相同的功能：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequiredArgsConstructor
public class CustomRequestBodyAdvice extends RequestBodyAdviceAdapter {

    private final ObjectMapper objectMapper;

    @Override
    public boolean supports(MethodParameter methodParameter, Type targetType,
                            Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) {
        Class&amp;lt;?&amp;gt; clazz = (Class) targetType;
        return Encryptable.class.isAssignableFrom(clazz);
    }

    @Override
    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType,
                                           Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) throws IOException {
        Class&amp;lt;?&amp;gt; clazz = (Class) targetType;
        if (Encryptable.class.isAssignableFrom(clazz)) {
            String content = StreamUtils.copyToString(inputMessage.getBody(), Charset.forName(&quot;UTF-8&quot;));
            EncryptModel in = objectMapper.readValue(content, EncryptModel.class);
            String inRawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, in.getData(), in.getTimestamp());
            String inSign;
            try {
                inSign = EncryptUtils.SINGLETON.sha(inRawSign);
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            if (!inSign.equals(in.getSign())) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            ByteArrayInputStream inputStream = new ByteArrayInputStream(in.getData().getBytes(Charset.forName(&quot;UTF-8&quot;)));
            return new MappingJacksonInputMessage(inputStream, inputMessage.getHeaders());
        } else {
            return super.beforeBodyRead(inputMessage, parameter, targetType, converterType);
        }
    }
}

@RequiredArgsConstructor
public class CustomResponseBodyAdvice extends JsonViewResponseBodyAdvice {

    private final ObjectMapper objectMapper;

    @Override
    public boolean supports(MethodParameter returnType, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) {
        Class&amp;lt;?&amp;gt; parameterType = returnType.getParameterType();
        return Encryptable.class.isAssignableFrom(parameterType);
    }

    @Override
    protected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,
                                           MethodParameter returnType, ServerHttpRequest request,
                                           ServerHttpResponse response) {
        Class&amp;lt;?&amp;gt; parameterType = returnType.getParameterType();
        if (Encryptable.class.isAssignableFrom(parameterType)) {
            EncryptModel out = new EncryptModel();
            out.setTimestamp(System.currentTimeMillis());
            try {
                out.setData(EncryptUtils.SINGLETON.encryptByAes(objectMapper.writeValueAsString(bodyContainer.getValue())));
                String rawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, out.getData(), out.getTimestamp());
                out.setSign(EncryptUtils.SINGLETON.sha(rawSign));
                out.setSign(EncryptUtils.SINGLETON.sha(rawSign));
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;参数签名失败!&quot;);
            }
        } else {
            super.beforeBodyWriteInternal(bodyContainer, contentType, returnType, request, response);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;一般情况下，对接方的请求参数完全采用application/x-www-form-urlencoded表单请求参数返回结果全部按照Json接收，我们也可以通过一个HttpMessageConverter实现就完成加解密模块。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FormHttpMessageConverter implements HttpMessageConverter&amp;lt;Object&amp;gt; {

    private final List&amp;lt;MediaType&amp;gt; mediaTypes;
    private final ObjectMapper objectMapper;

    public FormHttpMessageConverter(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
        this.mediaTypes = new ArrayList&amp;lt;&amp;gt;(1);
        this.mediaTypes.add(MediaType.APPLICATION_FORM_URLENCODED);
    }

    @Override
    public boolean canRead(Class&amp;lt;?&amp;gt; clazz, MediaType mediaType) {
        return Encryptable.class.isAssignableFrom(clazz) &amp;amp;&amp;amp; mediaTypes.contains(mediaType);
    }

    @Override
    public boolean canWrite(Class&amp;lt;?&amp;gt; clazz, MediaType mediaType) {
        return Encryptable.class.isAssignableFrom(clazz) &amp;amp;&amp;amp; mediaTypes.contains(mediaType);
    }

    @Override
    public List&amp;lt;MediaType&amp;gt; getSupportedMediaTypes() {
        return mediaTypes;
    }

    @Override
    public Object read(Class&amp;lt;?&amp;gt; clazz, HttpInputMessage inputMessage) throws
            IOException, HttpMessageNotReadableException {
        if (Encryptable.class.isAssignableFrom(clazz)) {
            String content = StreamUtils.copyToString(inputMessage.getBody(), Charset.forName(&quot;UTF-8&quot;));
            EncryptModel in = objectMapper.readValue(content, EncryptModel.class);
            String inRawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, in.getData(), in.getTimestamp());
            String inSign;
            try {
                inSign = EncryptUtils.SINGLETON.sha(inRawSign);
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            if (!inSign.equals(in.getSign())) {
                throw new IllegalArgumentException(&quot;验证参数签名失败!&quot;);
            }
            try {
                return objectMapper.readValue(EncryptUtils.SINGLETON.decryptByAes(in.getData()), clazz);
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;解密失败!&quot;);
            }
        } else {
            MediaType contentType = inputMessage.getHeaders().getContentType();
            Charset charset = (contentType != null &amp;amp;&amp;amp; contentType.getCharset() != null ?
                    contentType.getCharset() : Charset.forName(&quot;UTF-8&quot;));
            String body = StreamUtils.copyToString(inputMessage.getBody(), charset);

            String[] pairs = StringUtils.tokenizeToStringArray(body, &quot;&amp;amp;&quot;);
            MultiValueMap&amp;lt;String, String&amp;gt; result = new LinkedMultiValueMap&amp;lt;&amp;gt;(pairs.length);
            for (String pair : pairs) {
                int idx = pair.indexOf('=');
                if (idx == -1) {
                    result.add(URLDecoder.decode(pair, charset.name()), null);
                } else {
                    String name = URLDecoder.decode(pair.substring(0, idx), charset.name());
                    String value = URLDecoder.decode(pair.substring(idx + 1), charset.name());
                    result.add(name, value);
                }
            }
            return result;
        }
    }

    @Override
    public void write(Object o, MediaType contentType, HttpOutputMessage outputMessage)
            throws IOException, HttpMessageNotWritableException {
        Class&amp;lt;?&amp;gt; clazz = o.getClass();
        if (Encryptable.class.isAssignableFrom(clazz)) {
            EncryptModel out = new EncryptModel();
            out.setTimestamp(System.currentTimeMillis());
            try {
                out.setData(EncryptUtils.SINGLETON.encryptByAes(objectMapper.writeValueAsString(o)));
                String rawSign = String.format(&quot;data=%s&amp;amp;timestamp=%d&quot;, out.getData(), out.getTimestamp());
                out.setSign(EncryptUtils.SINGLETON.sha(rawSign));
                StreamUtils.copy(objectMapper.writeValueAsString(out)
                        .getBytes(Charset.forName(&quot;UTF-8&quot;)), outputMessage.getBody());
            } catch (Exception e) {
                throw new IllegalArgumentException(&quot;参数签名失败!&quot;);
            }
        } else {
            String out = objectMapper.writeValueAsString(o);
            StreamUtils.copy(out.getBytes(Charset.forName(&quot;UTF-8&quot;)), outputMessage.getBody());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的HttpMessageConverter的实现可以参考org.springframework.http.converter.FormHttpMessageConverter。&lt;/p&gt;

&lt;p&gt;这篇文章强行复杂化了实际的情况(但是在实际中真的碰到过)，一般情况下，现在流行使用Json进行数据传输，在SpringMVC项目中，我们只需要针对性地改造MappingJackson2HttpMessageConverter即可(继承并且添加特性)，如果对SpringMVC的源码相对熟悉的话，直接添加自定义的RequestBodyAdvice(RequestBodyAdviceAdapter)和ResponseBodyAdvice(JsonViewResponseBodyAdvice)实现也可以达到目的。至于为什么使用HttpMessageConverter做加解密功能，这里基于SpringMVC源码的对请求参数处理的过程整理了一张处理流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-ed-2.png&quot; alt=&quot;sp-ed-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面流程最核心的代码可以看&lt;code&gt;AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters&lt;/code&gt;和&lt;code&gt;HandlerMethodArgumentResolverComposite#resolveArgument&lt;/code&gt;，毕竟源码不会骗人。控制器方法返回值的处理基于是对称的，阅读起来也比较轻松。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-web-starter:2.0.3.RELEASE源码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（本文完 c-d-4）&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 16:41:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 前段时间在做一个对外的网关项目，涉及到加密和解密模块，这里详细分析解决方案和适用的场景。为了模拟真实的交互场景，先定制一下整个交互流程。第三方传输(包括请求和响应)数据报文包括三个部分： 1、t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9471938.html</dc:identifier>
</item>
<item>
<title>进制转换 - 有思想的行动者</title>
<link>http://www.cnblogs.com/thoughtful-actors/p/9471910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thoughtful-actors/p/9471910.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1、进制：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　是人为的一种计数方法，一般以进制基数进行命名区分，例如常见的十进制就是逢十进一。&lt;/p&gt;
&lt;p&gt;　    &lt;span&gt;2、分类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　进制主要有二进制、四进制、七进制、八进制、十进制、十二进制、十六进制和六十进制等。&lt;/p&gt;
&lt;p&gt;　　　　　　其中生活中最常用的是十进制，十二进制主要是用在时间计时和年份上，&lt;span&gt;计算机识别的语言就是以二进制形式&lt;/span&gt;存在的数据。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;3、基数、位权、系数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　基数：即进位置制，命名规则也是依据基数命名，例如二进制就是逢二进一，基数为2。&lt;/p&gt;
&lt;p&gt;　　　　系数：不同位权上的数字，例如十进制123，系数分别为1,2,3。&lt;/p&gt;
&lt;p&gt;　　　　位权：即数制中某一固定位置对应的单位，例如十进制123，系数1的位权是100，系数2的位权是10，系数3的位权是1。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;进制&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基数&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;位权&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;系数&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;符号&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;十进制&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;10&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;10&lt;sup&gt;(0~n)&lt;/sup&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(0~9)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;D&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;二进制&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2&lt;sup&gt;(0~n)&lt;/sup&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(0,1)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;B&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;八进制&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;8&lt;sup&gt;(0~n)&lt;/sup&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(0~7)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;O&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;十六进制&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;16&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;16&lt;sup&gt;(0~n)&lt;/sup&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(0~9,A~F)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;H&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;p&gt;&lt;span&gt;二、十进制转R进制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　十进制转其他进制方法：按照&lt;span&gt;除相应基数取余逆排法&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　例如：十进制转二进制：（123）D=（）B&lt;/p&gt;
&lt;p&gt;   计算过程：&lt;span&gt;123/2=61 余1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;61/2=30   余1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;30/2=15   余0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;15/2=7     余1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;7/2=3       余1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;3/2=1       余1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;1/2=0       余1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　然后把余数按照从下到上的顺序再从左到右排列&lt;/p&gt;
&lt;p&gt;　　最后结果就是（123）D=(1111011)B&lt;/p&gt;
&lt;p&gt;　　十进制转其他进制的方法都一样，只需要&lt;span&gt;改变除数&lt;/span&gt;就行，转成八进制就除以8，转成十六进制就除以16。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、R进制转十进制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　其他进制转十进制方法：按权求和，即&lt;span&gt;系数*位权展开求和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　例如：二进制转十进制：（1111011）B=（）D&lt;/p&gt;
&lt;p&gt;　　计算过程：&lt;span&gt;1*2&lt;sup&gt;6&lt;/sup&gt;+1*2&lt;sup&gt;5&lt;/sup&gt;+1*2&lt;sup&gt;4&lt;/sup&gt;+1*2&lt;sup&gt;3&lt;/sup&gt;+0*2&lt;sup&gt;2&lt;/sup&gt;+1*2&lt;sup&gt;1&lt;/sup&gt;+1*2&lt;sup&gt;0&lt;/sup&gt;=123&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后结果就是（1111011）B=（123）D&lt;/p&gt;
&lt;p&gt;　　其他进制转十进制的方法都一样，只需要&lt;span&gt;改变位权即幂运算的底数&lt;/span&gt;就行，幂运算的底数就是相应的基数，指数就是从左向右以0开始计位数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、二进制转八进制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　二进制转八进制方法：从左到右每&lt;span&gt;三位合一&lt;/span&gt;，遇到高位不够补0&lt;/p&gt;
&lt;p&gt;　　例如：（1111011）B=（）O&lt;/p&gt;
&lt;p&gt;　　从左到右：&lt;span&gt;1 111 011 = 001 111 011 =（1 7 3）O&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后结果为（1111011）B=（173）O&lt;/p&gt;
&lt;p&gt;　　三位一组计算时就可以看成三个互不关联的&lt;span&gt;二进制&lt;/span&gt;，然后分别&lt;span&gt;转成&lt;/span&gt;相应的&lt;span&gt;十进制数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;五、二进制转十六进制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　方法：从左到右每&lt;span&gt;四位合一&lt;/span&gt;，遇到高位不够补0&lt;/p&gt;
&lt;p&gt;　　例如：（1111011）B=（）H&lt;/p&gt;
&lt;p&gt;　　从左到右：&lt;span&gt;111 1011 = 0111 1011 = （7 11）=（7B）H&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后结果为：（1111011）B=（7B）H&lt;/p&gt;
&lt;p&gt;　　四一组计算时就可以看成四个互不关联的&lt;span&gt;二进制&lt;/span&gt;，然后分别&lt;span&gt;转成&lt;/span&gt;相应的&lt;span&gt;十进制数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;六、八进制转二进制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　方法：从左到右每个&lt;span&gt;系数&lt;/span&gt;都&lt;span&gt;转成&lt;/span&gt;相应的&lt;span&gt;二进制数&lt;/span&gt;，可以看成是一分三&lt;/p&gt;
&lt;p&gt;　　例如：（173）O=（）B&lt;/p&gt;
&lt;p&gt;　　从左到右：&lt;span&gt;1 7 3=1 111 011=（1111011）B&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后结果为：（173）O=（1111011）B&lt;/p&gt;
&lt;p&gt;　　此过程可以看成是二进制转成八进制的逆运算，每位系数都按照十进制转二进制的规则转成相应的二进制，然后按照原来&lt;span&gt;从左到右&lt;/span&gt;的顺序排列，最高位的0可以省略。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;七、十六进制转二进制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　方法：从左到右每个&lt;span&gt;系数&lt;/span&gt;都&lt;span&gt;转成&lt;/span&gt;相应的&lt;span&gt;二进制数&lt;/span&gt;，可以看成是一分四&lt;/p&gt;
&lt;p&gt;　　例如：（7B）H=（）B&lt;/p&gt;
&lt;p&gt;　　从左到右：&lt;span&gt;7B=7 B= 7 11= 0111 1011=（1111011）B&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后结果为：（173）O=（1111011）B&lt;/p&gt;
&lt;p&gt;　　此过程可以看成是二进制转成十六进制的逆运算，每位系数都按照十进制转二进制的规则转成相应的二进制，然后按照原来&lt;span&gt;从左到右&lt;/span&gt;的顺序排列，最高位的0可以省去。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;八、八进制与十六进制相互转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　两个进制之间的转换可以先转成二进制或者十进制，然后再转成相应的进制。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 16:27:00 +0000</pubDate>
<dc:creator>有思想的行动者</dc:creator>
<og:description>一、概念 1、进制： 是人为的一种计数方法，一般以进制基数进行命名区分，例如常见的十进制就是逢十进一。 2、分类： 进制主要有二进制、四进制、七进制、八进制、十进制、十二进制、十六进制和六十进制等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thoughtful-actors/p/9471910.html</dc:identifier>
</item>
<item>
<title>Node的简介 - 一步一步向上爬</title>
<link>http://www.cnblogs.com/z937741304/p/9471904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z937741304/p/9471904.html</guid>
<description>&lt;p&gt;　　从开始学习node到现在已经有半年多了，中间没有做过什么实际工作中的项目，所以感觉自己的知识有些匮乏，但是我还是要写这些文章，因为工作中的需要用node来开发后台环境，再加上我对这些知识记得不多，都是来看以前写的源码抄过来，自己根本记不住一些繁琐的代码，想借此机会来巩固一下我所学到的东西，等以后慢慢来补充我现在所写的文章。&lt;/p&gt;
&lt;p&gt;　　可以去百度node.js中文网，上面所写的第一句话就是这么一句概括了node.js所有的话吧。&lt;/p&gt;
&lt;p&gt;　　node.js是一个基于Chorme V8引擎的javascript运行环境。node.js使用了一个事件驱动，非阻塞式I/O模型，使其轻量又高效。&lt;/p&gt;


&lt;p&gt;　　Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。&lt;/p&gt;
&lt;p&gt;　　众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。&lt;/p&gt;
&lt;p&gt;后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。（2001年推出的古老的IE 6到今天仍然有人在使用！）&lt;/p&gt;
&lt;p&gt;没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。&lt;/p&gt;
&lt;p&gt;先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了Firefox浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的Safari浏览器，不过仅限于Mac平台。&lt;/p&gt;
&lt;p&gt;　　随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了Chrome浏览器。&lt;/p&gt;
&lt;p&gt;Chrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。&lt;/p&gt;
&lt;p&gt;现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。&lt;/p&gt;
&lt;p&gt;浏览器大战和Node有何关系？&lt;/p&gt;
&lt;p&gt;　　话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。&lt;/p&gt;
&lt;p&gt;　　因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。&lt;/p&gt;
&lt;p&gt;选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。&lt;/p&gt;
&lt;p&gt;　　于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。&lt;/p&gt;
&lt;p&gt;在Node上运行的JavaScript相比其他后端开发语言有何优势？&lt;/p&gt;
&lt;p&gt;　　最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。&lt;/p&gt;
&lt;p&gt;　　其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。&lt;/p&gt;
&lt;h3&gt;　&lt;/h3&gt;
&lt;h2&gt;　　node是啥？&lt;/h2&gt;
&lt;p&gt;　　传统意义上的javascript运行在浏览器上，这是因为浏览器内核实际上分为两个部分，渲染引擎和javaScript引擎。前者主要负责渲染HTML+CSS，后者主要负责运行javaScript。Chorme使用的javascript引擎是V8，它的运行速度非常快。&lt;/p&gt;

&lt;h2&gt;　　node 跟 chorme 有什么区别？&lt;/h2&gt;
&lt;p&gt;　　架构一样，都是基于事件驱动的异步架构！&lt;/p&gt;
&lt;p&gt;　　浏览器主要是通过事件驱动来服务页面交互。&lt;/p&gt;

&lt;p&gt;　　node 主要是通过事件驱动来服务 I/O&lt;/p&gt;
&lt;p&gt;　　node 没有HTML，WebKit和显卡等等的UI技术支持&lt;/p&gt;

&lt;h2&gt;　　为什么要用node.js?&lt;/h2&gt;
&lt;p&gt;　　总的来说，Node.js 适合以下场景:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实时性应用，比如在线多人协作工具，网页聊天应用等。&lt;/li&gt;
&lt;li&gt;以 I/O 为主的高并发应用，比如为客户端提供 API，读取数据库。&lt;/li&gt;
&lt;li&gt;流式应用，比如客户端经常上传文件。&lt;/li&gt;
&lt;li&gt;前后端分离。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　实际上前两者可以归结为一种，即客户端广泛使用长连接，虽然并发数较高，但其中大部分是空闲连接。&lt;/p&gt;
&lt;p&gt;　　Node.js 也有它的局限性，它并不适合 CPU 密集型的任务，比如人工智能方面的计算，视频、图片的处理等。&lt;/p&gt;
&lt;p&gt;当然，以上缺点不是信口开河，或者死记硬背，更不是人云亦云，需要我们对 Node.js 的原理有一定的了解，才能做出正确的判断。&lt;/p&gt;
&lt;h3&gt;　　　&lt;/h3&gt;
&lt;h2&gt;　　基础概念&lt;/h2&gt;
&lt;h3 id=&quot;articleHeader3&quot;&gt;　　并发 下面的这些是参考的他人的文章&lt;/h3&gt;
&lt;p&gt;　　与客户端不同，服务端开发者非常关心的一项数据是并发数，也就是这台服务器最多能支持多少个客户端的并发请求。早年的 C10K 问题就是讨论如何利用单台服务器支持 10K 并发数。当然随着软硬件性能的提高，目前 C10K 已经不再是问题，我们开始尝试解决 C10M 问题，即单台服务器如何处理百万级的并发。&lt;/p&gt;
&lt;p&gt;　　在 C10K 提出时，我们还在使用 Apache 服务器，它的工作原理是每当有一个网络请求到达，就 fork 出一个子进程并在子进程中运行 PHP 脚本。执行完脚本后再把结果发回客户端。&lt;/p&gt;
&lt;p&gt;　　这样可以确保不同进程之间互不干扰，即使一个进程出问题也不影响整个服务器，但是缺点也很明显:进程是一个比较重的概念，拥有自己的堆和栈，占用内存较多，一台服务器能运行的进程数量有上限，大约也就在几千左右。&lt;/p&gt;
&lt;p&gt;虽然 Apache 后来使用了 FastCGI，但本质上只是一个进程池，它减少了创建进程的开销，但无法有效提高并发数。&lt;/p&gt;
&lt;p&gt;　　Java 的 Servlet 使用了线程池，即每个 Servlet 运行在一个线程上。线程虽然比进程轻量，但也是相对的。 有人测试过 ，每个线程独享的栈的大小是 1M，依然不够高效。除此以外，多线程编程会带来各种麻烦，这一点想必程序员们都深有体会。&lt;/p&gt;
&lt;p&gt;　　如果不使用线程，还有两种解决方案，分别是使用协程(coroutine)和非阻塞 I/O。协程比线程更加轻量，多个协程可以运行在同一个线程中，并由程序员自己负责调度，这种技术在 Go 语言中被广泛使用。而非阻塞 I/O 则被 Node.js 用来处理高并发的场景。&lt;/p&gt;

&lt;h2 id=&quot;articleHeader4&quot;&gt;　　非阻塞 I/O&lt;/h2&gt;
&lt;p&gt;　　这里所说的 I/O 可以分为两种: 网络 I/O 和文件 I/O，实际上两者高度类似。 I/O 可以分为两个步骤，首先把文件(网络)中的内容拷贝到缓冲区，这个缓冲区位于操作系统独占的内存区域中。随后再把缓冲区中的内容拷贝到用户程序的内存区域中。&lt;/p&gt;
&lt;p&gt;　　对于阻塞 I/O 来说，从发起读请求，到缓冲区就绪，再到用户进程获取数据，这两个步骤都是阻塞的。&lt;/p&gt;
&lt;p&gt;　　非阻塞 I/O 实际上是向内核轮询，缓冲区是否就绪，如果没有则继续执行其他操作。当缓冲区就绪时，讲缓冲区内容拷贝到用户进程，这一步实际上还是阻塞的。&lt;/p&gt;
&lt;p&gt;I/O 多路复用技术是指利用单个线程处理多个网络 I/O，我们常说的 select 、 epoll 就是用来轮询所有 socket 的函数。比如 Apache 采用了前者，而 Nginx 和 Node.js 使用了后者，区别在于后者效率更高。由于 I/O 多路复用实际上还是单线程的轮询，因此它也是一种非阻塞 I/O 的方案。&lt;/p&gt;
&lt;p&gt;　　异步 I/O 是最理想的 I/O 模型，然而可惜的是真正的异步 I/O 并不存在。 Linux 上的 AIO 通过信号和回调来传递数据，但是存在缺陷。现有的 libeio 以及 Windows 上的 IOCP，本质上都是利用线程池与阻塞 I/O 来模拟异步 I/O。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader5&quot;&gt;　　Node.js 线程模型&lt;/h2&gt;
&lt;p&gt;很多文章都提到 Node.js 是单线程的，然而这样的说法并不严谨，甚至可以说很不负责，因为我们至少会想到以下几个问题:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Node.js 在一个线程中如何处理并发请求？&lt;/li&gt;
&lt;li&gt;Node.js 在一个线程中如何进行文件的异步 I/O？&lt;/li&gt;
&lt;li&gt;Node.js 如何重复利用服务器上的多个 CPU 的处理能力？&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;　　&lt;/h3&gt;
&lt;h2 id=&quot;articleHeader6&quot;&gt;　　网络 I/O&lt;/h2&gt;
&lt;p&gt;　　Node.js 确实可以在单线程中处理大量的并发请求，但这需要一定的编程技巧。总之，在利用 Node.js 编程时，任何耗时操作一定要使用异步来完成，避免阻塞当前函数。因为你在为客户端提供服务，而所有代码总是单线程、顺序执行。&lt;/p&gt;

&lt;h2 id=&quot;articleHeader7&quot;&gt;　　文件 I/O&lt;/h2&gt;
&lt;p&gt;　　我在之前的文章中也强调过，异步是为了优化体验，避免卡顿。而真正节省处理时间，利用 CPU 多核性能，还是要靠多线程并行处理。&lt;/p&gt;
&lt;p&gt;　　实际上 Node.js 在底层维护了一个线程池。之前在基础概念部分也提到过，不存在真正的异步文件 I/O，通常是通过线程池来模拟。线程池中默认有四个线程，用来进行文件 I/O。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，我们无法直接操作底层的线程池，实际上也不需要关心它们的存在。线程池的作用仅仅是完成 I/O 操作，而非用来执行 CPU 密集型的操作，比如图像、视频处理，大规模计算等。&lt;/p&gt;
&lt;p&gt;　　如果有少量 CPU 密集型的任务需要处理，我们可以启动多个 Node.js 进程并利用 IPC 机制进行进程间通讯，或者调用外部的 C++/Java 程序。如果有大量 CPU 密集型任务，那只能说明选择 Node.js 是一个错误的决定。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader9&quot;&gt;　　事件循环&lt;/h2&gt;
&lt;p&gt;　　在 Node.js 中存在一个事件循环(Event Loop)。&lt;/p&gt;
&lt;p&gt;　　一次完整的 Event Loop 也可以分为多个阶段(phase)，依次是 poll、check、close callbacks、timers、I/O callbacks 、Idle。&lt;/p&gt;
&lt;p&gt;由于 Node.js 是事件驱动的，每个事件的回调函数会被注册到 Event Loop 的不同阶段。比如 fs.readFile 的回调函数被添加到 I/O callbacks， setImmediate 的回调被添加到下一次 Loop 的 poll 阶段结束后， process.nextTick() 的回调被添加到当前 phase 结束后，下一个 phase 开始前。&lt;/p&gt;
&lt;p&gt;　　不同异步方法的回调会在不同的 phase 被执行，掌握这一点很重要，否则就会因为调用顺序问题产生逻辑错误。&lt;/p&gt;
&lt;p&gt;　　Event Loop 不断的循环，每一个阶段内都会同步执行所有在该阶段注册的回调函数。这也正是为什么我在网络 I/O 部分提到，不要在回调函数中调用阻塞方法，总是用异步的思想来进行耗时操作。一个耗时太久的回调函数可能会让 Event Loop 卡在某个阶段很久，新来的网络请求就无法被及时响应。&lt;/p&gt;
&lt;p&gt;由于本文的目的是对 Node.js 有一个初步的，全面的认识。就不详细介绍 Event Loop 的每个阶段了。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader10&quot;&gt;　　数据流&lt;/h2&gt;
&lt;p&gt;　　使用数据流的好处很明显，生活中也有真实写照。举个例子，老师布置了暑假作业，如果学生每天都做一点(作业流)，就可以比较轻松的完成任务。如果积压在一起，到了最后一天，面对堆成小山的作业本，就会感到力不从心。&lt;/p&gt;
&lt;p&gt;　　Server 开发也是这样，假设用户上传 1G 文件，或者读取本地 1G 的文件。如果没有数据流的概念，我们需要开辟 1G 大小的缓冲区，然后在缓冲区满后一次性集中处理。&lt;/p&gt;
&lt;p&gt;如果是采用数据流的方式，我们可以定义很小的一块缓冲区，比如大小是 1Mb。当缓冲区满后就执行回调函数，对这一小块数据进行处理，从而避免出现积压。&lt;/p&gt;
&lt;p&gt;实际上 request 和 fs 模块的文件读取都是一个可读数据流:&lt;/p&gt;
&lt;h2 id=&quot;articleHeader11&quot;&gt;　　总结&lt;/h2&gt;
&lt;p&gt;　　对于高并发的长连接，事件驱动模型比线程轻量得多，多个 Node.js 进程配合负载均衡可以方便的进行拓展。因此 Node.js 非常适合为 I/O 密集型应用提供服务。但这种方式的缺陷就是不擅长处理 CPU 密集型任务。&lt;/p&gt;
&lt;p&gt; 　　本来这次是想自己写一篇文章看看的，但是看到他人写的文章太好了~~~&lt;/p&gt;
&lt;p&gt;　　对不起，这次的文章后半部分都是参考的他人的文章&lt;/p&gt;
&lt;p&gt;　　参考文章： &lt;a href=&quot;https://blog.csdn.net/fengyinchao/article/details/52512462&quot; target=&quot;_blank&quot;&gt;为什么要用node.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　    &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000&quot; target=&quot;_blank&quot;&gt;廖雪峰的javaScript教程&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 Aug 2018 16:23:00 +0000</pubDate>
<dc:creator>一步一步向上爬</dc:creator>
<og:description>从开始学习node到现在已经有半年多了，中间没有做过什么实际工作中的项目，所以感觉自己的知识有些匮乏，但是我还是要写这些文章，因为工作中的需要用node来开发后台环境，再加上我对这些知识记得不多，都是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z937741304/p/9471904.html</dc:identifier>
</item>
<item>
<title>Java HashMap类源码解析(续)-TreeNode - GrayWind</title>
<link>http://www.cnblogs.com/graywind/p/9471756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/graywind/p/9471756.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　由于TreeNode本身是红黑树的实现，所以在分析TreeNode的之前我还是摸了一篇算法导论里红黑树的读书笔记：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;a title=&quot;算法导论——红黑树&quot; href=&quot;https://www.cnblogs.com/graywind/p/9468965.html&quot; target=&quot;_blank&quot;&gt;算法导论——红黑树&lt;/a&gt;&lt;/strong&gt;&lt;span&gt;，从伪代码行数也可以看出完整的红黑树的插入和删除操作代码是很长的，下面源码分析部分的行数就更多了，所以所谓手写红黑树画个图分析下逻辑还行，手写代码估计要写死(滑稽)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　TreeNode从JDK8开始引入，作用是当HashMap解决冲突的链表长度超过了8时，生成一个红黑树来加速查找和插入，这里树结构存在并不影响本身依然存在线性链表结构，意思是Node.next这个属性依然有效，所以说树替换了线性链表依然还是链表法解决冲突，只不过链表的实现策略换了。当结点因为移除或分裂操作少于6个时，消除树结构。虽然生产树之后能加快查找插入和删除，但是建立和消除树本身是存在消耗的，所以在两个临界值之间来回插入和删除会导致开销快速增加。HashMap的源码分析见：&lt;a title=&quot;Java HashMap类源码解析&quot; href=&quot;https://www.cnblogs.com/graywind/p/9457521.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;Java HashMap类源码解析&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　红黑树是基于二叉搜索树扩展而来，对于TreeNode来说排序的依据是结点的hash值，若相等然后比较key值，若key不能比较或是相等则根据hash值，左儿子的hash值小于等于父亲，右儿子的hash值大于父亲。TreeNode 保有红黑树的性质：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;每个结点都是红色的或者是黑色的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;根结点是黑色的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个叶结点NIL是黑色的，但是通常我们不考虑NIL叶结点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果一个结点是红色的，它的两个子结点都是黑色的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个结点到其他所有后代叶结点的简单路径上，均包含相同数目的黑色结点，这个属性被称为黑高，记作bh(x)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　先来看一下TreeNode扩展的内部属性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        TreeNode&amp;lt;K,V&amp;gt; parent;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父亲结点&lt;/span&gt;
&lt;span&gt;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; left;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左儿子&lt;/span&gt;
&lt;span&gt;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; right;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右儿子&lt;/span&gt;
&lt;span&gt;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; prev;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前方结点&lt;/span&gt;

        &lt;span&gt;boolean&lt;/span&gt; red;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是红色&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;根据他的构造函数向上追溯TreeNode&amp;lt;K,V&amp;gt;继承了LinkedHashMap.Entry&amp;lt;K,V&amp;gt;而后者又继承了HashMap.Node&amp;lt;K,V&amp;gt;。所以TreeNode依然保有Node的属性，同时由于添加了prev这个前驱指针使得链表变为了双向的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
    TreeNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V val, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
       &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, val, next);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; HashMap.Node&amp;lt;K,V&amp;gt;&lt;span&gt; {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; before, after;
        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面这个方法可以返回根结点，实现很简单就是不断从一个结点检查parent是否为null&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Returns root of tree containing this node.返回根结点
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root() {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; r = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, p;;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = r.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
                r &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不断检查parent是否为null，为null的是根结点&lt;/span&gt;
&lt;span&gt;            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;moveRootToFront&lt;/span&gt;这个方法的作用是确保根结点被保存在了table数组上面，如果不是的话，就将root从链表中取出，将他放到数组对应的位置上，原本在数组上的结点链接到root的后面。这里最后调用了断言方法checkInvariants，作用是递归检查整棵树是否符合红黑树的性质，若检查不符会返回false导致moveRootToFront抛出错误。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_95d676b5-00dd-461b-9e47-30b3b461190f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_95d676b5-00dd-461b-9e47-30b3b461190f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_95d676b5-00dd-461b-9e47-30b3b461190f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Ensures that the given root is the first node of its bin.
         * 确保给出的根结点是箱中的第一个结点也就是直接位于table上，原本的第一个结点若不是root则将root从链表中剪下放到第一个结点的前方
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;void&lt;/span&gt; moveRootToFront(Node&amp;lt;K,V&amp;gt;[] tab, TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tab != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (n - 1) &amp;amp; root.hash;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据root的hash值快速定位下标&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; first = (TreeNode&amp;lt;K,V&amp;gt;)tab[index];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出table[index]中的第一个结点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (root != first) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;root不是第一个结点&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt;&lt;span&gt; rn;
                    tab[index] &lt;/span&gt;= root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;root放到table[index]位置&lt;/span&gt;
                    TreeNode&amp;lt;K,V&amp;gt; rp = root.prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rp=root的前一个结点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; ((rn = root.next) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rn=root的后一个结点&lt;/span&gt;
                        ((TreeNode&amp;lt;K,V&amp;gt;)rn).prev = rp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rn的前指针指向root的前一个结点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (rp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        rp.next &lt;/span&gt;= rn;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rp的后指针指向root的后一个结点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (first != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        first.prev &lt;/span&gt;= root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原本的first放到root的后面&lt;/span&gt;
                    root.next =&lt;span&gt; first;
                    root.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; checkInvariants(root);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;assert后面的表达式为false时会抛出错误&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Recursive invariant check
         * 从root开始递归检查红黑树的性质，仅在检查root是否落在table上时调用
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;boolean&lt;/span&gt; checkInvariants(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; t) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; tp = t.parent, tl = t.left, tr =&lt;span&gt; t.right,
                tb &lt;/span&gt;= t.prev, tn = (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)t.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tb != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tb.next !=&lt;span&gt; t)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的前一个结点的后续应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tn != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tn.prev !=&lt;span&gt; t)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的后一个结点的前驱应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tp != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != tp.left &amp;amp;&amp;amp; t !=&lt;span&gt; tp.right)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t因为t父亲的左儿子或右儿子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (tl.parent != t || tl.hash &amp;gt;&lt;span&gt; t.hash))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的左儿子的hash值应小于t，父亲应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (tr.parent != t || tr.hash &amp;lt;&lt;span&gt; t.hash))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的右儿子的hash值应大于t，父亲应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (t.red &amp;amp;&amp;amp; tl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tl.red &amp;amp;&amp;amp; tr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; tr.red)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t和t的儿子不能同时是红色&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;checkInvariants(tl))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归检查t的左儿子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;checkInvariants(tr))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归检查t的右儿子&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;getTreeNode这个方法在HashMap中被多次使用，左右是寻找某个结点所在的树中是否有hash和key值符合的结点。我们可以看到这个方法一定会确保最后调用的是root.find()，也就是说find方法调用时this一定是根结点。所以无论最初调用getTreeNode的结点在树中处于什么位置，最后都会从根结点开始寻找，由于红黑树是相对平衡的二叉搜索树，所以可以认为搜索时间相比于链表从O(n)下降到了O(lgn)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_cdfcd925-bc65-40fa-a614-60b758b5279b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cdfcd925-bc65-40fa-a614-60b758b5279b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cdfcd925-bc65-40fa-a614-60b758b5279b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Calls find for root node.从根结点寻找h和k符合的结点
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; getTreeNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h, Object k) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((parent != &lt;span&gt;null&lt;/span&gt;) ? root() : &lt;span&gt;this&lt;/span&gt;).find(h, k, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Finds the node starting at root p with the given hash and key.
         * The kc argument caches comparableClassFor(key) upon first use
         * comparing keys.
         * 从根结点p开始根据hash和key值寻找指定的结点。kc是key的class
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; find(&lt;span&gt;int&lt;/span&gt; h, Object k, Class&amp;lt;?&amp;gt;&lt;span&gt; kc) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;this&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法调用时this是根结点&lt;/span&gt;
            &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ph, dir; K pk;
                TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; pl = p.left, pr =&lt;span&gt; p.right, q;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt;&lt;span&gt; h)
                    p &lt;/span&gt;= pl;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;gt;参数hash时，移向左子树&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt;&lt;span&gt; h)
                    p &lt;/span&gt;= pr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;lt;参数hash时，移向右子树&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((pk = p.key) == k || (k != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k.equals(pk)))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash=参数hash，且p.key与参数key相等找到指定结点并返回&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pl == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若hash相等但key不等，向左右子树非空的一侧移动&lt;/span&gt;
                    p =&lt;span&gt; pr;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    p &lt;/span&gt;=&lt;span&gt; pl;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc != &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                          (kc &lt;/span&gt;= comparableClassFor(k)) != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;kc是否是一个可比较的类&lt;/span&gt;
                         (dir = compareComparables(kc, k, pk)) != 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较k和p.key&lt;/span&gt;
                    p = (dir &amp;lt; 0) ? pl : pr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k&amp;lt;p.key向左子树移动否则向右子树移动&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((q = pr.find(h, k, kc)) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里开始的条件仅当输入k=null的时候才会进入，先检查右子树再检查左子树&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; q;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    p &lt;/span&gt;=&lt;span&gt; pl;
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面这个treeify就是根据链表生成树了，遍历链表获取结点，一个个插入到红黑树中，每次插入从根开始根据hash值寻找到叶结点位置进行插入，插入一个结点后调用一次balanceInsertion(root, x)检查x位置的红黑树性质是否需要修复。tieBreakOrder(k, pk)是在插入结点的key值k和父结点的key值pk无法比较出大小时，用于比较k和pk的hash值大小。关于红黑树性质的修复和保持稍后一起讨论。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_25877a15-cc2c-4596-a9d8-12c61b16868b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_25877a15-cc2c-4596-a9d8-12c61b16868b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_25877a15-cc2c-4596-a9d8-12c61b16868b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; treeify(Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; x = &lt;span&gt;this&lt;/span&gt;, next; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; next) {
                next &lt;/span&gt;= (TreeNode&amp;lt;K,V&amp;gt;)x.next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据链表进行遍历&lt;/span&gt;
                x.left = x.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根结点一定是黑色的&lt;/span&gt;
                    root =&lt;span&gt; x;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    K k &lt;/span&gt;=&lt;span&gt; x.key;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; x.hash;
                    Class&lt;/span&gt;&amp;lt;?&amp;gt; kc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; p =&lt;span&gt; root;;) {
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dir, ph;
                        K pk &lt;/span&gt;=&lt;span&gt; p.key;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt; h)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;gt;h则dir=-1，p.hash&amp;lt;h则dir=1&lt;/span&gt;
                            dir = -1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt;&lt;span&gt; h)
                            dir &lt;/span&gt;= 1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                                  (kc &lt;/span&gt;= comparableClassFor(k)) == &lt;span&gt;null&lt;/span&gt;) ||&lt;span&gt;
                                 (dir &lt;/span&gt;= compareComparables(kc, k, pk)) == 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k是不可比较的类或者k和p.key相等，kc==null这个条件只是为了给kc初始化&lt;/span&gt;
                            dir = tieBreakOrder(k, pk);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较k和p.k的hash值大小，k大dir=-1，p.key大则dir=1，pk是父亲的hash，k是要插入结点的hash&lt;/span&gt;
&lt;span&gt;
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; xp =&lt;span&gt; p;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = (dir &amp;lt;= 0) ? p.left : p.right) == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要插入的位置已没有子结点，则进行插入，否则沿着要插入的子树位置继续向下遍历&lt;/span&gt;
                            x.parent =&lt;span&gt; xp;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dir &amp;lt;= 0&lt;span&gt;)
                                xp.left &lt;/span&gt;= x;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的hash值小于等于p的hash值时尝试插入到左子树&lt;/span&gt;
                            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                xp.right &lt;/span&gt;= x;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的hash值大于p的hash值时尝试插入到右子树&lt;/span&gt;
                            root = balanceInsertion(root, x);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入后修复红黑树性质&lt;/span&gt;
                            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }
            }
            moveRootToFront(tab, root);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保当前的root是直接落在table数组上&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tieBreakOrder(Object a, Object b) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; d;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt; || b == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                (d &lt;/span&gt;=&lt;span&gt; a.getClass().getName().
                 compareTo(b.getClass().getName())) &lt;/span&gt;== 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a和b的class相同或者一方是null&lt;/span&gt;
                d = (System.identityHashCode(a) &amp;lt;= System.identityHashCode(b) ?
                     -1 : 1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; d;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a的hashcode&amp;lt;=b的hashcode则返回-1，否则返回1，不能比较返回0&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;untreeify的作用就是把树转为链表，由于replacementNode这个方法会生成新的Node，所以产生的新链表不再具有树的信息了，原本的TreeNode被gc了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_73cca3d7-1204-4dcf-aca3-ce27dcf88eb8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_73cca3d7-1204-4dcf-aca3-ce27dcf88eb8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_73cca3d7-1204-4dcf-aca3-ce27dcf88eb8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; untreeify(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; map) {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; hd = &lt;span&gt;null&lt;/span&gt;, tl = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hd是头部，tl是尾部&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; q = &lt;span&gt;this&lt;/span&gt;; q != &lt;span&gt;null&lt;/span&gt;; q =&lt;span&gt; q.next) {
                Node&lt;/span&gt;&amp;lt;K,V&amp;gt; p = map.replacementNode(q, &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据q产生一个新的结点，next=null，hash key value和q相等&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (tl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    hd &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个结点产生时头部指向它&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    tl.next &lt;/span&gt;=&lt;span&gt; p;
                tl &lt;/span&gt;=&lt;span&gt; p;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hd;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;拆分这个方法只有在resize的时候调用，可以对照线性链表扩展的情况，作用是把树拆成两棵，一棵放到新扩展出来的数组高位去，一棵留在原来的位置，划分的依据是扩展后新增的hash有效位是0还是1，拆分的时候会破坏树结构，所以先拆成两个链表再调用treeify来组装树。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_c0d0379c-1962-4b4e-b19f-764a492bdc9a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c0d0379c-1962-4b4e-b19f-764a492bdc9a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c0d0379c-1962-4b4e-b19f-764a492bdc9a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Splits nodes in a tree bin into lower and upper tree bins,
         * or untreeifies if now too small. Called only from resize;
         * see above discussion about split bits and indices.
         * 将树从给定的结点分裂成低位和高位的两棵树，若新树结点太少则转为线性链表。只有resize时会调用
         *
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map the map
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; tab the table for recording bin heads存储链表头的hash表
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index the index of the table being split需要分裂的表下标位置
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bit the bit of hash to split on分裂时分到高位和低位的依据参数，实际使用时输入的是扩展之前旧数组的大小
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; split(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;int&lt;/span&gt; index, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bit) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; b = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Relink into lo and hi lists, preserving order&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;低位头尾指针&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高位头尾指针&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; lc = 0, hc = 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;低位和高位的结点个数统计&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; e = b, next; e != &lt;span&gt;null&lt;/span&gt;; e = next) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e从this开始遍历直到next为null&lt;/span&gt;
                next = (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)e.next;
                e.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这段决定了该结点被分到低位还是高位，依据算式是e.hash mod bit，由于bit是扩展前数组的大小，所以一定是2的指数次幂，所以bit一定只有一个高位是1其余全是0
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个算式实际是判断e.hash新多出来的有效位是0还是1，若是0则分去低位树，是1则分去高位树&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; bit) == 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e.prev = loTail) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        loHead &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        loTail.next &lt;/span&gt;=&lt;span&gt; e;
                    loTail &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;++&lt;span&gt;lc;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e.prev = hiTail) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        hiHead &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        hiTail.next &lt;/span&gt;=&lt;span&gt; e;
                    hiTail &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;++&lt;span&gt;hc;
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loHead != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lc &amp;lt;=&lt;span&gt; UNTREEIFY_THRESHOLD)
                    tab[index] &lt;/span&gt;= loHead.untreeify(map);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分裂后的低位树结点太少转为线性链表&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    tab[index] &lt;/span&gt;=&lt;span&gt; loHead;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiHead != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若高位树为null则代表整棵树全保留在了低位，树没有变化所以不用进行后面的treeify&lt;/span&gt;
&lt;span&gt;                        loHead.treeify(tab);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiHead != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这段与上面对于低位部分的分析相对应&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (hc &amp;lt;=&lt;span&gt; UNTREEIFY_THRESHOLD)
                    tab[index &lt;/span&gt;+ bit] =&lt;span&gt; hiHead.untreeify(map);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    tab[index &lt;/span&gt;+ bit] = hiHead;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高位所处的位置为原本位置+旧数组的大小即bit&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (loHead != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        hiHead.treeify(tab);
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;下面开始要进入插入和删除操作部分分析了，为了便于说明把之前那篇几张关键的图贴过来方便与代码进行对照&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;旋转&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如图所示是基本的左旋和右旋操作，这部分对着图看很容易理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813232303759-104544341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_4ba3b869-94bb-4c12-bab5-fc0ab1773bfb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4ba3b869-94bb-4c12-bab5-fc0ab1773bfb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4ba3b869-94bb-4c12-bab5-fc0ab1773bfb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左旋操作，见图中右向左，p是x，r是y&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateLeft(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                              TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; r, pp, rl;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (r = p.right) != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r是p的右儿子，也就是图中的y&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((rl = p.right = r.left) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r的左儿子β成为p的右儿子&lt;/span&gt;
                    rl.parent =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((pp = r.parent = p.parent) == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p的父亲成为r的父亲&lt;/span&gt;
                    (root = r).red = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是根结点,r的颜色改黑色&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pp.left == p)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r取代p原本的位置&lt;/span&gt;
                    pp.left =&lt;span&gt; r;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.right &lt;/span&gt;=&lt;span&gt; r;
                r.left &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p成为r的右儿子&lt;/span&gt;
                p.parent =&lt;span&gt; r;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋操作，见图中左向右，p是y，l是x&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateRight(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                               TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; l, pp, lr;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (l = p.left) != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l是p的左儿子，即图中x&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((lr = p.left = l.right) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l的右儿子β成为p的左儿子&lt;/span&gt;
                    lr.parent =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((pp = l.parent = p.parent) == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p的父亲成为l的父亲&lt;/span&gt;
                    (root = l).red = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是根结点,l的颜色改黑色&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pp.right == p)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l取代p原本的位置&lt;/span&gt;
                    pp.right =&lt;span&gt; l;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.left &lt;/span&gt;=&lt;span&gt; l;
                l.right &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p成为l的右儿子&lt;/span&gt;
                p.parent =&lt;span&gt; l;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;插入分为如图所示的3中情况，具体描述和处理方法见文章最前面的链接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813233323432-870010423.png&quot; alt=&quot;&quot;/&gt;情况1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813233441284-1121761199.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入操作涉及到两段很长的代码，首先是putTreeVal只要有h和k值符合的结点就不做插入，这里k必须是==或者equals才算是相等，返回找到的结点由调用的方法修改已有结点的value值，否则插入一个新结点并返回null。前面提到过，结点在树中的排序按照hash值大小，再按照key的大小，最后比较key计算Hash的大小进行排列，对应方法中的查找逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_8dd21e5e-44e1-40be-99bb-3f68d39d546a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8dd21e5e-44e1-40be-99bb-3f68d39d546a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8dd21e5e-44e1-40be-99bb-3f68d39d546a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; putTreeVal(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab,
                                       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h, K k, V v) {
            Class&lt;/span&gt;&amp;lt;?&amp;gt; kc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; searched = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; root = (parent != &lt;span&gt;null&lt;/span&gt;) ? root() : &lt;span&gt;this&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.parent为null代表已是根结点，否则通过root()获取根结点&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; p =&lt;span&gt; root;;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dir, ph; K pk;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt; h)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;gt;h时dir=-1，p.hash&amp;lt;h时dir=1&lt;/span&gt;
                    dir = -1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt;&lt;span&gt; h)
                    dir &lt;/span&gt;= 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((pk = p.key) == k || (k != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k.equals(pk)))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash=h且p.key与k相等时，已存在k值对应的结点则返回&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                          (kc &lt;/span&gt;= comparableClassFor(k)) == &lt;span&gt;null&lt;/span&gt;) ||&lt;span&gt;
                         (dir &lt;/span&gt;= compareComparables(kc, k, pk)) == 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/k是不可比较的类或者k和p.key通过compareTo比较相等&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;searched) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这部分只会在在k和p.key通过compareTo比较相等时执行一次，若未能在在左右子树中寻找到k==p.key或者k.equals(p.key)的情况则下次不会再进入&lt;/span&gt;
                        TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; q, ch;
                        searched &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((ch = p.left) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                             (q &lt;/span&gt;= ch.find(h, k, kc)) != &lt;span&gt;null&lt;/span&gt;) ||&lt;span&gt;
                            ((ch &lt;/span&gt;= p.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                             (q &lt;/span&gt;= ch.find(h, k, kc)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; q;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从p的左子树或者右子树中找到符合条件的结点则返回&lt;/span&gt;
&lt;span&gt;                    }
                    dir &lt;/span&gt;= tieBreakOrder(k, pk);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较k和p.key的hash值大小，-1表示k&amp;lt;p.key&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash=hash但是key值不相等且p的左右子树中也没有找到符合的结点&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; xp =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = (dir &amp;lt;= 0) ? p.left : p.right) == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到了新增结点该插入的位置&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt; xpn = xp.next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表关系上的下一个结点&lt;/span&gt;
                    TreeNode&amp;lt;K,V&amp;gt; x = map.newTreeNode(h, k, v, xpn);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个结点，插入到p与它在链表上的下一个结点之间&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (dir &amp;lt;= 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据dir大小把p的左儿子或者右儿子设为新增的结点&lt;/span&gt;
                        xp.left =&lt;span&gt; x;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        xp.right &lt;/span&gt;=&lt;span&gt; x;
                    xp.next &lt;/span&gt;=&lt;span&gt; x;
                    x.parent &lt;/span&gt;= x.prev =&lt;span&gt; xp;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpn != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        ((TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;)xpn).prev =&lt;span&gt; x;
                    moveRootToFront(tab, balanceInsertion(root, x));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入后进行红黑树的性质修复，并检查root是否是直接在table数组上&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; balanceInsertion是插入后用于维持红黑树性质的修复操作，这里涉及到了上面图中展示的3中情况不同的操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_dce82fd4-1716-4adf-b4c2-79d5196fc68b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dce82fd4-1716-4adf-b4c2-79d5196fc68b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dce82fd4-1716-4adf-b4c2-79d5196fc68b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceInsertion(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                                    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
            x.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入的结点设为红色&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; xp, xpp, xppl, xppr;;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((xp = x.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲为null代表x是根结点，x改黑色直接结束&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!xp.red || (xpp = xp.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若x的父结点为黑色或者x的父亲为根结点(实际上根应该是黑色)插入红色结点不影响红黑树性质&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (xp == (xppl = xpp.left)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若x的父亲为左儿子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; ((xppr = xpp.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xppr.red) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xppr为x的叔叔，且叔叔为红色，图中的情况1，x的叔叔和父亲改为红色，x的爷爷改为黑色，x指针上移到爷爷的位置&lt;/span&gt;
                        xppr.red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        x &lt;/span&gt;=&lt;span&gt; xpp;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; xp.right) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况2，x的叔叔是黑色且x是右儿子。对x上升至父亲后执行一次左旋&lt;/span&gt;
                            root = rotateLeft(root, x =&lt;span&gt; xp);
                            xpp &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.parent;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况3，x的叔叔是黑色且x是左儿子。x的父亲改黑色，x的爷爷改红色后对x的爷爷进行右旋&lt;/span&gt;
                            xp.red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xpp);
                            }
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下为对称的操作&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (xppl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xppl.red) {
                        xppl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        x &lt;/span&gt;=&lt;span&gt; xpp;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; xp.left) {
                            root &lt;/span&gt;= rotateRight(root, x =&lt;span&gt; xp);
                            xpp &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.parent;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;最后是删除操作部分，删除操作需要寻找一个后驱结点来顶替原结点的位置，在结点无儿子时删除后不需做其他调整，结点只有一个儿子时那个儿子是后驱，否则右子树中的最小结点作为后驱。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_e1bfc1a3-eaae-474d-ab5c-5b82afb7d03e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e1bfc1a3-eaae-474d-ab5c-5b82afb7d03e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e1bfc1a3-eaae-474d-ab5c-5b82afb7d03e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Removes the given node, that must be present before this call.
         * This is messier than typical red-black deletion code because we
         * cannot swap the contents of an interior node with a leaf
         * successor that is pinned by &quot;next&quot; pointers that are accessible
         * independently during traversal. So instead we swap the tree
         * linkages. If the current tree appears to have too few nodes,
         * the bin is converted back to a plain bin. (The test triggers
         * somewhere between 2 and 6 nodes, depending on tree structure).
         * 移除给定的结点，这个方法相比一般的红黑树删除更加杂乱，因为我们无法交换内部结点的内容他们被next指针给限制了，这个指针是在遍历的时候独立的。
         * 因此我们交换树的连接。如果当前的树结点太少，需要转换为线性链表，通常这个值设定为2-6个结点
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; removeTreeNode(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab,
                                  &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; movable) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (n - 1) &amp;amp; hash;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index = hash mod n&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; first = (TreeNode&amp;lt;K,V&amp;gt;)tab[index], root =&lt;span&gt; first, rl;
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; succ = (TreeNode&amp;lt;K,V&amp;gt;)next, pred = prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;succ指向要删除结点的后一个点，pred指向要删除结点的前一个&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                tab[index] &lt;/span&gt;= first = succ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若要删除的结点的前一个为空，则first和tab[index]都指向要删除结点的后一个结点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                pred.next &lt;/span&gt;= succ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若要删除结点的前驱非空，则前一个结点的next指针指向该结点的后驱&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (succ != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                succ.prev &lt;/span&gt;= pred;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后驱结点不为空时，后驱结点的前置指针设为删除结点的前置结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若删除的结点是树中的唯一结点则直接结束&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (root.parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                root &lt;/span&gt;= root.root();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保root指向根结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt; || root.right == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                (rl &lt;/span&gt;= root.left) == &lt;span&gt;null&lt;/span&gt; || rl.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                tab[index] &lt;/span&gt;= first.untreeify(map);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根自身或者左右儿子其中一个为空说明结点数过少（不超过2）转为线性表并结束&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;this&lt;/span&gt;, pl = left, pr = right, replacement;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p指向要删除的结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; pr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; s =&lt;span&gt; pr, sl;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((sl = s.left) != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除结点的左右儿子都不为空时，寻找右子树中最左的叶结点作为后继，s指向这个后继结点&lt;/span&gt;
                    s =&lt;span&gt; sl;
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; c = s.red; s.red = p.red; p.red = c; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换后继结点和要删除结点的颜色&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; sr =&lt;span&gt; s.right;
                TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; pp =&lt;span&gt; p.parent;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; pr) { 
                    p.parent &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p是s的直接右儿子，交换p和s的位置&lt;/span&gt;
                    s.right =&lt;span&gt; p;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; sp =&lt;span&gt; s.parent;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p.parent = sp) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; sp.left)
                            sp.left &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p放到s原本的位置&lt;/span&gt;
                        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            sp.right &lt;/span&gt;=&lt;span&gt; p;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s.right = pr) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        pr.parent &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s放到p原本的位置&lt;/span&gt;
&lt;span&gt;                }
                p.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p.right = sr) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    sr.parent &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s原本的右子树成为p的右子树&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((s.left = pl) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    pl.parent &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s原本的左子树成为p的左子树&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((s.parent = pp) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    root &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p原本是根则新的根是s&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
                    pp.left &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是某个结点的左儿子，则s成为该结点的左儿子&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.right &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是某个结点的右儿子，则s成为该结点的右儿子&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (sr != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若s结点有右儿子（s一定没有左儿子），则replacement为这个右儿子否则为p&lt;/span&gt;
                    replacement =&lt;span&gt; sr;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    replacement &lt;/span&gt;=&lt;span&gt; p;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pl != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p的左右儿子有一方为null，则replacement为非空的一方，否则为p自己&lt;/span&gt;
                replacement =&lt;span&gt; pl;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                replacement &lt;/span&gt;=&lt;span&gt; pr;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                replacement &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (replacement != p) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p有儿子或者s有儿子&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; pp = replacement.parent =&lt;span&gt; p.parent;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pp == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用replacement来替换p&lt;/span&gt;
                    root =&lt;span&gt; replacement;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
                    pp.left &lt;/span&gt;=&lt;span&gt; replacement;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.right &lt;/span&gt;=&lt;span&gt; replacement;
                p.left &lt;/span&gt;= p.right = p.parent = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除p结点&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以replacement为中心，进行红黑树性质的修复，replacement可能为s的右儿子或者p的儿子或者p自己&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; r = p.red ?&lt;span&gt; root : balanceDeletion(root, replacement);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (replacement == p) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p没有儿子或者s没有儿子，直接移除p&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; pp =&lt;span&gt; p.parent;
                p.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
                        pp.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.right)
                        pp.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (movable)
                moveRootToFront(tab, r);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整理根结点&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813234611480-1909610969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样有删除和删除之后维持红黑树性质的修复操作，这里涉及到图中展示的4种不同情况的操作 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_c87bd9ec-cb5e-46d3-89f3-cda59b8ba105&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c87bd9ec-cb5e-46d3-89f3-cda59b8ba105&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c87bd9ec-cb5e-46d3-89f3-cda59b8ba105&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceDeletion(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                                   TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; xp, xpl, xpr;;)  {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;null&lt;/span&gt; || x ==&lt;span&gt; root)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除结点为空或者删除的是根结点，直接返回&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((xp = x.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除后x成为根结点，x的颜色改为黑色&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (x.red) {
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个红色的结点提升到删除结点的位置不会改变黑高&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((xpl = xp.left) == x) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲是左儿子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; ((xpr = xp.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xpr.red) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况1，x的兄弟是红色的&lt;/span&gt;
                        xpr.red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xp);
                        xpr &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.right;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        x &lt;/span&gt;= xp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若x没有兄弟，x上升到父亲的位置&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; sl = xpr.left, sr =&lt;span&gt; xpr.right;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sr == &lt;span&gt;null&lt;/span&gt; || !sr.red) &amp;amp;&amp;amp;&lt;span&gt;
                            (sl &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sl.red)) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况2，x兄弟是黑色，他的两个儿子是黑色的&lt;/span&gt;
                            xpr.red = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                            x &lt;/span&gt;=&lt;span&gt; xp;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sr == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sr.red) {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况3，x兄弟是黑色，他的右儿子是黑色，左儿子红色&lt;/span&gt;
                                &lt;span&gt;if&lt;/span&gt; (sl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                xpr.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xpr);
                                xpr &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ?
                                    &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.right;
                            }
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况4&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (xpr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpr.red &lt;/span&gt;= (xp == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt; : xp.red;
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sr = xpr.right) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xp);
                            }
                            x &lt;/span&gt;=&lt;span&gt; root;
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下为对称操作&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (xpl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xpl.red) {
                        xpl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xp);
                        xpl &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.left;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        x &lt;/span&gt;=&lt;span&gt; xp;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; sl = xpl.left, sr =&lt;span&gt; xpl.right;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sl == &lt;span&gt;null&lt;/span&gt; || !sl.red) &amp;amp;&amp;amp;&lt;span&gt;
                            (sr &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sr.red)) {
                            xpl.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                            x &lt;/span&gt;=&lt;span&gt; xp;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sl == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sl.red) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                xpl.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xpl);
                                xpl &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ?
                                    &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.left;
                            }
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpl.red &lt;/span&gt;= (xp == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt; : xp.red;
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sl = xpl.left) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xp);
                            }
                            x &lt;/span&gt;=&lt;span&gt; root;
                        }
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 13 Aug 2018 15:49:00 +0000</pubDate>
<dc:creator>GrayWind</dc:creator>
<og:description>由于TreeNode本身是红黑树的实现，所以在分析TreeNode的之前我还是摸了一篇算法导论里红黑树的读书笔记：算法导论——红黑树，从伪代码行数也可以看出完整的红黑树的插入和删除操作代码是很长的，下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/graywind/p/9471756.html</dc:identifier>
</item>
<item>
<title>JasperReport 中踩过的坑 - pengisgood</title>
<link>http://www.cnblogs.com/penghongwei/p/9471801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghongwei/p/9471801.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Mac Book Pro 10.13.6&lt;br/&gt;Jaspersoft Studio community version 6.6.9&lt;br/&gt;JDK 8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;安装 Jaspersoft Studio&lt;/h2&gt;
&lt;p&gt;Jasper Report 分为专业版（收费）和社区版（免费），如果只是用来设计一些 基本的报表模板，社区版就足够了。从&lt;a href=&quot;https://community.jaspersoft.com/community-download&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;可以下载，选择 Jaspersoft Studio。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;727&quot; data-height=&quot;572&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-f95ab54688f71192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-f95ab54688f71192.png&quot; data-original-width=&quot;727&quot; data-original-height=&quot;572&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;113226&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;jaspersoft-studio.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;安装时可能遇到的问题&lt;/h3&gt;
&lt;p&gt;如果在安装时一切顺利，那么可以直接跳过本小节。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;420&quot; data-height=&quot;174&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-a991e8042c40d2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-a991e8042c40d2d8.png&quot; data-original-width=&quot;420&quot; data-original-height=&quot;174&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;25470&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;install-jasper-studio.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果安装过程中遇到如上错误，可以尝试一下 解决办法：&lt;/p&gt;
&lt;p&gt;System Preferences -&amp;gt; Security &amp;amp; Privacy -&amp;gt; General&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;667&quot; data-height=&quot;572&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-ac9f2beccbb345d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-ac9f2beccbb345d2.png&quot; data-original-width=&quot;667&quot; data-original-height=&quot;572&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;69025&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;security-privacy.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果 Step 1 不能解决问题，打开 Terminal，执行如下命令：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;# sudo bash
&lt;span class=&quot;hljs-meta&quot;&gt;# xattr -cr &lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;/Applications/TIBCO Jaspersoft Studio 6.6.0.app&quot;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你对这个 &lt;code&gt;xattr&lt;/code&gt; 感到好奇，可以执行 &lt;code&gt;man xattr&lt;/code&gt; 读一读解释。&lt;/p&gt;
&lt;h2&gt;理解 Report Band&lt;/h2&gt;
&lt;p&gt;Jasper Studio 内置了很多种 Band，不同的 Band 有不同的用途，也有些不同默认行为。除了 Background Band，其他的 Band 的总高度要小于或等于一页的最大高度减去顶部和底部的边距。&lt;/p&gt;
&lt;h3&gt;Title&lt;/h3&gt;
&lt;p&gt;默认只会出现在第一页的最顶部。也可以像下面这样控制它显示在单独的一页上。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;370&quot; data-height=&quot;341&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-4f50480b8b620139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/370&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-4f50480b8b620139.png&quot; data-original-width=&quot;370&quot; data-original-height=&quot;341&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;42995&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;title-on-new-page.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;Page Header&lt;/h3&gt;
&lt;p&gt;页眉默认会出现在每一页的顶部。当 Title 和 Summary Band 设置为显示在单独的一页上时，页眉则不会显示出来。&lt;/p&gt;
&lt;h3&gt;Detail&lt;/h3&gt;
&lt;p&gt;Detail Band 比较神奇，它能够自动的迭代 DataSource 中的所有元素，如果 DataSource 为 null，则只有静态文本会显示出来。默认情况下，Main Dataset 的 Query 有多少条记录，Detail Band 就会重复多少遍。&lt;/p&gt;
&lt;p&gt;更加详细一点的解释看&lt;a href=&quot;https://stackoverflow.com/questions/8388178/jasperreport-purpose-of-the-details-band&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Page Footer&lt;/h3&gt;
&lt;p&gt;页脚默认会出现在每一页的底部。&lt;/p&gt;
&lt;h3&gt;Last Page Footer&lt;/h3&gt;
&lt;p&gt;如果想在最后一页的页脚上放一些不同的内容，就可以考虑使用这个 Band。&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;默认会显示在报表的最后，和 Title Band 一样，也可以设置为显示在单独的一页上。如果是基于统计的报表，一般会放一些计算出来的内容，比如：最大值，最小值，平均值，总值等。当然，根据实际需要，也可以放任意内容。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;371&quot; data-height=&quot;299&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-7df3cf6d1ffe4d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/371&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-7df3cf6d1ffe4d9f.png&quot; data-original-width=&quot;371&quot; data-original-height=&quot;299&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;39357&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;summary-on-new-page.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;顾名思义，这个一般就是放报表的背景的，比如水印之类的。它的最大高度可以和报表一页的高度相同。&lt;/p&gt;
&lt;h3&gt;其他的 Band&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Column Header&lt;/code&gt;, &lt;code&gt;Group Header&lt;/code&gt;, &lt;code&gt;Group Footer&lt;/code&gt;, &lt;code&gt;Column Footer&lt;/code&gt;, &lt;code&gt;No Data&lt;/code&gt; 这些 Band 根据名字也比较容易理解，具体的解释在这篇&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/understanding-bands&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;中讲解的比较详细。&lt;/p&gt;
&lt;h2&gt;全局设置&lt;/h2&gt;
&lt;p&gt;在页面的全局设置中可以设置页面的大小，边距，尺寸单位，页面方向等。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;570&quot; data-height=&quot;489&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-9848ae10f0b997a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/570&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-9848ae10f0b997a2.png&quot; data-original-width=&quot;570&quot; data-original-height=&quot;489&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;54727&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;page-format.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;一个小建议是，如果设计稿是什么计量单位，这里就设置成什么计量单位，然后把尺寸设置的和设计稿一样，避免在设计模板的时候做繁琐的尺寸换算。&lt;/p&gt;
&lt;p&gt;关于页面边距需要注意的一点是，即使将上下左右都设置为 0，最终导出 PDF 打印出来，边距也不见得是 0，因为打印机的设置中可能还会有默认的边距设置。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;540&quot; data-height=&quot;546&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-6406bff8c65f13bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-6406bff8c65f13bd.png&quot; data-original-width=&quot;540&quot; data-original-height=&quot;546&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;55717&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;printer-settings.png&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;页码&lt;/h2&gt;
&lt;p&gt;在报表中，几乎都会有显示页码的需求，比如 &lt;code&gt;Page x of y&lt;/code&gt; 这种。看似很简单，并且 Jasper Studio 中已经提供预设好的组件。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;725&quot; data-height=&quot;254&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-9b51e9c397a26a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-9b51e9c397a26a3f.png&quot; data-original-width=&quot;725&quot; data-original-height=&quot;254&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;59329&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;page-x-of-y.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个内置的组件是通过两个 Text Field 实现的，如果对对齐的精度要求不高，直接使用这个组件也是挺方便的。其原理就是使用了两次 &lt;code&gt;$V{PAGE_NUMBER}&lt;/code&gt; 变量，只是设置不同的求值时机即可。对于每一页的页码设置 &lt;code&gt;Evaluation Time&lt;/code&gt; 为 &lt;code&gt;Now&lt;/code&gt;，对于总页码设置为 &lt;code&gt;Report&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是如果对精度要求非常高的话，这个方式就不太合适了，我们需要用一个 Text Field 来实现，具体的做法参考&lt;a href=&quot;https://communities.ca.com/blogs/rob.ensinger/2015/12/28/how-to-single-textbox-page-x-of-y-page-counts-in-jaspersoft-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;设置中英文为不同的字体（Font Set）&lt;/h2&gt;
&lt;p&gt;相信用 Word 软件进行过中英文排版的可能应对过这种需求，就是对一篇文章中的中英文需要设置不同 的字体，在 Word 中是有这个菜单项可以设置的，但是在 Jasper Report 中要实现这个需求就不那么简单了。&lt;/p&gt;
&lt;p&gt;主要涉及到下面这些步骤：&lt;/p&gt;
&lt;h3&gt;创建 Font Set&lt;/h3&gt;
&lt;p&gt;创建 &lt;code&gt;Font Extension&lt;/code&gt; 和 &lt;code&gt;Font Set&lt;/code&gt; 的步骤比较直观，参考&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/working-font-extensions&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;即可。&lt;/p&gt;
&lt;h3&gt;在 Java 代码中引用字体文件&lt;/h3&gt;
&lt;p&gt;如果服务器所在的系统中没有相应的字体，在 Jasper Report 尝试生成 PDF 的时候就会报错。需要以下几步来解决：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先需要从 Jasper Studio 中导出包含字体的 Jar 包，一次点击 &lt;code&gt;Window &amp;gt; Preferences &amp;gt; Jaspersoft Studio &amp;gt; Fonts&lt;/code&gt;，选中创建的 Font Set 和其包含的字体并点击 &lt;code&gt;Export&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在导出 Font 到 Jar 包的对话框中写上名称并保存。比如 &lt;code&gt;SampleFontSet.jar&lt;/code&gt;。这个 Jar 包和一般普通的 Jar 包不同，它包含了一些 Jaspersoft 需要的额外信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在代码依赖中引入字体 Jar 包。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1203&quot; data-height=&quot;616&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-4077729344d87225.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-4077729344d87225.png&quot; data-original-width=&quot;1203&quot; data-original-height=&quot;616&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;157957&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;jasper-font-set.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;将字体嵌入到 PDF 中&lt;/h3&gt;
&lt;p&gt;有人可能会怀疑将报表中用到的字体嵌入到导出的 PDF 中是否会带来性能问题，毕竟一般汉字的字体文件体积都比较大，大几十兆。在用 Japser 导出 PDF 的时候，只会嵌入用到的字体文件的子集，所以 几乎不用担心导出的 PDF 的体积。&lt;/p&gt;
&lt;h3&gt;测量 Text Field 的实际宽度（使用 Font Set ）&lt;/h3&gt;
&lt;p&gt;如果在 Text Field 上设置的字体是自定义的 Font Set，那么需要注意了，不是那么容易能够测量出真实的宽度。目前的解决办法是先分离出文本中的汉字字符和非汉字字符，然后分别设置成相应的字体，再各自测量出宽度，最后相加即为文本所占的实际宽度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分离汉字字符和非汉字字符&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static Pair&amp;lt;String, String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;splitHanAndOthers&lt;span class=&quot;hljs-params&quot;&gt;(String str) {
        StringBuilder hanToken = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder();
        StringBuilder othersToken = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder();

        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; str.length(); ) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;int codePoint = str.codePointAt(i);

            &lt;span class=&quot;hljs-keyword&quot;&gt;if (UnicodeScript.of(codePoint) == UnicodeScript.HAN) {
                hanToken.append(str.charAt(i));
            } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                othersToken.append(str.charAt(i));
            }
            i += Character.charCount(codePoint);
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;return Pair.of(hanToken.toString(), othersToken.toString());
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测量文本的实际宽度&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;float &lt;span class=&quot;hljs-title&quot;&gt;getWidth&lt;span class=&quot;hljs-params&quot;&gt;(JRPrintText jrPrintText, String text, String fontName) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final DefaultJasperReportsContext instance = DefaultJasperReportsContext.getInstance();

        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRDefaultStyleProvider defaultStyleProvider = jrPrintText.getDefaultStyleProvider();
        JRPrintText printText = &lt;span class=&quot;hljs-keyword&quot;&gt;new JRBasePrintText(defaultStyleProvider);
        printText.setText(text);
        printText.setFontName(fontName);
        printText.setFontSize(jrPrintText.getFontsize());

        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRStyledText hanTextFullStyledText = printText.getFullStyledText(JRStyledTextAttributeSelector.getAllSelector(instance));
        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRTextMeasurer measure = JRTextMeasurerUtil.getInstance(instance).createTextMeasurer(jrPrintText);
        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRMeasuredText measuredText = measure.measure(hanTextFullStyledText, &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-keyword&quot;&gt;false);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return measuredText.getTextWidth();
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;计算总宽度&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;float &lt;span class=&quot;hljs-title&quot;&gt;getTotalWidth&lt;span class=&quot;hljs-params&quot;&gt;(JRPrintText jrPrintText, String text) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final Pair&amp;lt;String, String&amp;gt; hanAndOthers = splitHanAndOthers(text);
        &lt;span class=&quot;hljs-keyword&quot;&gt;final String han = hanAndOthers.getLeft();
        &lt;span class=&quot;hljs-keyword&quot;&gt;final String others = hanAndOthers.getRight();

        &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;float hanWidth = getWidth(jrPrintText, han, &lt;span class=&quot;hljs-string&quot;&gt;&quot;JianSong&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;float othersWidth = getWidth(jrPrintText, others, &lt;span class=&quot;hljs-string&quot;&gt;&quot;CorporateS&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return hanWidth + othersWidth;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Image&lt;/h2&gt;
&lt;h3&gt;显示图片&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;路径问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Jasper Studio 中添加一个 Image 组件，正确的设置一个图片的路径，点击预览就可以看到显示出来的图片了。但是细心的同学会发现在 &lt;code&gt;.jrxml&lt;/code&gt; 模板文件中图片的路径是一个绝对路径，这在实际生产过程中肯定是不行的。&lt;/p&gt;
&lt;p&gt;因此，通过搜索找出了一个方法，可以解决静态图片的路径问题。在 Image 组件的表达式中写上这样的表达式：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.getClass().getResourceAsStream(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/images/logo.png&quot;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1300&quot; data-height=&quot;360&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-9cff7be68f81bdf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-9cff7be68f81bdf3.png&quot; data-original-width=&quot;1300&quot; data-original-height=&quot;360&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;161896&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image-expression.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;还有几种其他的场景可能直接写&lt;a href=&quot;https://stackoverflow.com/questions/3623420/image-expression-url-in-jasper-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;相对路径&lt;/a&gt;也能工作，我没有验证过。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传参问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，Image 组件的表达式中不仅支持写图片的路径，也可以在代码中将图片读入内存然后直接以 InputStream 的形式传递，不过要确保每个 Stream 只能被消费一次，不要复用同一个 InputStream，如果想要复用，考虑使用 Image 组件的 &lt;code&gt;isUsingCache&lt;/code&gt; 属性。不过 Jasper 支持的类型除此之外，还有好几种：&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.lang&lt;span class=&quot;hljs-selector-class&quot;&gt;.String
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.io&lt;span class=&quot;hljs-selector-class&quot;&gt;.File
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.net&lt;span class=&quot;hljs-selector-class&quot;&gt;.URL
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.io&lt;span class=&quot;hljs-selector-class&quot;&gt;.InputStream
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.awt&lt;span class=&quot;hljs-selector-class&quot;&gt;.Image
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;net&lt;span class=&quot;hljs-selector-class&quot;&gt;.sf&lt;span class=&quot;hljs-selector-class&quot;&gt;.jasperreports&lt;span class=&quot;hljs-selector-class&quot;&gt;.engine&lt;span class=&quot;hljs-selector-class&quot;&gt;.JRRenderable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子可以参考&lt;a href=&quot;http://jasperreports.sourceforge.net/sample.reference/images/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;使用 InputStream 时可能遇到的问题&lt;/h3&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;net.sf.jasperreports.engine.JRException: java.io.IOException: The byte &lt;span class=&quot;hljs-built_in&quot;&gt;array is &lt;span class=&quot;hljs-keyword&quot;&gt;not a recognized imageformat.
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.processImageRetainShape(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1747)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.process(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1604)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.access$&lt;span class=&quot;hljs-number&quot;&gt;300(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1532)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportImage(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1472)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportElements(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1090)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportFrame(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;3117)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportElements(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1098)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportPage(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1053)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportReportToStream(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;917)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportReport(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;537)
      at net.sf.jasperreports.engine.JasperExportManager.exportToPdfFile(JasperExportManager.java:&lt;span class=&quot;hljs-number&quot;&gt;155)
      at net.sf.jasperreports.engine.JasperExportManager.exportReportToPdfFile(JasperExportManager.java:&lt;span class=&quot;hljs-number&quot;&gt;503)
      at com.finger.hr.controllers.HRCreatePDFController$&lt;span class=&quot;hljs-number&quot;&gt;2.run(HRCreatePDFController.java:&lt;span class=&quot;hljs-number&quot;&gt;244)
Caused by: java.io.IOException: The byte &lt;span class=&quot;hljs-built_in&quot;&gt;array is &lt;span class=&quot;hljs-keyword&quot;&gt;not a recognized imageformat.
      at com.lowagie.text.Image.getInstance(Unknown Source)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.processImageRetainShape(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1742)
      ... &lt;span class=&quot;hljs-number&quot;&gt;12 more
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.experts-exchange.com/questions/28991458/Jasper-Reports-Image-error-java-io-IOException-The-byte-array-is-not-a-recognized-imageformat-in-a-bulk-pdf-creation.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;解决办法&lt;/a&gt;很奇特，到现在我也不知道为什么。&lt;/p&gt;
&lt;p&gt;如果传递的参数是一个独立的 InputStream 类型的字段，就会有上述错误。 解决办法就是把这个单独的 字段包到一个 Java 对象中（:D）。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Getter
&lt;span class=&quot;hljs-meta&quot;&gt;@Setter
&lt;span class=&quot;hljs-meta&quot;&gt;@AllArgsConstructor
&lt;span class=&quot;hljs-meta&quot;&gt;@NoArgsConstructor
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;PhotoDto {
    &lt;span class=&quot;hljs-keyword&quot;&gt;private InputStream photo;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;List&lt;/h2&gt;
&lt;h3&gt;List 显示行号&lt;/h3&gt;
&lt;p&gt;不管是 List 还是 Table 如果只是想显示简单的行号，最简单的办法就是使用 &lt;a href=&quot;https://community.jaspersoft.com/questions/500238/display-row-numbers&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;$V{REPORT_COUNT}&lt;/code&gt;&lt;/a&gt;。 如果对行号还有一些比较复杂的计算逻辑，则最好在代码中处理好，然后作为数据的一个字段传递给 Jasper 直接渲染。&lt;/p&gt;
&lt;h3&gt;_THIS 大法&lt;/h3&gt;
&lt;p&gt;如果传递给 List 的（或者是 Table）数据是一个基本类型（这里姑且把 String 也看做基本类型，其实只要是不包含属性的对象都满足条件）的数据的集合，那么在引用单个数据的时候就得注意了，因为基本类型的数据不存在字段一说，所以需要在 Field 的命名上做点文章。&lt;/p&gt;
&lt;p&gt;比如说 dataSource 是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;，那么在定义 Field 的时候就没办引用对象的字段名了，这时候我们只需要将字段名定义为 &lt;code&gt;_THIS&lt;/code&gt; 即可，在引用的地方写 &lt;code&gt;$F{_THIS}&lt;/code&gt;。更多解释参考&lt;a href=&quot;https://community.jaspersoft.com/questions/1032486/detailed-explanation&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Table&lt;/h2&gt;
&lt;h3&gt;Dataset&lt;/h3&gt;
&lt;h3&gt;Table 嵌套中的坑&lt;/h3&gt;
&lt;p&gt;Table 中嵌套 Table 可以实现类似合并单元格的效果，但是如果最外层的 Table 中一行的高度超过了页面的最大高度就会直接报错，而不是分页。&lt;/p&gt;
&lt;h3&gt;Table 中实现分组效果&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Merge Cell？impossible！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Table 组件中不能直接做合并单元格的操作，只能通过嵌套 Table 来实现类似的效果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Table Cell 中的负数缩进&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在使用 Jasper Studio 6.6.0 版的设计器的时候，在界面上设置坐标值的时候，会出现保存不成功的情况。只能通过直接修改模板源文件的方式设置负数坐标。感觉是 IDE 的 Bug，在后续版本应该修复了。&lt;/p&gt;
&lt;p&gt;设置 right indent 为负数的时候，left indent 不能为 0，如果为 0 right indent 不会生效 :( (至今不知道为什么 :boom:)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用 Table 组件的特性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有分组的需求，可以考虑使用 Table 的 Group Header 和 Group Footer 来显示组名和小计之类的数据。&lt;/p&gt;
&lt;h2&gt;Text Field &amp;amp; Static Text&lt;/h2&gt;
&lt;p&gt;关于 Strech，在设计器里有一个属性叫做 &lt;code&gt;Strech With Overflow&lt;/code&gt;，当这个属性被勾选后，表示当数据的长度超过组件的长度时会自动折行，相当于垂直方向上的 Overflow，而 Jasper 也不支持水平方向的 Overflow。&lt;/p&gt;
&lt;p&gt;在 Jasper 中可以很方便的设置一些特殊文本的显示格式，比如： 日期，时间，货币，数字，百分比等。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;403&quot; data-height=&quot;332&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-c0f08762040a5afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/403&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-c0f08762040a5afe.png&quot; data-original-width=&quot;403&quot; data-original-height=&quot;332&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;48837&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;pattern.png&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;SubReport&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Compile 问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Jasper Studio 的设计器里可以通过直接引用 &lt;code&gt;*.jasper&lt;/code&gt; 文件的方式，在主报表中引用子报表。但是如果在实际的产品代码中这样做，非常不利于对源码的版本控制，因为这个 &lt;code&gt;*.jasper&lt;/code&gt; 文件是一个经过编译之后的临时文件。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;663&quot; data-height=&quot;374&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-4acee209d1305044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/663&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-4acee209d1305044.png&quot; data-original-width=&quot;663&quot; data-original-height=&quot;374&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;71351&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;subreport-expression.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们在生产代码中可以先将子报表的模板预编译好，然后直接以参数的形式传递给主报表（例如如下代码将编译好的 “checklist.jrxml” 子报表作为参数传给主报表，然后在主报表中的引用表达式写成&lt;code&gt;$P{checklist}&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;String subreport = &lt;span class=&quot;hljs-string&quot;&gt;&quot;checklist&quot;;
    JasperReport jasperReport = &lt;span class=&quot;hljs-literal&quot;&gt;null;
    &lt;span class=&quot;hljs-keyword&quot;&gt;try (InputStream inputStream = getResourceAsStream(subreport + &lt;span class=&quot;hljs-string&quot;&gt;&quot;.jrxml&quot;)) {
        jasperReport = JasperCompileManager.compileReport(inputStream);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (IOException | JRException e) {
        e.printStackTrace();
    }
    params.put(subreport, jasperReport);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Detail Band 重复多次的问题&lt;/h2&gt;
&lt;p&gt;Detail Band 被渲染的次数是由 Main Dataset 中数据条数决定的，如果发现 Detail Band 被重复渲染了多次，那么请检查是否添加了 Main Dataset 的 Query，并且查询出来的数据不止一条。如果没有要设置 Main Dataset 的场景，可以选择 &lt;code&gt;One Empty Record&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;页面的多列排版&lt;/h2&gt;
&lt;p&gt;在页面设置中的多列设置，只对 Detail Band，Column Header，Column Footer 有影响。&lt;/p&gt;
&lt;h2&gt;HTML Markup 的限制&lt;/h2&gt;
&lt;p&gt;对于 HTML Markup 的使用，其实没有想象中的那么美好，使用起来功能比较有限。只能支持文本格式相关的标签和属性，不支持布局相关的标签。所以想通过 CSS 实现 一些效果，基本上都行不通。&lt;/p&gt;
&lt;p&gt;支持的 HTML 标签如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;b&lt;/li&gt;
&lt;li&gt;u&lt;/li&gt;
&lt;li&gt;i&lt;/li&gt;
&lt;li&gt;font&lt;/li&gt;
&lt;li&gt;sup&lt;/li&gt;
&lt;li&gt;sub&lt;/li&gt;
&lt;li&gt;li&lt;/li&gt;
&lt;li&gt;br&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个列表是从源码中 找出来的，并没有什么文档（也有可能是我没搜到）明确的列出来。 源码参考&lt;a href=&quot;https://github.com/TIBCOSoftware/jasperreports/blob/a044d33a54d93f45000d99c818ca23403a30e6be/jasperreports/src/net/sf/jasperreports/engine/JRCommonText.java#L71&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Position Type 设置为 Float 中的误区&lt;/h2&gt;
&lt;p&gt;一开始我不是特别理解这个 Float Position Type 的原理，走了很多弯路，经过很长时间的摸索才理解 Float Position Type 的用法。其实主要是因为 Jaser Studio 设计器中显示出来的样子容易误导使用的人。&lt;/p&gt;
&lt;p&gt;正常情况下，在设计模板的时候我们会把一些组件摆放的规规矩矩，整整齐齐的，看着都觉得舒服。Float 是相对于设计器里离它最近的元素漂移的，其相对位置在设计模板的阶段就决定好了。而有的组件在设计器里展示的形状比较大，如果要摆放整齐，需要 Float 的元素就会有比较大的相对距离出现。其实，这个时候我们不能相信我们眼睛看到的，也不能有强迫症，在设计器里。因为很多时候需要一些元素看上去是叠在一起的，渲染出来的效果反而是我们需要的。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;871&quot; data-height=&quot;438&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-22db6aa1c0e3a578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-22db6aa1c0e3a578.png&quot; data-original-width=&quot;871&quot; data-original-height=&quot;438&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;117983&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;position-type-float.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们在实际项目中有一个模板设计出来是这样的，是不是看着感觉很乱，但是要使用 Float 达到我们想要的效果，还必须要设计成这样。&lt;/p&gt;
&lt;h2&gt;时间的时区问题&lt;/h2&gt;
&lt;p&gt;解决报表中时区问题很简单，只需要给报表内置的一个变量传入相应的时区就行了。&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Map&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;String, &lt;span class=&quot;hljs-built_in&quot;&gt;Object&amp;gt; params = &lt;span class=&quot;hljs-keyword&quot;&gt;new HashMap&amp;lt;&amp;gt;();
params.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;REPORT_TIME_ZONE&quot;, TimeZone.getTimeZone(ZoneId.of(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Asia/Shanghai&quot;)));
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;通过代码定位元素坐标（终极大法）&lt;/h2&gt;
&lt;p&gt;如果在 Jasper Studio 中无法实现组件的动态定位，基本上也就只有这么一条路可以走了。如果这条路也实现不了，要么改需求，要么换掉 Jasper Report 解决方案。&lt;/p&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v71/getting-started-jaspersoft-studio-0&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v71/getting-started-jaspersoft-studio-0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/understanding-bands&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/understanding-bands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/wiki/report-structure-jaspersoft-studio&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/wiki/report-structure-jaspersoft-studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://communities.ca.com/blogs/rob.ensinger/2015/12/28/how-to-single-textbox-page-x-of-y-page-counts-in-jaspersoft-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://communities.ca.com/blogs/rob.ensinger/2015/12/28/how-to-single-textbox-page-x-of-y-page-counts-in-jaspersoft-reports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/10673263/show-page-x-of-y-using-a-single-text-field&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/10673263/show-page-x-of-y-using-a-single-text-field&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/working-font-extensions&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/working-font-extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3623420/image-expression-url-in-jasper-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/3623420/image-expression-url-in-jasper-reports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27903072/print-liststring-each-element-in-new-field&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/27903072/print-liststring-each-element-in-new-field&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:44:00 +0000</pubDate>
<dc:creator>pengisgood</dc:creator>
<og:description>Mac Book Pro 10.13.6Jaspersoft Studio community version 6.6.9JDK 8 安装 Jaspersoft Studio Jasper Repor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/penghongwei/p/9471801.html</dc:identifier>
</item>
<item>
<title>SpringBoot简单打包部署(附工程) - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9471802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9471802.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要介绍SpringBoot的一些打包事项和项目部署以及在其中遇到一些问题的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;springboot打包&quot;&gt;SpringBoot打包&lt;/h2&gt;
&lt;p&gt;在SpringBoot打包这块，我们就用之前的一个web项目来进行打包。&lt;br/&gt;首先需要明确的是，该项目打包的形态是可执行的&lt;strong&gt;jar&lt;/strong&gt;包，还是在&lt;strong&gt;tomcat&lt;/strong&gt;下运行的&lt;strong&gt;war&lt;/strong&gt;包。&lt;br/&gt;虽然本项目是用&lt;strong&gt;maven&lt;/strong&gt;构建的，用&lt;strong&gt;maven&lt;/strong&gt;打包也更加方便，但是这里也说明普通非&lt;strong&gt;maven&lt;/strong&gt;打包的项目如何打包。&lt;/p&gt;
&lt;h3 id=&quot;maven打包&quot;&gt;Maven打包&lt;/h3&gt;
&lt;p&gt;首先是&lt;strong&gt;maven&lt;/strong&gt;方式打包:&lt;br/&gt;如果是&lt;strong&gt;jar&lt;/strong&gt;包&lt;br/&gt;需在&lt;code&gt;pom.xml&lt;/code&gt;指定打成的包为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是&lt;strong&gt;war&lt;/strong&gt;包。&lt;br/&gt;需在&lt;code&gt;pom.xml&lt;/code&gt;指定打成的包为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并通过&lt;code&gt;&amp;lt;scope&amp;gt;&lt;/code&gt;标签在打包的时候排除&lt;strong&gt;tomcat&lt;/strong&gt;依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后添加&lt;strong&gt;SpringBoot&lt;/strong&gt;自带的打包方式&lt;br/&gt;&lt;strong&gt;示例如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
        &amp;lt;defaultGoal&amp;gt;compile&amp;lt;/defaultGoal&amp;gt;
        &amp;lt;sourceDirectory&amp;gt;src&amp;lt;/sourceDirectory&amp;gt;
        &amp;lt;finalName&amp;gt;springboot-package&amp;lt;/finalName&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin &amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;
                    &amp;lt;mainClass&amp;gt;com.pancm.App&amp;lt;/mainClass&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;code&gt;&amp;lt;finalName&amp;gt;&lt;/code&gt;标签是指定打包之后的名称，&lt;code&gt;&amp;lt;mainClass&amp;gt;&lt;/code&gt;是指定main函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也可以不用&lt;strong&gt;SpringBoot&lt;/strong&gt;自带的打包方式，使用&lt;strong&gt;maven&lt;/strong&gt;的&lt;strong&gt;assembly&lt;/strong&gt;插件进行打包。&lt;br/&gt;&lt;strong&gt;示例如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
          &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;2.5.5&amp;lt;/version&amp;gt;  
            &amp;lt;configuration&amp;gt;
                &amp;lt;archive&amp;gt;  
                    &amp;lt;manifest&amp;gt;  
                        &amp;lt;mainClass&amp;gt;com.pancm.App&amp;lt;/mainClass&amp;gt;  
                    &amp;lt;/manifest&amp;gt;  
                &amp;lt;/archive&amp;gt;  
                &amp;lt;descriptorRefs&amp;gt;  
                    &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;  
                &amp;lt;/descriptorRefs&amp;gt;  
            &amp;lt;/configuration&amp;gt;  
        &amp;lt;/plugin&amp;gt; 
       &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;strong&gt;pom.xml&lt;/strong&gt;中添加完相应的标签之后，我们只需在项目同级（pom.xml同级）输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn clean package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可完成打包&lt;br/&gt;如果想排除测试代码，则可以输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn clean package  -Dmaven.test.skip=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来进行打包。&lt;/p&gt;
&lt;p&gt;一般我们是把&lt;strong&gt;application.properties&lt;/strong&gt;和&lt;strong&gt;logback.xml&lt;/strong&gt;文件放在resources文件夹中，但是进行打包之后，它们也会包含在&lt;strong&gt;jar&lt;/strong&gt;或&lt;strong&gt;war&lt;/strong&gt;包中，如果我们想更改配置，则会比较麻烦。&lt;br/&gt;如果想将它们和项目放在同级目录下，&lt;strong&gt;application.properties&lt;/strong&gt;可以直接移出和项目同级的目录下，因为Spring程序会按优先级从下面这些路径来加载&lt;strong&gt;application.properties&lt;/strong&gt;配置文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前目录下的/config目录&lt;/li&gt;
&lt;li&gt;当前目录&lt;/li&gt;
&lt;li&gt;classpath里的/config目录&lt;/li&gt;
&lt;li&gt;classpath 根目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;springboot&lt;/strong&gt;默认加载的&lt;strong&gt;logback&lt;/strong&gt;是在&lt;strong&gt;classpath&lt;/strong&gt;目录下，这时我们只需要在&lt;strong&gt;application.properties&lt;/strong&gt;配置文件指定&lt;strong&gt;logback.xml&lt;/strong&gt;的路径即可。&lt;br/&gt;添加如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;logging.config=logback.xml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果引入了第三方的&lt;strong&gt;jar&lt;/strong&gt;包，但是又无法通过&lt;strong&gt;maven&lt;/strong&gt;私服进行下载，这时可以手动进行编译。&lt;br/&gt;例如，我写了一个工具类为&lt;strong&gt;Mytools&lt;/strong&gt;，然后把它打成了一个&lt;strong&gt;jar&lt;/strong&gt;包，然后放在我的这个项目中&lt;strong&gt;lib&lt;/strong&gt;目录下，并且需要引用它，那么此时便可以对该&lt;strong&gt;jar&lt;/strong&gt;包进行编译到本地仓库中，然后再&lt;strong&gt;pom.xml&lt;/strong&gt;添加相应的名称和版本号。&lt;br/&gt;命令示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn install:install-file -Dfile=lib/pancmtools.jar -DgroupId=com.panncm.utils -DartifactId=pancm-utils -Dversion=1.0 -Dpackaging=jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.panncm.utils&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pancm-utils&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;便可以进行打包了。&lt;/p&gt;
&lt;h3 id=&quot;普通项目打包&quot;&gt;普通项目打包&lt;/h3&gt;
&lt;p&gt;如果是普通的项目，没有使用&lt;strong&gt;maven&lt;/strong&gt;构建的话，可以使用&lt;strong&gt;eclipse&lt;/strong&gt;等工具进行打包。&lt;br/&gt;如果是&lt;strong&gt;jar&lt;/strong&gt;包&lt;br/&gt;首先在&lt;strong&gt;eclipse&lt;/strong&gt;中运行该项目(&lt;strong&gt;main&lt;/strong&gt;方法运行)，然后在&lt;strong&gt;eclipse&lt;/strong&gt;中右键项目 &lt;code&gt;export -&amp;gt;java -&amp;gt; runnable jar file-&amp;gt; package required libraries into generated jar&lt;/code&gt; 指定&lt;strong&gt;main&lt;/strong&gt;方法，然后选择打包的名称以及打包的路径。点击&lt;strong&gt;finish&lt;/strong&gt;完成打包。&lt;/p&gt;
&lt;p&gt;如果是&lt;strong&gt;war&lt;/strong&gt;包&lt;br/&gt;在&lt;strong&gt;eclipse&lt;/strong&gt;中右键项目 &lt;code&gt;export -&amp;gt;web -&amp;gt; war file&lt;/code&gt;，然后选择打包的名称以及打包的路径。点击&lt;strong&gt;finish&lt;/strong&gt;完成打包。&lt;/p&gt;
&lt;h3 id=&quot;ant打包&quot;&gt;Ant打包&lt;/h3&gt;
&lt;p&gt;介绍了上述两种打包之后，这里介绍下通过&lt;strong&gt;ant&lt;/strong&gt;方法进行打包(需要安装&lt;strong&gt;ant&lt;/strong&gt;环境，安装方式基本和maven一致，指定路径，配置环境变量，这里就不在过多讲述了)。&lt;br/&gt;一般打包之后，我们需要将包和配置文件放在一个目录下，这时我们又不想手动进行复制粘贴的话，就可以用&lt;strong&gt;ant&lt;/strong&gt;来进行打包，将打包的文件整合在一起。&lt;br/&gt;这里我们就编写一个&lt;strong&gt;build.xml&lt;/strong&gt;的配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project name=&quot;springboot-package&quot; default=&quot;copyAll&quot; basedir=&quot;.&quot;&amp;gt;
    &amp;lt;property name=&quot;build&quot; value=&quot;build&quot; /&amp;gt;
    &amp;lt;property name=&quot;target&quot; value=&quot;target&quot; /&amp;gt;
    &amp;lt;target name=&quot;clean&quot;&amp;gt;
        &amp;lt;delete dir=&quot;${target}&quot; /&amp;gt;
        &amp;lt;delete dir=&quot;${build}&quot; /&amp;gt;
    &amp;lt;/target&amp;gt;

    &amp;lt;target name=&quot;create-path&quot; depends=&quot;clean&quot;&amp;gt;
        &amp;lt;mkdir dir=&quot;${build}&quot; /&amp;gt;
    &amp;lt;/target&amp;gt;

    &amp;lt;target name=&quot;mvn_package&quot; depends=&quot;create-path&quot;&amp;gt;
        &amp;lt;exec executable=&quot;cmd&quot; failonerror=&quot;true&quot;&amp;gt;
            &amp;lt;arg line=&quot;/c mvn install:install-file -Dfile=lib/pancmtools.jar -DgroupId=com.panncm.utils -DartifactId=pancm-utils -Dversion=1.0 -Dpackaging=jar&quot; /&amp;gt;
        &amp;lt;/exec&amp;gt;
        &amp;lt;exec executable=&quot;cmd&quot; failonerror=&quot;true&quot;&amp;gt;
            &amp;lt;arg line=&quot;/c mvn clean package&quot; /&amp;gt;
        &amp;lt;/exec&amp;gt;
    &amp;lt;/target&amp;gt;

    &amp;lt;target name=&quot;copyAll&quot; depends=&quot;mvn_package&quot;&amp;gt;
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;${target}/springboot-package.jar&quot;&amp;gt;&amp;lt;/copy&amp;gt; 
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;logback.xml&quot;&amp;gt;&amp;lt;/copy&amp;gt;
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;application.properties&quot;&amp;gt;&amp;lt;/copy&amp;gt;
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;run.bat&quot;&amp;gt;&amp;lt;/copy&amp;gt;
    &amp;lt;/target&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：&lt;code&gt;&amp;lt;mkdir dir=&quot;${build}&quot; /&amp;gt;&lt;/code&gt;是指定文件存放的文件夹，&lt;strong&gt;executable&lt;/strong&gt;是使用cmd命令，&lt;strong&gt;line&lt;/strong&gt;是执行的语句， 标签是将文件复制到指定的文件夹中。&lt;/p&gt;
&lt;p&gt;然后再新建一个 &lt;strong&gt;build.bat&lt;/strong&gt;文件，里面只需要填写 &lt;code&gt;ant&lt;/code&gt;就行了。&lt;br/&gt;准备完之后，只需双击&lt;strong&gt;build.bat&lt;/strong&gt;，项目和配置文件就自动到&lt;strong&gt;build&lt;/strong&gt;文件中了，省去了很多操作。&lt;/p&gt;
&lt;p&gt;虽然现在流行通过&lt;strong&gt;jenkins&lt;/strong&gt;进行打包部署，不过使用ant加maven进行打包也不错的，比较简单。&lt;/p&gt;
&lt;h2 id=&quot;springboot部署&quot;&gt;SpringBoot部署&lt;/h2&gt;
&lt;p&gt;如果是&lt;strong&gt;jar&lt;/strong&gt;项目&lt;br/&gt;&lt;strong&gt;Windows&lt;/strong&gt;系统在项目同级目录下输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar springboot-package &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可启动项目。&lt;br/&gt;关闭项目，只需关掉&lt;strong&gt;dos&lt;/strong&gt;界面就可以了。&lt;br/&gt;也可以写一个&lt;strong&gt;bat&lt;/strong&gt;文件进行运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;系统在项目同级目录下输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup -jar springboot-package &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可启动。&lt;br/&gt;关闭输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill -9 pid（jar的进程id）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在&lt;code&gt;init.d&lt;/code&gt;注册一个服务&lt;br/&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ln -s /home/jars/app/springboot-package.jar /etc/init.d/springboot-package
chmod +x /etc/init.d/springboot-package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service springboot-package start|stop|restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行启动或者停止。&lt;br/&gt;当然也可以编写&lt;strong&gt;xshell&lt;/strong&gt;脚本进行启动和关闭。&lt;/p&gt;
&lt;p&gt;如果是&lt;strong&gt;war&lt;/strong&gt;项目&lt;br/&gt;将&lt;strong&gt;war&lt;/strong&gt;放在&lt;strong&gt;tomcat/webapp&lt;/strong&gt;目录下，然后启动&lt;strong&gt;tomcat&lt;/strong&gt;就可以了。&lt;strong&gt;Windows&lt;/strong&gt;系统 在&lt;strong&gt;tomcat/bin&lt;/strong&gt;目录下双击&lt;strong&gt;startup.bat&lt;/strong&gt;即可启动，双击&lt;strong&gt;shutdown.bat&lt;/strong&gt;关闭。&lt;br/&gt;&lt;strong&gt;Linux&lt;/strong&gt;系统则在&lt;strong&gt;tomcat/bin&lt;/strong&gt; 目录下输入&lt;strong&gt;startup.sh&lt;/strong&gt;即可启动， 输入&lt;strong&gt;shutdown.sh&lt;/strong&gt;关闭。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;关于SpringBoot打包部署就讲解到这里了，如有不妥，欢迎指正！&lt;br/&gt;SpringBoot打包部署的项目工程地址:&lt;br/&gt;&lt;a href=&quot;https://github.com/xuwujing/springBoot-study/tree/master/springboot-package&quot; class=&quot;uri&quot;&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-package&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot整合系列:&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:43:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本文主要介绍SpringBoot的一些打包事项和项目部署以及在其中遇到一些问题的解决方案。 SpringBoot打包 在SpringBoot打包这块，我们就用之前的一个web项目来进行打包。 首</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9471802.html</dc:identifier>
</item>
<item>
<title>推荐BIG DATA Spark 的7本学习电子书籍（大牛专区） - 跨界大数据</title>
<link>http://www.cnblogs.com/coxiebig/p/9471794.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coxiebig/p/9471794.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813215309854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本书于2017-03由Packt Publishing出版，作者Muhammad Asif Abbasi，全书356页。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;概述大数据分析及其对组织和数据专业人员的重要性&lt;/li&gt;
&lt;li&gt;深入了解Spark，了解它与现有处理平台的区别&lt;/li&gt;
&lt;li&gt;了解各种文件格式的复杂性，以及如何使用Apache Spark处理它们。&lt;/li&gt;
&lt;li&gt;实现如何使用YARN，MESOS或独立集群管理器部署Spark。&lt;/li&gt;
&lt;li&gt;了解Spark SQL，SchemaRDD，缓存以及使用Hive和Parquet文件格式的概念&lt;/li&gt;
&lt;li&gt;了解Spark MLLib的架构，同时讨论Spark附带的一些现成算法。&lt;/li&gt;
&lt;li&gt;介绍一下SparkR的部署和使用情况。&lt;/li&gt;
&lt;li&gt;了解图形计算和市场上可用的图形处理系统的重要性&lt;/li&gt;
&lt;li&gt;通过使用ALS使用Spark构建推荐引擎来检查Spark的真实示例。&lt;/li&gt;
&lt;li&gt;使用Telco数据集，使用随机森林预测客户流失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813225538640?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本书适合数据工程师，数据科学家以及那些想使用Spark的读者。阅读本书之前最好有Scala的编程基础。通过本书你将学到以下知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在AWS上使用各种集群管理器安装和配置Apache Spark&lt;/li&gt;
&lt;li&gt;为Apache Spark设置开发环境，包括Databricks Cloud笔记本&lt;/li&gt;
&lt;li&gt;了解如何使用模式在Spark中操作数据&lt;/li&gt;
&lt;li&gt;使用Spark Streaming和Structured Streaming掌握实时流分析&lt;/li&gt;
&lt;li&gt;使用MLlib掌握监督学习和无监督学习&lt;/li&gt;
&lt;li&gt;使用MLlib构建推荐引擎&lt;/li&gt;
&lt;li&gt;使用GraphX和GraphFrames库进行图形处理&lt;/li&gt;
&lt;li&gt;开发一组通用应用程序或项目类型，以及解决复杂大数据问题的解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;了解Spark流媒体是如何适应全局的&lt;/li&gt;
&lt;li&gt;学习核心概念，如Spark RDDs、Spark流集群和DStream的基础知识&lt;/li&gt;
&lt;li&gt;了解如何创建健壮的部署&lt;/li&gt;
&lt;li&gt;深入流算法&lt;/li&gt;
&lt;li&gt;学习如何调优，测量和监测火花流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231454407?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用不同的文件格式处理数据，例如XML、JSON、CSV和纯文本，使用Spark core库。&lt;/li&gt;
&lt;li&gt;使用Spark流媒体库对来自各种数据源的数据进行分析，例如Kafka和Flume&lt;/li&gt;
&lt;li&gt;学习使用各种SQL函数(包括Spark SQL库中的窗口函数)创建SQL模式和分析结构化数据&lt;/li&gt;
&lt;li&gt;在实现机器学习技术以解决实际问题的同时，探索Spark Mlib api&lt;/li&gt;
&lt;li&gt;了解Spark GraphX，这样您就可以了解使用Spark执行的各种基于图形的分析&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231635592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;了解Scala面向对象和函数式编程的概念&lt;/li&gt;
&lt;li&gt;深入了解Scala集合api&lt;/li&gt;
&lt;li&gt;使用RDD和DataFrame学习Spark的核心抽象&lt;/li&gt;
&lt;li&gt;使用SparkSQL和GraphX分析结构化和非结构化数据&lt;/li&gt;
&lt;li&gt;使用Spark结构化流进行可伸缩的容错流应用程序开发&lt;/li&gt;
&lt;li&gt;学习机器学习的最佳实践，分类，回归，降维，和推荐系统，以建立预测模型与广泛使用的算法在Spark MLlib &amp;amp; ML&lt;br/&gt;构建集群模型来集群大量数据&lt;/li&gt;
&lt;li&gt;了解Spark应用程序的调优、调试和监视&lt;br/&gt;在独立集群、Mesos和YARN上部署Spark应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231820463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本书适合软件工程师、数据工程师、开发者以及Spark系统管理员的使用。通过本数你可以学到：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;了解如何使Spark作业运行速度更快；&lt;/li&gt;
&lt;li&gt;使用Spark探索数据；&lt;/li&gt;
&lt;li&gt;使用Spark处理更大的数据集；&lt;/li&gt;
&lt;li&gt;减少管道运行时间以获得更快的洞察力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813232017662?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;接触最新版本的Spark ML&lt;/li&gt;
&lt;li&gt;用Scala和Python创建您的第一个Spark程序&lt;/li&gt;
&lt;li&gt;在您自己的计算机上以及在Amazon EC2上为Spark设置和配置开发环境&lt;/li&gt;
&lt;li&gt;访问公共机器学习数据集并使用Spark加载、处理、清理和转换数据&lt;/li&gt;
&lt;li&gt;使用Spark机器学习库通过使用众所周知的机器学习模型来实现程序&lt;/li&gt;
&lt;li&gt;处理大规模的文本数据，包括特征提取和使用文本数据作为机器学习模型的输入&lt;/li&gt;
&lt;li&gt;编写Spark函数来评估机器学习模型的性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813232155292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎订阅博客&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:42:00 +0000</pubDate>
<dc:creator>跨界大数据</dc:creator>
<og:description>目录 [toc] Lean Apache Spark 2 本书于2017 03由Packt Publishing出版，作者Muhammad Asif Abbasi，全书356页。 通过本书你将学到以下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coxiebig/p/9471794.html</dc:identifier>
</item>
</channel>
</rss>