<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一个在线排版小工具：中文、英文、数字、符号中间加个空格 - kurryluo</title>
<link>http://www.cnblogs.com/kurryluo/p/9672166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kurryluo/p/9672166.html</guid>
<description>&lt;p&gt;我一直相信这个世界是懒人创造的。&lt;/p&gt;
&lt;p&gt;大家如果仔细看我的文章，会发现一个有趣的地方。就是数字、英文和中文之间会多一个空格，比如 1 是数字，1 两边有空格。如果你再仔细观察，微信文字消息的排版风格也是这样，不信你试试。&lt;/p&gt;
&lt;p&gt;这个排版的风格是师从 stormzhang，包括微信整个排版风格都跟他差不多，只是我比较喜欢在文章开头放一张图片，以后考虑放一段语音。&lt;/p&gt;
&lt;p&gt;写文章免不了中英文混合，还有阿拉伯数字夹杂其中，每次码字的时候，之前我都是挨个敲空格，终于有一天右手大拇指疼得罢工了，我就想，能不能写一个转换工具呢。&lt;/p&gt;
&lt;p&gt;说干就干，我起先想自己操作，利用 JavaScript 的正则表达式似乎不是很难的事儿。就在查找教程的时候，发现一个很好用的工具 &lt;a href=&quot;https://github.com/vinta/pangu.js/&quot;&gt;pangu.js&lt;/a&gt;，懒癌发作，直接拿来用了。它的介绍是这样的&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;為什麼你們就是不能加個空格呢？&lt;/p&gt;
&lt;p&gt;如果你跟我一樣，每次看到網頁上的中文字和英文、數字、符號擠在一塊，就會坐立難安，忍不住想在它們之間加個空格。這個外掛（支援 Chrome 和 Firefox）正是你在網路世界走跳所需要的東西，它會自動替你在網頁中所有的中文字和半形的英文、數字、符號之間插入空白。&lt;/p&gt;
&lt;p&gt;漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。&lt;/p&gt;
&lt;p&gt;與大家共勉之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以发现这个工具后，我今天晚上用了半个小时开发完就用上了，地址是：&lt;a href=&quot;http://www.kurryluo.com/transform&quot; class=&quot;uri&quot;&gt;http://www.kurryluo.com/transform&lt;/a&gt;， 希望对你有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/18/165ed4eb6b0bbdef?w=1329&amp;amp;h=608&amp;amp;f=png&amp;amp;s=15724&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：这篇文章也是经过 pangu 劈开过的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/28/16580e5417d2716a?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27042&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家关注微信公众号：** 可视化技术（ visteacher ）**&lt;/p&gt;
&lt;p&gt;不仅有前端和可视化，还有算法、源码分析、书籍相送&lt;/p&gt;
&lt;p&gt;个人网站：&lt;a href=&quot;http://blog.kurryluo.com/&quot; class=&quot;uri&quot;&gt;http://blog.kurryluo.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各个分享平台的 KurryLuo 都是在下。&lt;/p&gt;
&lt;p&gt;用心学习，认真生活，努力工作！&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 15:39:00 +0000</pubDate>
<dc:creator>kurryluo</dc:creator>
<og:description>我一直相信这个世界是懒人创造的。 大家如果仔细看我的文章，会发现一个有趣的地方。就是数字、英文和中文之间会多一个空格，比如 1 是数字，1 两边有空格。如果你再仔细观察，微信文字消息的排版风格也是这样</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kurryluo/p/9672166.html</dc:identifier>
</item>
<item>
<title>.NET西安社区 [拥抱开源，又见 .NET] 活动简报 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9671905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9671905.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201809/1413706-20180918224226456-1729969901.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥抱开源, 又见 .NET」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;随着 .NET Core的发布和开源，.NET又重新回到了人们的视野。除了开源、跨平台、高性能以及优秀的语言特性，越来越多的第三方开源库也出现在了Github上——包括ML.NET机器学习、Xamarin移动开发平台、基于Actor模型的分布式框架Orleans以及分布式开发及部署平台Service Fabric等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9月15日 .NET西安社区第一次线下分享交流会如期举行并取得圆满成功；以下是活动本次活动的精彩内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201809/1413706-20180918224440112-506379175.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci4.googleusercontent.com/proxy/mMbkBGh_OJlPO_RXybl3UN52oknWw2bXv8jBPw8e0X5hs5KvAN9GD1WEZVglVMVDluj_Ym9AtfEWoWXIaT4hMDZQ6U8bYFt5nJFF4rRURkbW9R8G2D5kwRlDLLY6ce9zQ4zaNvT1AMkn79RxRmgX78vUAHqrJk8Vqi44Oom9F_jlQDk=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/782b2f7e-7384-46a3-8cca-4369cbc43351.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;      &lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci5.googleusercontent.com/proxy/Q20XUSHq7mfSfRfc8SvrVw47kRG8kyT-goRexh84jPWwWNBwDILUSMudyiISXkQIjNZetAJ0zyR6xKQ_McNJ0TKGD-j6-gauN421sgg-joMM_SJWV7J6QnmWoD_63toRsomq-EDVqaF44N3N0NsNXY3-zsta5a1OXHeI7kfXtnwQ0Uw=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/2ee8eb4f-4dc5-4418-823f-f0ceb0ece0b8.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci6.googleusercontent.com/proxy/_N30oL1HnMZ8xaCF3QlEZSM7KrNvc8wTaTeMf9FEN-8JWmpz7-Svo79MWbv8KYfhAhwWGk8QbU0LiNly7wuJeygyZ8qv6CANsnXye0YK58DFjY80FPn2-yHc56V9_NUO_GhA1FDrGai4RKzttUVABT8ke_gQbiVNyDQloD9MjDDMgn8=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/1dcc1873-baa1-4e6a-a9fc-31d65f4e0ae7.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;      &lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci3.googleusercontent.com/proxy/04aYdeoZM2to7HyT3hh5GI2JpmiPxmC3iCW8jlHWvjG3BFcAxNhxLFKjqhjfDtckB7Xqz1XVhk-c-zj4z1Sr0tZ42tzz-QXu98fr0ZZy7XR_KTdTdWNIgk0U0UOIw1_UDvXHm_G2L-M3gAVWfnLQHSO9E3C5_Ua9fQtojSgX0bqrlUc=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/5e264564-2ba0-4322-975f-860b21ee994a.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;活动反馈：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201809/1413706-20180918225240768-1870851214.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢张阳对F#普及，改变了自己很多对代码的认识。希望能分享一些&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&quot; target=&quot;_blank&quot; data-saferedirecturl=&quot;https://www.google.com/url?hl=en&amp;amp;q=https://docs.microsoft.com/en-us/aspnet/core/?view%3Daspnetcore-2.1&amp;amp;source=gmail&amp;amp;ust=1537367771308000&amp;amp;usg=AFQjCNEJxp0Zi7hA7UAoiOm6kgqxElfOdQ&quot;&gt;ASP.NET Core&lt;/a&gt;&lt;/span&gt;大型工程化的经验和干货。也愿意作为讲师分享使用Blazor的心得；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;认识了新朋友，对DotNet了解更深入，觉得应该有一些 .NET Core新特性，以及相对于 .NET Fx的优势的介绍，期望下次活动分享交流Azure，.NET Core应用架构相关经验心得；也愿意作为讲师进行&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&quot; target=&quot;_blank&quot; data-saferedirecturl=&quot;https://www.google.com/url?hl=en&amp;amp;q=https://docs.microsoft.com/en-us/aspnet/core/?view%3Daspnetcore-2.1&amp;amp;source=gmail&amp;amp;ust=1537367771308000&amp;amp;usg=AFQjCNEJxp0Zi7hA7UAoiOm6kgqxElfOdQ&quot;&gt;ASP.NET Core&lt;/a&gt;+Azure App Service+ Azure SQL实践分享；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;增长了见识，见识到很多新的技术，多增加互动的环节效果会更好；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特别鸣谢：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢魏琼东，张文清，张阳三位讲师为我们带来的精彩话题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;感谢西安thoughtworks对「拥抱开源, 又见 .NET」第一次线下分享交流活动的大力支持；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;还有陈计节，远在北京，特意主动联系我们，赞助 .NET西安社区《C#本质论》&amp;amp;《.NET性能优化》共10本图书；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;感谢彭子健，马建勋，阿布，何易凡，王婧，卢冲（排名以报名顺序为准）牺牲周末，冒雨前来，协助社区布置活动现场，维护活动内外场秩序。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;非常感谢大家的鼎力支持，是你们的支持和付出，促成了 .NET西安社区的成立，也促成了西安地区第一次 .NET线下分享交流会的圆满成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后的最后，期待大家对 .NET西安社区持续关注，更期待大家线上、线下分享。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面是三位讲师的ppt下载链接。&lt;/span&gt;&lt;/p&gt;




</description>
<pubDate>Tue, 18 Sep 2018 15:11:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>拥抱开源, 又见 .NET」 随着 .NET Core的发布和开源，.NET又重新回到了人们的视野。除了开源、跨平台、高性能以及优秀的语言特性，越来越多的第三方开源库也出现在了Github上——包括M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9671905.html</dc:identifier>
</item>
<item>
<title>机器学习之KNN原理与代码实现 - w_x_w1985</title>
<link>http://www.cnblogs.com/further-further-further/p/9670187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/further-further-further/p/9670187.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;Created on Mon Sep 17 15:58:58 2018
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;KNN(K-Nearest Neighbor) K-近邻算法
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;@author: weixw
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; operator
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：行测试数据集，训练数据集，标签数据集，用于选择最近邻居的数目&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：根据欧氏距离公式，找到与未知类别的测试数据距离最小的 k 个点，&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     以这 k 个点出现频率最高的类别座位测试数据的预测分类。&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     欧氏距离公式：测试数据与训练数据对应位置作差，平方和，然后开方&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：测试数据预测分类结果&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; classify(testDataSet, trainingDataSet, labelList, k):
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据集行数&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     trainingDataSetSize =&lt;span&gt; trainingDataSet.shape[0]
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;np.tile(testDataSet, (trainingDataSetSize,1)沿X轴复制1倍（相当于没有复制），再沿Y轴复制trainingDataSetSize倍，维数：1000*3&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;欧氏距离公式实现 &lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 测试数据 - 训练数据&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;     diffMat = np.mat(np.tile(testDataSet, (trainingDataSetSize, 1)) -&lt;span&gt; trainingDataSet)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 差平方（需要将matrix转化为数组，否则报错）&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     sqDiffMat = diffMat.A**2
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3 按行求和 axis = 0(默认按列) axis = 1(按行)&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     sqDistances = sqDiffMat.sum(axis = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4 开方&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     distances = sqDistances**0.5
&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;agrsort():从小到大排序，返回欧氏距离最小值对应的索引列表&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;     sortedDistIndicies =&lt;span&gt; distances.argsort()
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测分类计数&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;     predictClassCount =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;多数表决方式，选择 k 个欧氏距离最小值 &lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k):
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;找到索引对应的标签值&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         voteLabel =&lt;span&gt; labelList[sortedDistIndicies[i]]
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测标签值字典，存储索引标签值预测次数&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         predictClassCount[voteLabel] = predictClassCount.get(voteLabel, 0) + 1
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对象按值逆向（由大到小）排序 &lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; sorted(iterable[, cmp[, key[, reverse]]])&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; itemgetter(1) 取第一项结果&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     sortedPredictClassCount = sorted(predictClassCount.items(), key = operator.itemgetter(1), reverse =&lt;span&gt; True)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sortedPredictClassCount[0][0]
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：数据文件&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：加载文件，文件最后一列是标签数据，分离特征数据集与标签数据集&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     自动检测多少列特征数据并分离&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：特征数据集矩阵，标签数据集矩阵&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadDataSet(fileName):
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;特征数据列长度&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     numberFeat = len(open(fileName).readline().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) - 1
&lt;span&gt; 53&lt;/span&gt;     dataSet = []; labelSet =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     fr =&lt;span&gt; open(fileName)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fr.readlines():
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         lineArr =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;去除收尾空格，然后分割每一列&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;         curLine = line.strip().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存每一列特征数据&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(numberFeat):
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            lineArr.append(float(curLine[i]))
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        dataSet.append(lineArr)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         labelSet.append(float(curLine[-1&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; np.mat(dataSet), labelSet
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：原始特征数据集&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：数据归一化，使每类数据都在同一范围内 (0, 1) 变化&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     归一化公式：newValue = (oldValue - min)/(max - min)&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：归一化后特征数据集，范围数组大小（分母）,列最小值数组   &lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; autoNorm(dataMat):
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;min(axis) 无参数：所有值中最小值；axis = 0：每列最小值；axis = 1：每行最小值&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出每列最小值&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     minValsMat =&lt;span&gt; dataMat.min(0)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出每列最大值&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;     maxValsMat =&lt;span&gt; dataMat.max(0)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算差值（对应位置相减）&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;     rangesMat = maxValsMat -&lt;span&gt; minValsMat
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化特征数据集初始化，维数：1000*3&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;     normDataMat =&lt;span&gt; np.zeros(np.shape(dataMat))
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始数据集行数目&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;     m =&lt;span&gt; dataMat.shape[0]
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化公式分子实现&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;np.tile(minVals, (m,1)沿X轴复制1倍（相当于没有复制），再沿Y轴复制m倍，维数：1000*3&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;     normDataMat = dataMat - np.tile(minValsMat, (m, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化公式实现，求得归一化结果&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;     normDataMat = normDataMat/np.tile(rangesMat, (m, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; normDataMat, rangesMat, minValsMat
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：特征数据集矩阵，标签数据集列表，测试数据与训练数据比例，用于选择最近邻居的数目&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：求出测试特征数据集预测分类结果&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.解析文件&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.通过ratio确定测试数据集&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.归一化&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.对每一行测试数据运用欧氏距离公式以及多数表决方式预测分类结果&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.求出整个测试数据集的预测分类结果&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：测试数据预测分类结果&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dataClassify(dataMat, labelList, ratio, k):
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;特征数据集归一化&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;     normDataMat, rangesMat, minValsMat =&lt;span&gt; autoNorm(dataMat)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化特征数据集行数目&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;     m =&lt;span&gt; normDataMat.shape[0]
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;测试数据集行数目（也就知道训练数据集行数）&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;     testDataNum = int(m*&lt;span&gt;ratio)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测分类错误计数&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     errorCount = 0.0
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(testDataNum):
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出测试数据集每行预测分类&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         classifierResult =&lt;span&gt; classify(normDataMat[i, :], normDataMat[testDataNum:m, :], labelList[testDataNum:m], k)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the classifier result is: %d, the real answer is: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt; (classifierResult, labelList[i]))
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;统计错误预测分类&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(classifierResult !=&lt;span&gt; labelList[i]):
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             errorCount += 1.0
&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the total error count is %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt; errorCount)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the total error rate is: %f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(errorCount/&lt;span&gt;float(testDataNum)))
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制散点图&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; drawScatter(filename):
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载文件，分离特征数据集和标签数据集&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;     dataMat, labelList =&lt;span&gt; loadDataSet(filename)
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;矩阵转化为数组&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;     dataArr =&lt;span&gt; dataMat.A
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一副图画&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;    plt.figure()
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存标签类型相同的索引值（观察标签数据集，有3种不同类型）&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;     label_idx1 = []; label_idx2 = []; label_idx3 =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历标签数组，索引，值&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; index, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(labelList):
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(value == 1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;            label_idx1.append(index)
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt;(value == 2&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;            label_idx2.append(index)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            label_idx3.append(index)
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;scatter(x,y,s,maker,color,label)&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;x,y必须是数组类型，s表示形状大小，maker:形状&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;     plt.scatter(dataArr[label_idx1, 1], dataArr[label_idx1, 2], marker = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, color = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;no like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, s = 30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     plt.scatter(dataArr[label_idx2, 1], dataArr[label_idx2, 2], marker = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, color = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, s = 50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;     plt.scatter(dataArr[label_idx3, 1], dataArr[label_idx3, 2], marker = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, color = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;very like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, s = 15&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;     plt.legend(loc = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;upper right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         
&lt;span&gt;144&lt;/span&gt;         
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Sep 2018 15:09:00 +0000</pubDate>
<dc:creator>w_x_w1985</dc:creator>
<og:description>KNN原理与代码实现 本文系作者原创，转载请注明出处:https://www.cnblogs.com/further-further-further/p/9670187.html 1. KNN原理 K</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/further-further-further/p/9670187.html</dc:identifier>
</item>
<item>
<title>使用Dapper处理多个结果集和多重映射的教程 - 省厓</title>
<link>http://www.cnblogs.com/shengya/p/9671932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shengya/p/9671932.html</guid>
<description>&lt;p&gt;在本文中，我们将介绍如何使用DAPPER从单个数据库调用中读取数据库中的多个结果集。我们将看看我们可能希望这样做的场景，以及如何使用它的Query和QueryMultiple方法更简洁地实现这一点。 当我们谈论以数据为中心的应用程序时，可能会出现一些场景，在这些场景中我们可能希望从数据库中检索多重结果。多个结果集既可以是相关的，也可以是无关的。要做到这一点，我们不需要对数据库进行多次往返，而是可以在一次数据库调用本身中实际使用dapper检索结果，然后将结果映射到代码中的所需对象。 在我们继续并开始研究如何做到这一点之前，让我们首先试着理解在我们的应用程序中可能希望做到这一点的场景： &lt;strong&gt;1、查询无关实体：&lt;/strong&gt;所请求的实体根本不相关。 2、&lt;strong&gt;查询具有1至多个关系的相关实体：&lt;/strong&gt;被请求的实体具有1对多的关系，我们需要在代码中处理多个结果集 &lt;strong&gt;3、查询具有1至1关系的相关实体：&lt;/strong&gt;被请求的实体具有1-1关系，我们需要在代码中执行处理多个映射 在第一个场景中，我们有完全不相关的实体，因此基本上，我们只想执行两个独立的查询来检索数据，然后将其映射到这些实体。在第二个场景中，返回的实体与1-多相关，因此我们希望检索数据，然后将结果映射到具有1至多个关系的POCO中。最后，在第三个场景中，返回的实体是1-1，因此我们希望检索数据，然后将结果映射到具有1-1关系的POCO中。 现在让我们看看一些代码，了解如何使用Dapper来实现这一切。 所有这些都可以通过DAPPER的查询、QueryMultiple和Read方法进行归档。现在让我们把重点放在如何在代码中执行这些操作。&lt;/p&gt;

&lt;p&gt;假设我们想从API中检索书籍和视频列表。我们可以通过两个简单的选择所有查询来实现这一点，数据库结果看起来如下： &lt;img src=&quot;https://www.codeproject.com/KB/library/1260540/DBResults1.PNG&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.codeproject.com/KB/library/1260540/DBResults1.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，为了能够从代码中执行同样的操作，我们首先需要定义我们的实体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; BookName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ISBN { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Video
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; VideoName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这些模型，让我们看看如何只使用一个数据库调用来使用DAPPER检索这些结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; define our SQL query - it contains mulitple queries seprated by ;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; query = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * from Books; Select * from Videos&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Execute the query&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; results =&lt;span&gt; dbConnection.QueryMultiple(query);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; retrieve the results into the respective models&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; books = results.Read&amp;lt;Book&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; videos = results.Read&amp;lt;Video&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; { Books = books, Videos =&lt;span&gt; videos});
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们在POSTMAN中运行，以查看行动中的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918223359956-1109966857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：我已经创建了一个简单的API控制器来测试这个代码，所有的DB访问代码都在里面运行。这只是为了演示目的和现实世界的应用，这样的代码根本不应该被使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询具有1到多关系的查询相关实体&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 检索相关实体的另一个典型场景是实体之间存在一对多关系。让我们尝试使用组织和联系人的例子来可视化这一点。组织通常具有与其关联的多个联系人。如果我们想要检索一个组织，并且想要检索所有关联的联系人，我们可以利用QueryMultiple来做到这一点。这就是关系在数据库中的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918223714021-1402598326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先让我们检查一下如何使用SQL查询做同样的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918223803839-900493122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，如果我们必须在代码中做同样的事情，我们首先需要定义我们的实体。请注意，我们的实体也将建模一对多关系的方式，每个组织有一个联系人列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Organization
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; OrganizationName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;contact&amp;gt; Contacts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Contact
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OrganizationId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ContactName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}
&lt;/span&gt;&amp;lt;/contact&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们看一下用于检索这些相关实体的代码，并了解如何用dapper的QueryMultiple方法填充与1到多个关系相关的实体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult GetOrganization(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; define our SQL query - it contains mulitple queries seprated by ;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; query = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT* from Organizations where id = @id;
                Select * from Contacts where OrganizationId = @id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Execute the query&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; results = dbConnection.QueryMultiple(query, &lt;span&gt;new&lt;/span&gt; { @id =&lt;span&gt; id });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; retrieve the results into the respective models&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; org = results.ReadSingle&amp;lt;Organization&amp;gt;&lt;span&gt;();
    org.Contacts &lt;/span&gt;= results.Read&amp;lt;Contact&amp;gt;&lt;span&gt;().ToList();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(org);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们可以看到我们是如何同时执行2个查询的。我们接受了第一个查询结果并填充了我们的组织对象。第二个查询结果作为同一个组织对象的联系人集合被推送。&lt;/p&gt;
&lt;p&gt; 现在让我们在POSTMAN中运行，以查看行动中的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918224046940-2121142997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;具有1到1关系的查询相关实体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前两个场景非常简单，因为它们要求我们编写两个独立的查询，然后独立收集每个查询的结果，以便根据需要创建模型对象。&lt;/p&gt;
&lt;p&gt; 但是有1到1个关系的场景是很棘手的。从数据库的角度来看，我们可以在单个SQL查询本身中检索相关实体，但是随后我们希望将单个结果集映射到代码中的多个对象中。这可以使用在DAPPER中可用的多重映射特征来完成。让我们在一个例子的帮助下理解这一点。&lt;/p&gt;
&lt;p&gt; 注意：我们仍然可以使用与1到许多关系相同的方法来检索与1到1相关的数据，但是本节将展示如何使用单个SQL并映射结果。&lt;/p&gt;
&lt;p&gt; 让我们举一个联系和护照的例子。每个联系人只能有一个护照。让我们先想象一下这个数据库关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918224313493-1076495498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，让我们看看是否需要从数据库中检索联系人列表及其护照信息，我们如何用SQL实现这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918231639042-860546003.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在让我们看看我们的实体如何寻找联系和护照。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Contact
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OrganizationId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ContactName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Passport Passport { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Passport
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Contactid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PassportNumber { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们看看如何从数据库中检索这些相关实体，并使用更简洁的多重映射完整地填充具有相同关系的POCOs。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult GetContact(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; query = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Select
                c.ID, c.Organizationid, c.ContactName,
                p.ID as PassPortId, p.ContactId, p.PassportNumber
                from Contacts c,
                Passports p
                where c.ID = p.ContactID
                and c.id = @id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Execute the query&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; contact = dbConnection.Query&amp;lt;Contact, Passport, Contact&amp;gt;(query, MapResults, &lt;span&gt;new&lt;/span&gt; { @id = id }, splitOn: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PassportId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(contact);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Contact MapResults(Contact contact, Passport passport)
{
    contact.Passport &lt;/span&gt;=&lt;span&gt; passport;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; contact;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们使用的是查询方法的重载版本，它采用多个类型。传递的类型是我们要映射的每个对象的类型参数，最后一个类型参数是表示该查询将返回的对象类型的附加参数。&lt;/p&gt;

&lt;p&gt;因此，在我们的查询中，我们希望将结果映射到类型Contact和Passsport，然后期望结果返回到类型Contact的对象中。&lt;/p&gt;

&lt;p&gt;现在，让我们看看在查询方法中传递的实际参数。&lt;/p&gt;

&lt;p&gt;第一个参数是SQL查询本身。&lt;/p&gt;
&lt;p&gt;第二个参数是映射函数，它将获取结果，将它绑定到相应的类型，然后创建所需的返回类型并返回该返回类型。在我们的代码中，它采用Contact和Passport类型，并将Contact的Passport属性指定为正在传递的Passport值。一旦这样做，结果接触类型返回。&lt;/p&gt;
&lt;p&gt;第三个参数是命令参数@ id。&lt;/p&gt;
&lt;p&gt;最后一个参数拆分是将告诉DAPPER哪些列必须映射到下一个对象的列名。在我们的示例中，我们将此值作为PassportId传递，这意味着在找到PassportId列之前，所有列都将映射到第一种类型，即Contact，然后随后的列将被映射到下一个参数类型，即Passport。&lt;/p&gt;
&lt;p&gt;注意：如果我们有2个以上的对象需要映射，splitOn将是一个逗号分隔的列表，其中每个列名将充当分隔符，并开始下一个对象类型的映射列。&lt;/p&gt;

&lt;p&gt;现在让我们在POSTMAN中运行，以查看行动中的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918231944055-765209209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欧了，我们使用DAPPER从数据库中检索多个结果集，以避免数据库往返。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在本文中，我们讨论了如何使用dapper提供的特性在一次运行中检索多个相关或无关的实体，从而避免多次数据库往返。这是从初学者的角度写的。我希望这有一定的信息性。&lt;/p&gt;

</description>
<pubDate>Tue, 18 Sep 2018 14:48:00 +0000</pubDate>
<dc:creator>省厓</dc:creator>
<og:description>在本文中，我们将介绍如何使用DAPPER从单个数据库调用中读取数据库中的多个结果集。我们将看看我们可能希望这样做的场景，以及如何使用它的Query和QueryMultiple方法更简洁地实现这一点。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shengya/p/9671932.html</dc:identifier>
</item>
<item>
<title>node.js环境搭建超详细图文教程 - javaa</title>
<link>http://www.cnblogs.com/javaa/p/9671892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaa/p/9671892.html</guid>
<description>&lt;p&gt;身为一名Java开发者对前端充满无限的好奇，于是开始踏入前端的领地。要想先学习，搭建环境是必备，所以整理一篇node.js环境搭建教程。&lt;/p&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;Node.js 是一个让 JavaScript 运行在服务端的开发平台&lt;br/&gt;官网&lt;a href=&quot;https://nodejs.org/&quot; class=&quot;uri&quot;&gt;https://nodejs.org&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;1.3953488372093&quot;&gt;
&lt;p&gt;下载地址&lt;a href=&quot;https://nodejs.org/en/download/&quot; class=&quot;uri&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-07a773d6e44f4f79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;node.js下载&quot;/&gt;&lt;br/&gt;本次下载&lt;strong&gt;LTS长期支持版&lt;/strong&gt;,&lt;strong&gt;.zip解压版本&lt;/strong&gt;(当然也可以使用安装版.msi),点击右侧[64-bit]即可下载.&lt;/p&gt;

&lt;p&gt;解压到自己所要存放的文件夹中，如图：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-a8ab5587367eb618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;解压完成后会有&lt;strong&gt;node-v8.12.0-win-x64&lt;/strong&gt;文件夹&lt;/p&gt;

&lt;p&gt;[我的电脑]-右键-&amp;gt;[属性]-左侧-&amp;gt;[高级系统设置]-下侧-&amp;gt;[环境变量]&lt;br/&gt;图示：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-a8d8c6eac1cb4106.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;[我的电脑]-右键-&amp;gt;[属性]&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-c65d96aec32364f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;左侧-&amp;gt;[高级系统设置]&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-ef13dd8aef8c667c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;下侧-&amp;gt;[环境变量]&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-584993ebcbc349de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;环境变量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要在cmd黑窗口中使用node命令，需要在path中加入node安装路径，点击&lt;strong&gt;编辑&lt;/strong&gt;按钮，新增node安装路径。&lt;br/&gt;以下是win10的界面，点击&lt;strong&gt;编辑文本&lt;/strong&gt;按钮即可切换至和win7一样的界面。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-f2773e0ca669a658.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;新增path&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-1a7d38da8708e20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;加入node路径&quot;/&gt;&lt;br/&gt;&lt;strong&gt;D:\aqqaz\dev\node\node-v8.12.0-win-x64&lt;/strong&gt; 是我的安装目录，请换成自己的目录&lt;strong&gt;！！！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者 在编辑框中加上,对应自己的node路径&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;;D:\aqqaz\dev\Java\jdk1.8.0_181\bin;&lt;br/&gt;这样node.js基本环境就配置完成&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;快捷键win+R,输入cmd,点击确定按钮&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-65ae5b6720f57266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;快捷键win+R&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-0290825bbfd23d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;测试node环境&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入node -v&lt;br/&gt;返回node版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入npm -v&lt;br/&gt;返回npm版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示环境变量配置成功&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;此处主要配置的是npm安装的全局模块所在的路径和缓存cache的路径，因为在以后使用node.js的时候会经常使用nmp命令来下载包,比如&lt;strong&gt;npm install express [-g]&lt;/strong&gt; （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，占C盘空间.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在安装node的目录下,node-v8.12.0-win-x64下新建文件夹&lt;strong&gt;node_cache&lt;/strong&gt;和&lt;strong&gt;node_global&lt;/strong&gt;&lt;br/&gt;node_cache存放缓存,node_global下载的包&lt;br/&gt;如图&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-0c6309c80a7d550e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;新建文件夹node_cache和node_global&quot;/&gt;&lt;br/&gt;然后，在node中设置，win+R 运行cmd，进入黑窗口。&lt;br/&gt;输入&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;npm config set prefix &quot;D:\aqqaz\dev\node\node-v8.12.0-win-x64\node_global&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回车&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;npm config set cache &quot;D:\aqqaz\dev\node\node-v8.12.0-win-x64\node_cache&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;D:\aqqaz\dev\node\node-v8.12.0-win-x64&lt;/strong&gt; 是我的安装目录，请换成自己的目录&lt;strong&gt;！！！！！！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-a3b3ac40e9165035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;node中设置路径&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在环境变量中新建，添加&lt;strong&gt;变量名&lt;/strong&gt;【NODE_PATH】，变量值【D:\aqqaz\dev\node\node-v8.12.0-win-x64\node_global\node_modules】，确定&lt;br/&gt;&lt;strong&gt;D:\aqqaz\dev\node\node-v8.12.0-win-x64&lt;/strong&gt; 是我的安装目录，请换成自己的目录&lt;strong&gt;！！！！！！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-528e509114626296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;添加NODE_PATH环境变量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在【Path】中新增D:\aqqaz\dev\node\node-v8.12.0-win-x64\node_global&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-69875f14bca7a359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;33.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用nmp下载包的时候，很多包都是国外的，所以配置镜像会比较快，&lt;/p&gt;
&lt;blockquote readability=&quot;5.0386473429952&quot;&gt;
&lt;p&gt;查看当前使用的镜像地址，在黑窗口输入npm get registry&lt;br/&gt;返回&amp;gt; &lt;a href=&quot;https://registry.npmjs.org/&quot; class=&quot;uri&quot;&gt;https://registry.npmjs.org/&lt;/a&gt;&lt;br/&gt;更换成阿里的镜像，在黑窗口输入npm config set registry &lt;a href=&quot;http://registry.npm.taobao.org/&quot; class=&quot;uri&quot;&gt;http://registry.npm.taobao.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如图&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-7a6170cf96693451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;更换淘宝镜像&quot;/&gt;&lt;/p&gt;

&lt;p&gt;安装个module测试下，我们就安装最常用的express模块，打开cmd窗口，&lt;br/&gt;输入如下命令进行模块的全局安装：&lt;br/&gt;npm install express -g # -g是全局安装的意思&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-8a22330b33905d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;安装最常用的express模块&quot;/&gt;&lt;br/&gt;安装成功&lt;br/&gt;D:\aqqaz\dev\node\node-v8.12.0-win-x64\node_global\node_modules目录下会出现express文件夹&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2219101-0e21b19c72c40f33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;express&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 14:39:00 +0000</pubDate>
<dc:creator>javaa</dc:creator>
<og:description>身为一名Java开发者对前端充满无限的好奇，于是开始踏入前端的领地。要想先学习，搭建环境是必备，所以整理一篇node.js环境搭建教程。 Node.js 是一个让 JavaScript 运行在服务端的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/javaa/p/9671892.html</dc:identifier>
</item>
<item>
<title>Java 反射机制 - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/9650710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/9650710.html</guid>
<description>&lt;h2&gt;一、概念&lt;/h2&gt;
&lt;p&gt;    Java 反射（Reflection）就是 Java 程序在运行时可以加载一个才知道类名的类，获得类的完整构造方法，并实例化出对象，给对象属性设定值或者调用对象的方法。这种在运行时动态获取类的信息以及动态调用对象的方法的功能称为 Java 的反射机制。&lt;/p&gt;
&lt;h2&gt;二、Class 类&lt;/h2&gt;
&lt;p&gt;    Class 类继承自 Object 类，是 Java 反射机制的入口，封装了一个类或接口的运行时信息，通过调用 Class 类的方法可以获取到这些信息。怎么理解这个 Class 类呢？如果说普通类是所有对象方法、属性的集合，那就可以把这个 Class 类理解成是所有普通类的集合。&lt;/p&gt;
&lt;p&gt;    下面列举了获取 Class 类的几种方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、 Class.forName();&lt;/span&gt;
        Class&amp;lt;?&amp;gt; aClass0 = Class.forName(&quot;java.lang.Object&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、类名.Class&lt;/span&gt;
        Class&amp;lt;Integer&amp;gt; aClass1 = Integer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、包装类.TYPE —— 返回基本类型的 Class 引用，基本类型在虚拟机运行时就已经加载了它的Class&lt;/span&gt;
        Class&amp;lt;Integer&amp;gt; aClass2 =&lt;span&gt; Integer.TYPE;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、对象名.getClass()&lt;/span&gt;
        String str = &quot;Hello, World&quot;&lt;span&gt;;
        Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; String&amp;gt; aClass3 =&lt;span&gt; str.getClass();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5、Class类.getSuperClass() —— 获得父类的 Class 对象&lt;/span&gt;
        Class&amp;lt;?&amp;gt; aClass4 =&lt;span&gt; aClass3.getSuperclass();

        System.out.println(aClass0.getName());
        System.out.println(aClass1.getName());
        System.out.println(aClass2.getName());
        System.out.println(aClass3.getName());
        System.out.println(aClass4.getName());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、获取类信息&lt;/h2&gt;
&lt;p&gt;    为了测试 Java 的反射机制，我新建了一对父子类，其中涵盖了四种封装属性，以尽可能的测试多种类信息的获取：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('57e0eb81-e44d-4451-b09e-5413b5eea749')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_57e0eb81-e44d-4451-b09e-5413b5eea749&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_57e0eb81-e44d-4451-b09e-5413b5eea749&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('57e0eb81-e44d-4451-b09e-5413b5eea749',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_57e0eb81-e44d-4451-b09e-5413b5eea749&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
vpublic &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Vehicle {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String color;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer seat;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; year;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date createdOn;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getColor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer getSeat() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; seat;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getYear() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; year;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getCreatedOn() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createdOn;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Vehicle.java&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8dbd34af-8bdf-4440-b122-aebad132ce5a')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_8dbd34af-8bdf-4440-b122-aebad132ce5a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8dbd34af-8bdf-4440-b122-aebad132ce5a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8dbd34af-8bdf-4440-b122-aebad132ce5a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8dbd34af-8bdf-4440-b122-aebad132ce5a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Car &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Vehicle {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String brand;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer a;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date updatedOn;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car(){}

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Car(String brand, Integer a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b, Date updatedOn) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.brand =&lt;span&gt; brand;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b =&lt;span&gt; b;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.updatedOn =&lt;span&gt; updatedOn;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getBrand() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; brand;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer getA() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getB() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getUpdatedOn() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; updatedOn;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Car.java&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;    1、获取方法&lt;/h3&gt;
&lt;p&gt;    Class 类对方法的获取主要通过以下两种方式：&lt;/p&gt;
&lt;p&gt;Method[] getMethods() 返回该类或接口的所有可访问公共方法（含继承的公共方法）。&lt;/p&gt;
&lt;p&gt;Method[] getDeclaredMethods() 返回该类或接口的所有方法（不含继承的方法）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMethod {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Class&lt;/span&gt;&amp;lt;Car&amp;gt; carClass = Car.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Method[] methods &lt;/span&gt;=&lt;span&gt; carClass.getMethods();
        Method[] declaredMethods &lt;/span&gt;=&lt;span&gt; carClass.getDeclaredMethods();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (Method method : declaredMethods) {&lt;/span&gt;
            System.out.println(&quot;方法名：&quot; +&lt;span&gt; method.getName());
            System.out.println(&lt;/span&gt;&quot;该方法所在的类或接口：&quot; +&lt;span&gt; method.getDeclaringClass());
            System.out.println(&lt;/span&gt;&quot;该方法的参数列表：&quot; +&lt;span&gt; method.getParameterTypes());
            System.out.println(&lt;/span&gt;&quot;该方法的异常列表：&quot; +&lt;span&gt; method.getExceptionTypes());
            System.out.println(&lt;/span&gt;&quot;该方法的返回值类型：&quot; +&lt;span&gt; method.getReturnType());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;    2、获取属性&lt;/h3&gt;
&lt;p&gt;    Class 类对属性的获取主要通过以下两种方式：&lt;/p&gt;
&lt;p&gt;Field[] getFields() ：存放该类或接口的所有可访问公共属性（含继承的公共属性）。&lt;/p&gt;
&lt;p&gt;Field[] getDeclaredFields()：存放该类或接口的所有属性（不含继承的属性）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestField {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Class&lt;/span&gt;&amp;lt;Car&amp;gt; carClass = Car.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Field[] fields &lt;/span&gt;=&lt;span&gt; carClass.getFields();
        Field[] declaredFields &lt;/span&gt;=&lt;span&gt; carClass.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (Field field : fields) {&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field field : declaredFields) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;属性名称是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; field.getName());
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该属性所在的类或接口是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; field.getDeclaringClass());
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该属性的类型是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; field.getType());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; field.getModifiers() 以整数形式返回由此 Field 对象表示的属性的 Java 访问权限修饰符&lt;/span&gt;
            System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该属性的修饰符是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Modifier.toString(field.getModifiers()));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;    3、获取构造函数&lt;/h3&gt;
&lt;p&gt;     Class 类对构造方法的获取主要通过以下两种方式：&lt;/p&gt;
&lt;p&gt;Constructor&amp;lt;?&amp;gt;[] getConstructors() ：返回该类或接口的所有的公共构造方法&lt;/p&gt;
&lt;p&gt;Constructor&amp;lt;?&amp;gt;[] getDeclaredConstructors()：返回该类或接口的所有构造方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestConstructor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException {
        Class&lt;/span&gt;&amp;lt;Car&amp;gt; carClass = Car.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Constructor&lt;/span&gt;&amp;lt;?&amp;gt;[] constructors =&lt;span&gt; carClass.getConstructors();
        Constructor&lt;/span&gt;&amp;lt;?&amp;gt;[] declaredConstructors =&lt;span&gt; carClass.getDeclaredConstructors();
        Constructor&lt;/span&gt;&amp;lt;Car&amp;gt; carConstructor = carClass.getDeclaredConstructor(String.&lt;span&gt;class&lt;/span&gt;, Integer.&lt;span&gt;class&lt;/span&gt;, Integer.TYPE, Date.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (Constructor constructor : declaredConstructors) {&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Constructor constructor : constructors) {
            System.out.println(&lt;/span&gt;&quot;该构造器的名称是：&quot; +&lt;span&gt; constructor.getName());
            System.out.println(&lt;/span&gt;&quot;该构造器所在的类或接口是：&quot; +&lt;span&gt; constructor.getDeclaringClass());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回构造方法的参数类型&lt;/span&gt;
&lt;span&gt;            constructor.getParameterTypes();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、动态调用&lt;/h2&gt;
&lt;p&gt;    到目前为止，我们都是通过 Class 类的方法获取对应类属性、方法和构造函数的详细信息。接下来我们将通过这些信息，来动态创建对象、修改属性和动态调用方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
        Class&lt;/span&gt;&amp;lt;Car&amp;gt; carClass = Car.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、实例化对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 Class 类的newInstance()；要求对应类必须有无参构造函数，相当于 Car car = new Car()&lt;/span&gt;
        Car car =&lt;span&gt; carClass.newInstance();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用构造器的newInstance(Object ... initargs);&lt;/span&gt;
        Constructor&amp;lt;Car&amp;gt; declaredConstructor = carClass.getDeclaredConstructor(String.&lt;span&gt;class&lt;/span&gt;, Integer.&lt;span&gt;class&lt;/span&gt;, Integer.TYPE, Date.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消访问权限控制，即使是 private 权限也可以访问&lt;/span&gt;
        declaredConstructor.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        Car car1 &lt;/span&gt;= declaredConstructor.newInstance(&quot;brand&quot;, 21, 21, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        System.out.println(car1.getUpdatedOn());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、修改属性&lt;/span&gt;
        Field brand = carClass.getDeclaredField(&quot;brand&quot;&lt;span&gt;);
        brand.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;取消访问权限控制后的值：&quot; +&lt;span&gt; brand.get(car1));
        brand.set(car1, &lt;/span&gt;&quot;dnarb&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;修改属性后的值是：&quot; +&lt;span&gt; brand.get(car1));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、调用方法&lt;/span&gt;
        Method getBrand = carClass.getDeclaredMethod(&quot;getBrand&quot;&lt;span&gt;);
        getBrand.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;调用反射方法得到的值是：&quot; +&lt;span&gt; getBrand.invoke(car1));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 18 Sep 2018 13:43:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<og:description>一、概念 Java 反射（Reflection）就是 Java 程序在运行时可以加载一个才知道类名的类，获得类的完整构造方法，并实例化出对象，给对象属性设定值或者调用对象的方法。这种在运行时动态获取类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/9650710.html</dc:identifier>
</item>
<item>
<title>.NET Core中的性能测试工具BenchmarkDotnet - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9671611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9671611.html</guid>
<description>&lt;p&gt;之前一篇博客中，我们讲解&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/9639456.html&quot;&gt;.NET Core中的CSV解析库&lt;/a&gt;，在文章的最后，作者使用了性能基准测试工具BenchmarkDotNet测试了2个不同CSV解析库的性能，本篇我们来详细介绍一下BenchmarkDotNet。&lt;/p&gt;
&lt;blockquote readability=&quot;0.89108910891089&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://dotnetcoretutorials.com/2017/12/04/benchmarking-net-core-code-benchmarkdotnet/&quot; class=&quot;uri&quot;&gt;https://dotnetcoretutorials.com/2017/12/04/benchmarking-net-core-code-benchmarkdotnet/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么需要性能基准测试&quot;&gt;为什么需要性能基准测试?&lt;/h2&gt;
&lt;p&gt;性能基准测试可以帮助程序员对比2个代码段或者方法的性能，这对于代码重写或者重构来说，可以提供一种很好的量化标准。如果没有性能基准测试，很难想象将方法A改为B方法时候，仅凭肉眼如何区分性能的变化。&lt;/p&gt;
&lt;h2 id=&quot;benchmarkdotnet&quot;&gt;BenchmarkDotNet&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180918213719984-897319236.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BenchmarkDotNet是一款强力的.NET性能基准测试库, 官网https://benchmarkdotnet.org/。&lt;/p&gt;
&lt;p&gt;运行时支持&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NET Framework (4.6+),&lt;/li&gt;
&lt;li&gt;.NET Core (2.0+)&lt;/li&gt;
&lt;li&gt;Mono&lt;/li&gt;
&lt;li&gt;CoreRT。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BenchmarkDotnet为每个被测试的方法提供了孤立的环境, 使用BenchmarkDotnet, 程序员可以很容易的编写各种性能测试方法，并可以避免许多常见的坑。&lt;/p&gt;
&lt;h2 id=&quot;代码基准测试code-benchmarking&quot;&gt;代码基准测试(Code Benchmarking)&lt;/h2&gt;
&lt;p&gt;现在我们希望来对比一下Linq to object中First和Single方法的性能&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;虽然我们知道First的性能肯定比Single高, First方法会在查询到第一个满足条件的对象之后就停止集合遍历，而Single找到第一个满足条件的对象之后，不会停止查找，它会去继续查找集合中的剩余对象，直到遍历整个集合或者在集合中找到第二个匹配条件的对象。 这里我们只是为了演示一下如何进行代码基准测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了使用BenchmarkDotNet来进行代码基准测试，我们首先创建一个空的.Net Core控制台程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180918213733352-132878750.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们使用Package Manage Console添加BenchmarkDotNet库&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM&amp;gt; Install-Package BenchmarkDotNet&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们修改Program.cs文件, 代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Program
    {
        public class SingleVsFirst
        {
            private readonly List&amp;lt;string&amp;gt; _haystack = new List&amp;lt;string&amp;gt;();
            private readonly int _haystackSize = 1000000;
            private readonly string _needle = &quot;needle&quot;;

            public SingleVsFirst()
            {
                //Add a large amount of items to our list. 
                Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&amp;gt; _haystack.Add(x.ToString()));
                //Insert the needle right in the middle. 
                _haystack.Insert(_haystackSize / 2, _needle);
            }

            [Benchmark]
            public string Single() =&amp;gt; _haystack.SingleOrDefault(x =&amp;gt; x == _needle);

            [Benchmark]
            public string First() =&amp;gt; _haystack.FirstOrDefault(x =&amp;gt; x == _needle);

        }

        public static void Main(string[] args)
        {
            var summary = BenchmarkRunner.Run&amp;lt;SingleVsFirst&amp;gt;();
            Console.ReadLine();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码解释说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上代码中&lt;code&gt;SingleVsFirst&lt;/code&gt;类是一个测试类。&lt;/li&gt;
&lt;li&gt;测试类中我们生成了一个拥有100万对象的字符串集合。&lt;/li&gt;
&lt;li&gt;我们在集合的中间位置插入了一个测试字符串，字符串的内容是&quot;needle&quot;。&lt;/li&gt;
&lt;li&gt;代码中的&lt;code&gt;Single&lt;/code&gt;和&lt;code&gt;First&lt;/code&gt;方法，分别调用了Linq to object的&lt;code&gt;SingleOrDefault&lt;/code&gt;和&lt;code&gt;FirstOrDefault&lt;/code&gt;方法来查询字符串集合中的&quot;needle&quot;字符串。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Single&lt;/code&gt;和&lt;code&gt;First&lt;/code&gt;方法上，我们加入&lt;code&gt;[Benchmark]&lt;/code&gt;特性, 拥有该特性的方法会出现在最后的基准检测报告中。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试的方法必须是公开的(public), 如果把public去掉，程序不会产生任何结果&lt;/li&gt;
&lt;li&gt;在运行程序之前，还有一步关键的操作，测试的程序需要使用Release模式编译，并且不能附加任何调试器(Debugger)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;最终结果&quot;&gt;最终结果&lt;/h3&gt;
&lt;p&gt;现在我们运行程序，程序产生的最终报告如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Method  |     Mean |     Error |   StdDev |   Median |
------- |---------:|----------:|---------:|---------:|
 Single | 28.12 ms | 0.9347 ms | 2.697 ms | 28.93 ms |
  First | 13.30 ms | 0.8394 ms | 2.475 ms | 14.48 ms |&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果中的第一列Mean表明了2个方法处理的平均响应时间，&lt;code&gt;First&lt;/code&gt;比&lt;code&gt;Single&lt;/code&gt;快了一倍(这和我们测试字符串放置的位置有关系)。&lt;/p&gt;
&lt;h2 id=&quot;带测试参数的基准测试input-benchmarking&quot;&gt;带测试参数的基准测试(Input Benchmarking)&lt;/h2&gt;
&lt;p&gt;BenchmarkDotNet中我们还可以使用&lt;code&gt;[ParamsSource]&lt;/code&gt;参数来指定测试的用例范围。&lt;br/&gt;在上面的代码中，我们测试了匹配字符串在集合中间位置时，&lt;code&gt;First&lt;/code&gt;和&lt;code&gt;Single&lt;/code&gt;的效率对比，下面我们修改上面的代码，我们希望分别测试匹配字符串在集合头部，尾部以及中间位置时&lt;code&gt;First&lt;/code&gt;和&lt;code&gt;Single&lt;/code&gt;的效率对比。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
using System;
using System.Collections.Generic;
using System.Linq;
 
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
 
namespace BenchmarkExample
{
    public class SingleVsFirst
    {
        private readonly List&amp;lt;string&amp;gt; _haystack = new List&amp;lt;string&amp;gt;();
        private readonly int _haystackSize = 1000000;
 
        public List&amp;lt;string&amp;gt; _needles =&amp;gt; new List&amp;lt;string&amp;gt; { &quot;StartNeedle&quot;, &quot;MiddleNeedle&quot;, &quot;EndNeedle&quot; };
 
        public SingleVsFirst()
        {
            //Add a large amount of items to our list. 
            Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&amp;gt; _haystack.Add(x.ToString()));
 
            //One at the start. 
            _haystack.Insert(0, _needles[0]);
            //One right in the middle. 
            _haystack.Insert(_haystackSize / 2, _needles[1]);
            //One at the end. 
            _haystack.Insert(_haystack.Count - 1, _needles[2]);
        }
 
        [ParamsSource(nameof(_needles))]
        public string Needle { get; set; }
 
        [Benchmark]
        public string Single() =&amp;gt; _haystack.SingleOrDefault(x =&amp;gt; x == Needle);
 
        [Benchmark]
        public string First() =&amp;gt; _haystack.FirstOrDefault(x =&amp;gt; x == Needle);
 
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            var summary = BenchmarkRunner.Run&amp;lt;SingleVsFirst&amp;gt;();
            Console.ReadLine();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码解释说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们创建了测试的用例字符串集合&lt;code&gt;_needles&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在构造函数中，我们在字符串集合的头部，中部，尾部分别插入了3个字符串&lt;/li&gt;
&lt;li&gt;我们添加了一个属性&lt;code&gt;Needle&lt;/code&gt;, 表示当前测试的用例，在被测试&lt;code&gt;Single&lt;/code&gt;和&lt;code&gt;First&lt;/code&gt;方法中，我们使用属性&lt;code&gt;Needle&lt;/code&gt;来匹配&lt;/li&gt;
&lt;li&gt;在属性Needle上我们加上了参数来源特性&lt;code&gt;[ParamsSource]&lt;/code&gt;, 并设置参数来源是&lt;code&gt;_needles&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最终效果&quot;&gt;最终效果&lt;/h3&gt;
&lt;p&gt;现在我们运行程序，程序产生的最终报告如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Method |       Needle |             Mean |          Error |           StdDev |           Median |
------- |------------- |-----------------:|---------------:|-----------------:|-----------------:|
 Single |    EndNeedle | 23,266,757.53 ns | 432,206.593 ns |   591,609.263 ns | 23,236,343.07 ns |
  First |    EndNeedle | 24,984,621.12 ns | 494,223.345 ns |   783,890.599 ns | 24,936,945.21 ns |
 Single | MiddleNeedle | 21,379,814.14 ns | 806,253.579 ns | 2,377,256.870 ns | 22,436,101.14 ns |
  First | MiddleNeedle | 11,984,519.09 ns | 315,184.021 ns |   924,380.173 ns | 12,233,700.94 ns |
 Single |  StartNeedle | 23,650,243.23 ns | 599,968.173 ns |   714,219.431 ns | 23,555,402.19 ns |
  First |  StartNeedle |         89.17 ns |       1.864 ns |         2.732 ns |         89.07 ns&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果上看&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当匹配字符串在集合头部的时候，&lt;code&gt;First&lt;/code&gt;性能比&lt;code&gt;Single&lt;/code&gt;高的多&lt;/li&gt;
&lt;li&gt;当匹配字符串在集合中部的时候，&lt;code&gt;First&lt;/code&gt;性能是比&lt;code&gt;Single&lt;/code&gt;的一倍&lt;/li&gt;
&lt;li&gt;当匹配字符串在集合尾部的时候，&lt;code&gt;First&lt;/code&gt;和比&lt;code&gt;Single&lt;/code&gt;的性能差不多&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;加入内存测试&quot;&gt;加入内存测试&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/9639456.html&quot;&gt;.NET Core中的CSV解析库&lt;/a&gt;中，我们使用了以下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [MemoryDiagnoser]
    public class CsvBenchmarking
    {
        [Benchmark(Baseline =true)]
        public IEnumerable&amp;lt;Automobile&amp;gt; CSVHelper()
        {
            TextReader reader = new StreamReader(&quot;import.txt&quot;);
            var csvReader = new CsvReader(reader);
            var records = csvReader.GetRecords&amp;lt;Automobile&amp;gt;();
            return records.ToList();
        }
     
        [Benchmark]
        public IEnumerable&amp;lt;Automobile&amp;gt; TinyCsvParser()
        {
            CsvParserOptions csvParserOptions = new CsvParserOptions(true, ',');
            var csvParser = new CsvParser&amp;lt;Automobile&amp;gt;(csvParserOptions, new CsvAutomobileMapping());
     
            var records = csvParser.ReadFromFile(&quot;import.txt&quot;, Encoding.UTF8);
     
            return records.Select(x =&amp;gt; x.Result).ToList();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中除了[Benchmark]特性，我们还在测试类&lt;code&gt;CsvBenchmarking&lt;/code&gt;上添加了&lt;code&gt;[MemoryDiagnoser]&lt;/code&gt;特性，该特性会在测试报告中追加，2个方法执行时的内存使用情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        Method |       Mean | Scaled | Allocated |
-------------- |-----------:|-------:|----------:|
     CSVHelper | 1,404.5 ms |   1.00 | 244.39 MB |
 TinyCsvParser |   381.6 ms |   0.27 |  32.53 MB |&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中Allocated表明了内存占用情况。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;BenchmarkDotNet绝对是.NET开发人员了解代码性能，以及对比代码性能的必备神器。你的项目里用了BenchmarkDotnet了么？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/lwqlun/BenchmarkSample.zip&quot;&gt;本文源代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 13:39:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>背景介绍 之前一篇博客中，我们讲解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9671611.html</dc:identifier>
</item>
<item>
<title>CPU与GPU性能的比较报告 - 侯凯</title>
<link>http://www.cnblogs.com/houkai/p/9671543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/houkai/p/9671543.html</guid>
<description>&lt;p&gt;不同的模型在cpu和gpu下的时间差异较大，一般来说gpu会比cpu快5-20倍。我们选用了最常用的inception v3的分类模型，输入图片尺寸为：3x299x299。&lt;/p&gt;
&lt;h2 id=&quot;gpu&quot;&gt;GPU&lt;/h2&gt;
&lt;p&gt;在一块P100GPU（显存16276MiB），性能如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/gpu.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可见，随着进程数目的增大耗时会线性增加。&lt;/p&gt;
&lt;p&gt;所以：如果服务中在同个卡上多开进程只是服务连接/下载图片的并发实现了并发提速（neuron框架中连接建立、下载图片、算法处理是并发独立的，可近似认为互不影响）；&lt;strong&gt;算法的吞吐量基本不变&lt;/strong&gt;。而且从RT角度考虑单进程较好独占卡（任务可以占据Volatile GPU-Util 90%左右的情况下）。&lt;/p&gt;
&lt;p&gt;当然，如果RT满足要求，卡上可以同时部署其他任务。&lt;/p&gt;
&lt;h2 id=&quot;cpu&quot;&gt;CPU&lt;/h2&gt;
&lt;p&gt;Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz 24核服务器下。TF默认为尽可能的占用所有的核，真正的neuron服务也是尽可能的占用所有的核，所以请求量大的时候RT会上升。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/cpu.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;24核服务器下，QPS呈现log趋势。&lt;strong&gt;考虑RT，算法可以开启10个进程较优&lt;/strong&gt;。此时CPU使用率已经逼近2400%。当然&lt;strong&gt;如果RT有限制，则采用更小的并发/更多的机器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PS：一个进程下CPU占用率1600% 2个并发2000% 3个并发2100% 4个并发2200% 5个并发2250% 6个并发已达2280%。&lt;/p&gt;
&lt;h2 id=&quot;cpu-more&quot;&gt;CPU more&lt;/h2&gt;
&lt;p&gt;从另个角度来看，通过改变进程使用的核数统计RT值。这部分和前面CPU部分很类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/%E5%8D%95%E8%BF%9B%E7%A8%8Bcpu.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这个分类任务，10核以后性能基本不会提升了（并发就到这水平了）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果要保证一定的RT，就要保证每个请求可以拿到足够多的核&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;单GPU QPS可以达到55；24核CPU的QPS可以达到24左右。但是GPU的TR要远低于CPU，不过GPU并发数上来，RT也会线性增加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照目前线上一个GPU的成本约等于96个CPU核，CPU性价比还是远优于GPU的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PS:评测中P100性能较好价格较贵、CPU E5-2620已经较为(古老)便宜了。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 13:25:00 +0000</pubDate>
<dc:creator>侯凯</dc:creator>
<og:description>不同的模型在cpu和gpu下的时间差异较大，一般来说gpu会比cpu快5-20倍。我们选用了最常用的inception v3的分类模型，输入图片尺寸为：3x299x299。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/houkai/p/9671543.html</dc:identifier>
</item>
<item>
<title>从零开始搭建django前后端分离项目 系列一（技术选型） - 杰哥要增肥</title>
<link>http://www.cnblogs.com/dotafeiying/p/9663514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotafeiying/p/9663514.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近公司要求基于公司的hadoop平台做一个关于电信移动网络的数据分析平台，整个项目需求大体分为四大功能模块：数据挖掘分析、报表数据查询、GIS地理化展示、任务监控管理。由于页面功能较复杂，所以采用前后端分离方式开发。前端采用webpack+vue+vue-router+axios技术栈，后端用django进行开发。从搭建到上线，整个项目前前后后花了差不多一个月时间，中途也遇到一些问题，不过还好都解决了。由于是个人项目，所以我打算把源码贡献出来大家一起讨论学习。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;源代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;github代码&quot; href=&quot;https://github.com/dotafeiying/myproject&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/dotafeiying/myproject&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于技术选型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于页面交互较多，所以整个项目采用前后端分离方式开发。使用Vue.js作为前端框架，代替Django本身较为孱弱的模板引擎，Django则作为服务端提供api接口，使得前后端实现完全分离，更适合单页应用的开发构建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前端：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;webpack + vue + axios + element-ui + iview + zui + jquery&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后端：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;django + celery&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql + redis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;impala + pandas + sklearn&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;项目目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918125156414-1206912602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918124843978-1133285045.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;实现的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、文件上传预览&lt;/p&gt;
&lt;p&gt;2、异步任务执行&lt;/p&gt;
&lt;p&gt;3、websocket实现实时进度&lt;/p&gt;
&lt;p&gt;4、表格分页&lt;/p&gt;
&lt;p&gt;5、excel文件动态导出&lt;/p&gt;
&lt;p&gt;6、pandas数据分析&lt;/p&gt;
&lt;p&gt;7、impala大数据实时查询分析&lt;/p&gt;
&lt;p&gt;8、KMeans、DBSCAN聚类分析&lt;/p&gt;
&lt;p&gt;9、距离计算算法优化&lt;/p&gt;
&lt;p&gt;10、GIS地图展示&lt;/p&gt;
&lt;p&gt;11、websocket实现实时进度和动态渲染&lt;/p&gt;
&lt;p&gt;12、百度地图批量经纬度转换（服务端实现）&lt;/p&gt;
&lt;p&gt;13、历史数据流式查询，解决数据量过大问题&lt;/p&gt;
&lt;p&gt;14、树组件懒加载，改善用户体验&lt;/p&gt;
&lt;p&gt;15、excel文件流式导出&lt;/p&gt;
&lt;p&gt;16、celery异步任务监控管理，websocket实时监控&lt;/p&gt;
&lt;p&gt;17、django后台管理&lt;/p&gt;
&lt;p&gt;18、项目部署nginx+uwsgi+django+centos7.5&lt;/p&gt;

&lt;p&gt;&lt;span&gt;效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文件上传前进行数据核查和预览&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918115739175-1225582942.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步任务执行和实时进度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918115933271-1296270002.png&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表格分页&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918122815250-303541841.png&quot; alt=&quot;&quot; width=&quot;808&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;海量点聚类分析和GIS展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918122908863-478986450.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;452&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 历史数据流式查询和树节点懒加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918123016200-422558054.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;456&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步任务实时监控和管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1177395/201809/1177395-20180918123106518-957118606.png&quot; alt=&quot;&quot; width=&quot;817&quot; height=&quot;454&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 18 Sep 2018 13:01:00 +0000</pubDate>
<dc:creator>杰哥要增肥</dc:creator>
<og:description>前言 最近公司要求基于公司的hadoop平台做一个关于电信移动网络的数据分析平台，整个项目需求大体分为四大功能模块：数据挖掘分析、报表数据查询、GIS地理化展示、任务监控管理。由于页面功能较复杂，所以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotafeiying/p/9663514.html</dc:identifier>
</item>
<item>
<title>webpack打包nodejs项目（前端代码） - 巽秋</title>
<link>http://www.cnblogs.com/lhyxq/p/9671388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhyxq/p/9671388.html</guid>
<description>&lt;p&gt;首先说明，此情况不具备普遍性。若你的情况与笔者类似那么希望这篇文章能够帮到你。&lt;/p&gt;
&lt;p&gt;我的项目情况是这样的：用node.js做后台，ejs做模板引擎（即整个页面是一个ejs文件）由node.js将数据渲染完成后，再将完整页面返回给用户。&lt;/p&gt;
&lt;p&gt;那么这样做会遇到的问题：&lt;/p&gt;
&lt;p&gt;1. 本项目没有html页面，ejs的作用也不是引入公共的组件，直接就是一个完整的页面，用webpack中处理ejs文件的loader返回的是一个函数，故会产生问题&lt;/p&gt;
&lt;p&gt;2.由于node.js配置了静态资源目录public，而视图目录与之同级，webpack在处理图像等静态资源目录的路径的时候会产生问题&lt;/p&gt;
&lt;p&gt;3.如果使用publicpath 那么nodejs在运行的时候就会找不到资源，因为设置了静态资源的目录&lt;/p&gt;

&lt;p&gt;如果你也遇到了类似的问题，希望你能在本文中找到解决方法。&lt;/p&gt;
&lt;p&gt;这里多说一句：不要觉得我的项目很奇怪，因为我当时写的时候，知识储备不足，等到后面发现不妥的时候，为时已晚。&lt;/p&gt;
&lt;p&gt;改起来太麻烦，所以将错就错了。。。。。。&lt;/p&gt;


&lt;h2&gt;1.处理ejs&lt;/h2&gt;
&lt;p&gt;我在各个论坛，官网搜寻良久，始终没能找到，能处理我这种情况的loader。&lt;/p&gt;
&lt;p&gt;没有办法之下，只能换一个思路，将ejs文件先转为html&lt;/p&gt;

&lt;p&gt;首先要修改文件，那么就要修改服务器的模板引擎（这里是我的app.js）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918203451833-881633992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么要修改成什么呢？我要让nodejs使用ejs模板引擎，但是使用html文件来渲染&lt;/p&gt;
&lt;p&gt;这里我们要用的是express中的app.engine 来注册一个引擎&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
app.set('views',path.join(__dirname,'views'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置模板引擎的目录&lt;/span&gt;
app.engine('html', require('ejs'&lt;span&gt;).renderFile);
app.set(&lt;/span&gt;'view engine','html');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以将原本views视图目录中的ejs文件的后缀修改为.html了&lt;/p&gt;
&lt;h2&gt;2.webpack处理html文件&lt;/h2&gt;
&lt;p&gt;首先引入我眼帘的是webpack插件:HtmlWebpackPlugin&lt;/p&gt;
&lt;p&gt;我找了许多文章，文章中对html文件的处理无一列外都用到了这个插件&lt;/p&gt;
&lt;p&gt;既然那么多人用，那么它的强大是毋庸置疑的。&lt;/p&gt;
&lt;p&gt;但是配置好后运行webpack，报了一个locals未定义的错误&lt;/p&gt;
&lt;p&gt;报错代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918204239527-1771875649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于locals是由express中的res.render（）传回页面的数据，而在此时webpack处理的时候，理所当然的会报未定义的错误了。&lt;/p&gt;
&lt;p&gt;那么这个问题怎么解决呢？&lt;/p&gt;
&lt;p&gt;我现在需要让webpack帮我处理html中的资源，又要让webpack不要理会ejs的语法，帮我继续压缩代码，就陷入了一个十分难受的境地。&lt;/p&gt;
&lt;p&gt;在搜寻良久无果后，一篇误打误撞的文章启发了我&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918204654453-676748211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这篇文章的博主是希望，webpack能够把ejs引入的模板打包到一个页面中，而我恰恰相反，我就是需要webpack不理会我的ejs代码。&lt;/p&gt;
&lt;p&gt;于是解决办法氤氲而生。&lt;/p&gt;
&lt;p&gt;首先我将原本html中的js代码抽离到test.js中&lt;/p&gt;
&lt;p&gt;然后以这个js文件为入口文件，再以原本的html文件为模板&lt;/p&gt;
&lt;p&gt;用HtmlWebpackPlugin来生成我所需要的压缩过后的html&lt;/p&gt;

&lt;p&gt;webpack.config.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;
const path &lt;/span&gt;= require('path'&lt;span&gt;);
const HtmlWebpackPlugin &lt;/span&gt;= require('html-webpack-plugin'&lt;span&gt;);


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包ejs&lt;/span&gt;
&lt;span&gt;
module.exports &lt;/span&gt;=&lt;span&gt; {
  entry: {
    test: &lt;/span&gt;'./test.js',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;入口文件 即一般来说app.js&lt;/span&gt;
&lt;span&gt;  },
  mode:&lt;/span&gt;&quot;production&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产环境&lt;/span&gt;
&lt;span&gt;  output: {
    path: path.resolve(__dirname,&lt;/span&gt;'build'),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出路径&lt;/span&gt;
    filename: 'js/[name]/[name].js'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出后的文件名&lt;/span&gt;
&lt;span&gt;  },
  externals: {
    jquery:&lt;/span&gt;'window.jQuery'&lt;span&gt;
  },&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部加载的资源 这些都是不需要进行打包的&lt;/span&gt;
&lt;span&gt;  module: {
    rules: [&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置处理js文件的loader&lt;/span&gt;
      {test:/\.js$/,use:'babel-loader',exclude:/node_modules/&lt;span&gt;},
      {test:&lt;/span&gt;/\.css$/,use:[&quot;style-loader&quot;,&quot;css-loader&quot;&lt;span&gt;]},
      {
        test: &lt;/span&gt;/\.(png|jpg|gif)$/&lt;span&gt;,
        use: [
          {
            loader: &lt;/span&gt;'file-loader'&lt;span&gt;,
            options: {
              name: &lt;/span&gt;'images/[name].[ext]'&lt;span&gt;
            }
          }
        ]
      },
      {
        test: &lt;/span&gt;/\.(html)$/&lt;span&gt;,
        use: {
          loader: &lt;/span&gt;'html-loader'&lt;span&gt;,
          options: {
            attrs: [&lt;/span&gt;':data-src'&lt;span&gt;]
          }
        }
      }
    ]
  },
  plugins:[
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({
      name:&lt;/span&gt;'test'&lt;span&gt;,
      template:&lt;/span&gt;'./public/init.html',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模板文件&lt;/span&gt;
      filename:'views/test.html',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标文件&lt;/span&gt;
&lt;span&gt;      minify:{
        collapseWhitespace:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        collapseInlineTagWhitespace:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        conservativeCollapse:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        minifyCSS:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        minifyJS: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        removeComments:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        trimCustomFragments:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      }
    })
  ],
  optimization: {
    minimize: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否压缩代码&lt;/span&gt;
&lt;span&gt;  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的minify参数主要是配置html压缩的&lt;/p&gt;
&lt;p&gt;入口文件test.js&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里面没有任何有关webpack的代码，全是项目的业务代码，故在这里就不粘了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;运行webpack 大功告成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918205520219-1249519869.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们来看看打包前后的html&lt;/p&gt;

&lt;p&gt;打包前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918205608201-1044938555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打包后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918205634493-541447395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;大小对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918210548872-2018267502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 启动nodejs服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201809/1467672-20180918205709569-106529069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 问题解决 睡觉咯~~&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 12:59:00 +0000</pubDate>
<dc:creator>巽秋</dc:creator>
<og:description>webpack打包 nodejs + express + ejs 的项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhyxq/p/9671388.html</dc:identifier>
</item>
</channel>
</rss>