<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>责任链模式（Chain Of Responsibility） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9823497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9823497.html</guid>
<description>&lt;h4 id=&quot;chain-of-responsibility&quot;&gt;Chain Of Responsibility？&lt;/h4&gt;
&lt;p&gt;这种情况下，我们可以考虑将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理。&lt;br/&gt;通俗：她告诉我们应该去“营业窗口”。然后等我们到了“营业窗口”后，又被告知应该去“售后部门”。等我们好不容易赶到了“售后部门”，又被告知应该去“资料中心”，因此最后我们又不得不赶往“资料中心”。像这样，在找到合适的办事人之前，我们被不断地踢给一个又一个人，这就是“推卸责任”。&lt;/p&gt;
&lt;h4 id=&quot;理解职责&quot;&gt;理解职责&lt;/h4&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;理解好责任链设计模式关键在于 SolveAnswer是处理者而NoSolve、LimitSolve、OddSolve、SpcialSolve才是具体的处理者。&lt;br/&gt;在SolveAnswer用模版设计的模式定义遇到解决问题的策略办法，能解决就在当前实现的解决方法的子类进行解决，不能解决就在继续向下面的责任类继续传递。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;|名字 +++++++++++++++++++++++++++++++说明&lt;br/&gt;|Question|表示发生的问题的类。它带有问题编号（number）&lt;br/&gt;SolveAnswer用来解决问题的抽象类&lt;br/&gt;NoSolve用来解决问题的具体类（永远“不处理问题”）&lt;br/&gt;LimitSolve用来解决问题的具体类（仅解决编号小于指定编号的问题）&lt;br/&gt;OddSolve|用来解决问题的具体类（仅解决奇数编号的问题）&lt;br/&gt;SpcialSolve用来解决问题的具体类（仅解决指定编号的问题）&lt;br/&gt;MainT 制作SolveAnswer的职责链，制造问题并测试程序行为&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;比较重要的话: &lt;strong&gt;Chain of Responsibility模式的最大优点就在于它弱化了发出请求的人（Client角色）和处理请求的人（ConcreteHandler角色）之间的关系。Client角色向第一个ConcreteHandler角色发出请求，然后请求会在职责链中传播，直到某个ConcreteHandler角色处理该请求。&lt;br/&gt;如果不使用该模式，就必须有某个伟大的角色知道“谁应该处理什么请求”，这有点类似中央集权制。而让“发出请求的人”知道“谁应该处理该请求”并不明智，因为如果发出请求的人不得不知道处理请求的人各自的责任分担情况，就会降低其作为可复用的组件的独立性。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;需要知道的技术点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用Chain of Responsibility模式可以推卸请求，直至找到合适的处理请求的对象，这样确实提高了程序的灵活性，但是会有一定的处理延迟：当然你也可以通过算法来定义处理的特殊路径，但是未免太多余麻烦：所以有的时候我们不如直接显示调用来提高灵活性。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181020233639707-1683296524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181020233642534-1377568772.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Question :&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Question {

    private int question_number;

    public Question(int question_number) {
        this.question_number = question_number;
    }

    public int getQuestion_number() {
        return question_number;
    }

    @Override
    public String toString() {
        return &quot;Question{&quot; +
                &quot;question_number=&quot; + question_number +
                '}';
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;SolveAnswer&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class SolveAnswer {

    private String Solve_Name;

    // 继承链者
    private SolveAnswer next;

    public SolveAnswer(String solve_Name) {
        Solve_Name = solve_Name;
    }

    /**
     * 设置需要推卸责任的对象
     */
    public SolveAnswer setNext(SolveAnswer solveAnswer){
        this.next=solveAnswer;
        return next;
    }

    /**
     * 解决问题的步骤
     */
    public final void support(Question question){
        if(solve(question)){
            finish(question);
        }else if(next!=null){
            this.next.support(question);
        }else{
            fail(question);
        }
    }

    /**
     * 交给子类取解决
     * @param question
     * @return
     */
    protected abstract boolean solve(Question question);

    /**
     *
     * @param question
     */
    private void finish(Question question) {
        System.out.println(question+&quot;能被解决&quot;+this.toString()+&quot;.&quot;);
    }

    /**
     *
     * @param question
     */
    private void fail(Question question) {
        System.out.println(question+&quot;不能被解决.&quot;);
    }

    @Override
    public String toString() {
        return &quot;[&quot;+this.Solve_Name+ &quot;]&quot;;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;NoSolve SpcialSolve OddSolve LimitSolve&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class LimitSolve extends SolveAnswer {

    private int limit;

    public LimitSolve(String solve_Name ,int limit) {
        super(solve_Name);
        this.limit=limit;
    }

    @Override
    public boolean solve(Question question) {

        if(question.getQuestion_number()&amp;lt;limit){
            return true;
        }else{
            return false;
        }

    }
}

public class NoSolve extends SolveAnswer{


    public NoSolve(String solve_Name) {
        super(solve_Name);
    }

    @Override
    public boolean solve(Question question) {
        return false;
    }
}

public class OddSolve extends SolveAnswer {

    public OddSolve(String solve_Name) {
        super(solve_Name);
    }

    @Override
    public boolean solve(Question question) {
        if(question.getQuestion_number()%2==1){
            return  true;
        }else{
            return false;
        }
    }
}

public class SpcialSolve extends SolveAnswer {

    private int special;

    public SpcialSolve(String solve_Name,int specalNum) {
        super(solve_Name);
        this.special=specalNum;
    }

    @Override
    public boolean solve(Question question) {
        if(question.getQuestion_number()==special){
            return true;
        }else {
            return false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;MainT 测试&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class MainT {

    public static void main(String[] args) {

        SolveAnswer tom=new NoSolve(&quot;cat1&quot;);
        SolveAnswer tom2=new LimitSolve(&quot;cat2&quot;,100);
        SolveAnswer tom3=new OddSolve(&quot;cat3&quot;);
        //只能解决225问题
        SolveAnswer tom4=new SpcialSolve(&quot;cat4&quot;,225);

        tom.setNext(tom2).setNext(tom3).setNext(tom4);

        for (int i = 0; i &amp;lt; 300; i+=3) {
                tom.support(new Question(i));
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Oct 2018 15:37:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Chain Of Responsibility？ 这种情况下，我们可以考虑将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理。 通俗：她告诉我们应该去“营业窗口”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9823497.html</dc:identifier>
</item>
<item>
<title>框架设计原则（梁飞） - 莫那-鲁道</title>
<link>http://www.cnblogs.com/stateis0/p/9823450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stateis0/p/9823450.html</guid>
<description>&lt;h2&gt;大纲&lt;/h2&gt;
&lt;p&gt;1 模块分包原则&lt;br/&gt;2 框架扩展原则&lt;br/&gt;3 领域划分原则&lt;br/&gt;4 接口分离原则&lt;br/&gt;5 组件协作原则&lt;br/&gt;6 功能演进原则&lt;/p&gt;
&lt;p&gt;我将对每个原则进行自己的解读，如有不对，还请指教 ：）&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;1 模块分包原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1842&quot; data-height=&quot;966&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-cdc90616f48ca317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;237&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-cdc90616f48ca317.png&quot; data-original-width=&quot;1842&quot; data-original-height=&quot;966&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;506514&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;说说我的理解。这里其实是从框架结构的解读来解读，这里的包指的是 Maven 的 module。&lt;/p&gt;
&lt;p&gt;复用度，指的是 maven 包的复用。可以理解为工具类。这个工具类不应该变化无常。&lt;/p&gt;
&lt;p&gt;稳定度：被依赖的包应该保持稳定，或者说，被依赖者应当比依赖者稳定，且不能成环状依赖。如果不稳定，将会影响其他的包。&lt;/p&gt;
&lt;p&gt;抽象度，越抽象，越稳定。越具体，越容易变化。&lt;/p&gt;
&lt;p&gt;同时，梁飞给出了一个公式，但是实践起来有点麻烦.......&lt;/p&gt;
&lt;p&gt;关于模块分包，可以参见更详细的博客。 &lt;a href=&quot;http://javatar.iteye.com/blog/1188028&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;以HTTL为例讲讲模块分包&amp;amp;领域模型&amp;amp;扩展框架&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;2 框架扩展原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1082&quot; data-height=&quot;674&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-1cc980030bdcc3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;249&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-1cc980030bdcc3d1.png&quot; data-original-width=&quot;1082&quot; data-original-height=&quot;674&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;106011&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是其实是说的比较多的东西了。&lt;/p&gt;
&lt;p&gt;什么是微核心 + 插件？按照作者的说法，核心只负责装配插件。这样，无论是作者自己的功能，还是第三方的功能，都是平等的，再多的插件也不会影响软件架构，因为没有硬编码，且都是可以卸载的。甚至微核也是可以扩展的。：）&lt;/p&gt;
&lt;p&gt;同时，插件的组装规则是统一的。说到这里，你应该想到了 IDEA，Maven，Eclipse 等等。&lt;/p&gt;
&lt;p&gt;然后说外置生命周期。这个其实我是有一点不理解的。按照作者的说法，其实是说，框架只负责管理对象，对象的出生和死亡不由框架负责。即，用户应将实例注册到框架中。&lt;/p&gt;
&lt;p&gt;但 Spring 似乎不是这么做的。同时，如果使用注册机制，那么就需要硬编码。或者说，Spring 本身就是管理 Bean 生命周期的框架，而 Dubbo 的职责不在于此？&lt;/p&gt;
&lt;p&gt;最少化概念模型，这个其实是一种优化。&lt;/p&gt;
&lt;p&gt;一致化数据模型：例如 URL 这种对象，就是一致化数据模型，拒绝使用 String 拼接，解析。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;3 领域划分原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1730&quot; data-height=&quot;870&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-f1c8ef84562c176c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;277&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-f1c8ef84562c176c.png&quot; data-original-width=&quot;1730&quot; data-original-height=&quot;870&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;304674&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是在框架设计中，是非常重要的。&lt;/p&gt;
&lt;p&gt;PPT 中已经说的非常清楚，我就不再说明。其中，Invocation 一定要轻量。否则，对 GC 来说，将是很大的压力（使用对象池？性能不好。）&lt;/p&gt;
&lt;p&gt;说说他的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结构清晰，这个不必讲吧。&lt;/li&gt;
&lt;li&gt;充血模型......这个怎么理解？&lt;/li&gt;
&lt;li&gt;可变和不可变状态分离，可变状态集中。通常实体域都是只读的，即不变状态。会话域都是可变状态。&lt;/li&gt;
&lt;li&gt;所有领域模型线程安全。无锁编程（lock-free 非常重要）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于他们的线程安全性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务域无状态，天生线程安全。&lt;/li&gt;
&lt;li&gt;实体域属性只读，线程安全。&lt;/li&gt;
&lt;li&gt;会话域工作在栈中，线程安全。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，需要保证他们是这么设计的，才能实现无锁编程。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;4 接口分离原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1396&quot; data-height=&quot;1004&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-85cf6df6bdac6163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;241&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-85cf6df6bdac6163.png&quot; data-original-width=&quot;1396&quot; data-original-height=&quot;1004&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;513717&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;关于接口分离，我认为是单一职责的一种实现。&lt;/p&gt;
&lt;p&gt;其中提到 API 和 SPI，API 面向用户，SPI 面向开发者。两者必须分离。&lt;/p&gt;
&lt;p&gt;声明式 API 和过程式 SPI ，没看懂，看懂的说一下。：）&lt;/p&gt;
&lt;p&gt;API 可配置，一定可编程，这个不用说吧。&lt;/p&gt;
&lt;p&gt;区分命令和查询，例如，不应该有 updateAndGet 这个方法（不包括原子类），应该分成 2 个方法，保证 get 方法幂等。&lt;/p&gt;
&lt;p&gt;对称性接口：很简单，有 get 方法，就应该有 set 方法，有 add 就由 remove，称之为对称性和完备性。这样用户能自行推导出接口。&lt;/p&gt;
&lt;p&gt;兼容性：如果接口加方法，应该是增加子接口的方式。其他的没看明白.......&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;5 组件协作原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1412&quot; data-height=&quot;1590&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-e38bd0a40b19206d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;263&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-e38bd0a40b19206d.png&quot; data-original-width=&quot;1412&quot; data-original-height=&quot;1590&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;842198&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个就比较爽了，我们知道 Dubbo 是管道式设计。一个 Invoker 贯通整个流程，事实上，web 服务器都是这么设计的。例如 Tomcat ，Netty。&lt;/p&gt;
&lt;p&gt;关于派发，还记得 Spring 的 dispatchServlet 吗？&lt;/p&gt;
&lt;p&gt;关于状态的共享：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布是什么？即通过行为传递（适合交互性系统）。&lt;/li&gt;
&lt;li&gt;共享是什么？通过一个固定的点获取，称之为仓库（适合管理状态的系统）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主过程拦截，还记得 Mybatis 留给我们的插件吗？还记得 Spring 留给我们的拦截器吗？框架要在关键节点留出拦截点供用户扩展。&lt;/p&gt;
&lt;p&gt;事件派发：观察者模式，Reactor 模式，另外提到 Proactor 模式，查了一下，通常在 GNU 编程中，由 OS 支持。&lt;/p&gt;
&lt;p&gt;Dubbo 暴露、引用、调用事件，都预留了监听器。&lt;/p&gt;
&lt;p&gt;关键路径，即在管道使用职责连模式进行拦截，保证每个拦截器职责单一。&lt;/p&gt;
&lt;p&gt;非关键路径，需要有监听机制，不能影响主流程运行。&lt;/p&gt;
&lt;p&gt;关于协作防御，我理解为防御性编程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分离可靠操作和不可靠操作。不可靠操作尽量范围要小。&lt;/li&gt;
&lt;li&gt;状态分离，尽量无状态。状态要尽可能小。&lt;/li&gt;
&lt;li&gt;对状态要尽早验证，因为如果失败，通常无人回滚。前后断言验证状态正确性。&lt;/li&gt;
&lt;li&gt;异常防御，应该是预见性的异常，异常包含环境信息。&lt;/li&gt;
&lt;li&gt;降低修改成本，防止埋雷：不要根据异常类型做分支判断。保持 null 和 empty 一致。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2&gt;6 功能演进原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1398&quot; data-height=&quot;760&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-231023fac9a633b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;207&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-231023fac9a633b6.png&quot; data-original-width=&quot;1398&quot; data-original-height=&quot;760&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;421693&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;第一就是开闭原则，微核心加插件机制能够支持。&lt;br/&gt;软件质量的下降，来源于修改。&lt;/p&gt;
&lt;p&gt;加功能的姿势：应该是增量式，而不是扩充式，即不在原有基础上修改，而是新增加功能。&lt;/p&gt;
&lt;p&gt;关于高阶：顶层接口尽量抽象，且不能依赖底层实现。这样，当底层实现变化时，高层无需变化。&lt;/p&gt;
&lt;p&gt;例如 Dubbo 泛化，在顶层就足够抽象，底层实现方式不影响高层。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;总结&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1828&quot; data-height=&quot;1034&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-60328aeaccfc19cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;261&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-60328aeaccfc19cf.png&quot; data-original-width=&quot;1828&quot; data-original-height=&quot;1034&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;215828&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上是梁飞总结。&lt;/p&gt;
&lt;p&gt;今天说的框架设计和现在大部分人喜欢说的架构设计有所不同，现在似乎只需要再 processon 上放几个阿里云组件，再连几条线，就是架构设计了 ：）&lt;/p&gt;
&lt;p&gt;我个人认为，框架设计更能考验一个程序员对程序的抽象和管理能力（也许措辞不当？）&lt;/p&gt;
&lt;p&gt;然后，再说说我的总结：关于一个系统的设计，这里应该指的是框架的设计，首先要知道用户需求（废话）。根据需求抽象出模型，再变成代码，且是可扩展，可复用的代码。&lt;/p&gt;
&lt;p&gt;这里提到的 6 个原则，应该算是比较成熟的原则了。&lt;/p&gt;
&lt;p&gt;1 微核 + 插件，非常理想化，例如 SOFA，也有自己的扩展机制。&lt;/p&gt;
&lt;p&gt;2 关于领域模型设计，这 3 个模型的职责一定要划分清楚，同时实现无锁编程，这个对于系统的性能非常重要。&lt;/p&gt;
&lt;p&gt;3 关于组件协作，一个系统有多个组件，通常需要进行状态的共享，在 Dubbo 中，使用行为进行传递，也就是会话域。&lt;/p&gt;
&lt;p&gt;4 关于功能演进，请遵循开闭原则，但前提通常是有一个好的内核。&lt;/p&gt;
&lt;p&gt;5 关于接口分离和模块分包，通常在后期重构能够达到更好的效果？&lt;/p&gt;
&lt;p&gt;好了，洋洋洒洒说了不少，读者如有更好的见解，请与我分享，毕竟现在关注这块的人不多了。：）期待和对此感兴趣的人一起讨论&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 15:19:00 +0000</pubDate>
<dc:creator>莫那-鲁道</dc:creator>
<og:description>读梁飞博客和其分享的 PPT 总结笔记。期待和对此感兴趣的人一起讨论 ：）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stateis0/p/9823450.html</dc:identifier>
</item>
<item>
<title>一文秒懂如何搭建一个最简单的充值系统 - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/9823406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/9823406.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;     阅读完本文大概需要5分钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;移动支付&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;微信支付&lt;/li&gt;
&lt;li&gt;支付宝支付&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;充值体系&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;最基础的架构&lt;/li&gt;
&lt;li&gt;生产环境应用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;     一切都是生意。“天下熙熙皆为利来,天下攘攘皆为利往”。不知从什么时候起，人类社会诞生了公司这样的组织,而这个组织把人们结合在一起,产生了各种行业和商业形态，最后,公司的一切活动都变成了生意。当然,大公司有大公司的生意,小公司有小公司的买卖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;     过去几年saas服务软件大行其道,这其中就有大家熟悉的阿里云服务,客户注册账户+线上支付就能使用软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;     线上支付,相信大家都不陌生。支付宝,微信,云闪付,苹果支付等,人人都离不开支付通道。我们看到很多大公司都有自己的支付体系和金融体系。大厂,财大气粗,有足够的投入可以自建高可用的支付体系。那么,如何中小微企业想在做点小生意,没有足够的资源自建支付体系,怎么玩？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;     借力。这就好比大厂花了大价钱,找到水源,然后挖了一口井，小店也得活不是,给点佣金，分一股“清泉”吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一、移动支付&lt;/strong&gt;&lt;br/&gt;　&lt;/p&gt;
&lt;blockquote readability=&quot;2.5510204081633&quot;&gt;
&lt;p&gt;本文代码示例是基于威富通移动支付(&lt;a href=&quot;https://www.swiftpass.cn/products/epay/page.html&quot; class=&quot;uri&quot;&gt;https://www.swiftpass.cn/products/epay/page.html&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;微信支付&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;     场景介绍&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用户扫描商户展示在各种场景的二维码进行支付。:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;     步骤1：商户根据微信支付的规则，为不同商品生成不同的二维码（如图6.1），展示在各种场景，用于用户扫描购买。&lt;/p&gt;
&lt;p&gt;     步骤2：用户使用微信“扫一扫”（如图6.2）扫描二维码后，获取商品支付信息，引导用户完成支付（如图6.3）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%9801.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;     步骤3：用户确认支付，输入支付密码（如图6.4）。&lt;/p&gt;
&lt;p&gt;     步骤4：支付完成后会提示用户支付成功（如图6.5），商户后台得到支付成功的通知，然后进行发货处理。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%9802.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;     查看是否安装成功:&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/java%E7%89%88%E6%9C%AC.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;     笔者在实际项目中要使用微信扫码付款功能,开发的时候选择的是微信扫码支付的模式一(&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_4&quot; class=&quot;uri&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_4&lt;/a&gt;)&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%89%AB%E6%8F%8F%E6%94%AF%E4%BB%98.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;     代码片段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// 威富通-微信支付
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;total_fee&quot;&amp;gt;订单金额&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;orderno&quot;&amp;gt;订单号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;productName&quot;&amp;gt;产品名称&amp;lt;/param&amp;gt;
        private void WebChat(decimal total_fee, string orderno, string productName)
        {
            try
            {
                total_fee = total_fee * 100;//单位：分
                PayReqEntity entity = new PayReqEntity();
                entity.mch_id =“商户ID”
                string key =“KEY&quot;;//您申请的
                entity.key = key;
                entity.req_url = &quot;https://pay.swiftpass.cn/pay/gateway&quot;;
                entity.service = &quot;pay.weixin.native&quot;;
                entity.version = &quot;2.0&quot;;
                entity.out_trade_no = orderno;
                entity.body = productName;
                entity.attach = &quot;&quot;;
                entity.total_fee = Math.Round(total_fee).ToString();
                entity.time_start = &quot;&quot;;
                entity.time_expire = &quot;&quot;;
                entity.mch_create_ip = AppUtils.GetIp();
                entity.notify_url = ChargeHelper.BuildUrl() + &quot;WebChat/Notify.aspx&quot;;
                WeChatPayInterface service = new WeChatPayInterface();
                PayResEntity result = service.SubmitPay(entity);
                if (!result.IsSuccess)
                {
                    string msg = result.Message;
                    if (msg.Contains(&quot;订单已存在&quot;))
                    {
                        msg = msg + &quot;,请重新下单！&quot;;
                    }
                    Response.Write(&quot;&amp;lt;script&amp;gt;alert('&quot; + msg + &quot;')&amp;lt;/script&amp;gt;&quot;);
                    return;
                }
                Session[&quot;pavlue&quot;] = result.arr;
                Response.Redirect(&quot;WebChat/Pay.aspx&quot;);
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;     付款完成之后,会回调WebChat/Pay.aspx页面,执行订单业务功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void callback()
        {
            try
            {
                WeChatPayInterface service = new WeChatPayInterface();
                Stream stream = Request.InputStream;
                string key = &quot;KEY&quot;;//你申请的
                NotifyResEntity result = service.PayResult(key, stream);
                if (!result.IsSuccess)
                {
                    Log.Info(&quot;[威富通-微信支付回调]：&quot; + result.Message);
                    Response.Write(&quot;failure&quot;);
                    return;
                }
                Hashtable data = result.data;
                /*-----------交易状态------------
                 SUCCESS—支付成功
                 REFUND—转入退款
                 NOTPAY—未支付
                 CLOSED—已关闭
                 PAYERROR—支付失败(其他原因，如银行返回失败)
                 ------------------------------------ */
                string out_trade_no = data[&quot;out_trade_no&quot;].ToString();//商户订单号
                int status = Convert.ToInt32(data[&quot;status&quot;]);//返回状态码(0表示成功，非0表示失败此字段是通信标识，非交易标识，交易是否成功需要查看 result_code 来判断)
                int result_code = Convert.ToInt32(data[&quot;result_code&quot;]);//业务结果(0表示成功，非0表示失败)
                if (status == 0 &amp;amp;&amp;amp; result_code == 0)
                {
                    string total_fee = data[&quot;total_fee&quot;].ToString();//总金额，以分为单位，不允许包含任何字、符号
                    string transaction_id = data[&quot;transaction_id&quot;].ToString();//平台交易单号
                    //此处可以在添加相关处理业务 ，更新数据库表中的记录。
                    int proxyid = 0;
                    string bankbill = &quot;&quot;;
                    ulong employeeid = 1;
                    string comment = &quot;微信支付&quot;;
                    string billtype = &quot;正常订单&quot;;
                    int payment = 24;//微信支付
                    string bankname = &quot;&quot;;
                    string payer = &quot;&quot;;
                    string orderno = out_trade_no;
                    string taobaopayno = transaction_id;
                    decimal amountpaid = 0;
                    if (!string.IsNullOrEmpty(total_fee))
                    {
                        amountpaid = Convert.ToDecimal(total_fee) / 100;
                    }
         
                    //TODO:业务处理部分
                    Response.Write(&quot;success&quot;);
                    return;
                    
                }
                else
                {
                    Log.Info(&quot;[威富通-微信支付回调]：商户订单号out_trade_no=&quot; + out_trade_no + &quot;状态码status=&quot; + status + &quot;,业务结果result_code=&quot; + result_code);
                }
            }
            catch (Exception ex)
            {
                Log.Info(&quot;[威富通-微信支付回调]异常：&quot; + ex);
            }
            Response.Write(&quot;failure&quot;);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.&lt;strong&gt;支付宝支付&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     场景介绍&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;    扫码支付，指用户打开支付宝钱包中的“扫一扫”功能，扫描商户针对每个订单实时生成的订单二维码，并在手机端确认支付。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;     调用流程&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.open.alipay.com/194/105170/&quot; class=&quot;uri&quot;&gt;https://docs.open.alipay.com/194/105170/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%9801.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;    商户系统调用支付宝预下单接口alipay.trade.precreate，获得该订单二维码图片地址。&lt;br/&gt;    发起轮询获得支付结果：等待5秒后调用交易查询接口alipay.trade.query通过支付时传入的商户订单号(out_trade_no)查询支付结果（返回参数TRADE_STATUS），如果仍然返回等待用户付款（WAIT_BUYER_PAY），则再次等待5秒后继续查询，直到返回确切的支付结果（成功TRADE_SUCCESS 或 已撤销关闭TRADE_CLOSED），或是超出轮询时间。在最后一次查询仍然返回等待用户付款的情况下，必须立即调用交易撤销接口alipay.trade.cancel将这笔交易撤销，避免用户继续支付。&lt;br/&gt;    除了主动轮询，也可以通过接受异步通知获得支付结果，详见扫码异步通知，注意一定要对异步通知做验签，确保通知是支付宝发出的。&lt;/p&gt;
&lt;p&gt;代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private void Alipay(decimal total_fee, string orderno, string productName)
        {
            total_fee = total_fee * 100;//单位：分
            PayReqEntity entity = new PayReqEntity();
            entity.mch_id = &quot;商户ID&quot;;
            string key = 商户Key&quot;&quot;;
            entity.key = key;
            entity.req_url = &quot;https://pay.swiftpass.cn/pay/gateway&quot;;
            entity.service = &quot;pay.alipay.native&quot;;
            entity.version = &quot;2.0&quot;;
            entity.out_trade_no = orderno;
            entity.body = productName;
            entity.attach = &quot;&quot;;
            entity.total_fee = Math.Round(total_fee).ToString();
            entity.time_start = &quot;&quot;;
            entity.time_expire = &quot;&quot;;
            entity.mch_create_ip = AppUtils.GetIp();
            entity.notify_url = ChargeHelper.BuildUrl() + &quot;Alipay/Notify.aspx&quot;;
            WeChatPayInterface service = new WeChatPayInterface();
            PayResEntity result = service.SubmitPay(entity);
            if (!result.IsSuccess)
            {
                string msg = result.Message;
                if (msg.Contains(&quot;订单已存在&quot;))
                {
                    msg = msg + &quot;,请重新下单！&quot;;
                }
                Response.Write(&quot;&amp;lt;script&amp;gt;alert('&quot; + msg + &quot;')&amp;lt;/script&amp;gt;&quot;);
                return;
            }
            Session[&quot;alipay_pavlue&quot;] = result.arr;
            Response.Redirect(&quot;Alipay/Pay.aspx&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    支付完成,同样回调Alipay/Pay.aspx&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void callback()
        {
            try
            {
                WeChatPayInterface service = new WeChatPayInterface();
                Stream stream = Request.InputStream;
                string key = &quot;KEY&quot;;//填写自己的
                NotifyResEntity result = service.PayResult(key, stream);
                if (!result.IsSuccess)
                {
                    Log.Info(&quot;[威富通-支付宝支付回调]：&quot; + result.Message);
                    Response.Write(&quot;failure&quot;);
                    return;
                }
                Hashtable data = result.data;
                /*-----------交易状态------------
                 SUCCESS—支付成功
                 REFUND—转入退款
                 NOTPAY—未支付
                 CLOSED—已关闭
                 PAYERROR—支付失败(其他原因，如银行返回失败)
                 ------------------------------------ */
                //string trade_state = data[&quot;trade_state&quot;].ToString();
                string out_trade_no = data[&quot;out_trade_no&quot;].ToString();//商户订单号
                int status = Convert.ToInt32(data[&quot;status&quot;]);//返回状态码(0表示成功，非0表示失败此字段是通信标识，非交易标识，交易是否成功需要查看 result_code 来判断)
                int result_code = Convert.ToInt32(data[&quot;result_code&quot;]);//业务结果(0表示成功，非0表示失败)
                if (status == 0 &amp;amp;&amp;amp; result_code == 0)
                {
                    string total_fee = data[&quot;total_fee&quot;].ToString();//总金额，以分为单位，不允许包含任何字、符号
                    string transaction_id = data[&quot;transaction_id&quot;].ToString();//平台交易单号
                    //此处可以在添加相关处理业务 ，更新数据库表中的记录。
                    int proxyid = 0;
                    string bankbill = &quot;&quot;;
                    ulong employeeid = 1;
                    string comment = &quot;支付宝支付&quot;;
                    string billtype = &quot;正常订单&quot;;
                    int payment = 23;//威富通-支付宝支付
                    string bankname = &quot;&quot;;
                    string payer = &quot;&quot;;
                    string orderno = out_trade_no;
                    string taobaopayno = transaction_id;
                    decimal amountpaid = 0;
                    if (!string.IsNullOrEmpty(total_fee))
                    {
                        amountpaid = Convert.ToDecimal(total_fee) / 100;
                    }
                    //TODO:业务处理部分
                    Response.Write(&quot;success&quot;);
                    return;
                }
                else
                {
                    Log.Info(&quot;[威富通-支付宝支付回调]：商户订单号out_trade_no=&quot; + out_trade_no + &quot;状态码status=&quot; + status + &quot;,业务结果result_code=&quot; + result_code);
                }
            }
            catch (Exception ex)
            {
                Log.Info(&quot;[威富通-支付宝支付回调]异常：&quot; + ex);
            }
            Response.Write(&quot;failure&quot;);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;二、充值体系&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;任何一家公司做生意的都会使用支付业务,这里以SAAS行业支付为例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%85%85%E5%80%BC%E4%BD%93%E7%B3%BB.png&quot;/&gt;&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;订单生成流程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     在实际生产环境中中,订单的流程也是较为重要的一环。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%AE%A2%E6%88%B7%E5%85%85%E5%80%BC%E6%B5%81%E7%A8%8B.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;防止重复支付&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     支付完成,回调的时候检测订单状态。已支付的就不再执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何保证支付一致性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     在实际生产环境中中,总会发生支付接口支付成功,回调执行订单业务失败的情况，简单的办法是可以增加一个单独检查业务,定时对不一致的订单进行二次执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     基本的充值体系是通用的。订单业务量大的可以增加消息队列处理。在保证一致性方面,我们在该架构上还有很多细节可以完善。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     个人微信公众号:&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E7%A0%81%E5%86%9C%E5%95%86%E4%B8%9A%E5%8F%82%E8%B0%8B%20%282%29.jpg&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
</description>
<pubDate>Sat, 20 Oct 2018 15:01:00 +0000</pubDate>
<dc:creator>戎&amp;quot;码&amp;quot;一生</dc:creator>
<og:description>&amp; 160; &amp; 160;&amp; 160;&amp; 160;阅读完本文大概需要5分钟。 目录 移动支付 微信支付 支付宝支付 充值体系 最基础的架构 生产环境应用 总结 参考 &amp; 160; &amp; 160;&amp; 16</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lucky_hu/p/9823406.html</dc:identifier>
</item>
<item>
<title>SpringBoot 之Actuator. - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/9820579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/9820579.html</guid>
<description>&lt;h2&gt;一、Actuator 介绍&lt;/h2&gt;
&lt;p&gt;    Actuator 是 SpringBoot 项目中一个非常强大一个功能，有助于对应用程序进行监视和管理，通过 restful api 请求来监管、审计、收集应用的运行情况。&lt;/p&gt;
&lt;p&gt;    Actuator 的核心是端点 Endpoint，它用来监视应用程序及交互，spring-boot-actuator 中已经内置了非常多的 Endpoint（health、info、beans、metrics、httptrace、shutdown等等），同时也允许我们自己扩展自己的 Endpoints。每个 Endpoint 都可以启用和禁用。要远程访问 Endpoint，还必须通过 JMX 或 HTTP 进行暴露，大部分应用选择HTTP，Endpoint 的ID默认映射到一个带 &lt;strong&gt;/actuator&lt;/strong&gt; 前缀的URL。例如，health 端点默认映射到 &lt;strong&gt;/actuator/health&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;二、Actuator 使用&lt;/h2&gt;
&lt;p&gt;    启用 Actuator 最简单方式是添加 &lt;strong&gt;spring-boot-starter-actuator&lt;/strong&gt; ‘Starter’依赖。 &lt;/p&gt;
&lt;h3&gt;    1、pom.xml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 2、监控 —— Actuator插件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;    2、application.yml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;management&lt;/strong&gt;:
  &lt;strong&gt;endpoints&lt;/strong&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 暴露 EndPoint 以供访问，有jmx和web两种方式，exclude 的优先级高于 include&lt;/span&gt;
&lt;span&gt;&lt;span&gt;    jmx&lt;/span&gt;:
      exposure:
        exclude: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        include: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    web&lt;/span&gt;:
      exposure:
      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; exclude: '*'&lt;/span&gt;
        include: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;health&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metrics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
      base&lt;/span&gt;-path: /actuator  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置 Endpoint 的基础路径&lt;/span&gt;
      cors: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置跨域资源共享&lt;/span&gt;
        allowed-origins: http://&lt;span&gt;example.com
        allowed&lt;/span&gt;-&lt;span&gt;methods: GET,POST
    enabled&lt;/span&gt;-by-default: true &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改全局 endpoint 默认设置&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;  endpoint&lt;/strong&gt;:
    &lt;span&gt;auditevents&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、显示当前引用程序的审计事件信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
      cache:
        time&lt;/span&gt;-to-live: 10s &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置端点缓存响应的时间&lt;/span&gt;
    &lt;span&gt;beans&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、显示一个应用中所有 Spring Beans 的完整列表，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;conditions&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3、显示配置类和自动配置类的状态及它们被应用和未被应用的原因，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;configprops&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4、显示一个所有@ConfigurationProperties的集合列表，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;env&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5、显示来自Spring的 ConfigurableEnvironment的属性，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;flyway&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6、显示数据库迁移路径，如果有的话，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;health&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7、显示健康信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
      show&lt;/span&gt;-&lt;span&gt;details: always
    &lt;span&gt;info&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 8、显示任意的应用信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;liquibase&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 9、展示任何Liquibase数据库迁移路径，如果有的话，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;metrics&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 10、展示当前应用的metrics信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;mappings&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 11、显示一个所有@RequestMapping路径的集合列表，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;scheduledtasks&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 12、显示应用程序中的计划任务，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;sessions&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 13、允许从Spring会话支持的会话存储中检索和删除(retrieval and deletion)用户会话。使用Spring Session对反应性Web应用程序的支持时不可用。默认开启。&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;shutdown&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 14、允许应用以优雅的方式关闭，默认关闭&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;threaddump&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 15、执行一个线程dump&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; web 应用时可以使用以下端点&lt;/span&gt;
    &lt;span&gt;heapdump&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 16、    返回一个GZip压缩的hprof堆dump文件，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;jolokia&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 17、通过HTTP暴露JMX beans（当Jolokia在类路径上时，WebFlux不可用），默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;logfile&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 18、返回日志文件内容（如果设置了logging.file或logging.path属性的话），支持使用HTTP Range头接收日志文件内容的部分信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;prometheus&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;19、以可以被Prometheus服务器抓取的格式显示metrics信息，默认开启&lt;/span&gt;
      enabled: true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这大抵就是全部默认的 Endpoint 的配置了，怎么样？强大吧！之前做了一个网络监控的项目，就是能够实时查看服务器的 CPU、内存、磁盘、IO 这些（基于 sigar.jar 实现），然后现在发现 SpringBoot 就这样轻松支持了，还更强大，更简便......&lt;/p&gt;
&lt;p&gt;    默认的 Endpoint 映射前缀是 &lt;strong&gt;/actuator&lt;/strong&gt;，可以通过如上 base-path 自定义设置。&lt;/p&gt;
&lt;p&gt;    每个 Endpoint 都可以配置开启或者禁用。但是仅仅开启 Endpoint 是不够的，还需要通过 jmx 或者 web 暴露他们，通过 exclude 和 include 属性配置。&lt;/p&gt;
&lt;h3&gt;    3、效果&lt;/h3&gt;
&lt;p&gt;    做好了如上的配置，接下来我们只需要访问对应的 Endpoint 就可以啦，&lt;span&gt;/actuator/[Endpoint ID]&lt;/span&gt;（http://127.0.0.1:8080/actuator/health）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1153954/201810/1153954-20181020094706537-1978178389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、自定义 Endpoint&lt;/h2&gt;
&lt;p&gt;    自定义 Endpoint 端点，只需要在我们的新建Bean上使用 &lt;strong&gt;@Endpoint&lt;/strong&gt; 注解即可。则 Bean 中的方法就可以通过 JMX 或者 HTTP 公开。除此之外，你还可以使用 &lt;strong&gt;@JmxEndpoint&lt;/strong&gt; 或 &lt;strong&gt;@WebEndpoint&lt;/strong&gt; 编写 EndPoint。但是这些 EndPoint 仅限于各自的公开方式。例如，@WebEndpoint 仅通过HTTP公开，而不通过JMX公开。&lt;/p&gt;
&lt;p&gt;    那么是不是类中所有的方法都支持对外公开呢？很明显不是的。这里又要提到三个注解，只有加三个注解的方法才支持对外公开，并且每个注解都有支持它的 HTTP method。如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;HTTP method&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@ReadOperation&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@WriteOperation&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@DeleteOperation&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;    Endpoint 上的操作通过参数接收输入。 当通过网络公开时，这些参数的值取自URL的查询参数和JSON请求主体。 通过JMX公开时，参数将映射到MBean操作的参数。参数默认是必需的,可以通过使用 &lt;strong&gt;@Nullable&lt;/strong&gt; 注释使其成为可选的。&lt;/p&gt;
&lt;p&gt;    可以通过使用 &lt;strong&gt;@Selector&lt;/strong&gt; 注释操作方法的一个或多个参数来进一步定制路径。@Selector 会将路径上的参数作为变量传递给操作方法。这个注解有点诡异，且听我徐徐道来~~&lt;/p&gt;
&lt;h3&gt;    1、Endpoint Bean&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Endpoint(id &lt;/span&gt;= &quot;my&quot;, enableByDefault = &lt;span&gt;true&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 id，并选择是否默认开启&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyEndPoint {

    @ReadOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getPaths() {
        List&lt;/span&gt;&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&quot;java&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;c++&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;python&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    @ReadOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String get(@Selector String arg0) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arg0;
    }&lt;br/&gt;@WriteOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String post() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;post&quot;&lt;span&gt;;
    }

    @DeleteOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer delete() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;    2、暴露 Endpoint&lt;/h3&gt;
&lt;p&gt;设置好了上面的 Endpoint Bean，还不能真正的访问到它们，需要在 application.yml 中将它们暴露出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;management&lt;/strong&gt;:
  endpoints:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 暴露 EndPoint 以供访问，有jmx和web两种方式，exclude 的优先级高于 include&lt;/span&gt;
&lt;span&gt;&lt;span&gt;    jmx&lt;/span&gt;:
      exposure:
        exclude: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        include: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    web&lt;/span&gt;:
      exposure:
      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; exclude: '*'&lt;/span&gt;
        include: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;health&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metrics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;做好这些配置后，你就能访问到 Endpoint 了（http://127.0.0.1:8080/actuator/my）&lt;/p&gt;
&lt;h3&gt;    3、@Selector&lt;/h3&gt;
&lt;p&gt;注意到没有，上面的 Endpoint 有一个 @Selector 参数的方法，并且参数名是 arg0，这个参数名是有学问滴......&lt;/p&gt;
&lt;p&gt;原来我给的参数名是 path，原来我设想我可以访问 /actuator/my/[任意字符] 的路径，但是会报 400 参数不匹配错误。但是嘞，/actuator/my/[任意字符]?path=[任意字符] 是正常访问的，真是奇了怪了！&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;原来，为了使 @Selector 正常工作，必须使用嵌入的参数名称编译 Endpoint（-parameters&lt;/span&gt;&lt;/span&gt;&lt;span&gt;），如下。或者将参数名改为 arg0 就能达到目的。&lt;span&gt;&lt;a href=&quot;https://stackoverflow.com/questions/47920201/how-do-you-use-selector-in-writeoperation-in-spring-boot-2-0-actuator-endp&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这个是 stackoverflow 上的一个解释~&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;compilerArgs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;-parameters&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;compilerArgs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 或者：
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;parameters&amp;gt;true&amp;lt;/parameters&amp;gt;
        &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;tips：&lt;/span&gt;&lt;/strong&gt; -parameters 的方式我没有验证通过呀~~汗&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;演示源代码：&lt;/strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/JMCuixy/Thymeleaf&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/JMCuixy/Thymeleaf&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 14:10:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<og:description>一、Actuator 介绍 Actuator 是 SpringBoot 项目中一个非常强大一个功能，有助于对应用程序进行监视和管理，通过 restful api 请求来监管、审计、收集应用的运行情况。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/9820579.html</dc:identifier>
</item>
<item>
<title>一起学HBase——简单介绍HBase各种组件 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9823149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9823149.html</guid>
<description>&lt;p&gt;HBase是谷歌BigTble的开源实现。谷歌的三篇论文拉开了大数据江湖的序幕，铸就了现在以Hadoop为主的大数据技术生态圈。而HBase是开源的大数据数据库，和传统的行式数据库不同的是，HBase是列式数据库。列式数据的特点是开源横向扩展，将一张表的数据存储在hadoop集群的不同datanode中，一张表的存储量可以达到T级别。这是行式关系型数据库无法实现的。本文主要讲解HBase的基本概念，只有概念清楚了才能更好的在我们的系统中使用HBase。&lt;/p&gt;
&lt;h3 id=&quot;核心组件介绍&quot;&gt;核心组件介绍&lt;/h3&gt;
&lt;p&gt;Table：可理解为传统数据库中的一个表，但因为SchemaLess的设计，它较之传统数据库的表而言，在设计上更加灵活。&lt;/p&gt;
&lt;p&gt;Region：将表横向切割为一个个子表，子表在HBase中被称之为Region。&lt;/p&gt;
&lt;p&gt;RegionServer：数据服务进程，Region必须部署在某一个RegionServer上才可以提供读写服务。&lt;/p&gt;
&lt;p&gt;HFile：HBase数据库在底层分布式文件系统中的文件组织形式。&lt;/p&gt;
&lt;p&gt;Column Family：一些列的集合。不同的Column Family数据被存储在不同的路径中。&lt;/p&gt;
&lt;p&gt;MemStore：用来在内存中缓存一定大小的数据，达到设定的阈值后批量写入到底层文件系统中。数据是有序的。&lt;/p&gt;
&lt;p&gt;下图清晰的展示了Table，Region，RegionServer，HFile，MemStore，Column Family在HBase的逻辑关系。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory1.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图显示了HBase集群中的关键进程&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory2.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;br/&gt;Zookeeper：HBase集群的调度器，可以用于将HBase RegionServer信息注册到zookeeper中，查询HBase RegionServer状态信息，HMaster启动时会将HBase系统表-ROOT-加载到zookeeper集群中，通过zookeeper集群可以获取当前系统表.META.的存储所对应的RegionServer信息&lt;br/&gt;。&lt;br/&gt;Master，通过jps命令显示的进程名称是HMaster，在负责表管理操作，Region到各个RegionServer的分配以及RegionServer Failover的处理等。&lt;/p&gt;
&lt;p&gt;RegionServer进程提供数据读写服务。&lt;/p&gt;
&lt;p&gt;NameNode，Hadoop进程，处理来自Master的请求，H管理DFS文件系统的命名空间NameSpace。&lt;/p&gt;
&lt;p&gt;DataNode，Hadoop数据节点进程，HBase的所有数据都存在Hadoop的DataNode中。&lt;/p&gt;
&lt;h3 id=&quot;keyvalue数据存储结构&quot;&gt;KeyValue数据存储结构&lt;/h3&gt;
&lt;p&gt;HBase所存储的数据是以KeyValue形式存放的，KeyValue有特定的数据结构，如下图所示，一个KeyValue可以理解成HBase表中的一个列，当一行存在多个列时，将包含多个KeyValue，同一行的KeyValue有可能存储在不同的文件中，但在读取时，会按需合并在一起返回给客户端。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory3.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户写数据时，需要定义用户数据的RowKey,指定每一列所存放的Column Family,并且为其定义相应的Qualifier（列名），Value部分存放用户数据。Hbase中每一行可拥有不同的KeyValues，这就是HBase Schema-less的特点。&lt;/p&gt;
&lt;p&gt;HBase中支持数据的多版本，通过带有不同时间戳的多个KeyValue版本来实现的，如下图所示。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory5.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HBase所保存的版本数据是可配置的，默认存放3个版本。在普通的读取流程中，旧版本的数据时不可见的，但通过制定版本数或者版本号的读取，可以获取旧版本数据。下图是普通读取刘恒与多版本读取流程的对比。&lt;/p&gt;
&lt;h3 id=&quot;灵活的列定义&quot;&gt;灵活的列定义&lt;/h3&gt;
&lt;p&gt;用户数据存入到HBase表中时，需要进行Qualifier(KeyValue/列)设计。一个最简单的设计是保持HBase的列与用户数据的列一致，如下图1的设计。这种设计，基本上与关系型数据库的设计是一致的，但这种设计会带来较大的数据冗余(KeyValue结构开销)。但HBase基于KeyValue的接口，决定了这种设计可以是非常灵活的，例如，我们也可以考虑为HBase的每一行只设置两个列，其中，Name为一个列，其他内容合并到一个列中，如下图2所示。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory6.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽管我们在使用HBase表存放数据的时候，需要预先做好列的设计。但这个设计仅仅由应用层感知，HBase并没有存放任何的Schema信息来描述这个设计。也就是说，应用层需要知道为每一个表/每一行设计了什么样的列(KeyValue)，然后在地区的时候做相应的解析。既然HBase中并没有Schema信息，name，每一行中的列，也可以是任意添加的。如下图所示，绿色背景的KeyValue为后续增加的。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory7.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;column-family&quot;&gt;Column Family&lt;/h3&gt;
&lt;p&gt;假设为表设置了两个列族，而且，定义了每一个列簇中要存放的列，如下图所示：&lt;br/&gt;{Name} -&amp;gt; Column Family - A, {City,Phone,Gender} -&amp;gt; Column Familly-B。不同列簇的数据会被存储在不同的路径中。即，设置多个列簇时一行数据可能存在于两个路径中。整行读取的时候，需要将两个路径中的数据合并在一起蔡可以获取完整的一行记录。但如果仅仅读取Name一列的话，只需要读取Column Family-A即可。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory8.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 13:52:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>HBase是谷歌BigTble的开源实现。谷歌的三篇论文拉开了大数据江湖的序幕，铸就了现在以Hadoop为主的大数据技术生态圈。而HBase是开源的大数据数据库，和传统的行式数据库不同的是，HBase</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9823149.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core中服务的生命周期选项区别和用法 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/9823076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/9823076.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　在做一个小的Demo中，在一个界面上两次调用视图组件，并且在视图组件中都调用了数据库查询，结果发现，一直报错，将两个视图组件的调用分离，单独进行，却又是正常的，寻找一番，发现是配置依赖注入服务时，对于服务的生命周期没有配置得当导致，特此做一次实验来认识三者之间(甚至是四者之间的用法及区别)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本文demo地址(具体见WebApi控制器中):&lt;a href=&quot;https://gitee.com/530521314/koInstance.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/530521314/koInstance.git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、服务的生命周期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在Asp.Net Core中，内置容器负责管理服务的生命周期，从被依赖注入容器创建开始，等我们调用完服务时，到容器释放该服务的所有实力为止，有几种形式表现：&lt;/p&gt;
&lt;p&gt;　　1、Transient：每次请求服务时，都会创建一个新实例，这种生命周期适合用于轻量级服务（如Repository和ApplicationService服务）。&lt;/p&gt;
&lt;p&gt;　　2、Scoped：为每个HTTP请求创建一个实例，生命周期将横贯整次请求。&lt;/p&gt;
&lt;p&gt;　　3、SingleTon：在第一次请求服务时，为该服务创建一个实例，之后每次请求将会使用第一次创建好的服务。&lt;/p&gt;
&lt;p&gt;　　4、Instance：与SingleTon类似，但在应用程序启动时会将该实例注册到容器中，可以理解为比SingleTon还早存在。&lt;/p&gt;
&lt;p&gt;　　应用程序中相关服务的控制生命周期的方法时通过相应的Add*指定，如下三种，当然还可以通过扩展方法来简化ConfigurationServices方法中所见的代码数量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
services.AddTransient&amp;lt;IApplicationService, ApplicationService&amp;gt;&lt;span&gt;();
services.AddScoped&lt;/span&gt;&amp;lt;IApplicationService, ApplicationService&amp;gt;&lt;span&gt;();
services.AddSingleton&lt;/span&gt;&amp;lt;IApplicationService, ApplicationService&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、代码设计服务生命周期&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先设计一些服务相关的操作接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b08933b3-07cc-440d-857b-d80f1cb98324&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b08933b3-07cc-440d-857b-d80f1cb98324&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b08933b3-07cc-440d-857b-d80f1cb98324&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperation
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        Guid GetGuid();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationTransient: IOperation
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationScoped : IOperation
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationSingleton : IOperation
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationInstance : IOperation
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;    
&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;基础服务接口&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　其次对这些操作类予以实现并生成相关服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8e1c5861-5faf-43ab-8936-961ba7015a6c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8e1c5861-5faf-43ab-8936-961ba7015a6c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8e1c5861-5faf-43ab-8936-961ba7015a6c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 常规服务
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation : IOperation
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation()
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation(Guid guid)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 瞬时服务
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationTransient : IOperationTransient
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationTransient()
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationTransient(Guid guid)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单次请求内服务固定
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationScoped : IOperationScoped
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationScoped()
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationScoped(Guid guid)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 所有请求内固定服务
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationSingleton : IOperationSingleton
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationSingleton()
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationSingleton(Guid guid)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 应用程序内固定服务
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationInstance : IOperationInstance
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationInstance()
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationInstance(Guid guid)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;基础服务具体实现&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　对基础服务的聚合接口，提供统一服务接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_e404f470-dddd-406c-b651-327d805bca58&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e404f470-dddd-406c-b651-327d805bca58&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e404f470-dddd-406c-b651-327d805bca58&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取四种形式的Guid码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetGuidString();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;聚合服务接口&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　对基础服务的聚合实现，将基础服务全部接入进来作为统一服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_c2786653-77a4-4309-a421-77603c0a5355&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c2786653-77a4-4309-a421-77603c0a5355&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c2786653-77a4-4309-a421-77603c0a5355&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务调用
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationService : IOperationService
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationTransient _transientOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationScoped _scopedOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationSingleton _singletonOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationInstance _instanceOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationService(IOperationTransient transientOperation,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            IOperationScoped scopedOperation,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            IOperationSingleton singletonOperation,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            IOperationInstance instanceOperation)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             _transientOperation =&lt;span&gt; transientOperation;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             _scopedOperation =&lt;span&gt; scopedOperation;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             _singletonOperation =&lt;span&gt; singletonOperation;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             _instanceOperation =&lt;span&gt; instanceOperation;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetGuidString()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transient:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_transientOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scoped:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_scopedOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Singleton:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;_singletonOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_instanceOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;聚合服务的实现&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　在控制器中进行服务注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    [ApiController]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IOperationService _operationService;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(IOperationService operationService)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             _operationService =&lt;span&gt; operationService;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        [HttpGet]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        [Route(nameof(GetGuidString))]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetGuidString()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _operationService.GetGuidString());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在StartUp中完成服务注入逻辑，这里实现服务注入的方式多种均可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
services.AddTransient&amp;lt;IOperationTransient, OperationTransient&amp;gt;&lt;span&gt;();
services.AddScoped&lt;/span&gt;&amp;lt;IOperationScoped, OperationScoped&amp;gt;&lt;span&gt;();
services.AddSingleton&lt;/span&gt;&amp;lt;IOperationSingleton, OperationSingleton&amp;gt;&lt;span&gt;();&lt;br/&gt;//应用程序启动时便注入该实例
services.AddSingleton&lt;/span&gt;&amp;lt;IOperationInstance&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OperationInstance(Guid.Empty));
services.AddTransient&lt;/span&gt;&amp;lt;IOperationService, OperationService&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过访问预期Api地址可以得到不同的四种基础服务的Guid信息，&lt;/p&gt;
&lt;p&gt;　　第一次启动程序(不关闭)发起访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020202700048-2029519958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二次(第一次基础上再次访问)发起访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020202714830-1469125807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看见，两次访问下，Singleton和Instance是相同的，都是由应用程序启动时和应用服务加载时决定完毕，Singleton在首次进入服务时进行分配，并始终保持不变，而Instance在应用程序启动时，便将实例注入，进入服务也保持着最先的实例，没有重新分配实例。而Transient和Scoped则进行着变化。&lt;/p&gt;
&lt;p&gt;　　关闭程序，重启，第三次发起访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020202751014-1076736110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以见到，Singleton和Instance都发生了变化，也说明了之前在Singleton和Instance处写上的作用。&lt;/p&gt;
&lt;p&gt;　　接下来开始设计Transient和Scoped的不同之处，对于已有代码加上新功能，此次我们只针对Scoped和Transient进行比较。&lt;/p&gt;
&lt;p&gt;　　首先在StartUp中将HttpContextAccessor服务注入，目的是在后期能够针对Scoped获取新的服务实例(尽管两个实例是相同的)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   services.AddHttpContextAccessor();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着在聚合服务中增加一个方法，用来针对Transient、Scoped测试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取Transient、Scoped的Guid码
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetTransientAndScopedGuidString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在聚合服务实现中实现该方法并对已有的服务重新获取实例，得到不同实例下的Guid码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetTransientAndScopedGuidString()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var tempTransientService = (IOperationTransient)ServiceLocator.Instance.GetService(typeof(IOperationTransient));&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tempTransientService = (IOperationTransient)_httpContextAccessor.HttpContext.RequestServices.GetService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IOperationTransient));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tempScopedService = (IOperationScoped)_httpContextAccessor.HttpContext.RequestServices.GetService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IOperationScoped));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原生Transient请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_transientOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手动Transient请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt; tempTransientService.GetGuid(),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原生Scoped请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_scopedOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手动Scoped请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;tempScopedService.GetGuid(),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在控制器部分调用该聚合服务即可，并返回相应的结果，本次我返回的结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020213329519-1827201712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，对于Scoped来讲，一次请求内多次访问同一个服务是共用一个服务实例的，而对于Transient则是，每次访问都是新的服务实例。&lt;/p&gt;
&lt;p&gt;　　至此，对于这四种服务生命周期算是掌握的差不多了。&lt;/p&gt;

&lt;p&gt;　　参考：&lt;/p&gt;
&lt;p&gt;　　   蒋老师文章： &lt;a href=&quot;http://www.cnblogs.com/artech/p/asp-net-core-di-register.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/artech/p/asp-net-core-di-register.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　 　  田园里的蟋蟀：&lt;a href=&quot;https://www.cnblogs.com/xishuai/p/asp-net-core-ioc-di-get-service.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xishuai/p/asp-net-core-ioc-di-get-service.html&lt;/a&gt;&lt;/p&gt;


&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-10-20,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 20 Oct 2018 13:38:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>在做一个小的Demo中，在一个界面上两次调用视图组件，并且在视图组件中都调用了数据库查询，结果发现，一直报错，将两个视图组件的调用分离，单独进行，却又是正常的，寻找一番，发现是配置依赖注入服务时，对于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/9823076.html</dc:identifier>
</item>
<item>
<title>浅谈前端实现页面加载进度条以及 nprogress.js 的实现 - 子迟</title>
<link>http://www.cnblogs.com/zichi/p/9823043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zichi/p/9823043.html</guid>
<description>&lt;p&gt;以前在 Vue 的项目用了 &lt;a href=&quot;https://github.com/rstacruz/nprogress&quot;&gt;nprogress&lt;/a&gt; 这个插件，一直对于其如何得知加载进度充满好奇，最近又看到了「前端如何实现页面加载进度条」这个问题，今天周六恰好一探究竟。以下仅为一家之言，如有异议，欢迎指出。&lt;/p&gt;

&lt;p&gt;首先不得不说，&lt;strong&gt;前端的页面加载进度条其实有两种&lt;/strong&gt;，所以你得先搞清楚说的是哪一种。&lt;/p&gt;
&lt;p&gt;第一种，进度条显示的是 &lt;strong&gt;前端静态资源&lt;/strong&gt; 的加载。比如你打开一个页面，页面需要加载 js、css、img 等静态资源，那么每加载完一个资源（监听 onload 事件或者类似事件），进度条就向前滚动一下，直到加载完所有，进度条到头。&lt;/p&gt;
&lt;p&gt;实际操作中，如果不做前置静态资源配置，基本不可能实现，因为你很难在代码中获取页面加载所需要的 js、css、img 资源，假设可以获取，还需要监听它们的 onload 事件，即使能实现这个进度条，也是一件 &lt;strong&gt;性价比很低&lt;/strong&gt; 的事情，除非一个情况。&lt;/p&gt;
&lt;p&gt;没错，这个特殊情况就是 &lt;strong&gt;游戏资源的加载&lt;/strong&gt;。我们在写游戏的时候，通常需要把静态资源项目都列出来到配置中，而且，这个资源请求，一般比较耗时，这个时候，我们就需要这样一个进度条，因为前置条件也已经满足（资源已经列出），而如果只是写一个普通的页面，我们一般不会手动去列出静态资源。（具体实现我没有研究过，实际可能更加复杂，详见 &lt;a href=&quot;https://www.zhihu.com/question/31952175/answer/54078627&quot;&gt;这个回答&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;第二种情况，也是我们现在通常说的进度条加载，举个简单的例子，GitHub 中就有用到。先打开我的 GitHub 主页 &lt;a href=&quot;https://github.com/hanzichi&quot; class=&quot;uri&quot;&gt;https://github.com/hanzichi&lt;/a&gt;，然后点击 tab 中的 Stars 标签，这个时候 url 会变成 &lt;a href=&quot;https://github.com/hanzichi?tab=stars&quot; class=&quot;uri&quot;&gt;https://github.com/hanzichi?tab=stars&lt;/a&gt;，进度条开始加载，当页面内容切换过去的时候，进度条结束。&lt;/p&gt;
&lt;p&gt;以上实现，其实就是 pjax 的实现，忽略掉 &quot;p&quot; 的部分，其实就是一个普通的 ajax。当页面发起 ajax 请求的时候，显示进度条，ajax 结束的时候，进度条到头，从而实现整个页面加载。这种情况，其实通常都会搭档 SPA 出现。&lt;/p&gt;

&lt;p&gt;以上第二种情况，业界有个成熟的插件 &lt;a href=&quot;http://ricostacruz.com/nprogress/&quot;&gt;NProgress&lt;/a&gt;。它的 API 非常简单，&lt;code&gt;NProgress.start()&lt;/code&gt; 表示进度条开始，&lt;code&gt;NProgress.done()&lt;/code&gt; 表示进度条结束。&lt;/p&gt;
&lt;p&gt;如果搭配 pjax，可以这样用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(document).on('pjax:start', function() { NProgress.start(); });
$(document).on('pjax:end',   function() { NProgress.done();  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Vue 中，可以这样用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;router.beforeEach((to, from, next) =&amp;gt; {
  NProgress.start()
  next()
})

router.afterEach(() =&amp;gt; {
  NProgress.done() // 结束 Progress
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;甚至，普通的页面中也可以用，页面开始的时候 &lt;code&gt;NProgress.start()&lt;/code&gt;，window.onload 的回调中运行 &lt;code&gt;NProgress.done()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NProgress.start()&lt;/code&gt; 和 &lt;code&gt;NProgress.done()&lt;/code&gt; 过程中，进度条会不断加载，时快时慢，这个速度的控制，依赖的是什么？答案是，&lt;strong&gt;进度条的进度其实是假的，进度是 NProgress 自己在代码中控制的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以看下 &lt;a href=&quot;https://github.com/rstacruz/nprogress/blob/master/nprogress.js&quot;&gt;源码&lt;/a&gt;，调用 &lt;code&gt;NProgress.start&lt;/code&gt; 后，会持续调用 &lt;code&gt;NProgress.inc&lt;/code&gt; 方法，我们看下这个方法实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;NProgress.inc = function(amount) {
  var n = NProgress.status;

  if (!n) {
    return NProgress.start();
  } else if(n &amp;gt; 1) {
    return;
  } else {
    if (typeof amount !== 'number') {
      if (n &amp;gt;= 0 &amp;amp;&amp;amp; n &amp;lt; 0.2) { amount = 0.1; }
      else if (n &amp;gt;= 0.2 &amp;amp;&amp;amp; n &amp;lt; 0.5) { amount = 0.04; }
      else if (n &amp;gt;= 0.5 &amp;amp;&amp;amp; n &amp;lt; 0.8) { amount = 0.02; }
      else if (n &amp;gt;= 0.8 &amp;amp;&amp;amp; n &amp;lt; 0.99) { amount = 0.005; }
      else { amount = 0; }
    }

    n = clamp(n + amount, 0, 0.994);
    return NProgress.set(n);
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中的 amount 就是进度条增量（0 为进度条起始值，1 为进度条终止值），可以从数值上判断，进度条增长速度是越来越慢。当进度条增长到 99.4% 的时候，就停止了，直到调用 &lt;code&gt;NProgress.done()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;其实，某些场景，想获取真实进度也是可以的，xhr2 其实是可以获取进度的，用 ajax 上传文件就可以持续获取进度进行展示，本文就不展开讨论了。&lt;/p&gt;
&lt;p&gt;本文的结论是，绝大多数情况下看到的前端页面进度条展示，都是假的，只是特效 ...&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 13:32:00 +0000</pubDate>
<dc:creator>子迟</dc:creator>
<og:description>以前在 Vue 的项目用了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zichi/p/9823043.html</dc:identifier>
</item>
<item>
<title>传统线程技术中创建线程的两种方式 - 程序员私房菜</title>
<link>http://www.cnblogs.com/eson15/p/9822870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eson15/p/9822870.html</guid>
<description>&lt;p&gt;传统的线程技术中有两种创建线程的方式：一是&lt;span&gt;继承&lt;code&gt;Thread&lt;/code&gt;类，并重写&lt;code&gt;run()&lt;/code&gt;方法&lt;/span&gt;；二是&lt;span&gt;实现&lt;code&gt;Runnable&lt;/code&gt;接口，覆盖接口中的&lt;code&gt;run()&lt;/code&gt;方法，并把&lt;code&gt;Runnable&lt;/code&gt;接口的实现扔给&lt;code&gt;Thread&lt;/code&gt;&lt;/span&gt;。这两种方式大部分人可能都知道，但是为什么这样玩就可以呢？下面我们来详细分析一下这两种方法的来龙去脉。&lt;br/&gt;&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5FFFA&quot;&gt;
&lt;h2&gt;&lt;strong&gt;1. 揭秘Thread中run()&lt;/strong&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;br/&gt;上面我们看到这两种方式都跟&lt;code&gt;run()&lt;/code&gt;方法有关，所以我们来看一下&lt;code&gt;Thread&lt;/code&gt;的源码中&lt;code&gt;run()&lt;/code&gt;方法到底都干了什么：
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void run() {
    if (target != null) {
        target.run();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看出，&lt;code&gt;run()&lt;/code&gt;方法中很简单，只有一个&lt;code&gt;if&lt;/code&gt;语句，如果target不为空就执行target的&lt;code&gt;run()&lt;/code&gt;方法，否则什么也不干，那么这target到底是何方神圣呢？我们点击进去可以看到：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Runnable target;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来target就是Runnable接口，我们再点进Runnable看看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Runnable {
    public abstract void run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Runnable中就一个方法，也是&lt;code&gt;run()&lt;/code&gt;方法！好了，现在再回到Thread类的&lt;code&gt;run()&lt;/code&gt;方法中，如果target不为空，即实现了Runnable接口，也即实现了Runnable中的&lt;code&gt;run()&lt;/code&gt;方法，那么我们就使用该接口中的&lt;code&gt;run()&lt;/code&gt;方法；如果target为空，即没有实现Runnable接口，那我们什么也不做，即线程创建后立马就消失了。&lt;br/&gt;所以到这里，大家就明白了为什么创建线程有上面两种方式了。第一种：你不是要先进行&lt;code&gt;if&lt;/code&gt;判断么？我现在不判断了，我把你的&lt;code&gt;if&lt;/code&gt;干掉，我在&lt;code&gt;run()&lt;/code&gt;方法中自己写代码，想干啥就干啥，即重写Thread中的&lt;code&gt;run()&lt;/code&gt;方法，；第二种：你不是要先进行&lt;code&gt;if&lt;/code&gt;判断么？行，给你一个Runnable接口让你判断，但你还是得调用我Runnable中的&lt;code&gt;run()&lt;/code&gt;方法啊，那我重写我Runnable中的&lt;code&gt;run()&lt;/code&gt;方法不就行了！　　&lt;br/&gt;知道了来龙去脉后，下面就针对这两种传统的方式写个实例。&lt;br/&gt;&lt;/p&gt;
&lt;table readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td bgcolor=&quot;#F5FFFA&quot;&gt;
&lt;h2&gt;&lt;strong&gt;2. 创建方式1：继承Thread类&lt;/strong&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;br/&gt;只要两步即可创建并开启一个线程：
&lt;ul&gt;&lt;li&gt;继承&lt;code&gt;Thread&lt;/code&gt;类，并实现&lt;code&gt;run()&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;start()&lt;/code&gt;方法开启线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于只要实现一个&lt;code&gt;run()&lt;/code&gt;方法即可，所以我们可以使用java中的匿名内部类来实现，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TraditionalThread {

    public static void main(String[] args) {
        
        /********** 第一种方法：继承Thread类，覆写run()方法 **************/
        Thread thread1 = new Thread(){

            @Override
            public void run() {
                try {
                    Thread.sleep(500);//让线程休息500毫秒
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());//打印出当前线程名
            }
        };
        thread1.start();//开启线程
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;table readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td bgcolor=&quot;#F5FFFA&quot;&gt;
&lt;h2&gt;&lt;strong&gt;3. 创建方式2：实现Runnable接口&lt;/strong&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;只要两步即可创建并开启一个线程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现&lt;code&gt;Runnable&lt;/code&gt;接口，并实现&lt;code&gt;run()&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;start()&lt;/code&gt;方法开启线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于只要实现一个&lt;code&gt;run()&lt;/code&gt;方法即可，所以我们也可以使用java中的匿名内部类来实现，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TraditionalThread {

    public static void main(String[] args) {
        
        /********** 第二种方法：实现Runnable接口，扔给Thread **************/
        Thread thread2 = new Thread(new Runnable() {
            
            @Override
            public void run() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                
            }
        });
        thread2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;table readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td bgcolor=&quot;#F5FFFA&quot;&gt;
&lt;h2&gt;&lt;strong&gt;4. 两种方式同时使用&lt;/strong&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;如果有个哥们比较给力，他两种方式同时使用了，即：既实现了Thread类中的&lt;code&gt;run()&lt;/code&gt;方法，又给Thread扔了一个实现了&lt;code&gt;run()&lt;/code&gt;方法的Runnable。如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TraditionalThread {

    public static void main(String[] args) {
        //这哥们的代码写的比较给力
        new Thread(new Runnable() {
            
            @Override
            public void run() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;Runnable:&quot; + Thread.currentThread().getName());
            }
        }){

            @Override
            public void run() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;Thread:&quot; + Thread.currentThread().getName());
            }
            
        }.start();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在又会执行哪个呢？我们运行一下上面的程序就会发现，它会打印出Thread的信息，所以运行的是Thread的&lt;code&gt;run()&lt;/code&gt;方法，知道结论了，但是为啥呢？&lt;br/&gt;从面向对象的思想去考虑：上面一段代码其实是新new了一个对象（子对象）继承了Thread对象（父对象），在子对象里重写了父类的&lt;code&gt;run()&lt;/code&gt;方法，父对象中扔了个Runnable进去，父对象中的&lt;code&gt;run()&lt;/code&gt;方法就是最初的带有&lt;code&gt;if&lt;/code&gt;判断的&lt;code&gt;run()&lt;/code&gt;方法。&lt;br/&gt;好了，现在执行&lt;code&gt;start()&lt;/code&gt;后，肯定先在子类中找&lt;code&gt;run()&lt;/code&gt;方法，找到了，父类的&lt;code&gt;run()&lt;/code&gt;方法自然就被干掉了，所以会打印出Thread:，如果我们现在假设子类中没有重写&lt;code&gt;run()&lt;/code&gt;方法，那么必然要去父类找&lt;code&gt;run()&lt;/code&gt;方法，父类的&lt;code&gt;run()&lt;/code&gt;方法中就得判断是否有Runnable传进来，现在有一个，所以执行Runnable中的&lt;code&gt;run()&lt;/code&gt;方法，那么就会打印Runnable:出来。&lt;br/&gt;　　&lt;br/&gt;OK，传统的创建线程的两种方式就总结这么多~如有错误之处，欢迎留言指正~&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 12:39:00 +0000</pubDate>
<dc:creator>程序员私房菜</dc:creator>
<og:description>传统的线程技术中有两种创建线程的方式：一是继承 类，并重写 方法；二是实现 接口，覆盖接口中的 方法，并把 接口的实现扔给 。这两种方式大部分人可能都知道，但是为什么这样玩就可以呢？下面我们来详细分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eson15/p/9822870.html</dc:identifier>
</item>
<item>
<title>跟我一起造轮子 手写springmvc - XRom</title>
<link>http://www.cnblogs.com/xrog/p/9820168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrog/p/9820168.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;　作为java程序员，项目中使用到的主流框架多多少少和spring有关联，在面试的过程难免会问一些spring springmvc spring boot的东西，比如设计模式的使用、 怎么实现springioc &lt;/span&gt;&lt;/span&gt;&lt;span&gt;怎么实现springmvc诸如此类的问题，今天我们就来探寻spring mvc的实现，然后自己实现一个简单的spring mvc&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一. &lt;span&gt;了解spring mvc的基本运行流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　ps: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;网上一大堆关于springmvc的详细讲解，在这里就不累赘了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094658/201810/1094658-20181020011500286-1901225590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　小结：spring mvc的核心是DispatcherServlet，DispatcherServlet继承于HttpServlet，可以说spring mvc是基于Servlet的一个实现，DispatcherServlet负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。&lt;/p&gt;


&lt;h2&gt;　　&lt;span&gt;1. 初始化容器 &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　　　　　　&lt;strong&gt;1.1 &lt;span&gt;读取配置文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　1.1.1.加载配置文件信息到DispatcherServlet&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;strong&gt;1.2 &lt;/strong&gt; &lt;span&gt;&lt;strong&gt;根据配置扫描包、初始化容器和组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　1.2.1.根据配置信息递归扫描包&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　1.2.2.把包下的类实例化 并且扫描注解&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　1.2.3.根据类的方法和注解，初始化HandlerMapping&lt;/p&gt;
&lt;h2&gt;　　&lt;span&gt;2. 处理业务请求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　　　2.1 &lt;strong&gt;处理请求业务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;2.2.1 首先拿到请求URI &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　 　   2.2.2 根据URI，在HandlerMapping中查找和URI对应的Handler&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　        2.2.3 根据Handler里面的method中的参数名称和http中的请求参数匹配，填充method参数，反射调用&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　　&lt;span&gt;　ps ：环境基于maven idea tomat（端口8080） servlet&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　1.搭建一个基本web项目，并导入idea配置servlet 和javassist pom依赖 如下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;创建命令: mvn archetype:generate -DgroupId=com.adminkk -DartifactId=adminkk-mvc -DpackageName=com.adminkk -Dversion=1.0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/1094658/201810/1094658-20181020125701503-1278948793.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; pom依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
  xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;com.adminkk&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;adminkk-mvc&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;configuration&amp;gt;
          &amp;lt;source&amp;gt;8&amp;lt;/source&amp;gt;
          &amp;lt;target&amp;gt;8&amp;lt;/target&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

  &amp;lt;name&amp;gt;adminkk-mvc&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--servlet--&amp;gt;
      &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
      &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- asm --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;asm&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;asm&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- javassist --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.javassist&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javassist&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.23.1-GA&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;


  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.创建mvc的注解 Controller RequestMapping 和统一异常处理类、方法参数工具类ParameterNameUtils&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;　　 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.adminkk.annotation;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Controller {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String value() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String description() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.adminkk.annotation;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Target({ElementType.TYPE,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RequestMapping {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String value() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String method() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String description() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.adminkk.exception;

public  final  class MvcException extends RuntimeException{

    public MvcException() {
        super();
    }

    public MvcException(String message) {
        super(message);
    }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.adminkk.tools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; javassist.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.bytecode.CodeAttribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.bytecode.LocalVariableAttribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.bytecode.MethodInfo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParameterNameUtils {


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String[] getParameterNamesByJavassist(&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; clazz, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Method method) {

        ClassPool pool &lt;/span&gt;=&lt;span&gt; ClassPool.getDefault();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            CtClass ctClass &lt;/span&gt;=&lt;span&gt; pool.get(clazz.getName());
            CtMethod ctMethod &lt;/span&gt;=&lt;span&gt; ctClass.getDeclaredMethod(method.getName());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用javassist的反射方法的参数名&lt;/span&gt;
            MethodInfo methodInfo =&lt;span&gt; ctMethod.getMethodInfo();
            CodeAttribute codeAttribute &lt;/span&gt;=&lt;span&gt; methodInfo.getCodeAttribute();
            LocalVariableAttribute attr &lt;/span&gt;=&lt;span&gt; (LocalVariableAttribute) codeAttribute
                    .getAttribute(LocalVariableAttribute.tag);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (attr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {

                String[] rtv &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[ctMethod.getParameterTypes().length];
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; ctMethod.getParameterTypes().length;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非静态的成员函数的第一个参数是this&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; pos = Modifier.isStatic(ctMethod.getModifiers()) ? 0 : 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; len; i++&lt;span&gt;) {
                    rtv[i] &lt;/span&gt;= attr.variableName(i +&lt;span&gt; pos);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtv;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NotFoundException e) {
            System.out.println(&lt;/span&gt;&quot;获取异常&quot;+&lt;span&gt; e.getMessage());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[0&lt;span&gt;];
    }



}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.创建 HandlerMapping类 主要是两个方法  doInit初始化 doService处理请求 相关代码如下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.adminkk.handler;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.scan.FileScaner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.scan.Scaner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.scan.XmlScaner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.tools.ParameterNameUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandlerMapping {


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String,Handler&amp;gt; handlerMapping = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Handler&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt; List&amp;lt;Scaner&amp;gt; scaners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(2&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        scaners.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlScaner());
        scaners.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileScaner());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; scanPackage(String scanUrl) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RuntimeException, IllegalAccessException, InstantiationException, ClassNotFoundException {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Scaner scaner : scaners) {
            scaner.doScane(scanUrl);
        }

    }




    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doInit(String scanUrl) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalAccessException, ClassNotFoundException, InstantiationException {
        scanPackage(scanUrl);
    }



    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doService(HttpServletRequest request, HttpServletResponse response) {

        String requestURI &lt;/span&gt;=&lt;span&gt; request.getRequestURI();
        System.out.println(&lt;/span&gt;&quot;请求地址是=&quot;+&lt;span&gt; requestURI);
        Handler handler &lt;/span&gt;=&lt;span&gt; handlerMapping.get(requestURI);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;请求地址是=&quot;+ requestURI+&quot; 没有配置改路径&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        Method method &lt;/span&gt;=&lt;span&gt; handler.getMethod();
        Object instance &lt;/span&gt;=&lt;span&gt; handler.getInstance();
        response.setCharacterEncoding(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;response.setContentType(&quot;application/json; charset=utf-8&quot;);&lt;/span&gt;
        PrintWriter writer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是简单的解析 可以像springmvc那样解析处理&lt;/span&gt;
            Map&amp;lt;String, String[]&amp;gt; parameterMap =&lt;span&gt; request.getParameterMap();
            String[] parameters &lt;/span&gt;=&lt;span&gt; ParameterNameUtils.getParameterNamesByJavassist(instance.getClass(),method);
            Object[]  parameter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[parameters.length];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(parameters != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parameters.length &amp;gt; 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; parameters.length; i++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String simpleName =&lt;span&gt; parameters[i];
                    StringBuilder parameterSb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt;  StringBuilder();
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String[] parameterStr =&lt;span&gt; parameterMap.get(simpleName);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(parameterStr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; parameterStr.length; j++&lt;span&gt;) {
                            parameterSb.append(parameterStr[j]);
                        }
                    }
                    parameter[i] &lt;/span&gt;=&lt;span&gt; parameterSb.toString();
                }
            }

            writer &lt;/span&gt;=&lt;span&gt; response.getWriter();
            String result &lt;/span&gt;=&lt;span&gt; (String) method.invoke(instance,parameter);
            writer.print(result);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            System.out.println(&lt;/span&gt;&quot;请求地址是=&quot;+ requestURI+&quot; 执行异常&quot;&lt;span&gt;);
            writer.print(&lt;/span&gt;&quot;业务执行异常&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            writer.flush();
            writer.close();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Handler addHandlerMapping(String url,Handler handler) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handlerMapping.put(url,handler);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Handler getHandlerMapping(String url) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handlerMapping.get(url);
    }



}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 扫描包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.adminkk.scan;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Scaner {

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; doScane(String scanUrl) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalAccessException, InstantiationException, ClassNotFoundException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73.5&quot;&gt;
&lt;pre readability=&quot;56&quot;&gt;
package com.adminkk.scan;&lt;p&gt;import com.adminkk.exception.MvcException;&lt;br/&gt;import com.adminkk.factory.BeanPostProcessor;&lt;br/&gt;import com.adminkk.factory.MvcBeanPostProcessor;&lt;br/&gt;import com.adminkk.factory.ServiceBeanPostProcessor;&lt;br/&gt;import com.adminkk.handler.HandlerMapping;&lt;br/&gt;import javassist.ClassClassPath;&lt;br/&gt;import javassist.ClassPool;&lt;/p&gt;&lt;p&gt;import java.io.File;&lt;br/&gt;import java.util.ArrayList;&lt;br/&gt;import java.util.List;&lt;/p&gt;&lt;p&gt;public final  class FileScaner implements Scaner{&lt;/p&gt;&lt;p&gt;public FileScaner() {&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static final List&amp;lt;BeanPostProcessor&amp;gt; beanPostProcessorList = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;static {&lt;br/&gt;beanPostProcessorList.add(new MvcBeanPostProcessor());&lt;br/&gt;beanPostProcessorList.add(new ServiceBeanPostProcessor());&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void doScane(String scanUrl) throws IllegalAccessException, InstantiationException, ClassNotFoundException {&lt;br/&gt;if(scanUrl == null || scanUrl.length() == 0){&lt;br/&gt;throw new MvcException(&quot;容器基础扫描路径为空，请检查参数配置&quot;);&lt;br/&gt;}&lt;br/&gt;String baseUrl = HandlerMapping.class.getResource(&quot;/&quot;).getPath();&lt;br/&gt;String codeUrl = scanUrl.replaceAll(&quot;\\.&quot;, &quot;/&quot;);&lt;br/&gt;String path =  baseUrl + codeUrl;&lt;br/&gt;File file = new File(path);&lt;br/&gt;if(file == null || !file.exists()){&lt;br/&gt;throw new MvcException(&quot;找不到对应扫描路径，请检查参数配置&quot;);&lt;br/&gt;}&lt;br/&gt;recursionRedFile(scanUrl,file);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;//递归读取文件&lt;br/&gt;private  void recursionRedFile(String scanUrl,File file) throws MvcException, ClassNotFoundException, IllegalAccessException, InstantiationException {&lt;/p&gt;&lt;p&gt;if(!file.exists()){&lt;br/&gt;return;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;//读取java文件&lt;br/&gt;if(file.isFile()){&lt;/p&gt;&lt;p&gt;String beanName = scanUrl.replaceAll(&quot;.class&quot;,&quot;&quot;);&lt;br/&gt;Class&amp;lt;?&amp;gt; forName = Class.forName(beanName);&lt;br/&gt;//放到Javassist容器里面&lt;br/&gt;ClassPool pool = ClassPool.getDefault();&lt;br/&gt;ClassClassPath classPath = new ClassClassPath(forName);&lt;br/&gt;pool.insertClassPath(classPath);&lt;br/&gt;if(forName.isAnnotation() || forName.isEnum() || forName.isInterface() ){&lt;br/&gt;return;&lt;br/&gt;}&lt;br/&gt;Object newInstance = forName.newInstance();&lt;/p&gt;&lt;p&gt;//前置执行&lt;br/&gt;for (int i = 0; i &amp;lt; beanPostProcessorList.size() ; i++) {&lt;br/&gt;BeanPostProcessor beanPostProcessor = beanPostProcessorList.get(i);&lt;br/&gt;beanPostProcessor.postProcessBeforeInitialization(newInstance,beanName);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;//后置执行&lt;br/&gt;for (int i = beanPostProcessorList.size()-1; i &amp;gt; 0  ; i++) {&lt;br/&gt;BeanPostProcessor beanPostProcessor = beanPostProcessorList.get(i);&lt;br/&gt;beanPostProcessor.postProcessAfterInitialization(newInstance,beanName);&lt;br/&gt;}&lt;br/&gt;return;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;//文件夹下面的文件都递归处理&lt;br/&gt;if(file.isDirectory()){&lt;br/&gt;File[] files = file.listFiles();&lt;br/&gt;if(files != null &amp;amp;&amp;amp; files.length &amp;gt;0){&lt;br/&gt;for (int i = 0; i &amp;lt; files.length; i++) {&lt;br/&gt;File targetFile = files[i];&lt;br/&gt;recursionRedFile(scanUrl+&quot;.&quot;+targetFile.getName(),targetFile);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.adminkk.scan;

public final class XmlScaner implements Scaner{

    public XmlScaner() {
    }

    @Override
    public void doScane(String scanUrl) {
        //可自行扩展
    }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　扫描bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.adminkk.factory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.exception.MvcException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BeanPostProcessor {

    Object postProcessBeforeInitialization(Object object, String beanName) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; MvcException;

    Object postProcessAfterInitialization(Object object, String beanName) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; MvcException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.adminkk.factory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.annotation.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.exception.MvcException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.handler.Handler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.adminkk.handler.HandlerMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MvcBeanPostProcessor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanPostProcessor{


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描Controller业务&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInitialization(Object object, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; MvcException {

        Class&lt;/span&gt;&amp;lt;?&amp;gt; objectClass =&lt;span&gt; object.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(objectClass.getAnnotation(Controller.&lt;span&gt;class&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            RequestMapping calssRequestMappingAnnotation &lt;/span&gt;= objectClass.getAnnotation(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            StringBuilder urlSb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(calssRequestMappingAnnotation != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                urlSb.append(calssRequestMappingAnnotation.value());
            }
            Method[] methods &lt;/span&gt;=&lt;span&gt; objectClass.getMethods();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(methods != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; methods.length &amp;gt; 0&lt;span&gt; ){
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; methods.length; i++&lt;span&gt;) {
                    Method method &lt;/span&gt;=&lt;span&gt; methods[i];
                    RequestMapping methodAnnotation &lt;/span&gt;= method.getAnnotation(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(methodAnnotation != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                        String methodValue &lt;/span&gt;=&lt;span&gt; methodAnnotation.value();
                        String url &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder().append(urlSb).append(methodValue).toString();
                        Handler handler &lt;/span&gt;=&lt;span&gt; HandlerMapping.getHandlerMapping(url);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                            handler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler();
                            handler.setMethod(method);
                            handler.setInstance(object);
                            HandlerMapping.addHandlerMapping(url,handler);
                        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MvcException(&quot;请求路径&quot;+ url + &quot;已经存在容器中&quot;&lt;span&gt;);
                        }
                    }
                }

            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessAfterInitialization(Object object, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; MvcException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.adminkk.factory;

import com.adminkk.exception.MvcException;

public class ServiceBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object object, String beanName) throws MvcException {
        //可自行扩展
        return null;
    }

    @Override
    public Object postProcessAfterInitialization(Object object, String beanName) throws MvcException {
        //可自行扩展
        return null;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.创建 DispatcherServlet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.adminkk.servlet;

import com.adminkk.handler.HandlerMapping;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = &quot;DispatcherServlet&quot;,loadOnStartup=1,urlPatterns={&quot;/&quot;})
public final  class DispatcherServlet extends HttpServlet {



    public static final String BASE_SCAN_URL = &quot;com.adminkk&quot;;

    //初始化容器
    @Override
    public void init() throws ServletException {
        doInit();
    }

    //处理业务请求
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doService(req,resp);
    }

    private void doService(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
        try {
            HandlerMapping.doService(req,resp);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServletException(e.getMessage());
        }
    }

    private void doInit() throws ServletException {
        try {     
            HandlerMapping.doInit(this.BASE_SCAN_URL);
        }catch (Exception e){
            e.printStackTrace();
            throw new ServletException(e.getMessage());
        }

    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;span&gt;　好了，目前为止我们就写好了简版的springmvc 下面开始测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.adminkk.controller;

import com.adminkk.annotation.Controller;
import com.adminkk.annotation.RequestMapping;


@Controller
@RequestMapping(&quot;/mvc&quot;)
public class MvcController {


    @RequestMapping(&quot;/index&quot;)
    public String index(){
        return  &quot;adminkk-mvc system is running&quot;;
    }


    @RequestMapping(&quot;/arg&quot;)
    public String parameter(String argOne, String argTwo){
        return  &quot;argOne = &quot; + argOne + &quot; argTwo = &quot; + argTwo;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　访问地址 http://localhost:8080/mvc/index&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094658/201810/1094658-20181020192721749-79101242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　访问地址: http://localhost:8080/mvc/arg?argOne=argOne&amp;amp;argTwo=argTwo&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094658/201810/1094658-20181020192747562-2041221449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;：整体实现简单的springmvc，设计上还可以扩展更多，难点在于method 获取方法上的参数名称，由于jdk1.8以前是不支持的，需要借用第三方工具 比如 asm javassist黑科技工具包来帮助实现，spring-core使用的是LocalVariableTableParameterNameDiscoverer底层是调用asm,我们这里使用的是javassist。延用这套思路还可以和spring项目结合，写一个 基于spring的springmvc项目&lt;/p&gt;
&lt;p&gt;源代码 ： https://gitee.com/chenchenche/mvc&lt;/p&gt;
&lt;p&gt;写博客不容易，希望大家多多提建议 &lt;/p&gt;
&lt;p&gt;下一篇预告 跟我一起造轮子 手写分布式im系统（上）&lt;/p&gt;

</description>
<pubDate>Sat, 20 Oct 2018 12:10:00 +0000</pubDate>
<dc:creator>XRom</dc:creator>
<og:description>作为java程序员，项目中使用到的主流框架多多少少和spring有关联，在面试的过程难免会问一些spring springmvc spring boot的东西，比如设计模式的使用、 怎么实现sprin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrog/p/9820168.html</dc:identifier>
</item>
<item>
<title>lombok 简化 Java 代码 - 辰砂tj</title>
<link>http://www.cnblogs.com/tojian/p/9822771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tojian/p/9822771.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: lombok 简化 Java 代码&lt;br/&gt;date: 2018-10-20 20:32:19&lt;br/&gt;tags: lombok&lt;br/&gt;author :辰砂tj&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;介绍&quot;&gt;1.介绍&lt;/h2&gt;
&lt;p&gt;Lombok 是一种 Java 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注解实现这一目的。Lombok官网：https://projectlombok.org&lt;/p&gt;
&lt;h2 id=&quot;idea使用&quot;&gt;2.idea使用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201810/1513801-20181020200241126-1313207598.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201810/1513801-20181020200249875-256614034.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;1.引入依赖&lt;/h3&gt;
&lt;p&gt;在项目中添加Lombok依赖jar，在pom文件中添加如下部分。(不清楚版本可以在Maven仓库中搜索)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.16.18&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;idea插件&quot;&gt;2.idea插件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181020195600516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDY2OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181020195631428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDY2OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注解的说明&quot;&gt;3.注解的说明&lt;/h2&gt;
&lt;h3 id=&quot;nonnull&quot;&gt;@NonNull&lt;/h3&gt;
&lt;p&gt;or: How I learned to stop worrying and love the NullPointerException.&lt;br/&gt;该注解使用在属性上，该注解用于属的非空检查，当放在setter方法的字段上，将生成一个空检查，如果为空，则抛出NullPointerException。&lt;br/&gt;该注解会默认是生成一个无参构造。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    @NonNull
    @Setter
    @Getter
    private String username;

    private boolean flag;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果测试的时候username为空的情况下结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.lang.NullPointerException: username
    at com.taojian.tblog.lombok.User.setUsername(User.java:28)
    at com.taojian.tblog.lombok.Test.main(Test.java:15)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cleanup&quot;&gt;@Cleanup&lt;/h3&gt;
&lt;p&gt;Automatic resource management: Call your close() methods safely with no hassle.&lt;br/&gt;该注解使用在属性前，该注解是用来保证分配的资源被释放。在本地变量上使用该注解，任何后续代码都将封装在try/finally中，确保当前作用于中的资源被释放。默认@Cleanup清理的方法为close，可以使用value指定不同的方法名称&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.*;

public class CleanupExample {
  public static void main(String[] args) throws IOException {
    InputStream in = new FileInputStream(args[0]);
    try {
      OutputStream out = new FileOutputStream(args[1]);
      try {
        byte[] b = new byte[10000];
        while (true) {
          int r = in.read(b);
          if (r == -1) break;
          out.write(b, 0, r);
        }
      } finally {
        if (out != null) {
          out.close();
        }
      }
    } finally {
      if (in != null) {
        in.close();
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.Cleanup;
import java.io.*;

public class CleanupExample {
  public static void main(String[] args) throws IOException {
    @Cleanup InputStream in = new FileInputStream(args[0]);
    @Cleanup OutputStream out = new FileOutputStream(args[1]);
    byte[] b = new byte[10000];
    while (true) {
      int r = in.read(b);
      if (r == -1) break;
      out.write(b, 0, r);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gettersetter&quot;&gt;@Getter/@Setter&lt;/h3&gt;
&lt;p&gt;Never write public int getFoo() {return foo;} again.&lt;br/&gt;@Getter 就相对于是属性的get()方法，@Setter就相当于属性的set()方法。&lt;/p&gt;
&lt;p&gt;The generated getter/setter method will be public unless you explicitly specify an AccessLevel, as shown in the example below. Legal access levels are PUBLIC, PROTECTED, PACKAGE, and PRIVATE.&lt;br/&gt;这句话的意思就是可以指定设置的getter，setter的方法的权限， @Setter(AccessLevel.PROTECTED) 这个就表示是一个protected属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @Setter(AccessLevel.PROTECTED) private String name;
 
   /**
   * Changes the name of this person.
   *
   * @param name The new value.
   */
  protected void setName(String name) {
    this.name = name;
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用前：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private String password;
    
    public Integer getUid() {
        return uid;
    }

    public String getUsername() {
        return username;
    }

    public String getPassword() {
        return password;
    }

    public void setUid(Integer uid) {
        this.uid = uid;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@Getter
@Setter
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private String password;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;tostring&quot;&gt;@ToString&lt;/h3&gt;
&lt;p&gt;No need to start a debugger to see your fields: Just let lombok generate a toString for you!&lt;/p&gt;
&lt;p&gt;1、如果需要可以通过注释参数includeFieldNames来控制输出中是否包含的属性名称。&lt;br/&gt;2、可以通过exclude参数中包含字段名称，可以从生成的方法中排除特定字段。&lt;br/&gt;3、可以通过callSuper参数控制父类的输出。&lt;/p&gt;
&lt;p&gt;@ToString(exclude=&quot;column&quot;)&lt;/p&gt;
&lt;p&gt;意义：排除column列所对应的元素，即在生成toString方法时不包含column参数；&lt;/p&gt;
&lt;p&gt;@ToString(exclude={&quot;column1&quot;,&quot;column2&quot;})&lt;/p&gt;
&lt;p&gt;意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数；&lt;/p&gt;
&lt;p&gt;@ToString(of=&quot;column&quot;)&lt;/p&gt;
&lt;p&gt;意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；&lt;/p&gt;
&lt;p&gt;@ToString(of={&quot;column1&quot;,&quot;column2&quot;})&lt;/p&gt;
&lt;p&gt;意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；&lt;/p&gt;
&lt;p&gt;使用前：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private String password;

    @Override
    public String toString() {
        return super.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ToString
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private String password;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;equalsandhashcode&quot;&gt;@EqualsAndHashCode&lt;/h3&gt;
&lt;p&gt;Equality made easy: Generates hashCode and equals implementations from the fields of your object..&lt;br/&gt;可以使用@EqualsAndHashCodelombok生成equals(Object other)和hashCode()方法的实现来注释任何类定义&lt;br/&gt;作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）&lt;br/&gt;使用前：&lt;/p&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
 import lombok.EqualsAndHashCode;

@EqualsAndHashCode
public class EqualsAndHashCodeExample {
  private transient int transientVar = 10;
  private String name;
  private double score;
  @EqualsAndHashCode.Exclude private Shape shape = new Square(5, 10);
  private String[] tags;
  @EqualsAndHashCode.Exclude private int id;
  
  public String getName() {
    return this.name;
  }
  // 因为有继承的关系，所以要设置true，如果没有，只继承了Object类的时候，就会报错
  
  @EqualsAndHashCode(callSuper=true)
  public static class Square extends Shape {
    private final int width, height;
    
    public Square(int width, int height) {
      this.width = width;
      this.height = height;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class EqualsAndHashCodeExample {
  private transient int transientVar = 10;
  private String name;
  private double score;
  private Shape shape = new Square(5, 10);
  private String[] tags;
  private int id;
  
  public String getName() {
    return this.name;
  }
  
  @Override public boolean equals(Object o) {
    if (o == this) return true;
    if (!(o instanceof EqualsAndHashCodeExample)) return false;
    EqualsAndHashCodeExample other = (EqualsAndHashCodeExample) o;
    if (!other.canEqual((Object)this)) return false;
    if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;
    if (Double.compare(this.score, other.score) != 0) return false;
    if (!Arrays.deepEquals(this.tags, other.tags)) return false;
    return true;
  }
  
  @Override public int hashCode() {
    final int PRIME = 59;
    int result = 1;
    final long temp1 = Double.doubleToLongBits(this.score);
    result = (result*PRIME) + (this.name == null ? 43 : this.name.hashCode());
    result = (result*PRIME) + (int)(temp1 ^ (temp1 &amp;gt;&amp;gt;&amp;gt; 32));
    result = (result*PRIME) + Arrays.deepHashCode(this.tags);
    return result;
  }
  
  protected boolean canEqual(Object other) {
    return other instanceof EqualsAndHashCodeExample;
  }
  
  public static class Square extends Shape {
    private final int width, height;
    
    public Square(int width, int height) {
      this.width = width;
      this.height = height;
    }
    
    @Override public boolean equals(Object o) {
      if (o == this) return true;
      if (!(o instanceof Square)) return false;
      Square other = (Square) o;
      if (!other.canEqual((Object)this)) return false;
      if (!super.equals(o)) return false;
      if (this.width != other.width) return false;
      if (this.height != other.height) return false;
      return true;
    }
    
    @Override public int hashCode() {
      final int PRIME = 59;
      int result = 1;
      result = (result*PRIME) + super.hashCode();
      result = (result*PRIME) + this.width;
      result = (result*PRIME) + this.height;
      return result;
    }
    
    protected boolean canEqual(Object other) {
      return other instanceof Square;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;noargsconstructor-requiredargsconstructor-and-allargsconstructor&quot;&gt;@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor&lt;/h3&gt;
&lt;p&gt;Constructors made to order: Generates constructors that take no arguments, one argument per final / non-nullfield, or one argument for every field.&lt;br/&gt;@NoArgsConstructor 相对于：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public User(){}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@RequiredArgsConstructor 该注解使用在类上，使用类中所有带有 @NonNull 注解的或者带有 final 修饰的成员变量生成对应的构造方法。&lt;/p&gt;
&lt;p&gt;@NoArgsConstructor 相对于：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public User(Integer uid, String username, boolean flag) {
        this.uid = uid;
        this.username = username;
        this.flag = flag;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;data&quot;&gt;@Data&lt;/h3&gt;
&lt;p&gt;All together now: A shortcut for @ToString, @EqualsAndHashCode, @Getter on all fields, and @Setter on all non-final fields, and @RequiredArgsConstructor!&lt;/p&gt;
&lt;p&gt;该注解使用在类上，该注解是最常用的注解，它结合了@ToString，@EqualsAndHashCode， @Getter和@Setter。本质上使用@Data注解，类默认@ToString和@EqualsAndHashCode以及每个字段都有@Setter和@getter。该注解也会生成一个公共构造函数，可以将任何@NonNull和final字段作为参数。&lt;/p&gt;
&lt;p&gt;虽然@Data注解非常有用，但是它没有与其他注解相同的控制粒度。@Data提供了一个可以生成静态工厂的单一参数，将staticConstructor参数设置为所需要的名称，Lombok自动生成的构造函数设置为私有，并提供公开的给定名称的静态工厂方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description:
 * @author: taojian
 * @create: 2018-09-30 22:32
 * 实际上含有这些方法
 * getUid
 * getUsername
 * isFlag 这里是isFlag()，而不是getFlag()
 * setUid
 * setUsername
 * setFlag
 * equals
 * hashCode
 * canEqual
 * toString
 **/
@Data
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private boolean flag;


@Data
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private boolean flag;

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;value&quot;&gt;@Value&lt;/h3&gt;
&lt;p&gt;Immutable classes made very easy.&lt;br/&gt;这个注解用在 类 上，会生成含所有参数的构造方法，get 方法，此外还提供了equals、hashCode、toString 方法。 注意：没有setter 类似@Data&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description:
 * @author: taojian
 * @create: 2018-09-30 22:32
 * User
 * getUid
 * getUsername
 * isFlag
 * equals
 * hashCode
 * toString
 * serialVersionUID
 * uid
 * username
 * flag
 **/

@Value
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private boolean flag;


}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;builder&quot;&gt;@Builder&lt;/h3&gt;
&lt;p&gt;... and Bob's your uncle: No-hassle fancy-pants APIs for object creation!&lt;br/&gt;Project Lombok的@Builder 是一种在不编写样板代码的情况下使用Builder模式的有用机制。我们可以将此注释应用于 类 或方法。&lt;/p&gt;
&lt;h4 id=&quot;在类上使用builder&quot;&gt;在类上使用@Builder&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * @description:
 * User
 * getUid
 * getUsername
 * isFlag
 * builder 这个方法是增加的方法
 **/

@Getter
@Builder
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer uid;

    private String username;

    private boolean flag;


}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class Test {
    public static void main(String[] args) {

        User  user = User.builder().username(&quot;taojian&quot;).flag(true).uid(1).build();
        System.out.println(user.getUsername().equals(&quot;taojian&quot;)); // true

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在方法上使用builder&quot;&gt;2. 在方法上使用@Builder&lt;/h4&gt;
&lt;p&gt;假设我们正在使用我们想要使用构建器构造的对象，但我们无法修改源或扩展类。&lt;/p&gt;
&lt;p&gt;首先，让我们使用Lombok的@Value注释创建一个快速示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Value
final class ImmutableClient {
    private int id;
    private String name;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们有一个带有两个不可变成员的最终 类，它们的getter和一个all-arguments构造函数。&lt;/p&gt;
&lt;p&gt;我们介绍了如何在Class上 使用@Builder，但我们也可以在方法上使用它。我们将使用此功能来解决无法修改或扩展ImmutableClient的问题。&lt;/p&gt;
&lt;p&gt;接下来，我们将使用创建ImmutableClients的方法创建一个新类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class ClientBuilder {
 
    @Builder(builderMethodName = &quot;builder&quot;)
    public static ImmutableClient newClient(int id, String name) {
        return new ImmutableClient(id, name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个注解创建了一个名为法生成器（）是返回一个生成器来创建ImmutableClients。&lt;/p&gt;
&lt;p&gt;现在我们可以构建一个ImmutableClient：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ImmutableClient testImmutableClient = ClientBuilder.builder()
  .name(&quot;foo&quot;)
  .id(1)
  .build();
assertThat(testImmutableClient.getName())
  .isEqualTo(&quot;foo&quot;);
assertThat(testImmutableClient.getId())
  .isEqualTo(1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sneakythrows&quot;&gt;@SneakyThrows&lt;/h3&gt;
&lt;p&gt;To boldly throw checked exceptions where no one has thrown them before!&lt;br/&gt;该注解使用在方法上，这个注解用在 方法 上，可以将方法中的代码用 try-catch 语句包裹起来，捕获异常并在 catch 中用 Lombok.sneakyThrow(e) 把异常抛出，可以使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常。该注解需要谨慎使用&lt;/p&gt;
&lt;p&gt;使用前：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
 import lombok.Lombok;

public class SneakyThrowsExample implements Runnable {
  public String utf8ToString(byte[] bytes) {
    try {
      return new String(bytes, &quot;UTF-8&quot;);
    } catch (UnsupportedEncodingException e) {
      throw Lombok.sneakyThrow(e);
    }
  }
  
  public void run() {
    try {
      throw new Throwable();
    } catch (Throwable t) {
      throw Lombok.sneakyThrow(t);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
 import lombok.SneakyThrows;

public class SneakyThrowsExample implements Runnable {
  @SneakyThrows(UnsupportedEncodingException.class)
  public String utf8ToString(byte[] bytes) {
    return new String(bytes, &quot;UTF-8&quot;);
  }
  
  @SneakyThrows
  public void run() {
    throw new Throwable();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;synchronized&quot;&gt;@Synchronized&lt;/h3&gt;
&lt;p&gt;synchronized done right: Don't expose your locks.&lt;br/&gt;该注解使用在类或者实例方法上，Synchronized在一个方法上，使用关键字可能会导致结果和想要的结果不同，因为多线程情况下会出现异常情况。Synchronized&lt;br/&gt;关键字将在this示例方法情况下锁定当前对象，或者class讲台方法的对象上多锁定。这可能会导致死锁现象。一般情况下建议锁定一个专门用于此目的的独立锁，而不是允许公共对象进行锁定。该注解也是为了达到该目的。&lt;/p&gt;
&lt;p&gt;使用前：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class SynchronizedExample {
  private static final Object $LOCK = new Object[0];
  private final Object $lock = new Object[0];
  private final Object readLock = new Object();
  
  public static void hello() {
    synchronized($LOCK) {
      System.out.println(&quot;world&quot;);
    }
  }
  
  public int answerToLife() {
    synchronized($lock) {
      return 42;
    }
  }
  
  public void foo() {
    synchronized(readLock) {
      System.out.println(&quot;bar&quot;);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mport lombok.Synchronized;

public class SynchronizedExample {
  private final Object readLock = new Object();
  
  @Synchronized
  public static void hello() {
    System.out.println(&quot;world&quot;);
  }
  
  @Synchronized
  public int answerToLife() {
    return 42;
  }
  
  @Synchronized(&quot;readLock&quot;)
  public void foo() {
    System.out.println(&quot;bar&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;log-slf4j&quot;&gt;@Log @Slf4j&lt;/h3&gt;
&lt;p&gt;Captain's Log, stardate 24435.7: &quot;What was that line again?&quot;&lt;br/&gt;日志类型&lt;br/&gt;experimental&lt;br/&gt;Head to the lab: The new stuff we're working on.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@CommonsLog
Creates private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);
@Flogger
Creates private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
@JBossLog
Creates private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);
@Log
Creates private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());
@Log4j
Creates private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);
@Log4j2
Creates private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);
@Slf4j
Creates private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);
@XSlf4j
Creates private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用前：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LogExample {
  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());
  
  public static void main(String... args) {
    log.severe(&quot;Something's wrong here&quot;);
  }
}

public class LogExampleOther {
  private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);
  
  public static void main(String... args) {
    log.error(&quot;Something else is wrong here&quot;);
  }
}

public class LogExampleCategory {
  private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(&quot;CounterLog&quot;);

  public static void main(String... args) {
    log.error(&quot;Calling the 'CounterLog' with a message&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用后：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.extern.java.Log;
import lombok.extern.slf4j.Slf4j;

@Log
public class LogExample {
  
  public static void main(String... args) {
    log.severe(&quot;Something's wrong here&quot;);
  }
}

@Slf4j
public class LogExampleOther {
  
  public static void main(String... args) {
    log.error(&quot;Something else is wrong here&quot;);
  }
}

@CommonsLog(topic=&quot;CounterLog&quot;)
public class LogExampleCategory {

  public static void main(String... args) {
    log.error(&quot;Calling the 'CounterLog' with a message&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考文章链接：&lt;/p&gt;
&lt;p&gt;https://www.baeldung.com/lombok-builder&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/motui/article/details/79012846&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/motui/article/details/79012846&lt;/p&gt;
&lt;p&gt;https://projectlombok.org/&lt;/p&gt;
&lt;p&gt;https://segmentfault.com/a/1190000005133786&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 12:04:00 +0000</pubDate>
<dc:creator>辰砂tj</dc:creator>
<og:description>title: lombok 简化 Java 代码 date: 2018 10 20 20:32:19 tags: lombok author :辰砂tj 1.介绍 Lombok 是一种 Java 实用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tojian/p/9822771.html</dc:identifier>
</item>
</channel>
</rss>