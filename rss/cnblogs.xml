<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从壹开始微服务 [ DDD ] 之五 ║聚合：实体与值对象 （上） - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9888502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9888502.html</guid>
<description>&lt;p&gt;哈喽，老张是周四放松又开始了，这些天的工作真的是繁重，三个项目同时启动，没办法，只能在深夜写文章了，现在时间的周四凌晨，白天上班已经没有时间开始写文章了，希望看到文章的小伙伴，能给个辛苦赞👍哈哈，当然看心情很随意。废话不多说，话说上次咱们对DDD简单说明了下存在的意义，还有就是基于教学上下文的第一次定义，今天咱们就继续说说DDD领域驱动设计中的聚合相关知识，聚合这一块比较多，我暂时决定用两到三篇文章来说说，今天就主要说一下“实体和值对象”的相关概念，其实之前我在定计划的时候，感觉这一块应该很好说，但是晚上吃完饭搜索资料的时候，发现真的好多人对实体理解的还好，但是对值对象真是各种不理解，甚至嗤之以鼻，这一点我感觉是不好的，希望我的读者不要只会说这个不好，那个不对，而是想，这个东西既然产生了，并且一直被大家说着，也有在使用的，肯定有存在的意义，举个栗子，可能今天大家看完对值对象还是蒙胧胧，多想想，多跟着DDD的思想走，也许就好多了，思想真的很难改变，不过只要努力了就是成功了。&lt;/p&gt;
&lt;p&gt;好！咱们还是开篇一个小问题，给大家正好一个思考的时间：&lt;/p&gt;
&lt;p&gt;咱们从壹大学的后台系统中，每个学生都有自己的家庭住址，肯定会有这样或那样的原因，会变化，那我们是如何设计 Student模型 和 Address 模型的呢，这里只是说代码实现上，数据库其实是对应的。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1、在Students实体中，添加家庭地址属性：省、市、县、街道；&lt;/p&gt;
&lt;p&gt;2、新建家庭地址Address实体，在Student中引入地址外键；&lt;/p&gt;
&lt;p&gt;3、新建 Students 、Address、StuAdd三个表，在Students中引入List&amp;lt;Address&amp;gt;，一对多；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个就是我们平时的思路，无论是第一种的一对一（一个学生一个家庭地址），还是第三种的一对多（一个学生多个家庭地址），如果你对这个思路很熟悉，那就需要好好看看今天的文章了，因为上边的这种还是面向数据库数据开发的，希望下边的说明，能让你对DDD的思想有一定的体验。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181101113152041-1911558235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div readability=&quot;15&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;实体对应的英语单词为Entity。提到实体，你可能立马就想到了代码中定义的实体类。在使用一些ORM框架时，比如Entity Framework，实体作为直接反映数据库表结构的对象，就更尤为重要。特别是当我们使用EF Code First时，我们首先要做的就是实体类的设计。在DDD中，实体作为领域建模的工具之一，也是十分重要的概念。&lt;/p&gt;
&lt;p&gt;但DDD中的实体和我们以往开发中定义的实体是同一个概念吗？&lt;br/&gt;不完全是。在以往未实施DDD的项目中，我们习惯于将关注点放在数据上，而非领域上。这也就说明了为什么我们在软件开发过程中会首先做数据库的设计，进而根据数据库表结构设计相应的实体对象，这样的实体对象是数据模型转换的结果。&lt;br/&gt;在DDD中，实体作为一个领域概念，在设计实体时，我们将从领域出发。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;1、DDD中的实体是什么&lt;/h3&gt;
许多对象不是由它们的属性来定义，而是通过一系列的连续性（continuity）和标识（identity）来从根本上定义的。只要一个对象在生命周期中能够保持连续性，并且独立于它的属性（即使这些属性对系统用户非常重要），那它就是一个实体。&lt;/div&gt;
&lt;div readability=&quot;106.00361830001&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;对于实体Entity，实体核心是用唯一的标识符来定义，而不是通过属性来定义。即即使属性完全相同也可能是两个不同的对象。同时实体本身有状态的，实体又演进的生命周期，实体本身会体现出相关的业务行为，业务行为会实体属性或状态造成影响和改变。&lt;/p&gt;
&lt;p&gt;如果从值对象本身无状态，不可变，并且不分配具体的标识层面来看。那么值对象可以仅仅理解为实际的Entity对象的一个属性结合而已。该值对象附属在一个实际的实体对象上面。值对象本身不存在一个独立的生命周期，也一般不会产生独立的行为。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;2、为什么要使用实体&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;当我们需要考虑一个对象的个性特征，或者要区分不同对象的时候，我们就需要一个实体这个领域概念，一个实体是一个唯一的东西，并且可以长时间相当长的一段时间内持续的变化，但是无论我们做了多少变化，这个的实体对象可能也已经变化的很多了，但是因为他们都一个相同的身份标识，所有还是同一个实体。很简单，就好像一个学生，无论手机号，姓名，年龄，邮箱，是否毕业等等，全部变化了，因为唯一标识的原因，我们就可以认为，变化前后的所有对象，都是同一个实体。随着对象的改变，我们可能会一直跟踪变化过程，什么时候，什么人，发生了什么变化：就比如学生因为学习太好，学校研究通过，提前毕业，更新状态为已毕业等。&lt;/p&gt;
&lt;p&gt;这个时候我们发现了，实体的两大特性：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、有唯一的标识，不受状态属性的影响。&lt;/p&gt;
&lt;p&gt;2、可变性特征，状态信息一直可以变化。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt; 在我们之前的代码中，我们定义了 Student 模型，我们是在当前模型中，添加了唯一标识 &lt;/p&gt;
&lt;div readability=&quot;41&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    public class Student
    {
        protected Student() { }
        public Student(Guid id, string name, string email, DateTime birthDate)
        {
            Id = id;
            Name = name;
            Email = email;
            BirthDate = birthDate;
        }

        public Guid Id { get; private set; }//模型的唯一标识
        public string Name { get; private set; }
        public string Email { get; private set; }
        public string Phone { get; private set; }
        public DateTime BirthDate { get; private set; }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们平时用到的标识都是 Int 类型，优点是占位少，内存小等，当然有时候受到长度的影响，我们就用 long，&lt;/p&gt;
&lt;h3&gt;1、唯一标识都是什么类型&lt;/h3&gt;
&lt;p&gt;　　一般我们都是会倾向于使用int类型，映射到数据库中的自增长int。它的优势是简单，唯一性由数据库保障，占用空间小，查询速度快。我之前也采用了很长时间，大部分时候很好用，不过偶尔会很头痛。由于实体标识需要等到插入数据库之后才创建出来，所以你在保存之前不可能知道标识值是多少，如果在保存之前需要拿到Id,唯一的方法是先插入数据库，得到Id以后，再执行另外的操作，换句话说，需要把本来是同一个事务中的操作分成多个事务执行。除了这个问题，还有多个数据库表合并的问题，如果两个分表都是自增，那肯定需要单独再一个字段来做标识，劳民伤财。&lt;/p&gt;
&lt;p&gt;后来我就用string字符串来设置主键，最大的问题就出现了，就是有时候会出现一致的情况，倒是保存失败，然后用户反馈，当测试的时候，又好了，这种幽灵事件。所以我就决定使用 Guid 了。&lt;/p&gt;
&lt;p&gt;　　它的主要优势是生成Guid非常容易，不论是Js,C#还是在数据库中，都能轻易的生成出来。另外，Guid的唯一性很强，基本不可能生成出两个相同的Guid。&lt;/p&gt;
&lt;p&gt;　　Guid类型的主要缺点是占用空间太大。另外实体标识一般映射到数据库的主键，而Sql Server会默认把主键设成聚集索引，由于Guid的不连续性，这可能导致大量的页拆分，造成大量碎片从而拖慢查询。一个解决办法是使用Sql Server来生成Guid，它可以生成连续的Guid值，但这又回到了老路，只有插入数据库你才知道具体的Id值，所以行不通。另一个解决办法是把聚集索引移到其它列上，比如创建时间。如果你打算把聚集索引继续放到Guid标识列上，可以观察到碎片一般都在90%以上，写一个Sql脚本，定时在半夜整理一下碎片，也算一个勉强的办法。&lt;/p&gt;
&lt;p&gt;　　如果生成一个有意义的流水号来作为标识，这时候标识类型就是一个字符串。&lt;/p&gt;
&lt;p&gt;　　有些时候可能还要使用更复杂的组合标识，这一般需要创建一个值对象作为标识类型。&lt;/p&gt;
&lt;p&gt;既然每个实体都有一个标识，那么为所有实体创建一个基类就显得很有用了，这个基类就是层超类型，它为所有领域实体提供基础服务。&lt;/p&gt;

&lt;h3&gt;2、创建领域核心类库，并添加实体&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;在领域驱动设计中，我们会有一些核心的公共的核心内容，所以类库 Christ.Domain.Core 就是起到的这个作用，除了领域模型外，还有以后的事件、命令和通知等核心内容类。&lt;/p&gt;
&lt;p&gt;因为实体属于领域模型内容，所以我们新建一个 Models 文件夹，并在其新建 Entity.cs 文件&lt;/p&gt;
&lt;p&gt;这个时候，如果你问我，为什么要单单定义一个 Entity 基类，而不把 Id 放到每一个实体中，嗯，那就是还没有命名领域设计中，基于业务的考虑，我们平时都是直接用面向数据库数据的思想来考虑的，duang duang设计表结构，自然而然的想到每一个表（实体模型）必须有一个Id，但是现在，我们是基于业务考虑的，每一个业务下边会有子领域，然后每个子领域都是聚合的，通过一个聚合根来关联，把相似的功能或者根单独拿出来，这个就是实体基类 Entity 的作用，当然除了 Id 还会有一些方法，比如以下：&lt;/p&gt;

&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
namespace Christ.Domain.Core.Models
{
    /// &amp;lt;summary&amp;gt;
    /// 定义领域实体基类
    /// &amp;lt;/summary&amp;gt;
    public abstract class Entity
    {
        /// &amp;lt;summary&amp;gt;
        /// 唯一标识
        /// &amp;lt;/summary&amp;gt;
        public Guid Id { get; protected set; }

        /// &amp;lt;summary&amp;gt;
        /// 重写方法 相等运算
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;obj&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override bool Equals(object obj)
        {
            var compareTo = obj as Entity;

            if (ReferenceEquals(this, compareTo)) return true;
            if (ReferenceEquals(null, compareTo)) return false;

            return Id.Equals(compareTo.Id);
        }
        /// &amp;lt;summary&amp;gt;
        /// 重写方法 实体比较 ==
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;a&quot;&amp;gt;领域实体a&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;b&quot;&amp;gt;领域实体b&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static bool operator ==(Entity a, Entity b)
        {
            if (ReferenceEquals(a, null) &amp;amp;&amp;amp; ReferenceEquals(b, null))
                return true;

            if (ReferenceEquals(a, null) || ReferenceEquals(b, null))
                return false;

            return a.Equals(b);
        }
        /// &amp;lt;summary&amp;gt;
        /// 重写方法 实体比较 !=
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;a&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;b&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static bool operator !=(Entity a, Entity b)
        {
            return !(a == b);
        }
        /// &amp;lt;summary&amp;gt;
        /// 获取哈希
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override int GetHashCode()
        {
            return (GetType().GetHashCode() * 907) + Id.GetHashCode();
        }
        /// &amp;lt;summary&amp;gt;
        /// 输出领域对象的状态
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override string ToString()
        {
            return GetType().Name + &quot; [Id=&quot; + Id + &quot;]&quot;;
        }
       
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181101132042828-1111973572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、实体模型继承该Entity&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt; 修改我们的 Student 模型，继承 Entity，并把属性 Id 去掉。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181101132318853-1396864375.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;这个时候，我们就已经把实体说完了，其实很简单，我们平时也都在用，总结来说以下两点：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、实体的2大特性：唯一标识、可变性特性；&lt;/p&gt;
&lt;p&gt;2、通过业务的思维，去思考为什么定义 Entity 的作用，主要也是起到了一个聚合的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那实体我们现在已经理解了它的概念，作用，产生以及意义，剩下的还有一个是实体验证支持，这个以后再说到，说到了实体，与之对应的是值对象，那值对象又是什么呢？请往下看。&lt;/p&gt;


&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;前面介绍了DDD分层架构的实体，并完成了实体层超类型的开发（ 就是Entity ），本篇将介绍另一个重要的构造块——值对象，它是聚合中的主要成分。在我们之前的开发中，因为是基于数据库数据的，所以我们基本都是通过数据表来建立模型，这就是数据建模，然后依赖的是数据库范式设计，这样我们就把每一个数据库表就对应一个实体模型，每一个表字段就对应应该实体属性。&lt;/p&gt;
&lt;p&gt;在看我们文章开头的那个问题，我们就常常用第一种方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student : Entity
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Student() { }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Student(Guid id, &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; email, DateTime birthDate)
        {
            Id &lt;/span&gt;=&lt;span&gt; id;
            Name &lt;/span&gt;=&lt;span&gt; name;
            Email &lt;/span&gt;=&lt;span&gt; email;
            BirthDate &lt;/span&gt;=&lt;span&gt; birthDate;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public Guid Id { get; private set; }&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 姓名
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮箱
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 手机
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生日
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime BirthDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 省份
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Province { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 城市
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; City { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 区县
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; County { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 街道
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Street { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
     
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，为了考虑不该有的属性，比如家庭地址信息，不应该出现在学生student的业务模型中，我们就拆开，用两个实体进行表示，然后引入外键，就是我们第二种方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student : Entity
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.....其他属性&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 地址外键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Address&lt;/span&gt; Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
     
    }


    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 地址
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Address ：Entity {&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 省份
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Province { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 城市
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; City { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　可以看到，对于这样的简单场景，一般有两个选择，要么把属性放到外部的实体中，只创建一张表，要么建立两个实体，并相应的创建两张表。第一种方法的缺点是，全部属性值放到一切，没有了整体业务概念，不仅无法表达业务语义，而且使用起来非常困难，同时将很多不必要的业务知识泄露到调用端。第二种方法的问题是导致了不必要的复杂性。&lt;/p&gt;
&lt;p&gt;　　更好的方法很简单，就是把以上两种方法结合起来。我们通过把地址建模成值对象，而不是实体，然后把值对象的属性值嵌入外部员工实体的表中，这种映射方式被称为&lt;strong&gt;嵌入值&lt;/strong&gt;模式。换句话说，你现在的数据库表采用上面的第一种方式定义，而你在c#代码中通过第二种方式使用，只是把实体改成值对象。这样做的好处是显而易见的，既将业务概念表达得清楚，而且数据库也没有变得复杂。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt; 1、值对象的概念&lt;/h3&gt;
&lt;p&gt; 值对象虽然有时候和实体特别想象，看上边的学校家庭信息就可得知，但是它却有着自己独有的好处，值对象很常见：比如数字，字符串，日期时间，甚至一个人的信息，邮寄地址等等，当然还有更复杂的值对象，这些都是反映 通用语言 概念的值对象。&lt;/p&gt;
&lt;p&gt;我们应该尽量使用值对象来建模，而不是实体对象，你可能很想不通，即使上边的学生的家庭地址信息，你一定要单放一个数据库表，构建实体模型，在设计的时候我们应该也要更偏向作为一个值对象容器，而不是子实体容器，因为这样我们可以对值对象很好的创建，测试，使用，优化和维护。&lt;/p&gt;

&lt;p&gt;当你决定一个领域概念是否是一个值对象的时候，你需要考虑它是否有以下特性：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;1、它描述了领域中的一个东西&lt;/p&gt;
&lt;p&gt;2、可以作为一个不变量。&lt;/p&gt;
&lt;p&gt;3、当它被改变时，可以用另一个值对象替换。&lt;/p&gt;
&lt;p&gt;4、可以和别的值对象进行相等性比较。&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;在值对象中，我们不关心标识，只要我们能确定该值对象的属性值都一样，我们就可以说这两个值对象是相同的，比如我们说两个学生的家庭地址（省市县街道门排）是一样的，我们就可以认为是同一个地址，这就是相等性比较。&lt;/p&gt;
&lt;p&gt;如果学生在修改地址的时候，我们不是仅仅的修改省，或者市，或者县，而且将整个值对象给覆盖，这个就是值对象的不变性和可替换性。&lt;/p&gt;


&lt;h3&gt;1、创建值对象基类&lt;/h3&gt;
&lt;p&gt;在 Christ3D.Domain.Core 类库下的Models文件夹中，新建 ValueObject.cs&lt;/p&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Core.Models
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义值对象基类 
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注意没有唯一标识了
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ValueObject&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : ValueObject&amp;lt;T&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写方法 相等运算
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; valueObject = obj &lt;span&gt;as&lt;/span&gt;&lt;span&gt; T;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !ReferenceEquals(valueObject, &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; EqualsCore(valueObject);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; EqualsCore(T other);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取哈希
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetHashCode()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetHashCodeCore();
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetHashCodeCore();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写方法 实体比较 ==
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;b&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; ==(ValueObject&amp;lt;T&amp;gt; a, ValueObject&amp;lt;T&amp;gt;&lt;span&gt; b)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ReferenceEquals(a, &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; ReferenceEquals(b, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ReferenceEquals(a, &lt;span&gt;null&lt;/span&gt;) || ReferenceEquals(b, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.Equals(b);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写方法 实体比较 !=
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;b&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; !=(ValueObject&amp;lt;T&amp;gt; a, ValueObject&amp;lt;T&amp;gt;&lt;span&gt; b)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !(a ==&lt;span&gt; b);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 克隆副本
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; T Clone()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T)MemberwiseClone();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、在 Christ3D.Domain 类库下的Models文件夹中，新建 Address 值对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Models
{

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Address(&lt;span&gt;string&lt;/span&gt; province, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; city,
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; county, &lt;span&gt;string&lt;/span&gt; street, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; zip)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Province =&lt;span&gt; province;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.City =&lt;span&gt; city;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.County =&lt;span&gt; county;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Street =&lt;span&gt; street;
        }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 地址
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Address : ValueObject&amp;lt;Address&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 省份
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Province { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 城市
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; City { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 区县
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; County { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 街道
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Street { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
   

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; EqualsCore(Address other)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetHashCodeCore()
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，我们的Address就具有了值的特征，我们可以直接使用Address address = new Address(&quot;北京市&quot;, &quot;北京市&quot;, &quot;海淀区&quot;, &quot;一路 &quot;);)来表示一个具体的通过属性识别的不可变的位置概念。在DDD中，我们称这个Address为值对象。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; 
&lt;h3&gt;3、实体与值对象的区别：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;实体拥有标识，而值对象没有。&lt;/li&gt;
&lt;li&gt;相等性测试方式不同。实体根据标识判等，而值对象根据内部所有属性值判等。&lt;/li&gt;
&lt;li&gt;实体允许变化，值对象不允许变化。&lt;/li&gt;
&lt;li&gt;持久化的映射方式不同。实体采用单表继承、类表继承和具体表继承来映射类层次结构，而值对象使用嵌入值或序列化大对象方式映射。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;


&lt;p&gt;今天因为时间的问题暂时就说这么多吧，这里只是把 实体 和值对象的概念和使用说明了下，具体的好处和强大的优势还没有来得及说，下一篇文章，我会说继续说聚合的内容，包括实体验证等，这篇文章也需要慢慢的润润色，加油吧&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/ChristDDD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/ChristDDD&lt;/a&gt; &lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 01 Nov 2018 07:38:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>前言 哈喽，老张是周四放松又开始了，这些天的工作真的是繁重，三个项目同时启动，没办法，只能在深夜写文章了，现在时间的周四凌晨，白天上班已经没有时间开始写文章了，希望看到文章的小伙伴，能给个辛苦赞</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9888502.html</dc:identifier>
</item>
<item>
<title>【ASP.NET Core】EF Core -  “导航属性” - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/9882099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/9882099.html</guid>
<description>&lt;p&gt;“导航属性”是实体框架用得算是比较频繁的概念。&lt;/p&gt;
&lt;p&gt;首先，它是类型成员，其次，他是属性，这不是 F 话，而是明确它的本质。那么，什么场景下会用到导航属性呢？重点就落在“导航”一词上了，当实体 A 需要引用实体 B 时，实体 A 中需要公开一个属性，通过这个属性，能找到关联的实体 B。&lt;/p&gt;
&lt;p&gt;又或者，X 实体表示你的博客，P 实体表示你发的一篇博文。你的博客肯定会发很多博文的，所以，X 实体中可能需要一个 List&amp;lt;P&amp;gt; 类型的属性，这个属性包含了你的博客所发表的文章。&lt;em&gt;&lt;strong&gt;通过一个实体的属性成员，可以定位到与之有关联的实体，这就是导航的用途了&lt;/strong&gt;&lt;/em&gt;。就像你开着车去穿越神农架一样，迷路了就打开高德导航（前提是不存在定位干扰）。&lt;/p&gt;
&lt;p&gt;现在跑江湖的人多，通过各种江湖骗术发家致富。有了不正常的财富积累后，他们开始大量买车，还买地打造个人车库。于是，Person 实体代表这些有钱人，CarData 实体表示他们买的各种壕车。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;CarData&amp;gt; Cars { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;; }
&lt;/strong&gt;&lt;/em&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarData
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid CarID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CarAttribute { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Cost { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个 Person 都有 Cars 属性，表示各自所购买的车。这个 Cars 就是导航属性，通过这个属性能找到关联的 CarData 实体。&lt;/p&gt;
&lt;p&gt;再定义一个数据上下文类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Person&amp;gt;&lt;span&gt; Persons
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; Set&amp;lt;Person&amp;gt;&lt;span&gt;(); }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;公开一个 Persons 属性，便于访问，当然了，你觉得我那样写代码太多，你可以直接来这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Person&amp;gt; Persons { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两种写法都是可以的。&lt;/p&gt;
&lt;p&gt;这一次，我选择用 SQLite 数据库，新的 .net core 框架没有包含访问 SQLIte 的程序集，不过没关系，有 Nuget 啥都能裹进来。怎么安装 nuget 包就不用我教了，你会的。最简单不粗暴的方法就是直接在 nuget 控制台中执行 install-package 命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PM&amp;gt; install-package microsoft.entityframeworkcore.sqlite
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到下面这一堆东东就说明完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367389/201810/367389-20181031113943928-587604164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;回到 MyContext 类，进行一下连接字符串的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source=TMD.db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重写 OnConfiguring 方法，再调用 UseSqlite 扩展方法，就可以设置连接字符串了。&lt;/p&gt;
&lt;p&gt;还要重写 OnModelCreating 方法，要做两件事情：一是为每个实体设置主键；二是为两个实体建立关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置主键&lt;/span&gt;
            modelBuilder.Entity&amp;lt;Person&amp;gt;().HasKey(p =&amp;gt;&lt;span&gt; p.PID);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;CarData&amp;gt;().HasKey(c =&amp;gt;&lt;span&gt; c.CarID);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射实体关系，一对多&lt;/span&gt;
            modelBuilder.Entity&amp;lt;Person&amp;gt;().HasMany(p =&amp;gt;&lt;span&gt; p.Cars);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在本例中，你懂的，一个人可以有 N 辆车，因此 Person 与 CarData 之间是“一对多”的关，故而实体 Person 可以 HasMany 个 CarData 对象，其中，Cars 即是导航属性。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;注意：由于 MyContext 类重写了 OnConfiguring 方法，所以，在 MyContext 类的构造函数中，无需接收 DbContextOptions&amp;lt;MyContext&amp;gt; 的依赖注入 ，在 Startup.ConfigureServices 方法中也无需再调用 UseSqlite 方法，你只需 Add 一下就可以了。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;em&gt;&lt;strong&gt;services.AddDbContext&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&amp;lt;MyContext&amp;gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;();
&lt;/strong&gt;&lt;/em&gt;            services.AddMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在 Main 入口点中，先创建 host 实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHostBuilder()
                .UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseEnvironment(EnvironmentName.Development)
                .UseUrls(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7552&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，不要急着调用 Run 方法。因为咱们还没创建数据库呢。当然，你可以用老周上一篇中介绍的方法，在 nuget 控制台中，用 Add-Migration 命令添加迁移，然后用 Update-Database 命令创建数据库。不过，本文中，老周将通过代码在运行阶段创建数据库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (IServiceScope scope =&lt;span&gt; host.Services.CreateScope())
            {
                MyContext cxt &lt;/span&gt;= scope.ServiceProvider.GetRequiredService&amp;lt;MyContext&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cxt.Database.EnsureCreated())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入一些记录&lt;/span&gt;
                    Person p1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王老三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Age &lt;/span&gt;= &lt;span&gt;65&lt;/span&gt;&lt;span&gt;,
                        Cars &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;CarData&amp;gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                            {
                                CarAttribute&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;黄色兰博基尼&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                Cost &lt;/span&gt;= &lt;span&gt;1500020002.00M&lt;/span&gt;&lt;span&gt;
                            },
                            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                            {
                                CarAttribute &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;景泰蓝 吉利瑞博GE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                Cost &lt;/span&gt;=&lt;span&gt; 138_000M
                            }
                        }
                    };
                    cxt.Persons.Add(p1);
                    Person p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;朱大日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Age &lt;/span&gt;= &lt;span&gt;72&lt;/span&gt;&lt;span&gt;,
                        Cars &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;CarData&amp;gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                            {
                                CarAttribute &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;玛瑙红 别克VELITE 5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                Cost &lt;/span&gt;=&lt;span&gt; 289_500M
                            },
                            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                            {
                                CarAttribute &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;雅韵金 本田INSPIRE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                Cost &lt;/span&gt;=&lt;span&gt; 171000M
                            },
                           &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                           {
                               CarAttribute &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;奥迪A4L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                               Cost &lt;/span&gt;=&lt;span&gt; 401000M
                           }
                        }
                    };
                    cxt.Persons.Add(p2);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新到数据库&lt;/span&gt;
&lt;span&gt;                    cxt.SaveChanges();
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IServiceScope 是个有趣的玩意儿，它创建一个基于当前作用域的服务列表，从该对象中获取的服务实例，其生命周期只在当前 scope 中有效。这特别适用于临时实例化服务的情景。比如这里，MyContext 只是暂时实例化，等创建数据库并写入测试数据后，就可以 Dispose 了。&lt;/p&gt;
&lt;p&gt;初始化数据库后，可以运行 host 了。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
        host.Run();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;添加一个控制器，为了简单，咱们不创建 View 了，就直接返回 JSON 数据好了，就当 Web API 来使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController : Controller
    {
        &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; MyContext context;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestController(MyContext c)
        {
            context &lt;/span&gt;=&lt;span&gt; c;
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ListData()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(context.Persons);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在可以运行了，用诸如 Postman 等测试工具，请求 &amp;lt;root url&amp;gt;/test/listdata，结果发现惊人一幕。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
        &lt;/span&gt;&quot;pid&quot;: 1&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;王老三&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;age&quot;: 65&lt;span&gt;,
        &lt;/span&gt;&quot;cars&quot;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    },
    {
        &lt;/span&gt;&quot;pid&quot;: 2&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;朱大日&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;age&quot;: 72&lt;span&gt;,
        &lt;/span&gt;&quot;cars&quot;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我相信，很多人都遇到了这个问题，所以，本文老周也顺便解释一下这个问题。如你所见，cars 属性是 null，明明是添加了 CarData 对象的，为啥会 null，你是不是开始怀疑人生了？千万不要轻易怀疑人生，那样是很不负责任的。&lt;/p&gt;
&lt;p&gt;好，不卖关子了。出现这个问题，是因为导航属性的状态在默认情况下不会自动去还原的，不然的话，会增加对象引用，所以默认是不加载的。那么，你会问，那么 CarData 实体的数据记录到底加载了没？加载了的，你可以写一个 Action 去试试的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult CarList()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cars = context.Set&amp;lt;CarData&amp;gt;&lt;span&gt;().ToList();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(cars);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，你访问一下 &amp;lt;root url&amp;gt;/test/carlist，看看下面的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
        &lt;/span&gt;&quot;carID&quot;: &quot;36e97ed0-56b1-4d92-bb2d-aeec9f9e1b43&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;黄色兰博基尼&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 1500020002&lt;span&gt;
    },
    {
        &lt;/span&gt;&quot;carID&quot;: &quot;0fd6c2a0-d4ef-4838-bc08-43a5cb024eef&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;景泰蓝 吉利瑞博GE&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 138000&lt;span&gt;
    },
    {
        &lt;/span&gt;&quot;carID&quot;: &quot;c9eb20c8-931e-4563-b380-cbee926015c8&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;玛瑙红 别克VELITE 5&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 289500&lt;span&gt;
    },
    {
        &lt;/span&gt;&quot;carID&quot;: &quot;3d563693-5ae0-4682-bd53-c7fc87e951de&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;雅韵金 本田INSPIRE&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 171000&lt;span&gt;
    },
    {
        &lt;/span&gt;&quot;carID&quot;: &quot;2294a556-fd02-49c3-b4b2-559f15413e75&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;奥迪A4L&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 401000&lt;span&gt;
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我没骗你吧，有数据的呀。&lt;/p&gt;
&lt;p&gt;现在我们有这个需求，要求还原导航属性的状态，那咋办呢？再次回到 ListData 方法，把它改成这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ListData()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; persons = context.Persons.&lt;em&gt;&lt;strong&gt;Include(p =&amp;gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; p.Cars)&lt;/strong&gt;&lt;/em&gt;.ToList();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(persons);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用 Include 方法记得引入 Microsoft.EntityFrameworkCore 命名空间，这个不用我多说了。Incluse 扩展方法的意思就是加载导航属性中的内容，它会自动还原状态，知道哪些 CarData 实例与 Person 实例有关。&lt;/p&gt;
&lt;p&gt;再次运行，请求一下 &amp;lt;root url&amp;gt;/test/listdata，这下你就放心了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
        &lt;/span&gt;&quot;pid&quot;: 1&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;王老三&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;age&quot;: 65&lt;span&gt;,
        &lt;/span&gt;&quot;cars&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;carID&quot;: &quot;36e97ed0-56b1-4d92-bb2d-aeec9f9e1b43&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;carAttribute&quot;: &quot;黄色兰博基尼&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;cost&quot;: 1500020002&lt;span&gt;
            },
            {
                &lt;/span&gt;&quot;carID&quot;: &quot;0fd6c2a0-d4ef-4838-bc08-43a5cb024eef&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;carAttribute&quot;: &quot;景泰蓝 吉利瑞博GE&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;cost&quot;: 138000&lt;span&gt;
            }
        ]
    },
    {
        &lt;/span&gt;&quot;pid&quot;: 2&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;朱大日&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;age&quot;: 72&lt;span&gt;,
        &lt;/span&gt;&quot;cars&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;carID&quot;: &quot;c9eb20c8-931e-4563-b380-cbee926015c8&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;carAttribute&quot;: &quot;玛瑙红 别克VELITE 5&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;cost&quot;: 289500&lt;span&gt;
            },
            {
                &lt;/span&gt;&quot;carID&quot;: &quot;3d563693-5ae0-4682-bd53-c7fc87e951de&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;carAttribute&quot;: &quot;雅韵金 本田INSPIRE&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;cost&quot;: 171000&lt;span&gt;
            },
            {
                &lt;/span&gt;&quot;carID&quot;: &quot;2294a556-fd02-49c3-b4b2-559f15413e75&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;carAttribute&quot;: &quot;奥迪A4L&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;cost&quot;: 401000&lt;span&gt;
            }
        ]
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎么样，满意了吧。&lt;/p&gt;

&lt;p&gt;接下来，咱们再看看反过来的情况，咋返过来呢？我们假设以汽车为主，现在是每辆车都对应着一位车主信息，每个人只与一辆车关联，所以，车与人之间是“一对一”的关系。&lt;/p&gt;
&lt;p&gt;先定义实体类，结构与前面的差不多。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarData
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CarID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CarAttribute { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Cost { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person Owner { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一次，如你所见，导航属性是 CarData 类的 Owner 属性，即该车的车主信息，引用一个 Person 实例。&lt;/p&gt;
&lt;p&gt;下面定义 DbContext。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Person&amp;gt; Persons { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;CarData&amp;gt; Cars { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重写 OnModelCreating 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;/span&gt;&amp;lt;Person&amp;gt;().HasKey(p =&amp;gt;&lt;span&gt; p.PID);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;CarData&amp;gt;().HasKey(c =&amp;gt;&lt;span&gt; c.CarID);

           &lt;em&gt;&lt;strong&gt; modelBuilder.Entity&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&amp;lt;CarData&amp;gt;().HasOne(c =&amp;gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; c.Owner);
&lt;/strong&gt;&lt;/em&gt;        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了每两个实体设置主键外，请注意看最后一行，这一次，CarData 实体只对应着一个 Person 实例，所以是 HasOne，导航属性是 Owner。&lt;/p&gt;
&lt;p&gt;重写 OnConfiguring 方法，配置连接字符串，这一次就用 SQL Server LocalDB，轻量级的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=(localdb)\\MSSQLLocalDB;database=DemoDt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main 方法中的做法与前面一样，初始化 WebHost 后，先创建数据库，填一下垃圾数据，然后再启动 host。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHostBuilder()
                .UseKestrel()
                .UseEnvironment(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseUrls(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:19230&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .Build();

            &lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;using&lt;/span&gt;(IServiceScope scope =&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; host.Services.CreateScope())
&lt;/strong&gt;&lt;/em&gt;            {
                MyContext cxt &lt;/span&gt;= scope.ServiceProvider.GetRequiredService&amp;lt;MyContext&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;em&gt;&lt;strong&gt;cxt.Database.EnsureCreated()&lt;/strong&gt;&lt;/em&gt;)
                {
                    Person p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王阿基&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    Person p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;刘二打&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    Person p3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person
                    {
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李无牙&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    CarData c1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                    {
                        CarAttribute &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;三无产品 A款&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Cost &lt;/span&gt;=&lt;span&gt; 150000M,
                        Owner &lt;/span&gt;=&lt;span&gt; p1
                    };
                    CarData c2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                    {
                        CarAttribute &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;三无产品 F款&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Cost &lt;/span&gt;=&lt;span&gt; 67500M,
                        Owner &lt;/span&gt;=&lt;span&gt; p2
                    };
                    CarData c3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CarData
                    {
                        CarAttribute &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;三无产品 2018款&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Cost &lt;/span&gt;=&lt;span&gt; 76000M,
                        Owner &lt;/span&gt;=&lt;span&gt; p3
                    };
                   &lt;em&gt;&lt;strong&gt; cxt.Persons.Add(p1);
                    cxt.Persons.Add(p2);
                    cxt.Persons.Add(p3);
                    cxt.Cars.Add(c1);
                    cxt.Cars.Add(c2);
                    cxt.Cars.Add(c3);
                    cxt.SaveChanges();&lt;/strong&gt;&lt;/em&gt;
                }
            }

            host.Run();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，创建一个控制器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SampleController : Controller
    {
    }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过依赖注入，获得 MyContext 实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; MyContext context;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SampleController(MyContext cxt)
        {
            context &lt;/span&gt;=&lt;span&gt; cxt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义一个获取数据列表的 Action。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult List()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cars = context.Cars.Include(c =&amp;gt;&lt;span&gt; c.Owner);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(cars.ToList());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Include 方法的调用与前面一样，只是注意这次是以 CarData 实体为主，顺便加载导航属性 Owner 的内容。&lt;/p&gt;
&lt;p&gt;Postman 测试结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
        &lt;/span&gt;&quot;carID&quot;: 1&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;三无产品 A款&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 150000&lt;span&gt;,
        &lt;/span&gt;&quot;owner&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;pid&quot;: 1&lt;span&gt;,
            &lt;/span&gt;&quot;name&quot;: &quot;王阿基&quot;&lt;span&gt;
        }
    },
    {
        &lt;/span&gt;&quot;carID&quot;: 2&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;三无产品 F款&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 67500&lt;span&gt;,
        &lt;/span&gt;&quot;owner&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;pid&quot;: 2&lt;span&gt;,
            &lt;/span&gt;&quot;name&quot;: &quot;刘二打&quot;&lt;span&gt;
        }
    },
    {
        &lt;/span&gt;&quot;carID&quot;: 3&lt;span&gt;,
        &lt;/span&gt;&quot;carAttribute&quot;: &quot;三无产品 2018款&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cost&quot;: 76000&lt;span&gt;,
        &lt;/span&gt;&quot;owner&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;pid&quot;: 3&lt;span&gt;,
            &lt;/span&gt;&quot;name&quot;: &quot;李无牙&quot;&lt;span&gt;
        }
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，这也达到预期的效果了。&lt;/p&gt;

&lt;p&gt;我们查看一下所生成的数据库，你会发现，Cars 表中生成了一列，名为 OwnerPID，引用的是关联的 Person 实例的主键。加载数据时，就是通过这一列来还原两个实体之间的关系的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367389/201811/367389-20181101153251780-1054356735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Nov 2018 07:35:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<og:description>“导航属性”是实体框架用得算是比较频繁的概念。 首先，它是类型成员，其次，他是属性，这不是 F 话，而是明确它的本质。那么，什么场景下会用到导航属性呢？重点就落在“导航”一词上了，当实体 A 需要引用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/9882099.html</dc:identifier>
</item>
<item>
<title>Jmeter微信小程序接口测试 - 雪山狼</title>
<link>http://www.cnblogs.com/weimeizhizuo/p/9889526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weimeizhizuo/p/9889526.html</guid>
<description>&lt;p&gt;　　最近公司新项目组开发一款微信小程序电商平台，为了更好保证产品质量，因此提出了需要进行接口测试。&lt;/p&gt;
&lt;p&gt;从接口本身来讲，对其测试与其他项目应该是一样的。所以不难理解，我们要对小程序的接口测试需要准备的&lt;/p&gt;
&lt;p&gt;材料有：&lt;/p&gt;
&lt;p&gt;　　   1、完备的接口文档（什么是完备的接口文档，之前文章有写到，这里不再缀叙）&lt;/p&gt;
&lt;p&gt;　　   2、测试工具的选型（Jmeter/postman/或者直接撸代码？），在这里我对jmeter进行讲解&lt;/p&gt;
&lt;p&gt;　　   3、抓包工具，更好的分析数据的扭转&lt;/p&gt;
&lt;p&gt;OK，准备工作已完成，现在我们对小程序进行抓包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、打开小程序，并抓出登录接口如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图（一）&lt;/strong&gt;&lt;/span&gt;为接口调用服务器和调用地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356714/201811/1356714-20181101143309023-732874823.png&quot; alt=&quot;&quot; width=&quot;708&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图（二）&lt;/strong&gt;&lt;/span&gt;为接口请求参数和接口返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356714/201811/1356714-20181101143726968-1110060859.png&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、根据一抓出的参数将接口配置于jmeter中，如下图所示：&lt;/p&gt;
&lt;p&gt;　　2.1、jmeter请求配置，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356714/201811/1356714-20181101144526497-782537005.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：配置OK后，欣喜若狂，欢天喜地，以为万事大吉&lt;/p&gt;
&lt;p&gt;　　2.2、执行脚本查看返回结果，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356714/201811/1356714-20181101144904283-853175587.png&quot; alt=&quot;&quot; width=&quot;755&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MMP啊，一般登录接口不是放入请求参数后便能成功登录了吗？在这里通过抓包多次打开小程序发现登录接口中请求参数&lt;/p&gt;
&lt;p&gt;值（&quot;code&quot;: &quot;061xam5b2hJCfP0BNn5b2fL15b2xam5e&quot;）他她它是会变的，当然这也没毛病。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、分析并获取code值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;3.1、根据2.2中的报错信息我们可以得知，小程序的的登录接口实际上是调用微信的登录态&lt;/p&gt;
&lt;p&gt;　　3.2、code值是哪方给到我们的？（具体问题具体分析）&lt;/p&gt;
&lt;p&gt;　　　　解析：因为小程序是通过微信直接跳转进去，所以小程序的登录态实际上是直接获取微信登录状态，因此code是微信&lt;/p&gt;
&lt;p&gt;传给我方小程序&lt;/p&gt;
&lt;p&gt;　　3.3、怎么获取code值？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;3.3.1、从开发角度讲，直接去调用微信提供的api接口（这里不讲解）&lt;/p&gt;
&lt;p&gt;　　　　3.3.2、通过微信开发者工具，将code抓取出来，并填写到登录接口中，抓取code值的方法（可与开发沟通），我的&lt;/p&gt;
&lt;p&gt;方法如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356714/201811/1356714-20181101151927483-1707995698.png&quot; alt=&quot;&quot; width=&quot;779&quot; height=&quot;594&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 四、将获取的code的值放入登录请求中，从新发起请求，如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356714/201811/1356714-20181101152359854-757367856.png&quot; alt=&quot;&quot; width=&quot;816&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;


&lt;p&gt;ps:小程序的登录接口测试已掉通，可以开心进行后面的一些操作了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家进群交流：775129837&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Nov 2018 07:29:00 +0000</pubDate>
<dc:creator>雪山狼</dc:creator>
<og:description>最近公司新项目组开发一款微信小程序电商平台，为了更好保证产品质量，因此提出了需要进行接口测试。 从接口本身来讲，对其测试与其他项目应该是一样的。所以不难理解，我们要对小程序的接口测试需要准备的 材料有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weimeizhizuo/p/9889526.html</dc:identifier>
</item>
<item>
<title># 深入浅出爬虫之道： Python、Golang与GraphQuery的对比 - gomaster</title>
<link>http://www.cnblogs.com/gomaster/p/9889487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gomaster/p/9889487.html</guid>
<description>&lt;p&gt;本文将分别使用 &lt;code&gt;Python&lt;/code&gt; ，&lt;code&gt;Golang&lt;/code&gt; 以及 &lt;code&gt;GraphQuery&lt;/code&gt; 来解析某网站的 &lt;a href=&quot;http://www.58pic.com/newpic/32504070.html&quot;&gt;素材详情页面&lt;/a&gt; ，这个页面的特色是具有清晰的数据结构，但是DOM结构不够规范，无法通过单独的选择器定位页面元素，对页面的解析造成了一些曲折。通过这个页面的解析过程，深入浅出的了解爬虫的解析思想与这些语言之间的异同。&lt;/p&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在前言中，为了防止在后面的章节产生不必要的困扰，我们将会首先了解一些基本的编程理念。&lt;/p&gt;
&lt;h3 id=&quot;语义化的dom结构&quot;&gt;1. 语义化的DOM结构&lt;/h3&gt;
&lt;p&gt;这里我们讲的语义化的DOM结构，不仅仅包括 &lt;a href=&quot;https://baike.baidu.com/item/%E8%AF%AD%E4%B9%89%E5%8C%96/1811394?fr=aladdin&quot;&gt;语义化的html标签&lt;/a&gt;，也包括了语义化的选择器，在前端开发中应该注意的是，所有的动态文本都应该有单独的 html 标签包裹，并最好赋予其语义化的 &lt;code&gt;class&lt;/code&gt; 属性或 &lt;code&gt;id&lt;/code&gt; 属性，这在版本功能的迭代中，对前端和后端的开发都是大有裨益的，比如下面的HTML代码：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;main-right fr&quot;&amp;gt;
    &amp;lt;p&amp;gt;编号：32490230&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;模式：RGB&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;体积：16.659 MB&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;分辨率：72dpi&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是不够语义化的前端代码，&lt;code&gt;32504070&lt;/code&gt;，&lt;code&gt;RGB&lt;/code&gt;，&lt;code&gt;16.659 MB&lt;/code&gt;，&lt;code&gt;72dpi&lt;/code&gt;这些值都是动态属性， 会跟随编号的改变而改变，在规范的开发中，应该将这些 &lt;code&gt;动态变化的属性&lt;/code&gt;，分别用 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 这类行内标签包裹起来，并赋予其一定的语义化选择器，在上面的HTML结构中大致可以推测出这是后端直接使用 foreach 渲染出的页面，这是不符合前后端分离的思想的，如果有一天他们决定使用 &lt;code&gt;jsonp&lt;/code&gt; 或 &lt;code&gt;Ajax&lt;/code&gt; 渲染这些属性， 由前端进行渲染，工作量无疑会上一个层次。语义化的DOM结构更倾向于下面这样：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;p class=&quot;main-rightStage property-mode&quot;&amp;gt;
    模式：&amp;lt;span&amp;gt;RGB&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以将 &lt;code&gt;property-mode&lt;/code&gt; 直接作为 &lt;code&gt;span&lt;/code&gt; 的 &lt;code&gt;class&lt;/code&gt; 属性，这样这些属性无论是后端渲染，还是前端动态渲染都减轻了产品迭代产生的负担。&lt;/p&gt;
&lt;h3 id=&quot;稳定的解析代码&quot;&gt;2. 稳定的解析代码&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;语义化的DOM结构&lt;/code&gt; 之后，我们来谈谈稳定的解析代码， 对于下面的DOM结构：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;main-right fr&quot;&amp;gt;
    &amp;lt;p&amp;gt;编号：32490230&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;模式：RGB&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;体积：16.659 MB&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;分辨率：72dpi&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们想要提取 &lt;code&gt;模式&lt;/code&gt; 信息，当然可以采取下面的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选取 &lt;code&gt;class&lt;/code&gt; 属性中包含 &lt;code&gt;main-right&lt;/code&gt; 的 &lt;code&gt;div&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选取这个 &lt;code&gt;div&lt;/code&gt; 中第二个 &lt;code&gt;p&lt;/code&gt; 元素，取出其包含的文本&lt;/li&gt;
&lt;li&gt;删除文本中的 &lt;code&gt;模式：&lt;/code&gt;， 得到模式为 &lt;code&gt;RGB&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;虽然成功获取到了想要的结果，但是这样的解析方法，我们认为它是 &lt;code&gt;不稳定的&lt;/code&gt;，这个不稳定是指 &lt;strong&gt;&lt;em&gt;在其祖先元素、兄弟元素等自身以外的元素节点发生一定程度的结构改变时，导致解析错误或失败&lt;/em&gt;&lt;/strong&gt; 的情况， 比如如果有一天在 &lt;code&gt;模式&lt;/code&gt; 所在的节点之前增加了一个 &lt;code&gt;尺寸&lt;/code&gt; 的属性：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;main-right fr&quot;&amp;gt;
    &amp;lt;p&amp;gt;编号：32490230&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;尺寸：4724×6299像素&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;模式：RGB&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;体积：16.659 MB&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;main-rightStage&quot;&amp;gt;分辨率：72dpi&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们之前的解析将会发生错误（什么？你觉得不可能发生这样的变动？请对比 &lt;a href=&quot;http://www.58pic.com/newpic/32504070.html&quot;&gt;Page1&lt;/a&gt; 和 &lt;a href=&quot;http://www.58pic.com/newpic/32490230.html&quot;&gt;Page2&lt;/a&gt;）。&lt;br/&gt;那我们应该如何写出更稳定的解析代码呢，对于上面的DOM结构，我们可以有下面几种思路：&lt;br/&gt;思路一： 遍历 &lt;code&gt;class&lt;/code&gt; 属性为 &lt;code&gt;main-rightStage&lt;/code&gt;的 &lt;code&gt;p&lt;/code&gt; 节点，依次判断节点的文本是否以 &lt;code&gt;模式&lt;/code&gt; 开头， 如果是， 取出其 &lt;code&gt;：&lt;/code&gt; 后的内容，缺点是逻辑太多，不易维护且降低了代码可读性。&lt;br/&gt;思路二： 使用正则表达式 &lt;code&gt;模式：([A-Z]+)&lt;/code&gt; 进行匹配，缺点是使用不当可能造成效率问题。&lt;br/&gt;思路三： 使用 CSS选择器中的 &lt;code&gt;contains&lt;/code&gt; 方法，比如 &lt;code&gt;.main-rightStage:contains(模式)&lt;/code&gt;， 就可以选取文本中包含 &lt;code&gt;模式&lt;/code&gt;，且 &lt;code&gt;class&lt;/code&gt; 属性中包含 &lt;code&gt;main-rightStage&lt;/code&gt; 的节点了。但缺点是不同语言和不同库对这种语法的支持程度各有不同，缺乏兼容性。&lt;br/&gt;使用哪种方法，仁者见仁智者见智，不同的解析思路带来的解析的 &lt;code&gt;稳定性&lt;/code&gt;、代码的 &lt;code&gt;复杂程度&lt;/code&gt;、&lt;code&gt;运行效率&lt;/code&gt; 和 &lt;code&gt;兼容性&lt;/code&gt; 都是不同的， 开发者需要从各种因素中进行权衡， 来写出最优秀的解析代码。&lt;/p&gt;
&lt;h2 id=&quot;二进行页面的解析&quot;&gt;二、进行页面的解析&lt;/h2&gt;
&lt;p&gt;在进行页面数据的抽取之前，首先要做的是明确我们需要哪些数据、页面上提供了哪些数据，然后设计出我们需要的数据结构。首先打开 &lt;a href=&quot;http://www.58pic.com/newpic/32504070.html&quot;&gt;待解析页面&lt;/a&gt;， 由于其最上方的 &lt;code&gt;浏览量&lt;/code&gt;、&lt;code&gt;收藏量&lt;/code&gt;、&lt;code&gt;下载量&lt;/code&gt;等数据是动态加载的， 在我们的演示中暂时不需要，而这个页面右边的 &lt;code&gt;尺寸&lt;/code&gt;、&lt;code&gt;模式&lt;/code&gt; 等数据，通过上面 &lt;a href=&quot;http://www.58pic.com/newpic/32504070.html&quot;&gt;Page1&lt;/a&gt; 和 &lt;a href=&quot;http://www.58pic.com/newpic/32490230.html&quot;&gt;Page2&lt;/a&gt; 的对比，可以得知这些属性是不一定存在的，因此将它们一起归到 &lt;code&gt;metainfo&lt;/code&gt; 中。因此我们需要获得的数据如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451775/201811/1451775-20181101152215233-1710757940.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此我们可以很快设计出我们的数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    title
    pictype
    number
    type
    metadata {
        size
        volume
        mode
        resolution
    }
    author
    images []
    tags []
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;size&lt;/code&gt;、&lt;code&gt;volume&lt;/code&gt;、&lt;code&gt;mode&lt;/code&gt;、&lt;code&gt;resolution&lt;/code&gt;由于可能不存在，因此归入到了 &lt;code&gt;metadata&lt;/code&gt; 下， &lt;code&gt;images&lt;/code&gt; 是一个图片地址的数组，&lt;code&gt;tags&lt;/code&gt; 是标签数组，在确定了要提取的数据结构，就可以开始进行解析。&lt;/p&gt;
&lt;h3 id=&quot;使用python进行页面的解析&quot;&gt;使用Python进行页面的解析&lt;/h3&gt;
&lt;p&gt;Python库的数量非常庞大，有很多优秀的库可以帮助到我们，在使用Python进行页面的解析时，我们通常用到下面这些库：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供 &lt;code&gt;正则表达式&lt;/code&gt; 支持的 &lt;code&gt;re&lt;/code&gt; 库&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;CSS选择器&lt;/code&gt; 支持的 &lt;code&gt;pyquery&lt;/code&gt; 和 &lt;code&gt;beautifulsoup4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;Xpath&lt;/code&gt; 支持的 &lt;code&gt;lxml&lt;/code&gt; 库&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;JSON PATH&lt;/code&gt; 支持的 &lt;code&gt;jsonpath_rw&lt;/code&gt; 库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些库在 &lt;code&gt;Python 3&lt;/code&gt; 下获得支持的，可以通过 &lt;code&gt;pip install&lt;/code&gt; 进行安装。&lt;br/&gt;由于 &lt;code&gt;CSS选择器&lt;/code&gt; 的语法比 &lt;code&gt;Xpath&lt;/code&gt; 语法要更加简洁，而在方法的调用上，&lt;code&gt;pyquery&lt;/code&gt; 比 &lt;code&gt;beautifulsoup4&lt;/code&gt; 要更加方便，因此在 2 和 3 之间我们选择了 &lt;code&gt;pyquery&lt;/code&gt;。&lt;br/&gt;下面我们会以 &lt;code&gt;title&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 属性的获取作为例子进行讲解， 其他节点的获取是同理的。首先我们先使用 &lt;code&gt;requests&lt;/code&gt; 库下载这个页面的源文件：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from pyquery import PyQuery as pq
response = requests.get(&quot;http://www.58pic.com/newpic/32504070.html&quot;)
document = pq(response.content.decode('gb2312'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面使用Python进行的解析都将依次为前提进行。&lt;/p&gt;
&lt;h4 id=&quot;获取title节点&quot;&gt;1. 获取title节点&lt;/h4&gt;
&lt;p&gt;打开 &lt;a href=&quot;http://www.58pic.com/newpic/32504070.html&quot;&gt;待解析页面&lt;/a&gt;，在标题上右键， 点击 &lt;code&gt;查看元素&lt;/code&gt;，可以看到它的DOM结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451775/201811/1451775-20181101152227164-353751554.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们注意到， 我们想要提取出的标题文本 &lt;code&gt;大侠海报金庸武侠水墨中国风黑白&lt;/code&gt;，并没有被html标签包裹，这是不符合我们上面提到的 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/9889487.html#1-语义化的dom结构&quot;&gt;语义化的dom结构&lt;/a&gt; 的。同时，使用CSS选择器，也是无法直接选取到这个文本节点的（可以使用Xpath直接选取到，本文略）。对于这样的节点，我们可以有下面两种思路：&lt;br/&gt;&lt;code&gt;思路一&lt;/code&gt;： 先选取其父元素节点， 获取其 HTML 内容，使用正则表达式， 匹配在 &lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;p&lt;/code&gt; 之间的文本。&lt;br/&gt;&lt;code&gt;思路二&lt;/code&gt;： 先选取其父元素节点，然后删除文本节点之外的其他节点，再直接通过获取父元素节点的文本，得到想要的标题文本。&lt;br/&gt;我们采取思路二，写出下面的Python代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;title_node = document.find(&quot;.detail-title&quot;)
title_node.find(&quot;div&quot;).remove()
title_node.find(&quot;p&quot;).remove()
print(title_node.text())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果与我们期望的相同， 为 &lt;code&gt;大侠海报金庸武侠水墨中国风黑白&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;获取size节点&quot;&gt;2. 获取size节点&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;尺寸&lt;/code&gt; 上右键查看元素，可以看到下图所示的DOM结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451775/201811/1451775-20181101152249199-212387709.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现这些节点不具有语义化的选择器，并且这些属性不一定都存在（详见&lt;a href=&quot;http://www.58pic.com/newpic/32504070.html&quot;&gt;Page1&lt;/a&gt; 和 &lt;a href=&quot;http://www.58pic.com/newpic/32490230.html&quot;&gt;Page2&lt;/a&gt; 的对比）。在 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/9889487.html#2-稳定的解析代码&quot;&gt;稳定的解析代码&lt;/a&gt; 中我们也讲到了对于这种结构的文档可以采取的几种思路，这里我们采用正则解析的方法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
context = document.find(&quot;.mainRight-file&quot;).text()
file_type_matches = re.compile(&quot;尺寸：(.*?像素)&quot;).findall(context)
filetype = &quot;&quot;
if len(file_type_matches) &amp;gt; 0:
    filetype =  file_type_matches[0]
print(filetype)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于获取 &lt;code&gt;size&lt;/code&gt;、&lt;code&gt;volume&lt;/code&gt;、&lt;code&gt;mode&lt;/code&gt;、&lt;code&gt;resolution&lt;/code&gt; 这些属性，都可以采取类似的方法，因此我们可以归结出一个正则提取的函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def regex_get(text, expr):
    matches = re.compile(expr).findall(text)
    if len(matches) == 0:
        return &quot;&quot;
    return matches[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，在获取 &lt;code&gt;size&lt;/code&gt; 节点时，我们的代码就可以精简为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;size = regex_get(context, r&quot;尺寸：(.*?像素)&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;完整的python代码&quot;&gt;3. 完整的Python代码&lt;/h4&gt;
&lt;p&gt;到这里，我们解析页面可能遇到的问题就已经解决了大半，整个Python代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
import re
from pyquery import PyQuery as pq

def regex_get(text, expr):
    matches = re.compile(expr).findall(text)
    if len(matches) == 0:
        return &quot;&quot;
    return matches[0]

conseq = {}

## 下载文档
response = requests.get(&quot;http://www.58pic.com/newpic/32504070.html&quot;)
document = pq(response.text)

## 获取文件标题
title_node = document.find(&quot;.detail-title&quot;)
title_node.find(&quot;div&quot;).remove()
title_node.find(&quot;p&quot;).remove()
conseq[&quot;title&quot;] = title_node.text()

## 获取素材类型
conseq[&quot;pictype&quot;] = document.find(&quot;.pic-type&quot;).text()

## 获取文件格式
conseq[&quot;filetype&quot;] =  regex_get(document.find(&quot;.mainRight-file&quot;).text(), r&quot;文件格式：([a-z]+)&quot;)

## 获取元数据
context = document.find(&quot;.main-right p&quot;).text()
conseq['metainfo'] = {
    &quot;size&quot;: regex_get(context, r&quot;尺寸：(.*?像素)&quot;),
    &quot;volume&quot;: regex_get(context, r&quot;体积：(.*? MB)&quot;),
    &quot;mode&quot;: regex_get(context, r&quot;模式：([A-Z]+)&quot;),
    &quot;resolution&quot;: regex_get(context, r&quot;分辨率：(\d+dpi)&quot;),
}

## 获取作者
conseq['author'] = document.find('.user-name').text()

## 获取图片
conseq['images'] = []
for node_image in document.find(&quot;#show-area-height img&quot;):
    conseq['images'].append(pq(node_image).attr(&quot;src&quot;))

## 获取tag
conseq['tags'] = []
for node_image in document.find(&quot;.mainRight-tagBox .fl&quot;):
    conseq['tags'].append(pq(node_image).text())

print(conseq)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用golang进行页面的解析&quot;&gt;使用Golang进行页面的解析&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;Golang&lt;/code&gt; 中解析 &lt;code&gt;html&lt;/code&gt; 和 &lt;code&gt;xml&lt;/code&gt; 文档， 常用到的库有以下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供 &lt;code&gt;正则表达式&lt;/code&gt; 支持的 &lt;code&gt;regexp&lt;/code&gt; 库&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;CSS选择器&lt;/code&gt; 支持的 &lt;code&gt;github.com/PuerkitoBio/goquery&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;Xpath&lt;/code&gt; 支持的 &lt;code&gt;gopkg.in/xmlpath.v2&lt;/code&gt; 库&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;JSON PATH&lt;/code&gt; 支持的 &lt;code&gt;github.com/tidwall/gjson&lt;/code&gt; 库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些库，你都可以通过 &lt;code&gt;go get -u&lt;/code&gt; 来获取，由于在上面的Python解析中我们已经整理出了解析逻辑，在&lt;code&gt;Golang&lt;/code&gt;中只需要复现即可，与 &lt;code&gt;Python&lt;/code&gt; 不同的是，我们最好先为我们的数据结构定义一个 struct，像下面这样：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Reuslt struct {
    Title    string
    Pictype  string
    Number   string
    Type     string
    Metadata struct {
        Size       string
        Volume     string
        Mode       string
        Resolution string
    }
    Author string
    Images []string
    Tags   []string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，由于我们的 &lt;a&gt;待解析页面&lt;/a&gt; 是非主流的 &lt;code&gt;gbk&lt;/code&gt; 编码，所以在下载下来文档之后，需要手动将 &lt;code&gt;utf-8&lt;/code&gt; 的编码转换为 &lt;code&gt;gbk&lt;/code&gt; 的编码，这个过程虽然不在解析的范畴之内，但是也是必须要做的步骤之一， 我们使用了 &lt;code&gt;github.com/axgle/mahonia&lt;/code&gt; 这个库进行编码的转换，并整理出了编码转换的函数 &lt;code&gt;decoderConvert&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func decoderConvert(name string, body string) string {
    return mahonia.NewDecoder(&quot;gbk&quot;).ConvertString(body)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此， 最终的 &lt;code&gt;golang&lt;/code&gt; 代码应该是下面这样的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;regexp&quot;
    &quot;strings&quot;

    &quot;github.com/axgle/mahonia&quot;
    &quot;github.com/parnurzeal/gorequest&quot;

    &quot;github.com/PuerkitoBio/goquery&quot;
)

type Reuslt struct {
    Title    string
    Pictype  string
    Number   string
    Type     string
    Metadata struct {
        Size       string
        Volume     string
        Mode       string
        Resolution string
    }
    Author string
    Images []string
    Tags   []string
}

func RegexGet(text string, expr string) string {
    regex, _ := regexp.Compile(expr)
    return regex.FindString(text)
}

func decoderConvert(name string, body string) string {
    return mahonia.NewDecoder(&quot;gbk&quot;).ConvertString(body)
}

func main() {
    //下载文档
    request := gorequest.New()
    _, body, _ := request.Get(&quot;http://www.58pic.com/newpic/32504070.html&quot;).End()
    document, err := goquery.NewDocumentFromReader(strings.NewReader(decoderConvert(&quot;gbk&quot;, body)))
    if err != nil {
        panic(err)
    }
    conseq := &amp;amp;Reuslt{}
    //获取文件标题
    titleNode := document.Find(&quot;.detail-title&quot;)
    titleNode.Find(&quot;div&quot;).Remove()
    titleNode.Find(&quot;p&quot;).Remove()
    conseq.Title = titleNode.Text()

    // 获取素材类型
    conseq.Pictype = document.Find(&quot;.pic-type&quot;).Text()
    // 获取文件格式
    conseq.Type = document.Find(&quot;.mainRight-file&quot;).Text()
    // 获取元数据
    context := document.Find(&quot;.main-right p&quot;).Text()
    conseq.Metadata.Mode = RegexGet(context, `尺寸：(.*?)像素`)
    conseq.Metadata.Resolution = RegexGet(context, `体积：(.*? MB)`)
    conseq.Metadata.Size = RegexGet(context, `模式：([A-Z]+)`)
    conseq.Metadata.Volume = RegexGet(context, `分辨率：(\d+dpi)`)
    // 获取作者
    conseq.Author = document.Find(&quot;.user-name&quot;).Text()
    // 获取图片
    document.Find(&quot;#show-area-height img&quot;).Each(func(i int, element *goquery.Selection) {
        if attribute, exists := element.Attr(&quot;src&quot;); exists &amp;amp;&amp;amp; attribute != &quot;&quot; {
            conseq.Images = append(conseq.Images, attribute)
        }
    })
    // 获取tag
    document.Find(&quot;.mainRight-tagBox .fl&quot;).Each(func(i int, element *goquery.Selection) {
        conseq.Tags = append(conseq.Tags, element.Text())
    })
    bytes, _ := json.Marshal(conseq)
    log.Println(string(bytes))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析逻辑完全相同，代码量和复杂程度相较 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/3.-完整的Python代码&quot;&gt;python版&lt;/a&gt; 差不多，下面我们来看一下新出现的 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 是如何做的。&lt;/p&gt;
&lt;h3 id=&quot;使用graphquery进行解析&quot;&gt;使用GraphQuery进行解析&lt;/h3&gt;
&lt;p&gt;已知我们想要得到的数据结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    title
    pictype
    number
    type
    metadata {
        size
        volume
        mode
        resolution
    }
    author
    images []
    tags []
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 的代码是下面这样的：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;{
    title `xpath(&quot;/html/body/div[4]/div[1]/div/div/div[1]/text()&quot;)`
    pictype `css(&quot;.pic-type&quot;)`
    number `css(&quot;.detailBtn-down&quot;);attr(&quot;data-id&quot;)`
    type `regex(&quot;文件格式：([a-z]+)&quot;)`
    metadata `css(&quot;.main-right p&quot;)` {
        size `regex(&quot;尺寸：(.*?)像素&quot;)`
        volume `regex(&quot;体积：(.*? MB)&quot;)`
        mode `regex(&quot;模式：([A-Z]+)&quot;)`
        resolution `regex(&quot;分辨率：(\d+dpi)&quot;)`  
    }
    author `css(&quot;.user-name&quot;)`
    images `css(&quot;#show-area-height img&quot;)` [
        src `attr(&quot;src&quot;)`
    ]
    tags `css(&quot;.mainRight-tagBox .fl&quot;)` [
        tag `text()`
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过对比可以看出， 它只是在我们设计的数据结构之中添加了一些由反引号包裹起来的函数。惊艳的是，它能完全还原我们上面在 &lt;code&gt;Python&lt;/code&gt; 和 &lt;code&gt;Golang&lt;/code&gt; 中的解析逻辑，而且从它的语法结构上，更能清晰的读出返回的数据结构。这段 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 的执行结果如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;data&quot;: {
        &quot;author&quot;: &quot;Ice bear&quot;,
        &quot;images&quot;: [
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a0&quot;, 
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a1024&quot;, 
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a2048&quot;, 
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a3072&quot;
        ],
        &quot;metadata&quot;: {
            &quot;mode&quot;: &quot;RGB&quot;,
            &quot;resolution&quot;: &quot;200dpi&quot;,
            &quot;size&quot;: &quot;4724×6299&quot;,
            &quot;volume&quot;: &quot;196.886 MB&quot;
        },
        &quot;number&quot;: &quot;32504070&quot;,
        &quot;pictype&quot;: &quot;原创&quot;,
        &quot;tags&quot;: [&quot;大侠&quot;, &quot;海报&quot;, &quot;黑白&quot;, &quot;金庸&quot;, &quot;水墨&quot;, &quot;武侠&quot;, &quot;中国风&quot;],
        &quot;title&quot;: &quot;大侠海报金庸武侠水墨中国风黑白&quot;,
        &quot;type&quot;: &quot;psd&quot;
    },
    &quot;error&quot;: &quot;&quot;,
    &quot;timecost&quot;: 10997800
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 是一个文本查询语言，它不依赖于任何后端语言，可以被任何后端语言调用，一段 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 查询语句，在任何语言中可以得到相同的解析结果。&lt;br/&gt;它内置了 &lt;code&gt;xpath&lt;/code&gt;选择器，&lt;code&gt;css&lt;/code&gt;选择器，&lt;code&gt;jsonpath&lt;/code&gt; 选择器和 &lt;code&gt;正则表达式&lt;/code&gt; ，以及足量的文本处理函数，结构清晰易读，能够保证 &lt;code&gt;数据结构&lt;/code&gt;、&lt;code&gt;解析代码&lt;/code&gt;、&lt;code&gt;返回结果&lt;/code&gt; 结构的一致性。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7021276595745&quot;&gt;
&lt;p&gt;项目地址： &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/github.com/storyicon/graphquery&quot; class=&quot;uri&quot;&gt;github.com/storyicon/graphquery&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 的语法简洁易懂, 即使你是第一次接触它， 也能很快的上手， 它的语法设计理念之一就是 &lt;code&gt;符合直觉&lt;/code&gt;， 我们应该如何执行它呢：&lt;/p&gt;
&lt;h4 id=&quot;在golang中调用graphquery&quot;&gt;1. 在Golang中调用GraphQuery&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;golang&lt;/code&gt; 中，你只需要首先使用 &lt;code&gt;go get -u github.com/storyicon/graphquery&lt;/code&gt; 获得 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 并在代码中调用即可：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;log&quot;

    &quot;github.com/axgle/mahonia&quot;
    &quot;github.com/parnurzeal/gorequest&quot;
    &quot;github.com/storyicon/graphquery&quot;
)

func decoderConvert(name string, body string) string {
    return mahonia.NewDecoder(&quot;gbk&quot;).ConvertString(body)
}

func main() {
    request := gorequest.New()
    _, body, _ := request.Get(&quot;http://www.58pic.com/newpic/32504070.html&quot;).End()
    body = decoderConvert(&quot;gbk&quot;, body)
    response := graphquery.ParseFromString(body, &quot;{ title `xpath(\&quot;/html/body/div[4]/div[1]/div/div/div[1]/text()\&quot;)` pictype `css(\&quot;.pic-type\&quot;)` number `css(\&quot;.detailBtn-down\&quot;);attr(\&quot;data-id\&quot;)` type `regex(\&quot;文件格式：([a-z]+)\&quot;)` metadata `css(\&quot;.main-right p\&quot;)` { size `regex(\&quot;尺寸：(.*?)像素\&quot;)` volume `regex(\&quot;体积：(.*? MB)\&quot;)` mode `regex(\&quot;模式：([A-Z]+)\&quot;)` resolution `regex(\&quot;分辨率：(\\d+dpi)\&quot;)` } author `css(\&quot;.user-name\&quot;)` images `css(\&quot;#show-area-height img\&quot;)` [ src `attr(\&quot;src\&quot;)` ] tags `css(\&quot;.mainRight-tagBox .fl\&quot;)` [ tag `text()` ] }&quot;)
    log.Println(response)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 表达式以 &lt;code&gt;单行&lt;/code&gt; 的形式， 作为函数 &lt;code&gt;graphquery.ParseFromString&lt;/code&gt; 的第二个参数传入，得到的结果与预期完全相同。&lt;/p&gt;
&lt;h4 id=&quot;在python中调用graphquery&quot;&gt;2. 在Python中调用GraphQuery&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 等其他后端语言中，调用 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 需要首先启动其服务，服务已经为 &lt;code&gt;windows&lt;/code&gt;、&lt;code&gt;mac&lt;/code&gt; 和 &lt;code&gt;linux&lt;/code&gt; 编译好，到 &lt;a href=&quot;https://github.com/storyicon/graphquery-http/releases&quot;&gt;GraphQuery-http&lt;/a&gt; 中下载即可。&lt;br/&gt;在解压并启动服务后，我们就可以愉快的使用 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 在任何后端语言中对任何文档以图形的方式进行解析了。Python调用的示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests

def GraphQuery(document, expr):
    response = requests.post(&quot;http://127.0.0.1:8559&quot;, data={
        &quot;document&quot;: document,
        &quot;expression&quot;: expr,
    })
    return response.text

response = requests.get(&quot;http://www.58pic.com/newpic/32504070.html&quot;)
conseq = GraphQuery(response.text, r&quot;&quot;&quot;
    {
        title `xpath(&quot;/html/body/div[4]/div[1]/div/div/div[1]/text()&quot;)`
        pictype `css(&quot;.pic-type&quot;)`
        number `css(&quot;.detailBtn-down&quot;);attr(&quot;data-id&quot;)`
        type `regex(&quot;文件格式：([a-z]+)&quot;)`
        metadata `css(&quot;.main-right p&quot;)` {
            size `regex(&quot;尺寸：(.*?)像素&quot;)`
            volume `regex(&quot;体积：(.*? MB)&quot;)`
            mode `regex(&quot;模式：([A-Z]+)&quot;)`
            resolution `regex(&quot;分辨率：(\d+dpi)&quot;)`  
        }
        author `css(&quot;.user-name&quot;)`
        images `css(&quot;#show-area-height img&quot;)` [
            src `attr(&quot;src&quot;)`
        ]
        tags `css(&quot;.mainRight-tagBox .fl&quot;)` [
            tag `text()`
        ]
    }
&quot;&quot;&quot;)
print(conseq)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;data&quot;: {
        &quot;author&quot;: &quot;Ice bear&quot;,
        &quot;images&quot;: [
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a0&quot;, 
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a1024&quot;, 
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a2048&quot;, 
            &quot;http://pic.qiantucdn.com/58pic/32/50/40/70d58PICZfkRTfbnM2UVe_PIC2018.jpg!/fw/1024/watermark/url/L2ltYWdlcy93YXRlcm1hcmsvZGF0dS5wbmc=/repeat/true/crop/0x1024a0a3072&quot;
        ],
        &quot;metadata&quot;: {
            &quot;mode&quot;: &quot;RGB&quot;,
            &quot;resolution&quot;: &quot;200dpi&quot;,
            &quot;size&quot;: &quot;4724×6299&quot;,
            &quot;volume&quot;: &quot;196.886 MB&quot;
        },
        &quot;number&quot;: &quot;32504070&quot;,
        &quot;pictype&quot;: &quot;原创&quot;,
        &quot;tags&quot;: [&quot;大侠&quot;, &quot;海报&quot;, &quot;黑白&quot;, &quot;金庸&quot;, &quot;水墨&quot;, &quot;武侠&quot;, &quot;中国风&quot;],
        &quot;title&quot;: &quot;大侠海报金庸武侠水墨中国风黑白&quot;,
        &quot;type&quot;: &quot;psd&quot;
    },
    &quot;error&quot;: &quot;&quot;,
    &quot;timecost&quot;: 10997800
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三后记&quot;&gt;三、后记&lt;/h2&gt;
&lt;p&gt;复杂的解析逻辑带来的不仅仅是代码可读性的问题，在代码的维护和移植上也会造成很大的困扰，不同的语言和不同的库也为代码的解析结果造成了差异，&lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 是一个全新的开源项目，它的主旨就是让开发者从这些重复繁琐的解析逻辑中解脱出来，写出高可读性、高可移植性、高可维护性的代码。欢迎实践、持续关注与代码贡献，一起见证 &lt;a href=&quot;http://www.cnblogs.com/gomaster/p/(github.com/storyicon/graphquery)&quot;&gt;&lt;code&gt;GraphQuery&lt;/code&gt;&lt;/a&gt; 与开源社区的发展！&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 07:24:00 +0000</pubDate>
<dc:creator>gomaster</dc:creator>
<og:description>深入浅出爬虫之道： Python、Golang与GraphQuery的对比 本文将分别使用 ， 以及 来解析某网站的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gomaster/p/9889487.html</dc:identifier>
</item>
<item>
<title>大名鼎鼎的红黑树，你get了么？2-3树 绝对平衡 右旋转 左旋转 颜色反转 - 柳德维</title>
<link>http://www.cnblogs.com/liudw-0215/p/9887951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudw-0215/p/9887951.html</guid>
<description>&lt;h2&gt;　　前言&lt;/h2&gt;
&lt;p&gt;　　11.1新的一月加油！这个购物狂欢的季节，一看，已囊中羞涩！赶紧来恶补一下红黑树和2-3树吧!红黑树真的算是大名鼎鼎了吧？即使你不了解它，但一定听过吧？下面跟随我来揭开神秘的面纱吧！&lt;/p&gt;
&lt;h2&gt;　　一、2-3树&lt;/h2&gt;
&lt;h3&gt;　　1、抢了红黑树的光环？&lt;/h3&gt;
&lt;p&gt;　　今天的主角是红黑树，是无疑的，主角光环在呢！那2-3树又是什么鬼呢？学习2-3树不仅对理解红黑树有帮助，对理解B类树，也是有巨大帮助的，所以学习2-3树很必要！&lt;/p&gt;
&lt;h3&gt;　　2、基本性质&lt;/h3&gt;
&lt;p&gt;　　2-3树满足二分搜索树的基本性质，但节点可以存放一个元素或两个元素！如下图，就是2-3树：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101094825334-1110119815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说明：2-3树一颗绝对平衡的树（绝对平衡：对于任意一个节点，左右子树高度相同）&lt;/p&gt;
&lt;h3&gt;　　3、维护绝对平衡&lt;/h3&gt;
&lt;p&gt;　　2-3树在插入过程中如何维护绝对平衡呢？进行画图演示，实在有点不好画，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101100802466-478767323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说明：&lt;/p&gt;
&lt;h4&gt;　　1、不能将新节点插入到空节点&lt;/h4&gt;
&lt;p&gt;　　　　因为那样如上图，就不满足绝对平衡了，所以可以将37和42合并，2-3支持3节点。&lt;/p&gt;
&lt;h4&gt;　　2、不支持4节点，进行拆分&lt;/h4&gt;
&lt;p&gt;　　　　再插入12时，也不能插入空节点，也要合并，但2-3树不支持4节点，所以进行进行拆分。&lt;/p&gt;
&lt;h4&gt;　　3、子节点达到3节点，合并到父节点&lt;/h4&gt;
&lt;p&gt;　　　　再依次插入18、6，达到4节点，进行拆分，但不符合绝对平衡了怎么办？将12和37合并，就形成了最后3节点的图了&lt;/p&gt;
&lt;p&gt;　　总结：讲到这里，应该对2-3树如何维护绝对平衡，应该了解了吧？理解2-3树，对于再理解红黑树，是非常有帮助的，其实，它们有等价性的，接下来会说明的。&lt;/p&gt;
&lt;h2&gt;　　二、红黑树&lt;/h2&gt;
&lt;h3&gt;　　1、红黑树和2-3树的等价性&lt;/h3&gt;
&lt;p&gt;　　也想达到像2-3树那样的绝对平衡，但2-3树的实现比较麻烦，所以产生了红黑树；那么,红黑树和2-3树有怎么样的等价性呢？如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101104244394-1798852869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说明：红黑树最开始想用红线区别b、c，但实现起来比较困难，然后用红黑来表示节点，就比较好实现了！&lt;/p&gt;
&lt;p&gt;　　红黑树和2-3树总体对比图，可以参考一下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101104629461-1743791571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2、红黑树5个重要性质&lt;/h3&gt;
&lt;h4&gt;　　1、引自《算法导论》&lt;/h4&gt;
&lt;p&gt;　　红黑树有五个重要性质，引自算法界一本圣洁《算法导论》中的内容，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101110043169-1573794450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　是不是看着有点晕，下面我进行解释。&lt;/p&gt;
&lt;h3&gt;　　2、5个重要性质&lt;/h3&gt;
&lt;p&gt;　　1、每一个节点或者红色的，或是黑色的&lt;/p&gt;
&lt;p&gt;　　2、根节点是黑色的&lt;/p&gt;
&lt;p&gt;　　3、每一个叶子节点（最后的空节点）是黑色的&lt;/p&gt;
&lt;p&gt;　　4、如果一个节点是红色的，那么它的孩子节点都是黑色的&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　5、从任意节点到叶子节点，经过的黑色节点是一样的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　解释：最重要的性质是第五条，前4条在理解2-3树之后，就很好理解了，第5条性质说明了：&lt;span&gt;红黑树是保持“黑平衡”的二叉树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;严格意义上来说，红黑树不是平衡二叉树，最大高度：2logn，但是时间复杂度仍然是O（logn），因为2是常数，但比AVL树查询要稍微慢一些。&lt;/p&gt;
&lt;h2&gt;　　三、红黑树添加元素&lt;/h2&gt;
&lt;p&gt;　　红黑树添加元素，比较繁琐，因为要保持上面的五个性质，要不然就不是红黑树了；&lt;/p&gt;
&lt;h3&gt;　　1、保持根节点为节点&lt;/h3&gt;
&lt;p&gt;　　红黑树的节点类也可以从二分搜索树上进行修改，但要新增“color”成员变量，来标注节点颜色，节点类如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
template&amp;lt;typename Key, typename Value&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RBTree {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; RED = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; BLACK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Node {
        Key key;
        Value value;
        Node &lt;/span&gt;*&lt;span&gt;left;
        Node &lt;/span&gt;*&lt;span&gt;right;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; color;

        Node(Key key, Value value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = &lt;span&gt;this&lt;/span&gt;-&amp;gt;right =&lt;span&gt; nullptr;
            color &lt;/span&gt;=&lt;span&gt; RED;　　//默认初始化为红色
        }

        Node(Node &lt;/span&gt;*&lt;span&gt;node) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key = node-&amp;gt;&lt;span&gt;key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value = node-&amp;gt;&lt;span&gt;value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = node-&amp;gt;&lt;span&gt;left;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;right = node-&amp;gt;&lt;span&gt;right;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;color = node-&amp;gt;&lt;span&gt;color;
        }
    };

    Node &lt;/span&gt;*&lt;span&gt;root;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为红黑树性质1要求根节点为黑色，所以要保持根节点为黑色；&lt;/p&gt;
&lt;h3&gt;　　2、左旋转&lt;/h3&gt;
&lt;p&gt;　　像AVL树一样，红黑树也需要左旋和右旋，如下图就需要左旋转，因为“红色节点是左倾斜的”：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101140220371-743866320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说明：图中黑色字体标识黑色节点，红色表示红色节点，并演示了旋转过程，最后还要改变节点颜色。&lt;/p&gt;
&lt;h3&gt;　　3、左旋转代码实现&lt;/h3&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Node *leftRotate(Node *&lt;span&gt;node) {
        Node &lt;/span&gt;*x = node-&amp;gt;&lt;span&gt;right;
        node&lt;/span&gt;-&amp;gt;right = x-&amp;gt;&lt;span&gt;left;
        x&lt;/span&gt;-&amp;gt;left =&lt;span&gt; node;

        x&lt;/span&gt;-&amp;gt;color = node-&amp;gt;&lt;span&gt;color;
        node&lt;/span&gt;-&amp;gt;color =&lt;span&gt; RED;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4、颜色反转&lt;/h3&gt;
&lt;p&gt;　　下面这种情况就需要颜色反转，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101141046836-110302128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　5、颜色反转代码实现&lt;/h3&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; flipColors(Node *&lt;span&gt;node) {
        node&lt;/span&gt;-&amp;gt;color =&lt;span&gt; RED;
        node&lt;/span&gt;-&amp;gt;left-&amp;gt;color =&lt;span&gt; BLACK;
        node&lt;/span&gt;-&amp;gt;right-&amp;gt;color =&lt;span&gt; BLACK;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6、右旋转&lt;/h3&gt;
&lt;p&gt;　　下面情况需要右旋转，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101141253177-123809800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　旋转之后，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101141420473-549794270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　　7、右旋转代码如下&lt;/h3&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Node *rightRotate(Node *&lt;span&gt;node) {
        Node &lt;/span&gt;*x = node-&amp;gt;&lt;span&gt;left;
        node&lt;/span&gt;-&amp;gt;left = x-&amp;gt;&lt;span&gt;right;
        x&lt;/span&gt;-&amp;gt;right =&lt;span&gt; node;

        x&lt;/span&gt;-&amp;gt;color = node-&amp;gt;&lt;span&gt;color;
        node&lt;/span&gt;-&amp;gt;color =&lt;span&gt; RED;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　8、总体流程图&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201811/1249620-20181101142306686-612551506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　9、总体代码&lt;/h3&gt;
&lt;p&gt;　　总体代码如下，供参考和学习：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f9fc909a-8ac1-40b3-8551-bff7c4ff1a3b')&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_f9fc909a-8ac1-40b3-8551-bff7c4ff1a3b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f9fc909a-8ac1-40b3-8551-bff7c4ff1a3b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f9fc909a-8ac1-40b3-8551-bff7c4ff1a3b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f9fc909a-8ac1-40b3-8551-bff7c4ff1a3b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef RED_BLACK_TREE_RBTREE_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; RED_BLACK_TREE_RBTREE_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;vector&amp;gt;&lt;span&gt;

template&lt;/span&gt;&amp;lt;typename Key, typename Value&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RBTree {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; RED = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; BLACK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Node {
        Key key;
        Value value;
        Node &lt;/span&gt;*&lt;span&gt;left;
        Node &lt;/span&gt;*&lt;span&gt;right;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; color;

        Node(Key key, Value value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = &lt;span&gt;this&lt;/span&gt;-&amp;gt;right =&lt;span&gt; nullptr;
            color &lt;/span&gt;=&lt;span&gt; RED;
        }

        Node(Node &lt;/span&gt;*&lt;span&gt;node) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key = node-&amp;gt;&lt;span&gt;key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value = node-&amp;gt;&lt;span&gt;value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = node-&amp;gt;&lt;span&gt;left;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;right = node-&amp;gt;&lt;span&gt;right;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;color = node-&amp;gt;&lt;span&gt;color;
        }
    };

    Node &lt;/span&gt;*&lt;span&gt;root;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    RBTree() {
        root &lt;/span&gt;=&lt;span&gt; nullptr;
        size &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;~&lt;span&gt;RBTree() {
        destroy(root);
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getSize() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; size == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isRed(Node *&lt;span&gt;node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; nullptr) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BLACK;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; node-&amp;gt;&lt;span&gt;color;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(Key key, Value value) {
        root &lt;/span&gt;=&lt;span&gt; add(root, key, value);
        root&lt;/span&gt;-&amp;gt;color =&lt;span&gt; BLACK;
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; contains(Key key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getNode(root, key) !=&lt;span&gt; nullptr;
    }

    Value &lt;/span&gt;*&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Key key) {
        Node &lt;/span&gt;*node =&lt;span&gt; getNode(root, key);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; node == nullptr ? nullptr : &amp;amp;(node-&amp;gt;&lt;span&gt;value);
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(Key key, Value newValue) {
        Node &lt;/span&gt;*node =&lt;span&gt; getNode(root, key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; nullptr) {
            node&lt;/span&gt;-&amp;gt;value =&lt;span&gt; newValue;
        }
    }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向以node为根的二叉搜索树中,插入节点(key, value)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回插入新节点后的二叉搜索树的根&lt;/span&gt;
    Node *add(Node *&lt;span&gt;node, Key key, Value value) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; nullptr) {
            size&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key, value);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;&lt;span&gt;key) {
            node&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key) {
            node&lt;/span&gt;-&amp;gt;left = add(node-&amp;gt;&lt;span&gt;left, key, value);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            node&lt;/span&gt;-&amp;gt;right = add(node-&amp;gt;&lt;span&gt;right, key, value);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRed(node-&amp;gt;right) &amp;amp;&amp;amp; !isRed(node-&amp;gt;&lt;span&gt;left)) {
            node &lt;/span&gt;=&lt;span&gt; leftRotate(node);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRed(node-&amp;gt;left) &amp;amp;&amp;amp; isRed(node-&amp;gt;left-&amp;gt;&lt;span&gt;left)) {
            node &lt;/span&gt;=&lt;span&gt; rightRotate(node);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRed(node-&amp;gt;left) &amp;amp;&amp;amp; isRed(node-&amp;gt;&lt;span&gt;right)) {
            flipColors(node);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在以node为根的二叉搜索树中查找key所对应的Node&lt;/span&gt;
    Node *getNode(Node *&lt;span&gt;node, Key key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; nullptr) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;&lt;span&gt;key) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getNode(node-&amp;gt;&lt;span&gt;left, key);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getNode(node-&amp;gt;&lt;span&gt;right, key);
        }
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; destroy(Node *&lt;span&gt;node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; nullptr) {
            destroy(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            destroy(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
            &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; node;
            size&lt;/span&gt;--&lt;span&gt;;
        }
    }

    Node &lt;/span&gt;*leftRotate(Node *&lt;span&gt;node) {
        Node &lt;/span&gt;*x = node-&amp;gt;&lt;span&gt;right;
        node&lt;/span&gt;-&amp;gt;right = x-&amp;gt;&lt;span&gt;left;
        x&lt;/span&gt;-&amp;gt;left =&lt;span&gt; node;

        x&lt;/span&gt;-&amp;gt;color = node-&amp;gt;&lt;span&gt;color;
        node&lt;/span&gt;-&amp;gt;color =&lt;span&gt; RED;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
    }

    Node &lt;/span&gt;*rightRotate(Node *&lt;span&gt;node) {
        Node &lt;/span&gt;*x = node-&amp;gt;&lt;span&gt;left;
        node&lt;/span&gt;-&amp;gt;left = x-&amp;gt;&lt;span&gt;right;
        x&lt;/span&gt;-&amp;gt;right =&lt;span&gt; node;

        x&lt;/span&gt;-&amp;gt;color = node-&amp;gt;&lt;span&gt;color;
        node&lt;/span&gt;-&amp;gt;color =&lt;span&gt; RED;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; flipColors(Node *&lt;span&gt;node) {
        node&lt;/span&gt;-&amp;gt;color =&lt;span&gt; RED;
        node&lt;/span&gt;-&amp;gt;left-&amp;gt;color =&lt;span&gt; BLACK;
        node&lt;/span&gt;-&amp;gt;right-&amp;gt;color =&lt;span&gt; BLACK;
    }
};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;RED_BLACK_TREE_RBTREE_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;　　总结　　&lt;/h2&gt;
&lt;p&gt;　　面试时99.9%不会让手写一下红黑树的添加过程，除非你面试算法工程师，那就打扰了！主要理解红黑树的性质、左旋和右旋等。&lt;/p&gt;
&lt;p&gt;　　欢迎点赞和评论，感谢支持！&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 06:30:00 +0000</pubDate>
<dc:creator>柳德维</dc:creator>
<og:description>前言 11.1新的一月加油！这个购物狂欢的季节，一看，已囊中羞涩！赶紧来恶补一下红黑树和2-3树吧!红黑树真的算是大名鼎鼎了吧？即使你不了解它，但一定听过吧？下面跟随我来揭开神秘的面纱吧！ 一、2-3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudw-0215/p/9887951.html</dc:identifier>
</item>
<item>
<title>C++雾中风景番外篇2：Gtest 与 Gmock，聊聊C++的单元测试 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/9888900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/9888900.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;正式工作之后，公司对于单元测试要求比较严格。（笔者之前比较懒，一般很少写完整的单测~~）。作为一个合格的开发工程师，需要为所编写代码编写适量的&lt;strong&gt;单元测试&lt;/strong&gt;是十分必要的，在实际进行的开发工作之中，TDD（&lt;strong&gt;Test drivern development&lt;/strong&gt;) 是一种经过实践可行的开发方式。&lt;strong&gt;编写单元测试可以帮助我们在开发阶段就发现错误，并且保证新的修改没有破坏已有的程序逻辑。&lt;/strong&gt; 在 C++之中，常用的测试框架有 &lt;strong&gt;Gtest，Boost test，CPPUint&lt;/strong&gt; 等。正是由于 Gmock 的加持，让 Gtest 在多种测试框架之中脱颖而出。今天笔者在这里要和大家聊聊的就是目前我司主力在使用的&lt;strong&gt;Gtest&lt;/strong&gt;，以及配套的 &lt;strong&gt;Gmock&lt;/strong&gt;，通过两者的配合使用，相信能够搞定绝大多数的测试场景了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;gtest-的安装&quot;&gt;1.Gtest 的安装&lt;/h4&gt;
&lt;p&gt;笔者目前使用的系统是&lt;strong&gt;Deepin 15.6&lt;/strong&gt;，是基于 &lt;strong&gt;Debian jessie&lt;/strong&gt;的一款国内发行版。安装 Gtest 和 GMock 十分简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install libgtest-dev libgmock-dev &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他发行版如：&lt;strong&gt;Ubuntu，Centos&lt;/strong&gt; 应该也可以通过自带的包管理软件就可以完成安装了。但是如果包管理软件之中没有带上对应的开发包，也可以选择编译安装：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载源码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; git clone https://github.com/google/googletest&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;用 CMake 生成 Makefile之后直接 make 编译&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cd build &amp;amp;&amp;amp; cmake .. &amp;amp;&amp;amp; make -j 2&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最后进行安装&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;sudo make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后只要在/usr/include路径下找到&lt;strong&gt;gtest.h,gmock.h&lt;/strong&gt;就说明我们安装成功了。之后只需要在 CMake 之中链接对应的静态库，就可以利用 Gtest 进行单元测试了。&lt;/p&gt;
&lt;h4 id=&quot;gtest-的使用&quot;&gt;2.Gtest 的使用&lt;/h4&gt;
&lt;p&gt;Gtest 十分容易上手，通过其中的定义的宏就可以轻松实现要进行单元测试。并且其中每个单元测试都会计算出对应执行时间，可以通过执行时间来分析代码的执行效率。&lt;/p&gt;
&lt;h5 id=&quot;测试函数test&quot;&gt;测试函数TEST&lt;/h5&gt;
&lt;p&gt;先举个简单的栗子，假如现在我们需要测试一下函数来判断&lt;strong&gt;质数&lt;/strong&gt;，代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool is_prime(int num) {
    if (num &amp;lt; 2)
        return false;
    for(int i = 2; i &amp;lt;= sqrt(num) + 1; i++) {
        if (num % i == 0)
            return false;
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们用 Gtest 对这个函数进行测试，&lt;strong&gt;TEST&lt;/strong&gt;的宏定义代表了会被&lt;strong&gt;RUN_ALL_TESTS&lt;/strong&gt;执行的测试函数。在 Gtest 之中提供了两类断言&lt;strong&gt;ASSERT_*&lt;/strong&gt;系列和&lt;strong&gt;EXPECT_*&lt;/strong&gt;系列。两者的区别就在于，&lt;strong&gt;ASSERT&lt;/strong&gt; 失败之后就不会运行后续的测试了，但是 &lt;strong&gt;EXPECT&lt;/strong&gt; 虽然失败，但是不影响后续测试的进行。看起来&lt;strong&gt;EXPECT&lt;/strong&gt;会更加灵活一些，尤其是需要释放一些资源或执行一些其他逻辑时，更适合用&lt;strong&gt;EXPECT&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TEST(test_prime, is_true) {
    EXPECT_TRUE(is_prime(5));
    ASSERT_TRUE(is_prime(5));
    EXPECT_TRUE(is_prime(3));
}

TEST(test_prime, is_false) {
    ASSERT_FALSE(is_prime(4));
    EXPECT_FALSE(is_prime(4));
}

int main(int argc,char *argv[]) {
    testing::InitGoogleTest(&amp;amp;argc, argv);
    RUN_ALL_TESTS();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;testing::InitGoogleTest&lt;/strong&gt; 初始化测试框架，必须在运行测试之前调用 &lt;strong&gt;RUN_ALL_TESTS&lt;/strong&gt; 会运行所有由TEST 宏定义的测试。测试结果如下图所示：我们定义的&lt;strong&gt;is_true和 is_false同属同一个测试 case：test_prime&lt;/strong&gt;，并且成功通过了测试。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-ece09a1c16242d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;测试结果&quot;/&gt;&lt;br/&gt;上面我们使用了这TRUE 与 FALSE 的判断宏：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-86219bf31f556d81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;判断宏&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Gtest 提供了多种的判断宏，包括字符串的判断，数值判断等等，具体的细节可以参照 &lt;a href=&quot;https://github.com/google/googletest/blob/master/googletest/docs/primer.md&quot;&gt;Gtest 的官方文档&lt;/a&gt;，笔者这里不再赘述。&lt;/p&gt;
&lt;h5 id=&quot;测试函数test_f&quot;&gt;测试函数TEST_F&lt;/h5&gt;
&lt;p&gt;很多时候，我们进行一些测试的时候需要进行&lt;strong&gt;资源初始化工作，进行资源复用，最后回收资源&lt;/strong&gt;。这样的场景就适合使用 &lt;strong&gt;TEST_F&lt;/strong&gt;的宏来进行测试。&lt;strong&gt;TEST_F&lt;/strong&gt;适用于多种测试场景需要相同数据配置的情况，利用了 C++继承类来实现对父类方法的测试。举个例子，笔者实现了一个跳表，下面是对跳表进行测试的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Test_Skiplist : public testing::Test {
public:
    virtual void SetUp() {
        std::cout &amp;lt;&amp;lt; &quot;Set Up Test&quot; &amp;lt;&amp;lt; std::endl;
        _sl-&amp;gt;load();

    }
    virtual void TearDown() {
        std::cout &amp;lt;&amp;lt; &quot;Tear Down Test&quot; &amp;lt;&amp;lt; std::endl;
        _sl-&amp;gt;dump();
    }

    ~Test_Skiplist(){};

    SkipList* _sl = new SkipList();
};

TEST_F(Test_Skiplist, insert) {
    std::string test_string(&quot;happen&quot;);
    ASSERT_EQ(_sl-&amp;gt;insert(&quot;1&quot;, test_string.c_str(), test_string.size()), Status::SUCCESS);
    test_string = &quot;lee&quot;;
    ASSERT_EQ(_sl-&amp;gt;insert(&quot;2&quot;, test_string.c_str(), test_string.size()), Status::SUCCESS);

    uint64_t data64 = 50;
    ASSERT_EQ(_sl-&amp;gt;insert(&quot;50&quot;, reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;data64), 8), Status::SUCCESS);
    uint32_t data32 = 20;
    ASSERT_EQ(_sl-&amp;gt;insert(&quot;20&quot;, reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;data32), 4), Status::SUCCESS);
}

TEST_F(Test_Skiplist, search) {
    ASSERT_EQ(_sl-&amp;gt;search(&quot;1&quot;)-&amp;gt;value_size, 6);
    ASSERT_STREQ(std::string(_sl-&amp;gt;search(&quot;1&quot;)-&amp;gt;value.get()).c_str(), &quot;happen&quot;);

    ASSERT_EQ(_sl-&amp;gt;search(&quot;3&quot;), nullptr);
}

TEST_F(Test_Skiplist, remove) {
    ASSERT_EQ(_sl-&amp;gt;remove(&quot;1&quot;), Status::SUCCESS);
    ASSERT_EQ(_sl-&amp;gt;remove(&quot;1&quot;), Status::FAIL);

    ASSERT_EQ(_sl-&amp;gt;search(&quot;1&quot;), nullptr);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上述代码可以看到，通过 &lt;strong&gt;TEST_F&lt;/strong&gt;进行的测试类需要继承&lt;strong&gt;testing::Test&lt;/strong&gt;类。同时要实现对应的 &lt;strong&gt;SetUp&lt;/strong&gt;与&lt;strong&gt;TearDown&lt;/strong&gt;方法，&lt;strong&gt;SetUp&lt;/strong&gt;方式执行资源的初始化操作，而&lt;strong&gt;TearDown&lt;/strong&gt;则负责资源的释放。需要注意的是，上述代码我们测试了跳表的&lt;strong&gt;search,remove,insert&lt;/strong&gt;方法，而每个测试是&lt;strong&gt;独立的进行&lt;/strong&gt;的。也就是每个测试执行时都会运行对应的&lt;strong&gt;SetUp和 TearDown&lt;/strong&gt;方法。&lt;/p&gt;
&lt;h5 id=&quot;命令行参数&quot;&gt;命令行参数&lt;/h5&gt;
&lt;p&gt;编译生成二进制的测试执行文件之后，直接运行就可以执行单元测试了。但是 Gtest 提供了一些命令行参数来帮助我们更好的使用，下面介绍一下笔者常用的几个命令行参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;--gtest_list_tests&lt;/strong&gt;&lt;br/&gt;列出所有需要执行的测试，但是并不执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--gtest_filter&lt;/strong&gt;&lt;br/&gt;对所执行的测试进行过滤，支持通配符&lt;br/&gt;? 单个字符&lt;br/&gt;* 任意字符&lt;br/&gt;- 排除&lt;br/&gt;&lt;strong&gt;./test --gtest_filter=SkTest.*-SkTest.insert&lt;/strong&gt; 表示运行所有名为&lt;strong&gt;SkTest&lt;/strong&gt;的案例，排除了SkTest.insert这个案例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--gtest_repeat=[count]&lt;/strong&gt;&lt;br/&gt;设置测试重复运行的次数，其中-1表示无限执行。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;gmock-的使用&quot;&gt;3.Gmock 的使用&lt;/h4&gt;
&lt;p&gt;上述 Gtest 的使用应该能够满足绝大多数小型项目的测试场景了。但是对于一些涉及&lt;strong&gt;数据库交互，网络通信&lt;/strong&gt;的大型项目的测试场景，我们很难仿真一个真实的环境进行单元测试。所以这时就需要引入** Mock Objects **（模拟对象）来模拟程序的一部分来构造测试场景。Mock Object模拟了实际对象的接口，通过一些简单的代码模拟实际对象部分的逻辑，实现起来简单很多。通过 Mock object 的方式可以更好的提升项目的模块化程度，隔离不同的程序逻辑或环境。&lt;/p&gt;
&lt;p&gt;至于如何使用 Mock Object 呢？这里要引出本章的主角 Gmock 了，接下来笔者将编写一个简要的 Mock对象并进行单元测试，来展示一下 GMock 的用法。这里我们用 Gmock 模拟一个 kv 存储引擎，并运行一些简单的测试逻辑。下面的代码是我们要模拟的 kv 存储引擎的头文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef LDB_KVDB_MOCK_H
#define LDB_KVDB_MOCK_H

class KVDB {
public:
    std::string get(const std::string &amp;amp;key) const;
    Status set(const std::string &amp;amp;key, const std::string &amp;amp;value);
    Status remove(const std::string &amp;amp;key);
};
#endif //LDB_KVDB_MOCK_H&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们需要定义个 Mock 类来继承 KVDB，并且定义需要模拟的方法：&lt;strong&gt;get, set, remove&lt;/strong&gt;。这里我们用到了宏定义 &lt;strong&gt;MOCK_METHOD&lt;/strong&gt;，后面的数字代表了模拟函数的参数个数，如&lt;strong&gt;MOCK_METHOD0&lt;/strong&gt;，&lt;strong&gt;MOCK_METHOD1&lt;/strong&gt;。它接受两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数1，方法名称。&lt;/li&gt;
&lt;li&gt;参数2，函数的指针的定义&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class MockKVDB : public KVDB {
public:
    MockKVDB() {
    }
    
    MOCK_METHOD1(remove, Status(const std::string&amp;amp;));
    MOCK_METHOD2(set, Status(const std::string&amp;amp;, const std::string&amp;amp;));
    MOCK_METHOD1(get, std::string (const std::string&amp;amp;));
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个宏定义，我们已经初步模拟出对应的方法了。接下来我们需要告诉 Mock Object 被调用时的正确行为。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TEST_F(TestKVDB, setstr) {
    EXPECT_CALL(*kvdb, set(_,_)).WillRepeatedly(Return(Status::SUCCESS));

    ASSERT_EQ(kvdb-&amp;gt;set(&quot;1&quot;, &quot;happen&quot;), Status::SUCCESS);
    ASSERT_EQ(kvdb-&amp;gt;set(&quot;2&quot;, &quot;lee&quot;), Status::SUCCESS);
    ASSERT_EQ(kvdb-&amp;gt;set(&quot;happen&quot;, &quot;1&quot;), Status::SUCCESS);
    ASSERT_EQ(kvdb-&amp;gt;set(&quot;lee&quot;, &quot;2&quot;), Status::SUCCESS);
}

TEST_F(TestKVDB, getstr) {
    EXPECT_CALL(*kvdb, get(_)) \
            .WillOnce(Return(&quot;happen&quot;))
            .WillOnce(Return(&quot;lee&quot;))
            .WillOnce(Return(&quot;1&quot;))
            .WillOnce(Return(&quot;2&quot;));

    ASSERT_STREQ(kvdb-&amp;gt;get(&quot;1&quot;).c_str(), &quot;happen&quot;);
    ASSERT_STREQ(kvdb-&amp;gt;get(&quot;2&quot;).c_str(), &quot;lee&quot;);
    ASSERT_STREQ(kvdb-&amp;gt;get(&quot;happen&quot;).c_str(), &quot;1&quot;);
    ASSERT_STREQ(kvdb-&amp;gt;get(&quot;lee&quot;).c_str(), &quot;2&quot;);
}

TEST_F(TestKVDB, remove) {
    EXPECT_CALL(*kvdb, remove(_)).WillOnce(Return(Status::SUCCESS)).
            WillOnce(Return(Status::FAIL));
    EXPECT_CALL(*kvdb, get(_)) \
            .WillOnce(Return(&quot;&quot;));

    ASSERT_EQ(kvdb-&amp;gt;remove(&quot;1&quot;), Status::SUCCESS);
    ASSERT_EQ(kvdb-&amp;gt;get(&quot;1&quot;), &quot;&quot;);
    ASSERT_EQ(kvdb-&amp;gt;remove(&quot;1&quot;), Status::FAIL);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上述代码可以了解，这里通过了&lt;strong&gt;EXPECT_CALL&lt;/strong&gt;来指定 Mock Object 的对应行为，其中 &lt;strong&gt;WillOnce&lt;/strong&gt;代表调用一次返回的结果。通过&lt;strong&gt;链式调用&lt;/strong&gt;的方式，我们就可以构造出所有我们想要的模拟结果。当然如果每次调用的结果都一样，这里也可以使用&lt;strong&gt;WillRepeatedly&lt;/strong&gt;直接返回对应的结果。由上述代码可以看到，这里我们用寥寥数十行代码就模拟出了一个 KV 存储引擎，可见 Gmock 的强大。&lt;/p&gt;
&lt;p&gt;这里要注意，在通过 Gmock 来编写 Mock Object 时，能够模拟的方法是对于原抽象类之中的&lt;strong&gt;virtual&lt;/strong&gt; 方法。这个是因为 &lt;strong&gt;C++只有通过&lt;/strong&gt;virtual&lt;strong&gt;的方式才能实现子类覆写的多态，这一点在编写代码进行抽象和编写 Mock Object 的时候需要多加注意。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;4.小结&lt;/h4&gt;
&lt;p&gt;通过Gtest 与 Gmock 的使用，能够覆盖绝大多数进行 C++ 单元测试的场景，同时也减少了我们编写单元测试的工作。笔者希望通过本篇文章来抛砖引玉，希望大家多写单测。在笔者实际的工作经验之中，单测给项目带来的影响是极其正面的，一定要&lt;strong&gt;坚持写单测，坚持写单测，坚持写单测&lt;/strong&gt;~~~！！！&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 06:01:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<og:description>正式工作之后，公司对于单元测试要求比较严格。（笔者之前比较懒，一般很少写完整的单测~~）。作为一个合格的开发工程师，需要为所编写代码编写适量的 单元测试 是十分必要的，在实际进行的开发工作之中，TDD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/9888900.html</dc:identifier>
</item>
<item>
<title>【Python3爬虫】12306爬虫 - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/9883322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/9883322.html</guid>
<description>&lt;p&gt;&lt;span&gt;此次要实现的目标是登录12306网站和查看火车票信息。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;一、登录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;登录功能是通过使用selenium实现的，用到了超级鹰来识别验证码。没有超级鹰账号的先注册一个账号，充值一点题分，然后把下载这个&lt;a href=&quot;http://www.chaojiying.com/download/Chaojiying_Python.rar&quot; target=&quot;_blank&quot;&gt;Python接口&lt;/a&gt;文件，再在里面添加一个use_cjy的函数，以后使用的时候传入文件名就可以了（验证码类型和价格可以在&lt;a href=&quot;http://www.chaojiying.com/price.html&quot; target=&quot;_blank&quot;&gt;价格体系&lt;/a&gt;查看）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; use_cjy(filename):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     username = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户名&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     app_id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 软件ID&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     cjy = CJYClient(username, password, app_id)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户中心&amp;gt;&amp;gt;软件ID&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     im = open(filename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).read()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本地图片文件路径&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; cjy.PostPic(im, 9004)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 9004-&amp;gt;验证码类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后进入12306的登录页面，网址为&lt;a href=&quot;https://kyfw.12306.cn/otn/login/init&quot; target=&quot;_blank&quot;&gt;https://kyfw.12306.cn/otn/login/init&lt;/a&gt;，可以看到有一个像下面这样的验证码：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201811/1450803-20181101114836435-190982216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要破解这个验证码，第一个问题是怎么得到这个验证码图片，我们可以很轻松的找到这个验证码图片的链接，但是如果用requests去请求这个链接，然后把图片下载下来，这样得到的图片和网页上的验证码图片是不同的，因为每次请求都会刷新一次验证码。所以需要换个思路，比如先把网页截个图，然后我们可以知道验证码图片在网页中的位置，然后再根据这个位置，把截图相应的位置给截取出来，就相当于把验证码图片从整个截图中给抠出来了，这样得到的验证码图片就和网页上的验证码一样了。相关代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定位到验证码图片&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; captcha_img = browser.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;loginForm&quot;]/div/ul[2]/li[4]/div/div/div[3]/img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; location =&lt;span&gt; captcha_img.location
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; size =&lt;span&gt; captcha_img.size
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写成我们需要截取的位置坐标&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; coordinates = (int(location[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]), int(location[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                int(location[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + size[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]), int(location[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + size[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; browser.save_screenshot(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;screen.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; i = Image.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;screen.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用Image的crop函数，从截图中再次截取我们需要的区域&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; verify_code_image =&lt;span&gt; i.crop(coordinates)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; verify_code_image.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;captcha.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在已经得到了验证码图片了，下一个问题是怎么识别？点触验证码识别起来有两个难点，一个是文字识别，要把图上的鞭炮文字识别出来，第二点是识别图片中的内容，比如上图就要把有鞭炮的图片识别出来，而这两个难点利用OCR技术都很那实现，因此选择使用打码平台（比如超级鹰）来识别验证码。对于上面这个图，在使用超级鹰识别之后会返回下面这个结果：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;{'pic_id': '6048511471893900001', 'err_no': 0, 'err_str': 'OK', 'md5': 'bde1de3b886fe2019a252934874c6669', 'pic_str': '117,140'}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 其中pic_str对应的值就是有鞭炮的图片的坐标位置（如果有多个坐标，会用“|”进行分隔），我们对这个结果进行解析，把坐标提取出来，再利用selenium模拟点击就可以了，相关代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用超级鹰识别验证码&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; capture_result = use_cjy(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;captcha.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(capture_result)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对返回的结果进行解析&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; groups = capture_result.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pic_str&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; points = [[int(number) &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; group.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)] &lt;span&gt;for&lt;/span&gt; group &lt;span&gt;in&lt;/span&gt;&lt;span&gt; groups]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; point &lt;span&gt;in&lt;/span&gt;&lt;span&gt; points:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先定位到验证图片&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     element = WebDriverWait(browser, 20&lt;span&gt;).until(
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         EC.presence_of_element_located((By.CLASS_NAME, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;touclick-bgimg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟点击验证图片&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     ActionChains(browser).move_to_element_with_offset(element, point[0], point[1&lt;span&gt;]).click().perform()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     sleep(1)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;二、查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;带有车票信息的ajax接口很容易找到，格式也是标准的json格式，解析起来会方便不少&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201810/1450803-20181031204814542-608015685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是爆保存车票的字符串很复杂，我们先把第一条信息打印出来看看，以下是部分信息：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;pre&gt;
'hH0qeKPBgl0X0aCnrtZFyBgzqydzV45U2M1r%2F32FsaPHeb7Mul00sIb7y9W%2B6df1tUdDGCxqdVs8%0Aw2VodSjdXjUQ2uNdwFprKdVK9iaW60Wj2jKpNKaViR4ndlBCjsYB0SIF&lt;br/&gt;QR0pLksy7HDP0KcaoLe4%0A4RW6zRcscO7SRNJZOsF%2Fxj3Ooq76lzzdku3Uw957yjLFyf7ikixOaC%2FAOrLAwCc7y0krRpKJbSn3%0ApBsY%2F%2Fok%2Bmg2xNhXapoCPIt4w0p9',　　这段字符是随机生成的，过几秒就回失效。
 '39000D30280G',　　列车编号
 'D3028',　　车次
 'HKN',　　始发站
 'AOH',　　终点站
 'HKN',　　出发站
 'AOH',　　目的站
 '07:31',　　出发时间
 '13:06',　　到达时间
 '05:35',　　总耗时
 'Y',　　Y表示可以购票，N表示不可以
 '20181111',　　日期&lt;br/&gt;后面基本都是座位的余票信息了。
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;对于提到的列车站点代码，可以通过请求&lt;a href=&quot;https://kyfw.12306.cn/otn/resources/js/framework/station_name.js&quot; target=&quot;_blank&quot;&gt;这个&lt;/a&gt;链接，通过得到JS脚本中的station_names变量获取，对应的站点以@字符分隔，相关&lt;/span&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 请求保存列车站点代码的链接&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; res1 = requests.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://kyfw.12306.cn/otn/resources/js/framework/station_name.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把分割处理后的车站信息保存在station_data中&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; self.station_data = res1.text.lstrip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var station_names ='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).rstrip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回车站英文缩写&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_station(self, city):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.station_data:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; city &lt;span&gt;in&lt;/span&gt;&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; i.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回车站中文缩写&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_city(self, station):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.station_data:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; station &lt;span&gt;in&lt;/span&gt;&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; i.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;完整代码已上传到GitHub：&lt;a href=&quot;https://github.com/QAQ112233/12306&quot; target=&quot;_blank&quot;&gt;https://github.com/QAQ112233/12306&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Thu, 01 Nov 2018 04:50:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>此次要实现的目标是登录12306网站和查看火车票信息。 具体步骤 一、登录 登录功能是通过使用selenium实现的，用到了超级鹰来识别验证码。没有超级鹰账号的先注册一个账号，充值一点题分，然后把下载</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TM0831/p/9883322.html</dc:identifier>
</item>
<item>
<title>三叔学FPGA系列之1：Cyclone V中的时钟资源 - 最浪三叔</title>
<link>http://www.cnblogs.com/zuilangsanshu/p/9888608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuilangsanshu/p/9888608.html</guid>
<description>
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;之前的项目中更多的是有师兄提供经验和帮助，追求的是快速上手，所以不管对于硬件电路设计，还是verilog电路编程，甚至是FPGA内部的资源，都没来得及系统地学习，最近在做算法到电路的实现，正好系统学习，将感悟记于此，如有错误，欢迎指出、讨论。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、关于时钟引脚&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;FPGA芯片一般有好几组时钟引脚 CLK [0..N] [p，n]，我的理解是：&lt;strong&gt;首先&lt;/strong&gt;，时钟必须由外部晶振通过CLK引脚输入到FPGA的时钟网络，至于选用哪一组CLK，主要看FPGA哪个bank对时钟要求最为苛刻；&lt;strong&gt;其次&lt;/strong&gt;，一般用p端，n端由quartus置位三态；&lt;strong&gt;再次&lt;/strong&gt;，对于简单的系统，只有一组CLK输入作为系统主时钟，其他时钟引脚空置，或者作为某些高带载能力的时钟的输出口（是否可作为输出口，要看芯片手册）；&lt;strong&gt;然后&lt;/strong&gt;，复杂系统，可以有不同源的时钟分别从不同CLK引脚输入，只是猜想，没实践过，个人认为这样不好，因为FPGA的核心就是同步；&lt;strong&gt;另外&lt;/strong&gt;，不要把CLK引脚和全局时钟、区域时钟什么的混为一谈，一个是时钟输入引脚，一个是内部时钟走线；&lt;strong&gt;最后&lt;/strong&gt;，CLK引脚进去的走线肯定进过优化的（H型铜皮，专用的、直达每个触发器的布线资源），所以能做到小的抖动和偏斜，带载能力&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515465/201811/1515465-20181101093618972-1644564171.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;466&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1  &lt;/p&gt;
&lt;p&gt;                  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1515465/201811/1515465-20181101095008824-1021690107.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;337&quot;/&gt;图2&lt;/p&gt;
&lt;p&gt;图1所示：红圈为时钟输入引脚，当然，从时钟引脚输入的时钟必定首先进入全局时钟网络，再进一步驱动区域时钟，或者由PLL进行分/倍频==；三个黑色方框内PLL输出引脚，我的理解是：这几组引脚的布线也经过了优化，可以使PLL分/倍频后输出的时钟信号质量较好。&lt;/p&gt;
&lt;p&gt;图2所示：CLK9p作为系统唯一的外部输入时钟源，&lt;span&gt;需要注意，单端输入时，只有p端是与内部PLL相连的&lt;/span&gt;；CLK1[p，n]作为差分时钟输出引脚，由内部PLL驱动，输出作为AD时钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;二、内部时钟资源&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;全局时钟（GCLK）网络、区域时钟（RCLK）网络、外设时钟（PCLK）&lt;/strong&gt;（一般出现在集成了某些外设的FPGA中，个人理解）网络&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;全局时钟&lt;/strong&gt;：FPGA内部的专用全局时钟布线资源（图4上），具有直达每一个触发器的能力，且布线资源经过优化，时钟经过它传输后具有高扇出、最小的偏斜和抖动等。但也因为是全局布线相较于区域时钟，会有较大的插入延时（手册也这么说），而且资源较少（且用且珍惜）。&lt;span&gt;全局时钟网络：&lt;/span&gt;1）可由CLK引脚、内部PLL、高速串口（HSSI）、普通逻辑电路产生的时钟（一般不这么干）驱动；2）可驱动所有输出引脚（尤其是CLK引脚，输出作为其他芯片的基础时钟）、内部PLL、区域时钟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区域时钟&lt;/strong&gt;：只在他们自己所在的区域有效（图4下），相当于区域内的全局时钟，在区域内，具有全局时钟的优点，且插入延时比全局时钟小，布线资源也比较多。&lt;span&gt;区域时钟网络：&lt;/span&gt;1）可由CLK引脚（注意区域）、内部PLL、高速串口（HSSI）、普通逻辑电路产生的时钟（一般不这么干）驱动；2）可驱动所有输出引脚（尤其是CLK引脚，输出作为其他芯片的基础时钟）、内部PLL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外设时钟&lt;/strong&gt;：没用到，查手册。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515465/201811/1515465-20181101111128737-1585917428.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;473&quot;/&gt;图3 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1515465/201811/1515465-20181101111205521-665133937.png&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;508&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;******注意******&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常规操作：外部晶振—&amp;gt;时钟引脚—&amp;gt;PLL—&amp;gt;&lt;span&gt;区域时钟、各个模块、输出（待验证和完善，我也迷）&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;关于CLK引脚选择：不是所有的CLK引脚都可以连接到所有的全局/区域时钟网路，见图5。&lt;/li&gt;
&lt;li&gt;关于PLL：不是所有始终都可以驱动PLL，详见手册，如图6所示。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515465/201811/1515465-20181101121629504-1727600640.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;629&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515465/201811/1515465-20181101121737658-613589927.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6      &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;三、时钟资源的使用、分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;疑问：编写逻辑电路，或者布局布线时，我怎么知道某个时钟具体使用了哪种、哪个网络？以及怎么人为地控制使用具体某个网络？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续.....&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信 Alasica，欢迎讨论学习。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 04:44:00 +0000</pubDate>
<dc:creator>最浪三叔</dc:creator>
<og:description>之前的项目中更多的是有师兄提供经验和帮助，追求的是快速上手，所以不管对于硬件电路设计，还是verilog电路编程，甚至是FPGA内部的资源，都没来得及系统地学习，最近在做算法到电路的实现，正好系统学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuilangsanshu/p/9888608.html</dc:identifier>
</item>
<item>
<title>前端案例分享（一）：CSS+JS实现流星雨动画 - 低头苦读、抬头高歌</title>
<link>http://www.cnblogs.com/keepStudying/p/9886697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keepStudying/p/9886697.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;       平常会做一些有意思的小案例练手，通常都会发到codepen上，但是codepen不能写分析。&lt;/p&gt;&lt;p&gt;       所以就在博客上开个案例分享系列，对demo做个剖析。目的以分享为主，然后也希望各路大神能给出改进的想法，在review中提升技术，发现乐趣~&lt;/p&gt;
&lt;h3 id=&quot;效果图&quot;&gt;1、效果图&lt;/h3&gt;
&lt;p&gt;完整效果，请移步 &lt;a href=&quot;https://codepen.io/HaiLoongLyu/full/Lgqbzy/&quot;&gt;codepen-流星雨案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201810/1080150-20181031235706644-1683123670.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;2、源码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div id=&quot;mask&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;sky&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;moon&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;stars&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;cloud cloud-1&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;cloud cloud-2&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;cloud cloud-3&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  /* ------------reset------------ */
 
 * {
     margin: 0;
     padding: 0;
 }
 
 html,
 body {
     width: 100%;
     min-width: 1000px;
     height: 100%;
     min-height: 400px;
     overflow: hidden;
 }

 /*  ------------画布 ------------ */
 .container {
     position: relative;
     height: 100%;
 }
 /* 遮罩层 */
 
 #mask {
     position: absolute;
     width: 100%;
     height: 100%;
     background: rgba(0, 0, 0, .8);
     z-index: 900;
 }
 /* 天空背景 */
 
 #sky {
     width: 100%;
     height: 100%;
     background: linear-gradient(rgba(0, 150, 255, 1), rgba(0, 150, 255, .8), rgba(0, 150, 255, .5));
 }
 /* 月亮 */
 
 #moon {
     position: absolute;
     top: 50px;
     right: 200px;
     width: 120px;
     height: 120px;
     background: rgba(251, 255, 25, 0.938);
     border-radius: 50%;
     box-shadow: 0 0 20px rgba(251, 255, 25, 0.5);
     z-index: 9999;
 }
 /* 闪烁星星 */
 
 .blink {
     position: absolute;
     background: rgb(255, 255, 255);
     border-radius: 50%;
     box-shadow: 0 0 5px rgb(255, 255, 255);
     opacity: 0;
     z-index: 10000;
 }
 /* 流星 */
 
 .star {
     position: absolute;
     opacity: 0;
     z-index: 10000;
 }
 
 .star::after {
     content: &quot;&quot;;
     display: block;
     border: solid;
     border-width: 2px 0 2px 80px;
     /*流星随长度逐渐缩小*/
     border-color: transparent transparent transparent rgba(255, 255, 255, 1);
     border-radius: 2px 0 0 2px;
     transform: rotate(-45deg);
     transform-origin: 0 0 0;
     box-shadow: 0 0 20px rgba(255, 255, 255, .3);
 }
 /* 云 */
 
 .cloud {
     position: absolute;
     width: 100%;
     height: 100px;
 }
 
 .cloud-1 {
     bottom: -100px;
     z-index: 1000;
     opacity: 1;
     transform: scale(1.5);
     -webkit-transform: scale(1.5);
     -moz-transform: scale(1.5);
     -ms-transform: scale(1.5);
     -o-transform: scale(1.5);
 }
 
 .cloud-2 {
     left: -100px;
     bottom: -50px;
     z-index: 999;
     opacity: .5;
     transform: rotate(7deg);
     -webkit-transform: rotate(7deg);
     -moz-transform: rotate(7deg);
     -ms-transform: rotate(7deg);
     -o-transform: rotate(7deg);
 }
 
 .cloud-3 {
     left: 120px;
     bottom: -50px;
     z-index: 999;
     opacity: .1;
     transform: rotate(-10deg);
     -webkit-transform: rotate(-10deg);
     -moz-transform: rotate(-10deg);
     -ms-transform: rotate(-10deg);
     -o-transform: rotate(-10deg);
 }
 
 .circle {
     position: absolute;
     border-radius: 50%;
     background: #fff;
 }
 
 .circle-1 {
     width: 100px;
     height: 100px;
     top: -50px;
     left: 10px;
 }
 
 .circle-2 {
     width: 150px;
     height: 150px;
     top: -50px;
     left: 30px;
 }
 
 .circle-3 {
     width: 300px;
     height: 300px;
     top: -100px;
     left: 80px;
 }
 
 .circle-4 {
     width: 200px;
     height: 200px;
     top: -60px;
     left: 300px;
 }
 
 .circle-5 {
     width: 80px;
     height: 80px;
     top: -30px;
     left: 450px;
 }
 
 .circle-6 {
     width: 200px;
     height: 200px;
     top: -50px;
     left: 500px;
 }
 
 .circle-7 {
     width: 100px;
     height: 100px;
     top: -10px;
     left: 650px;
 }
 
 .circle-8 {
     width: 50px;
     height: 50px;
     top: 30px;
     left: 730px;
 }
 
 .circle-9 {
     width: 100px;
     height: 100px;
     top: 30px;
     left: 750px;
 }
 
 .circle-10 {
     width: 150px;
     height: 150px;
     top: 10px;
     left: 800px;
 }
 
 .circle-11 {
     width: 150px;
     height: 150px;
     top: -30px;
     left: 850px;
 }
 
 .circle-12 {
     width: 250px;
     height: 250px;
     top: -50px;
     left: 900px;
 }
 
 .circle-13 {
     width: 200px;
     height: 200px;
     top: -40px;
     left: 1000px;
 }
 
 .circle-14 {
     width: 300px;
     height: 300px;
     top: -70px;
     left: 1100px;
 }
 &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//流星动画
setInterval(function() {
    const obj = addChild(&quot;#sky&quot;, &quot;div&quot;, 2, &quot;star&quot;);

    for (let i = 0; i &amp;lt; obj.children.length; i++) {
        const top = -50 + Math.random() * 200 + &quot;px&quot;,
            left = 200 + Math.random() * 1200 + &quot;px&quot;,
            scale = 0.3 + Math.random() * 0.5;
        const timer = 1000 + Math.random() * 1000;

        obj.children[i].style.top = top;
        obj.children[i].style.left = left;
        obj.children[i].style.transform = `scale(${scale})`;

        requestAnimation({
            ele: obj.children[i],
            attr: [&quot;top&quot;, &quot;left&quot;, &quot;opacity&quot;],
            value: [150, -150, .8],
            time: timer,
            flag: false,
            fn: function() {
                requestAnimation({
                    ele: obj.children[i],
                    attr: [&quot;top&quot;, &quot;left&quot;, &quot;opacity&quot;],
                    value: [150, -150, 0],
                    time: timer,
                    flag: false,
                    fn: () =&amp;gt; {
                        obj.parent.removeChild(obj.children[i]);
                    }
                })
            }
        });
    }

}, 1000);

//闪烁星星动画
setInterval(function() {
    const obj = addChild(&quot;#stars&quot;, &quot;div&quot;, 2, &quot;blink&quot;);

    for (let i = 0; i &amp;lt; obj.children.length; i++) {
        const top = -50 + Math.random() * 500 + &quot;px&quot;,
            left = 200 + Math.random() * 1200 + &quot;px&quot;,
            round = 1 + Math.random() * 2 + &quot;px&quot;;
        const timer = 1000 + Math.random() * 4000;

        obj.children[i].style.top = top;
        obj.children[i].style.left = left;
        obj.children[i].style.width = round;
        obj.children[i].style.height = round;

        requestAnimation({
            ele: obj.children[i],
            attr: &quot;opacity&quot;,
            value: .5,
            time: timer,
            flag: false,
            fn: function() {
                requestAnimation({
                    ele: obj.children[i],
                    attr: &quot;opacity&quot;,
                    value: 0,
                    time: timer,
                    flag: false,
                    fn: function() {
                        obj.parent.removeChild(obj.children[i]);
                    }
                });
            }
        });
    }

}, 1000);

//月亮移动
requestAnimation({
    ele: &quot;#moon&quot;,
    attr: &quot;right&quot;,
    value: 1200,
    time: 10000000,
});


// 添加云
const clouds = addChild(&quot;.cloud&quot;, &quot;div&quot;, 14, &quot;circle&quot;, true);
for (let i = 0; i &amp;lt; clouds.children.length; i++) {
    for (let j = 0; j &amp;lt; clouds.children[i].length;) {
        clouds.children[i][j].classList.add(`circle-${++j}`);
    }
}
//云动画

let flag = 1;
setInterval(
    function() {
        const clouds = document.querySelectorAll(&quot;.cloud&quot;);
        const left = Math.random() * 5;
        bottom = Math.random() * 5;

        let timer = 0;
        for (let i = 0; i &amp;lt; clouds.length; i++) {
            requestAnimation({
                ele: clouds[i],
                attr: [&quot;left&quot;, &quot;bottom&quot;],
                value: flag % 2 ? [-left, -bottom] : [left, bottom],
                time: timer += 500,
                flag: false,
                fn: function() {
                    requestAnimation({
                        ele: clouds[i],
                        attr: [&quot;left&quot;, &quot;bottom&quot;],
                        value: flag % 2 ? [left, bottom] : [-left, -bottom],
                        time: timer,
                        flag: false
                    })
                }
            });
        }

        flag++;
    }, 2000)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;封装方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//———————————————————————————————————————————动画———————————————————————————————————————————————————
//运动动画，调用Tween.js
//ele: dom | class | id | tag  节点 | 类名 | id名 | 标签名，只支持选择一个节点，class类名以及标签名只能选择页面中第一个
//attr: attribute 属性名
//value: target value 目标值
//time: duration 持续时间
//tween: timing function 函数方程
//flag: Boolean 判断是按值移动还是按位置移动,默认按位置移动
//fn: callback 回调函数
//增加返回值: 将内部参数对象返回，可以通过设置返回对象的属性stop为true打断动画
function requestAnimation(obj) {
    //—————————————————————————————————————参数设置—————————————————————————————————————————————
    //默认属性
    const parameter = {
        ele: null,
        attr: null,
        value: null,
        time: 1000,
        tween: &quot;linear&quot;,
        flag: true,
        stop: false,
        fn: &quot;&quot;
    }

    //合并传入属性
    Object.assign(parameter, obj); //覆盖重名属性

    //—————————————————————————————————————动画设置—————————————————————————————————————————————
    //创建运动方程初始参数,方便复用
    let start = 0; //用于保存初始时间戳
    let target = (typeof parameter.ele === &quot;string&quot; ? document.querySelector(parameter.ele) : parameter.ele), //目标节点
        attr = parameter.attr, //目标属性
        beginAttr = parseFloat(getComputedStyle(target)[attr]), //attr起始值
        value = parameter.value, //运动目标值
        count = value - beginAttr, //实际运动值
        time = parameter.time, //运动持续时间,
        tween = parameter.tween, //运动函数
        flag = parameter.flag,
        callback = parameter.fn, //回调函数
        curVal = 0; //运动当前值

    //判断传入函数是否为数组，多段运动
    (function() {
        if (attr instanceof Array) {
            beginAttr = [];
            count = [];
            for (let i of attr) {
                const val = parseFloat(getComputedStyle(target)[i]);
                beginAttr.push(val);
                count.push(value - val);
            }
        }
        if (value instanceof Array) {
            for (let i in value) {
                count[i] = value[i] - beginAttr[i];
            }
        }
    })();

    //运动函数
    function animate(timestamp) {
        if (parameter.stop) return; //打断
        //存储初始时间戳
        if (!start) start = timestamp;
        //已运动时间
        let t = timestamp - start;
        //判断多段运动
        if (beginAttr instanceof Array) {
            // const len = beginAttr.length //存数组长度，复用

            //多段运动第1类——多属性，同目标，同时间/不同时间
            if (typeof count === &quot;number&quot;) { //同目标
                //同时间
                if (typeof time === &quot;number&quot;) {
                    if (t &amp;gt; time) t = time; //判断是否超出目标值

                    //循环attr，分别赋值
                    for (let i in beginAttr) {
                        if (flag) curVal = Tween[tween](t, beginAttr[i], count, time); //调用Tween，返回当前属性值,此时计算方法为移动到写入位置
                        else curVal = Tween[tween](t, beginAttr[i], count + beginAttr[i], time); //调用Tween，返回当前属性值，此时计算方法为移动了写入距离
                        if (attr[i] === &quot;opacity&quot;) target.style[attr[i]] = curVal; //给属性赋值
                        else target.style[attr[i]] = curVal + &quot;px&quot;; //给属性赋值

                        if (t &amp;lt; time) requestAnimationFrame(animate); //判断是否运动完
                        else callback &amp;amp;&amp;amp; callback(); //调用回调函数
                    }
                    return;
                }

                //不同时间
                if (time instanceof Array) {
                    //循环time，attr，分别赋值
                    for (let i in beginAttr) {
                        //错误判断
                        if (!time[i] &amp;amp;&amp;amp; time[i] !== 0) {
                            throw new Error(
                                &quot;The input time's length is not equal to attribute's length&quot;);
                        }

                        //判断是否已经完成动画，完成则跳过此次循环
                        if (parseFloat(getComputedStyle(target)[attr[i]]) === (typeof value === &quot;number&quot; ? value : value[i]))
                            continue;
                        // t = timestamp - start; //每次循环初始化t
                        if (t &amp;gt; time[i]) t = time[i]; //判断是否超出目标值

                        if (flag || attr[i] === &quot;opacity&quot;) curVal = Tween[tween](t, beginAttr[i], count, i); //调用Tween，返回当前属性值,此时计算方法为移动到写入位置
                        else curVal = Tween[tween](t, beginAttr[i], count + beginAttr[i], i); //调用Tween，返回当前属性值，此时计算方法为移动了写入距离
                        if (attr[i] === &quot;opacity&quot;) target.style[attr[i]] = curVal; //给属性赋值
                        else target.style[attr[i]] = curVal + &quot;px&quot;; //给属性赋值
                    }

                    if (t &amp;lt; Math.max(...time)) requestAnimationFrame(animate); //判断函数是否运动完
                    else callback &amp;amp;&amp;amp; callback(); //如果已经执行完时间最长的动画，则调用回调函数
                    return;
                }
            }

            //多段运动第2类——多属性，不同目标，同时间/不同时间
            if (count instanceof Array) {
                //同时间
                if (typeof time === &quot;number&quot;) {

                    if (t &amp;gt; time) t = time; //判断是否超出目标值

                    for (let i in beginAttr) { //循环attr，count，分别赋值
                        //错误判断
                        if (!count[i] &amp;amp;&amp;amp; count[i] !== 0) {
                            throw new Error(
                                &quot;The input value's length is not equal to attribute's length&quot;);
                        }

                        if (flag || attr[i] === &quot;opacity&quot;) curVal = Tween[tween](t, beginAttr[i], count[i], time); //调用Tween，返回当前属性值,此时计算方法为移动到写入位置
                        else curVal = Tween[tween](t, beginAttr[i], count[i] + beginAttr[i], time); //调用Tween，返回当前属性值，此时计算方法为移动了写入距离
                        if (attr[i] === &quot;opacity&quot;) target.style[attr[i]] = curVal; //给属性赋值
                        else target.style[attr[i]] = curVal + &quot;px&quot;; //给属性赋值
                    }

                    if (t &amp;lt; time) requestAnimationFrame(animate); //判断函数是否运动完
                    else callback &amp;amp;&amp;amp; callback(); //如果已经执行完时间最长的动画，则调用回调函数
                    return;
                }

                //不同时间
                if (time instanceof Array) {
                    for (let i in beginAttr) {
                        //错误判断
                        if (!time[i] &amp;amp;&amp;amp; time[i] !== 0) {
                            throw new Error(
                                &quot;The input time's length is not equal to attribute's length&quot;);
                        }

                        //判断是否已经完成动画，完成则跳过此次循环
                        if (parseFloat(getComputedStyle(target)[attr[i]]) === (typeof value === &quot;number&quot; ? value : value[i]))
                            continue;

                        if (t &amp;gt; time[i]) t = time[i]; //判断是否超出目标值

                        //错误判断
                        if (!count[i] &amp;amp;&amp;amp; count[i] !== 0) {
                            throw new Error(
                                &quot;The input value's length is not equal to attribute's length&quot;);
                        }

                        if (flag || attr[i] === &quot;opacity&quot;) curVal = Tween[tween](t, beginAttr[i], count[i], time[i]); //调用Tween，返回当前属性值,此时计算方法为移动到写入位置
                        else curVal = Tween[tween](t, beginAttr[i], count[i] + beginAttr[i], time[i]); //调用Tween，返回当前属性值，此时计算方法为移动了写入距离
                        if (attr[i] === &quot;opacity&quot;) target.style[attr[i]] = curVal;
                        else target.style[attr[i]] = curVal + &quot;px&quot;;
                    }

                    if (t &amp;lt; Math.max(...time)) requestAnimationFrame(animate);
                    else callback &amp;amp;&amp;amp; callback();
                    return;
                }
            }

        }

        //单运动模式
        if (t &amp;gt; time) t = time;
        if (flag || attr === &quot;opacity&quot;) curVal = Tween[tween](t, beginAttr, count, time); //调用Tween，返回当前属性值,此时计算方法为移动到写入位置
        else curVal = Tween[tween](t, beginAttr[i], count + beginAttr, time); //调用Tween，返回当前属性值，此时计算方法为移动了写入距离
        if (attr === &quot;opacity&quot;) target.style[attr] = curVal;
        else target.style[attr] = curVal + &quot;px&quot;;

        if (t &amp;lt; time) requestAnimationFrame(animate);
        else callback &amp;amp;&amp;amp; callback();

    }

    requestAnimationFrame(animate);
    return parameter; //返回对象，供打断或其他用途
}
//Tween.js
/*
 * t : time 已过时间
 * b : begin 起始值
 * c : count 总的运动值
 * d : duration 持续时间
 *
 * 曲线方程
 *
 * http://www.cnblogs.com/bluedream2009/archive/2010/06/19/1760909.html
 * */

let Tween = {
    linear: function(t, b, c, d) { //匀速
        return c * t / d + b;
    },
    easeIn: function(t, b, c, d) { //加速曲线
        return c * (t /= d) * t + b;
    },
    easeOut: function(t, b, c, d) { //减速曲线
        return -c * (t /= d) * (t - 2) + b;
    },
    easeBoth: function(t, b, c, d) { //加速减速曲线
        if ((t /= d / 2) &amp;lt; 1) {
            return c / 2 * t * t + b;
        }
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },
    easeInStrong: function(t, b, c, d) { //加加速曲线
        return c * (t /= d) * t * t * t + b;
    },
    easeOutStrong: function(t, b, c, d) { //减减速曲线
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },
    easeBothStrong: function(t, b, c, d) { //加加速减减速曲线
        if ((t /= d / 2) &amp;lt; 1) {
            return c / 2 * t * t * t * t + b;
        }
        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    },
    elasticIn: function(t, b, c, d, a, p) { //正弦衰减曲线（弹动渐入）
        if (t === 0) {
            return b;
        }
        if ((t /= d) == 1) {
            return b + c;
        }
        if (!p) {
            p = d * 0.3;
        }
        if (!a || a &amp;lt; Math.abs(c)) {
            a = c;
            var s = p / 4;
        } else {
            var s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    },
    elasticOut: function(t, b, c, d, a, p) { //正弦增强曲线（弹动渐出）
        if (t === 0) {
            return b;
        }
        if ((t /= d) == 1) {
            return b + c;
        }
        if (!p) {
            p = d * 0.3;
        }
        if (!a || a &amp;lt; Math.abs(c)) {
            a = c;
            var s = p / 4;
        } else {
            var s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
    },
    elasticBoth: function(t, b, c, d, a, p) {
        if (t === 0) {
            return b;
        }
        if ((t /= d / 2) == 2) {
            return b + c;
        }
        if (!p) {
            p = d * (0.3 * 1.5);
        }
        if (!a || a &amp;lt; Math.abs(c)) {
            a = c;
            var s = p / 4;
        } else {
            var s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        if (t &amp;lt; 1) {
            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) *
                Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        }
        return a * Math.pow(2, -10 * (t -= 1)) *
            Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
    },
    backIn: function(t, b, c, d, s) { //回退加速（回退渐入）
        if (typeof s == 'undefined') {
            s = 1.70158;
        }
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    backOut: function(t, b, c, d, s) {
        if (typeof s == 'undefined') {
            s = 3.70158; //回缩的距离
        }
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    backBoth: function(t, b, c, d, s) {
        if (typeof s == 'undefined') {
            s = 1.70158;
        }
        if ((t /= d / 2) &amp;lt; 1) {
            return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
        }
        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    },
    bounceIn: function(t, b, c, d) { //弹球减振（弹球渐出）
        return c - Tween['bounceOut'](d - t, 0, c, d) + b;
    },
    bounceOut: function(t, b, c, d) {
        if ((t /= d) &amp;lt; (1 / 2.75)) {
            return c * (7.5625 * t * t) + b;
        } else if (t &amp;lt; (2 / 2.75)) {
            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
        } else if (t &amp;lt; (2.5 / 2.75)) {
            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
        }
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    },
    bounceBoth: function(t, b, c, d) {
        if (t &amp;lt; d / 2) {
            return Tween['bounceIn'](t * 2, 0, c, d) * 0.5 + b;
        }
        return Tween['bounceOut'](t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
}


//———————————————————————————————————————————DOM操作———————————————————————————————————————————————————
// 添加节点
// ele: 父节点，支持输入变量，id值，class值，标签值。除变量外，其余值必须为字符串
// node: 添加的标签名，值为字符串
// n: 节点添加个数
// className: 节点绑定的class名，，值为字符串，多个class名用空格隔开
// boolean: 是否选中所有目标父节点。可选参数，不输入则判定为false，则只匹配选中的第一个节点
function addChild(ele, node, n, className, boolean) {
    //获取节点
    let parent = null;

    if (typeof ele !== &quot;string&quot;) parent = ele;
    else if (ele[0] === &quot;#&quot;) parent = document.getElementById(ele.slice(1));
    else if (ele[0] === &quot;.&quot;) {
        if (boolean === false) parent = document.getElementsByClassName(ele.slice(1))[0];
        else parent = document.getElementsByClassName(ele.slice(1));
    } else {
        if (boolean === false) parent = docuemnt.getElementsByTagName(ele)[0];
        else parent = document.getElementsByTagNameNS(ele);
    }

    //声明用于存储父节点及子节点的对象 
    const obj = {
        &quot;parent&quot;: parent,
        &quot;children&quot;: []
    };

    //添加节点
    if (boolean) {
        for (let i = 0; i &amp;lt; parent.length; i++) {
            //创建容器碎片
            const fragment = document.createDocumentFragment();
            //保存子节点，用于返回值
            obj.children[i] = [];

            for (let j = 0; j &amp;lt; n; j++) {
                const target = document.createElement(node);
                target.className = className;
                fragment.appendChild(target);
                //添加子节点到数组，用于返回值
                obj.children[i][j] = target;
            }

            parent[i].appendChild(fragment)
        }
    } else {
        //创建碎片容器
        const fragment = document.createDocumentFragment();

        for (let i = 0; i &amp;lt; n; i++) {
            const target = document.createElement(node);
            target.className = className;
            fragment.appendChild(target);
            //添加子节点，用于返回值
            obj.children[i] = target;
        }
        //将碎片容器一次性添加到父节点
        parent.appendChild(fragment);
    }

    //返回参数，供动画函数调用
    return obj;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;案例解析&quot;&gt;3、案例解析&lt;/h3&gt;
&lt;p&gt;       由于节点很多，并且我想尽量做得逼真有趣一点，就给节点加了随机位置。所以节点的输出都是用JS控制的，HTML这边只写了几个父元素盒子，加上相应的id名和class类名，结构相对简单。&lt;/p&gt;
&lt;p&gt;       CSS部分的难点就是流星的样式和用圈圈画云层，然后将云层堆叠出立体效果。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;首先说一下流星的样式：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;#sky .star {
     position: absolute;
     opacity: 0;
     z-index: 10000;
 }
 
 .star::after {
     content: &quot;&quot;;
     display: block;
     border: solid;
     border-width: 2px 0 2px 80px;
     /*流星随长度逐渐缩小*/
     border-color: transparent transparent transparent rgba(255, 255, 255, 1);
     border-radius: 2px 0 0 2px;
     transform: rotate(-45deg);
     transform-origin: 0 0 0;
     box-shadow: 0 0 20px rgba(255, 255, 255, .3);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       先提取了公共样式，添加定位属性；&lt;/p&gt;&lt;p&gt;       然后在star后通过after伪类添加流星，&lt;strong&gt;用border特性画：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;strong&gt;1）模型绘制：&lt;/strong&gt; &lt;strong&gt;border-width&lt;/strong&gt;的顺序为四边&lt;strong&gt;top、right、bottom、left&lt;/strong&gt;，同理&lt;strong&gt;border-color&lt;/strong&gt;的顺序也为四边&lt;strong&gt;top、right、bottom、left&lt;/strong&gt;。这样将border-width与border-color一一对应后，就能看出&lt;strong&gt;2px是流星的宽度，80px是流星的长度，而0px就是流星的尾巴&lt;/strong&gt;。这样就形成了一个&lt;strong&gt;头部2px宽，尾部0px，长度80px的流星模型&lt;/strong&gt;;&lt;/p&gt;&lt;p&gt;       &lt;strong&gt;2）稍微逼真：&lt;/strong&gt; 通过&lt;strong&gt;border-radius&lt;/strong&gt;给流星的头部增加个圆角，让它看起来emmmmmmm更逼真？最后通过&lt;strong&gt;roteta&lt;/strong&gt;旋转一个角度，让它看起来像是往下掉;&lt;/p&gt;&lt;p&gt;       &lt;strong&gt;3）增加闪光：&lt;/strong&gt; 通过&lt;strong&gt;box-shadow&lt;/strong&gt; 给流星增加一点光晕，让它看起来有闪光的效果;&lt;/p&gt;&lt;p&gt;       通过以上3步，一个流星就画好了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;然后是画云：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;因为云的代码比较长，这里就不贴出来了。方法无非是通过一个一个的圆，相互叠加覆盖，完成一个云朵的形状;
完成一个云层之后，copy一个，然后多个云层通过rotate、opacity、left定位等，做出一个渐隐叠加的立体效果;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;JS部分以流星举例说明&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setInterval(function() {
    const obj = addChild(&quot;#sky&quot;, &quot;div&quot;, 2, &quot;star&quot;); //插入流星

    for (let i = 0; i &amp;lt; obj.children.length; i++) {
        //随机位置
        const top = -50 + Math.random() * 200 + &quot;px&quot;,
            left = 200 + Math.random() * 1200 + &quot;px&quot;,
            scale = 0.3 + Math.random() * 0.5;
        const timer = 1000 + Math.random() * 1000;

        obj.children[i].style.top = top;
        obj.children[i].style.left = left;
        obj.children[i].style.transform = `scale(${scale})`;
        
        //添加动画
        requestAnimation({
            ele: obj.children[i],
            attr: [&quot;top&quot;, &quot;left&quot;, &quot;opacity&quot;],
            value: [150, -150, .8],
            time: timer,
            flag: false,
            fn: function() {
                requestAnimation({
                    ele: obj.children[i],
                    attr: [&quot;top&quot;, &quot;left&quot;, &quot;opacity&quot;],
                    value: [150, -150, 0],
                    time: timer,
                    flag: false,
                    fn: () =&amp;gt; {
                        obj.parent.removeChild(obj.children[i]); //动画结束删除节点
                    }
                })
            }
        });
    }

}, 1000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       这里边用到了我自己封装的&lt;strong&gt;两个方法&lt;/strong&gt;，一个是基于requestAnimationFrame的&lt;strong&gt;requestAnimation&lt;/strong&gt;，以及基于appendChild的&lt;strong&gt;addChild&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;       为了达成星星位置随机的效果，通过定时器setInterval不停的&lt;strong&gt;插入&lt;/strong&gt;与&lt;strong&gt;删除&lt;/strong&gt;流星：&lt;/p&gt;&lt;p&gt;       &lt;strong&gt;首先&lt;/strong&gt;，每次添加&lt;strong&gt;2个流星&lt;/strong&gt;到页面，但是&lt;strong&gt;定时器的间隔时间小于流星的动画时间&lt;/strong&gt;，这样就能保证页面中的流星的数量不是一个固定值，但肯定是大于2的。不然一次2个流星略显冷清;&lt;/p&gt;&lt;p&gt;       &lt;strong&gt;然后&lt;/strong&gt;，通过for循环（也可以用for-in，for-of，都行。for-of最简单）给每个新添加到页面中的流星一个随机的位置（top、left）、随机的大小（scale）、随机的动画执行时间（timer）;&lt;br/&gt;       &lt;strong&gt;最后&lt;/strong&gt;，在for循环中，给每个新添加到页面中的流星加上动画，并通过回调函数在执行完动画后删除节点。这里要注意的是，动画要分成&lt;strong&gt;两个阶段&lt;/strong&gt;（&lt;strong&gt;出现&lt;/strong&gt;与&lt;strong&gt;消失&lt;/strong&gt;，主要是&lt;strong&gt;opacity&lt;/strong&gt;控制）。另外我这里的处理，每个流星都移动相同的距离&lt;strong&gt;300px&lt;/strong&gt;，这个距离我觉得也可以通过随机数控制，但我犯了个懒，就没有做。&lt;/p&gt;
&lt;h3 id=&quot;小问题&quot;&gt;4、小问题&lt;/h3&gt;
&lt;p&gt;       目前我发现的问题有&lt;strong&gt;2个：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       一是DOM操作本身的问题。页面不停的添加与删除节点，造成不停地&lt;strong&gt;回流与重绘&lt;/strong&gt;，很耗性能;&lt;br/&gt;       二是requestAnimationFrame本身的问题。因为定时器不断在添加节点，而requestAnimationFrame的特性——&lt;strong&gt;当离开当前页面去浏览其他页面时，动画会暂停&lt;/strong&gt;。这就造成了一个问题，&lt;strong&gt;节点一直在加，但动画全停在那没有执行&lt;/strong&gt;。那么下次再回到这个页面的时候，就boom!！！动画就炸了，你会看到画面一卡，很多小蝌蚪集体出动去找妈妈;&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;5、结语&lt;/h3&gt;
&lt;p&gt;       这个小案例虽然从难度上来看很简单，但是它可拓展性很高——比如表个白啊、寄个相思、耍个浪漫啊等等（手动狗头doge），而且用纯CSS也可以实现（我也写了一版纯CSS的，因为不能随机位置随机大小，所以看起来比较静态一点，就不贴了）。所以对于了解CSS动画与JS动画，是个很不错的练手小案例。&lt;/p&gt;&lt;p&gt;       感谢看完这篇文章的可爱的人儿，希望你能从中获得灵感~如果能给你带来帮助，那我是极高兴地~如果你把灵感告诉我，那我就can't happniess anymore了~&lt;/p&gt;&lt;p&gt;       最后，再次感谢，如果有优化写法，欢迎指导~&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 03:57:00 +0000</pubDate>
<dc:creator>低头苦读、抬头高歌</dc:creator>
<og:description>[toc] 引言        平常会做一些有意思的小案例练手，通常都会发到codepen上，但是codepen不能写分析。 &amp;n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keepStudying/p/9886697.html</dc:identifier>
</item>
<item>
<title>ionic4+angular6 混合移动开发 capacitor cordova - huangenai</title>
<link>http://www.cnblogs.com/huangenai/p/9886721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangenai/p/9886721.html</guid>
<description>&lt;p&gt;首先要更新或者安装 ionic cli&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install -g ionic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ionic start ionic-angular tabs --type=angular
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  –type=angular 是需要多加的参数，现在官方只集成好了angualr 或许以后就会有 --type=vue  or --type=react 呢&lt;/p&gt;
&lt;p&gt;新建好项目后你会发现，与ionic2 ionic3项目 它的目录结构变了。在ionic4 ，已更改为遵循每个受支持框架的建议设置。例如，如果某个应用程序正在使用Angular，那么该项目结构将与Angular CLI应用程序完全相同。&lt;/p&gt;
&lt;p&gt;这是新建好后的目录结构，有angular项目经验的开发人员来说，这应该非常熟悉。&lt;/p&gt;
&lt;p&gt;命令跑起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开 http://localhost:4200&lt;/p&gt;

&lt;p&gt;图一项目结构&lt;/p&gt;
&lt;p&gt;图二跑起来在浏览器的效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/833855/201810/833855-20181031215422819-655668800.png&quot; alt=&quot;&quot; width=&quot;141&quot; height=&quot;428&quot;/&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/blog/833855/201810/833855-20181031220112018-1455771947.png&quot; alt=&quot;&quot; width=&quot;254&quot; height=&quot;426&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文不会详细介绍如何配置android java 环境，&lt;/p&gt;
&lt;p&gt;不会详细介绍如何配置ios appid以及签名等，&lt;/p&gt;
&lt;p&gt;在看下面内容前，可能你需要有懂得 使用cordova 打包移动应用程序。&lt;/p&gt;
&lt;p&gt;android 环境以及 cordova 相关知识请翻我的以前等文章，这里就不详细说明了。&lt;/p&gt;

&lt;h3&gt;使用 cordova 构建移动应用程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/833855/201810/833855-20181031230416174-11849243.jpg&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只展示打包ios ipa&lt;/p&gt;
&lt;p&gt;首先&lt;span&gt;打开&lt;/span&gt;&lt;code&gt;config.xml&lt;/code&gt;&lt;span&gt;文件并修改&lt;/span&gt;&lt;code&gt;id，id即为你ios开发者中心中的 appid&lt;/code&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ionic build&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;bash&quot;&gt;ionic cordova prepare ios&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;xcode打开MyApp.xcodeproj， &lt;/p&gt;
&lt;p&gt;选择开发团队自动签名后，手机连接电脑，xcode直接运行安装完成，打开app 看效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/833855/201810/833855-20181031224140923-1515399883.png&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;使用 Capacitor 构建移动应用程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/833855/201810/833855-20181031230610068-2038251806.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;83&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建的项目确保能够跑起来后，比如说我项目已经添加了 cordova 就不能再使用Capacitor构建了。&lt;/p&gt;

&lt;p&gt;这里展示的是如何打包android apk&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先，你&lt;/span&gt;&lt;span&gt;必须安装&lt;/span&gt;&lt;/span&gt;Java 8 JDK&lt;span&gt;并将其设置为默认 ，切记&lt;/span&gt;&lt;span&gt;&lt;span&gt;Java 9目前&lt;/span&gt;&lt;/span&gt;&lt;em&gt;无法运行&lt;/em&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Android开发需要&lt;/span&gt;&lt;span&gt;安装&lt;/span&gt;&lt;a href=&quot;https://developer.android.com/studio/index.html&quot;&gt;&lt;span&gt;Android Studio&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;Android SDK&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Android Studio不是必需的，可以仅使用Android CLI工具构建和运行应用程序，但用android studio 它将使构建和运行应用程序变得更加容，所以官方是强烈建议安装的。当前&lt;/span&gt;&lt;/span&gt;Capacitor团队的目标是API21或更高，即Android 5.0（Lollipop）或更高版本。所以捏，意思是不支持4的咯，所以使用Capacitor的，要注意了。此外，Capacitor还需要安装Chrome版本50或更高版本的Android WebView。 &lt;/p&gt;
&lt;p&gt;终端执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
ionic build &lt;p&gt;ionic capacitor add android
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开android studio，你要等待一会，android studio 会同步并更新Gradle。。 更新后，变可以编译或者跑在模拟器或者手机上。&lt;/p&gt;

&lt;p&gt;这里是展示如何打包ios ipa&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ionic build 
 
ionic capacitor add ios&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用capacitor打包ios ipa的时候出现了很多问题。&lt;/p&gt;
&lt;p&gt;可能出现的问题：&lt;/p&gt;
&lt;p&gt;问题一&lt;/p&gt;
&lt;p&gt;cocoapods is not installed&lt;/p&gt;
&lt;p&gt;在capacitor官网有介绍到需要&lt;a href=&quot;https://nodejs.org/&quot;&gt;&lt;span&gt;&lt;span&gt;Node v8.6.0&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;或更高版本&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，以及&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;NPM 5.6.0+版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而且在&lt;span&gt;&lt;span&gt;对于构建iOS应用程序，Capacitor需要&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;具有Xcode 9或更高版本&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Mac。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/833855/201810/833855-20181031231001141-70749184.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;安装cocoapods，并且要更新本地存储库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo gem install cocoapods&lt;br/&gt;pod repo update
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题二&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
✔ Installing iOS dependencies &lt;span&gt;in&lt;/span&gt; 15&lt;span&gt;.36s
✔ Adding native xcode project &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;: /Users/huangenai/Desktop/test/ionic-angular/ios &lt;span&gt;in&lt;/span&gt; 221&lt;span&gt;.25ms
✔ add &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 15&lt;span&gt;.58s
✔ Copying web assets from www to ios&lt;/span&gt;/App/public &lt;span&gt;in&lt;/span&gt; 830&lt;span&gt;.41ms
✔ Copying native bridge &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 1&lt;span&gt;.47ms
✔ Copying capacitor.config.json &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 4&lt;span&gt;.50ms
✔ copy &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 849&lt;span&gt;.44ms
✔ Updating iOS plugins &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 5&lt;span&gt;.48ms
  Found &lt;/span&gt;0 Capacitor plugins &lt;span&gt;for&lt;/span&gt;&lt;span&gt; ios:
✖ Updating iOS native dependencies: 
✖ update ios: 
[error] Analyzing dependencies
Fetching podspec &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; `Capacitor` from `../../node_modules/@capacitor/&lt;span&gt;ios`
Fetching podspec &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; `CapacitorCordova` from `../../node_modules/@capacitor/&lt;span&gt;ios`
[&lt;/span&gt;!] Unable to find a specification &lt;span&gt;for&lt;/span&gt; `GCDWebServer (~&amp;gt; 3.0&lt;span&gt;)` depended upon by `Capacitor`

[ERROR] An error occurred &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; running subprocess capacitor.
        
        capacitor add ios exited &lt;/span&gt;&lt;span&gt;with&lt;/span&gt; exit code 1&lt;span&gt;.&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 问题原因：我一开始没看清楚需要更新本地库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pod repo update
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是在更新本地库的时候出现问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
fatal: 有歧义的参数 'HEAD'&lt;span&gt;：未知的版本或路径不存在于工作区中。
使用 &lt;/span&gt;'--'&lt;span&gt; 来分隔版本和路径，例如：
&lt;/span&gt;'git &amp;lt;命令&amp;gt; [&amp;lt;版本&amp;gt;...] -- [&amp;lt;文件&amp;gt;...]'&lt;span&gt;
Updating spec repo `master`
fatal: 有歧义的参数 &lt;/span&gt;'HEAD'&lt;span&gt;：未知的版本或路径不存在于工作区中。
使用 &lt;/span&gt;'--'&lt;span&gt; 来分隔版本和路径，例如：
&lt;/span&gt;'git &amp;lt;命令&amp;gt; [&amp;lt;版本&amp;gt;...] -- [&amp;lt;文件&amp;gt;...]'&lt;span&gt;
fatal: 有歧义的参数 &lt;/span&gt;'HEAD'&lt;span&gt;：未知的版本或路径不存在于工作区中。
使用 &lt;/span&gt;'--'&lt;span&gt; 来分隔版本和路径，例如：
&lt;/span&gt;'git &amp;lt;命令&amp;gt; [&amp;lt;版本&amp;gt;...] -- [&amp;lt;文件&amp;gt;...]'&lt;span&gt;
  $ &lt;/span&gt;/usr/local/bin/git -C /Users/huangenai/.cocoapods/repos/master fetch origin
  --&lt;span&gt;progress
  remote: Enumerating objects: &lt;/span&gt;127&lt;span&gt;, done.        
  remote: Counting objects: &lt;/span&gt;100% (127/127), done.        
  remote: Compressing objects: 100% (91/91), done.        
  remote: Total 2561792 (delta 55), reused 35 (delta 35), pack-reused 2561665&lt;span&gt;        
  接收对象中: &lt;/span&gt;100% (2561792/2561792), 585.57 MiB | 2.17 MiB/&lt;span&gt;s, 完成.
  处理 delta 中: &lt;/span&gt;100% (1501235/1501235), 完成.
  来自 https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/CocoaPods/Specs&lt;/span&gt;
   * [新分支]          backz                 -&amp;gt; origin/backz
   * [新分支]          master                -&amp;gt; origin/master
   * [新分支]          predates_sharding_branch -&amp;gt; origin/predates_sharding_branch
   * [新分支]          swift_version_support -&amp;gt; origin/swift_version_support
   * [新标签]          v0.32.1               -&amp;gt; v0.32.1
   * [新标签]                  20161019              -&amp;gt; 20161019&lt;span&gt;
  $ &lt;/span&gt;/usr/local/bin/git -C /Users/huangenai/.cocoapods/repos/master rev-parse
  --abbrev-&lt;span&gt;ref HEAD
  fatal: 有歧义的参数 &lt;/span&gt;'HEAD'&lt;span&gt;：未知的版本或路径不存在于工作区中。
  HEAD
  使用 &lt;/span&gt;'--'&lt;span&gt; 来分隔版本和路径，例如：
  &lt;/span&gt;'git &amp;lt;命令&amp;gt; [&amp;lt;版本&amp;gt;...] -- [&amp;lt;文件&amp;gt;...]'&lt;span&gt;
[&lt;/span&gt;!] CocoaPods was not able to update the `master` repo. If &lt;span&gt;this&lt;/span&gt; is an unexpected issue and persists you can inspect it running `pod repo update --verbose`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;p&gt;首先我们将源改为国内的地址&lt;/p&gt;
&lt;p&gt;ps：网上介绍的都是用淘宝的源，一开始我也是设置淘宝的源，一直报错。原因是中国的ruby镜像交由社区来维护了，一开始是重定向到&lt;a href=&quot;http://gems.ruby-china.org/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://gems.ruby-china.org/&lt;/a&gt;，后来社区域名改了 最终ruby的镜像地址是 这个&lt;span&gt;https://gems.ruby-china.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Error fetching https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ruby.taobao.org/: bad response Not Found 404 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以先去掉默认的源设置为国内社区维护的源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去掉默认更新源&lt;/span&gt;
$ gem sources --remove https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rubygems.org/  &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;使用国内社区维护的源&lt;/span&gt;
$ gem sources -a https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gems.ruby-china.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再更新本地库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pod repo update
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新完本地库后， &lt;span&gt;Unable to find a specification&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;`GCDWebServer (~&amp;gt; 3.0&lt;/span&gt;&lt;span&gt;)` depended upon by `Capacitor` &lt;/span&gt;&lt;span&gt;这个问题算是解决了 。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;问题三&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;✖ update ios:
[error] Analyzing dependencies
Fetching podspec &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; `Capacitor` from `../../node_modules/@capacitor/&lt;span&gt;ios`
Fetching podspec &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; `CapacitorCordova` from `../../node_modules/@capacitor/&lt;span&gt;ios`
Downloading dependencies
Installing Capacitor &lt;/span&gt;1.0.0-beta.7 (was 0.0.99&lt;span&gt;)
Installing CapacitorCordova &lt;/span&gt;1.0.0-beta.7 (was 0.0.99&lt;span&gt;)
Using GCDWebServer (&lt;/span&gt;3.4.2&lt;span&gt;)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete&lt;/span&gt;! There are 2 dependencies from the Podfile and 3&lt;span&gt; total pods installed.
xcode&lt;/span&gt;-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools'&lt;span&gt; is a command line tools instance

[ERROR] An error occurred &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; running subprocess capacitor.

        capacitor add ios exited &lt;/span&gt;&lt;span&gt;with&lt;/span&gt; exit code 1&lt;span&gt;.

        Re&lt;/span&gt;-running &lt;span&gt;this&lt;/span&gt; command &lt;span&gt;with&lt;/span&gt; the --verbose flag may provide more information.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方案： 安装xcode 命令行工具&lt;/p&gt;
&lt;p&gt;详细请看 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huangenai/p/9887821.html&quot;&gt;Xcode 命令行工具 Command Line Tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;问题四&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[error] &quot;ios&quot;&lt;span&gt; platform already exists.
    To add a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &quot;ios&quot; platform, please remove &quot;/Users/huangenai/Desktop/test/ionic-angular/ios&quot; and run &lt;span&gt;this&lt;/span&gt;&lt;span&gt; command again.
    WARNING&lt;/span&gt;!&lt;span&gt; your native IDE project will be completely removed.
[ERROR] An error occurred &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; running subprocess capacitor.

        capacitor add ios exited &lt;/span&gt;&lt;span&gt;with&lt;/span&gt; exit code 1&lt;span&gt;.

        Re&lt;/span&gt;-running &lt;span&gt;this&lt;/span&gt; command &lt;span&gt;with&lt;/span&gt; the --verbose flag may provide more information.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;移除项目下的ios即可，再从新执行ionic capacitor add ios。&lt;/p&gt;

&lt;p&gt;漂亮终于终于解决了层层问题后可以了，接下来就简单了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
//打开xcode&lt;br/&gt;ionic capacitor run ios
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接上手机，选择开发团队，自动签名后，run便直接运行在手机上了。&lt;/p&gt;
&lt;p&gt;切记找到文件capacitor.config.json，appId 要改成你自己在开发者中心添加的的appid。&lt;/p&gt;

&lt;p&gt;下图为android 模拟器跑起来效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/833855/201811/833855-20181101010658787-338411528.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;


&lt;p&gt;使用Capacitor构建移动应用，出现以上问题，很大原因是我没有完完全全的去了解并安装好Capacitor。&lt;/p&gt;
&lt;p&gt;你需要了解Capacitor。详细请看官方文档 https://capacitor.ionicframework.com&lt;/p&gt;

&lt;p&gt;此随笔乃本人学习工作记录，如有疑问欢迎在下面评论，转载请标明出处。&lt;/p&gt;
&lt;p&gt;如果对您有帮助请动动鼠标右下方给我来个赞，您的支持是我最大的动力。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 03:46:00 +0000</pubDate>
<dc:creator>huangenai</dc:creator>
<og:description>首先要更新或者安装 ionic cli 创建项目 –type=angular 是需要多加的参数，现在官方只集成好了angualr 或许以后就会有 --type=vue or --type=r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangenai/p/9886721.html</dc:identifier>
</item>
</channel>
</rss>